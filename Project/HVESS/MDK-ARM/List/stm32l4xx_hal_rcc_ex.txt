; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_rcc_ex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_rcc_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_CRSConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSConfig PROC
;;;2596     */
;;;2597   void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
000000  4910              LDR      r1,|L1.68|
;;;2598   {
;;;2599     uint32_t value;  /* no init needed */
;;;2600   
;;;2601     /* Check the parameters */
;;;2602     assert_param(IS_RCC_CRS_SYNC_DIV(pInit->Prescaler));
;;;2603     assert_param(IS_RCC_CRS_SYNC_SOURCE(pInit->Source));
;;;2604     assert_param(IS_RCC_CRS_SYNC_POLARITY(pInit->Polarity));
;;;2605     assert_param(IS_RCC_CRS_RELOADVALUE(pInit->ReloadValue));
;;;2606     assert_param(IS_RCC_CRS_ERRORLIMIT(pInit->ErrorLimitValue));
;;;2607     assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));
;;;2608   
;;;2609     /* CONFIGURATION */
;;;2610   
;;;2611     /* Before configuration, reset CRS registers to their default values*/
;;;2612     __HAL_RCC_CRS_FORCE_RESET();
000002  6b8a              LDR      r2,[r1,#0x38]
000004  f0427280          ORR      r2,r2,#0x1000000
000008  638a              STR      r2,[r1,#0x38]
;;;2613     __HAL_RCC_CRS_RELEASE_RESET();
00000a  6b8a              LDR      r2,[r1,#0x38]
00000c  f0227280          BIC      r2,r2,#0x1000000
000010  638a              STR      r2,[r1,#0x38]
;;;2614   
;;;2615     /* Set the SYNCDIV[2:0] bits according to Prescaler value */
;;;2616     /* Set the SYNCSRC[1:0] bits according to Source value */
;;;2617     /* Set the SYNCSPOL bit according to Polarity value */
;;;2618     value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
000012  e9d01200          LDRD     r1,r2,[r0,#0]
000016  4311              ORRS     r1,r1,r2
000018  6882              LDR      r2,[r0,#8]
00001a  4311              ORRS     r1,r1,r2
;;;2619     /* Set the RELOAD[15:0] bits according to ReloadValue value */
;;;2620     value |= pInit->ReloadValue;
00001c  68c2              LDR      r2,[r0,#0xc]
00001e  430a              ORRS     r2,r2,r1
;;;2621     /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
;;;2622     value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
000020  8a01              LDRH     r1,[r0,#0x10]
000022  ea424201          ORR      r2,r2,r1,LSL #16
;;;2623     WRITE_REG(CRS->CFGR, value);
000026  4908              LDR      r1,|L1.72|
000028  604a              STR      r2,[r1,#4]
;;;2624   
;;;2625     /* Adjust HSI48 oscillator smooth trimming */
;;;2626     /* Set the TRIM[6:0] bits for STM32L412xx/L422xx or TRIM[5:0] bits otherwise
;;;2627        according to RCC_CRS_HSI48CalibrationValue value */
;;;2628     MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
00002a  680a              LDR      r2,[r1,#0]
00002c  6940              LDR      r0,[r0,#0x14]
00002e  f422527c          BIC      r2,r2,#0x3f00
000032  ea422000          ORR      r0,r2,r0,LSL #8
000036  6008              STR      r0,[r1,#0]
;;;2629   
;;;2630     /* START AUTOMATIC SYNCHRONIZATION*/
;;;2631   
;;;2632     /* Enable Automatic trimming & Frequency error counter */
;;;2633     SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
000038  6808              LDR      r0,[r1,#0]
00003a  f0400060          ORR      r0,r0,#0x60
00003e  6008              STR      r0,[r1,#0]
;;;2634   }
000040  4770              BX       lr
;;;2635   
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x40021000
                  |L1.72|
                          DCD      0x40006000

                          AREA ||i.HAL_RCCEx_CRSGetSynchronizationInfo||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSGetSynchronizationInfo PROC
;;;2649     */
;;;2650   void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
000000  4907              LDR      r1,|L2.32|
;;;2651   {
;;;2652     /* Check the parameter */
;;;2653     assert_param(pSynchroInfo != (void *)NULL);
;;;2654   
;;;2655     /* Get the reload value */
;;;2656     pSynchroInfo->ReloadValue = (READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
000002  684a              LDR      r2,[r1,#4]
000004  b292              UXTH     r2,r2
000006  6002              STR      r2,[r0,#0]
;;;2657   
;;;2658     /* Get HSI48 oscillator smooth trimming */
;;;2659     pSynchroInfo->HSI48CalibrationValue = (READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
000008  680a              LDR      r2,[r1,#0]
00000a  f3c22205          UBFX     r2,r2,#8,#6
00000e  6042              STR      r2,[r0,#4]
;;;2660   
;;;2661     /* Get Frequency error capture */
;;;2662     pSynchroInfo->FreqErrorCapture = (READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
000010  688a              LDR      r2,[r1,#8]
000012  0c12              LSRS     r2,r2,#16
000014  6082              STR      r2,[r0,#8]
;;;2663   
;;;2664     /* Get Frequency error direction */
;;;2665     pSynchroInfo->FreqErrorDirection = (READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
000016  6889              LDR      r1,[r1,#8]
000018  f4014100          AND      r1,r1,#0x8000
00001c  60c1              STR      r1,[r0,#0xc]
;;;2666   }
00001e  4770              BX       lr
;;;2667   
                          ENDP

                  |L2.32|
                          DCD      0x40006000

                          AREA ||i.HAL_RCCEx_CRSSoftwareSynchronizationGenerate||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSSoftwareSynchronizationGenerate PROC
;;;2639     */
;;;2640   void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
000000  4802              LDR      r0,|L3.12|
;;;2641   {
;;;2642     SET_BIT(CRS->CR, CRS_CR_SWSYNC);
000002  6801              LDR      r1,[r0,#0]
000004  f0410180          ORR      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;2643   }
00000a  4770              BX       lr
;;;2644   
                          ENDP

                  |L3.12|
                          DCD      0x40006000

                          AREA ||i.HAL_RCCEx_CRSWaitSynchronization||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRSWaitSynchronization PROC
;;;2682   */
;;;2683   uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2684   {
000004  4605              MOV      r5,r0
;;;2685     uint32_t crsstatus = RCC_CRS_NONE;
000006  2400              MOVS     r4,#0
;;;2686     uint32_t tickstart;
;;;2687   
;;;2688     /* Get timeout */
;;;2689     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4680              MOV      r8,r0
;;;2690   
;;;2691     /* Wait for CRS flag or timeout detection */
;;;2692     do
;;;2693     {
;;;2694       if(Timeout != HAL_MAX_DELAY)
;;;2695       {
;;;2696         if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;2697         {
;;;2698           crsstatus = RCC_CRS_TIMEOUT;
;;;2699         }
;;;2700       }
;;;2701       /* Check CRS SYNCOK flag  */
;;;2702       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
00000e  4e1b              LDR      r6,|L4.124|
;;;2703       {
;;;2704         /* CRS SYNC event OK */
;;;2705         crsstatus |= RCC_CRS_SYNCOK;
;;;2706   
;;;2707         /* Clear CRS SYNC event OK bit */
;;;2708         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
;;;2709       }
;;;2710   
;;;2711       /* Check CRS SYNCWARN flag  */
;;;2712       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
;;;2713       {
;;;2714         /* CRS SYNC warning */
;;;2715         crsstatus |= RCC_CRS_SYNCWARN;
;;;2716   
;;;2717         /* Clear CRS SYNCWARN bit */
;;;2718         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
;;;2719       }
;;;2720   
;;;2721       /* Check CRS TRIM overflow flag  */
;;;2722       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
;;;2723       {
;;;2724         /* CRS SYNC Error */
;;;2725         crsstatus |= RCC_CRS_TRIMOVF;
;;;2726   
;;;2727         /* Clear CRS Error bit */
;;;2728         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
000010  2704              MOVS     r7,#4
                  |L4.18|
000012  1c68              ADDS     r0,r5,#1              ;2694
000014  d007              BEQ      |L4.38|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;2696
00001e  42a8              CMP      r0,r5                 ;2696
000020  d800              BHI      |L4.36|
000022  b905              CBNZ     r5,|L4.38|
                  |L4.36|
000024  2401              MOVS     r4,#1                 ;2698
                  |L4.38|
000026  68b0              LDR      r0,[r6,#8]            ;2702
000028  07c0              LSLS     r0,r0,#31             ;2702
00002a  d003              BEQ      |L4.52|
00002c  f0440402          ORR      r4,r4,#2              ;2705
000030  2001              MOVS     r0,#1                 ;2708
000032  60f0              STR      r0,[r6,#0xc]          ;2708
                  |L4.52|
000034  68b0              LDR      r0,[r6,#8]            ;2712
000036  0780              LSLS     r0,r0,#30             ;2712
000038  d503              BPL      |L4.66|
00003a  f0440404          ORR      r4,r4,#4              ;2715
00003e  2002              MOVS     r0,#2                 ;2718
000040  60f0              STR      r0,[r6,#0xc]          ;2718
                  |L4.66|
000042  68b0              LDR      r0,[r6,#8]            ;2722
000044  0540              LSLS     r0,r0,#21             ;2722
000046  d502              BPL      |L4.78|
000048  f0440420          ORR      r4,r4,#0x20           ;2725
00004c  60f7              STR      r7,[r6,#0xc]
                  |L4.78|
;;;2729       }
;;;2730   
;;;2731       /* Check CRS Error flag  */
;;;2732       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
00004e  68b0              LDR      r0,[r6,#8]
000050  05c0              LSLS     r0,r0,#23
000052  d502              BPL      |L4.90|
;;;2733       {
;;;2734         /* CRS SYNC Error */
;;;2735         crsstatus |= RCC_CRS_SYNCERR;
000054  f0440408          ORR      r4,r4,#8
;;;2736   
;;;2737         /* Clear CRS Error bit */
;;;2738         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
000058  60f7              STR      r7,[r6,#0xc]
                  |L4.90|
;;;2739       }
;;;2740   
;;;2741       /* Check CRS SYNC Missed flag  */
;;;2742       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
00005a  68b0              LDR      r0,[r6,#8]
00005c  0580              LSLS     r0,r0,#22
00005e  d502              BPL      |L4.102|
;;;2743       {
;;;2744         /* CRS SYNC Missed */
;;;2745         crsstatus |= RCC_CRS_SYNCMISS;
000060  f0440410          ORR      r4,r4,#0x10
;;;2746   
;;;2747         /* Clear CRS SYNC Missed bit */
;;;2748         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
000064  60f7              STR      r7,[r6,#0xc]
                  |L4.102|
;;;2749       }
;;;2750   
;;;2751       /* Check CRS Expected SYNC flag  */
;;;2752       if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
000066  68b0              LDR      r0,[r6,#8]
000068  0700              LSLS     r0,r0,#28
00006a  d501              BPL      |L4.112|
;;;2753       {
;;;2754         /* frequency error counter reached a zero value */
;;;2755         __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
00006c  2008              MOVS     r0,#8
00006e  60f0              STR      r0,[r6,#0xc]
                  |L4.112|
;;;2756       }
;;;2757     } while(RCC_CRS_NONE == crsstatus);
000070  2c00              CMP      r4,#0
000072  d0ce              BEQ      |L4.18|
;;;2758   
;;;2759     return crsstatus;
000074  4620              MOV      r0,r4
;;;2760   }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;2761   
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      0x40006000

                          AREA ||i.HAL_RCCEx_CRS_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_ErrorCallback PROC
;;;2868     */
;;;2869   __weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
000000  4770              BX       lr
;;;2870   {
;;;2871     /* Prevent unused argument(s) compilation warning */
;;;2872     UNUSED(Error);
;;;2873   
;;;2874     /* NOTE : This function should not be modified, when the callback is needed,
;;;2875               the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
;;;2876      */
;;;2877   }
;;;2878   
                          ENDP


                          AREA ||i.HAL_RCCEx_CRS_ExpectedSyncCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_ExpectedSyncCallback PROC
;;;2852     */
;;;2853   __weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
000000  4770              BX       lr
;;;2854   {
;;;2855     /* NOTE : This function should not be modified, when the callback is needed,
;;;2856               the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
;;;2857      */
;;;2858   }
;;;2859   
                          ENDP


                          AREA ||i.HAL_RCCEx_CRS_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_CRS_IRQHandler PROC
;;;2765     */
;;;2766   void HAL_RCCEx_CRS_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;2767   {
;;;2768     uint32_t crserror = RCC_CRS_NONE;
000002  2000              MOVS     r0,#0
;;;2769     /* Get current IT flags and IT sources values */
;;;2770     uint32_t itflags = READ_REG(CRS->ISR);
000004  4b18              LDR      r3,|L7.104|
000006  6899              LDR      r1,[r3,#8]
;;;2771     uint32_t itsources = READ_REG(CRS->CR);
000008  681a              LDR      r2,[r3,#0]
;;;2772   
;;;2773     /* Check CRS SYNCOK flag  */
;;;2774     if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
00000a  ea010402          AND      r4,r1,r2
00000e  07e4              LSLS     r4,r4,#31
000010  d004              BEQ      |L7.28|
;;;2775     {
;;;2776       /* Clear CRS SYNC event OK flag */
;;;2777       WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
000012  2001              MOVS     r0,#1
000014  60d8              STR      r0,[r3,#0xc]
;;;2778   
;;;2779       /* user callback */
;;;2780       HAL_RCCEx_CRS_SyncOkCallback();
000016  f7fffffe          BL       HAL_RCCEx_CRS_SyncOkCallback
;;;2781     }
;;;2782     /* Check CRS SYNCWARN flag  */
;;;2783     else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
;;;2784     {
;;;2785       /* Clear CRS SYNCWARN flag */
;;;2786       WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
;;;2787   
;;;2788       /* user callback */
;;;2789       HAL_RCCEx_CRS_SyncWarnCallback();
;;;2790     }
;;;2791     /* Check CRS Expected SYNC flag  */
;;;2792     else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
;;;2793     {
;;;2794       /* frequency error counter reached a zero value */
;;;2795       WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
;;;2796   
;;;2797       /* user callback */
;;;2798       HAL_RCCEx_CRS_ExpectedSyncCallback();
;;;2799     }
;;;2800     /* Check CRS Error flags  */
;;;2801     else
;;;2802     {
;;;2803       if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
;;;2804       {
;;;2805         if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
;;;2806         {
;;;2807           crserror |= RCC_CRS_SYNCERR;
;;;2808         }
;;;2809         if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
;;;2810         {
;;;2811           crserror |= RCC_CRS_SYNCMISS;
;;;2812         }
;;;2813         if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
;;;2814         {
;;;2815           crserror |= RCC_CRS_TRIMOVF;
;;;2816         }
;;;2817   
;;;2818         /* Clear CRS Error flags */
;;;2819         WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
;;;2820   
;;;2821         /* user error callback */
;;;2822         HAL_RCCEx_CRS_ErrorCallback(crserror);
;;;2823       }
;;;2824     }
;;;2825   }
00001a  bd10              POP      {r4,pc}
                  |L7.28|
00001c  078c              LSLS     r4,r1,#30             ;2783
00001e  d506              BPL      |L7.46|
000020  0794              LSLS     r4,r2,#30             ;2783
000022  d504              BPL      |L7.46|
000024  2002              MOVS     r0,#2                 ;2786
000026  60d8              STR      r0,[r3,#0xc]          ;2786
000028  f7fffffe          BL       HAL_RCCEx_CRS_SyncWarnCallback
00002c  bd10              POP      {r4,pc}
                  |L7.46|
00002e  070c              LSLS     r4,r1,#28             ;2792
000030  d506              BPL      |L7.64|
000032  0714              LSLS     r4,r2,#28             ;2792
000034  d504              BPL      |L7.64|
000036  2008              MOVS     r0,#8                 ;2795
000038  60d8              STR      r0,[r3,#0xc]          ;2795
00003a  f7fffffe          BL       HAL_RCCEx_CRS_ExpectedSyncCallback
                  |L7.62|
00003e  bd10              POP      {r4,pc}
                  |L7.64|
000040  074c              LSLS     r4,r1,#29             ;2803
000042  d5fc              BPL      |L7.62|
000044  0752              LSLS     r2,r2,#29             ;2803
000046  d5fa              BPL      |L7.62|
000048  05ca              LSLS     r2,r1,#23             ;2805
00004a  d500              BPL      |L7.78|
00004c  2008              MOVS     r0,#8                 ;2807
                  |L7.78|
00004e  058a              LSLS     r2,r1,#22             ;2809
000050  d501              BPL      |L7.86|
000052  f0400010          ORR      r0,r0,#0x10           ;2811
                  |L7.86|
000056  0549              LSLS     r1,r1,#21             ;2813
000058  d501              BPL      |L7.94|
00005a  f0400020          ORR      r0,r0,#0x20           ;2815
                  |L7.94|
00005e  2104              MOVS     r1,#4                 ;2819
000060  60d9              STR      r1,[r3,#0xc]          ;2819
000062  f7fffffe          BL       HAL_RCCEx_CRS_ErrorCallback
000066  bd10              POP      {r4,pc}
;;;2826   
                          ENDP

                  |L7.104|
                          DCD      0x40006000

                          AREA ||i.HAL_RCCEx_CRS_SyncOkCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_SyncOkCallback PROC
;;;2830     */
;;;2831   __weak void HAL_RCCEx_CRS_SyncOkCallback(void)
000000  4770              BX       lr
;;;2832   {
;;;2833     /* NOTE : This function should not be modified, when the callback is needed,
;;;2834               the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
;;;2835      */
;;;2836   }
;;;2837   
                          ENDP


                          AREA ||i.HAL_RCCEx_CRS_SyncWarnCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_CRS_SyncWarnCallback PROC
;;;2841     */
;;;2842   __weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
000000  4770              BX       lr
;;;2843   {
;;;2844     /* NOTE : This function should not be modified, when the callback is needed,
;;;2845               the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
;;;2846      */
;;;2847   }
;;;2848   
                          ENDP


                          AREA ||i.HAL_RCCEx_DisableLSCO||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableLSCO PROC
;;;2451     */
;;;2452   void HAL_RCCEx_DisableLSCO(void)
000000  b538              PUSH     {r3-r5,lr}
;;;2453   {
;;;2454     FlagStatus       pwrclkchanged = RESET;
000002  2400              MOVS     r4,#0
;;;2455     FlagStatus       backupchanged = RESET;
000004  2000              MOVS     r0,#0
;;;2456   
;;;2457     /* Update LSCOEN bit in Backup Domain control register */
;;;2458     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000006  4d12              LDR      r5,|L10.80|
000008  6da9              LDR      r1,[r5,#0x58]
00000a  00c9              LSLS     r1,r1,#3
00000c  d408              BMI      |L10.32|
;;;2459     {
;;;2460       __HAL_RCC_PWR_CLK_ENABLE();
00000e  6da9              LDR      r1,[r5,#0x58]
000010  f0415180          ORR      r1,r1,#0x10000000
000014  65a9              STR      r1,[r5,#0x58]
000016  6da9              LDR      r1,[r5,#0x58]
000018  f0015180          AND      r1,r1,#0x10000000
00001c  9100              STR      r1,[sp,#0]
;;;2461       pwrclkchanged = SET;
00001e  2401              MOVS     r4,#1
                  |L10.32|
;;;2462     }
;;;2463     if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
000020  490c              LDR      r1,|L10.84|
000022  6809              LDR      r1,[r1,#0]
000024  05c9              LSLS     r1,r1,#23
000026  d402              BMI      |L10.46|
;;;2464     {
;;;2465       /* Enable access to the backup domain */
;;;2466       HAL_PWR_EnableBkUpAccess();
000028  f7fffffe          BL       HAL_PWR_EnableBkUpAccess
;;;2467       backupchanged = SET;
00002c  2001              MOVS     r0,#1
                  |L10.46|
;;;2468     }
;;;2469   
;;;2470     CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
00002e  f8d51090          LDR      r1,[r5,#0x90]
000032  f0217180          BIC      r1,r1,#0x1000000
000036  f8c51090          STR      r1,[r5,#0x90]
;;;2471   
;;;2472     /* Restore previous configuration */
;;;2473     if(backupchanged == SET)
00003a  2801              CMP      r0,#1
00003c  d101              BNE      |L10.66|
;;;2474     {
;;;2475       /* Disable access to the backup domain */
;;;2476       HAL_PWR_DisableBkUpAccess();
00003e  f7fffffe          BL       HAL_PWR_DisableBkUpAccess
                  |L10.66|
;;;2477     }
;;;2478     if(pwrclkchanged == SET)
000042  2c01              CMP      r4,#1
000044  d103              BNE      |L10.78|
;;;2479     {
;;;2480       __HAL_RCC_PWR_CLK_DISABLE();
000046  6da8              LDR      r0,[r5,#0x58]
000048  f0205080          BIC      r0,r0,#0x10000000
00004c  65a8              STR      r0,[r5,#0x58]
                  |L10.78|
;;;2481     }
;;;2482   }
00004e  bd38              POP      {r3-r5,pc}
;;;2483   
                          ENDP

                  |L10.80|
                          DCD      0x40021000
                  |L10.84|
                          DCD      0x40007000

                          AREA ||i.HAL_RCCEx_DisableLSECSS||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableLSECSS PROC
;;;2342     */
;;;2343   void HAL_RCCEx_DisableLSECSS(void)
000000  4804              LDR      r0,|L11.20|
;;;2344   {
;;;2345     CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
000002  6f81              LDR      r1,[r0,#0x78]
000004  f0210120          BIC      r1,r1,#0x20
000008  6781              STR      r1,[r0,#0x78]
;;;2346   
;;;2347     /* Disable LSE CSS IT if any */
;;;2348     __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
00000a  6801              LDR      r1,[r0,#0]
00000c  f4217100          BIC      r1,r1,#0x200
000010  6001              STR      r1,[r0,#0]
;;;2349   }
000012  4770              BX       lr
;;;2350   
                          ENDP

                  |L11.20|
                          DCD      0x40021018

                          AREA ||i.HAL_RCCEx_DisableMSIPLLMode||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisableMSIPLLMode PROC
;;;2499     */
;;;2500   void HAL_RCCEx_DisableMSIPLLMode(void)
000000  4802              LDR      r0,|L12.12|
;;;2501   {
;;;2502     CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;2503   }
00000a  4770              BX       lr
;;;2504   
                          ENDP

                  |L12.12|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_DisablePLLSAI1||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisablePLLSAI1 PROC
;;;2123     */
;;;2124   HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI1(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2125   {
;;;2126     uint32_t tickstart;
;;;2127     HAL_StatusTypeDef status = HAL_OK;
000002  2600              MOVS     r6,#0
;;;2128   
;;;2129     /* Disable the PLLSAI1 */
;;;2130     __HAL_RCC_PLLSAI1_DISABLE();
000004  4c10              LDR      r4,|L13.72|
000006  6820              LDR      r0,[r4,#0]
000008  f0206080          BIC      r0,r0,#0x4000000
00000c  6020              STR      r0,[r4,#0]
;;;2131   
;;;2132     /* Get Start Tick*/
;;;2133     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;2134   
;;;2135     /* Wait till PLLSAI1 is ready */
;;;2136     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
000014  e006              B        |L13.36|
                  |L13.22|
;;;2137     {
;;;2138       if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
000016  f7fffffe          BL       HAL_GetTick
00001a  1b40              SUBS     r0,r0,r5
00001c  2802              CMP      r0,#2
00001e  d901              BLS      |L13.36|
;;;2139       {
;;;2140         status = HAL_TIMEOUT;
000020  2603              MOVS     r6,#3
;;;2141         break;
000022  e002              B        |L13.42|
                  |L13.36|
000024  6820              LDR      r0,[r4,#0]            ;2136
000026  0100              LSLS     r0,r0,#4              ;2136
000028  d4f5              BMI      |L13.22|
                  |L13.42|
;;;2142       }
;;;2143     }
;;;2144   
;;;2145     /* Disable the PLLSAI1 Clock outputs */
;;;2146     __HAL_RCC_PLLSAI1CLKOUT_DISABLE(RCC_PLLSAI1CFGR_PLLSAI1PEN|RCC_PLLSAI1CFGR_PLLSAI1QEN|RCC_PLLSAI1CFGR_PLLSAI1REN);
00002a  6920              LDR      r0,[r4,#0x10]
00002c  4907              LDR      r1,|L13.76|
00002e  4008              ANDS     r0,r0,r1
000030  6120              STR      r0,[r4,#0x10]
;;;2147   
;;;2148     /* Reset PLL source to save power if no PLLs on */
;;;2149   #if defined(RCC_PLLSAI2_SUPPORT)
;;;2150     if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI2RDY)) == 0U)
000032  6820              LDR      r0,[r4,#0]
000034  f0105f08          TST      r0,#0x22000000
000038  d103              BNE      |L13.66|
;;;2151     {
;;;2152       MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  f0200003          BIC      r0,r0,#3
000040  60e0              STR      r0,[r4,#0xc]
                  |L13.66|
;;;2153     }
;;;2154   #else
;;;2155     if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
;;;2156     {
;;;2157       MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;2158     }
;;;2159   #endif /* RCC_PLLSAI2_SUPPORT */
;;;2160   
;;;2161     return status;
000042  4630              MOV      r0,r6
;;;2162   }
000044  bd70              POP      {r4-r6,pc}
;;;2163   
                          ENDP

000046  0000              DCW      0x0000
                  |L13.72|
                          DCD      0x40021000
                  |L13.76|
                          DCD      0xfeeeffff

                          AREA ||i.HAL_RCCEx_DisablePLLSAI2||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisablePLLSAI2 PROC
;;;2251     */
;;;2252   HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI2(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2253   {
;;;2254     uint32_t tickstart;
;;;2255     HAL_StatusTypeDef status = HAL_OK;
000002  2600              MOVS     r6,#0
;;;2256   
;;;2257     /* Disable the PLLSAI2 */
;;;2258     __HAL_RCC_PLLSAI2_DISABLE();
000004  4c10              LDR      r4,|L14.72|
000006  6820              LDR      r0,[r4,#0]
000008  f0205080          BIC      r0,r0,#0x10000000
00000c  6020              STR      r0,[r4,#0]
;;;2259   
;;;2260     /* Get Start Tick*/
;;;2261     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;2262   
;;;2263     /* Wait till PLLSAI2 is ready */
;;;2264     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
000014  e006              B        |L14.36|
                  |L14.22|
;;;2265     {
;;;2266       if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
000016  f7fffffe          BL       HAL_GetTick
00001a  1b40              SUBS     r0,r0,r5
00001c  2802              CMP      r0,#2
00001e  d901              BLS      |L14.36|
;;;2267       {
;;;2268         status = HAL_TIMEOUT;
000020  2603              MOVS     r6,#3
;;;2269         break;
000022  e002              B        |L14.42|
                  |L14.36|
000024  6820              LDR      r0,[r4,#0]            ;2264
000026  0080              LSLS     r0,r0,#2              ;2264
000028  d4f5              BMI      |L14.22|
                  |L14.42|
;;;2270       }
;;;2271     }
;;;2272   
;;;2273     /* Disable the PLLSAI2 Clock outputs */
;;;2274   #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2275     __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2QEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
;;;2276   #else
;;;2277     __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
00002a  6960              LDR      r0,[r4,#0x14]
00002c  4907              LDR      r1,|L14.76|
00002e  4008              ANDS     r0,r0,r1
000030  6160              STR      r0,[r4,#0x14]
;;;2278   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */
;;;2279   
;;;2280     /* Reset PLL source to save power if no PLLs on */
;;;2281     if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY)) == 0U)
000032  6820              LDR      r0,[r4,#0]
000034  f0106f20          TST      r0,#0xa000000
000038  d103              BNE      |L14.66|
;;;2282     {
;;;2283       MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  f0200003          BIC      r0,r0,#3
000040  60e0              STR      r0,[r4,#0xc]
                  |L14.66|
;;;2284     }
;;;2285   
;;;2286     return status;
000042  4630              MOV      r0,r6
;;;2287   }
000044  bd70              POP      {r4-r6,pc}
;;;2288   
                          ENDP

000046  0000              DCW      0x0000
                  |L14.72|
                          DCD      0x40021000
                  |L14.76|
                          DCD      0xfefeffff

                          AREA ||i.HAL_RCCEx_EnableLSCO||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSCO PROC
;;;2404     */
;;;2405   void HAL_RCCEx_EnableLSCO(uint32_t LSCOSource)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2406   {
000002  b087              SUB      sp,sp,#0x1c
000004  4607              MOV      r7,r0
;;;2407     GPIO_InitTypeDef GPIO_InitStruct;
;;;2408     FlagStatus       pwrclkchanged = RESET;
000006  2400              MOVS     r4,#0
;;;2409     FlagStatus       backupchanged = RESET;
000008  2500              MOVS     r5,#0
;;;2410   
;;;2411     /* Check the parameters */
;;;2412     assert_param(IS_RCC_LSCOSOURCE(LSCOSource));
;;;2413   
;;;2414     /* LSCO Pin Clock Enable */
;;;2415     __LSCO_CLK_ENABLE();
00000a  4e1f              LDR      r6,|L15.136|
00000c  6cf0              LDR      r0,[r6,#0x4c]
00000e  f0400001          ORR      r0,r0,#1
000012  64f0              STR      r0,[r6,#0x4c]
000014  6cf0              LDR      r0,[r6,#0x4c]
000016  f0000001          AND      r0,r0,#1
00001a  9001              STR      r0,[sp,#4]
;;;2416   
;;;2417     /* Configue the LSCO pin in analog mode */
;;;2418     GPIO_InitStruct.Pin = LSCO_PIN;
00001c  2004              MOVS     r0,#4
00001e  9002              STR      r0,[sp,#8]
;;;2419     GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
000020  2003              MOVS     r0,#3
000022  9003              STR      r0,[sp,#0xc]
;;;2420     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000024  2002              MOVS     r0,#2
000026  9005              STR      r0,[sp,#0x14]
;;;2421     GPIO_InitStruct.Pull = GPIO_NOPULL;
000028  2000              MOVS     r0,#0
00002a  9004              STR      r0,[sp,#0x10]
;;;2422     HAL_GPIO_Init(LSCO_GPIO_PORT, &GPIO_InitStruct);
00002c  a902              ADD      r1,sp,#8
00002e  f04f4090          MOV      r0,#0x48000000
000032  f7fffffe          BL       HAL_GPIO_Init
;;;2423   
;;;2424     /* Update LSCOSEL clock source in Backup Domain control register */
;;;2425     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000036  6db0              LDR      r0,[r6,#0x58]
000038  00c0              LSLS     r0,r0,#3
00003a  d408              BMI      |L15.78|
;;;2426     {
;;;2427       __HAL_RCC_PWR_CLK_ENABLE();
00003c  6db0              LDR      r0,[r6,#0x58]
00003e  f0405080          ORR      r0,r0,#0x10000000
000042  65b0              STR      r0,[r6,#0x58]
000044  6db0              LDR      r0,[r6,#0x58]
000046  f0005080          AND      r0,r0,#0x10000000
00004a  9001              STR      r0,[sp,#4]
;;;2428       pwrclkchanged = SET;
00004c  2401              MOVS     r4,#1
                  |L15.78|
;;;2429     }
;;;2430     if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
00004e  480f              LDR      r0,|L15.140|
000050  6800              LDR      r0,[r0,#0]
000052  05c0              LSLS     r0,r0,#23
000054  d402              BMI      |L15.92|
;;;2431     {
;;;2432       HAL_PWR_EnableBkUpAccess();
000056  f7fffffe          BL       HAL_PWR_EnableBkUpAccess
;;;2433       backupchanged = SET;
00005a  2501              MOVS     r5,#1
                  |L15.92|
;;;2434     }
;;;2435   
;;;2436     MODIFY_REG(RCC->BDCR, RCC_BDCR_LSCOSEL | RCC_BDCR_LSCOEN, LSCOSource | RCC_BDCR_LSCOEN);
00005c  f8d60090          LDR      r0,[r6,#0x90]
000060  f0207040          BIC      r0,r0,#0x3000000
000064  4338              ORRS     r0,r0,r7
000066  f0407080          ORR      r0,r0,#0x1000000
00006a  f8c60090          STR      r0,[r6,#0x90]
;;;2437   
;;;2438     if(backupchanged == SET)
00006e  2d01              CMP      r5,#1
000070  d101              BNE      |L15.118|
;;;2439     {
;;;2440       HAL_PWR_DisableBkUpAccess();
000072  f7fffffe          BL       HAL_PWR_DisableBkUpAccess
                  |L15.118|
;;;2441     }
;;;2442     if(pwrclkchanged == SET)
000076  2c01              CMP      r4,#1
000078  d103              BNE      |L15.130|
;;;2443     {
;;;2444       __HAL_RCC_PWR_CLK_DISABLE();
00007a  6db0              LDR      r0,[r6,#0x58]
00007c  f0205080          BIC      r0,r0,#0x10000000
000080  65b0              STR      r0,[r6,#0x58]
                  |L15.130|
;;;2445     }
;;;2446   }
000082  b007              ADD      sp,sp,#0x1c
000084  bdf0              POP      {r4-r7,pc}
;;;2447   
                          ENDP

000086  0000              DCW      0x0000
                  |L15.136|
                          DCD      0x40021000
                  |L15.140|
                          DCD      0x40007000

                          AREA ||i.HAL_RCCEx_EnableLSECSS||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSECSS PROC
;;;2332     */
;;;2333   void HAL_RCCEx_EnableLSECSS(void)
000000  4802              LDR      r0,|L16.12|
;;;2334   {
;;;2335     SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
000002  6801              LDR      r1,[r0,#0]
000004  f0410120          ORR      r1,r1,#0x20
000008  6001              STR      r1,[r0,#0]
;;;2336   }
00000a  4770              BX       lr
;;;2337   
                          ENDP

                  |L16.12|
                          DCD      0x40021090

                          AREA ||i.HAL_RCCEx_EnableLSECSS_IT||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableLSECSS_IT PROC
;;;2355     */
;;;2356   void HAL_RCCEx_EnableLSECSS_IT(void)
000000  480a              LDR      r0,|L17.44|
;;;2357   {
;;;2358     /* Enable LSE CSS */
;;;2359     SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
000002  6f81              LDR      r1,[r0,#0x78]
000004  f0410120          ORR      r1,r1,#0x20
000008  6781              STR      r1,[r0,#0x78]
;;;2360   
;;;2361     /* Enable LSE CSS IT */
;;;2362     __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
00000a  6801              LDR      r1,[r0,#0]
00000c  f4417100          ORR      r1,r1,#0x200
000010  6001              STR      r1,[r0,#0]
;;;2363   
;;;2364     /* Enable IT on EXTI Line 19 */
;;;2365     __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
000012  4807              LDR      r0,|L17.48|
000014  6801              LDR      r1,[r0,#0]
000016  f4412100          ORR      r1,r1,#0x80000
00001a  6001              STR      r1,[r0,#0]
;;;2366     __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
00001c  4804              LDR      r0,|L17.48|
00001e  3008              ADDS     r0,r0,#8
000020  6801              LDR      r1,[r0,#0]
000022  f4412100          ORR      r1,r1,#0x80000
000026  6001              STR      r1,[r0,#0]
;;;2367   }
000028  4770              BX       lr
;;;2368   
                          ENDP

00002a  0000              DCW      0x0000
                  |L17.44|
                          DCD      0x40021018
                  |L17.48|
                          DCD      0x40010400

                          AREA ||i.HAL_RCCEx_EnableMSIPLLMode||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnableMSIPLLMode PROC
;;;2489     */
;;;2490   void HAL_RCCEx_EnableMSIPLLMode(void)
000000  4802              LDR      r0,|L18.12|
;;;2491   {
;;;2492     SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;2493   }
00000a  4770              BX       lr
;;;2494   
                          ENDP

                  |L18.12|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_EnablePLLSAI1||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnablePLLSAI1 PROC
;;;2055     */
;;;2056   HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2057   {
000004  4604              MOV      r4,r0
;;;2058     uint32_t tickstart;
;;;2059     HAL_StatusTypeDef status = HAL_OK;
000006  2500              MOVS     r5,#0
;;;2060   
;;;2061     /* check for PLLSAI1 Parameters used to output PLLSAI1CLK */
;;;2062     assert_param(IS_RCC_PLLSAI1SOURCE(PLLSAI1Init->PLLSAI1Source));
;;;2063     assert_param(IS_RCC_PLLSAI1M_VALUE(PLLSAI1Init->PLLSAI1M));
;;;2064     assert_param(IS_RCC_PLLSAI1N_VALUE(PLLSAI1Init->PLLSAI1N));
;;;2065     assert_param(IS_RCC_PLLSAI1P_VALUE(PLLSAI1Init->PLLSAI1P));
;;;2066     assert_param(IS_RCC_PLLSAI1Q_VALUE(PLLSAI1Init->PLLSAI1Q));
;;;2067     assert_param(IS_RCC_PLLSAI1R_VALUE(PLLSAI1Init->PLLSAI1R));
;;;2068     assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1Init->PLLSAI1ClockOut));
;;;2069   
;;;2070     /* Disable the PLLSAI1 */
;;;2071     __HAL_RCC_PLLSAI1_DISABLE();
000008  4e21              LDR      r6,|L19.144|
00000a  6830              LDR      r0,[r6,#0]
00000c  f0206080          BIC      r0,r0,#0x4000000
000010  6030              STR      r0,[r6,#0]
;;;2072   
;;;2073     /* Get Start Tick*/
;;;2074     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4607              MOV      r7,r0
;;;2075   
;;;2076     /* Wait till PLLSAI1 is ready to be updated */
;;;2077     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
000018  e006              B        |L19.40|
                  |L19.26|
;;;2078     {
;;;2079       if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1bc0              SUBS     r0,r0,r7
000020  2802              CMP      r0,#2
000022  d901              BLS      |L19.40|
;;;2080       {
;;;2081         status = HAL_TIMEOUT;
000024  2503              MOVS     r5,#3
;;;2082         break;
000026  e002              B        |L19.46|
                  |L19.40|
000028  6830              LDR      r0,[r6,#0]            ;2077
00002a  0100              LSLS     r0,r0,#4              ;2077
00002c  d4f5              BMI      |L19.26|
                  |L19.46|
;;;2083       }
;;;2084     }
;;;2085   
;;;2086     if(status == HAL_OK)
00002e  bb3d              CBNZ     r5,|L19.128|
;;;2087     {
;;;2088   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;2089       /* Configure the PLLSAI1 Multiplication factor N */
;;;2090       /* Configure the PLLSAI1 Division factors M, P, Q and R */
;;;2091       __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1M, PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
;;;2092   #else
;;;2093       /* Configure the PLLSAI1 Multiplication factor N */
;;;2094       /* Configure the PLLSAI1 Division factors P, Q and R */
;;;2095       __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
000030  68a0              LDR      r0,[r4,#8]
000032  8a22              LDRH     r2,[r4,#0x10]
000034  0201              LSLS     r1,r0,#8
000036  f04f30ff          MOV      r0,#0xffffffff
00003a  eb000252          ADD      r2,r0,r2,LSR #1
00003e  ea415142          ORR      r1,r1,r2,LSL #21
000042  7d22              LDRB     r2,[r4,#0x14]
000044  eb000052          ADD      r0,r0,r2,LSR #1
000048  ea416040          ORR      r0,r1,r0,LSL #25
00004c  7b21              LDRB     r1,[r4,#0xc]
00004e  ea4060c1          ORR      r0,r0,r1,LSL #27
000052  6931              LDR      r1,[r6,#0x10]
000054  4a0f              LDR      r2,|L19.148|
000056  4011              ANDS     r1,r1,r2
000058  4308              ORRS     r0,r0,r1
00005a  6130              STR      r0,[r6,#0x10]
;;;2096   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;2097       /* Configure the PLLSAI1 Clock output(s) */
;;;2098       __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1Init->PLLSAI1ClockOut);
00005c  6930              LDR      r0,[r6,#0x10]
00005e  69a1              LDR      r1,[r4,#0x18]
000060  4308              ORRS     r0,r0,r1
000062  6130              STR      r0,[r6,#0x10]
;;;2099   
;;;2100       /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
;;;2101       __HAL_RCC_PLLSAI1_ENABLE();
000064  6830              LDR      r0,[r6,#0]
000066  f0406080          ORR      r0,r0,#0x4000000
00006a  6030              STR      r0,[r6,#0]
;;;2102   
;;;2103       /* Get Start Tick*/
;;;2104       tickstart = HAL_GetTick();
00006c  f7fffffe          BL       HAL_GetTick
000070  4604              MOV      r4,r0
;;;2105   
;;;2106       /* Wait till PLLSAI1 is ready */
;;;2107       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
000072  e006              B        |L19.130|
                  |L19.116|
;;;2108       {
;;;2109         if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
000074  f7fffffe          BL       HAL_GetTick
000078  1b00              SUBS     r0,r0,r4
00007a  2802              CMP      r0,#2
00007c  d901              BLS      |L19.130|
;;;2110         {
;;;2111           status = HAL_TIMEOUT;
00007e  2503              MOVS     r5,#3
                  |L19.128|
;;;2112           break;
000080  e002              B        |L19.136|
                  |L19.130|
000082  6830              LDR      r0,[r6,#0]            ;2107
000084  0100              LSLS     r0,r0,#4              ;2107
000086  d5f5              BPL      |L19.116|
                  |L19.136|
;;;2113         }
;;;2114       }
;;;2115     }
;;;2116   
;;;2117     return status;
000088  4628              MOV      r0,r5
;;;2118   }
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;2119   
                          ENDP

00008e  0000              DCW      0x0000
                  |L19.144|
                          DCD      0x40021000
                  |L19.148|
                          DCD      0x019d80ff

                          AREA ||i.HAL_RCCEx_EnablePLLSAI2||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnablePLLSAI2 PROC
;;;2173     */
;;;2174   HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2175   {
000004  4605              MOV      r5,r0
;;;2176     uint32_t tickstart;
;;;2177     HAL_StatusTypeDef status = HAL_OK;
000006  2400              MOVS     r4,#0
;;;2178   
;;;2179     /* check for PLLSAI2 Parameters used to output PLLSAI2CLK */
;;;2180     assert_param(IS_RCC_PLLSAI2SOURCE(PLLSAI2Init->PLLSAI2Source));
;;;2181     assert_param(IS_RCC_PLLSAI2M_VALUE(PLLSAI2Init->PLLSAI2M));
;;;2182     assert_param(IS_RCC_PLLSAI2N_VALUE(PLLSAI2Init->PLLSAI2N));
;;;2183     assert_param(IS_RCC_PLLSAI2P_VALUE(PLLSAI2Init->PLLSAI2P));
;;;2184   #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2185     assert_param(IS_RCC_PLLSAI2Q_VALUE(PLLSAI2Init->PLLSAI2Q));
;;;2186   #endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
;;;2187     assert_param(IS_RCC_PLLSAI2R_VALUE(PLLSAI2Init->PLLSAI2R));
;;;2188     assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PLLSAI2Init->PLLSAI2ClockOut));
;;;2189   
;;;2190     /* Disable the PLLSAI2 */
;;;2191     __HAL_RCC_PLLSAI2_DISABLE();
000008  4e1e              LDR      r6,|L20.132|
00000a  6830              LDR      r0,[r6,#0]
00000c  f0205080          BIC      r0,r0,#0x10000000
000010  6030              STR      r0,[r6,#0]
;;;2192   
;;;2193     /* Get Start Tick*/
;;;2194     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4607              MOV      r7,r0
;;;2195   
;;;2196     /* Wait till PLLSAI2 is ready to be updated */
;;;2197     while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
000018  e006              B        |L20.40|
                  |L20.26|
;;;2198     {
;;;2199       if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1bc0              SUBS     r0,r0,r7
000020  2802              CMP      r0,#2
000022  d901              BLS      |L20.40|
;;;2200       {
;;;2201         status = HAL_TIMEOUT;
000024  2403              MOVS     r4,#3
;;;2202         break;
000026  e002              B        |L20.46|
                  |L20.40|
000028  6830              LDR      r0,[r6,#0]            ;2197
00002a  0080              LSLS     r0,r0,#2              ;2197
00002c  d4f5              BMI      |L20.26|
                  |L20.46|
;;;2203       }
;;;2204     }
;;;2205   
;;;2206     if(status == HAL_OK)
00002e  bb0c              CBNZ     r4,|L20.116|
;;;2207     {
;;;2208   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2209       /* Configure the PLLSAI2 Multiplication factor N */
;;;2210       /* Configure the PLLSAI2 Division factors M, P, Q and R */
;;;2211       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2M, PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2Q, PLLSAI2Init->PLLSAI2R);
;;;2212   #elif defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;2213       /* Configure the PLLSAI2 Multiplication factor N */
;;;2214       /* Configure the PLLSAI2 Division factors M, P and R */
;;;2215       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2M, PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2R);
;;;2216   #elif defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;2217       /* Configure the PLLSAI2 Multiplication factor N */
;;;2218       /* Configure the PLLSAI2 Division factors P, Q and R */
;;;2219       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2Q, PLLSAI2Init->PLLSAI2R);
;;;2220   #else
;;;2221       /* Configure the PLLSAI2 Multiplication factor N */
;;;2222       /* Configure the PLLSAI2 Division factors P and R */
;;;2223       __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2R);
000030  68a8              LDR      r0,[r5,#8]
000032  7c29              LDRB     r1,[r5,#0x10]
000034  0200              LSLS     r0,r0,#8
000036  227f              MOVS     r2,#0x7f
000038  eb020151          ADD      r1,r2,r1,LSR #1
00003c  ea406041          ORR      r0,r0,r1,LSL #25
000040  7b29              LDRB     r1,[r5,#0xc]
000042  ea4060c1          ORR      r0,r0,r1,LSL #27
000046  6971              LDR      r1,[r6,#0x14]
000048  4a0f              LDR      r2,|L20.136|
00004a  4011              ANDS     r1,r1,r2
00004c  4308              ORRS     r0,r0,r1
00004e  6170              STR      r0,[r6,#0x14]
;;;2224   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */
;;;2225       /* Configure the PLLSAI2 Clock output(s) */
;;;2226       __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PLLSAI2Init->PLLSAI2ClockOut);
000050  6970              LDR      r0,[r6,#0x14]
000052  6969              LDR      r1,[r5,#0x14]
000054  4308              ORRS     r0,r0,r1
000056  6170              STR      r0,[r6,#0x14]
;;;2227   
;;;2228       /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
;;;2229       __HAL_RCC_PLLSAI2_ENABLE();
000058  6830              LDR      r0,[r6,#0]
00005a  f0405080          ORR      r0,r0,#0x10000000
00005e  6030              STR      r0,[r6,#0]
;;;2230   
;;;2231       /* Get Start Tick*/
;;;2232       tickstart = HAL_GetTick();
000060  f7fffffe          BL       HAL_GetTick
000064  4605              MOV      r5,r0
;;;2233   
;;;2234       /* Wait till PLLSAI2 is ready */
;;;2235       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
000066  e006              B        |L20.118|
                  |L20.104|
;;;2236       {
;;;2237         if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
000068  f7fffffe          BL       HAL_GetTick
00006c  1b40              SUBS     r0,r0,r5
00006e  2802              CMP      r0,#2
000070  d901              BLS      |L20.118|
;;;2238         {
;;;2239           status = HAL_TIMEOUT;
000072  2403              MOVS     r4,#3
                  |L20.116|
;;;2240           break;
000074  e002              B        |L20.124|
                  |L20.118|
000076  6830              LDR      r0,[r6,#0]            ;2235
000078  0080              LSLS     r0,r0,#2              ;2235
00007a  d5f5              BPL      |L20.104|
                  |L20.124|
;;;2241         }
;;;2242       }
;;;2243     }
;;;2244   
;;;2245     return status;
00007c  4620              MOV      r0,r4
;;;2246   }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;2247   
                          ENDP

000082  0000              DCW      0x0000
                  |L20.132|
                          DCD      0x40021000
                  |L20.136|
                          DCD      0x01fd80ff

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;825      */
;;;826    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b530              PUSH     {r4,r5,lr}
;;;827    {
;;;828      /* Set all possible values for the extended clock type parameter------------*/
;;;829    
;;;830    #if defined(STM32L412xx) || defined(STM32L422xx)
;;;831    
;;;832      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 |                                               \
;;;833                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;834                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 |                                               RCC_PERIPHCLK_USB    | \
;;;835                                                                    RCC_PERIPHCLK_RNG    |                                                                      \
;;;836                                            RCC_PERIPHCLK_RTC ;
;;;837    
;;;838    #elif defined(STM32L431xx)
;;;839    
;;;840      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 |                                               \
;;;841                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;842                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                                               \
;;;843                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 |                        \
;;;844                                            RCC_PERIPHCLK_RTC ;
;;;845    
;;;846    #elif defined(STM32L432xx) || defined(STM32L442xx)
;;;847    
;;;848      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 |                                                                      \
;;;849                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   |                        RCC_PERIPHCLK_I2C3   |                        \
;;;850                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                        RCC_PERIPHCLK_USB    | \
;;;851                                                                    RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 |                        \
;;;852                                            RCC_PERIPHCLK_RTC ;
;;;853    
;;;854    #elif defined(STM32L433xx) || defined(STM32L443xx)
;;;855    
;;;856      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 |                                               \
;;;857                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;858                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                        RCC_PERIPHCLK_USB    | \
;;;859                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 |                        \
;;;860                                            RCC_PERIPHCLK_RTC ;
;;;861    
;;;862    #elif defined(STM32L451xx)
;;;863    
;;;864      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  |                        \
;;;865                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;866                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                                               \
;;;867                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    |                        RCC_PERIPHCLK_DFSDM1 | \
;;;868                                            RCC_PERIPHCLK_RTC ;
;;;869    
;;;870    #elif defined(STM32L452xx) || defined(STM32L462xx)
;;;871    
;;;872      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  |                        \
;;;873                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;874                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   |                        RCC_PERIPHCLK_USB    | \
;;;875                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    |                        RCC_PERIPHCLK_DFSDM1 | \
;;;876                                            RCC_PERIPHCLK_RTC ;
;;;877    
;;;878    #elif defined(STM32L471xx)
;;;879    
;;;880      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;881                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3                          | \
;;;882                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2                          | \
;;;883                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
;;;884                                            RCC_PERIPHCLK_RTC ;
;;;885    
;;;886    #elif defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
;;;887    
;;;888      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;889                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   |                        \
;;;890                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;891                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
;;;892                                            RCC_PERIPHCLK_RTC ;
;;;893    
;;;894    #elif defined(STM32L496xx) || defined(STM32L4A6xx)
;;;895    
;;;896      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
000002  4947              LDR      r1,|L21.288|
000004  6001              STR      r1,[r0,#0]
;;;897                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;898                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;899                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
;;;900                                            RCC_PERIPHCLK_RTC ;
;;;901    
;;;902    #elif defined(STM32L4R5xx) || defined(STM32L4S5xx)
;;;903    
;;;904      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;905                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;906                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;907                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC                           | RCC_PERIPHCLK_DFSDM1 | \
;;;908                                            RCC_PERIPHCLK_DFSDM1AUDIO | RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_OSPI;
;;;909    
;;;910    #elif defined(STM32L4R7xx) || defined(STM32L4S7xx) || defined(STM32L4Q5xx)
;;;911    
;;;912      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;913                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;914                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;915                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC                           | RCC_PERIPHCLK_DFSDM1 | \
;;;916                                            RCC_PERIPHCLK_DFSDM1AUDIO | RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_OSPI  | RCC_PERIPHCLK_LTDC;
;;;917    
;;;918    #elif defined(STM32L4R9xx) || defined(STM32L4S9xx)
;;;919    
;;;920      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
;;;921                                            RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_I2C2   | RCC_PERIPHCLK_I2C3   | RCC_PERIPHCLK_I2C4   | \
;;;922                                            RCC_PERIPHCLK_LPTIM1  | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2   | RCC_PERIPHCLK_USB    | \
;;;923                                            RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC                           | RCC_PERIPHCLK_DFSDM1 | \
;;;924                                            RCC_PERIPHCLK_DFSDM1AUDIO | RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_OSPI  | RCC_PERIPHCLK_LTDC   | RCC_PERIPHCLK_DSI;
;;;925    
;;;926    #endif /* STM32L431xx */
;;;927    
;;;928    #if defined(RCC_PLLSAI1_SUPPORT)
;;;929    
;;;930      /* Get the PLLSAI1 Clock configuration -----------------------------------------------*/
;;;931    
;;;932      PeriphClkInit->PLLSAI1.PLLSAI1Source = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC) >> RCC_PLLCFGR_PLLSRC_Pos;
000006  4947              LDR      r1,|L21.292|
000008  680a              LDR      r2,[r1,#0]
00000a  f0020303          AND      r3,r2,#3
00000e  6043              STR      r3,[r0,#4]
;;;933    #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;934      PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U;
;;;935    #else
;;;936      PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
000010  680a              LDR      r2,[r1,#0]
000012  f3c21202          UBFX     r2,r2,#4,#3
000016  1c52              ADDS     r2,r2,#1
000018  6082              STR      r2,[r0,#8]
;;;937    #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;938      PeriphClkInit->PLLSAI1.PLLSAI1N = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
00001a  684c              LDR      r4,[r1,#4]
00001c  f3c42406          UBFX     r4,r4,#8,#7
000020  60c4              STR      r4,[r0,#0xc]
;;;939      PeriphClkInit->PLLSAI1.PLLSAI1P = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) >> RCC_PLLSAI1CFGR_PLLSAI1P_Pos) << 4U) + 7U;
000022  684c              LDR      r4,[r1,#4]
000024  2507              MOVS     r5,#7
000026  f4043400          AND      r4,r4,#0x20000
00002a  eb053454          ADD      r4,r5,r4,LSR #13
00002e  6104              STR      r4,[r0,#0x10]
;;;940      PeriphClkInit->PLLSAI1.PLLSAI1Q = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) * 2U;
000030  684c              LDR      r4,[r1,#4]
000032  f3c45441          UBFX     r4,r4,#21,#2
000036  1c64              ADDS     r4,r4,#1
000038  0064              LSLS     r4,r4,#1
00003a  6144              STR      r4,[r0,#0x14]
;;;941      PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
00003c  684c              LDR      r4,[r1,#4]
00003e  f3c46441          UBFX     r4,r4,#25,#2
000042  1c64              ADDS     r4,r4,#1
000044  0064              LSLS     r4,r4,#1
000046  6184              STR      r4,[r0,#0x18]
;;;942    
;;;943    #endif /* RCC_PLLSAI1_SUPPORT */
;;;944    
;;;945    #if defined(RCC_PLLSAI2_SUPPORT)
;;;946    
;;;947      /* Get the PLLSAI2 Clock configuration -----------------------------------------------*/
;;;948    
;;;949      PeriphClkInit->PLLSAI2.PLLSAI2Source = PeriphClkInit->PLLSAI1.PLLSAI1Source;
000048  6203              STR      r3,[r0,#0x20]
;;;950    #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;951      PeriphClkInit->PLLSAI2.PLLSAI2M = (READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U;
;;;952    #else
;;;953      PeriphClkInit->PLLSAI2.PLLSAI2M = PeriphClkInit->PLLSAI1.PLLSAI1M;
00004a  6242              STR      r2,[r0,#0x24]
;;;954    #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;955      PeriphClkInit->PLLSAI2.PLLSAI2N = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
00004c  688a              LDR      r2,[r1,#8]
00004e  f3c22206          UBFX     r2,r2,#8,#7
000052  6282              STR      r2,[r0,#0x28]
;;;956      PeriphClkInit->PLLSAI2.PLLSAI2P = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) >> RCC_PLLSAI2CFGR_PLLSAI2P_Pos) << 4U) + 7U;
000054  688a              LDR      r2,[r1,#8]
000056  f4023200          AND      r2,r2,#0x20000
00005a  eb053252          ADD      r2,r5,r2,LSR #13
00005e  62c2              STR      r2,[r0,#0x2c]
;;;957    #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;958      PeriphClkInit->PLLSAI2.PLLSAI2Q = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2Q) >> RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) + 1U) * 2U;
;;;959    #endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
;;;960      PeriphClkInit->PLLSAI2.PLLSAI2R = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R)>> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) * 2U;
000060  688a              LDR      r2,[r1,#8]
000062  f3c26241          UBFX     r2,r2,#25,#2
000066  1c52              ADDS     r2,r2,#1
000068  0052              LSLS     r2,r2,#1
00006a  6302              STR      r2,[r0,#0x30]
;;;961    
;;;962    #endif /* RCC_PLLSAI2_SUPPORT */
;;;963    
;;;964      /* Get the USART1 clock source ---------------------------------------------*/
;;;965      PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
00006c  6fca              LDR      r2,[r1,#0x7c]
00006e  f0020203          AND      r2,r2,#3
000072  6382              STR      r2,[r0,#0x38]
;;;966      /* Get the USART2 clock source ---------------------------------------------*/
;;;967      PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
000074  6fca              LDR      r2,[r1,#0x7c]
000076  f002020c          AND      r2,r2,#0xc
00007a  63c2              STR      r2,[r0,#0x3c]
;;;968    
;;;969    #if defined(USART3)
;;;970      /* Get the USART3 clock source ---------------------------------------------*/
;;;971      PeriphClkInit->Usart3ClockSelection  = __HAL_RCC_GET_USART3_SOURCE();
00007c  6fca              LDR      r2,[r1,#0x7c]
00007e  f0020230          AND      r2,r2,#0x30
000082  6402              STR      r2,[r0,#0x40]
;;;972    #endif /* USART3 */
;;;973    
;;;974    #if defined(UART4)
;;;975      /* Get the UART4 clock source ----------------------------------------------*/
;;;976      PeriphClkInit->Uart4ClockSelection   = __HAL_RCC_GET_UART4_SOURCE();
000084  6fca              LDR      r2,[r1,#0x7c]
000086  f00202c0          AND      r2,r2,#0xc0
00008a  6442              STR      r2,[r0,#0x44]
;;;977    #endif /* UART4 */
;;;978    
;;;979    #if defined(UART5)
;;;980      /* Get the UART5 clock source ----------------------------------------------*/
;;;981      PeriphClkInit->Uart5ClockSelection   = __HAL_RCC_GET_UART5_SOURCE();
00008c  6fca              LDR      r2,[r1,#0x7c]
00008e  f4027240          AND      r2,r2,#0x300
000092  6482              STR      r2,[r0,#0x48]
;;;982    #endif /* UART5 */
;;;983    
;;;984      /* Get the LPUART1 clock source --------------------------------------------*/
;;;985      PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
000094  6fca              LDR      r2,[r1,#0x7c]
000096  f4026240          AND      r2,r2,#0xc00
00009a  64c2              STR      r2,[r0,#0x4c]
;;;986    
;;;987      /* Get the I2C1 clock source -----------------------------------------------*/
;;;988      PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
00009c  6fca              LDR      r2,[r1,#0x7c]
00009e  f4025240          AND      r2,r2,#0x3000
0000a2  6502              STR      r2,[r0,#0x50]
;;;989    
;;;990    #if defined(I2C2)
;;;991       /* Get the I2C2 clock source ----------------------------------------------*/
;;;992      PeriphClkInit->I2c2ClockSelection    = __HAL_RCC_GET_I2C2_SOURCE();
0000a4  6fca              LDR      r2,[r1,#0x7c]
0000a6  f4024240          AND      r2,r2,#0xc000
0000aa  6542              STR      r2,[r0,#0x54]
;;;993    #endif /* I2C2 */
;;;994    
;;;995      /* Get the I2C3 clock source -----------------------------------------------*/
;;;996      PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
0000ac  6fca              LDR      r2,[r1,#0x7c]
0000ae  f4023240          AND      r2,r2,#0x30000
0000b2  6582              STR      r2,[r0,#0x58]
;;;997    
;;;998    #if defined(I2C4)
;;;999      /* Get the I2C4 clock source -----------------------------------------------*/
;;;1000     PeriphClkInit->I2c4ClockSelection    = __HAL_RCC_GET_I2C4_SOURCE();
0000b4  f8d12090          LDR      r2,[r1,#0x90]
0000b8  f0020203          AND      r2,r2,#3
0000bc  65c2              STR      r2,[r0,#0x5c]
;;;1001   #endif /* I2C4 */
;;;1002   
;;;1003     /* Get the LPTIM1 clock source ---------------------------------------------*/
;;;1004     PeriphClkInit->Lptim1ClockSelection  = __HAL_RCC_GET_LPTIM1_SOURCE();
0000be  6fca              LDR      r2,[r1,#0x7c]
0000c0  f4022240          AND      r2,r2,#0xc0000
0000c4  6602              STR      r2,[r0,#0x60]
;;;1005   
;;;1006     /* Get the LPTIM2 clock source ---------------------------------------------*/
;;;1007     PeriphClkInit->Lptim2ClockSelection  = __HAL_RCC_GET_LPTIM2_SOURCE();
0000c6  6fca              LDR      r2,[r1,#0x7c]
0000c8  f4021240          AND      r2,r2,#0x300000
0000cc  6642              STR      r2,[r0,#0x64]
;;;1008   
;;;1009   #if defined(SAI1)
;;;1010     /* Get the SAI1 clock source -----------------------------------------------*/
;;;1011     PeriphClkInit->Sai1ClockSelection    = __HAL_RCC_GET_SAI1_SOURCE();
0000ce  6fca              LDR      r2,[r1,#0x7c]
0000d0  f4020240          AND      r2,r2,#0xc00000
0000d4  6682              STR      r2,[r0,#0x68]
;;;1012   #endif /* SAI1 */
;;;1013   
;;;1014   #if defined(SAI2)
;;;1015     /* Get the SAI2 clock source -----------------------------------------------*/
;;;1016     PeriphClkInit->Sai2ClockSelection    = __HAL_RCC_GET_SAI2_SOURCE();
0000d6  6fca              LDR      r2,[r1,#0x7c]
0000d8  f0027240          AND      r2,r2,#0x3000000
0000dc  66c2              STR      r2,[r0,#0x6c]
;;;1017   #endif /* SAI2 */
;;;1018   
;;;1019     /* Get the RTC clock source ------------------------------------------------*/
;;;1020     PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
0000de  f8d12084          LDR      r2,[r1,#0x84]
0000e2  f4027240          AND      r2,r2,#0x300
0000e6  f8c02088          STR      r2,[r0,#0x88]
;;;1021   
;;;1022   #if defined(USB_OTG_FS) || defined(USB)
;;;1023     /* Get the USB clock source ------------------------------------------------*/
;;;1024     PeriphClkInit->UsbClockSelection   = __HAL_RCC_GET_USB_SOURCE();
0000ea  6fca              LDR      r2,[r1,#0x7c]
0000ec  f0026240          AND      r2,r2,#0xc000000
0000f0  6702              STR      r2,[r0,#0x70]
;;;1025   #endif /* USB_OTG_FS || USB */
;;;1026   
;;;1027   #if defined(SDMMC1)
;;;1028     /* Get the SDMMC1 clock source ---------------------------------------------*/
;;;1029     PeriphClkInit->Sdmmc1ClockSelection   = __HAL_RCC_GET_SDMMC1_SOURCE();
0000f2  6fca              LDR      r2,[r1,#0x7c]
0000f4  f0026240          AND      r2,r2,#0xc000000
0000f8  6742              STR      r2,[r0,#0x74]
;;;1030   #endif /* SDMMC1 */
;;;1031   
;;;1032     /* Get the RNG clock source ------------------------------------------------*/
;;;1033     PeriphClkInit->RngClockSelection   = __HAL_RCC_GET_RNG_SOURCE();
0000fa  6fca              LDR      r2,[r1,#0x7c]
0000fc  f0026240          AND      r2,r2,#0xc000000
000100  6782              STR      r2,[r0,#0x78]
;;;1034   
;;;1035   #if !defined(STM32L412xx) && !defined(STM32L422xx)
;;;1036     /* Get the ADC clock source ------------------------------------------------*/
;;;1037     PeriphClkInit->AdcClockSelection     = __HAL_RCC_GET_ADC_SOURCE();
000102  6fca              LDR      r2,[r1,#0x7c]
000104  f0025240          AND      r2,r2,#0x30000000
000108  67c2              STR      r2,[r0,#0x7c]
;;;1038   #endif /* !STM32L412xx && !STM32L422xx */
;;;1039   
;;;1040   #if defined(SWPMI1)
;;;1041     /* Get the SWPMI1 clock source ---------------------------------------------*/
;;;1042     PeriphClkInit->Swpmi1ClockSelection  = __HAL_RCC_GET_SWPMI1_SOURCE();
00010a  6fca              LDR      r2,[r1,#0x7c]
00010c  f0024280          AND      r2,r2,#0x40000000
000110  f8c02080          STR      r2,[r0,#0x80]
;;;1043   #endif /* SWPMI1 */
;;;1044   
;;;1045   #if defined(DFSDM1_Filter0)
;;;1046     /* Get the DFSDM1 clock source ---------------------------------------------*/
;;;1047     PeriphClkInit->Dfsdm1ClockSelection  = __HAL_RCC_GET_DFSDM1_SOURCE();
000114  6fc9              LDR      r1,[r1,#0x7c]
000116  f0014100          AND      r1,r1,#0x80000000
00011a  f8c01084          STR      r1,[r0,#0x84]
;;;1048   
;;;1049   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1050     /* Get the DFSDM1 audio clock source ---------------------------------------*/
;;;1051     PeriphClkInit->Dfsdm1AudioClockSelection  = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
;;;1052   #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;1053   #endif /* DFSDM1_Filter0 */
;;;1054   
;;;1055   #if defined(LTDC)
;;;1056     /* Get the LTDC clock source -----------------------------------------------*/
;;;1057     PeriphClkInit->LtdcClockSelection = __HAL_RCC_GET_LTDC_SOURCE();
;;;1058   #endif /* LTDC */
;;;1059   
;;;1060   #if defined(DSI)
;;;1061     /* Get the DSI clock source ------------------------------------------------*/
;;;1062     PeriphClkInit->DsiClockSelection = __HAL_RCC_GET_DSI_SOURCE();
;;;1063   #endif /* DSI */
;;;1064   
;;;1065   #if defined(OCTOSPI1) || defined(OCTOSPI2)
;;;1066     /* Get the OctoSPIclock source --------------------------------------------*/
;;;1067     PeriphClkInit->OspiClockSelection = __HAL_RCC_GET_OSPI_SOURCE();
;;;1068   #endif /* OCTOSPI1 || OCTOSPI2 */
;;;1069   }
00011e  bd30              POP      {r4,r5,pc}
;;;1070   
                          ENDP

                  |L21.288|
                          DCD      0x001fffff
                  |L21.292|
                          DCD      0x4002100c

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;1151     */
;;;1152   uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1153   {
000004  4602              MOV      r2,r0
;;;1154     uint32_t frequency = 0U;
000006  2000              MOVS     r0,#0
;;;1155     uint32_t srcclk, pll_oscsource, pllvco, plln;    /* no init needed */
;;;1156   #if defined(SDMMC1) && defined(RCC_CCIPR2_SDMMCSEL)
;;;1157     uint32_t pllp;  /* no init needed */
;;;1158   #endif
;;;1159   
;;;1160     /* Check the parameters */
;;;1161     assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;1162   
;;;1163     if(PeriphClk == RCC_PERIPHCLK_RTC)
;;;1164     {
;;;1165       /* Get the current RTC source */
;;;1166       srcclk = __HAL_RCC_GET_RTC_SOURCE();
;;;1167   
;;;1168       switch(srcclk)
000008  f44f7780          MOV      r7,#0x100
;;;1169       {
;;;1170       case RCC_RTCCLKSOURCE_LSE:
;;;1171         /* Check if LSE is ready */
;;;1172         if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1173         {
;;;1174           frequency = LSE_VALUE;
00000c  01fd              LSLS     r5,r7,#7
00000e  4bfc              LDR      r3,|L22.1024|
000010  f44f7c00          MOV      r12,#0x200            ;1168
;;;1175         }
;;;1176         break;
;;;1177       case RCC_RTCCLKSOURCE_LSI:
;;;1178         /* Check if LSI is ready */
;;;1179         if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
;;;1180         {
;;;1181   #if defined(RCC_CSR_LSIPREDIV)
;;;1182           if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIPREDIV))
;;;1183           {
;;;1184             frequency = LSI_VALUE/128U;
;;;1185           }
;;;1186           else
;;;1187   #endif /* RCC_CSR_LSIPREDIV */
;;;1188           {
;;;1189             frequency = LSI_VALUE;
000014  f44f46fa          MOV      r6,#0x7d00
000018  f5b23f00          CMP      r2,#0x20000           ;1163
00001c  d034              BEQ      |L22.136|
;;;1190           }
;;;1191         }
;;;1192         break;
;;;1193       case RCC_RTCCLKSOURCE_HSE_DIV32:
;;;1194         /* Check if HSE is ready */
;;;1195         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
;;;1196         {
;;;1197           frequency = HSE_VALUE / 32U;
;;;1198         }
;;;1199         break;
;;;1200       default:
;;;1201         /* No clock source, frequency default init at 0 */
;;;1202         break;
;;;1203       }
;;;1204     }
;;;1205     else
;;;1206     {
;;;1207       /* Other external peripheral clock source than RTC */
;;;1208       pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
00001e  68d9              LDR      r1,[r3,#0xc]
000020  f0010103          AND      r1,r1,#3
;;;1209   
;;;1210       /* Compute PLL clock input */
;;;1211       switch(pll_oscsource)
;;;1212       {
;;;1213       case RCC_PLLSOURCE_MSI:   /* MSI ? */
;;;1214         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1215         {
;;;1216           /*MSI frequency range in HZ*/
;;;1217           pllvco = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
000024  f8df83dc          LDR      r8,|L22.1028|
;;;1218         }
;;;1219         else
;;;1220         {
;;;1221           pllvco = 0U;
;;;1222         }
;;;1223         break;
;;;1224       case RCC_PLLSOURCE_HSI:   /* HSI ? */
;;;1225         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1226         {
;;;1227           pllvco = HSI_VALUE;
000028  4cf7              LDR      r4,|L22.1032|
00002a  2901              CMP      r1,#1                 ;1211
00002c  d048              BEQ      |L22.192|
00002e  2902              CMP      r1,#2                 ;1211
000030  d05b              BEQ      |L22.234|
000032  2903              CMP      r1,#3                 ;1211
000034  d060              BEQ      |L22.248|
;;;1228         }
;;;1229         else
;;;1230         {
;;;1231           pllvco = 0U;
;;;1232         }
;;;1233         break;
;;;1234       case RCC_PLLSOURCE_HSE:   /* HSE ? */
;;;1235         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
;;;1236         {
;;;1237           pllvco = HSE_VALUE;
;;;1238         }
;;;1239         else
;;;1240         {
;;;1241           pllvco = 0U;
;;;1242         }
;;;1243         break;
;;;1244       default:
;;;1245         /* No source */
;;;1246         pllvco = 0U;
000036  2100              MOVS     r1,#0
                  |L22.56|
;;;1247         break;
;;;1248       }
;;;1249   
;;;1250       switch(PeriphClk)
000038  f44f6b80          MOV      r11,#0x400
00003c  f44f5e00          MOV      lr,#0x2000
000040  f44f6900          MOV      r9,#0x800
000044  f44f5a80          MOV      r10,#0x1000
000048  455a              CMP      r2,r11
00004a  d073              BEQ      |L22.308|
00004c  dc73              BGT      |L22.310|
00004e  2a20              CMP      r2,#0x20
000050  d072              BEQ      |L22.312|
000052  dc77              BGT      |L22.324|
000054  2a04              CMP      r2,#4
000056  d071              BEQ      |L22.316|
000058  dc55              BGT      |L22.262|
00005a  2a01              CMP      r2,#1
00005c  d06f              BEQ      |L22.318|
00005e  2a02              CMP      r2,#2
000060  d110              BNE      |L22.132|
;;;1251       {
;;;1252   #if defined(SAI1)
;;;1253   
;;;1254       case RCC_PERIPHCLK_SAI1:
;;;1255         frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI1, pllvco);
;;;1256         break;
;;;1257   
;;;1258   #endif
;;;1259   
;;;1260   #if defined(SAI2)
;;;1261   
;;;1262       case RCC_PERIPHCLK_SAI2:
;;;1263         frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI2, pllvco);
;;;1264         break;
;;;1265   
;;;1266   #endif
;;;1267   
;;;1268   #if defined(USB_OTG_FS) || defined(USB)
;;;1269   
;;;1270       case RCC_PERIPHCLK_USB:
;;;1271   
;;;1272   #endif /* USB_OTG_FS || USB */
;;;1273   
;;;1274       case RCC_PERIPHCLK_RNG:
;;;1275   
;;;1276   #if defined(SDMMC1) && !defined(RCC_CCIPR2_SDMMCSEL)
;;;1277   
;;;1278       case RCC_PERIPHCLK_SDMMC1:
;;;1279   
;;;1280   #endif /* SDMMC1 && !RCC_CCIPR2_SDMMCSEL */
;;;1281         {
;;;1282           srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
;;;1283   
;;;1284           switch(srcclk)
;;;1285           {
;;;1286           case RCC_CCIPR_CLK48SEL:   /* MSI ? */
;;;1287             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1288             {
;;;1289               /*MSI frequency range in HZ*/
;;;1290               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1291             }
;;;1292             break;
;;;1293           case RCC_CCIPR_CLK48SEL_1:  /* PLL ? */
;;;1294             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;1295             {
;;;1296               if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
;;;1297               {
;;;1298                 /* f(PLL Source) * PLLN / PLLM */
;;;1299                 plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;1300                 pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1301                 /* f(PLL48M1CLK) = f(VCO input) / PLLQ */
;;;1302                 frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
;;;1303               }
;;;1304             }
;;;1305             break;
;;;1306   #if defined(RCC_PLLSAI1_SUPPORT)
;;;1307           case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
;;;1308             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
;;;1309             {
;;;1310               if(HAL_IS_BIT_SET(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN))
;;;1311               {
;;;1312                 plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;1313   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;1314                 /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;1315                 /* f(PLLSAI1 Source) * PLLSAI1N / PLLSAI1M */
;;;1316                 pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;1317   #else
;;;1318                 /* f(PLL Source) * PLLSAI1N / PLLM */
;;;1319                 pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1320   #endif
;;;1321                 /* f(PLL48M2CLK) = f(VCOSAI1 input) / PLLSAI1Q */
;;;1322                 frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
;;;1323               }
;;;1324             }
;;;1325             break;
;;;1326   #endif /* RCC_PLLSAI1_SUPPORT */
;;;1327   #if defined(RCC_HSI48_SUPPORT)
;;;1328           case 0U:
;;;1329             if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
;;;1330             {
;;;1331               frequency = HSI48_VALUE;
;;;1332             }
;;;1333             break;
;;;1334   #endif /* RCC_HSI48_SUPPORT */
;;;1335           default:
;;;1336             /* No clock source, frequency default init at 0 */
;;;1337             break;
;;;1338           } /* switch(srcclk) */
;;;1339           break;
;;;1340         }
;;;1341   
;;;1342   #if defined(SDMMC1) && defined(RCC_CCIPR2_SDMMCSEL)
;;;1343   
;;;1344       case RCC_PERIPHCLK_SDMMC1:
;;;1345   
;;;1346         if(HAL_IS_BIT_SET(RCC->CCIPR2, RCC_CCIPR2_SDMMCSEL))  /* PLL "P" ? */
;;;1347         {
;;;1348           if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;1349           {
;;;1350             if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLPEN))
;;;1351             {
;;;1352               /* f(PLL Source) * PLLN / PLLM */
;;;1353               plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;1354               pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1355               /* f(PLLSAI3CLK) = f(VCO input) / PLLP */
;;;1356               pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
;;;1357               if(pllp == 0U)
;;;1358               {
;;;1359                 if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
;;;1360                 {
;;;1361                   pllp = 17U;
;;;1362                 }
;;;1363                 else
;;;1364                 {
;;;1365                   pllp = 7U;
;;;1366                 }
;;;1367               }
;;;1368               frequency = (pllvco / pllp);
;;;1369             }
;;;1370           }
;;;1371         }
;;;1372         else  /* 48MHz from PLL "Q" or MSI or PLLSAI1Q or HSI48 */
;;;1373         {
;;;1374           srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
;;;1375   
;;;1376           switch(srcclk)
;;;1377           {
;;;1378           case RCC_CCIPR_CLK48SEL:   /* MSI ? */
;;;1379             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1380             {
;;;1381               /*MSI frequency range in HZ*/
;;;1382               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1383             }
;;;1384             break;
;;;1385           case RCC_CCIPR_CLK48SEL_1:  /* PLL "Q" ? */
;;;1386             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;1387             {
;;;1388               if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
;;;1389               {
;;;1390                 /* f(PLL Source) * PLLN / PLLM */
;;;1391                 plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;1392                 pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1393                 /* f(PLL48M1CLK) = f(VCO input) / PLLQ */
;;;1394                 frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
;;;1395               }
;;;1396             }
;;;1397             break;
;;;1398           case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
;;;1399             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
;;;1400             {
;;;1401               if(HAL_IS_BIT_SET(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN))
;;;1402               {
;;;1403                 /* f(PLLSAI1 Source) * PLLSAI1N / PLLSAI1M */
;;;1404                 plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;1405                 pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;1406                 /* f(PLL48M2CLK) = f(VCOSAI1 input) / PLLSAI1Q */
;;;1407                 frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
;;;1408               }
;;;1409             }
;;;1410             break;
;;;1411           case 0U:
;;;1412             if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
;;;1413             {
;;;1414               frequency = HSI48_VALUE;
;;;1415             }
;;;1416             break;
;;;1417           default:
;;;1418             /* No clock source, frequency default init at 0 */
;;;1419             break;
;;;1420           } /* switch(srcclk) */
;;;1421         }
;;;1422         break;
;;;1423   
;;;1424   #endif /* SDMMC1 && RCC_CCIPR2_SDMMCSEL */
;;;1425   
;;;1426       case RCC_PERIPHCLK_USART1:
;;;1427         {
;;;1428           /* Get the current USART1 source */
;;;1429           srcclk = __HAL_RCC_GET_USART1_SOURCE();
;;;1430   
;;;1431           switch(srcclk)
;;;1432           {
;;;1433           case RCC_USART1CLKSOURCE_PCLK2:
;;;1434             frequency = HAL_RCC_GetPCLK2Freq();
;;;1435             break;
;;;1436           case RCC_USART1CLKSOURCE_SYSCLK:
;;;1437             frequency = HAL_RCC_GetSysClockFreq();
;;;1438             break;
;;;1439           case RCC_USART1CLKSOURCE_HSI:
;;;1440             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1441             {
;;;1442               frequency = HSI_VALUE;
;;;1443             }
;;;1444             break;
;;;1445           case RCC_USART1CLKSOURCE_LSE:
;;;1446             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1447             {
;;;1448               frequency = LSE_VALUE;
;;;1449             }
;;;1450             break;
;;;1451           default:
;;;1452             /* No clock source, frequency default init at 0 */
;;;1453             break;
;;;1454           }
;;;1455   
;;;1456           break;
;;;1457         }
;;;1458   
;;;1459       case RCC_PERIPHCLK_USART2:
;;;1460         {
;;;1461           /* Get the current USART2 source */
;;;1462           srcclk = __HAL_RCC_GET_USART2_SOURCE();
000062  f8d31088          LDR      r1,[r3,#0x88]
000066  f001010c          AND      r1,r1,#0xc
;;;1463   
;;;1464           switch(srcclk)
00006a  2900              CMP      r1,#0
00006c  d068              BEQ      |L22.320|
00006e  2904              CMP      r1,#4
000070  d067              BEQ      |L22.322|
000072  2908              CMP      r1,#8
000074  d07e              BEQ      |L22.372|
000076  290c              CMP      r1,#0xc
000078  d104              BNE      |L22.132|
;;;1465           {
;;;1466           case RCC_USART2CLKSOURCE_PCLK1:
;;;1467             frequency = HAL_RCC_GetPCLK1Freq();
;;;1468             break;
;;;1469           case RCC_USART2CLKSOURCE_SYSCLK:
;;;1470             frequency = HAL_RCC_GetSysClockFreq();
;;;1471             break;
;;;1472           case RCC_USART2CLKSOURCE_HSI:
;;;1473             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1474             {
;;;1475               frequency = HSI_VALUE;
;;;1476             }
;;;1477             break;
;;;1478           case RCC_USART2CLKSOURCE_LSE:
;;;1479             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
00007a  f8d31090          LDR      r1,[r3,#0x90]
00007e  0789              LSLS     r1,r1,#30
000080  d500              BPL      |L22.132|
;;;1480             {
;;;1481               frequency = LSE_VALUE;
000082  4628              MOV      r0,r5
                  |L22.132|
;;;1482             }
;;;1483             break;
;;;1484           default:
;;;1485             /* No clock source, frequency default init at 0 */
;;;1486             break;
;;;1487           }
;;;1488   
;;;1489           break;
;;;1490         }
;;;1491   
;;;1492   #if defined(USART3)
;;;1493   
;;;1494       case RCC_PERIPHCLK_USART3:
;;;1495         {
;;;1496           /* Get the current USART3 source */
;;;1497           srcclk = __HAL_RCC_GET_USART3_SOURCE();
;;;1498   
;;;1499           switch(srcclk)
;;;1500           {
;;;1501           case RCC_USART3CLKSOURCE_PCLK1:
;;;1502             frequency = HAL_RCC_GetPCLK1Freq();
;;;1503             break;
;;;1504           case RCC_USART3CLKSOURCE_SYSCLK:
;;;1505             frequency = HAL_RCC_GetSysClockFreq();
;;;1506             break;
;;;1507           case RCC_USART3CLKSOURCE_HSI:
;;;1508             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1509             {
;;;1510               frequency = HSI_VALUE;
;;;1511             }
;;;1512             break;
;;;1513           case RCC_USART3CLKSOURCE_LSE:
;;;1514             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1515             {
;;;1516               frequency = LSE_VALUE;
;;;1517             }
;;;1518             break;
;;;1519           default:
;;;1520             /* No clock source, frequency default init at 0 */
;;;1521             break;
;;;1522           }
;;;1523   
;;;1524           break;
;;;1525         }
;;;1526   
;;;1527   #endif /* USART3 */
;;;1528   
;;;1529   #if defined(UART4)
;;;1530   
;;;1531       case RCC_PERIPHCLK_UART4:
;;;1532         {
;;;1533           /* Get the current UART4 source */
;;;1534           srcclk = __HAL_RCC_GET_UART4_SOURCE();
;;;1535   
;;;1536           switch(srcclk)
;;;1537           {
;;;1538           case RCC_UART4CLKSOURCE_PCLK1:
;;;1539             frequency = HAL_RCC_GetPCLK1Freq();
;;;1540             break;
;;;1541           case RCC_UART4CLKSOURCE_SYSCLK:
;;;1542             frequency = HAL_RCC_GetSysClockFreq();
;;;1543             break;
;;;1544           case RCC_UART4CLKSOURCE_HSI:
;;;1545             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1546             {
;;;1547               frequency = HSI_VALUE;
;;;1548             }
;;;1549             break;
;;;1550           case RCC_UART4CLKSOURCE_LSE:
;;;1551             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1552             {
;;;1553               frequency = LSE_VALUE;
;;;1554             }
;;;1555             break;
;;;1556           default:
;;;1557             /* No clock source, frequency default init at 0 */
;;;1558             break;
;;;1559           }
;;;1560   
;;;1561           break;
;;;1562         }
;;;1563   
;;;1564   #endif /* UART4 */
;;;1565   
;;;1566   #if defined(UART5)
;;;1567   
;;;1568       case RCC_PERIPHCLK_UART5:
;;;1569         {
;;;1570           /* Get the current UART5 source */
;;;1571           srcclk = __HAL_RCC_GET_UART5_SOURCE();
;;;1572   
;;;1573           switch(srcclk)
;;;1574           {
;;;1575           case RCC_UART5CLKSOURCE_PCLK1:
;;;1576             frequency = HAL_RCC_GetPCLK1Freq();
;;;1577             break;
;;;1578           case RCC_UART5CLKSOURCE_SYSCLK:
;;;1579             frequency = HAL_RCC_GetSysClockFreq();
;;;1580             break;
;;;1581           case RCC_UART5CLKSOURCE_HSI:
;;;1582             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1583             {
;;;1584               frequency = HSI_VALUE;
;;;1585             }
;;;1586             break;
;;;1587           case RCC_UART5CLKSOURCE_LSE:
;;;1588             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1589             {
;;;1590               frequency = LSE_VALUE;
;;;1591             }
;;;1592             break;
;;;1593           default:
;;;1594             /* No clock source, frequency default init at 0 */
;;;1595             break;
;;;1596           }
;;;1597   
;;;1598           break;
;;;1599         }
;;;1600   
;;;1601   #endif /* UART5 */
;;;1602   
;;;1603       case RCC_PERIPHCLK_LPUART1:
;;;1604         {
;;;1605           /* Get the current LPUART1 source */
;;;1606           srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
;;;1607   
;;;1608           switch(srcclk)
;;;1609           {
;;;1610           case RCC_LPUART1CLKSOURCE_PCLK1:
;;;1611             frequency = HAL_RCC_GetPCLK1Freq();
;;;1612             break;
;;;1613           case RCC_LPUART1CLKSOURCE_SYSCLK:
;;;1614             frequency = HAL_RCC_GetSysClockFreq();
;;;1615             break;
;;;1616           case RCC_LPUART1CLKSOURCE_HSI:
;;;1617             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1618             {
;;;1619               frequency = HSI_VALUE;
;;;1620             }
;;;1621             break;
;;;1622           case RCC_LPUART1CLKSOURCE_LSE:
;;;1623             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1624             {
;;;1625               frequency = LSE_VALUE;
;;;1626             }
;;;1627             break;
;;;1628           default:
;;;1629             /* No clock source, frequency default init at 0 */
;;;1630             break;
;;;1631           }
;;;1632   
;;;1633           break;
;;;1634         }
;;;1635   
;;;1636       case RCC_PERIPHCLK_ADC:
;;;1637         {
;;;1638           srcclk = __HAL_RCC_GET_ADC_SOURCE();
;;;1639   
;;;1640           switch(srcclk)
;;;1641           {
;;;1642           case RCC_ADCCLKSOURCE_SYSCLK:
;;;1643             frequency = HAL_RCC_GetSysClockFreq();
;;;1644             break;
;;;1645   #if defined(RCC_PLLSAI1_SUPPORT)
;;;1646           case RCC_ADCCLKSOURCE_PLLSAI1:
;;;1647             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_ADC1CLK) != 0U))
;;;1648             {
;;;1649               plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;1650   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;1651               /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;1652               /* f(PLLSAI1 Source) * PLLSAI1N / PLLSAI1M */
;;;1653               pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;1654   #else
;;;1655               /* f(PLL Source) * PLLSAI1N / PLLM */
;;;1656               pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1657   #endif
;;;1658               /* f(PLLADC1CLK) = f(VCOSAI1 input) / PLLSAI1R */
;;;1659               frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U));
;;;1660             }
;;;1661             break;
;;;1662   #endif /* RCC_PLLSAI1_SUPPORT */
;;;1663   #if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) || defined(STM32L496xx) || defined(STM32L4A6xx)
;;;1664           case RCC_ADCCLKSOURCE_PLLSAI2:
;;;1665             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI2RDY) && (__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_ADC2CLK) != 0U))
;;;1666             {
;;;1667               plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
;;;1668   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;1669               /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
;;;1670               /* f(PLLSAI2 Source) * PLLSAI2N / PLLSAI2M */
;;;1671               pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
;;;1672   #else
;;;1673               /* f(PLL Source) * PLLSAI2N / PLLM */
;;;1674               pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;1675   #endif
;;;1676               /* f(PLLADC2CLK) = f(VCOSAI2 input) / PLLSAI2R */
;;;1677               frequency = (pllvco / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) << 1U));
;;;1678             }
;;;1679             break;
;;;1680   #endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx || STM32L496xx || STM32L4A6xx */
;;;1681           default:
;;;1682             /* No clock source, frequency default init at 0 */
;;;1683             break;
;;;1684           }
;;;1685   
;;;1686           break;
;;;1687         }
;;;1688   
;;;1689   #if defined(DFSDM1_Filter0)
;;;1690   
;;;1691       case RCC_PERIPHCLK_DFSDM1:
;;;1692         {
;;;1693           /* Get the current DFSDM1 source */
;;;1694           srcclk = __HAL_RCC_GET_DFSDM1_SOURCE();
;;;1695   
;;;1696           if(srcclk == RCC_DFSDM1CLKSOURCE_PCLK2)
;;;1697           {
;;;1698             frequency = HAL_RCC_GetPCLK2Freq();
;;;1699           }
;;;1700           else
;;;1701           {
;;;1702             frequency = HAL_RCC_GetSysClockFreq();
;;;1703           }
;;;1704   
;;;1705           break;
;;;1706         }
;;;1707   
;;;1708   #if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1709   
;;;1710       case RCC_PERIPHCLK_DFSDM1AUDIO:
;;;1711         {
;;;1712           /* Get the current DFSDM1 audio source */
;;;1713           srcclk = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
;;;1714   
;;;1715           switch(srcclk)
;;;1716           {
;;;1717           case RCC_DFSDM1AUDIOCLKSOURCE_SAI1:
;;;1718             frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI1, pllvco);
;;;1719             break;
;;;1720           case RCC_DFSDM1AUDIOCLKSOURCE_MSI:
;;;1721             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1722             {
;;;1723               /*MSI frequency range in HZ*/
;;;1724               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1725             }
;;;1726             break;
;;;1727           case RCC_DFSDM1AUDIOCLKSOURCE_HSI:
;;;1728             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1729             {
;;;1730               frequency = HSI_VALUE;
;;;1731             }
;;;1732             break;
;;;1733           default:
;;;1734             /* No clock source, frequency default init at 0 */
;;;1735             break;
;;;1736           }
;;;1737   
;;;1738           break;
;;;1739         }
;;;1740   
;;;1741   #endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;1742   
;;;1743   #endif /* DFSDM1_Filter0 */
;;;1744   
;;;1745       case RCC_PERIPHCLK_I2C1:
;;;1746         {
;;;1747           /* Get the current I2C1 source */
;;;1748           srcclk = __HAL_RCC_GET_I2C1_SOURCE();
;;;1749   
;;;1750           switch(srcclk)
;;;1751           {
;;;1752           case RCC_I2C1CLKSOURCE_PCLK1:
;;;1753             frequency = HAL_RCC_GetPCLK1Freq();
;;;1754             break;
;;;1755           case RCC_I2C1CLKSOURCE_SYSCLK:
;;;1756             frequency = HAL_RCC_GetSysClockFreq();
;;;1757             break;
;;;1758           case RCC_I2C1CLKSOURCE_HSI:
;;;1759             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1760             {
;;;1761               frequency = HSI_VALUE;
;;;1762             }
;;;1763             break;
;;;1764           default:
;;;1765             /* No clock source, frequency default init at 0 */
;;;1766             break;
;;;1767           }
;;;1768   
;;;1769           break;
;;;1770         }
;;;1771   
;;;1772   #if defined(I2C2)
;;;1773   
;;;1774       case RCC_PERIPHCLK_I2C2:
;;;1775         {
;;;1776           /* Get the current I2C2 source */
;;;1777           srcclk = __HAL_RCC_GET_I2C2_SOURCE();
;;;1778   
;;;1779           switch(srcclk)
;;;1780           {
;;;1781           case RCC_I2C2CLKSOURCE_PCLK1:
;;;1782             frequency = HAL_RCC_GetPCLK1Freq();
;;;1783             break;
;;;1784           case RCC_I2C2CLKSOURCE_SYSCLK:
;;;1785             frequency = HAL_RCC_GetSysClockFreq();
;;;1786             break;
;;;1787           case RCC_I2C2CLKSOURCE_HSI:
;;;1788             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1789             {
;;;1790               frequency = HSI_VALUE;
;;;1791             }
;;;1792             break;
;;;1793           default:
;;;1794             /* No clock source, frequency default init at 0 */
;;;1795             break;
;;;1796           }
;;;1797   
;;;1798           break;
;;;1799         }
;;;1800   
;;;1801   #endif /* I2C2 */
;;;1802   
;;;1803       case RCC_PERIPHCLK_I2C3:
;;;1804         {
;;;1805           /* Get the current I2C3 source */
;;;1806           srcclk = __HAL_RCC_GET_I2C3_SOURCE();
;;;1807   
;;;1808           switch(srcclk)
;;;1809           {
;;;1810           case RCC_I2C3CLKSOURCE_PCLK1:
;;;1811             frequency = HAL_RCC_GetPCLK1Freq();
;;;1812             break;
;;;1813           case RCC_I2C3CLKSOURCE_SYSCLK:
;;;1814             frequency = HAL_RCC_GetSysClockFreq();
;;;1815             break;
;;;1816           case RCC_I2C3CLKSOURCE_HSI:
;;;1817             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1818             {
;;;1819               frequency = HSI_VALUE;
;;;1820             }
;;;1821             break;
;;;1822           default:
;;;1823             /* No clock source, frequency default init at 0 */
;;;1824             break;
;;;1825           }
;;;1826   
;;;1827           break;
;;;1828         }
;;;1829   
;;;1830   #if defined(I2C4)
;;;1831   
;;;1832       case RCC_PERIPHCLK_I2C4:
;;;1833         {
;;;1834           /* Get the current I2C4 source */
;;;1835           srcclk = __HAL_RCC_GET_I2C4_SOURCE();
;;;1836   
;;;1837           switch(srcclk)
;;;1838           {
;;;1839           case RCC_I2C4CLKSOURCE_PCLK1:
;;;1840             frequency = HAL_RCC_GetPCLK1Freq();
;;;1841             break;
;;;1842           case RCC_I2C4CLKSOURCE_SYSCLK:
;;;1843             frequency = HAL_RCC_GetSysClockFreq();
;;;1844             break;
;;;1845           case RCC_I2C4CLKSOURCE_HSI:
;;;1846             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1847             {
;;;1848               frequency = HSI_VALUE;
;;;1849             }
;;;1850             break;
;;;1851           default:
;;;1852             /* No clock source, frequency default init at 0 */
;;;1853             break;
;;;1854           }
;;;1855   
;;;1856           break;
;;;1857         }
;;;1858   
;;;1859   #endif /* I2C4 */
;;;1860   
;;;1861       case RCC_PERIPHCLK_LPTIM1:
;;;1862         {
;;;1863           /* Get the current LPTIM1 source */
;;;1864           srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
;;;1865   
;;;1866           switch(srcclk)
;;;1867           {
;;;1868           case RCC_LPTIM1CLKSOURCE_PCLK1:
;;;1869             frequency = HAL_RCC_GetPCLK1Freq();
;;;1870             break;
;;;1871           case RCC_LPTIM1CLKSOURCE_LSI:
;;;1872             if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
;;;1873             {
;;;1874   #if defined(RCC_CSR_LSIPREDIV)
;;;1875               if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIPREDIV))
;;;1876               {
;;;1877                 frequency = LSI_VALUE/128U;
;;;1878               }
;;;1879               else
;;;1880   #endif /* RCC_CSR_LSIPREDIV */
;;;1881               {
;;;1882                 frequency = LSI_VALUE;
;;;1883               }
;;;1884             }
;;;1885             break;
;;;1886           case RCC_LPTIM1CLKSOURCE_HSI:
;;;1887             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1888             {
;;;1889               frequency = HSI_VALUE;
;;;1890             }
;;;1891             break;
;;;1892           case RCC_LPTIM1CLKSOURCE_LSE:
;;;1893             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1894             {
;;;1895               frequency = LSE_VALUE;
;;;1896             }
;;;1897             break;
;;;1898           default:
;;;1899             /* No clock source, frequency default init at 0 */
;;;1900             break;
;;;1901           }
;;;1902   
;;;1903           break;
;;;1904         }
;;;1905   
;;;1906       case RCC_PERIPHCLK_LPTIM2:
;;;1907         {
;;;1908           /* Get the current LPTIM2 source */
;;;1909          srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
;;;1910   
;;;1911           switch(srcclk)
;;;1912           {
;;;1913           case RCC_LPTIM2CLKSOURCE_PCLK1:
;;;1914             frequency = HAL_RCC_GetPCLK1Freq();
;;;1915             break;
;;;1916           case RCC_LPTIM2CLKSOURCE_LSI:
;;;1917             if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
;;;1918             {
;;;1919   #if defined(RCC_CSR_LSIPREDIV)
;;;1920               if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIPREDIV))
;;;1921               {
;;;1922                 frequency = LSI_VALUE/128U;
;;;1923               }
;;;1924               else
;;;1925   #endif /* RCC_CSR_LSIPREDIV */
;;;1926               {
;;;1927                 frequency = LSI_VALUE;
;;;1928               }
;;;1929             }
;;;1930             break;
;;;1931           case RCC_LPTIM2CLKSOURCE_HSI:
;;;1932             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1933             {
;;;1934               frequency = HSI_VALUE;
;;;1935             }
;;;1936             break;
;;;1937           case RCC_LPTIM2CLKSOURCE_LSE:
;;;1938             if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
;;;1939             {
;;;1940               frequency = LSE_VALUE;
;;;1941             }
;;;1942             break;
;;;1943           default:
;;;1944             /* No clock source, frequency default init at 0 */
;;;1945             break;
;;;1946           }
;;;1947   
;;;1948           break;
;;;1949         }
;;;1950   
;;;1951   #if defined(SWPMI1)
;;;1952   
;;;1953       case RCC_PERIPHCLK_SWPMI1:
;;;1954         {
;;;1955           /* Get the current SWPMI1 source */
;;;1956           srcclk = __HAL_RCC_GET_SWPMI1_SOURCE();
;;;1957   
;;;1958           switch(srcclk)
;;;1959           {
;;;1960           case RCC_SWPMI1CLKSOURCE_PCLK1:
;;;1961             frequency = HAL_RCC_GetPCLK1Freq();
;;;1962             break;
;;;1963           case RCC_SWPMI1CLKSOURCE_HSI:
;;;1964             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;1965             {
;;;1966               frequency = HSI_VALUE;
;;;1967             }
;;;1968             break;
;;;1969           default:
;;;1970             /* No clock source, frequency default init at 0 */
;;;1971             break;
;;;1972           }
;;;1973   
;;;1974           break;
;;;1975         }
;;;1976   
;;;1977   #endif /* SWPMI1 */
;;;1978   
;;;1979   #if defined(OCTOSPI1) || defined(OCTOSPI2)
;;;1980   
;;;1981       case RCC_PERIPHCLK_OSPI:
;;;1982         {
;;;1983           /* Get the current OctoSPI clock source */
;;;1984           srcclk = __HAL_RCC_GET_OSPI_SOURCE();
;;;1985   
;;;1986           switch(srcclk)
;;;1987           {
;;;1988           case RCC_OSPICLKSOURCE_SYSCLK:
;;;1989             frequency = HAL_RCC_GetSysClockFreq();
;;;1990             break;
;;;1991           case RCC_OSPICLKSOURCE_MSI:
;;;1992             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
;;;1993             {
;;;1994               /*MSI frequency range in HZ*/
;;;1995               frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
;;;1996             }
;;;1997             break;
;;;1998           case RCC_OSPICLKSOURCE_PLL:
;;;1999             if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
;;;2000             {
;;;2001               if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
;;;2002               {
;;;2003                 /* f(PLL Source) * PLLN / PLLM */
;;;2004                 plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;2005                 pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;2006                 /* f(PLL48M1CLK) = f(VCO input) / PLLQ */
;;;2007                 frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
;;;2008               }
;;;2009             }
;;;2010             break;
;;;2011           default:
;;;2012             /* No clock source, frequency default init at 0 */
;;;2013             break;
;;;2014           }
;;;2015   
;;;2016           break;
;;;2017         }
;;;2018   
;;;2019   #endif /* OCTOSPI1 || OCTOSPI2 */
;;;2020   
;;;2021       default:
;;;2022         break;
;;;2023       }
;;;2024     }
;;;2025   
;;;2026     return(frequency);
;;;2027   }
000084  e8bd9ff0          POP      {r4-r12,pc}
                  |L22.136|
000088  f8d31090          LDR      r1,[r3,#0x90]         ;1166
00008c  f4017140          AND      r1,r1,#0x300          ;1166
000090  42b9              CMP      r1,r7                 ;1168
000092  d009              BEQ      |L22.168|
000094  4561              CMP      r1,r12                ;1168
000096  d00d              BEQ      |L22.180|
000098  f5b17f40          CMP      r1,#0x300             ;1168
00009c  d1f2              BNE      |L22.132|
00009e  6819              LDR      r1,[r3,#0]            ;1195
0000a0  0389              LSLS     r1,r1,#14             ;1195
0000a2  d5ef              BPL      |L22.132|
0000a4  48d9              LDR      r0,|L22.1036|
                  |L22.166|
0000a6  e7ed              B        |L22.132|
                  |L22.168|
0000a8  f8d31090          LDR      r1,[r3,#0x90]         ;1172
0000ac  0789              LSLS     r1,r1,#30             ;1172
0000ae  d5e9              BPL      |L22.132|
0000b0  4628              MOV      r0,r5                 ;1174
0000b2  e7e7              B        |L22.132|
                  |L22.180|
0000b4  f8d31094          LDR      r1,[r3,#0x94]         ;1179
0000b8  0789              LSLS     r1,r1,#30             ;1179
0000ba  d5e3              BPL      |L22.132|
0000bc  4630              MOV      r0,r6                 ;1189
                  |L22.190|
0000be  e7e1              B        |L22.132|
                  |L22.192|
0000c0  6819              LDR      r1,[r3,#0]            ;1214
0000c2  0789              LSLS     r1,r1,#30             ;1214
0000c4  d50f              BPL      |L22.230|
0000c6  6819              LDR      r1,[r3,#0]            ;1217
0000c8  0709              LSLS     r1,r1,#28             ;1217
0000ca  d503              BPL      |L22.212|
0000cc  6819              LDR      r1,[r3,#0]            ;1217
0000ce  f00101f0          AND      r1,r1,#0xf0           ;1217
0000d2  e004              B        |L22.222|
                  |L22.212|
0000d4  f8d31094          LDR      r1,[r3,#0x94]         ;1217
0000d8  f4016170          AND      r1,r1,#0xf00          ;1217
0000dc  0909              LSRS     r1,r1,#4              ;1217
                  |L22.222|
0000de  0909              LSRS     r1,r1,#4              ;1217
0000e0  f8581021          LDR      r1,[r8,r1,LSL #2]     ;1217
0000e4  e7a8              B        |L22.56|
                  |L22.230|
0000e6  2100              MOVS     r1,#0                 ;1221
0000e8  e7a6              B        |L22.56|
                  |L22.234|
0000ea  6819              LDR      r1,[r3,#0]            ;1225
0000ec  0549              LSLS     r1,r1,#21             ;1225
0000ee  d501              BPL      |L22.244|
0000f0  4621              MOV      r1,r4                 ;1227
0000f2  e7a1              B        |L22.56|
                  |L22.244|
0000f4  2100              MOVS     r1,#0                 ;1231
0000f6  e79f              B        |L22.56|
                  |L22.248|
0000f8  6819              LDR      r1,[r3,#0]            ;1235
0000fa  0389              LSLS     r1,r1,#14             ;1235
0000fc  d501              BPL      |L22.258|
0000fe  49c4              LDR      r1,|L22.1040|
000100  e79a              B        |L22.56|
                  |L22.258|
000102  2100              MOVS     r1,#0                 ;1241
000104  e798              B        |L22.56|
                  |L22.262|
000106  2a08              CMP      r2,#8                 ;1250
000108  d073              BEQ      |L22.498|
00010a  2a10              CMP      r2,#0x10              ;1250
00010c  d1ba              BNE      |L22.132|
00010e  f8d31088          LDR      r1,[r3,#0x88]         ;1571
000112  f4017140          AND      r1,r1,#0x300          ;1571
000116  2900              CMP      r1,#0                 ;1573
000118  d06c              BEQ      |L22.500|
00011a  42b9              CMP      r1,r7                 ;1573
00011c  d06b              BEQ      |L22.502|
00011e  4561              CMP      r1,r12                ;1573
000120  d06a              BEQ      |L22.504|
000122  f5b17f40          CMP      r1,#0x300             ;1573
000126  d1ad              BNE      |L22.132|
000128  f8d31090          LDR      r1,[r3,#0x90]         ;1588
00012c  0789              LSLS     r1,r1,#30             ;1588
00012e  d5a9              BPL      |L22.132|
000130  4628              MOV      r0,r5                 ;1590
                  |L22.306|
000132  e7a7              B        |L22.132|
                  |L22.308|
000134  e209              B        |L22.1354|
                  |L22.310|
000136  e024              B        |L22.386|
                  |L22.312|
000138  e143              B        |L22.962|
00013a  e003              B        |L22.324|
                  |L22.316|
00013c  e0f8              B        |L22.816|
                  |L22.318|
00013e  e0cc              B        |L22.730|
                  |L22.320|
000140  e0e9              B        |L22.790|
                  |L22.322|
000142  e0ec              B        |L22.798|
                  |L22.324|
000144  2a40              CMP      r2,#0x40              ;1250
000146  d07a              BEQ      |L22.574|
000148  2a80              CMP      r2,#0x80              ;1250
00014a  d079              BEQ      |L22.576|
00014c  42ba              CMP      r2,r7                 ;1250
00014e  d078              BEQ      |L22.578|
000150  4562              CMP      r2,r12                ;1250
000152  d197              BNE      |L22.132|
000154  f8d31088          LDR      r1,[r3,#0x88]         ;1864
000158  f4012140          AND      r1,r1,#0xc0000        ;1864
00015c  2900              CMP      r1,#0                 ;1866
00015e  d071              BEQ      |L22.580|
000160  f5b12f80          CMP      r1,#0x40000           ;1866
000164  d06f              BEQ      |L22.582|
000166  f5b12f00          CMP      r1,#0x80000           ;1866
00016a  d06d              BEQ      |L22.584|
00016c  f5b12f40          CMP      r1,#0xc0000           ;1866
000170  d188              BNE      |L22.132|
000172  e000              B        |L22.374|
                  |L22.372|
000174  e0d7              B        |L22.806|
                  |L22.374|
000176  f8d31090          LDR      r1,[r3,#0x90]         ;1893
00017a  0789              LSLS     r1,r1,#30             ;1893
00017c  d582              BPL      |L22.132|
00017e  4628              MOV      r0,r5                 ;1895
                  |L22.384|
000180  e780              B        |L22.132|
                  |L22.386|
000182  42aa              CMP      r2,r5                 ;1250
000184  d07e              BEQ      |L22.644|
000186  dc19              BGT      |L22.444|
000188  454a              CMP      r2,r9                 ;1250
00018a  d036              BEQ      |L22.506|
00018c  4552              CMP      r2,r10                ;1250
00018e  d039              BEQ      |L22.516|
000190  4572              CMP      r2,lr                 ;1250
000192  d03c              BEQ      |L22.526|
000194  f5b24f80          CMP      r2,#0x4000            ;1250
000198  d185              BNE      |L22.166|
00019a  f8d32088          LDR      r2,[r3,#0x88]         ;1638
00019e  f0025240          AND      r2,r2,#0x30000000     ;1638
0001a2  f1b25f80          CMP      r2,#0x10000000        ;1640
0001a6  d06f              BEQ      |L22.648|
0001a8  f1b25f00          CMP      r2,#0x20000000        ;1640
0001ac  d06d              BEQ      |L22.650|
0001ae  f1b25f40          CMP      r2,#0x30000000        ;1640
0001b2  d184              BNE      |L22.190|
0001b4  e8bd5ff0          POP      {r4-r12,lr}           ;1643
0001b8  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.444|
0001bc  f5b23f80          CMP      r2,#0x10000           ;1250
0001c0  d07e              BEQ      |L22.704|
0001c2  f5b22f80          CMP      r2,#0x40000           ;1250
0001c6  d022              BEQ      |L22.526|
0001c8  f5b22f00          CMP      r2,#0x80000           ;1250
0001cc  d01f              BEQ      |L22.526|
0001ce  f5b21f80          CMP      r2,#0x100000          ;1250
0001d2  d1ae              BNE      |L22.306|
0001d4  f8d3109c          LDR      r1,[r3,#0x9c]         ;1835
0001d8  f0010103          AND      r1,r1,#3              ;1835
0001dc  2900              CMP      r1,#0                 ;1837
0001de  d070              BEQ      |L22.706|
0001e0  2901              CMP      r1,#1                 ;1837
0001e2  d06f              BEQ      |L22.708|
0001e4  2902              CMP      r1,#2                 ;1837
0001e6  d1a4              BNE      |L22.306|
0001e8  6819              LDR      r1,[r3,#0]            ;1846
0001ea  0549              LSLS     r1,r1,#21             ;1846
0001ec  d5a1              BPL      |L22.306|
0001ee  4620              MOV      r0,r4                 ;1848
                  |L22.496|
0001f0  e748              B        |L22.132|
                  |L22.498|
0001f2  e0bb              B        |L22.876|
                  |L22.500|
0001f4  e0d8              B        |L22.936|
                  |L22.502|
0001f6  e0db              B        |L22.944|
                  |L22.504|
0001f8  e0de              B        |L22.952|
                  |L22.506|
0001fa  4648              MOV      r0,r9                 ;1255
0001fc  e8bd5ff0          POP      {r4-r12,lr}           ;1255
000200  f7ffbffe          B.W      RCCEx_GetSAIxPeriphCLKFreq
                  |L22.516|
000204  4650              MOV      r0,r10                ;1263
000206  e8bd5ff0          POP      {r4-r12,lr}           ;1263
00020a  f7ffbffe          B.W      RCCEx_GetSAIxPeriphCLKFreq
                  |L22.526|
00020e  f8d32088          LDR      r2,[r3,#0x88]         ;1282
000212  f0026240          AND      r2,r2,#0xc000000      ;1282
000216  b3b2              CBZ      r2,|L22.646|
000218  f1b26f80          CMP      r2,#0x4000000         ;1284
00021c  d03b              BEQ      |L22.662|
00021e  f1b26f00          CMP      r2,#0x8000000         ;1284
000222  d01b              BEQ      |L22.604|
000224  f1b26f40          CMP      r2,#0xc000000         ;1284
000228  d1aa              BNE      |L22.384|
00022a  6819              LDR      r1,[r3,#0]            ;1287
00022c  0789              LSLS     r1,r1,#30             ;1287
00022e  d5a7              BPL      |L22.384|
000230  6818              LDR      r0,[r3,#0]            ;1290
000232  0700              LSLS     r0,r0,#28             ;1290
000234  d509              BPL      |L22.586|
000236  6818              LDR      r0,[r3,#0]            ;1290
000238  f00000f0          AND      r0,r0,#0xf0           ;1290
00023c  e00a              B        |L22.596|
                  |L22.574|
00023e  e128              B        |L22.1170|
                  |L22.576|
000240  e13d              B        |L22.1214|
                  |L22.578|
000242  e153              B        |L22.1260|
                  |L22.580|
000244  e172              B        |L22.1324|
                  |L22.582|
000246  e175              B        |L22.1332|
                  |L22.584|
000248  e17a              B        |L22.1344|
                  |L22.586|
00024a  f8d30094          LDR      r0,[r3,#0x94]         ;1290
00024e  f4006070          AND      r0,r0,#0xf00          ;1290
000252  0900              LSRS     r0,r0,#4              ;1290
                  |L22.596|
000254  0900              LSRS     r0,r0,#4              ;1290
000256  f8580020          LDR      r0,[r8,r0,LSL #2]     ;1290
                  |L22.602|
00025a  e713              B        |L22.132|
                  |L22.604|
00025c  681a              LDR      r2,[r3,#0]            ;1294
00025e  0192              LSLS     r2,r2,#6              ;1294
000260  d58e              BPL      |L22.384|
000262  68da              LDR      r2,[r3,#0xc]          ;1296
000264  02d2              LSLS     r2,r2,#11             ;1296
000266  d58b              BPL      |L22.384|
000268  68d8              LDR      r0,[r3,#0xc]          ;1299
00026a  f3c02006          UBFX     r0,r0,#8,#7           ;1299
00026e  4341              MULS     r1,r0,r1              ;1300
000270  68d8              LDR      r0,[r3,#0xc]          ;1300
000272  f3c01002          UBFX     r0,r0,#4,#3           ;1300
000276  1c40              ADDS     r0,r0,#1              ;1300
000278  fbb1f0f0          UDIV     r0,r1,r0              ;1300
00027c  68d9              LDR      r1,[r3,#0xc]          ;1302
00027e  f3c15141          UBFX     r1,r1,#21,#2          ;1302
000282  e003              B        |L22.652|
                  |L22.644|
000284  e184              B        |L22.1424|
                  |L22.646|
000286  e022              B        |L22.718|
                  |L22.648|
000288  e0c6              B        |L22.1048|
                  |L22.650|
00028a  e0dd              B        |L22.1096|
                  |L22.652|
00028c  1c49              ADDS     r1,r1,#1              ;1302
00028e  0049              LSLS     r1,r1,#1              ;1302
000290  fbb0f0f1          UDIV     r0,r0,r1              ;1302
                  |L22.660|
000294  e6f6              B        |L22.132|
                  |L22.662|
000296  681a              LDR      r2,[r3,#0]            ;1308
000298  0112              LSLS     r2,r2,#4              ;1308
00029a  d5a9              BPL      |L22.496|
00029c  691a              LDR      r2,[r3,#0x10]         ;1310
00029e  02d2              LSLS     r2,r2,#11             ;1310
0002a0  d5a6              BPL      |L22.496|
0002a2  6918              LDR      r0,[r3,#0x10]         ;1312
0002a4  f3c02006          UBFX     r0,r0,#8,#7           ;1312
0002a8  4341              MULS     r1,r0,r1              ;1319
0002aa  68d8              LDR      r0,[r3,#0xc]          ;1319
0002ac  f3c01002          UBFX     r0,r0,#4,#3           ;1319
0002b0  1c40              ADDS     r0,r0,#1              ;1319
0002b2  fbb1f0f0          UDIV     r0,r1,r0              ;1319
0002b6  6919              LDR      r1,[r3,#0x10]         ;1322
0002b8  f3c15141          UBFX     r1,r1,#21,#2          ;1322
0002bc  1c49              ADDS     r1,r1,#1              ;1322
0002be  e002              B        |L22.710|
                  |L22.704|
0002c0  e0da              B        |L22.1144|
                  |L22.706|
0002c2  e12b              B        |L22.1308|
                  |L22.708|
0002c4  e12e              B        |L22.1316|
                  |L22.710|
0002c6  0049              LSLS     r1,r1,#1              ;1322
0002c8  fbb0f0f1          UDIV     r0,r0,r1              ;1322
                  |L22.716|
0002cc  e6da              B        |L22.132|
                  |L22.718|
0002ce  f8d31098          LDR      r1,[r3,#0x98]         ;1329
0002d2  0789              LSLS     r1,r1,#30             ;1329
0002d4  d58c              BPL      |L22.496|
0002d6  484f              LDR      r0,|L22.1044|
0002d8  e6d4              B        |L22.132|
                  |L22.730|
0002da  f8d31088          LDR      r1,[r3,#0x88]         ;1429
0002de  f0010103          AND      r1,r1,#3              ;1429
0002e2  b159              CBZ      r1,|L22.764|
0002e4  2901              CMP      r1,#1                 ;1431
0002e6  d00d              BEQ      |L22.772|
0002e8  2902              CMP      r1,#2                 ;1431
0002ea  d00f              BEQ      |L22.780|
0002ec  2903              CMP      r1,#3                 ;1431
0002ee  d1b4              BNE      |L22.602|
0002f0  f8d31090          LDR      r1,[r3,#0x90]         ;1446
0002f4  0789              LSLS     r1,r1,#30             ;1446
0002f6  d5b0              BPL      |L22.602|
0002f8  4628              MOV      r0,r5                 ;1448
                  |L22.762|
0002fa  e6c3              B        |L22.132|
                  |L22.764|
0002fc  e8bd5ff0          POP      {r4-r12,lr}           ;1434
000300  f7ffbffe          B.W      HAL_RCC_GetPCLK2Freq
                  |L22.772|
000304  e8bd5ff0          POP      {r4-r12,lr}           ;1437
000308  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.780|
00030c  6819              LDR      r1,[r3,#0]            ;1440
00030e  0549              LSLS     r1,r1,#21             ;1440
000310  d5a3              BPL      |L22.602|
000312  4620              MOV      r0,r4                 ;1442
                  |L22.788|
000314  e6b6              B        |L22.132|
                  |L22.790|
000316  e8bd5ff0          POP      {r4-r12,lr}           ;1467
00031a  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.798|
00031e  e8bd5ff0          POP      {r4-r12,lr}           ;1470
000322  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.806|
000326  6819              LDR      r1,[r3,#0]            ;1473
000328  0549              LSLS     r1,r1,#21             ;1473
00032a  d596              BPL      |L22.602|
00032c  4620              MOV      r0,r4                 ;1475
                  |L22.814|
00032e  e6a9              B        |L22.132|
                  |L22.816|
000330  f8d31088          LDR      r1,[r3,#0x88]         ;1497
000334  f0010130          AND      r1,r1,#0x30           ;1497
000338  b159              CBZ      r1,|L22.850|
00033a  2910              CMP      r1,#0x10              ;1499
00033c  d00d              BEQ      |L22.858|
00033e  2920              CMP      r1,#0x20              ;1499
000340  d00f              BEQ      |L22.866|
000342  2930              CMP      r1,#0x30              ;1499
000344  d189              BNE      |L22.602|
000346  f8d31090          LDR      r1,[r3,#0x90]         ;1514
00034a  0789              LSLS     r1,r1,#30             ;1514
00034c  d585              BPL      |L22.602|
00034e  4628              MOV      r0,r5                 ;1516
000350  e698              B        |L22.132|
                  |L22.850|
000352  e8bd5ff0          POP      {r4-r12,lr}           ;1502
000356  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.858|
00035a  e8bd5ff0          POP      {r4-r12,lr}           ;1505
00035e  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.866|
000362  6819              LDR      r1,[r3,#0]            ;1508
000364  0549              LSLS     r1,r1,#21             ;1508
000366  d595              BPL      |L22.660|
000368  4620              MOV      r0,r4                 ;1510
                  |L22.874|
00036a  e68b              B        |L22.132|
                  |L22.876|
00036c  f8d31088          LDR      r1,[r3,#0x88]         ;1534
000370  f00101c0          AND      r1,r1,#0xc0           ;1534
000374  b159              CBZ      r1,|L22.910|
000376  2940              CMP      r1,#0x40              ;1536
000378  d00d              BEQ      |L22.918|
00037a  2980              CMP      r1,#0x80              ;1536
00037c  d00f              BEQ      |L22.926|
00037e  29c0              CMP      r1,#0xc0              ;1536
000380  d188              BNE      |L22.660|
000382  f8d31090          LDR      r1,[r3,#0x90]         ;1551
000386  0789              LSLS     r1,r1,#30             ;1551
000388  d584              BPL      |L22.660|
00038a  4628              MOV      r0,r5                 ;1553
00038c  e67a              B        |L22.132|
                  |L22.910|
00038e  e8bd5ff0          POP      {r4-r12,lr}           ;1539
000392  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.918|
000396  e8bd5ff0          POP      {r4-r12,lr}           ;1542
00039a  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.926|
00039e  6819              LDR      r1,[r3,#0]            ;1545
0003a0  0549              LSLS     r1,r1,#21             ;1545
0003a2  d593              BPL      |L22.716|
0003a4  4620              MOV      r0,r4                 ;1547
0003a6  e66d              B        |L22.132|
                  |L22.936|
0003a8  e8bd5ff0          POP      {r4-r12,lr}           ;1576
0003ac  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.944|
0003b0  e8bd5ff0          POP      {r4-r12,lr}           ;1579
0003b4  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.952|
0003b8  6819              LDR      r1,[r3,#0]            ;1582
0003ba  0549              LSLS     r1,r1,#21             ;1582
0003bc  d586              BPL      |L22.716|
0003be  4620              MOV      r0,r4                 ;1584
                  |L22.960|
0003c0  e660              B        |L22.132|
                  |L22.962|
0003c2  f8d31088          LDR      r1,[r3,#0x88]         ;1606
0003c6  f4016140          AND      r1,r1,#0xc00          ;1606
0003ca  b161              CBZ      r1,|L22.998|
0003cc  4559              CMP      r1,r11                ;1608
0003ce  d00e              BEQ      |L22.1006|
0003d0  4549              CMP      r1,r9                 ;1608
0003d2  d010              BEQ      |L22.1014|
0003d4  f5b16f40          CMP      r1,#0xc00             ;1608
0003d8  d18f              BNE      |L22.762|
0003da  f8d31090          LDR      r1,[r3,#0x90]         ;1623
0003de  0789              LSLS     r1,r1,#30             ;1623
0003e0  d58b              BPL      |L22.762|
0003e2  4628              MOV      r0,r5                 ;1625
                  |L22.996|
0003e4  e64e              B        |L22.132|
                  |L22.998|
0003e6  e8bd5ff0          POP      {r4-r12,lr}           ;1611
0003ea  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.1006|
0003ee  e8bd5ff0          POP      {r4-r12,lr}           ;1614
0003f2  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.1014|
0003f6  6819              LDR      r1,[r3,#0]            ;1617
0003f8  0549              LSLS     r1,r1,#21             ;1617
0003fa  d58b              BPL      |L22.788|
0003fc  4620              MOV      r0,r4                 ;1619
0003fe  e641              B        |L22.132|
                  |L22.1024|
                          DCD      0x40021000
                  |L22.1028|
                          DCD      MSIRangeTable
                  |L22.1032|
                          DCD      0x00f42400
                  |L22.1036|
                          DCD      0x0003d090
                  |L22.1040|
                          DCD      0x007a1200
                  |L22.1044|
                          DCD      0x02dc6c00
                  |L22.1048|
000418  681a              LDR      r2,[r3,#0]            ;1647
00041a  0112              LSLS     r2,r2,#4              ;1647
00041c  d587              BPL      |L22.814|
00041e  691a              LDR      r2,[r3,#0x10]         ;1647
000420  01d2              LSLS     r2,r2,#7              ;1647
000422  d584              BPL      |L22.814|
000424  6918              LDR      r0,[r3,#0x10]         ;1649
000426  f3c02006          UBFX     r0,r0,#8,#7           ;1649
00042a  4341              MULS     r1,r0,r1              ;1656
00042c  68d8              LDR      r0,[r3,#0xc]          ;1656
00042e  f3c01002          UBFX     r0,r0,#4,#3           ;1656
000432  1c40              ADDS     r0,r0,#1              ;1656
000434  fbb1f0f0          UDIV     r0,r1,r0              ;1656
000438  6919              LDR      r1,[r3,#0x10]         ;1659
00043a  f3c16141          UBFX     r1,r1,#25,#2          ;1659
00043e  1c49              ADDS     r1,r1,#1              ;1659
000440  0049              LSLS     r1,r1,#1              ;1659
000442  fbb0f0f1          UDIV     r0,r0,r1              ;1659
                  |L22.1094|
000446  e61d              B        |L22.132|
                  |L22.1096|
000448  681a              LDR      r2,[r3,#0]            ;1665
00044a  0092              LSLS     r2,r2,#2              ;1665
00044c  d58d              BPL      |L22.874|
00044e  695a              LDR      r2,[r3,#0x14]         ;1665
000450  01d2              LSLS     r2,r2,#7              ;1665
000452  d58a              BPL      |L22.874|
000454  6958              LDR      r0,[r3,#0x14]         ;1667
000456  f3c02006          UBFX     r0,r0,#8,#7           ;1667
00045a  4341              MULS     r1,r0,r1              ;1674
00045c  68d8              LDR      r0,[r3,#0xc]          ;1674
00045e  f3c01002          UBFX     r0,r0,#4,#3           ;1674
000462  1c40              ADDS     r0,r0,#1              ;1674
000464  fbb1f0f0          UDIV     r0,r1,r0              ;1674
000468  6959              LDR      r1,[r3,#0x14]         ;1677
00046a  f3c16141          UBFX     r1,r1,#25,#2          ;1677
00046e  1c49              ADDS     r1,r1,#1              ;1677
000470  0049              LSLS     r1,r1,#1              ;1677
000472  fbb0f0f1          UDIV     r0,r0,r1              ;1677
                  |L22.1142|
000476  e605              B        |L22.132|
                  |L22.1144|
000478  f8d30088          LDR      r0,[r3,#0x88]         ;1694
00047c  f0004000          AND      r0,r0,#0x80000000     ;1694
000480  b118              CBZ      r0,|L22.1162|
000482  e8bd5ff0          POP      {r4-r12,lr}           ;1702
000486  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.1162|
00048a  e8bd5ff0          POP      {r4-r12,lr}           ;1698
00048e  f7ffbffe          B.W      HAL_RCC_GetPCLK2Freq
                  |L22.1170|
000492  f8d31088          LDR      r1,[r3,#0x88]         ;1748
000496  f4015140          AND      r1,r1,#0x3000         ;1748
00049a  b141              CBZ      r1,|L22.1198|
00049c  4551              CMP      r1,r10                ;1750
00049e  d00a              BEQ      |L22.1206|
0004a0  4571              CMP      r1,lr                 ;1750
0004a2  d18d              BNE      |L22.960|
0004a4  6819              LDR      r1,[r3,#0]            ;1759
0004a6  0549              LSLS     r1,r1,#21             ;1759
0004a8  d58a              BPL      |L22.960|
0004aa  4620              MOV      r0,r4                 ;1761
                  |L22.1196|
0004ac  e5ea              B        |L22.132|
                  |L22.1198|
0004ae  e8bd5ff0          POP      {r4-r12,lr}           ;1753
0004b2  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.1206|
0004b6  e8bd5ff0          POP      {r4-r12,lr}           ;1756
0004ba  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.1214|
0004be  f8d31088          LDR      r1,[r3,#0x88]         ;1777
0004c2  f4014140          AND      r1,r1,#0xc000         ;1777
0004c6  b149              CBZ      r1,|L22.1244|
0004c8  f5b14f80          CMP      r1,#0x4000            ;1779
0004cc  d00a              BEQ      |L22.1252|
0004ce  42a9              CMP      r1,r5                 ;1779
0004d0  d188              BNE      |L22.996|
0004d2  6819              LDR      r1,[r3,#0]            ;1788
0004d4  0549              LSLS     r1,r1,#21             ;1788
0004d6  d585              BPL      |L22.996|
0004d8  4620              MOV      r0,r4                 ;1790
                  |L22.1242|
0004da  e5d3              B        |L22.132|
                  |L22.1244|
0004dc  e8bd5ff0          POP      {r4-r12,lr}           ;1782
0004e0  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.1252|
0004e4  e8bd5ff0          POP      {r4-r12,lr}           ;1785
0004e8  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.1260|
0004ec  f8d31088          LDR      r1,[r3,#0x88]         ;1806
0004f0  f4013140          AND      r1,r1,#0x30000        ;1806
0004f4  b151              CBZ      r1,|L22.1292|
0004f6  f5b13f80          CMP      r1,#0x10000           ;1808
0004fa  d00b              BEQ      |L22.1300|
0004fc  f5b13f00          CMP      r1,#0x20000           ;1808
000500  d1a1              BNE      |L22.1094|
000502  6819              LDR      r1,[r3,#0]            ;1817
000504  0549              LSLS     r1,r1,#21             ;1817
000506  d59e              BPL      |L22.1094|
000508  4620              MOV      r0,r4                 ;1819
00050a  e5bb              B        |L22.132|
                  |L22.1292|
00050c  e8bd5ff0          POP      {r4-r12,lr}           ;1811
000510  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.1300|
000514  e8bd5ff0          POP      {r4-r12,lr}           ;1814
000518  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.1308|
00051c  e8bd5ff0          POP      {r4-r12,lr}           ;1840
000520  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.1316|
000524  e8bd5ff0          POP      {r4-r12,lr}           ;1843
000528  f7ffbffe          B.W      HAL_RCC_GetSysClockFreq
                  |L22.1324|
00052c  e8bd5ff0          POP      {r4-r12,lr}           ;1869
000530  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.1332|
000534  f8d31094          LDR      r1,[r3,#0x94]         ;1872
000538  0789              LSLS     r1,r1,#30             ;1872
00053a  d584              BPL      |L22.1094|
00053c  4630              MOV      r0,r6                 ;1882
00053e  e5a1              B        |L22.132|
                  |L22.1344|
000540  6819              LDR      r1,[r3,#0]            ;1887
000542  0549              LSLS     r1,r1,#21             ;1887
000544  d597              BPL      |L22.1142|
000546  4620              MOV      r0,r4                 ;1889
000548  e59c              B        |L22.132|
                  |L22.1354|
00054a  f8d31088          LDR      r1,[r3,#0x88]         ;1909
00054e  f4011140          AND      r1,r1,#0x300000       ;1909
000552  b171              CBZ      r1,|L22.1394|
000554  f5b11f80          CMP      r1,#0x100000          ;1911
000558  d00f              BEQ      |L22.1402|
00055a  f5b11f00          CMP      r1,#0x200000          ;1911
00055e  d012              BEQ      |L22.1414|
000560  f5b11f40          CMP      r1,#0x300000          ;1911
000564  d187              BNE      |L22.1142|
000566  f8d31090          LDR      r1,[r3,#0x90]         ;1938
00056a  0789              LSLS     r1,r1,#30             ;1938
00056c  d59e              BPL      |L22.1196|
00056e  4628              MOV      r0,r5                 ;1940
000570  e588              B        |L22.132|
                  |L22.1394|
000572  e8bd5ff0          POP      {r4-r12,lr}           ;1914
000576  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
                  |L22.1402|
00057a  f8d31094          LDR      r1,[r3,#0x94]         ;1917
00057e  0789              LSLS     r1,r1,#30             ;1917
000580  d594              BPL      |L22.1196|
000582  4630              MOV      r0,r6                 ;1927
000584  e57e              B        |L22.132|
                  |L22.1414|
000586  6819              LDR      r1,[r3,#0]            ;1932
000588  0549              LSLS     r1,r1,#21             ;1932
00058a  d58f              BPL      |L22.1196|
00058c  4620              MOV      r0,r4                 ;1934
00058e  e579              B        |L22.132|
                  |L22.1424|
000590  f8d31088          LDR      r1,[r3,#0x88]         ;1956
000594  f0014180          AND      r1,r1,#0x40000000     ;1956
000598  b139              CBZ      r1,|L22.1450|
00059a  f1b14f80          CMP      r1,#0x40000000        ;1958
00059e  d185              BNE      |L22.1196|
0005a0  6819              LDR      r1,[r3,#0]            ;1964
0005a2  0549              LSLS     r1,r1,#21             ;1964
0005a4  d599              BPL      |L22.1242|
0005a6  4620              MOV      r0,r4                 ;1966
0005a8  e56c              B        |L22.132|
                  |L22.1450|
0005aa  e8bd5ff0          POP      {r4-r12,lr}           ;1961
0005ae  f7ffbffe          B.W      HAL_RCC_GetPCLK1Freq
;;;2028   
                          ENDP


                          AREA ||i.HAL_RCCEx_LSECSS_Callback||, CODE, READONLY, ALIGN=1

                  HAL_RCCEx_LSECSS_Callback PROC
;;;2389     */
;;;2390   __weak void HAL_RCCEx_LSECSS_Callback(void)
000000  4770              BX       lr
;;;2391   {
;;;2392     /* NOTE : This function should not be modified, when the callback is needed,
;;;2393               the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
;;;2394      */
;;;2395   }
;;;2396   
                          ENDP


                          AREA ||i.HAL_RCCEx_LSECSS_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_LSECSS_IRQHandler PROC
;;;2372     */
;;;2373   void HAL_RCCEx_LSECSS_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;2374   {
;;;2375     /* Check RCC LSE CSSF flag  */
;;;2376     if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
000002  4c04              LDR      r4,|L24.20|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  0580              LSLS     r0,r0,#22
000008  d503              BPL      |L24.18|
;;;2377     {
;;;2378       /* RCC LSE Clock Security System interrupt user callback */
;;;2379       HAL_RCCEx_LSECSS_Callback();
00000a  f7fffffe          BL       HAL_RCCEx_LSECSS_Callback
;;;2380   
;;;2381       /* Clear RCC LSE CSS pending bit */
;;;2382       __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
00000e  1560              ASRS     r0,r4,#21
000010  6220              STR      r0,[r4,#0x20]
                  |L24.18|
;;;2383     }
;;;2384   }
000012  bd10              POP      {r4,pc}
;;;2385   
                          ENDP

                  |L24.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;195      */
;;;196    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;197    {
000004  4604              MOV      r4,r0
;;;198      uint32_t tmpregister, tickstart;     /* no init needed */
;;;199      HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
000006  2500              MOVS     r5,#0
;;;200      HAL_StatusTypeDef status = HAL_OK;   /* Final status */
000008  2700              MOVS     r7,#0
;;;201    
;;;202      /* Check the parameters */
;;;203      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;204    
;;;205    #if defined(SAI1)
;;;206    
;;;207      /*-------------------------- SAI1 clock source configuration ---------------------*/
;;;208      if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
00000a  8820              LDRH     r0,[r4,#0]
;;;209      {
;;;210        /* Check the parameters */
;;;211        assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));
;;;212    
;;;213        switch(PeriphClkInit->Sai1ClockSelection)
;;;214        {
;;;215        case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
;;;216          /* Enable SAI Clock output generated from System PLL . */
;;;217    #if defined(RCC_PLLSAI2_SUPPORT)
;;;218          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
00000c  4eed              LDR      r6,|L25.964|
00000e  0500              LSLS     r0,r0,#20             ;208
;;;219    #else
;;;220          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
;;;221    #endif /* RCC_PLLSAI2_SUPPORT */
;;;222          /* SAI1 clock source config set later after clock selection check */
;;;223          break;
;;;224    
;;;225        case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
;;;226          /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
;;;227          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
;;;228          /* SAI1 clock source config set later after clock selection check */
;;;229          break;
;;;230    
;;;231    #if defined(RCC_PLLSAI2_SUPPORT)
;;;232    
;;;233        case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
;;;234          /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
;;;235          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
000010  f1040b20          ADD      r11,r4,#0x20
000014  d50d              BPL      |L25.50|
000016  6ea0              LDR      r0,[r4,#0x68]         ;213
000018  b3d0              CBZ      r0,|L25.144|
00001a  f5b00f80          CMP      r0,#0x400000          ;213
00001e  d045              BEQ      |L25.172|
000020  f5b00f00          CMP      r0,#0x800000          ;213
000024  d037              BEQ      |L25.150|
000026  f5b00f40          CMP      r0,#0xc00000          ;213
00002a  d000              BEQ      |L25.46|
;;;236          /* SAI1 clock source config set later after clock selection check */
;;;237          break;
;;;238    
;;;239    #endif /* RCC_PLLSAI2_SUPPORT */
;;;240    
;;;241        case RCC_SAI1CLKSOURCE_PIN:      /* External clock is used as source of SAI1 clock*/
;;;242    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;243        case RCC_SAI1CLKSOURCE_HSI:      /* HSI is used as source of SAI1 clock*/
;;;244    #endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;245          /* SAI1 clock source config set later after clock selection check */
;;;246          break;
;;;247    
;;;248        default:
;;;249          ret = HAL_ERROR;
00002c  2501              MOVS     r5,#1
                  |L25.46|
;;;250          break;
;;;251        }
;;;252    
;;;253        if(ret == HAL_OK)
00002e  b385              CBZ      r5,|L25.146|
;;;254        {
;;;255          /* Set the source of SAI1 clock*/
;;;256          __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
;;;257        }
;;;258        else
;;;259        {
;;;260          /* set overall return value */
;;;261          status = ret;
000030  462f              MOV      r7,r5
                  |L25.50|
;;;262        }
;;;263      }
;;;264    
;;;265    #endif /* SAI1 */
;;;266    
;;;267    #if defined(SAI2)
;;;268    
;;;269      /*-------------------------- SAI2 clock source configuration ---------------------*/
;;;270      if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
000032  8820              LDRH     r0,[r4,#0]
000034  04c0              LSLS     r0,r0,#19
000036  d50d              BPL      |L25.84|
;;;271      {
;;;272        /* Check the parameters */
;;;273        assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));
;;;274    
;;;275        switch(PeriphClkInit->Sai2ClockSelection)
000038  6ee0              LDR      r0,[r4,#0x6c]
00003a  b358              CBZ      r0,|L25.148|
00003c  f1b07f80          CMP      r0,#0x1000000
000040  d04f              BEQ      |L25.226|
000042  f1b07f00          CMP      r0,#0x2000000
000046  d041              BEQ      |L25.204|
000048  f1b07f40          CMP      r0,#0x3000000
00004c  d000              BEQ      |L25.80|
;;;276        {
;;;277        case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
;;;278          /* Enable SAI Clock output generated from System PLL . */
;;;279          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
;;;280          /* SAI2 clock source config set later after clock selection check */
;;;281          break;
;;;282    
;;;283        case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
;;;284          /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
;;;285          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
;;;286          /* SAI2 clock source config set later after clock selection check */
;;;287          break;
;;;288    
;;;289        case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
;;;290          /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
;;;291          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
;;;292          /* SAI2 clock source config set later after clock selection check */
;;;293          break;
;;;294    
;;;295        case RCC_SAI2CLKSOURCE_PIN:      /* External clock is used as source of SAI2 clock*/
;;;296    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;297        case RCC_SAI2CLKSOURCE_HSI:      /* HSI is used as source of SAI2 clock*/
;;;298    #endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;299          /* SAI2 clock source config set later after clock selection check */
;;;300          break;
;;;301    
;;;302        default:
;;;303          ret = HAL_ERROR;
00004e  2501              MOVS     r5,#1
                  |L25.80|
;;;304          break;
;;;305        }
;;;306    
;;;307        if(ret == HAL_OK)
000050  b395              CBZ      r5,|L25.184|
;;;308        {
;;;309          /* Set the source of SAI2 clock*/
;;;310          __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
;;;311        }
;;;312        else
;;;313        {
;;;314          /* set overall return value */
;;;315          status = ret;
000052  462f              MOV      r7,r5
                  |L25.84|
;;;316        }
;;;317      }
;;;318    #endif /* SAI2 */
;;;319    
;;;320      /*-------------------------- RTC clock source configuration ----------------------*/
;;;321      if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
000054  6820              LDR      r0,[r4,#0]
000056  0380              LSLS     r0,r0,#14
000058  d563              BPL      |L25.290|
;;;322      {
;;;323        FlagStatus       pwrclkchanged = RESET;
00005a  f04f0800          MOV      r8,#0
;;;324    
;;;325        /* Check for RTC Parameters used to output RTCCLK */
;;;326        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;327    
;;;328        /* Enable Power Clock */
;;;329        if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
00005e  6db0              LDR      r0,[r6,#0x58]
000060  00c0              LSLS     r0,r0,#3
000062  d409              BMI      |L25.120|
;;;330        {
;;;331          __HAL_RCC_PWR_CLK_ENABLE();
000064  6db0              LDR      r0,[r6,#0x58]
000066  f0405080          ORR      r0,r0,#0x10000000
00006a  65b0              STR      r0,[r6,#0x58]
00006c  6db0              LDR      r0,[r6,#0x58]
00006e  f0005080          AND      r0,r0,#0x10000000
000072  9000              STR      r0,[sp,#0]
;;;332          pwrclkchanged = SET;
000074  f04f0801          MOV      r8,#1
                  |L25.120|
;;;333        }
;;;334    
;;;335        /* Enable write access to Backup domain */
;;;336        SET_BIT(PWR->CR1, PWR_CR1_DBP);
000078  f8dfa34c          LDR      r10,|L25.968|
00007c  f8da0000          LDR      r0,[r10,#0]
000080  f4407080          ORR      r0,r0,#0x100
000084  f8ca0000          STR      r0,[r10,#0]
;;;337    
;;;338        /* Wait for Backup domain Write protection disable */
;;;339        tickstart = HAL_GetTick();
000088  f7fffffe          BL       HAL_GetTick
00008c  4681              MOV      r9,r0
;;;340    
;;;341        while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
00008e  e03f              B        |L25.272|
                  |L25.144|
000090  e006              B        |L25.160|
                  |L25.146|
000092  e012              B        |L25.186|
                  |L25.148|
000094  e01f              B        |L25.214|
                  |L25.150|
000096  68f0              LDR      r0,[r6,#0xc]          ;218
000098  f4403080          ORR      r0,r0,#0x10000        ;218
00009c  60f0              STR      r0,[r6,#0xc]          ;218
00009e  e7c6              B        |L25.46|
                  |L25.160|
0000a0  2100              MOVS     r1,#0                 ;227
0000a2  1d20              ADDS     r0,r4,#4              ;227
0000a4  f7fffffe          BL       RCCEx_PLLSAI1_Config
0000a8  4605              MOV      r5,r0                 ;227
0000aa  e7c0              B        |L25.46|
                  |L25.172|
0000ac  2100              MOVS     r1,#0                 ;235
0000ae  4658              MOV      r0,r11                ;235
0000b0  f7fffffe          BL       RCCEx_PLLSAI2_Config
0000b4  4605              MOV      r5,r0                 ;235
0000b6  e7ba              B        |L25.46|
                  |L25.184|
0000b8  e019              B        |L25.238|
                  |L25.186|
0000ba  f8d60088          LDR      r0,[r6,#0x88]         ;256
0000be  6ea1              LDR      r1,[r4,#0x68]         ;256
0000c0  f4200040          BIC      r0,r0,#0xc00000       ;256
0000c4  4308              ORRS     r0,r0,r1              ;256
0000c6  f8c60088          STR      r0,[r6,#0x88]         ;256
0000ca  e7b2              B        |L25.50|
                  |L25.204|
0000cc  68f0              LDR      r0,[r6,#0xc]          ;279
0000ce  f4403080          ORR      r0,r0,#0x10000        ;279
0000d2  60f0              STR      r0,[r6,#0xc]          ;279
0000d4  e7bc              B        |L25.80|
                  |L25.214|
0000d6  2100              MOVS     r1,#0                 ;285
0000d8  1d20              ADDS     r0,r4,#4              ;285
0000da  f7fffffe          BL       RCCEx_PLLSAI1_Config
0000de  4605              MOV      r5,r0                 ;285
0000e0  e7b6              B        |L25.80|
                  |L25.226|
0000e2  2100              MOVS     r1,#0                 ;291
0000e4  4658              MOV      r0,r11                ;291
0000e6  f7fffffe          BL       RCCEx_PLLSAI2_Config
0000ea  4605              MOV      r5,r0                 ;291
0000ec  e7b0              B        |L25.80|
                  |L25.238|
0000ee  f8d60088          LDR      r0,[r6,#0x88]         ;310
0000f2  6ee1              LDR      r1,[r4,#0x6c]         ;310
0000f4  f0207040          BIC      r0,r0,#0x3000000      ;310
0000f8  4308              ORRS     r0,r0,r1              ;310
0000fa  f8c60088          STR      r0,[r6,#0x88]         ;310
0000fe  e7a9              B        |L25.84|
                  |L25.256|
;;;342        {
;;;343          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000100  f7fffffe          BL       HAL_GetTick
000104  eba00009          SUB      r0,r0,r9
000108  2802              CMP      r0,#2
00010a  d901              BLS      |L25.272|
;;;344          {
;;;345            ret = HAL_TIMEOUT;
00010c  2503              MOVS     r5,#3
;;;346            break;
00010e  e003              B        |L25.280|
                  |L25.272|
000110  f8da0000          LDR      r0,[r10,#0]           ;341
000114  05c0              LSLS     r0,r0,#23             ;341
000116  d5f3              BPL      |L25.256|
                  |L25.280|
;;;347          }
;;;348        }
;;;349    
;;;350        if(ret == HAL_OK)
000118  b125              CBZ      r5,|L25.292|
;;;351        {
;;;352          /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
;;;353          tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
;;;354    
;;;355          if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
;;;356          {
;;;357            /* Store the content of BDCR register before the reset of Backup Domain */
;;;358            tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
;;;359            /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;360            __HAL_RCC_BACKUPRESET_FORCE();
;;;361            __HAL_RCC_BACKUPRESET_RELEASE();
;;;362            /* Restore the Content of BDCR register */
;;;363            RCC->BDCR = tmpregister;
;;;364          }
;;;365    
;;;366          /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
;;;367          if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
;;;368          {
;;;369            /* Get Start Tick*/
;;;370            tickstart = HAL_GetTick();
;;;371    
;;;372            /* Wait till LSE is ready */
;;;373            while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
;;;374            {
;;;375              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;376              {
;;;377                ret = HAL_TIMEOUT;
;;;378                break;
;;;379              }
;;;380            }
;;;381          }
;;;382    
;;;383          if(ret == HAL_OK)
;;;384          {
;;;385            /* Apply new RTC clock source selection */
;;;386            __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;387          }
;;;388          else
;;;389          {
;;;390            /* set overall return value */
;;;391            status = ret;
;;;392          }
;;;393        }
;;;394        else
;;;395        {
;;;396          /* set overall return value */
;;;397          status = ret;
00011a  462f              MOV      r7,r5
                  |L25.284|
;;;398        }
;;;399    
;;;400        /* Restore clock configuration if changed */
;;;401        if(pwrclkchanged == SET)
00011c  f1b80f01          CMP      r8,#1
000120  d038              BEQ      |L25.404|
                  |L25.290|
000122  e03b              B        |L25.412|
                  |L25.292|
000124  f8d60090          LDR      r0,[r6,#0x90]         ;353
000128  f4007040          AND      r0,r0,#0x300          ;353
00012c  b188              CBZ      r0,|L25.338|
00012e  f8d41088          LDR      r1,[r4,#0x88]         ;355
000132  4281              CMP      r1,r0                 ;355
000134  d00d              BEQ      |L25.338|
000136  f8560f90          LDR      r0,[r6,#0x90]!        ;358
00013a  f4207040          BIC      r0,r0,#0x300          ;358
00013e  6831              LDR      r1,[r6,#0]            ;360
000140  f4413180          ORR      r1,r1,#0x10000        ;360
000144  6031              STR      r1,[r6,#0]            ;360
000146  6831              LDR      r1,[r6,#0]            ;361
000148  f4213180          BIC      r1,r1,#0x10000        ;361
00014c  6031              STR      r1,[r6,#0]            ;361
00014e  f8460990          STR      r0,[r6],#-0x90        ;363
                  |L25.338|
000152  07c0              LSLS     r0,r0,#31             ;367
000154  d011              BEQ      |L25.378|
000156  f7fffffe          BL       HAL_GetTick
00015a  4681              MOV      r9,r0                 ;370
00015c  f2413a88          MOV      r10,#0x1388           ;375
000160  e007              B        |L25.370|
                  |L25.354|
000162  f7fffffe          BL       HAL_GetTick
000166  eba00009          SUB      r0,r0,r9              ;375
00016a  4550              CMP      r0,r10                ;375
00016c  d901              BLS      |L25.370|
00016e  2503              MOVS     r5,#3                 ;377
000170  e003              B        |L25.378|
                  |L25.370|
000172  f8d60090          LDR      r0,[r6,#0x90]         ;373
000176  0780              LSLS     r0,r0,#30             ;373
000178  d5f3              BPL      |L25.354|
                  |L25.378|
00017a  b10d              CBZ      r5,|L25.384|
00017c  462f              MOV      r7,r5                 ;391
00017e  e7cd              B        |L25.284|
                  |L25.384|
000180  f8d60090          LDR      r0,[r6,#0x90]         ;386
000184  f8d41088          LDR      r1,[r4,#0x88]         ;386
000188  f4207040          BIC      r0,r0,#0x300          ;386
00018c  4308              ORRS     r0,r0,r1              ;386
00018e  f8c60090          STR      r0,[r6,#0x90]         ;386
000192  e7c3              B        |L25.284|
                  |L25.404|
;;;402        {
;;;403          __HAL_RCC_PWR_CLK_DISABLE();
000194  6db0              LDR      r0,[r6,#0x58]
000196  f0205080          BIC      r0,r0,#0x10000000
00019a  65b0              STR      r0,[r6,#0x58]
                  |L25.412|
;;;404        }
;;;405      }
;;;406    
;;;407      /*-------------------------- USART1 clock source configuration -------------------*/
;;;408      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
00019c  7820              LDRB     r0,[r4,#0]
00019e  07c0              LSLS     r0,r0,#31
0001a0  d007              BEQ      |L25.434|
;;;409      {
;;;410        /* Check the parameters */
;;;411        assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
;;;412    
;;;413        /* Configure the USART1 clock source */
;;;414        __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
0001a2  f8d60088          LDR      r0,[r6,#0x88]
0001a6  6ba1              LDR      r1,[r4,#0x38]
0001a8  f0200003          BIC      r0,r0,#3
0001ac  4308              ORRS     r0,r0,r1
0001ae  f8c60088          STR      r0,[r6,#0x88]
                  |L25.434|
;;;415      }
;;;416    
;;;417      /*-------------------------- USART2 clock source configuration -------------------*/
;;;418      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
0001b2  7820              LDRB     r0,[r4,#0]
0001b4  0780              LSLS     r0,r0,#30
0001b6  d507              BPL      |L25.456|
;;;419      {
;;;420        /* Check the parameters */
;;;421        assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
;;;422    
;;;423        /* Configure the USART2 clock source */
;;;424        __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
0001b8  f8d60088          LDR      r0,[r6,#0x88]
0001bc  6be1              LDR      r1,[r4,#0x3c]
0001be  f020000c          BIC      r0,r0,#0xc
0001c2  4308              ORRS     r0,r0,r1
0001c4  f8c60088          STR      r0,[r6,#0x88]
                  |L25.456|
;;;425      }
;;;426    
;;;427    #if defined(USART3)
;;;428    
;;;429      /*-------------------------- USART3 clock source configuration -------------------*/
;;;430      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
0001c8  7820              LDRB     r0,[r4,#0]
0001ca  0740              LSLS     r0,r0,#29
0001cc  d507              BPL      |L25.478|
;;;431      {
;;;432        /* Check the parameters */
;;;433        assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
;;;434    
;;;435        /* Configure the USART3 clock source */
;;;436        __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
0001ce  f8d60088          LDR      r0,[r6,#0x88]
0001d2  6c21              LDR      r1,[r4,#0x40]
0001d4  f0200030          BIC      r0,r0,#0x30
0001d8  4308              ORRS     r0,r0,r1
0001da  f8c60088          STR      r0,[r6,#0x88]
                  |L25.478|
;;;437      }
;;;438    
;;;439    #endif /* USART3 */
;;;440    
;;;441    #if defined(UART4)
;;;442    
;;;443      /*-------------------------- UART4 clock source configuration --------------------*/
;;;444      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
0001de  7820              LDRB     r0,[r4,#0]
0001e0  0700              LSLS     r0,r0,#28
0001e2  d507              BPL      |L25.500|
;;;445      {
;;;446        /* Check the parameters */
;;;447        assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
;;;448    
;;;449        /* Configure the UART4 clock source */
;;;450        __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
0001e4  f8d60088          LDR      r0,[r6,#0x88]
0001e8  6c61              LDR      r1,[r4,#0x44]
0001ea  f02000c0          BIC      r0,r0,#0xc0
0001ee  4308              ORRS     r0,r0,r1
0001f0  f8c60088          STR      r0,[r6,#0x88]
                  |L25.500|
;;;451      }
;;;452    
;;;453    #endif /* UART4 */
;;;454    
;;;455    #if defined(UART5)
;;;456    
;;;457      /*-------------------------- UART5 clock source configuration --------------------*/
;;;458      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
0001f4  7820              LDRB     r0,[r4,#0]
0001f6  06c0              LSLS     r0,r0,#27
0001f8  d507              BPL      |L25.522|
;;;459      {
;;;460        /* Check the parameters */
;;;461        assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
;;;462    
;;;463        /* Configure the UART5 clock source */
;;;464        __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
0001fa  f8d60088          LDR      r0,[r6,#0x88]
0001fe  6ca1              LDR      r1,[r4,#0x48]
000200  f4207040          BIC      r0,r0,#0x300
000204  4308              ORRS     r0,r0,r1
000206  f8c60088          STR      r0,[r6,#0x88]
                  |L25.522|
;;;465      }
;;;466    
;;;467    #endif /* UART5 */
;;;468    
;;;469      /*-------------------------- LPUART1 clock source configuration ------------------*/
;;;470      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
00020a  7820              LDRB     r0,[r4,#0]
00020c  0680              LSLS     r0,r0,#26
00020e  d507              BPL      |L25.544|
;;;471      {
;;;472        /* Check the parameters */
;;;473        assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
;;;474    
;;;475        /* Configure the LPUART1 clock source */
;;;476        __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
000210  f8d60088          LDR      r0,[r6,#0x88]
000214  6ce1              LDR      r1,[r4,#0x4c]
000216  f4206040          BIC      r0,r0,#0xc00
00021a  4308              ORRS     r0,r0,r1
00021c  f8c60088          STR      r0,[r6,#0x88]
                  |L25.544|
;;;477      }
;;;478    
;;;479      /*-------------------------- LPTIM1 clock source configuration -------------------*/
;;;480      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
000220  8820              LDRH     r0,[r4,#0]
000222  0580              LSLS     r0,r0,#22
000224  d507              BPL      |L25.566|
;;;481      {
;;;482        assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
;;;483        __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
000226  f8d60088          LDR      r0,[r6,#0x88]
00022a  6e21              LDR      r1,[r4,#0x60]
00022c  f4202040          BIC      r0,r0,#0xc0000
000230  4308              ORRS     r0,r0,r1
000232  f8c60088          STR      r0,[r6,#0x88]
                  |L25.566|
;;;484      }
;;;485    
;;;486      /*-------------------------- LPTIM2 clock source configuration -------------------*/
;;;487      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
000236  8820              LDRH     r0,[r4,#0]
000238  0540              LSLS     r0,r0,#21
00023a  d507              BPL      |L25.588|
;;;488      {
;;;489        assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
;;;490        __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
00023c  f8d60088          LDR      r0,[r6,#0x88]
000240  6e61              LDR      r1,[r4,#0x64]
000242  f4201040          BIC      r0,r0,#0x300000
000246  4308              ORRS     r0,r0,r1
000248  f8c60088          STR      r0,[r6,#0x88]
                  |L25.588|
;;;491      }
;;;492    
;;;493      /*-------------------------- I2C1 clock source configuration ---------------------*/
;;;494      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
00024c  7820              LDRB     r0,[r4,#0]
00024e  0640              LSLS     r0,r0,#25
000250  d507              BPL      |L25.610|
;;;495      {
;;;496        /* Check the parameters */
;;;497        assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
;;;498    
;;;499        /* Configure the I2C1 clock source */
;;;500        __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
000252  f8d60088          LDR      r0,[r6,#0x88]
000256  6d21              LDR      r1,[r4,#0x50]
000258  f4205040          BIC      r0,r0,#0x3000
00025c  4308              ORRS     r0,r0,r1
00025e  f8c60088          STR      r0,[r6,#0x88]
                  |L25.610|
;;;501      }
;;;502    
;;;503    #if defined(I2C2)
;;;504    
;;;505      /*-------------------------- I2C2 clock source configuration ---------------------*/
;;;506      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
000262  7820              LDRB     r0,[r4,#0]
000264  0600              LSLS     r0,r0,#24
000266  d507              BPL      |L25.632|
;;;507      {
;;;508        /* Check the parameters */
;;;509        assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
;;;510    
;;;511        /* Configure the I2C2 clock source */
;;;512        __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
000268  f8d60088          LDR      r0,[r6,#0x88]
00026c  6d61              LDR      r1,[r4,#0x54]
00026e  f4204040          BIC      r0,r0,#0xc000
000272  4308              ORRS     r0,r0,r1
000274  f8c60088          STR      r0,[r6,#0x88]
                  |L25.632|
;;;513      }
;;;514    
;;;515    #endif /* I2C2 */
;;;516    
;;;517      /*-------------------------- I2C3 clock source configuration ---------------------*/
;;;518      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
000278  8820              LDRH     r0,[r4,#0]
00027a  05c0              LSLS     r0,r0,#23
00027c  d507              BPL      |L25.654|
;;;519      {
;;;520        /* Check the parameters */
;;;521        assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
;;;522    
;;;523        /* Configure the I2C3 clock source */
;;;524        __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
00027e  f8d60088          LDR      r0,[r6,#0x88]
000282  6da1              LDR      r1,[r4,#0x58]
000284  f4203040          BIC      r0,r0,#0x30000
000288  4308              ORRS     r0,r0,r1
00028a  f8c60088          STR      r0,[r6,#0x88]
                  |L25.654|
;;;525      }
;;;526    
;;;527    #if defined(I2C4)
;;;528    
;;;529      /*-------------------------- I2C4 clock source configuration ---------------------*/
;;;530      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
00028e  6820              LDR      r0,[r4,#0]
000290  02c0              LSLS     r0,r0,#11
000292  d507              BPL      |L25.676|
;;;531      {
;;;532        /* Check the parameters */
;;;533        assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
;;;534    
;;;535        /* Configure the I2C4 clock source */
;;;536        __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
000294  f8d6009c          LDR      r0,[r6,#0x9c]
000298  6de1              LDR      r1,[r4,#0x5c]
00029a  f0200003          BIC      r0,r0,#3
00029e  4308              ORRS     r0,r0,r1
0002a0  f8c6009c          STR      r0,[r6,#0x9c]
                  |L25.676|
;;;537      }
;;;538    
;;;539    #endif /* I2C4 */
;;;540    
;;;541    #if defined(USB_OTG_FS) || defined(USB)
;;;542    
;;;543      /*-------------------------- USB clock source configuration ----------------------*/
;;;544      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
0002a4  8820              LDRH     r0,[r4,#0]
;;;545      {
;;;546        assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
;;;547        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;548    
;;;549        if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
0002a6  f04f6500          MOV      r5,#0x8000000
0002aa  0480              LSLS     r0,r0,#18             ;544
;;;550        {
;;;551          /* Enable PLL48M1CLK output clock */
;;;552          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
;;;553        }
;;;554        else
;;;555        {
;;;556    #if defined(RCC_PLLSAI1_SUPPORT)
;;;557          if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
0002ac  f04f6880          MOV      r8,#0x4000000
0002b0  d517              BPL      |L25.738|
0002b2  f8d60088          LDR      r0,[r6,#0x88]         ;547
0002b6  6f21              LDR      r1,[r4,#0x70]         ;547
0002b8  f0206040          BIC      r0,r0,#0xc000000      ;547
0002bc  4308              ORRS     r0,r0,r1              ;547
0002be  f8c60088          STR      r0,[r6,#0x88]         ;547
0002c2  6f20              LDR      r0,[r4,#0x70]         ;549
0002c4  42a8              CMP      r0,r5                 ;549
0002c6  d104              BNE      |L25.722|
0002c8  68f0              LDR      r0,[r6,#0xc]          ;552
0002ca  f4401080          ORR      r0,r0,#0x100000       ;552
0002ce  60f0              STR      r0,[r6,#0xc]          ;552
0002d0  e007              B        |L25.738|
                  |L25.722|
0002d2  4540              CMP      r0,r8
0002d4  d105              BNE      |L25.738|
;;;558          {
;;;559            /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
;;;560            ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
0002d6  2101              MOVS     r1,#1
0002d8  1d20              ADDS     r0,r4,#4
0002da  f7fffffe          BL       RCCEx_PLLSAI1_Config
;;;561    
;;;562            if(ret != HAL_OK)
0002de  b100              CBZ      r0,|L25.738|
;;;563            {
;;;564              /* set overall return value */
;;;565              status = ret;
0002e0  4607              MOV      r7,r0
                  |L25.738|
;;;566            }
;;;567          }
;;;568    #endif /* RCC_PLLSAI1_SUPPORT */
;;;569        }
;;;570      }
;;;571    
;;;572    #endif /* USB_OTG_FS || USB */
;;;573    
;;;574    #if defined(SDMMC1)
;;;575    
;;;576      /*-------------------------- SDMMC1 clock source configuration -------------------*/
;;;577      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
0002e2  6820              LDR      r0,[r4,#0]
0002e4  0300              LSLS     r0,r0,#12
0002e6  d517              BPL      |L25.792|
;;;578      {
;;;579        assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
;;;580        __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
0002e8  f8d60088          LDR      r0,[r6,#0x88]
0002ec  6f61              LDR      r1,[r4,#0x74]
0002ee  f0206040          BIC      r0,r0,#0xc000000
0002f2  4308              ORRS     r0,r0,r1
0002f4  f8c60088          STR      r0,[r6,#0x88]
;;;581    
;;;582        if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
0002f8  6f60              LDR      r0,[r4,#0x74]
0002fa  42a8              CMP      r0,r5
0002fc  d104              BNE      |L25.776|
;;;583        {
;;;584          /* Enable PLL48M1CLK output clock */
;;;585          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
0002fe  68f0              LDR      r0,[r6,#0xc]
000300  f4401080          ORR      r0,r0,#0x100000
000304  60f0              STR      r0,[r6,#0xc]
000306  e007              B        |L25.792|
                  |L25.776|
;;;586        }
;;;587    #if defined(RCC_CCIPR2_SDMMCSEL)
;;;588        else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLP) /* PLL "P" ? */
;;;589        {
;;;590          /* Enable PLLSAI3CLK output */
;;;591          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
;;;592        }
;;;593    #endif
;;;594        else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
000308  4540              CMP      r0,r8
00030a  d105              BNE      |L25.792|
;;;595        {
;;;596          /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
;;;597          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
00030c  2101              MOVS     r1,#1
00030e  1d20              ADDS     r0,r4,#4
000310  f7fffffe          BL       RCCEx_PLLSAI1_Config
;;;598    
;;;599          if(ret != HAL_OK)
000314  b100              CBZ      r0,|L25.792|
;;;600          {
;;;601            /* set overall return value */
;;;602            status = ret;
000316  4607              MOV      r7,r0
                  |L25.792|
;;;603          }
;;;604        }
;;;605        else
;;;606        {
;;;607          /* nothing to do */
;;;608        }
;;;609      }
;;;610    
;;;611    #endif /* SDMMC1 */
;;;612    
;;;613      /*-------------------------- RNG clock source configuration ----------------------*/
;;;614      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
000318  6820              LDR      r0,[r4,#0]
00031a  0340              LSLS     r0,r0,#13
00031c  d517              BPL      |L25.846|
;;;615      {
;;;616        assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
;;;617        __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
00031e  f8d60088          LDR      r0,[r6,#0x88]
000322  6fa1              LDR      r1,[r4,#0x78]
000324  f0206040          BIC      r0,r0,#0xc000000
000328  4308              ORRS     r0,r0,r1
00032a  f8c60088          STR      r0,[r6,#0x88]
;;;618    
;;;619        if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
00032e  6fa0              LDR      r0,[r4,#0x78]
000330  42a8              CMP      r0,r5
000332  d104              BNE      |L25.830|
;;;620        {
;;;621          /* Enable PLL48M1CLK output clock */
;;;622          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
000334  68f0              LDR      r0,[r6,#0xc]
000336  f4401080          ORR      r0,r0,#0x100000
00033a  60f0              STR      r0,[r6,#0xc]
00033c  e007              B        |L25.846|
                  |L25.830|
;;;623        }
;;;624    #if defined(RCC_PLLSAI1_SUPPORT)
;;;625        else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
00033e  4540              CMP      r0,r8
000340  d105              BNE      |L25.846|
;;;626        {
;;;627          /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
;;;628          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
000342  2101              MOVS     r1,#1
000344  1d20              ADDS     r0,r4,#4
000346  f7fffffe          BL       RCCEx_PLLSAI1_Config
;;;629    
;;;630          if(ret != HAL_OK)
00034a  b100              CBZ      r0,|L25.846|
;;;631          {
;;;632            /* set overall return value */
;;;633            status = ret;
00034c  4607              MOV      r7,r0
                  |L25.846|
;;;634          }
;;;635        }
;;;636    #endif /* RCC_PLLSAI1_SUPPORT */
;;;637        else
;;;638        {
;;;639          /* nothing to do */
;;;640        }
;;;641      }
;;;642    
;;;643      /*-------------------------- ADC clock source configuration ----------------------*/
;;;644    #if !defined(STM32L412xx) && !defined(STM32L422xx)
;;;645      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
00034e  8820              LDRH     r0,[r4,#0]
000350  0440              LSLS     r0,r0,#17
000352  d51c              BPL      |L25.910|
;;;646      {
;;;647        /* Check the parameters */
;;;648        assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
;;;649    
;;;650        /* Configure the ADC interface clock source */
;;;651        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
000354  f8d60088          LDR      r0,[r6,#0x88]
000358  6fe1              LDR      r1,[r4,#0x7c]
00035a  f0205040          BIC      r0,r0,#0x30000000
00035e  4308              ORRS     r0,r0,r1
000360  f8c60088          STR      r0,[r6,#0x88]
;;;652    
;;;653    #if defined(RCC_PLLSAI1_SUPPORT)
;;;654        if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
000364  6fe0              LDR      r0,[r4,#0x7c]
000366  f1b05f80          CMP      r0,#0x10000000
00036a  d003              BEQ      |L25.884|
;;;655        {
;;;656          /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
;;;657          ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
;;;658    
;;;659          if(ret != HAL_OK)
;;;660          {
;;;661            /* set overall return value */
;;;662            status = ret;
;;;663          }
;;;664        }
;;;665    #endif /* RCC_PLLSAI1_SUPPORT */
;;;666    
;;;667    #if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) || defined(STM32L496xx) || defined(STM32L4A6xx)
;;;668    
;;;669        else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
00036c  f1b05f00          CMP      r0,#0x20000000
000370  d007              BEQ      |L25.898|
000372  e00c              B        |L25.910|
                  |L25.884|
000374  2102              MOVS     r1,#2                 ;657
000376  1d20              ADDS     r0,r4,#4              ;657
000378  f7fffffe          BL       RCCEx_PLLSAI1_Config
00037c  b138              CBZ      r0,|L25.910|
00037e  4607              MOV      r7,r0                 ;662
000380  e005              B        |L25.910|
                  |L25.898|
;;;670        {
;;;671          /* PLLSAI2 input clock, parameters M, N & R configuration and clock output (PLLSAI2ClockOut) */
;;;672          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
000382  2102              MOVS     r1,#2
000384  4658              MOV      r0,r11
000386  f7fffffe          BL       RCCEx_PLLSAI2_Config
;;;673    
;;;674          if(ret != HAL_OK)
00038a  b100              CBZ      r0,|L25.910|
;;;675          {
;;;676            /* set overall return value */
;;;677            status = ret;
00038c  4607              MOV      r7,r0
                  |L25.910|
;;;678          }
;;;679        }
;;;680    
;;;681    #endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx || STM32L496xx || STM32L4A6xx */
;;;682    
;;;683      }
;;;684    #endif /* !STM32L412xx && !STM32L422xx */
;;;685    
;;;686    #if defined(SWPMI1)
;;;687    
;;;688      /*-------------------------- SWPMI1 clock source configuration -------------------*/
;;;689      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
00038e  8820              LDRH     r0,[r4,#0]
000390  0400              LSLS     r0,r0,#16
000392  d508              BPL      |L25.934|
;;;690      {
;;;691        /* Check the parameters */
;;;692        assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
;;;693    
;;;694        /* Configure the SWPMI1 clock source */
;;;695        __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
000394  f8d60088          LDR      r0,[r6,#0x88]
000398  f8d41080          LDR      r1,[r4,#0x80]
00039c  f0204080          BIC      r0,r0,#0x40000000
0003a0  4308              ORRS     r0,r0,r1
0003a2  f8c60088          STR      r0,[r6,#0x88]
                  |L25.934|
;;;696      }
;;;697    
;;;698    #endif /* SWPMI1 */
;;;699    
;;;700    #if defined(DFSDM1_Filter0)
;;;701    
;;;702      /*-------------------------- DFSDM1 clock source configuration -------------------*/
;;;703      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
0003a6  6820              LDR      r0,[r4,#0]
0003a8  03c0              LSLS     r0,r0,#15
0003aa  d507              BPL      |L25.956|
;;;704      {
;;;705        /* Check the parameters */
;;;706        assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
;;;707    
;;;708        /* Configure the DFSDM1 interface clock source */
;;;709        __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
0003ac  f8560f88          LDR      r0,[r6,#0x88]!
0003b0  f8d41084          LDR      r1,[r4,#0x84]
0003b4  f0204000          BIC      r0,r0,#0x80000000
0003b8  4308              ORRS     r0,r0,r1
0003ba  6030              STR      r0,[r6,#0]
                  |L25.956|
;;;710      }
;;;711    
;;;712    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;713      /*-------------------------- DFSDM1 audio clock source configuration -------------*/
;;;714      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
;;;715      {
;;;716        /* Check the parameters */
;;;717        assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));
;;;718    
;;;719        /* Configure the DFSDM1 interface audio clock source */
;;;720        __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
;;;721      }
;;;722    
;;;723    #endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;724    
;;;725    #endif /* DFSDM1_Filter0 */
;;;726    
;;;727    #if defined(LTDC)
;;;728    
;;;729      /*-------------------------- LTDC clock source configuration --------------------*/
;;;730      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
;;;731      {
;;;732        /* Check the parameters */
;;;733        assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));
;;;734    
;;;735        /* Disable the PLLSAI2 */
;;;736        __HAL_RCC_PLLSAI2_DISABLE();
;;;737    
;;;738        /* Get Start Tick*/
;;;739        tickstart = HAL_GetTick();
;;;740    
;;;741        /* Wait till PLLSAI2 is ready */
;;;742        while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
;;;743        {
;;;744          if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
;;;745          {
;;;746            ret = HAL_TIMEOUT;
;;;747            break;
;;;748          }
;;;749        }
;;;750    
;;;751        if(ret == HAL_OK)
;;;752        {
;;;753          /* Configure the LTDC clock source */
;;;754          __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
;;;755    
;;;756          /* PLLSAI2 input clock, parameters M, N & R configuration and clock output (PLLSAI2ClockOut) */
;;;757          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
;;;758        }
;;;759    
;;;760        if(ret != HAL_OK)
;;;761        {
;;;762          /* set overall return value */
;;;763          status = ret;
;;;764        }
;;;765      }
;;;766    
;;;767    #endif /* LTDC */
;;;768    
;;;769    #if defined(DSI)
;;;770    
;;;771      /*-------------------------- DSI clock source configuration ---------------------*/
;;;772      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) == RCC_PERIPHCLK_DSI)
;;;773      {
;;;774        /* Check the parameters */
;;;775        assert_param(IS_RCC_DSICLKSOURCE(PeriphClkInit->DsiClockSelection));
;;;776    
;;;777        /* Configure the DSI clock source */
;;;778        __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
;;;779    
;;;780        if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
;;;781        {
;;;782          /* PLLSAI2 input clock, parameters M, N & Q configuration and clock output (PLLSAI2ClockOut) */
;;;783          ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_Q_UPDATE);
;;;784    
;;;785          if(ret != HAL_OK)
;;;786          {
;;;787            /* set overall return value */
;;;788            status = ret;
;;;789          }
;;;790        }
;;;791      }
;;;792    
;;;793    #endif /* DSI */
;;;794    
;;;795    #if defined(OCTOSPI1) || defined(OCTOSPI2)
;;;796    
;;;797      /*-------------------------- OctoSPIx clock source configuration ----------------*/
;;;798      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
;;;799      {
;;;800        /* Check the parameters */
;;;801        assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));
;;;802    
;;;803        /* Configure the OctoSPI clock source */
;;;804        __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
;;;805    
;;;806        if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
;;;807        {
;;;808          /* Enable PLL48M1CLK output */
;;;809          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
;;;810        }
;;;811      }
;;;812    
;;;813    #endif /* OCTOSPI1 || OCTOSPI2 */
;;;814    
;;;815      return status;
0003bc  4638              MOV      r0,r7
;;;816    }
0003be  e8bd8ff8          POP      {r3-r11,pc}
;;;817    
                          ENDP

0003c2  0000              DCW      0x0000
                  |L25.964|
                          DCD      0x40021000
                  |L25.968|
                          DCD      0x40007000

                          AREA ||i.HAL_RCCEx_StandbyMSIRangeConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_StandbyMSIRangeConfig PROC
;;;2318     */
;;;2319   void HAL_RCCEx_StandbyMSIRangeConfig(uint32_t MSIRange)
000000  4903              LDR      r1,|L26.16|
;;;2320   {
;;;2321     assert_param(IS_RCC_MSI_STANDBY_CLOCK_RANGE(MSIRange));
;;;2322   
;;;2323     __HAL_RCC_MSI_STANDBY_RANGE_CONFIG(MSIRange);
000002  680a              LDR      r2,[r1,#0]
000004  f4226270          BIC      r2,r2,#0xf00
000008  ea421000          ORR      r0,r2,r0,LSL #4
00000c  6008              STR      r0,[r1,#0]
;;;2324   }
00000e  4770              BX       lr
;;;2325   
                          ENDP

                  |L26.16|
                          DCD      0x40021094

                          AREA ||i.HAL_RCCEx_WakeUpStopCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_WakeUpStopCLKConfig PROC
;;;2300     */
;;;2301   void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
000000  4903              LDR      r1,|L27.16|
;;;2302   {
;;;2303     assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));
;;;2304   
;;;2305     __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
000002  688a              LDR      r2,[r1,#8]
000004  f4224200          BIC      r2,r2,#0x8000
000008  4302              ORRS     r2,r2,r0
00000a  608a              STR      r2,[r1,#8]
;;;2306   }
00000c  4770              BX       lr
;;;2307   
                          ENDP

00000e  0000              DCW      0x0000
                  |L27.16|
                          DCD      0x40021000

                          AREA ||i.RCCEx_GetSAIxPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  RCCEx_GetSAIxPeriphCLKFreq PROC
;;;3306   
;;;3307   static uint32_t RCCEx_GetSAIxPeriphCLKFreq(uint32_t PeriphClk, uint32_t InputFrequency)
000000  b530              PUSH     {r4,r5,lr}
;;;3308   {
000002  4604              MOV      r4,r0
;;;3309     uint32_t frequency = 0U;
000004  2000              MOVS     r0,#0
;;;3310     uint32_t srcclk = 0U;
000006  2200              MOVS     r2,#0
;;;3311     uint32_t pllvco, plln;    /* no init needed */
;;;3312   #if defined(RCC_PLLP_SUPPORT)
;;;3313     uint32_t pllp = 0U;
;;;3314   #endif /* RCC_PLLP_SUPPORT */
;;;3315   
;;;3316     /* Handle SAIs */
;;;3317     if(PeriphClk == RCC_PERIPHCLK_SAI1)
;;;3318     {
;;;3319       srcclk = __HAL_RCC_GET_SAI1_SOURCE();
000008  4b40              LDR      r3,|L28.268|
;;;3320       if(srcclk == RCC_SAI1CLKSOURCE_PIN)
;;;3321       {
;;;3322         frequency = EXTERNAL_SAI1_CLOCK_VALUE;
00000a  f64b3580          MOV      r5,#0xbb80
00000e  f5b46f00          CMP      r4,#0x800             ;3317
000012  d003              BEQ      |L28.28|
;;;3323       }
;;;3324       /* Else, PLL clock output to check below */
;;;3325     }
;;;3326   #if defined(SAI2)
;;;3327     else
;;;3328     {
;;;3329       if(PeriphClk == RCC_PERIPHCLK_SAI2)
000014  f5b45f80          CMP      r4,#0x1000
000018  d009              BEQ      |L28.46|
00001a  e010              B        |L28.62|
                  |L28.28|
00001c  f8d32088          LDR      r2,[r3,#0x88]         ;3319
000020  f4020240          AND      r2,r2,#0xc00000       ;3319
000024  f5b20f40          CMP      r2,#0xc00000          ;3320
000028  d109              BNE      |L28.62|
00002a  4628              MOV      r0,r5                 ;3322
00002c  e007              B        |L28.62|
                  |L28.46|
;;;3330       {
;;;3331         srcclk = __HAL_RCC_GET_SAI2_SOURCE();
00002e  f8d32088          LDR      r2,[r3,#0x88]
000032  f0027240          AND      r2,r2,#0x3000000
;;;3332         if(srcclk == RCC_SAI2CLKSOURCE_PIN)
000036  f1b27f40          CMP      r2,#0x3000000
00003a  d100              BNE      |L28.62|
;;;3333         {
;;;3334           frequency = EXTERNAL_SAI2_CLOCK_VALUE;
00003c  4628              MOV      r0,r5
                  |L28.62|
;;;3335         }
;;;3336         /* Else, PLL clock output to check below */
;;;3337       }
;;;3338     }
;;;3339   #endif /* SAI2 */
;;;3340   
;;;3341     if(frequency == 0U)
00003e  2800              CMP      r0,#0
000040  d13b              BNE      |L28.186|
;;;3342     {
;;;3343       pllvco = InputFrequency;
;;;3344   
;;;3345   #if defined(SAI2)
;;;3346       if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
000042  f5b20f00          CMP      r2,#0x800000
000046  d01c              BEQ      |L28.130|
000048  f1b27f00          CMP      r2,#0x2000000
00004c  d019              BEQ      |L28.130|
;;;3347       {
;;;3348         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U))
;;;3349         {
;;;3350           /* f(PLL Source) / PLLM */
;;;3351           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3352           /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
;;;3353           plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;3354   #if defined(RCC_PLLP_DIV_2_31_SUPPORT)
;;;3355           pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
;;;3356   #endif
;;;3357           if(pllp == 0U)
;;;3358           {
;;;3359             if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
;;;3360             {
;;;3361               pllp = 17U;
;;;3362             }
;;;3363             else
;;;3364             {
;;;3365               pllp = 7U;
;;;3366             }
;;;3367           }
;;;3368           frequency = (pllvco * plln) / pllp;
;;;3369         }
;;;3370       }
;;;3371       else if(srcclk == 0U)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
00004e  b37a              CBZ      r2,|L28.176|
;;;3372       {
;;;3373         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U))
;;;3374         {
;;;3375   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3376           /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;3377           /* f(PLLSAI1 Source) / PLLSAI1M */
;;;3378           pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;3379   #else
;;;3380           /* f(PLL Source) / PLLM */
;;;3381           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3382   #endif
;;;3383           /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
;;;3384           plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;3385   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;3386           pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
;;;3387   #endif
;;;3388           if(pllp == 0U)
;;;3389           {
;;;3390             if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != 0U)
;;;3391             {
;;;3392               pllp = 17U;
;;;3393             }
;;;3394             else
;;;3395             {
;;;3396               pllp = 7U;
;;;3397             }
;;;3398           }
;;;3399           frequency = (pllvco * plln) / pllp;
;;;3400         }
;;;3401       }
;;;3402   #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;3403       else if((srcclk == RCC_SAI1CLKSOURCE_HSI) || (srcclk == RCC_SAI2CLKSOURCE_HSI))
;;;3404       {
;;;3405         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;3406         {
;;;3407           frequency = HSI_VALUE;
;;;3408         }
;;;3409       }
;;;3410   #endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
;;;3411   
;;;3412   #else
;;;3413       if(srcclk == RCC_SAI1CLKSOURCE_PLL)
;;;3414       {
;;;3415         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI2CLK) != 0U))
;;;3416         {
;;;3417           /* f(PLL Source) / PLLM */
;;;3418           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3419           /* f(PLLSAI2CLK) = f(VCO input) * PLLN / PLLP */
;;;3420           plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
;;;3421   #if defined(RCC_PLLP_DIV_2_31_SUPPORT)
;;;3422           pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
;;;3423   #endif
;;;3424           if(pllp == 0U)
;;;3425           {
;;;3426             if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
;;;3427             {
;;;3428               pllp = 17U;
;;;3429             }
;;;3430             else
;;;3431             {
;;;3432               pllp = 7U;
;;;3433             }
;;;3434           }
;;;3435           frequency = (pllvco * plln) / pllp;
;;;3436         }
;;;3437         else if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;3438         {
;;;3439           /* HSI automatically selected as clock source if PLLs not enabled */
;;;3440           frequency = HSI_VALUE;
;;;3441         }
;;;3442         else
;;;3443         {
;;;3444           /* No clock source, frequency default init at 0 */
;;;3445         }
;;;3446       }
;;;3447       else if(srcclk == RCC_SAI1CLKSOURCE_PLLSAI1)
;;;3448       {
;;;3449         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U))
;;;3450         {
;;;3451   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3452           /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
;;;3453           /* f(PLLSAI1 Source) / PLLSAI1M */
;;;3454           pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
;;;3455   #else
;;;3456           /* f(PLL Source) / PLLM */
;;;3457           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
;;;3458   #endif
;;;3459           /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
;;;3460           plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
;;;3461   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;3462           pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
;;;3463   #endif
;;;3464           if(pllp == 0U)
;;;3465           {
;;;3466             if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != 0U)
;;;3467             {
;;;3468               pllp = 17U;
;;;3469             }
;;;3470             else
;;;3471             {
;;;3472               pllp = 7U;
;;;3473             }
;;;3474           }
;;;3475           frequency = (pllvco * plln) / pllp;
;;;3476         }
;;;3477         else if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
;;;3478         {
;;;3479           /* HSI automatically selected as clock source if PLLs not enabled */
;;;3480           frequency = HSI_VALUE;
;;;3481         }
;;;3482         else
;;;3483         {
;;;3484           /* No clock source, frequency default init at 0 */
;;;3485         }
;;;3486       }
;;;3487   #endif /* SAI2 */
;;;3488   
;;;3489   #if defined(RCC_PLLSAI2_SUPPORT)
;;;3490   
;;;3491       else if((srcclk == RCC_SAI1CLKSOURCE_PLLSAI2) || (srcclk == RCC_SAI2CLKSOURCE_PLLSAI2))
000050  f5b20f80          CMP      r2,#0x400000
000054  d002              BEQ      |L28.92|
000056  f1b27f80          CMP      r2,#0x1000000
00005a  d12e              BNE      |L28.186|
                  |L28.92|
;;;3492       {
;;;3493         if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI2RDY) && (__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != 0U))
00005c  681a              LDR      r2,[r3,#0]
00005e  0092              LSLS     r2,r2,#2
000060  d52b              BPL      |L28.186|
000062  695a              LDR      r2,[r3,#0x14]
000064  03d2              LSLS     r2,r2,#15
000066  d528              BPL      |L28.186|
;;;3494         {
;;;3495   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3496           /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
;;;3497           /* f(PLLSAI2 Source) / PLLSAI2M */
;;;3498           pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
;;;3499   #else
;;;3500           /* f(PLL Source) / PLLM */
;;;3501           pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
000068  68d8              LDR      r0,[r3,#0xc]
00006a  f3c01002          UBFX     r0,r0,#4,#3
00006e  1c40              ADDS     r0,r0,#1
000070  fbb1f1f0          UDIV     r1,r1,r0
;;;3502   #endif
;;;3503           /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
;;;3504           plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
000074  6958              LDR      r0,[r3,#0x14]
000076  f3c02206          UBFX     r2,r0,#8,#7
;;;3505   #if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
;;;3506           pllp = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PDIV) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos;
00007a  6958              LDR      r0,[r3,#0x14]
00007c  0ec0              LSRS     r0,r0,#27
;;;3507   #endif
;;;3508           if(pllp == 0U)
00007e  b3a0              CBZ      r0,|L28.234|
000080  e03f              B        |L28.258|
                  |L28.130|
000082  681a              LDR      r2,[r3,#0]            ;3348
000084  0192              LSLS     r2,r2,#6              ;3348
000086  d518              BPL      |L28.186|
000088  68da              LDR      r2,[r3,#0xc]          ;3348
00008a  03d2              LSLS     r2,r2,#15             ;3348
00008c  d515              BPL      |L28.186|
00008e  68d8              LDR      r0,[r3,#0xc]          ;3351
000090  f3c01002          UBFX     r0,r0,#4,#3           ;3351
000094  1c40              ADDS     r0,r0,#1              ;3351
000096  fbb1f1f0          UDIV     r1,r1,r0              ;3351
00009a  68d8              LDR      r0,[r3,#0xc]          ;3353
00009c  f3c02206          UBFX     r2,r0,#8,#7           ;3353
0000a0  68d8              LDR      r0,[r3,#0xc]          ;3355
0000a2  0ec0              LSRS     r0,r0,#27             ;3355
0000a4  b930              CBNZ     r0,|L28.180|
0000a6  68d8              LDR      r0,[r3,#0xc]          ;3359
0000a8  0380              LSLS     r0,r0,#14             ;3359
0000aa  d502              BPL      |L28.178|
0000ac  2011              MOVS     r0,#0x11              ;3361
0000ae  e001              B        |L28.180|
                  |L28.176|
0000b0  e004              B        |L28.188|
                  |L28.178|
0000b2  2007              MOVS     r0,#7                 ;3365
                  |L28.180|
0000b4  4351              MULS     r1,r2,r1              ;3368
0000b6  fbb1f0f0          UDIV     r0,r1,r0              ;3368
                  |L28.186|
;;;3509           {
;;;3510             if(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) != 0U)
;;;3511             {
;;;3512               pllp = 17U;
;;;3513             }
;;;3514             else
;;;3515             {
;;;3516               pllp = 7U;
;;;3517             }
;;;3518           }
;;;3519           frequency = (pllvco * plln) / pllp;
;;;3520         }
;;;3521       }
;;;3522   
;;;3523   #endif /* RCC_PLLSAI2_SUPPORT */
;;;3524   
;;;3525       else
;;;3526       {
;;;3527         /* No clock source, frequency default init at 0 */
;;;3528       }
;;;3529     }
;;;3530   
;;;3531   
;;;3532     return frequency;
;;;3533   }
0000ba  bd30              POP      {r4,r5,pc}
                  |L28.188|
0000bc  681a              LDR      r2,[r3,#0]            ;3373
0000be  0112              LSLS     r2,r2,#4              ;3373
0000c0  d5fb              BPL      |L28.186|
0000c2  691a              LDR      r2,[r3,#0x10]         ;3373
0000c4  03d2              LSLS     r2,r2,#15             ;3373
0000c6  d5f8              BPL      |L28.186|
0000c8  68d8              LDR      r0,[r3,#0xc]          ;3381
0000ca  f3c01002          UBFX     r0,r0,#4,#3           ;3381
0000ce  1c40              ADDS     r0,r0,#1              ;3381
0000d0  fbb1f1f0          UDIV     r1,r1,r0              ;3381
0000d4  6918              LDR      r0,[r3,#0x10]         ;3384
0000d6  f3c02206          UBFX     r2,r0,#8,#7           ;3384
0000da  6918              LDR      r0,[r3,#0x10]         ;3386
0000dc  0ec0              LSRS     r0,r0,#27             ;3386
0000de  b930              CBNZ     r0,|L28.238|
0000e0  6918              LDR      r0,[r3,#0x10]         ;3390
0000e2  0380              LSLS     r0,r0,#14             ;3390
0000e4  d502              BPL      |L28.236|
0000e6  2011              MOVS     r0,#0x11              ;3392
0000e8  e001              B        |L28.238|
                  |L28.234|
0000ea  e004              B        |L28.246|
                  |L28.236|
0000ec  2007              MOVS     r0,#7                 ;3396
                  |L28.238|
0000ee  4351              MULS     r1,r2,r1              ;3399
0000f0  fbb1f0f0          UDIV     r0,r1,r0              ;3399
0000f4  bd30              POP      {r4,r5,pc}
                  |L28.246|
0000f6  6958              LDR      r0,[r3,#0x14]         ;3510
0000f8  0380              LSLS     r0,r0,#14             ;3510
0000fa  d501              BPL      |L28.256|
0000fc  2011              MOVS     r0,#0x11              ;3512
0000fe  e000              B        |L28.258|
                  |L28.256|
000100  2007              MOVS     r0,#7                 ;3516
                  |L28.258|
000102  4351              MULS     r1,r2,r1              ;3519
000104  fbb1f0f0          UDIV     r0,r1,r0              ;3519
000108  bd30              POP      {r4,r5,pc}
;;;3534   
                          ENDP

00010a  0000              DCW      0x0000
                  |L28.268|
                          DCD      0x40021000

                          AREA ||i.RCCEx_PLLSAI1_Config||, CODE, READONLY, ALIGN=2

                  RCCEx_PLLSAI1_Config PROC
;;;2904     */
;;;2905   static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2906   {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;2907     uint32_t tickstart;
;;;2908     HAL_StatusTypeDef status = HAL_OK;
000008  2400              MOVS     r4,#0
;;;2909   
;;;2910     /* check for PLLSAI1 Parameters used to output PLLSAI1CLK */
;;;2911     /* P, Q and R dividers are verified in each specific divider case below */
;;;2912     assert_param(IS_RCC_PLLSAI1SOURCE(PllSai1->PLLSAI1Source));
;;;2913     assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
;;;2914     assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
;;;2915     assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));
;;;2916   
;;;2917     /* Check that PLLSAI1 clock source and divider M can be applied */
;;;2918     if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
00000a  4e49              LDR      r6,|L29.304|
00000c  68f0              LDR      r0,[r6,#0xc]
00000e  0781              LSLS     r1,r0,#30
;;;2919     {
;;;2920       /* PLL clock source and divider M already set, check that no request for change  */
;;;2921       if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
000010  6828              LDR      r0,[r5,#0]
000012  d00e              BEQ      |L29.50|
000014  68f1              LDR      r1,[r6,#0xc]
000016  f0010103          AND      r1,r1,#3
00001a  4281              CMP      r1,r0
00001c  d107              BNE      |L29.46|
;;;2922          ||
;;;2923          (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
00001e  b130              CBZ      r0,|L29.46|
;;;2924   #if !defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;2925          ||
;;;2926          (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
000020  68f0              LDR      r0,[r6,#0xc]
000022  6869              LDR      r1,[r5,#4]
000024  f3c01002          UBFX     r0,r0,#4,#3
000028  1c40              ADDS     r0,r0,#1
00002a  4288              CMP      r0,r1
00002c  d025              BEQ      |L29.122|
                  |L29.46|
;;;2927   #endif
;;;2928         )
;;;2929       {
;;;2930         status = HAL_ERROR;
00002e  2401              MOVS     r4,#1
000030  e023              B        |L29.122|
                  |L29.50|
;;;2931       }
;;;2932     }
;;;2933     else
;;;2934     {
;;;2935       /* Check PLLSAI1 clock source availability */
;;;2936       switch(PllSai1->PLLSAI1Source)
000032  2801              CMP      r0,#1
000034  d006              BEQ      |L29.68|
000036  2802              CMP      r0,#2
000038  d009              BEQ      |L29.78|
00003a  2803              CMP      r0,#3
00003c  d00c              BEQ      |L29.88|
;;;2937       {
;;;2938       case RCC_PLLSOURCE_MSI:
;;;2939         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
;;;2940         {
;;;2941           status = HAL_ERROR;
;;;2942         }
;;;2943         break;
;;;2944       case RCC_PLLSOURCE_HSI:
;;;2945         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
;;;2946         {
;;;2947           status = HAL_ERROR;
;;;2948         }
;;;2949         break;
;;;2950       case RCC_PLLSOURCE_HSE:
;;;2951         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
;;;2952         {
;;;2953           if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
;;;2954           {
;;;2955             status = HAL_ERROR;
;;;2956           }
;;;2957         }
;;;2958         break;
;;;2959       default:
;;;2960         status = HAL_ERROR;
00003e  2401              MOVS     r4,#1
                  |L29.64|
;;;2961         break;
;;;2962       }
;;;2963   
;;;2964       if(status == HAL_OK)
000040  b194              CBZ      r4,|L29.104|
000042  e01a              B        |L29.122|
                  |L29.68|
000044  6831              LDR      r1,[r6,#0]            ;2939
000046  0789              LSLS     r1,r1,#30             ;2939
000048  d4fa              BMI      |L29.64|
00004a  2401              MOVS     r4,#1                 ;2941
00004c  e7f8              B        |L29.64|
                  |L29.78|
00004e  6831              LDR      r1,[r6,#0]            ;2945
000050  0549              LSLS     r1,r1,#21             ;2945
000052  d4f5              BMI      |L29.64|
000054  2401              MOVS     r4,#1                 ;2947
000056  e7f3              B        |L29.64|
                  |L29.88|
000058  6831              LDR      r1,[r6,#0]            ;2951
00005a  0389              LSLS     r1,r1,#14             ;2951
00005c  d4f0              BMI      |L29.64|
00005e  6831              LDR      r1,[r6,#0]            ;2953
000060  0349              LSLS     r1,r1,#13             ;2953
000062  d4ed              BMI      |L29.64|
000064  2401              MOVS     r4,#1                 ;2955
000066  e7eb              B        |L29.64|
                  |L29.104|
;;;2965       {
;;;2966   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;2967         /* Set PLLSAI1 clock source */
;;;2968         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
;;;2969   #else
;;;2970         /* Set PLLSAI1 clock source and divider M */
;;;2971         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
000068  68f1              LDR      r1,[r6,#0xc]
00006a  f0210273          BIC      r2,r1,#0x73
00006e  6869              LDR      r1,[r5,#4]
000070  1e49              SUBS     r1,r1,#1
000072  ea421101          ORR      r1,r2,r1,LSL #4
000076  4301              ORRS     r1,r1,r0
000078  60f1              STR      r1,[r6,#0xc]
                  |L29.122|
;;;2972   #endif
;;;2973       }
;;;2974     }
;;;2975   
;;;2976     if(status == HAL_OK)
00007a  bb74              CBNZ     r4,|L29.218|
;;;2977     {
;;;2978       /* Disable the PLLSAI1 */
;;;2979       __HAL_RCC_PLLSAI1_DISABLE();
00007c  6830              LDR      r0,[r6,#0]
00007e  f0206080          BIC      r0,r0,#0x4000000
000082  6030              STR      r0,[r6,#0]
;;;2980   
;;;2981       /* Get Start Tick*/
;;;2982       tickstart = HAL_GetTick();
000084  f7fffffe          BL       HAL_GetTick
000088  4607              MOV      r7,r0
;;;2983   
;;;2984       /* Wait till PLLSAI1 is ready to be updated */
;;;2985       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
00008a  e006              B        |L29.154|
                  |L29.140|
;;;2986       {
;;;2987         if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
00008c  f7fffffe          BL       HAL_GetTick
000090  1bc0              SUBS     r0,r0,r7
000092  2802              CMP      r0,#2
000094  d901              BLS      |L29.154|
;;;2988         {
;;;2989           status = HAL_TIMEOUT;
000096  2403              MOVS     r4,#3
;;;2990           break;
000098  e002              B        |L29.160|
                  |L29.154|
00009a  6830              LDR      r0,[r6,#0]            ;2985
00009c  0100              LSLS     r0,r0,#4              ;2985
00009e  d4f5              BMI      |L29.140|
                  |L29.160|
;;;2991         }
;;;2992       }
;;;2993   
;;;2994       if(status == HAL_OK)
0000a0  b9dc              CBNZ     r4,|L29.218|
;;;2995       {
;;;2996         if(Divider == DIVIDER_P_UPDATE)
0000a2  f1b80f00          CMP      r8,#0
0000a6  d019              BEQ      |L29.220|
;;;2997         {
;;;2998           assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
;;;2999   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3000   
;;;3001           /* Configure the PLLSAI1 Division factor M, P and Multiplication factor N*/
;;;3002   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;3003           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3004                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1PDIV | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;3005                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3006                      (PllSai1->PLLSAI1P << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) |
;;;3007                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;3008   #else
;;;3009           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3010                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;3011                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3012                      ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos) |
;;;3013                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;3014   #endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
;;;3015   
;;;3016   #else
;;;3017           /* Configure the PLLSAI1 Division factor P and Multiplication factor N*/
;;;3018   #if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
;;;3019           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3020                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1PDIV,
;;;3021                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3022                      (PllSai1->PLLSAI1P << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos));
;;;3023   #else
;;;3024           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3025                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P,
;;;3026                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3027                      ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
;;;3028   #endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
;;;3029   
;;;3030   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;3031         }
;;;3032         else if(Divider == DIVIDER_Q_UPDATE)
;;;3033         {
;;;3034           assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
;;;3035   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3036           /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
;;;3037           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3038                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1Q | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;3039                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3040                      (((PllSai1->PLLSAI1Q >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) |
;;;3041                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;3042   #else
;;;3043           /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
;;;3044           MODIFY_REG(RCC->PLLSAI1CFGR,
0000a8  f04f30ff          MOV      r0,#0xffffffff
0000ac  f1b80f01          CMP      r8,#1                 ;3032
0000b0  d01f              BEQ      |L29.242|
;;;3045                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1Q,
;;;3046                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3047                      (((PllSai1->PLLSAI1Q >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos));
;;;3048   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;3049         }
;;;3050         else
;;;3051         {
;;;3052           assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
;;;3053   #if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
;;;3054           /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
;;;3055           MODIFY_REG(RCC->PLLSAI1CFGR,
;;;3056                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1R | RCC_PLLSAI1CFGR_PLLSAI1M,
;;;3057                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3058                      (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos) |
;;;3059                      ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
;;;3060   #else
;;;3061           /* Configure the PLLSAI1 Division factor R and Multiplication factor N*/
;;;3062           MODIFY_REG(RCC->PLLSAI1CFGR,
0000b2  68a9              LDR      r1,[r5,#8]
0000b4  7d2a              LDRB     r2,[r5,#0x14]
0000b6  0209              LSLS     r1,r1,#8
0000b8  eb000052          ADD      r0,r0,r2,LSR #1
0000bc  ea416040          ORR      r0,r1,r0,LSL #25
0000c0  6931              LDR      r1,[r6,#0x10]
0000c2  4a1c              LDR      r2,|L29.308|
0000c4  4011              ANDS     r1,r1,r2
0000c6  4308              ORRS     r0,r0,r1
0000c8  6130              STR      r0,[r6,#0x10]
                  |L29.202|
;;;3063                      RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1R,
;;;3064                      (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
;;;3065                      (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
;;;3066   #endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
;;;3067         }
;;;3068   
;;;3069         /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
;;;3070         __HAL_RCC_PLLSAI1_ENABLE();
0000ca  6830              LDR      r0,[r6,#0]
0000cc  f0406080          ORR      r0,r0,#0x4000000
0000d0  6030              STR      r0,[r6,#0]
;;;3071   
;;;3072         /* Get Start Tick*/
;;;3073         tickstart = HAL_GetTick();
0000d2  f7fffffe          BL       HAL_GetTick
0000d6  4607              MOV      r7,r0
;;;3074   
;;;3075         /* Wait till PLLSAI1 is ready */
;;;3076         while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
0000d8  e01f              B        |L29.282|
                  |L29.218|
0000da  e026              B        |L29.298|
                  |L29.220|
0000dc  68a8              LDR      r0,[r5,#8]            ;3019
0000de  7b29              LDRB     r1,[r5,#0xc]          ;3019
0000e0  0200              LSLS     r0,r0,#8              ;3019
0000e2  ea4060c1          ORR      r0,r0,r1,LSL #27      ;3019
0000e6  6931              LDR      r1,[r6,#0x10]         ;3019
0000e8  4a13              LDR      r2,|L29.312|
0000ea  4011              ANDS     r1,r1,r2              ;3019
0000ec  4308              ORRS     r0,r0,r1              ;3019
0000ee  6130              STR      r0,[r6,#0x10]         ;3019
0000f0  e7eb              B        |L29.202|
                  |L29.242|
0000f2  68a9              LDR      r1,[r5,#8]            ;3044
0000f4  8a2a              LDRH     r2,[r5,#0x10]         ;3044
0000f6  0209              LSLS     r1,r1,#8              ;3044
0000f8  eb000052          ADD      r0,r0,r2,LSR #1       ;3044
0000fc  ea415040          ORR      r0,r1,r0,LSL #21      ;3044
000100  6931              LDR      r1,[r6,#0x10]         ;3044
000102  4a0e              LDR      r2,|L29.316|
000104  4011              ANDS     r1,r1,r2              ;3044
000106  4308              ORRS     r0,r0,r1              ;3044
000108  6130              STR      r0,[r6,#0x10]         ;3044
00010a  e7de              B        |L29.202|
                  |L29.268|
;;;3077         {
;;;3078           if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
00010c  f7fffffe          BL       HAL_GetTick
000110  1bc0              SUBS     r0,r0,r7
000112  2802              CMP      r0,#2
000114  d901              BLS      |L29.282|
;;;3079           {
;;;3080             status = HAL_TIMEOUT;
000116  2403              MOVS     r4,#3
;;;3081             break;
000118  e002              B        |L29.288|
                  |L29.282|
00011a  6830              LDR      r0,[r6,#0]            ;3076
00011c  0100              LSLS     r0,r0,#4              ;3076
00011e  d5f5              BPL      |L29.268|
                  |L29.288|
;;;3082           }
;;;3083         }
;;;3084   
;;;3085         if(status == HAL_OK)
000120  b91c              CBNZ     r4,|L29.298|
;;;3086         {
;;;3087           /* Configure the PLLSAI1 Clock output(s) */
;;;3088           __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
000122  6930              LDR      r0,[r6,#0x10]
000124  69a9              LDR      r1,[r5,#0x18]
000126  4308              ORRS     r0,r0,r1
000128  6130              STR      r0,[r6,#0x10]
                  |L29.298|
;;;3089         }
;;;3090       }
;;;3091     }
;;;3092   
;;;3093     return status;
00012a  4620              MOV      r0,r4
;;;3094   }
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;3095   
                          ENDP

                  |L29.304|
                          DCD      0x40021000
                  |L29.308|
                          DCD      0xf9ff80ff
                  |L29.312|
                          DCD      0x07ff80ff
                  |L29.316|
                          DCD      0xff9f80ff

                          AREA ||i.RCCEx_PLLSAI2_Config||, CODE, READONLY, ALIGN=2

                  RCCEx_PLLSAI2_Config PROC
;;;3109     */
;;;3110   static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3111   {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;3112     uint32_t tickstart;
;;;3113     HAL_StatusTypeDef status = HAL_OK;
000008  2400              MOVS     r4,#0
;;;3114   
;;;3115     /* check for PLLSAI2 Parameters used to output PLLSAI2CLK */
;;;3116     /* P, Q and R dividers are verified in each specific divider case below */
;;;3117     assert_param(IS_RCC_PLLSAI2SOURCE(PllSai2->PLLSAI2Source));
;;;3118     assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
;;;3119     assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
;;;3120     assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));
;;;3121   
;;;3122     /* Check that PLLSAI2 clock source and divider M can be applied */
;;;3123     if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
00000a  4e41              LDR      r6,|L30.272|
00000c  68f0              LDR      r0,[r6,#0xc]
00000e  0781              LSLS     r1,r0,#30
;;;3124     {
;;;3125       /* PLL clock source and divider M already set, check that no request for change  */
;;;3126       if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
000010  6828              LDR      r0,[r5,#0]
000012  d00e              BEQ      |L30.50|
000014  68f1              LDR      r1,[r6,#0xc]
000016  f0010103          AND      r1,r1,#3
00001a  4281              CMP      r1,r0
00001c  d107              BNE      |L30.46|
;;;3127          ||
;;;3128          (PllSai2->PLLSAI2Source == RCC_PLLSOURCE_NONE)
00001e  b130              CBZ      r0,|L30.46|
;;;3129   #if !defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3130          ||
;;;3131          (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
000020  68f0              LDR      r0,[r6,#0xc]
000022  6869              LDR      r1,[r5,#4]
000024  f3c01002          UBFX     r0,r0,#4,#3
000028  1c40              ADDS     r0,r0,#1
00002a  4288              CMP      r0,r1
00002c  d025              BEQ      |L30.122|
                  |L30.46|
;;;3132   #endif
;;;3133         )
;;;3134       {
;;;3135         status = HAL_ERROR;
00002e  2401              MOVS     r4,#1
000030  e023              B        |L30.122|
                  |L30.50|
;;;3136       }
;;;3137     }
;;;3138     else
;;;3139     {
;;;3140       /* Check PLLSAI2 clock source availability */
;;;3141       switch(PllSai2->PLLSAI2Source)
000032  2801              CMP      r0,#1
000034  d006              BEQ      |L30.68|
000036  2802              CMP      r0,#2
000038  d009              BEQ      |L30.78|
00003a  2803              CMP      r0,#3
00003c  d00c              BEQ      |L30.88|
;;;3142       {
;;;3143       case RCC_PLLSOURCE_MSI:
;;;3144         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
;;;3145         {
;;;3146           status = HAL_ERROR;
;;;3147         }
;;;3148         break;
;;;3149       case RCC_PLLSOURCE_HSI:
;;;3150         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
;;;3151         {
;;;3152           status = HAL_ERROR;
;;;3153         }
;;;3154         break;
;;;3155       case RCC_PLLSOURCE_HSE:
;;;3156         if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
;;;3157         {
;;;3158           if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
;;;3159           {
;;;3160             status = HAL_ERROR;
;;;3161           }
;;;3162         }
;;;3163         break;
;;;3164       default:
;;;3165         status = HAL_ERROR;
00003e  2401              MOVS     r4,#1
                  |L30.64|
;;;3166         break;
;;;3167       }
;;;3168   
;;;3169       if(status == HAL_OK)
000040  b194              CBZ      r4,|L30.104|
000042  e01a              B        |L30.122|
                  |L30.68|
000044  6831              LDR      r1,[r6,#0]            ;3144
000046  0789              LSLS     r1,r1,#30             ;3144
000048  d4fa              BMI      |L30.64|
00004a  2401              MOVS     r4,#1                 ;3146
00004c  e7f8              B        |L30.64|
                  |L30.78|
00004e  6831              LDR      r1,[r6,#0]            ;3150
000050  0549              LSLS     r1,r1,#21             ;3150
000052  d4f5              BMI      |L30.64|
000054  2401              MOVS     r4,#1                 ;3152
000056  e7f3              B        |L30.64|
                  |L30.88|
000058  6831              LDR      r1,[r6,#0]            ;3156
00005a  0389              LSLS     r1,r1,#14             ;3156
00005c  d4f0              BMI      |L30.64|
00005e  6831              LDR      r1,[r6,#0]            ;3158
000060  0349              LSLS     r1,r1,#13             ;3158
000062  d4ed              BMI      |L30.64|
000064  2401              MOVS     r4,#1                 ;3160
000066  e7eb              B        |L30.64|
                  |L30.104|
;;;3170       {
;;;3171   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3172         /* Set PLLSAI2 clock source */
;;;3173         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
;;;3174   #else
;;;3175         /* Set PLLSAI2 clock source and divider M */
;;;3176         MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai2->PLLSAI2Source | (PllSai2->PLLSAI2M - 1U) << RCC_PLLCFGR_PLLM_Pos);
000068  68f1              LDR      r1,[r6,#0xc]
00006a  f0210273          BIC      r2,r1,#0x73
00006e  6869              LDR      r1,[r5,#4]
000070  1e49              SUBS     r1,r1,#1
000072  ea421101          ORR      r1,r2,r1,LSL #4
000076  4301              ORRS     r1,r1,r0
000078  60f1              STR      r1,[r6,#0xc]
                  |L30.122|
;;;3177   #endif
;;;3178       }
;;;3179     }
;;;3180   
;;;3181     if(status == HAL_OK)
00007a  bbac              CBNZ     r4,|L30.232|
;;;3182     {
;;;3183       /* Disable the PLLSAI2 */
;;;3184       __HAL_RCC_PLLSAI2_DISABLE();
00007c  6830              LDR      r0,[r6,#0]
00007e  f0205080          BIC      r0,r0,#0x10000000
000082  6030              STR      r0,[r6,#0]
;;;3185   
;;;3186       /* Get Start Tick*/
;;;3187       tickstart = HAL_GetTick();
000084  f7fffffe          BL       HAL_GetTick
000088  4607              MOV      r7,r0
;;;3188   
;;;3189       /* Wait till PLLSAI2 is ready to be updated */
;;;3190       while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
00008a  e006              B        |L30.154|
                  |L30.140|
;;;3191       {
;;;3192         if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
00008c  f7fffffe          BL       HAL_GetTick
000090  1bc0              SUBS     r0,r0,r7
000092  2802              CMP      r0,#2
000094  d901              BLS      |L30.154|
;;;3193         {
;;;3194           status = HAL_TIMEOUT;
000096  2403              MOVS     r4,#3
;;;3195           break;
000098  e002              B        |L30.160|
                  |L30.154|
00009a  6830              LDR      r0,[r6,#0]            ;3190
00009c  0080              LSLS     r0,r0,#2              ;3190
00009e  d4f5              BMI      |L30.140|
                  |L30.160|
;;;3196         }
;;;3197       }
;;;3198   
;;;3199       if(status == HAL_OK)
0000a0  bb14              CBNZ     r4,|L30.232|
;;;3200       {
;;;3201         if(Divider == DIVIDER_P_UPDATE)
0000a2  f1b80f00          CMP      r8,#0
0000a6  d014              BEQ      |L30.210|
;;;3202         {
;;;3203           assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
;;;3204   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3205   
;;;3206           /* Configure the PLLSAI2 Division factor M, P and Multiplication factor N*/
;;;3207   #if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
;;;3208           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3209                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2PDIV | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3210                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3211                      (PllSai2->PLLSAI2P << RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos) |
;;;3212                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3213   #else
;;;3214           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3215                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2P | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3216                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3217                      ((PllSai2->PLLSAI2P >> 4U) << RCC_PLLSAI2CFGR_PLLSAI2P_Pos) |
;;;3218                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3219   #endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */
;;;3220   
;;;3221   #else
;;;3222           /* Configure the PLLSAI2 Division factor P and Multiplication factor N*/
;;;3223   #if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
;;;3224           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3225                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2PDIV,
;;;3226                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3227                      (PllSai2->PLLSAI2P << RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos));
;;;3228   #else
;;;3229           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3230                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2P,
;;;3231                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3232                      ((PllSai2->PLLSAI2P >> 4U) << RCC_PLLSAI2CFGR_PLLSAI2P_Pos));
;;;3233   #endif /* RCC_PLLSAI2P_DIV_2_31_SUPPORT */
;;;3234   
;;;3235   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;3236         }
;;;3237   #if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
;;;3238         else if(Divider == DIVIDER_Q_UPDATE)
;;;3239         {
;;;3240           assert_param(IS_RCC_PLLSAI2Q_VALUE(PllSai2->PLLSAI2Q));
;;;3241   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3242           /* Configure the PLLSAI2 Division factor M, Q and Multiplication factor N*/
;;;3243           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3244                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2Q | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3245                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3246                      (((PllSai2->PLLSAI2Q >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) |
;;;3247                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3248   #else
;;;3249           /* Configure the PLLSAI2 Division factor Q and Multiplication factor N*/
;;;3250           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3251                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2Q,
;;;3252                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3253                      (((PllSai2->PLLSAI2Q >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2Q_Pos));
;;;3254   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;3255         }
;;;3256   #endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
;;;3257         else
;;;3258         {
;;;3259           assert_param(IS_RCC_PLLSAI2R_VALUE(PllSai2->PLLSAI2R));
;;;3260   #if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
;;;3261           /* Configure the PLLSAI2 Division factor M, R and Multiplication factor N*/
;;;3262           MODIFY_REG(RCC->PLLSAI2CFGR,
;;;3263                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2R | RCC_PLLSAI2CFGR_PLLSAI2M,
;;;3264                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3265                      (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos) |
;;;3266                      ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
;;;3267   #else
;;;3268           /* Configure the PLLSAI2 Division factor R and Multiplication factor N*/
;;;3269           MODIFY_REG(RCC->PLLSAI2CFGR,
0000a8  68a8              LDR      r0,[r5,#8]
0000aa  7c29              LDRB     r1,[r5,#0x10]
0000ac  0200              LSLS     r0,r0,#8
0000ae  227f              MOVS     r2,#0x7f
0000b0  eb020151          ADD      r1,r2,r1,LSR #1
0000b4  ea406041          ORR      r0,r0,r1,LSL #25
0000b8  6971              LDR      r1,[r6,#0x14]
0000ba  4a16              LDR      r2,|L30.276|
0000bc  4011              ANDS     r1,r1,r2
0000be  4308              ORRS     r0,r0,r1
0000c0  6170              STR      r0,[r6,#0x14]
                  |L30.194|
;;;3270                      RCC_PLLSAI2CFGR_PLLSAI2N | RCC_PLLSAI2CFGR_PLLSAI2R,
;;;3271                      (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
;;;3272                      (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
;;;3273   #endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
;;;3274         }
;;;3275   
;;;3276         /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
;;;3277         __HAL_RCC_PLLSAI2_ENABLE();
0000c2  6830              LDR      r0,[r6,#0]
0000c4  f0405080          ORR      r0,r0,#0x10000000
0000c8  6030              STR      r0,[r6,#0]
;;;3278   
;;;3279         /* Get Start Tick*/
;;;3280         tickstart = HAL_GetTick();
0000ca  f7fffffe          BL       HAL_GetTick
0000ce  4607              MOV      r7,r0
;;;3281   
;;;3282         /* Wait till PLLSAI2 is ready */
;;;3283         while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
0000d0  e012              B        |L30.248|
                  |L30.210|
0000d2  68a8              LDR      r0,[r5,#8]            ;3224
0000d4  7b29              LDRB     r1,[r5,#0xc]          ;3224
0000d6  0200              LSLS     r0,r0,#8              ;3224
0000d8  ea4060c1          ORR      r0,r0,r1,LSL #27      ;3224
0000dc  6971              LDR      r1,[r6,#0x14]         ;3224
0000de  4a0e              LDR      r2,|L30.280|
0000e0  4011              ANDS     r1,r1,r2              ;3224
0000e2  4308              ORRS     r0,r0,r1              ;3224
0000e4  6170              STR      r0,[r6,#0x14]         ;3224
0000e6  e7ec              B        |L30.194|
                  |L30.232|
0000e8  e00e              B        |L30.264|
                  |L30.234|
;;;3284         {
;;;3285           if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
0000ea  f7fffffe          BL       HAL_GetTick
0000ee  1bc0              SUBS     r0,r0,r7
0000f0  2802              CMP      r0,#2
0000f2  d901              BLS      |L30.248|
;;;3286           {
;;;3287             status = HAL_TIMEOUT;
0000f4  2403              MOVS     r4,#3
;;;3288             break;
0000f6  e002              B        |L30.254|
                  |L30.248|
0000f8  6830              LDR      r0,[r6,#0]            ;3283
0000fa  0080              LSLS     r0,r0,#2              ;3283
0000fc  d5f5              BPL      |L30.234|
                  |L30.254|
;;;3289           }
;;;3290         }
;;;3291   
;;;3292         if(status == HAL_OK)
0000fe  b91c              CBNZ     r4,|L30.264|
;;;3293         {
;;;3294           /* Configure the PLLSAI2 Clock output(s) */
;;;3295           __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
000100  6970              LDR      r0,[r6,#0x14]
000102  6969              LDR      r1,[r5,#0x14]
000104  4308              ORRS     r0,r0,r1
000106  6170              STR      r0,[r6,#0x14]
                  |L30.264|
;;;3296         }
;;;3297       }
;;;3298     }
;;;3299   
;;;3300     return status;
000108  4620              MOV      r0,r4
;;;3301   }
00010a  e8bd81f0          POP      {r4-r8,pc}
;;;3302   
                          ENDP

00010e  0000              DCW      0x0000
                  |L30.272|
                          DCD      0x40021000
                  |L30.276|
                          DCD      0xf9ff80ff
                  |L30.280|
                          DCD      0x07ff80ff

;*** Start embedded assembler ***

#line 1 "../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 507
|__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____RRX|
#line 694
|__asm___22_stm32l4xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
