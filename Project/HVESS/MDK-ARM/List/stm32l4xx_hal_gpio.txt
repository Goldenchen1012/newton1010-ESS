; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_gpio.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_gpio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;310      */
;;;311    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;312    {
;;;313      uint32_t position = 0x00u;
000004  2300              MOVS     r3,#0
;;;314      uint32_t iocurrent;
;;;315      uint32_t tmp;
;;;316    
;;;317      /* Check the parameters */
;;;318      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;319      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;320    
;;;321      /* Configure the port pins */
;;;322      while ((GPIO_Pin >> position) != 0x00u)
;;;323      {
;;;324        /* Get current io position */
;;;325        iocurrent = (GPIO_Pin) & (1uL << position);
;;;326    
;;;327        if (iocurrent != 0x00u)
;;;328        {
;;;329          /*------------------------- EXTI Mode Configuration --------------------*/
;;;330          /* Clear the External Interrupt or Event for the current IO */
;;;331    
;;;332          tmp = SYSCFG->EXTICR[position >> 2u];
000006  f8df8108          LDR      r8,|L1.272|
00000a  f04f0c01          MOV      r12,#1                ;325
;;;333          tmp &= (0x0FuL << (4u * (position & 0x03u)));
00000e  270f              MOVS     r7,#0xf
000010  e079              B        |L1.262|
                  |L1.18|
000012  fa0cf403          LSL      r4,r12,r3             ;325
000016  46a1              MOV      r9,r4                 ;325
000018  400c              ANDS     r4,r4,r1              ;325
00001a  2c00              CMP      r4,#0                 ;327
00001c  d072              BEQ      |L1.260|
00001e  f0230203          BIC      r2,r3,#3              ;332
000022  eb020508          ADD      r5,r2,r8              ;332
000026  68aa              LDR      r2,[r5,#8]            ;332
000028  079e              LSLS     r6,r3,#30
00002a  ea4f7a16          LSR      r10,r6,#28
00002e  fa07f60a          LSL      r6,r7,r10
000032  ea060b02          AND      r11,r6,r2
;;;334          if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
000036  f1b04f90          CMP      r0,#0x48000000
00003a  d004              BEQ      |L1.70|
00003c  4a35              LDR      r2,|L1.276|
00003e  4290              CMP      r0,r2
000040  d103              BNE      |L1.74|
000042  2201              MOVS     r2,#1
000044  e020              B        |L1.136|
                  |L1.70|
000046  2200              MOVS     r2,#0
000048  e01e              B        |L1.136|
                  |L1.74|
00004a  4a33              LDR      r2,|L1.280|
00004c  4290              CMP      r0,r2
00004e  d101              BNE      |L1.84|
000050  2202              MOVS     r2,#2
000052  e019              B        |L1.136|
                  |L1.84|
000054  4a31              LDR      r2,|L1.284|
000056  4290              CMP      r0,r2
000058  d101              BNE      |L1.94|
00005a  2203              MOVS     r2,#3
00005c  e014              B        |L1.136|
                  |L1.94|
00005e  4a30              LDR      r2,|L1.288|
000060  4290              CMP      r0,r2
000062  d101              BNE      |L1.104|
000064  2204              MOVS     r2,#4
000066  e00f              B        |L1.136|
                  |L1.104|
000068  4a2e              LDR      r2,|L1.292|
00006a  4290              CMP      r0,r2
00006c  d101              BNE      |L1.114|
00006e  2205              MOVS     r2,#5
000070  e00a              B        |L1.136|
                  |L1.114|
000072  4a2d              LDR      r2,|L1.296|
000074  4290              CMP      r0,r2
000076  d101              BNE      |L1.124|
000078  2206              MOVS     r2,#6
00007a  e005              B        |L1.136|
                  |L1.124|
00007c  4a2b              LDR      r2,|L1.300|
00007e  4290              CMP      r0,r2
000080  d101              BNE      |L1.134|
000082  2207              MOVS     r2,#7
000084  e000              B        |L1.136|
                  |L1.134|
000086  2208              MOVS     r2,#8
                  |L1.136|
000088  fa02f20a          LSL      r2,r2,r10
00008c  455a              CMP      r2,r11
00008e  d11e              BNE      |L1.206|
;;;335          {
;;;336            /* Clear EXTI line configuration */
;;;337            EXTI->IMR1 &= ~(iocurrent);
000090  f8dfa09c          LDR      r10,|L1.304|
000094  f8da2000          LDR      r2,[r10,#0]
000098  43a2              BICS     r2,r2,r4
00009a  f8ca2000          STR      r2,[r10,#0]
;;;338            EXTI->EMR1 &= ~(iocurrent);
00009e  f10a0a04          ADD      r10,r10,#4
0000a2  f8da2000          LDR      r2,[r10,#0]
0000a6  43a2              BICS     r2,r2,r4
0000a8  f8ca2000          STR      r2,[r10,#0]
;;;339    
;;;340            /* Clear Rising Falling edge configuration */
;;;341            EXTI->RTSR1 &= ~(iocurrent);
0000ac  f10a0a04          ADD      r10,r10,#4
0000b0  f8da2000          LDR      r2,[r10,#0]
0000b4  43a2              BICS     r2,r2,r4
0000b6  f8ca2000          STR      r2,[r10,#0]
;;;342            EXTI->FTSR1 &= ~(iocurrent);
0000ba  f10a0a04          ADD      r10,r10,#4
0000be  f8da2000          LDR      r2,[r10,#0]
0000c2  43a2              BICS     r2,r2,r4
0000c4  f8ca2000          STR      r2,[r10,#0]
;;;343    
;;;344            tmp = 0x0FuL << (4u * (position & 0x03u));
;;;345            SYSCFG->EXTICR[position >> 2u] &= ~tmp;
0000c8  68aa              LDR      r2,[r5,#8]
0000ca  43b2              BICS     r2,r2,r6
0000cc  60aa              STR      r2,[r5,#8]
                  |L1.206|
;;;346          }
;;;347    
;;;348          /*------------------------- GPIO Mode Configuration --------------------*/
;;;349          /* Configure IO in Analog Mode */
;;;350          GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
0000ce  6804              LDR      r4,[r0,#0]
0000d0  005d              LSLS     r5,r3,#1
0000d2  2203              MOVS     r2,#3
0000d4  40aa              LSLS     r2,r2,r5
0000d6  4314              ORRS     r4,r4,r2
0000d8  6004              STR      r4,[r0,#0]
;;;351    
;;;352          /* Configure the default Alternate Function in current IO */
;;;353          GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
0000da  08dc              LSRS     r4,r3,#3
0000dc  eb000484          ADD      r4,r0,r4,LSL #2
0000e0  6a26              LDR      r6,[r4,#0x20]
0000e2  075d              LSLS     r5,r3,#29
0000e4  ea4f6ad5          LSR      r10,r5,#27
0000e8  fa07f50a          LSL      r5,r7,r10
0000ec  43ae              BICS     r6,r6,r5
0000ee  6226              STR      r6,[r4,#0x20]
;;;354    
;;;355          /* Configure the default value for IO Speed */
;;;356          GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
0000f0  6884              LDR      r4,[r0,#8]
0000f2  4394              BICS     r4,r4,r2
0000f4  6084              STR      r4,[r0,#8]
;;;357    
;;;358          /* Configure the default value IO Output Type */
;;;359          GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
0000f6  6844              LDR      r4,[r0,#4]
0000f8  ea240409          BIC      r4,r4,r9
0000fc  6044              STR      r4,[r0,#4]
;;;360    
;;;361          /* Deactivate the Pull-up and Pull-down resistor for the current IO */
;;;362          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
0000fe  68c4              LDR      r4,[r0,#0xc]
000100  4394              BICS     r4,r4,r2
000102  60c4              STR      r4,[r0,#0xc]
                  |L1.260|
;;;363    
;;;364    #if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
;;;365          /* Deactivate the Control bit of Analog mode for the current IO */
;;;366          GPIOx->ASCR &= ~(GPIO_ASCR_ASC0<< position);
;;;367    #endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */
;;;368        }
;;;369    
;;;370        position++;
000104  1c5b              ADDS     r3,r3,#1
                  |L1.262|
000106  fa31f203          LSRS     r2,r1,r3              ;322
00010a  d182              BNE      |L1.18|
;;;371      }
;;;372    }
00010c  e8bd8ff0          POP      {r4-r11,pc}
;;;373    
                          ENDP

                  |L1.272|
                          DCD      0x40010000
                  |L1.276|
                          DCD      0x48000400
                  |L1.280|
                          DCD      0x48000800
                  |L1.284|
                          DCD      0x48000c00
                  |L1.288|
                          DCD      0x48001000
                  |L1.292|
                          DCD      0x48001400
                  |L1.296|
                          DCD      0x48001800
                  |L1.300|
                          DCD      0x48001c00
                  |L1.304|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;527      */
;;;528    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;529    {
;;;530      /* Prevent unused argument(s) compilation warning */
;;;531      UNUSED(GPIO_Pin);
;;;532    
;;;533      /* NOTE: This function should not be modified, when the callback is needed,
;;;534               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;535       */
;;;536    }
;;;537    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;512      */
;;;513    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;514    {
;;;515      /* EXTI line interrupt detected */
;;;516      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
000002  4904              LDR      r1,|L3.20|
000004  680a              LDR      r2,[r1,#0]
000006  4202              TST      r2,r0
000008  d002              BEQ      |L3.16|
;;;517      {
;;;518        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000a  6008              STR      r0,[r1,#0]
;;;519        HAL_GPIO_EXTI_Callback(GPIO_Pin);
00000c  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.16|
;;;520      }
;;;521    }
000010  bd10              POP      {r4,pc}
;;;522    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40010414

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;171      */
;;;172    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;173    {
;;;174      uint32_t position = 0x00u;
000004  2200              MOVS     r2,#0
;;;175      uint32_t iocurrent;
;;;176      uint32_t temp;
;;;177    
;;;178      /* Check the parameters */
;;;179      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;180      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;181      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;182      assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;183    
;;;184      /* Configure the port pins */
;;;185      while (((GPIO_Init->Pin) >> position) != 0x00u)
;;;186      {
;;;187        /* Get current io position */
;;;188        iocurrent = (GPIO_Init->Pin) & (1uL << position);
;;;189    
;;;190        if (iocurrent != 0x00u)
;;;191        {
;;;192          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;193          /* In case of Output or Alternate function mode selection */
;;;194          if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
;;;195             (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
;;;196          {
;;;197            /* Check the Speed parameter */
;;;198            assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;199            /* Configure the IO Speed */
;;;200            temp = GPIOx->OSPEEDR;
;;;201            temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
;;;202            temp |= (GPIO_Init->Speed << (position * 2u));
;;;203            GPIOx->OSPEEDR = temp;
;;;204    
;;;205            /* Configure the IO Output Type */
;;;206            temp = GPIOx->OTYPER;
;;;207            temp &= ~(GPIO_OTYPER_OT0 << position) ;
;;;208            temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
;;;209            GPIOx->OTYPER = temp;
;;;210          }
;;;211    
;;;212    #if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
;;;213    
;;;214          /* In case of Analog mode, check if ADC control mode is selected */
;;;215          if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
;;;216          {
;;;217            /* Configure the IO Output Type */
;;;218            temp = GPIOx->ASCR;
;;;219            temp &= ~(GPIO_ASCR_ASC0 << position) ;
;;;220            temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
;;;221            GPIOx->ASCR = temp;
;;;222          }
;;;223    
;;;224    #endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */
;;;225    
;;;226          /* Activate the Pull-up or Pull down resistor for the current IO */
;;;227          temp = GPIOx->PUPDR;
;;;228          temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
;;;229          temp |= ((GPIO_Init->Pull) << (position * 2u));
;;;230          GPIOx->PUPDR = temp;
;;;231    
;;;232          /* In case of Alternate function mode selection */
;;;233          if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
;;;234          {
;;;235            /* Check the Alternate function parameters */
;;;236            assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
;;;237            assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
;;;238    
;;;239            /* Configure Alternate function mapped with the current IO */
;;;240            temp = GPIOx->AFR[position >> 3u];
;;;241            temp &= ~(0xFu << ((position & 0x07u) * 4u));
;;;242            temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
;;;243            GPIOx->AFR[position >> 3u] = temp;
;;;244          }
;;;245    
;;;246          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;247          temp = GPIOx->MODER;
;;;248          temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
;;;249          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
;;;250          GPIOx->MODER = temp;
;;;251    
;;;252          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;253          /* Configure the External Interrupt or event for the current IO */
;;;254          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
;;;255          {
;;;256            /* Enable SYSCFG Clock */
;;;257            __HAL_RCC_SYSCFG_CLK_ENABLE();
;;;258    
;;;259            temp = SYSCFG->EXTICR[position >> 2u];
;;;260            temp &= ~(0x0FuL << (4u * (position & 0x03u)));
;;;261            temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
;;;262            SYSCFG->EXTICR[position >> 2u] = temp;
;;;263    
;;;264            /* Clear EXTI line configuration */
;;;265            temp = EXTI->IMR1;
000006  f8dfa180          LDR      r10,|L4.392|
00000a  f04f0803          MOV      r8,#3                 ;201
00000e  f04f090f          MOV      r9,#0xf               ;241
;;;266            temp &= ~(iocurrent);
;;;267            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
;;;268            {
;;;269              temp |= iocurrent;
;;;270            }
;;;271            EXTI->IMR1 = temp;
;;;272    
;;;273            temp = EXTI->EMR1;
000012  f10a0b04          ADD      r11,r10,#4
000016  e0af              B        |L4.376|
                  |L4.24|
000018  2501              MOVS     r5,#1                 ;188
00001a  4095              LSLS     r5,r5,r2              ;188
00001c  402b              ANDS     r3,r3,r5              ;188
00001e  2b00              CMP      r3,#0                 ;190
000020  d071              BEQ      |L4.262|
000022  684c              LDR      r4,[r1,#4]            ;194
000024  2c01              CMP      r4,#1                 ;194
000026  d005              BEQ      |L4.52|
000028  2c02              CMP      r4,#2                 ;194
00002a  d003              BEQ      |L4.52|
00002c  2c11              CMP      r4,#0x11              ;195
00002e  d001              BEQ      |L4.52|
000030  2c12              CMP      r4,#0x12              ;195
000032  d110              BNE      |L4.86|
                  |L4.52|
000034  6886              LDR      r6,[r0,#8]            ;200
000036  0054              LSLS     r4,r2,#1              ;201
000038  fa08f704          LSL      r7,r8,r4              ;201
00003c  43be              BICS     r6,r6,r7              ;201
00003e  68cf              LDR      r7,[r1,#0xc]          ;202
000040  40a7              LSLS     r7,r7,r4              ;202
000042  4337              ORRS     r7,r7,r6              ;202
000044  6087              STR      r7,[r0,#8]            ;203
000046  6844              LDR      r4,[r0,#4]            ;206
000048  43ac              BICS     r4,r4,r5              ;207
00004a  790d              LDRB     r5,[r1,#4]            ;208
00004c  f3c51500          UBFX     r5,r5,#4,#1           ;208
000050  4095              LSLS     r5,r5,r2              ;208
000052  4325              ORRS     r5,r5,r4              ;208
000054  6045              STR      r5,[r0,#4]            ;209
                  |L4.86|
000056  68c4              LDR      r4,[r0,#0xc]          ;227
000058  0057              LSLS     r7,r2,#1              ;228
00005a  fa08f507          LSL      r5,r8,r7              ;228
00005e  43ac              BICS     r4,r4,r5              ;228
000060  688e              LDR      r6,[r1,#8]            ;229
000062  40be              LSLS     r6,r6,r7              ;229
000064  4326              ORRS     r6,r6,r4              ;229
000066  60c6              STR      r6,[r0,#0xc]          ;230
000068  684c              LDR      r4,[r1,#4]            ;233
00006a  2c02              CMP      r4,#2                 ;233
00006c  d001              BEQ      |L4.114|
00006e  2c12              CMP      r4,#0x12              ;233
000070  d112              BNE      |L4.152|
                  |L4.114|
000072  08d4              LSRS     r4,r2,#3              ;240
000074  eb000c84          ADD      r12,r0,r4,LSL #2      ;240
000078  f8dc6020          LDR      r6,[r12,#0x20]        ;240
00007c  0754              LSLS     r4,r2,#29             ;241
00007e  0ee4              LSRS     r4,r4,#27             ;241
000080  fa09fe04          LSL      lr,r9,r4              ;241
000084  ea26060e          BIC      r6,r6,lr              ;241
000088  f8d1e010          LDR      lr,[r1,#0x10]         ;242
00008c  fa0efe04          LSL      lr,lr,r4              ;242
000090  ea4e0e06          ORR      lr,lr,r6              ;242
000094  f8cce020          STR      lr,[r12,#0x20]        ;243
                  |L4.152|
000098  6804              LDR      r4,[r0,#0]            ;247
00009a  43ac              BICS     r4,r4,r5              ;248
00009c  790d              LDRB     r5,[r1,#4]            ;249
00009e  f0050503          AND      r5,r5,#3              ;249
0000a2  40bd              LSLS     r5,r5,r7              ;249
0000a4  4325              ORRS     r5,r5,r4              ;249
0000a6  6005              STR      r5,[r0,#0]            ;250
0000a8  684c              LDR      r4,[r1,#4]            ;254
0000aa  00e4              LSLS     r4,r4,#3              ;254
0000ac  d563              BPL      |L4.374|
0000ae  4c37              LDR      r4,|L4.396|
0000b0  6e25              LDR      r5,[r4,#0x60]         ;257
0000b2  f0450501          ORR      r5,r5,#1              ;257
0000b6  6625              STR      r5,[r4,#0x60]         ;257
0000b8  6e24              LDR      r4,[r4,#0x60]         ;257
0000ba  f0040401          AND      r4,r4,#1              ;257
0000be  9400              STR      r4,[sp,#0]            ;257
0000c0  4c33              LDR      r4,|L4.400|
0000c2  f0220503          BIC      r5,r2,#3              ;259
0000c6  192e              ADDS     r6,r5,r4              ;259
0000c8  68b7              LDR      r7,[r6,#8]            ;259
0000ca  0794              LSLS     r4,r2,#30             ;260
0000cc  0f25              LSRS     r5,r4,#28             ;260
0000ce  fa09f405          LSL      r4,r9,r5              ;260
0000d2  43a7              BICS     r7,r7,r4              ;260
0000d4  f1b04f90          CMP      r0,#0x48000000        ;261
0000d8  d004              BEQ      |L4.228|
0000da  4c2e              LDR      r4,|L4.404|
0000dc  42a0              CMP      r0,r4                 ;261
0000de  d103              BNE      |L4.232|
0000e0  2401              MOVS     r4,#1                 ;261
0000e2  e021              B        |L4.296|
                  |L4.228|
0000e4  2400              MOVS     r4,#0                 ;261
0000e6  e01f              B        |L4.296|
                  |L4.232|
0000e8  4c2b              LDR      r4,|L4.408|
0000ea  42a0              CMP      r0,r4                 ;261
0000ec  d101              BNE      |L4.242|
0000ee  2402              MOVS     r4,#2                 ;261
0000f0  e01a              B        |L4.296|
                  |L4.242|
0000f2  4c2a              LDR      r4,|L4.412|
0000f4  42a0              CMP      r0,r4                 ;261
0000f6  d101              BNE      |L4.252|
0000f8  2403              MOVS     r4,#3                 ;261
0000fa  e015              B        |L4.296|
                  |L4.252|
0000fc  4c28              LDR      r4,|L4.416|
0000fe  42a0              CMP      r0,r4                 ;261
000100  d102              BNE      |L4.264|
000102  2404              MOVS     r4,#4                 ;261
000104  e010              B        |L4.296|
                  |L4.262|
000106  e036              B        |L4.374|
                  |L4.264|
000108  4c26              LDR      r4,|L4.420|
00010a  42a0              CMP      r0,r4                 ;261
00010c  d101              BNE      |L4.274|
00010e  2405              MOVS     r4,#5                 ;261
000110  e00a              B        |L4.296|
                  |L4.274|
000112  4c25              LDR      r4,|L4.424|
000114  42a0              CMP      r0,r4                 ;261
000116  d101              BNE      |L4.284|
000118  2406              MOVS     r4,#6                 ;261
00011a  e005              B        |L4.296|
                  |L4.284|
00011c  4c23              LDR      r4,|L4.428|
00011e  42a0              CMP      r0,r4                 ;261
000120  d101              BNE      |L4.294|
000122  2407              MOVS     r4,#7                 ;261
000124  e000              B        |L4.296|
                  |L4.294|
000126  2408              MOVS     r4,#8                 ;261
                  |L4.296|
000128  40ac              LSLS     r4,r4,r5              ;261
00012a  433c              ORRS     r4,r4,r7              ;261
00012c  60b4              STR      r4,[r6,#8]            ;262
00012e  f8da4000          LDR      r4,[r10,#0]           ;265
000132  439c              BICS     r4,r4,r3              ;266
000134  684d              LDR      r5,[r1,#4]            ;267
000136  03ed              LSLS     r5,r5,#15             ;267
000138  d500              BPL      |L4.316|
00013a  431c              ORRS     r4,r4,r3              ;269
                  |L4.316|
00013c  f8ca4000          STR      r4,[r10,#0]           ;271
000140  f8db4000          LDR      r4,[r11,#0]
;;;274            temp &= ~(iocurrent);
000144  439c              BICS     r4,r4,r3
;;;275            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
000146  684d              LDR      r5,[r1,#4]
000148  03ad              LSLS     r5,r5,#14
00014a  d500              BPL      |L4.334|
;;;276            {
;;;277              temp |= iocurrent;
00014c  431c              ORRS     r4,r4,r3
                  |L4.334|
;;;278            }
;;;279            EXTI->EMR1 = temp;
00014e  f8cb4000          STR      r4,[r11,#0]
;;;280    
;;;281            /* Clear Rising Falling edge configuration */
;;;282            temp = EXTI->RTSR1;
000152  4d0d              LDR      r5,|L4.392|
000154  3508              ADDS     r5,r5,#8
000156  682c              LDR      r4,[r5,#0]
;;;283            temp &= ~(iocurrent);
000158  439c              BICS     r4,r4,r3
;;;284            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
00015a  684e              LDR      r6,[r1,#4]
00015c  02f6              LSLS     r6,r6,#11
00015e  d500              BPL      |L4.354|
;;;285            {
;;;286              temp |= iocurrent;
000160  431c              ORRS     r4,r4,r3
                  |L4.354|
;;;287            }
;;;288            EXTI->RTSR1 = temp;
000162  602c              STR      r4,[r5,#0]
;;;289    
;;;290            temp = EXTI->FTSR1;
000164  4d08              LDR      r5,|L4.392|
000166  350c              ADDS     r5,r5,#0xc
000168  682c              LDR      r4,[r5,#0]
;;;291            temp &= ~(iocurrent);
00016a  439c              BICS     r4,r4,r3
;;;292            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
00016c  684e              LDR      r6,[r1,#4]
00016e  02b6              LSLS     r6,r6,#10
000170  d500              BPL      |L4.372|
;;;293            {
;;;294              temp |= iocurrent;
000172  431c              ORRS     r4,r4,r3
                  |L4.372|
;;;295            }
;;;296            EXTI->FTSR1 = temp;
000174  602c              STR      r4,[r5,#0]
                  |L4.374|
;;;297          }
;;;298        }
;;;299    
;;;300        position++;
000176  1c52              ADDS     r2,r2,#1
                  |L4.376|
000178  680b              LDR      r3,[r1,#0]            ;185
00017a  fa33f402          LSRS     r4,r3,r2              ;185
00017e  f47faf4b          BNE      |L4.24|
;;;301      }
;;;302    }
000182  e8bd8ff8          POP      {r3-r11,pc}
;;;303    
                          ENDP

000186  0000              DCW      0x0000
                  |L4.392|
                          DCD      0x40010400
                  |L4.396|
                          DCD      0x40021000
                  |L4.400|
                          DCD      0x40010000
                  |L4.404|
                          DCD      0x48000400
                  |L4.408|
                          DCD      0x48000800
                  |L4.412|
                          DCD      0x48000c00
                  |L4.416|
                          DCD      0x48001000
                  |L4.420|
                          DCD      0x48001400
                  |L4.424|
                          DCD      0x48001800
                  |L4.428|
                          DCD      0x48001c00

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;477      */
;;;478    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;479    {
;;;480      __IO uint32_t tmp = GPIO_LCKR_LCKK;
;;;481    
;;;482      /* Check the parameters */
;;;483      assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
;;;484      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;485    
;;;486      /* Apply lock key write sequence */
;;;487      tmp |= GPIO_Pin;
000002  f4413280          ORR      r2,r1,#0x10000
000006  9200              STR      r2,[sp,#0]
;;;488      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;489      GPIOx->LCKR = tmp;
000008  9a00              LDR      r2,[sp,#0]
00000a  61c2              STR      r2,[r0,#0x1c]
;;;490      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;491      GPIOx->LCKR = GPIO_Pin;
00000c  61c1              STR      r1,[r0,#0x1c]
;;;492      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;493      GPIOx->LCKR = tmp;
00000e  9900              LDR      r1,[sp,#0]
000010  61c1              STR      r1,[r0,#0x1c]
;;;494      /* Read LCKK register. This read is mandatory to complete key lock sequence */
;;;495      tmp = GPIOx->LCKR;
000012  69c1              LDR      r1,[r0,#0x1c]
000014  9100              STR      r1,[sp,#0]
;;;496    
;;;497      /* Read again in order to confirm lock is active */
;;;498      if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00u)
000016  69c0              LDR      r0,[r0,#0x1c]
000018  03c0              LSLS     r0,r0,#15
00001a  d501              BPL      |L5.32|
;;;499      {
;;;500        return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;501      }
;;;502      else
;;;503      {
;;;504        return HAL_ERROR;
;;;505      }
;;;506    }
00001e  bd08              POP      {r3,pc}
                  |L5.32|
000020  2001              MOVS     r0,#1                 ;504
000022  bd08              POP      {r3,pc}
;;;507    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;396      */
;;;397    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6900              LDR      r0,[r0,#0x10]
;;;398    {
;;;399      GPIO_PinState bitstatus;
;;;400    
;;;401      /* Check the parameters */
;;;402      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;403    
;;;404      if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
000002  4208              TST      r0,r1
000004  d001              BEQ      |L6.10|
;;;405      {
;;;406        bitstatus = GPIO_PIN_SET;
000006  2001              MOVS     r0,#1
;;;407      }
;;;408      else
;;;409      {
;;;410        bitstatus = GPIO_PIN_RESET;
;;;411      }
;;;412      return bitstatus;
;;;413    }
000008  4770              BX       lr
                  |L6.10|
00000a  2000              MOVS     r0,#0                 ;410
00000c  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;452      */
;;;453    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6942              LDR      r2,[r0,#0x14]
;;;454    {
;;;455      uint32_t odr;
;;;456    
;;;457      /* Check the parameters */
;;;458      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;459    
;;;460      /* get current Ouput Data Register value */
;;;461      odr = GPIOx->ODR;
;;;462    
;;;463      /* Set selected pins that were at low level, and reset ones that were high */
;;;464      GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
000002  ea210302          BIC      r3,r1,r2
000006  400a              ANDS     r2,r2,r1
000008  ea434102          ORR      r1,r3,r2,LSL #16
00000c  6181              STR      r1,[r0,#0x18]
;;;465    }
00000e  4770              BX       lr
;;;466    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;430      */
;;;431    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  2a00              CMP      r2,#0
;;;432    {
000002  d001              BEQ      |L8.8|
;;;433      /* Check the parameters */
;;;434      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;435      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;436    
;;;437      if(PinState != GPIO_PIN_RESET)
;;;438      {
;;;439        GPIOx->BSRR = (uint32_t)GPIO_Pin;
000004  6181              STR      r1,[r0,#0x18]
;;;440      }
;;;441      else
;;;442      {
;;;443        GPIOx->BRR = (uint32_t)GPIO_Pin;
;;;444      }
;;;445    }
000006  4770              BX       lr
                  |L8.8|
000008  6281              STR      r1,[r0,#0x28]         ;443
00000a  4770              BX       lr
;;;446    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_gpio_c_ea787061____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32l4xx_hal_gpio_c_ea787061____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_gpio_c_ea787061____REVSH|
#line 507
|__asm___20_stm32l4xx_hal_gpio_c_ea787061____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_gpio_c_ea787061____RRX|
#line 694
|__asm___20_stm32l4xx_hal_gpio_c_ea787061____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
