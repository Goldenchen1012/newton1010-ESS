L 1 "..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_ll_lptim.c"
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_lptim.c
N  * @author  MCD Application Team
N  * @brief   LPTIM LL module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 0L
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32l4xx_ll_lptim.h"
S#include "stm32l4xx_ll_bus.h"
S#include "stm32l4xx_ll_rcc.h"
S
S
S#ifdef  USE_FULL_ASSERT
S#include "stm32_assert.h"
S#else
S#define assert_param(expr) ((void)0U)
S#endif
S
S/** @addtogroup STM32L4xx_LL_Driver
S  * @{
S  */
S
S#if defined (LPTIM1) || defined (LPTIM2)
S
S/** @addtogroup LPTIM_LL
S  * @{
S  */
S
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/* Private macros ------------------------------------------------------------*/
S/** @addtogroup LPTIM_LL_Private_Macros
S  * @{
S  */
S#define IS_LL_LPTIM_CLOCK_SOURCE(__VALUE__) (((__VALUE__) == LL_LPTIM_CLK_SOURCE_INTERNAL) \
S                                             || ((__VALUE__) == LL_LPTIM_CLK_SOURCE_EXTERNAL))
X#define IS_LL_LPTIM_CLOCK_SOURCE(__VALUE__) (((__VALUE__) == LL_LPTIM_CLK_SOURCE_INTERNAL)                                              || ((__VALUE__) == LL_LPTIM_CLK_SOURCE_EXTERNAL))
S
S#define IS_LL_LPTIM_CLOCK_PRESCALER(__VALUE__) (((__VALUE__) == LL_LPTIM_PRESCALER_DIV1)   \
S                                                || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV2)   \
S                                                || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV4)   \
S                                                || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV8)   \
S                                                || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV16)  \
S                                                || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV32)  \
S                                                || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV64)  \
S                                                || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV128))
X#define IS_LL_LPTIM_CLOCK_PRESCALER(__VALUE__) (((__VALUE__) == LL_LPTIM_PRESCALER_DIV1)                                                   || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV2)                                                   || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV4)                                                   || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV8)                                                   || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV16)                                                  || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV32)                                                  || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV64)                                                  || ((__VALUE__) == LL_LPTIM_PRESCALER_DIV128))
S
S#define IS_LL_LPTIM_WAVEFORM(__VALUE__) (((__VALUE__) == LL_LPTIM_OUTPUT_WAVEFORM_PWM) \
S                                         || ((__VALUE__) == LL_LPTIM_OUTPUT_WAVEFORM_SETONCE))
X#define IS_LL_LPTIM_WAVEFORM(__VALUE__) (((__VALUE__) == LL_LPTIM_OUTPUT_WAVEFORM_PWM)                                          || ((__VALUE__) == LL_LPTIM_OUTPUT_WAVEFORM_SETONCE))
S
S#define IS_LL_LPTIM_OUTPUT_POLARITY(__VALUE__) (((__VALUE__) == LL_LPTIM_OUTPUT_POLARITY_REGULAR) \
S                                                || ((__VALUE__) == LL_LPTIM_OUTPUT_POLARITY_INVERSE))
X#define IS_LL_LPTIM_OUTPUT_POLARITY(__VALUE__) (((__VALUE__) == LL_LPTIM_OUTPUT_POLARITY_REGULAR)                                                 || ((__VALUE__) == LL_LPTIM_OUTPUT_POLARITY_INVERSE))
S/**
S  * @}
S  */
S
S
S/* Private function prototypes -----------------------------------------------*/
S/* Private functions ---------------------------------------------------------*/
S/** @defgroup LPTIM_Private_Functions LPTIM Private Functions
S  * @{
S  */
S/**
S  * @}
S  */
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup LPTIM_LL_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup LPTIM_LL_EF_Init
S  * @{
S  */
S
S/**
S  * @brief  Set LPTIMx registers to their reset values.
S  * @param  LPTIMx LP Timer instance
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: LPTIMx registers are de-initialized
S  *          - ERROR: invalid LPTIMx instance
S  */
SErrorStatus LL_LPTIM_DeInit(LPTIM_TypeDef *LPTIMx)
S{
S  ErrorStatus result = SUCCESS;
S
S  /* Check the parameters */
S  assert_param(IS_LPTIM_INSTANCE(LPTIMx));
S
S  if (LPTIMx == LPTIM1)
S  {
S    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_LPTIM1);
S    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_LPTIM1);
S  }
S#if defined(LPTIM2)
S  else if (LPTIMx == LPTIM2)
S  {
S    LL_APB1_GRP2_ForceReset(LL_APB1_GRP2_PERIPH_LPTIM2);
S    LL_APB1_GRP2_ReleaseReset(LL_APB1_GRP2_PERIPH_LPTIM2);
S  }
S#endif /* LPTIM2 */
S  else
S  {
S    result = ERROR;
S  }
S
S  return result;
S}
S
S/**
S  * @brief  Set each fields of the LPTIM_InitStruct structure to its default
S  *         value.
S  * @param  LPTIM_InitStruct pointer to a @ref LL_LPTIM_InitTypeDef structure
S  * @retval None
S  */
Svoid LL_LPTIM_StructInit(LL_LPTIM_InitTypeDef *LPTIM_InitStruct)
S{
S  /* Set the default configuration */
S  LPTIM_InitStruct->ClockSource = LL_LPTIM_CLK_SOURCE_INTERNAL;
S  LPTIM_InitStruct->Prescaler   = LL_LPTIM_PRESCALER_DIV1;
S  LPTIM_InitStruct->Waveform    = LL_LPTIM_OUTPUT_WAVEFORM_PWM;
S  LPTIM_InitStruct->Polarity    = LL_LPTIM_OUTPUT_POLARITY_REGULAR;
S}
S
S/**
S  * @brief  Configure the LPTIMx peripheral according to the specified parameters.
S  * @note LL_LPTIM_Init can only be called when the LPTIM instance is disabled.
S  * @note LPTIMx can be disabled using unitary function @ref LL_LPTIM_Disable().
S  * @param  LPTIMx LP Timer Instance
S  * @param  LPTIM_InitStruct pointer to a @ref LL_LPTIM_InitTypeDef structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: LPTIMx instance has been initialized
S  *          - ERROR: LPTIMx instance hasn't been initialized
S  */
SErrorStatus LL_LPTIM_Init(LPTIM_TypeDef *LPTIMx, LL_LPTIM_InitTypeDef *LPTIM_InitStruct)
S{
S  ErrorStatus result = SUCCESS;
S  /* Check the parameters */
S  assert_param(IS_LPTIM_INSTANCE(LPTIMx));
S  assert_param(IS_LL_LPTIM_CLOCK_SOURCE(LPTIM_InitStruct->ClockSource));
S  assert_param(IS_LL_LPTIM_CLOCK_PRESCALER(LPTIM_InitStruct->Prescaler));
S  assert_param(IS_LL_LPTIM_WAVEFORM(LPTIM_InitStruct->Waveform));
S  assert_param(IS_LL_LPTIM_OUTPUT_POLARITY(LPTIM_InitStruct->Polarity));
S
S  /* The LPTIMx_CFGR register must only be modified when the LPTIM is disabled
S     (ENABLE bit is reset to 0).
S  */
S  if (LL_LPTIM_IsEnabled(LPTIMx) == 1UL)
S  {
S    result = ERROR;
S  }
S  else
S  {
S    /* Set CKSEL bitfield according to ClockSource value */
S    /* Set PRESC bitfield according to Prescaler value */
S    /* Set WAVE bitfield according to Waveform value */
S    /* Set WAVEPOL bitfield according to Polarity value */
S    MODIFY_REG(LPTIMx->CFGR,
S               (LPTIM_CFGR_CKSEL | LPTIM_CFGR_PRESC | LPTIM_CFGR_WAVE | LPTIM_CFGR_WAVPOL),
S               LPTIM_InitStruct->ClockSource | \
S               LPTIM_InitStruct->Prescaler | \
S               LPTIM_InitStruct->Waveform | \
S               LPTIM_InitStruct->Polarity);
X               LPTIM_InitStruct->ClockSource |                LPTIM_InitStruct->Prescaler |                LPTIM_InitStruct->Waveform |                LPTIM_InitStruct->Polarity);
S  }
S
S  return result;
S}
S
S/**
S  * @brief  Disable the LPTIM instance
S  * @rmtoll CR           ENABLE        LL_LPTIM_Disable
S  * @param  LPTIMx Low-Power Timer instance
S  * @note   The following sequence is required to solve LPTIM disable HW limitation.
S  *         Please check Errata Sheet ES0335 for more details under "MCU may remain
S  *         stuck in LPTIM interrupt when entering Stop mode" section.
S  * @retval None
S  */
Svoid LL_LPTIM_Disable(LPTIM_TypeDef *LPTIMx)
S{
S  LL_RCC_ClocksTypeDef rcc_clock;
S  uint32_t tmpclksource = 0;
S  uint32_t tmpIER;
S  uint32_t tmpCFGR;
S  uint32_t tmpCMP;
S  uint32_t tmpARR;
S  uint32_t tmpOR;
S#if defined(LPTIM_RCR_REP)
S  uint32_t tmpRCR;
S#endif
S
S  /* Check the parameters */
S  assert_param(IS_LPTIM_INSTANCE(LPTIMx));
S
S  __disable_irq();
S
S  /********** Save LPTIM Config *********/
S  /* Save LPTIM source clock */
S  switch ((uint32_t)LPTIMx)
S  {
S    case LPTIM1_BASE:
S      tmpclksource = LL_RCC_GetLPTIMClockSource(LL_RCC_LPTIM1_CLKSOURCE);
S      break;
S#if defined(LPTIM2)
S    case LPTIM2_BASE:
S      tmpclksource = LL_RCC_GetLPTIMClockSource(LL_RCC_LPTIM2_CLKSOURCE);
S      break;
S#endif /* LPTIM2 */
S    default:
S      break;
S  }
S
S  /* Save LPTIM configuration registers */
S  tmpIER = LPTIMx->IER;
S  tmpCFGR = LPTIMx->CFGR;
S  tmpCMP = LPTIMx->CMP;
S  tmpARR = LPTIMx->ARR;
S  tmpOR = LPTIMx->OR;
S#if defined(LPTIM_RCR_REP)
S  tmpRCR = LPTIMx->RCR;
S#endif
S
S  /************* Reset LPTIM ************/
S  (void)LL_LPTIM_DeInit(LPTIMx);
S
S  /********* Restore LPTIM Config *******/
S  LL_RCC_GetSystemClocksFreq(&rcc_clock);
S
S#if defined(LPTIM_RCR_REP)
S  if ((tmpCMP != 0UL) || (tmpARR != 0UL) || (tmpRCR != 0UL))
S#else
S  if ((tmpCMP != 0UL) || (tmpARR != 0UL))
S#endif
S  {
S    /* Force LPTIM source kernel clock from APB */
S    switch ((uint32_t)LPTIMx)
S    {
S      case LPTIM1_BASE:
S        LL_RCC_SetLPTIMClockSource(LL_RCC_LPTIM1_CLKSOURCE_PCLK1);
S        break;
S#if defined(LPTIM2)
S      case LPTIM2_BASE:
S        LL_RCC_SetLPTIMClockSource(LL_RCC_LPTIM2_CLKSOURCE_PCLK1);
S        break;
S#endif /* LPTIM2 */
S      default:
S        break;
S    }
S
S    if (tmpCMP != 0UL)
S    {
S      /* Restore CMP and ARR registers (LPTIM should be enabled first) */
S      LPTIMx->CR |= LPTIM_CR_ENABLE;
S      LPTIMx->CMP = tmpCMP;
S
S      /* Polling on CMP write ok status after above restore operation */
S      do
S      {
S        rcc_clock.SYSCLK_Frequency--; /* Used for timeout */
S      } while (((LL_LPTIM_IsActiveFlag_CMPOK(LPTIMx) != 1UL)) && ((rcc_clock.SYSCLK_Frequency) > 0UL));
S
S      LL_LPTIM_ClearFlag_CMPOK(LPTIMx);
S    }
S
S    if (tmpARR != 0UL)
S    {
S      LPTIMx->CR |= LPTIM_CR_ENABLE;
S      LPTIMx->ARR = tmpARR;
S
S      LL_RCC_GetSystemClocksFreq(&rcc_clock);
S      /* Polling on ARR write ok status after above restore operation */
S      do
S      {
S        rcc_clock.SYSCLK_Frequency--; /* Used for timeout */
S      }
S      while (((LL_LPTIM_IsActiveFlag_ARROK(LPTIMx) != 1UL)) && ((rcc_clock.SYSCLK_Frequency) > 0UL));
S
S      LL_LPTIM_ClearFlag_ARROK(LPTIMx);
S    }
S
S#if defined(LPTIM_RCR_REP)
S    if (tmpRCR != 0UL)
S    {
S      LPTIMx->CR |= LPTIM_CR_ENABLE;
S      LPTIMx->RCR = tmpRCR;
S
S      LL_RCC_GetSystemClocksFreq(&rcc_clock);
S      /* Polling on RCR write ok status after above restore operation */
S      do
S      {
S        rcc_clock.SYSCLK_Frequency--; /* Used for timeout */
S      } while (((LL_LPTIM_IsActiveFlag_REPOK(LPTIMx) != 1UL)) && ((rcc_clock.SYSCLK_Frequency) > 0UL));
S
S      LL_LPTIM_ClearFlag_REPOK(LPTIMx);
S    }
S#endif
S
S    /* Restore LPTIM source kernel clock */
S    LL_RCC_SetLPTIMClockSource(tmpclksource);
S  }
S
S  /* Restore configuration registers (LPTIM should be disabled first) */
S  LPTIMx->CR &= ~(LPTIM_CR_ENABLE);
S  LPTIMx->IER = tmpIER;
S  LPTIMx->CFGR = tmpCFGR;
S  LPTIMx->OR = tmpOR;
S
S  __enable_irq();
S}
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S#endif /* LPTIM1 || LPTIM2 */
S
S/**
S  * @}
S  */
S
N#endif /* USE_FULL_LL_DRIVER */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
