; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\smp_uart.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\smp_uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\SMP\smp_uart.c]
                          THUMB

                          AREA ||i.BSP_UART1_DMA_RX_IRQHandler||, CODE, READONLY, ALIGN=2

                  BSP_UART1_DMA_RX_IRQHandler PROC
;;;631    
;;;632    void BSP_UART1_DMA_RX_IRQHandler(void)
000000  4801              LDR      r0,|L1.8|
;;;633    {
;;;634        HAL_DMA_IRQHandler(smp_uart1_handle.hdmarx);
000002  6f00              LDR      r0,[r0,#0x70]  ; smp_uart1_handle
000004  f7ffbffe          B.W      HAL_DMA_IRQHandler
;;;635    }
;;;636    
                          ENDP

                  |L1.8|
                          DCD      ||.bss||+0x1a4

                          AREA ||i.BSP_UART1_DMA_TX_IRQHandler||, CODE, READONLY, ALIGN=2

                  BSP_UART1_DMA_TX_IRQHandler PROC
;;;643      */
;;;644    void BSP_UART1_DMA_TX_IRQHandler(void)
000000  4801              LDR      r0,|L2.8|
;;;645    {
;;;646        HAL_DMA_IRQHandler(smp_uart1_handle.hdmatx);
000002  6ec0              LDR      r0,[r0,#0x6c]  ; smp_uart1_handle
000004  f7ffbffe          B.W      HAL_DMA_IRQHandler
;;;647    }
;;;648    
                          ENDP

                  |L2.8|
                          DCD      ||.bss||+0x1a4

                          AREA ||i.DMA2_Channel3_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Channel3_IRQHandler PROC
;;;625      */
;;;626    void BSP_UART0_DMA_TX_IRQHandler(void)
000000  4801              LDR      r0,|L3.8|
;;;627    {
;;;628        HAL_DMA_IRQHandler(smp_uart0_handle.hdmatx);
000002  6ec0              LDR      r0,[r0,#0x6c]  ; smp_uart0_handle
000004  f7ffbffe          B.W      HAL_DMA_IRQHandler
;;;629    }
;;;630    
                          ENDP

                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.DMA2_Channel5_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Channel5_IRQHandler PROC
;;;613      */
;;;614    void BSP_UART0_DMA_RX_IRQHandler(void)
000000  4801              LDR      r0,|L4.8|
;;;615    {
;;;616    	HAL_DMA_IRQHandler(smp_uart0_handle.hdmarx);
000002  6f00              LDR      r0,[r0,#0x70]  ; smp_uart0_handle
000004  f7ffbffe          B.W      HAL_DMA_IRQHandler
;;;617    }
;;;618    
                          ENDP

                  |L4.8|
                          DCD      ||.bss||

                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_UART_MspDeInit PROC
;;;551      */
;;;552    void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;553    {
000002  4604              MOV      r4,r0
;;;554    	if(huart->Instance == BSP_UART0){
;;;555    
;;;556    	    /*##-1- Reset peripherals ##################################################*/
;;;557    		  BSP_UART0_FORCE_RESET();
000004  4a23              LDR      r2,|L5.148|
000006  4b22              LDR      r3,|L5.144|
;;;558    		  BSP_UART0_RELEASE_RESET();
;;;559    
;;;560    		  /*##-2- Disable peripherals and GPIO Clocks #################################*/
;;;561    		  /* Configure BSP_UART0 Tx as alternate function  */
;;;562    		  HAL_GPIO_DeInit(BSP_UART0_TX_GPIO_PORT, BSP_UART0_TX_PIN);
000008  1511              ASRS     r1,r2,#20
00000a  6820              LDR      r0,[r4,#0]            ;554
;;;563    		  /* Configure BSP_UART0 Rx as alternate function  */
;;;564    		  HAL_GPIO_DeInit(BSP_UART0_RX_GPIO_PORT, BSP_UART0_RX_PIN);
00000c  004d              LSLS     r5,r1,#1
00000e  4298              CMP      r0,r3                 ;554
000010  d11f              BNE      |L5.82|
000012  6b90              LDR      r0,[r2,#0x38]         ;557
000014  f4402000          ORR      r0,r0,#0x80000        ;557
000018  6390              STR      r0,[r2,#0x38]         ;557
00001a  6b90              LDR      r0,[r2,#0x38]         ;558
00001c  f4202000          BIC      r0,r0,#0x80000        ;558
000020  6390              STR      r0,[r2,#0x38]         ;558
000022  4e1d              LDR      r6,|L5.152|
000024  4630              MOV      r0,r6                 ;562
000026  f7fffffe          BL       HAL_GPIO_DeInit
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       HAL_GPIO_DeInit
;;;565    
;;;566    		  /*##-3- Disable BSP_UART0 DMA #####################################################*/
;;;567    		  /* De-Initialize BSP_UART0 DMA channel associated to reception process */
;;;568    		  if(huart->hdmarx != 0){
000032  6f20              LDR      r0,[r4,#0x70]
000034  b108              CBZ      r0,|L5.58|
;;;569    			    HAL_DMA_DeInit(huart->hdmarx);
000036  f7fffffe          BL       HAL_DMA_DeInit
                  |L5.58|
;;;570    		  }
;;;571    		  /* De-Initialize BSP_UART0 DMA channel associated to transmission process */
;;;572    		  if(huart->hdmatx != 0){
00003a  6ee0              LDR      r0,[r4,#0x6c]
00003c  b108              CBZ      r0,|L5.66|
;;;573    			    HAL_DMA_DeInit(huart->hdmatx);
00003e  f7fffffe          BL       HAL_DMA_DeInit
                  |L5.66|
;;;574    		  }  
;;;575    
;;;576    		  /*##-4- Disable the NVIC for BSP_UART0 DMA ###########################################*/
;;;577    		  HAL_NVIC_DisableIRQ(BSP_UART0_DMA_TX_IRQn);
000042  203a              MOVS     r0,#0x3a
000044  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;578    		  HAL_NVIC_DisableIRQ(BSP_UART0_DMA_RX_IRQn);
000048  e8bd4070          POP      {r4-r6,lr}
00004c  203c              MOVS     r0,#0x3c
00004e  f7ffbffe          B.W      HAL_NVIC_DisableIRQ
                  |L5.82|
;;;579    	}else if(huart->Instance == BSP_UART1){
000052  4b12              LDR      r3,|L5.156|
000054  4298              CMP      r0,r3
000056  d11a              BNE      |L5.142|
;;;580    		  /*##-1- Reset peripherals ##################################################*/
;;;581    		  BSP_UART1_FORCE_RESET();
000058  6b90              LDR      r0,[r2,#0x38]
00005a  f4402080          ORR      r0,r0,#0x40000
00005e  6390              STR      r0,[r2,#0x38]
;;;582    		  BSP_UART1_RELEASE_RESET();
000060  6b90              LDR      r0,[r2,#0x38]
000062  f4202080          BIC      r0,r0,#0x40000
000066  6390              STR      r0,[r2,#0x38]
;;;583    
;;;584    		  /*##-2- Disable peripherals and GPIO Clocks #################################*/
;;;585    		  /* Configure BSP_UART1 Tx as alternate function  */
;;;586    		  HAL_GPIO_DeInit(BSP_UART1_TX_GPIO_PORT, BSP_UART1_TX_PIN);
000068  4e0d              LDR      r6,|L5.160|
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       HAL_GPIO_DeInit
;;;587    		  /* Configure BSP_UART1 Rx as alternate function  */
;;;588    		  HAL_GPIO_DeInit(BSP_UART1_RX_GPIO_PORT, BSP_UART1_RX_PIN);
000070  4629              MOV      r1,r5
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       HAL_GPIO_DeInit
;;;589    
;;;590    		  /*##-3- Disable BSP_UART DMA #####################################################*/
;;;591    		  /* De-Initialize BSP_UART DMA channel associated to reception process */
;;;592    		  if(huart->hdmarx != 0){
000078  6f20              LDR      r0,[r4,#0x70]
00007a  b108              CBZ      r0,|L5.128|
;;;593    			    HAL_DMA_DeInit(huart->hdmarx);
00007c  f7fffffe          BL       HAL_DMA_DeInit
                  |L5.128|
;;;594    		  }
;;;595    		  /* De-Initialize BSP_UART DMA channel associated to transmission process */
;;;596    		  if(huart->hdmatx != 0){
000080  6ee0              LDR      r0,[r4,#0x6c]
000082  2800              CMP      r0,#0
000084  d003              BEQ      |L5.142|
;;;597    			    HAL_DMA_DeInit(huart->hdmatx);
000086  e8bd4070          POP      {r4-r6,lr}
00008a  f7ffbffe          B.W      HAL_DMA_DeInit
                  |L5.142|
;;;598    		  }  
;;;599    		  /*##-4- Disable the NVIC for BSP_UART1 DMA ###########################################*/
;;;600          #if 0
;;;601    			HAL_NVIC_DisableIRQ(BSP_UART1_DMA_TX_IRQn);
;;;602          HAL_NVIC_DisableIRQ(BSP_UART1_DMA_RX_IRQn);
;;;603          #endif
;;;604    	}
;;;605    }
00008e  bd70              POP      {r4-r6,pc}
;;;606    
                          ENDP

                  |L5.144|
                          DCD      0x40004c00
                  |L5.148|
                          DCD      0x40021000
                  |L5.152|
                          DCD      0x48000800
                  |L5.156|
                          DCD      0x40004800
                  |L5.160|
                          DCD      0x48000400

                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_UART_MspInit PROC
;;;351    
;;;352    void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;353    {
000004  b0ae              SUB      sp,sp,#0xb8
000006  4606              MOV      r6,r0
;;;354    	GPIO_InitTypeDef GPIO_InitStruct = {0};
000008  2114              MOVS     r1,#0x14
00000a  a829              ADD      r0,sp,#0xa4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;355    	RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
000010  218c              MOVS     r1,#0x8c
000012  a806              ADD      r0,sp,#0x18
000014  f7fffffe          BL       __aeabi_memclr4
;;;356    	if(huart->Instance==BSP_UART0){
000018  4b6a              LDR      r3,|L6.452|
00001a  6830              LDR      r0,[r6,#0]
00001c  2500              MOVS     r5,#0
;;;357    		static DMA_HandleTypeDef uart0_dma_tx;
;;;358    		static DMA_HandleTypeDef uart0_dma_rx;
;;;359      
;;;360    		GPIO_InitTypeDef  GPIO_InitStruct;
;;;361    
;;;362    		/*##-1- Enable peripherals and GPIO Clocks #################################*/
;;;363    		/* Enable SMP UART0 GPIO TX/RX clock */
;;;364    		BSP_UART0_TX_GPIO_CLK_ENABLE();
00001e  4c6a              LDR      r4,|L6.456|
;;;365    		BSP_UART0_RX_GPIO_CLK_ENABLE();
;;;366    
;;;367    		/* Enable SMP UART0 clock */
;;;368    		BSP_UART0_CLK_ENABLE();
;;;369    
;;;370    		/* Enable SMP UART0 DMA clock */
;;;371    		BSP_UART0_DMA_CLK_ENABLE();
;;;372    
;;;373    		/*##-2- Configure peripheral GPIO ##########################################*/  
;;;374    		/* BSP_UART0 TX GPIO pin configuration  */
;;;375    		GPIO_InitStruct.Pin       = BSP_UART0_TX_PIN | BSP_UART0_RX_PIN;
;;;376    		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
000020  2702              MOVS     r7,#2
;;;377    		GPIO_InitStruct.Pull      = GPIO_PULLUP;
000022  2101              MOVS     r1,#1
000024  f44f6240          MOV      r2,#0xc00             ;375
;;;378    		GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
000028  f04f0803          MOV      r8,#3
00002c  4298              CMP      r0,r3                 ;356
00002e  d16c              BNE      |L6.266|
000030  6ce0              LDR      r0,[r4,#0x4c]         ;364
000032  f0400004          ORR      r0,r0,#4              ;364
000036  64e0              STR      r0,[r4,#0x4c]         ;364
000038  6ce0              LDR      r0,[r4,#0x4c]         ;364
00003a  f0000004          AND      r0,r0,#4              ;364
00003e  9000              STR      r0,[sp,#0]            ;364
000040  6ce0              LDR      r0,[r4,#0x4c]         ;365
000042  f0400004          ORR      r0,r0,#4              ;365
000046  64e0              STR      r0,[r4,#0x4c]         ;365
000048  6ce0              LDR      r0,[r4,#0x4c]         ;365
00004a  f0000004          AND      r0,r0,#4              ;365
00004e  9000              STR      r0,[sp,#0]            ;365
000050  6da0              LDR      r0,[r4,#0x58]         ;368
000052  f4402000          ORR      r0,r0,#0x80000        ;368
000056  65a0              STR      r0,[r4,#0x58]         ;368
000058  6da0              LDR      r0,[r4,#0x58]         ;368
00005a  f4002000          AND      r0,r0,#0x80000        ;368
00005e  9000              STR      r0,[sp,#0]            ;368
000060  6ca0              LDR      r0,[r4,#0x48]         ;371
000062  f0400002          ORR      r0,r0,#2              ;371
000066  64a0              STR      r0,[r4,#0x48]         ;371
000068  6ca0              LDR      r0,[r4,#0x48]         ;371
00006a  f0000002          AND      r0,r0,#2              ;371
00006e  9000              STR      r0,[sp,#0]            ;371
000070  9201              STR      r2,[sp,#4]            ;375
000072  9702              STR      r7,[sp,#8]            ;376
000074  9103              STR      r1,[sp,#0xc]          ;377
000076  f8cd8010          STR      r8,[sp,#0x10]
;;;379    		GPIO_InitStruct.Alternate = BSP_UART0_TX_AF | BSP_UART0_RX_AF;
00007a  2008              MOVS     r0,#8
00007c  9005              STR      r0,[sp,#0x14]
;;;380    
;;;381    		HAL_GPIO_Init(BSP_UART0_TX_GPIO_PORT, &GPIO_InitStruct);
00007e  a901              ADD      r1,sp,#4
000080  4852              LDR      r0,|L6.460|
000082  f7fffffe          BL       HAL_GPIO_Init
;;;382    
;;;383    		/* BSP_UART0 RX GPIO pin configuration  */
;;;384    		//GPIO_InitStruct.Pin = BSP_UART0_RX_PIN;
;;;385    		//GPIO_InitStruct.Alternate = BSP_UART0_RX_AF;
;;;386    
;;;387    		//HAL_GPIO_Init(BSP_UART0_RX_GPIO_PORT, &GPIO_InitStruct);
;;;388    
;;;389    		/*##-3- Configure BSP_UART0 DMA ##################################################*/
;;;390    		/* Configure BSP_UART0 DMA handler for Transmission process */
;;;391    		uart0_dma_tx.Instance                 = BSP_UART0_TX_DMA_CHANNEL;
000086  4c53              LDR      r4,|L6.468|
000088  4851              LDR      r0,|L6.464|
00008a  6020              STR      r0,[r4,#0]  ; uart0_dma_tx
;;;392    		uart0_dma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
00008c  2010              MOVS     r0,#0x10
00008e  60a0              STR      r0,[r4,#8]  ; uart0_dma_tx
;;;393    		uart0_dma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
000090  60e5              STR      r5,[r4,#0xc]  ; uart0_dma_tx
;;;394    		uart0_dma_tx.Init.MemInc              = DMA_MINC_ENABLE;
000092  f04f0880          MOV      r8,#0x80
000096  f8c48010          STR      r8,[r4,#0x10]  ; uart0_dma_tx
;;;395    		uart0_dma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
00009a  6165              STR      r5,[r4,#0x14]  ; uart0_dma_tx
;;;396    		uart0_dma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
00009c  61a5              STR      r5,[r4,#0x18]  ; uart0_dma_tx
;;;397    		uart0_dma_tx.Init.Mode                = DMA_NORMAL;
00009e  61e5              STR      r5,[r4,#0x1c]  ; uart0_dma_tx
;;;398    		uart0_dma_tx.Init.Priority            = DMA_PRIORITY_LOW;
0000a0  6225              STR      r5,[r4,#0x20]  ; uart0_dma_tx
;;;399    		uart0_dma_tx.Init.Request             = BSP_UART0_TX_DMA_REQUEST;
0000a2  6067              STR      r7,[r4,#4]  ; uart0_dma_tx
;;;400    
;;;401    		HAL_DMA_Init(&uart0_dma_tx);
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       HAL_DMA_Init
;;;402    
;;;403    		/* Associate the initialized DMA handle to the BSP_UART0 handle */
;;;404    		__HAL_LINKDMA(huart, hdmatx, uart0_dma_tx);
0000aa  66f4              STR      r4,[r6,#0x6c]
0000ac  62a6              STR      r6,[r4,#0x28]  ; uart0_dma_tx
;;;405    
;;;406    		/* Configure the DMA handler for reception process */
;;;407    		uart0_dma_rx.Instance                 = BSP_UART0_RX_DMA_CHANNEL;
0000ae  4848              LDR      r0,|L6.464|
0000b0  3028              ADDS     r0,r0,#0x28
0000b2  3448              ADDS     r4,r4,#0x48
0000b4  6020              STR      r0,[r4,#0]  ; uart0_dma_rx
;;;408    		uart0_dma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
0000b6  60a5              STR      r5,[r4,#8]  ; uart0_dma_rx
;;;409    		uart0_dma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
0000b8  60e5              STR      r5,[r4,#0xc]  ; uart0_dma_rx
;;;410    		uart0_dma_rx.Init.MemInc              = DMA_MINC_ENABLE;
0000ba  f8c48010          STR      r8,[r4,#0x10]  ; uart0_dma_rx
;;;411    		uart0_dma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
0000be  6165              STR      r5,[r4,#0x14]  ; uart0_dma_rx
;;;412    		uart0_dma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
0000c0  61a5              STR      r5,[r4,#0x18]  ; uart0_dma_rx
;;;413    		uart0_dma_rx.Init.Mode                = DMA_NORMAL;
0000c2  61e5              STR      r5,[r4,#0x1c]  ; uart0_dma_rx
;;;414    		uart0_dma_rx.Init.Priority            = DMA_PRIORITY_HIGH;
0000c4  0338              LSLS     r0,r7,#12
0000c6  6220              STR      r0,[r4,#0x20]  ; uart0_dma_rx
;;;415    		uart0_dma_rx.Init.Request             = BSP_UART0_RX_DMA_REQUEST;
0000c8  6067              STR      r7,[r4,#4]  ; uart0_dma_rx
;;;416    
;;;417    		HAL_DMA_Init(&uart0_dma_rx);
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       HAL_DMA_Init
;;;418    
;;;419    		/* Associate the initialized DMA handle to BSP_UART0 handle */
;;;420    		__HAL_LINKDMA(huart, hdmarx, uart0_dma_rx);
0000d0  6734              STR      r4,[r6,#0x70]
0000d2  62a6              STR      r6,[r4,#0x28]  ; uart0_dma_rx
;;;421    
;;;422    		/*##-4- Configure the NVIC for DMA #########################################*/
;;;423    		/* NVIC configuration for DMA transfer complete interrupt (BSP_UART0) */
;;;424    		HAL_NVIC_SetPriority(BSP_UART0_DMA_TX_IRQn, 0, 1);
0000d4  2201              MOVS     r2,#1
0000d6  2100              MOVS     r1,#0
0000d8  203a              MOVS     r0,#0x3a
0000da  f7fffffe          BL       HAL_NVIC_SetPriority
;;;425    		HAL_NVIC_EnableIRQ(BSP_UART0_DMA_TX_IRQn);
0000de  203a              MOVS     r0,#0x3a
0000e0  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;426    
;;;427    		/* NVIC configuration for DMA transfer complete interrupt (BSP_UART0) */
;;;428    		HAL_NVIC_SetPriority(BSP_UART0_DMA_RX_IRQn, 0, 0);
0000e4  2200              MOVS     r2,#0
0000e6  4611              MOV      r1,r2
0000e8  203c              MOVS     r0,#0x3c
0000ea  f7fffffe          BL       HAL_NVIC_SetPriority
;;;429    		HAL_NVIC_EnableIRQ(BSP_UART0_DMA_RX_IRQn);
0000ee  203c              MOVS     r0,#0x3c
0000f0  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;430    
;;;431    		/* NVIC for BSP_UART0, to catch the TX complete */
;;;432    		HAL_NVIC_SetPriority(BSP_UART0_IRQn, 0, 1);
0000f4  2201              MOVS     r2,#1
0000f6  2100              MOVS     r1,#0
0000f8  2034              MOVS     r0,#0x34
0000fa  f7fffffe          BL       HAL_NVIC_SetPriority
;;;433    		HAL_NVIC_EnableIRQ(BSP_UART0_IRQn);
0000fe  2034              MOVS     r0,#0x34
000100  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L6.260|
;;;434    		
;;;435    	}else if(huart->Instance==BSP_UART1){
;;;436    		static DMA_HandleTypeDef uart1_dma_tx;
;;;437    		static DMA_HandleTypeDef uart1_dma_rx;
;;;438      
;;;439    		GPIO_InitTypeDef  GPIO_InitStruct;
;;;440    
;;;441    		/*##-1- Enable peripherals and GPIO Clocks #################################*/
;;;442    		/* Enable SMP UART GPIO TX/RX clock */
;;;443    		BSP_UART1_TX_GPIO_CLK_ENABLE();
;;;444    		BSP_UART1_RX_GPIO_CLK_ENABLE();
;;;445    
;;;446    		/* Enable SMP UART clock */
;;;447    		BSP_UART1_CLK_ENABLE();
;;;448    
;;;449    		/* Enable SMP UART DMA clock */
;;;450    		BSP_UART1_DMA_CLK_ENABLE();
;;;451    
;;;452    		/*##-2- Configure peripheral GPIO ##########################################*/  
;;;453    		/* SMP UART TX GPIO pin configuration  */
;;;454    		GPIO_InitStruct.Pin       = BSP_UART1_TX_PIN | BSP_UART1_RX_PIN;
;;;455    		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
;;;456    		GPIO_InitStruct.Pull      = GPIO_PULLUP;
;;;457    		GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
;;;458    		GPIO_InitStruct.Alternate = BSP_UART1_TX_AF | BSP_UART1_RX_AF;
;;;459    
;;;460    		HAL_GPIO_Init(BSP_UART1_TX_GPIO_PORT, &GPIO_InitStruct);
;;;461    
;;;462    		/*##-3- Configure SMP UART0 DMA ##################################################*/
;;;463    		/* Configure SMP UART DMA handler for Transmission process */
;;;464    		#if	0
;;;465    		uart1_dma_tx.Instance                 = SMP_UART1_TX_DMA_CHANNEL;
;;;466    		uart1_dma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
;;;467    		uart1_dma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
;;;468    		uart1_dma_tx.Init.MemInc              = DMA_MINC_ENABLE;
;;;469    		uart1_dma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
;;;470    		uart1_dma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
;;;471    		uart1_dma_tx.Init.Mode                = DMA_NORMAL;
;;;472    		uart1_dma_tx.Init.Priority            = DMA_PRIORITY_LOW;
;;;473    		uart1_dma_tx.Init.Request             = SMP_UART1_TX_DMA_REQUEST;
;;;474    
;;;475    		HAL_DMA_Init(&uart1_dma_tx);
;;;476    	
;;;477    		/* Associate the initialized DMA handle to the SMP UART handle */
;;;478    		__HAL_LINKDMA(huart, hdmatx, uart1_dma_tx);
;;;479    		#endif
;;;480    		
;;;481    		/* Configure the DMA handler for reception process */
;;;482    		#if	0
;;;483    		uart1_dma_rx.Instance                 = SMP_UART1_RX_DMA_CHANNEL;
;;;484    		uart1_dma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
;;;485    		uart1_dma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
;;;486    		uart1_dma_rx.Init.MemInc              = DMA_MINC_ENABLE;
;;;487    		uart1_dma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
;;;488    		uart1_dma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
;;;489    		uart1_dma_rx.Init.Mode                = DMA_NORMAL;
;;;490    		uart1_dma_rx.Init.Priority            = DMA_PRIORITY_HIGH;
;;;491    		uart1_dma_rx.Init.Request             = SMP_UART1_RX_DMA_REQUEST;
;;;492    
;;;493    		HAL_DMA_Init(&uart1_dma_rx);
;;;494    
;;;495    		/* Associate the initialized DMA handle to SMP UART handle */
;;;496    		__HAL_LINKDMA(huart, hdmarx, uart1_dma_rx);
;;;497    		
;;;498    		/*##-4- Configure the NVIC for DMA #########################################*/
;;;499    		/* NVIC configuration for DMA transfer complete interrupt (SMP UART) */
;;;500    		HAL_NVIC_SetPriority(SMP_UART1_DMA_TX_IRQn, 0, 1);
;;;501    		HAL_NVIC_EnableIRQ(SMP_UART1_DMA_TX_IRQn);
;;;502    
;;;503    		/* NVIC configuration for DMA transfer complete interrupt (SMP UART) */
;;;504    		HAL_NVIC_SetPriority(SMP_UART1_DMA_RX_IRQn, 0, 0);
;;;505    		HAL_NVIC_EnableIRQ(SMP_UART1_DMA_RX_IRQn);
;;;506    		#endif
;;;507    		/* NVIC for BSP_UART1, to catch the TX complete */
;;;508    		HAL_NVIC_SetPriority(BSP_UART1_IRQn, 0, 1);
;;;509    		HAL_NVIC_EnableIRQ(BSP_UART1_IRQn);
;;;510    	}else if(huart->Instance==USART2){
;;;511      /* USER CODE BEGIN USART2_MspInit 0 */
;;;512    
;;;513      /* USER CODE END USART2_MspInit 0 */
;;;514      /** Initializes the peripherals clock
;;;515      */
;;;516        PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
;;;517        PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
;;;518        if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
;;;519        {
;;;520          
;;;521        }
;;;522    
;;;523        /* Peripheral clock enable */
;;;524        __HAL_RCC_USART2_CLK_ENABLE();
;;;525    
;;;526        __HAL_RCC_GPIOA_CLK_ENABLE();
;;;527        /**USART2 GPIO Configuration
;;;528        PA2     ------> USART2_TX
;;;529        PA3     ------> USART2_RX
;;;530        */
;;;531        GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
;;;532        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;533        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;534        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
;;;535        GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
;;;536        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
;;;537    
;;;538      /* USER CODE BEGIN USART2_MspInit 1 */
;;;539    
;;;540      /* USER CODE END USART2_MspInit 1 */
;;;541      }
;;;542    }
000104  b02e              ADD      sp,sp,#0xb8
000106  e8bd81f0          POP      {r4-r8,pc}
                  |L6.266|
00010a  4b33              LDR      r3,|L6.472|
00010c  2607              MOVS     r6,#7                 ;458
00010e  4298              CMP      r0,r3                 ;435
000110  d132              BNE      |L6.376|
000112  6ce0              LDR      r0,[r4,#0x4c]         ;443
000114  f0400002          ORR      r0,r0,#2              ;443
000118  64e0              STR      r0,[r4,#0x4c]         ;443
00011a  6ce0              LDR      r0,[r4,#0x4c]         ;443
00011c  f0000002          AND      r0,r0,#2              ;443
000120  9000              STR      r0,[sp,#0]            ;443
000122  6ce0              LDR      r0,[r4,#0x4c]         ;444
000124  f0400002          ORR      r0,r0,#2              ;444
000128  64e0              STR      r0,[r4,#0x4c]         ;444
00012a  6ce0              LDR      r0,[r4,#0x4c]         ;444
00012c  f0000002          AND      r0,r0,#2              ;444
000130  9000              STR      r0,[sp,#0]            ;444
000132  6da0              LDR      r0,[r4,#0x58]         ;447
000134  f4402080          ORR      r0,r0,#0x40000        ;447
000138  65a0              STR      r0,[r4,#0x58]         ;447
00013a  6da0              LDR      r0,[r4,#0x58]         ;447
00013c  f4002080          AND      r0,r0,#0x40000        ;447
000140  9000              STR      r0,[sp,#0]            ;447
000142  6ca0              LDR      r0,[r4,#0x48]         ;450
000144  f0400001          ORR      r0,r0,#1              ;450
000148  64a0              STR      r0,[r4,#0x48]         ;450
00014a  6ca0              LDR      r0,[r4,#0x48]         ;450
00014c  f0000001          AND      r0,r0,#1              ;450
000150  9000              STR      r0,[sp,#0]            ;450
000152  9201              STR      r2,[sp,#4]            ;454
000154  9702              STR      r7,[sp,#8]            ;455
000156  9103              STR      r1,[sp,#0xc]          ;456
000158  f8cd8010          STR      r8,[sp,#0x10]         ;457
00015c  9605              STR      r6,[sp,#0x14]         ;458
00015e  a901              ADD      r1,sp,#4              ;460
000160  481e              LDR      r0,|L6.476|
000162  f7fffffe          BL       HAL_GPIO_Init
000166  2201              MOVS     r2,#1                 ;508
000168  2100              MOVS     r1,#0                 ;508
00016a  2027              MOVS     r0,#0x27              ;508
00016c  f7fffffe          BL       HAL_NVIC_SetPriority
000170  2027              MOVS     r0,#0x27              ;509
000172  f7fffffe          BL       HAL_NVIC_EnableIRQ
000176  e7c5              B        |L6.260|
                  |L6.376|
000178  4919              LDR      r1,|L6.480|
00017a  4288              CMP      r0,r1                 ;510
00017c  d1c2              BNE      |L6.260|
00017e  9706              STR      r7,[sp,#0x18]         ;516
000180  9515              STR      r5,[sp,#0x54]         ;517
000182  a806              ADD      r0,sp,#0x18           ;518
000184  f7fffffe          BL       HAL_RCCEx_PeriphCLKConfig
000188  6da0              LDR      r0,[r4,#0x58]         ;524
00018a  f4403000          ORR      r0,r0,#0x20000        ;524
00018e  65a0              STR      r0,[r4,#0x58]         ;524
000190  6da0              LDR      r0,[r4,#0x58]         ;524
000192  f4003000          AND      r0,r0,#0x20000        ;524
000196  9005              STR      r0,[sp,#0x14]         ;524
000198  6ce0              LDR      r0,[r4,#0x4c]         ;526
00019a  f0400001          ORR      r0,r0,#1              ;526
00019e  64e0              STR      r0,[r4,#0x4c]         ;526
0001a0  6ce0              LDR      r0,[r4,#0x4c]         ;526
0001a2  f0000001          AND      r0,r0,#1              ;526
0001a6  9005              STR      r0,[sp,#0x14]         ;526
0001a8  200c              MOVS     r0,#0xc               ;531
0001aa  9029              STR      r0,[sp,#0xa4]         ;531
0001ac  972a              STR      r7,[sp,#0xa8]         ;532
0001ae  952b              STR      r5,[sp,#0xac]         ;533
0001b0  f8cd80b0          STR      r8,[sp,#0xb0]         ;534
0001b4  962d              STR      r6,[sp,#0xb4]         ;535
0001b6  a929              ADD      r1,sp,#0xa4           ;536
0001b8  f04f4090          MOV      r0,#0x48000000        ;536
0001bc  f7fffffe          BL       HAL_GPIO_Init
0001c0  e7a0              B        |L6.260|
;;;543    
                          ENDP

0001c2  0000              DCW      0x0000
                  |L6.452|
                          DCD      0x40004c00
                  |L6.456|
                          DCD      0x40021000
                  |L6.460|
                          DCD      0x48000800
                  |L6.464|
                          DCD      0x40020430
                  |L6.468|
                          DCD      ||.bss||+0x348
                  |L6.472|
                          DCD      0x40004800
                  |L6.476|
                          DCD      0x48000400
                  |L6.480|
                          DCD      0x40004400

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=2

                  HAL_UART_RxCpltCallback PROC
;;;282      */
;;;283    void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;284    {
000002  4606              MOV      r6,r0
;;;285    	uint8_t flag=0;
000004  2400              MOVS     r4,#0
;;;286    	
;;;287    	if(huart->Instance == BSP_UART0){
000006  4823              LDR      r0,|L7.148|
000008  6831              LDR      r1,[r6,#0]
;;;288    		
;;;289    		if(smp_fifo_push(&uart0_rx_fifo, (char)uart0_rx_buffer[0]) == SMP_SUCCESS){
;;;290    			flag = 1;
;;;291    		}else{
;;;292    			flag = 0;
;;;293    		}		
;;;294    			
;;;295    		if(HAL_UART_Receive_DMA(huart, uart0_rx_buffer, UART0_RX_BUFFER_SIZE) != HAL_OK){
;;;296    			return;
;;;297    		}
;;;298    		
;;;299    		if(flag == 1){
;;;300    			if(uart0_evt_cb)
00000a  4d23              LDR      r5,|L7.152|
00000c  4281              CMP      r1,r0                 ;287
00000e  d11d              BNE      |L7.76|
000010  4628              MOV      r0,r5                 ;289
000012  7801              LDRB     r1,[r0,#0]            ;289  ; uart0_rx_buffer
000014  4821              LDR      r0,|L7.156|
000016  f7fffffe          BL       smp_fifo_push
00001a  b900              CBNZ     r0,|L7.30|
00001c  2401              MOVS     r4,#1                 ;290
                  |L7.30|
00001e  2201              MOVS     r2,#1                 ;295
000020  491d              LDR      r1,|L7.152|
000022  4630              MOV      r0,r6                 ;295
000024  f7fffffe          BL       HAL_UART_Receive_DMA
000028  2800              CMP      r0,#0                 ;295
00002a  d132              BNE      |L7.146|
00002c  2c01              CMP      r4,#1                 ;299
00002e  d006              BEQ      |L7.62|
;;;301    				uart0_evt_cb(UART_DATA_READY);
;;;302    		}else{
;;;303    			if(uart0_evt_cb)
000030  6869              LDR      r1,[r5,#4]  ; uart0_evt_cb
000032  2900              CMP      r1,#0
000034  d02d              BEQ      |L7.146|
;;;304    				uart0_evt_cb(UART_BUFFER_FULL);
000036  e8bd4070          POP      {r4-r6,lr}
00003a  2001              MOVS     r0,#1
00003c  4708              BX       r1
                  |L7.62|
00003e  6869              LDR      r1,[r5,#4]            ;300  ; uart0_evt_cb
000040  2900              CMP      r1,#0                 ;300
000042  d026              BEQ      |L7.146|
000044  e8bd4070          POP      {r4-r6,lr}            ;301
000048  2000              MOVS     r0,#0                 ;301
00004a  4708              BX       r1                    ;301
                  |L7.76|
;;;305    		}			
;;;306    		
;;;307    		/* Test debug, but may demage the uart function.
;;;308        gpio_test_p_state = GPIO_ACTIVE_TOGGLE;
;;;309        smp_gpio_set_state(&gpio_test_p, gpio_test_p_state);		
;;;310    		*/
;;;311    		
;;;312    	}else if(huart->Instance == BSP_UART1){
00004c  4814              LDR      r0,|L7.160|
00004e  4281              CMP      r1,r0
000050  d11f              BNE      |L7.146|
;;;313    		if(smp_fifo_push(&uart1_rx_fifo, (char)uart1_rx_buffer[0]) == SMP_SUCCESS){
000052  4811              LDR      r0,|L7.152|
000054  1c40              ADDS     r0,r0,#1
000056  7801              LDRB     r1,[r0,#0]  ; uart1_rx_buffer
000058  4812              LDR      r0,|L7.164|
00005a  f7fffffe          BL       smp_fifo_push
00005e  b900              CBNZ     r0,|L7.98|
;;;314    			flag = 1;
000060  2401              MOVS     r4,#1
                  |L7.98|
;;;315    		}else{
;;;316    			flag = 0;
;;;317    		}		
;;;318    			
;;;319    		if(HAL_UART_Receive_IT(huart, uart1_rx_buffer, UART1_RX_BUFFER_SIZE) != HAL_OK){
000062  490d              LDR      r1,|L7.152|
000064  2201              MOVS     r2,#1
000066  1c49              ADDS     r1,r1,#1
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       HAL_UART_Receive_IT
00006e  2800              CMP      r0,#0
000070  d10f              BNE      |L7.146|
;;;320    			return;
;;;321    		}
;;;322    		
;;;323    		if(flag == 1){
000072  2c01              CMP      r4,#1
000074  d006              BEQ      |L7.132|
;;;324            if(uart1_evt_cb)
;;;325    		        uart1_evt_cb(UART_DATA_READY);
;;;326    		}else{
;;;327    			  if(uart1_evt_cb)
000076  68a9              LDR      r1,[r5,#8]  ; uart1_evt_cb
000078  2900              CMP      r1,#0
00007a  d00a              BEQ      |L7.146|
;;;328    				    uart1_evt_cb(UART_BUFFER_FULL);
00007c  e8bd4070          POP      {r4-r6,lr}
000080  2001              MOVS     r0,#1
000082  4708              BX       r1
                  |L7.132|
000084  68a9              LDR      r1,[r5,#8]            ;324  ; uart1_evt_cb
000086  2900              CMP      r1,#0                 ;324
000088  d003              BEQ      |L7.146|
00008a  e8bd4070          POP      {r4-r6,lr}            ;325
00008e  2000              MOVS     r0,#0                 ;325
000090  4708              BX       r1                    ;325
                  |L7.146|
;;;329    		}			
;;;330    		
;;;331    		/* Test debug, but may demage the uart function.
;;;332        gpio_test_p_state = GPIO_ACTIVE_TOGGLE;
;;;333        smp_gpio_set_state(&gpio_test_p, gpio_test_p_state);		
;;;334    		*/	
;;;335    	}		
;;;336    
;;;337    }
000092  bd70              POP      {r4-r6,pc}
;;;338    
                          ENDP

                  |L7.148|
                          DCD      0x40004c00
                  |L7.152|
                          DCD      ||.data||
                  |L7.156|
                          DCD      ||.bss||+0x84
                  |L7.160|
                          DCD      0x40004800
                  |L7.164|
                          DCD      ||.bss||+0x228

                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=2

                  HAL_UART_TxCpltCallback PROC
;;;238    
;;;239    void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;240    {
;;;241    	uint16_t size = 0, i =0;
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
000006  2400              MOVS     r4,#0
;;;242    	if(huart->Instance == BSP_UART0){
000008  492a              LDR      r1,|L8.180|
00000a  6800              LDR      r0,[r0,#0]
;;;243    		if(smp_fifo_get_size(&uart0_tx_fifo,&size)==SMP_SUCCESS){
;;;244    			if(size>UART0_TX_BUFFER_SIZE)
00000c  158e              ASRS     r6,r1,#22
;;;245    				size = UART0_TX_BUFFER_SIZE;
;;;246    			// This operation should be almost always successful, since we've
;;;247    			// just added a byte to FIFO, but if some bigger delay occurred
;;;248    			// (some heavy interrupt handler routine has been executed) since
;;;249    			// that time, FIFO might be empty already.
;;;250    			for(i=0;i<size;i++){
;;;251    				smp_fifo_pop(&uart0_tx_fifo, (char *)&uart0_tx_buffer[i]);
;;;252    			}
;;;253    			HAL_UART_Transmit_DMA(&smp_uart0_handle, &uart0_tx_buffer[0], size);
;;;254    		}else{
;;;255    			if(uart0_evt_cb)
00000e  4d2a              LDR      r5,|L8.184|
000010  4288              CMP      r0,r1                 ;242
000012  d125              BNE      |L8.96|
000014  4669              MOV      r1,sp                 ;243
000016  4829              LDR      r0,|L8.188|
000018  f7fffffe          BL       smp_fifo_get_size
00001c  b128              CBZ      r0,|L8.42|
00001e  6869              LDR      r1,[r5,#4]  ; uart0_evt_cb
000020  2900              CMP      r1,#0
000022  d001              BEQ      |L8.40|
;;;256    				uart0_evt_cb(UART_TX_EMPTY);
000024  2003              MOVS     r0,#3
000026  4788              BLX      r1
                  |L8.40|
;;;257    		}
;;;258    	}else if(huart->Instance == BSP_UART1){
;;;259    		if(smp_fifo_get_size(&uart1_tx_fifo,&size)==SMP_SUCCESS){
;;;260    			if(size>UART1_TX_BUFFER_SIZE)
;;;261    				size = UART1_TX_BUFFER_SIZE;
;;;262    			// This operation should be almost always successful, since we've
;;;263    			// just added a byte to FIFO, but if some bigger delay occurred
;;;264    			// (some heavy interrupt handler routine has been executed) since
;;;265    			// that time, FIFO might be empty already.
;;;266    			for(i=0;i<size;i++){
;;;267    				smp_fifo_pop(&uart1_tx_fifo, (char *)&uart1_tx_buffer[i]);
;;;268    			}
;;;269    			HAL_UART_Transmit_IT(&smp_uart1_handle, &uart1_tx_buffer[0], size);
;;;270    		}else{
;;;271    			if(uart1_evt_cb)
;;;272    				uart1_evt_cb(UART_TX_EMPTY);
;;;273    		}
;;;274    	}
;;;275    }
000028  bdf8              POP      {r3-r7,pc}
                  |L8.42|
00002a  f8bd0000          LDRH     r0,[sp,#0]            ;244
00002e  42b0              CMP      r0,r6                 ;244
000030  d900              BLS      |L8.52|
000032  9600              STR      r6,[sp,#0]            ;245
                  |L8.52|
000034  4d21              LDR      r5,|L8.188|
000036  3510              ADDS     r5,r5,#0x10           ;251
000038  e005              B        |L8.70|
                  |L8.58|
00003a  1929              ADDS     r1,r5,r4              ;251
00003c  481f              LDR      r0,|L8.188|
00003e  f7fffffe          BL       smp_fifo_pop
000042  1c64              ADDS     r4,r4,#1              ;250
000044  b2a4              UXTH     r4,r4                 ;250
                  |L8.70|
000046  f8bd0000          LDRH     r0,[sp,#0]            ;250
00004a  4284              CMP      r4,r0                 ;250
00004c  d3f5              BCC      |L8.58|
00004e  491b              LDR      r1,|L8.188|
000050  f8bd2000          LDRH     r2,[sp,#0]            ;253
000054  3110              ADDS     r1,r1,#0x10           ;253
000056  f1a100a4          SUB      r0,r1,#0xa4           ;253
00005a  f7fffffe          BL       HAL_UART_Transmit_DMA
                  |L8.94|
00005e  bdf8              POP      {r3-r7,pc}
                  |L8.96|
000060  4917              LDR      r1,|L8.192|
000062  4288              CMP      r0,r1                 ;258
000064  d1fb              BNE      |L8.94|
000066  4669              MOV      r1,sp                 ;259
000068  4816              LDR      r0,|L8.196|
00006a  f7fffffe          BL       smp_fifo_get_size
00006e  b128              CBZ      r0,|L8.124|
000070  68a9              LDR      r1,[r5,#8]            ;271  ; uart1_evt_cb
000072  2900              CMP      r1,#0                 ;271
000074  d0f3              BEQ      |L8.94|
000076  2003              MOVS     r0,#3                 ;272
000078  4788              BLX      r1                    ;272
00007a  bdf8              POP      {r3-r7,pc}
                  |L8.124|
00007c  f8bd0000          LDRH     r0,[sp,#0]            ;260
000080  42b0              CMP      r0,r6                 ;260
000082  d900              BLS      |L8.134|
000084  9600              STR      r6,[sp,#0]            ;261
                  |L8.134|
000086  4d0f              LDR      r5,|L8.196|
000088  3510              ADDS     r5,r5,#0x10           ;267
00008a  e005              B        |L8.152|
                  |L8.140|
00008c  1929              ADDS     r1,r5,r4              ;267
00008e  480d              LDR      r0,|L8.196|
000090  f7fffffe          BL       smp_fifo_pop
000094  1c64              ADDS     r4,r4,#1              ;266
000096  b2a4              UXTH     r4,r4                 ;266
                  |L8.152|
000098  f8bd0000          LDRH     r0,[sp,#0]            ;266
00009c  4284              CMP      r4,r0                 ;266
00009e  d3f5              BCC      |L8.140|
0000a0  4908              LDR      r1,|L8.196|
0000a2  f8bd2000          LDRH     r2,[sp,#0]            ;269
0000a6  3110              ADDS     r1,r1,#0x10           ;269
0000a8  f1a100a4          SUB      r0,r1,#0xa4           ;269
0000ac  f7fffffe          BL       HAL_UART_Transmit_IT
0000b0  bdf8              POP      {r3-r7,pc}
;;;276    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L8.180|
                          DCD      0x40004c00
                  |L8.184|
                          DCD      ||.data||
                  |L8.188|
                          DCD      ||.bss||+0x94
                  |L8.192|
                          DCD      0x40004800
                  |L8.196|
                          DCD      ||.bss||+0x238

                          AREA ||i.UART4_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART4_IRQHandler PROC
;;;655      */
;;;656    void BSP_UART0_IRQHandler(void)
000000  4801              LDR      r0,|L9.8|
;;;657    {
;;;658        HAL_UART_IRQHandler(&smp_uart0_handle);
000002  f7ffbffe          B.W      HAL_UART_IRQHandler
;;;659    }
;;;660    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      ||.bss||

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;660    
;;;661    void BSP_UART1_IRQHandler(void)
000000  4801              LDR      r0,|L10.8|
;;;662    {
;;;663        HAL_UART_IRQHandler(&smp_uart1_handle);
000002  f7ffbffe          B.W      HAL_UART_IRQHandler
;;;664    }
;;;665    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      ||.bss||+0x1a4

                          AREA ||i.smp_uart_deinit||, CODE, READONLY, ALIGN=2

                  smp_uart_deinit PROC
;;;157    
;;;158    int8_t smp_uart_deinit(smp_uart_t *p_uart)
000000  b570              PUSH     {r4-r6,lr}
;;;159    {
;;;160    	if(p_uart->num == UART0){
000002  7801              LDRB     r1,[r0,#0]
000004  2400              MOVS     r4,#0
;;;161    		if(smp_uart0_handle.Instance != 0){
;;;162    			if(HAL_UART_DeInit(&smp_uart0_handle) != HAL_OK)
;;;163    				return SMP_ERROR_NOT_FOUND;
000006  1e66              SUBS     r6,r4,#1
000008  2900              CMP      r1,#0                 ;160
00000a  d002              BEQ      |L11.18|
;;;164    			smp_uart0_handle.Instance = 0;
;;;165    		}
;;;166    	}else if(p_uart->num == UART1){
00000c  2901              CMP      r1,#1
00000e  d00b              BEQ      |L11.40|
000010  e014              B        |L11.60|
                  |L11.18|
000012  4d0b              LDR      r5,|L11.64|
000014  6828              LDR      r0,[r5,#0]            ;161  ; smp_uart0_handle
000016  b188              CBZ      r0,|L11.60|
000018  4628              MOV      r0,r5                 ;162
00001a  f7fffffe          BL       HAL_UART_DeInit
00001e  b108              CBZ      r0,|L11.36|
000020  4630              MOV      r0,r6                 ;163
;;;167    		if(smp_uart1_handle.Instance != 0){
;;;168    			if(HAL_UART_DeInit(&smp_uart1_handle) != HAL_OK)
;;;169    				return SMP_ERROR_NOT_FOUND;
;;;170    			smp_uart1_handle.Instance = 0;
;;;171    		}
;;;172    	}		
;;;173    	return SMP_SUCCESS;
;;;174    }
000022  bd70              POP      {r4-r6,pc}
                  |L11.36|
000024  602c              STR      r4,[r5,#0]            ;164  ; smp_uart0_handle
000026  e009              B        |L11.60|
                  |L11.40|
000028  4d06              LDR      r5,|L11.68|
00002a  6828              LDR      r0,[r5,#0]            ;167  ; smp_uart1_handle
00002c  b130              CBZ      r0,|L11.60|
00002e  4628              MOV      r0,r5                 ;168
000030  f7fffffe          BL       HAL_UART_DeInit
000034  b108              CBZ      r0,|L11.58|
000036  4630              MOV      r0,r6                 ;169
000038  bd70              POP      {r4-r6,pc}
                  |L11.58|
00003a  602c              STR      r4,[r5,#0]            ;170  ; smp_uart1_handle
                  |L11.60|
00003c  2000              MOVS     r0,#0                 ;173
00003e  bd70              POP      {r4-r6,pc}
;;;175    
                          ENDP

                  |L11.64|
                          DCD      ||.bss||
                  |L11.68|
                          DCD      ||.bss||+0x1a4

                          AREA ||i.smp_uart_get||, CODE, READONLY, ALIGN=2

                  smp_uart_get PROC
;;;226    
;;;227    int8_t smp_uart_get(smp_uart_t *p_uart, uint8_t *p_byte)
000000  7802              LDRB     r2,[r0,#0]
;;;228    {
;;;229    	int8_t bdata;
;;;230    	if(p_uart->num == UART0){
000002  2a00              CMP      r2,#0
000004  d004              BEQ      |L12.16|
;;;231    	    bdata = smp_fifo_pop(&uart0_rx_fifo, (char *)p_byte);
;;;232    	}else if(p_uart->num == UART1){
000006  2a01              CMP      r2,#1
000008  d105              BNE      |L12.22|
;;;233    	    bdata = smp_fifo_pop(&uart1_rx_fifo, (char *)p_byte);
00000a  4803              LDR      r0,|L12.24|
00000c  f7ffbffe          B.W      smp_fifo_pop
                  |L12.16|
000010  4802              LDR      r0,|L12.28|
000012  f7ffbffe          B.W      smp_fifo_pop
                  |L12.22|
;;;234    	}
;;;235    	
;;;236    	return(bdata);
;;;237    }
000016  4770              BX       lr
;;;238    
                          ENDP

                  |L12.24|
                          DCD      ||.bss||+0x228
                  |L12.28|
                          DCD      ||.bss||+0x84

                          AREA ||i.smp_uart_init||, CODE, READONLY, ALIGN=2

                  smp_uart_init PROC
;;;65     
;;;66     int8_t smp_uart_init(smp_uart_t *p_uart, smp_uart_event_t smp_uart_event_handler)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;67     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;68     	if(p_uart->num == UART0){
000008  7820              LDRB     r0,[r4,#0]
;;;69     		smp_uart0_handle.Instance        = BSP_UART0;
;;;70     		smp_uart0_handle.Init.BaudRate   = p_uart->baud_rate;
;;;71     
;;;72     		smp_uart0_handle.Init.WordLength = UART_WORDLENGTH_8B;
;;;73     		smp_uart0_handle.Init.StopBits   = UART_STOPBITS_1;
;;;74     		if(p_uart->use_parity == PARITY_NONE){
;;;75     			smp_uart0_handle.Init.Parity     = UART_PARITY_NONE;
;;;76     		}else if(p_uart->use_parity == PARITY_EVEN){
;;;77     			smp_uart0_handle.Init.Parity     = UART_PARITY_EVEN;
;;;78     		}else if(p_uart->use_parity == PARITY_ODD){
;;;79     			smp_uart0_handle.Init.Parity     = UART_PARITY_ODD;
;;;80     		}else{
;;;81     			return SMP_ERROR_INVALID_PARAM;
00000a  f06f0102          MVN      r1,#2
;;;82     		}
;;;83     		if(p_uart->flow_ctrl == UART_FLOW_CTRL_DISABLE){
;;;84     			smp_uart0_handle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
;;;85     		}else if(p_uart->flow_ctrl == UART_FLOW_CTRL_ENABLE){
;;;86     			smp_uart0_handle.Init.HwFlowCtl  = UART_HWCONTROL_RTS_CTS;
;;;87     		}else{
;;;88     			return SMP_ERROR_INVALID_PARAM;
;;;89     		}
;;;90     			
;;;91     		smp_uart0_handle.Init.Mode       = UART_MODE_TX_RX;
;;;92     		if(HAL_UART_DeInit(&smp_uart0_handle) != HAL_OK){
;;;93     			return SMP_ERROR_NOT_FOUND;
00000e  108f              ASRS     r7,r1,#2
;;;94     		}  
;;;95     		if(HAL_UART_Init(&smp_uart0_handle) != HAL_OK){
;;;96     			return SMP_ERROR_NOT_FOUND;
;;;97     		}
;;;98     		uart0_evt_cb = smp_uart_event_handler;
000010  4e4d              LDR      r6,|L13.328|
000012  2300              MOVS     r3,#0
000014  f44f6c80          MOV      r12,#0x400            ;77
000018  f44f68c0          MOV      r8,#0x600             ;79
00001c  f44f7940          MOV      r9,#0x300             ;86
000020  f04f0a0c          MOV      r10,#0xc              ;91
000024  2800              CMP      r0,#0                 ;68
000026  d004              BEQ      |L13.50|
;;;99     		// Configure buffer RX buffer.
;;;100    		uart_fifo_init(&uart0_rx_fifo, p_uart->buffers.rx_buf, p_uart->buffers.rx_buf_size);
;;;101    		// Configure buffer TX buffer.
;;;102    		uart_fifo_init(&uart0_tx_fifo, p_uart->buffers.tx_buf, p_uart->buffers.tx_buf_size);
;;;103    
;;;104    		if(HAL_UART_Receive_DMA(&smp_uart0_handle, uart0_rx_buffer, UART0_RX_BUFFER_SIZE) != HAL_OK){
;;;105    				return SMP_ERROR_NOT_FOUND;
;;;106    		}
;;;107    	}else	if(p_uart->num == UART1){
000028  2801              CMP      r0,#1
00002a  d047              BEQ      |L13.188|
;;;108    		smp_uart1_handle.Instance        = BSP_UART1;
;;;109    		smp_uart1_handle.Init.BaudRate   = p_uart->baud_rate;
;;;110    
;;;111    		smp_uart1_handle.Init.WordLength = UART_WORDLENGTH_8B;
;;;112    		smp_uart1_handle.Init.StopBits   = UART_STOPBITS_1;
;;;113    		
;;;114    		if(p_uart->use_parity == PARITY_NONE){
;;;115    			smp_uart1_handle.Init.Parity     = UART_PARITY_NONE;
;;;116    		}else if(p_uart->use_parity == PARITY_EVEN){
;;;117    			smp_uart1_handle.Init.Parity     = UART_PARITY_EVEN;
;;;118    		}else if(p_uart->use_parity == PARITY_ODD){
;;;119    			smp_uart1_handle.Init.Parity     = UART_PARITY_ODD;
;;;120    		}else{
;;;121    			return SMP_ERROR_INVALID_PARAM;
;;;122    		}
;;;123    		if(p_uart->flow_ctrl == UART_FLOW_CTRL_DISABLE){
;;;124    			smp_uart1_handle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
;;;125    		}else if(p_uart->flow_ctrl == UART_FLOW_CTRL_ENABLE){
;;;126    			smp_uart1_handle.Init.HwFlowCtl  = UART_HWCONTROL_RTS_CTS;
;;;127    		}else{
;;;128    			return SMP_ERROR_INVALID_PARAM;
;;;129    		}
;;;130    			
;;;131    		smp_uart1_handle.Init.Mode       = UART_MODE_TX_RX;
;;;132    		if(HAL_UART_DeInit(&smp_uart1_handle) != HAL_OK){
;;;133    			return SMP_ERROR_NOT_FOUND;
;;;134    		}  
;;;135    		if(HAL_UART_Init(&smp_uart1_handle) != HAL_OK){
;;;136    			return SMP_ERROR_NOT_FOUND;
;;;137    		}
;;;138    		uart1_evt_cb = smp_uart_event_handler;
;;;139    		
;;;140    		// Configure buffer RX buffer.
;;;141    		uart_fifo_init(&uart1_rx_fifo, p_uart->buffers.rx_buf, p_uart->buffers.rx_buf_size);
;;;142    		// Configure buffer TX buffer.
;;;143    		uart_fifo_init(&uart1_tx_fifo, p_uart->buffers.tx_buf, p_uart->buffers.tx_buf_size);
;;;144    		
;;;145    		HAL_UART_Receive_IT(&smp_uart1_handle, uart1_rx_buffer, UART1_RX_BUFFER_SIZE);
;;;146    
;;;147    		#if 0
;;;148    		if(HAL_UART_Receive_DMA(&smp_uart1_handle, uart1_rx_buffer, UART3_RX_BUFFER_SIZE) != HAL_OK){
;;;149    				return SMP_ERROR_NOT_FOUND;
;;;150    		}
;;;151    		#endif
;;;152    	 }else{
;;;153    		return SMP_ERROR_NOT_SUPPORTED;
00002c  1048              ASRS     r0,r1,#1
                  |L13.46|
;;;154    	 }		
;;;155    	 return SMP_SUCCESS;
;;;156    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L13.50|
000032  4847              LDR      r0,|L13.336|
000034  4a45              LDR      r2,|L13.332|
000036  6002              STR      r2,[r0,#0]            ;69  ; smp_uart0_handle
000038  6862              LDR      r2,[r4,#4]            ;70
00003a  6042              STR      r2,[r0,#4]            ;70  ; smp_uart0_handle
00003c  6083              STR      r3,[r0,#8]            ;72  ; smp_uart0_handle
00003e  60c3              STR      r3,[r0,#0xc]          ;73  ; smp_uart0_handle
000040  7a62              LDRB     r2,[r4,#9]            ;74
000042  b12a              CBZ      r2,|L13.80|
000044  2a01              CMP      r2,#1                 ;76
000046  d005              BEQ      |L13.84|
000048  2a02              CMP      r2,#2                 ;78
00004a  d006              BEQ      |L13.90|
00004c  4608              MOV      r0,r1                 ;81
00004e  e7ee              B        |L13.46|
                  |L13.80|
000050  6103              STR      r3,[r0,#0x10]         ;75  ; smp_uart0_handle
000052  e004              B        |L13.94|
                  |L13.84|
000054  f8c0c010          STR      r12,[r0,#0x10]        ;77  ; smp_uart0_handle
000058  e001              B        |L13.94|
                  |L13.90|
00005a  f8c08010          STR      r8,[r0,#0x10]         ;79  ; smp_uart0_handle
                  |L13.94|
00005e  7a22              LDRB     r2,[r4,#8]            ;83
000060  b11a              CBZ      r2,|L13.106|
000062  2a01              CMP      r2,#1                 ;85
000064  d003              BEQ      |L13.110|
000066  4608              MOV      r0,r1                 ;88
000068  e7e1              B        |L13.46|
                  |L13.106|
00006a  6183              STR      r3,[r0,#0x18]         ;84  ; smp_uart0_handle
00006c  e001              B        |L13.114|
                  |L13.110|
00006e  f8c09018          STR      r9,[r0,#0x18]         ;86  ; smp_uart0_handle
                  |L13.114|
000072  f8c0a014          STR      r10,[r0,#0x14]        ;91  ; smp_uart0_handle
000076  4836              LDR      r0,|L13.336|
000078  f7fffffe          BL       HAL_UART_DeInit
00007c  b108              CBZ      r0,|L13.130|
00007e  4638              MOV      r0,r7                 ;93
000080  e7d5              B        |L13.46|
                  |L13.130|
000082  4833              LDR      r0,|L13.336|
000084  f7fffffe          BL       HAL_UART_Init
000088  b108              CBZ      r0,|L13.142|
00008a  4638              MOV      r0,r7                 ;96
00008c  e7cf              B        |L13.46|
                  |L13.142|
00008e  6075              STR      r5,[r6,#4]            ;98  ; uart0_evt_cb
000090  8a20              LDRH     r0,[r4,#0x10]         ;100
000092  68e1              LDR      r1,[r4,#0xc]          ;100
000094  b282              UXTH     r2,r0                 ;100
000096  482e              LDR      r0,|L13.336|
000098  3084              ADDS     r0,r0,#0x84           ;100
00009a  f7fffffe          BL       uart_fifo_init
00009e  8b20              LDRH     r0,[r4,#0x18]         ;102
0000a0  6961              LDR      r1,[r4,#0x14]         ;102
0000a2  b282              UXTH     r2,r0                 ;102
0000a4  482a              LDR      r0,|L13.336|
0000a6  3094              ADDS     r0,r0,#0x94           ;102
0000a8  f7fffffe          BL       uart_fifo_init
0000ac  2201              MOVS     r2,#1                 ;104
0000ae  4926              LDR      r1,|L13.328|
0000b0  4827              LDR      r0,|L13.336|
0000b2  f7fffffe          BL       HAL_UART_Receive_DMA
0000b6  b378              CBZ      r0,|L13.280|
0000b8  4638              MOV      r0,r7                 ;105
0000ba  e7b8              B        |L13.46|
                  |L13.188|
0000bc  4826              LDR      r0,|L13.344|
0000be  4a25              LDR      r2,|L13.340|
0000c0  6002              STR      r2,[r0,#0]            ;108  ; smp_uart1_handle
0000c2  6862              LDR      r2,[r4,#4]            ;109
0000c4  6042              STR      r2,[r0,#4]            ;109  ; smp_uart1_handle
0000c6  6083              STR      r3,[r0,#8]            ;111  ; smp_uart1_handle
0000c8  60c3              STR      r3,[r0,#0xc]          ;112  ; smp_uart1_handle
0000ca  7a62              LDRB     r2,[r4,#9]            ;114
0000cc  b12a              CBZ      r2,|L13.218|
0000ce  2a01              CMP      r2,#1                 ;116
0000d0  d005              BEQ      |L13.222|
0000d2  2a02              CMP      r2,#2                 ;118
0000d4  d006              BEQ      |L13.228|
0000d6  4608              MOV      r0,r1                 ;121
0000d8  e7a9              B        |L13.46|
                  |L13.218|
0000da  6103              STR      r3,[r0,#0x10]         ;115  ; smp_uart1_handle
0000dc  e004              B        |L13.232|
                  |L13.222|
0000de  f8c0c010          STR      r12,[r0,#0x10]        ;117  ; smp_uart1_handle
0000e2  e001              B        |L13.232|
                  |L13.228|
0000e4  f8c08010          STR      r8,[r0,#0x10]         ;119  ; smp_uart1_handle
                  |L13.232|
0000e8  7a22              LDRB     r2,[r4,#8]            ;123
0000ea  b11a              CBZ      r2,|L13.244|
0000ec  2a01              CMP      r2,#1                 ;125
0000ee  d003              BEQ      |L13.248|
0000f0  4608              MOV      r0,r1                 ;128
0000f2  e79c              B        |L13.46|
                  |L13.244|
0000f4  6183              STR      r3,[r0,#0x18]         ;124  ; smp_uart1_handle
0000f6  e001              B        |L13.252|
                  |L13.248|
0000f8  f8c09018          STR      r9,[r0,#0x18]         ;126  ; smp_uart1_handle
                  |L13.252|
0000fc  f8c0a014          STR      r10,[r0,#0x14]        ;131  ; smp_uart1_handle
000100  4815              LDR      r0,|L13.344|
000102  f7fffffe          BL       HAL_UART_DeInit
000106  b108              CBZ      r0,|L13.268|
000108  4638              MOV      r0,r7                 ;133
00010a  e790              B        |L13.46|
                  |L13.268|
00010c  4812              LDR      r0,|L13.344|
00010e  f7fffffe          BL       HAL_UART_Init
000112  b110              CBZ      r0,|L13.282|
000114  4638              MOV      r0,r7                 ;136
000116  e78a              B        |L13.46|
                  |L13.280|
000118  e014              B        |L13.324|
                  |L13.282|
00011a  60b5              STR      r5,[r6,#8]            ;138  ; uart1_evt_cb
00011c  8a20              LDRH     r0,[r4,#0x10]         ;141
00011e  68e1              LDR      r1,[r4,#0xc]          ;141
000120  b282              UXTH     r2,r0                 ;141
000122  480d              LDR      r0,|L13.344|
000124  3084              ADDS     r0,r0,#0x84           ;141
000126  f7fffffe          BL       uart_fifo_init
00012a  8b20              LDRH     r0,[r4,#0x18]         ;143
00012c  6961              LDR      r1,[r4,#0x14]         ;143
00012e  b282              UXTH     r2,r0                 ;143
000130  4809              LDR      r0,|L13.344|
000132  3094              ADDS     r0,r0,#0x94           ;143
000134  f7fffffe          BL       uart_fifo_init
000138  4903              LDR      r1,|L13.328|
00013a  2201              MOVS     r2,#1                 ;145
00013c  1c49              ADDS     r1,r1,#1              ;145
00013e  4806              LDR      r0,|L13.344|
000140  f7fffffe          BL       HAL_UART_Receive_IT
                  |L13.324|
000144  2000              MOVS     r0,#0                 ;155
000146  e772              B        |L13.46|
;;;157    
                          ENDP

                  |L13.328|
                          DCD      ||.data||
                  |L13.332|
                          DCD      0x40004c00
                  |L13.336|
                          DCD      ||.bss||
                  |L13.340|
                          DCD      0x40004800
                  |L13.344|
                          DCD      ||.bss||+0x1a4

                          AREA ||i.smp_uart_put||, CODE, READONLY, ALIGN=2

                  smp_uart_put PROC
;;;175    
;;;176    int8_t smp_uart_put(smp_uart_t *p_uart, uint8_t byte)
000000  b538              PUSH     {r3-r5,lr}
;;;177    {
;;;178    	uint16_t size = 0, i =0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
000006  2400              MOVS     r4,#0
;;;179    	if(p_uart->num == UART0){
000008  7800              LDRB     r0,[r0,#0]
;;;180            if (smp_fifo_push(&uart0_tx_fifo, byte) == SMP_SUCCESS){
;;;181            // The new byte has been added to FIFO. It will be picked up from there
;;;182            // (in 'uart_event_handler') when all preceding bytes are transmitted.
;;;183            // But if UART is not transmitting anything at the moment, we must start
;;;184            // a new transmission here.
;;;185                if((smp_uart0_handle.gState == HAL_UART_STATE_READY)||(smp_uart0_handle.gState == HAL_UART_STATE_BUSY_RX)){
;;;186    				        if(smp_fifo_get_size(&uart0_tx_fifo,&size)==SMP_SUCCESS){
;;;187                        if(size>UART0_TX_BUFFER_SIZE)	size = UART0_TX_BUFFER_SIZE;
00000a  f44f7580          MOV      r5,#0x100
00000e  2800              CMP      r0,#0                 ;179
000010  d004              BEQ      |L14.28|
;;;188    						        // This operation should be almost always successful, since we've
;;;189    						        // just added a byte to FIFO, but if some bigger delay occurred
;;;190    						        // (some heavy interrupt handler routine has been executed) since
;;;191    						        // that time, FIFO might be empty already.
;;;192    						        for(i=0;i<size;i++){	
;;;193    							          smp_fifo_pop(&uart0_tx_fifo, (char *)&uart0_tx_buffer[i]);
;;;194    						        }
;;;195    						        HAL_UART_Transmit_DMA(&smp_uart0_handle, &uart0_tx_buffer[0], size);
;;;196    			         }
;;;197               }
;;;198    	     }
;;;199    	}else if(p_uart->num == UART1){
000012  2801              CMP      r0,#1
000014  d02e              BEQ      |L14.116|
;;;200            if (smp_fifo_push(&uart1_tx_fifo, byte) == SMP_SUCCESS){
;;;201            // The new byte has been added to FIFO. It will be picked up from there
;;;202            // (in 'uart_event_handler') when all preceding bytes are transmitted.
;;;203            // But if UART is not transmitting anything at the moment, we must start
;;;204            // a new transmission here.
;;;205    			      if((smp_uart1_handle.gState == HAL_UART_STATE_READY)||(smp_uart1_handle.gState == HAL_UART_STATE_BUSY_RX)){
;;;206    				        if(smp_fifo_get_size(&uart1_tx_fifo,&size)==SMP_SUCCESS){
;;;207    					          if(size>UART1_TX_BUFFER_SIZE) size = UART1_TX_BUFFER_SIZE;
;;;208    						        // This operation should be almost always successful, since we've
;;;209    						        // just added a byte to FIFO, but if some bigger delay occurred
;;;210    						        // (some heavy interrupt handler routine has been executed) since
;;;211    						        // that time, FIFO might be empty already.
;;;212    						        for(i=0;i<size;i++){	
;;;213    							          smp_fifo_pop(&uart1_tx_fifo, (char *)&uart1_tx_buffer[i]);
;;;214    						        }
;;;215    						        //HAL_UART_Transmit_DMA(&smp_uart1_handle, &uart1_tx_buffer[0], size);
;;;216    								HAL_UART_Transmit_IT(&smp_uart1_handle, &uart1_tx_buffer[0], size);
;;;217    			           }
;;;218                }	
;;;219    	       }
;;;220    	}else{
;;;221    		return SMP_ERROR_FULL;
000016  f06f0012          MVN      r0,#0x12
;;;222    	}
;;;223    	
;;;224    	return SMP_SUCCESS;
;;;225    }
00001a  bd38              POP      {r3-r5,pc}
                  |L14.28|
00001c  482c              LDR      r0,|L14.208|
00001e  f7fffffe          BL       smp_fifo_push
000022  bb30              CBNZ     r0,|L14.114|
000024  482a              LDR      r0,|L14.208|
000026  3894              SUBS     r0,r0,#0x94           ;185
000028  6f81              LDR      r1,[r0,#0x78]         ;185  ; smp_uart0_handle
00002a  2920              CMP      r1,#0x20              ;185
00002c  d002              BEQ      |L14.52|
00002e  6f80              LDR      r0,[r0,#0x78]         ;185  ; smp_uart0_handle
000030  2822              CMP      r0,#0x22              ;185
000032  d14a              BNE      |L14.202|
                  |L14.52|
000034  4669              MOV      r1,sp                 ;186
000036  4826              LDR      r0,|L14.208|
000038  f7fffffe          BL       smp_fifo_get_size
00003c  b9c8              CBNZ     r0,|L14.114|
00003e  f8bd0000          LDRH     r0,[sp,#0]            ;187
000042  42a8              CMP      r0,r5                 ;187
000044  d900              BLS      |L14.72|
000046  9500              STR      r5,[sp,#0]            ;187
                  |L14.72|
000048  4d21              LDR      r5,|L14.208|
00004a  3510              ADDS     r5,r5,#0x10           ;193
00004c  e005              B        |L14.90|
                  |L14.78|
00004e  1929              ADDS     r1,r5,r4              ;193
000050  481f              LDR      r0,|L14.208|
000052  f7fffffe          BL       smp_fifo_pop
000056  1c64              ADDS     r4,r4,#1              ;192
000058  b2a4              UXTH     r4,r4                 ;192
                  |L14.90|
00005a  f8bd0000          LDRH     r0,[sp,#0]            ;192
00005e  4284              CMP      r4,r0                 ;192
000060  d3f5              BCC      |L14.78|
000062  491b              LDR      r1,|L14.208|
000064  f8bd2000          LDRH     r2,[sp,#0]            ;195
000068  3110              ADDS     r1,r1,#0x10           ;195
00006a  f1a100a4          SUB      r0,r1,#0xa4           ;195
00006e  f7fffffe          BL       HAL_UART_Transmit_DMA
                  |L14.114|
000072  e02a              B        |L14.202|
                  |L14.116|
000074  4817              LDR      r0,|L14.212|
000076  f7fffffe          BL       smp_fifo_push
00007a  bb30              CBNZ     r0,|L14.202|
00007c  4815              LDR      r0,|L14.212|
00007e  3894              SUBS     r0,r0,#0x94           ;205
000080  6f81              LDR      r1,[r0,#0x78]         ;205  ; smp_uart1_handle
000082  2920              CMP      r1,#0x20              ;205
000084  d002              BEQ      |L14.140|
000086  6f80              LDR      r0,[r0,#0x78]         ;205  ; smp_uart1_handle
000088  2822              CMP      r0,#0x22              ;205
00008a  d11e              BNE      |L14.202|
                  |L14.140|
00008c  4669              MOV      r1,sp                 ;206
00008e  4811              LDR      r0,|L14.212|
000090  f7fffffe          BL       smp_fifo_get_size
000094  b9c8              CBNZ     r0,|L14.202|
000096  f8bd0000          LDRH     r0,[sp,#0]            ;207
00009a  42a8              CMP      r0,r5                 ;207
00009c  d900              BLS      |L14.160|
00009e  9500              STR      r5,[sp,#0]            ;207
                  |L14.160|
0000a0  4d0c              LDR      r5,|L14.212|
0000a2  3510              ADDS     r5,r5,#0x10           ;213
0000a4  e005              B        |L14.178|
                  |L14.166|
0000a6  1929              ADDS     r1,r5,r4              ;213
0000a8  480a              LDR      r0,|L14.212|
0000aa  f7fffffe          BL       smp_fifo_pop
0000ae  1c64              ADDS     r4,r4,#1              ;212
0000b0  b2a4              UXTH     r4,r4                 ;212
                  |L14.178|
0000b2  f8bd0000          LDRH     r0,[sp,#0]            ;212
0000b6  4284              CMP      r4,r0                 ;212
0000b8  d3f5              BCC      |L14.166|
0000ba  4906              LDR      r1,|L14.212|
0000bc  f8bd2000          LDRH     r2,[sp,#0]            ;216
0000c0  3110              ADDS     r1,r1,#0x10           ;216
0000c2  f1a100a4          SUB      r0,r1,#0xa4           ;216
0000c6  f7fffffe          BL       HAL_UART_Transmit_IT
                  |L14.202|
0000ca  2000              MOVS     r0,#0                 ;224
0000cc  bd38              POP      {r3-r5,pc}
;;;226    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L14.208|
                          DCD      ||.bss||+0x94
                  |L14.212|
                          DCD      ||.bss||+0x238

                          AREA ||i.uart_fifo_init||, CODE, READONLY, ALIGN=1

                  uart_fifo_init PROC
;;;50     
;;;51     int8_t uart_fifo_init(smp_fifo_t * p_fifo, uint8_t * p_buf, uint16_t buf_size)
000000  2900              CMP      r1,#0
;;;52     {
000002  d007              BEQ      |L15.20|
;;;53         // Check buffer for null pointer.
;;;54         if (p_buf == NULL){
;;;55             return SMP_ERROR_NULL;
;;;56         }
;;;57     
;;;58         p_fifo->buffer_addr   = (char *)p_buf;
000004  6001              STR      r1,[r0,#0]
;;;59         p_fifo->buffer_size 	= buf_size - 1;
000006  1e52              SUBS     r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;60         p_fifo->in      			= 0;
00000a  2100              MOVS     r1,#0
00000c  6081              STR      r1,[r0,#8]
;;;61         p_fifo->out     			= 0;
00000e  60c1              STR      r1,[r0,#0xc]
;;;62     
;;;63         return SMP_SUCCESS;
000010  2000              MOVS     r0,#0
;;;64     }
000012  4770              BX       lr
                  |L15.20|
000014  f06f000a          MVN      r0,#0xa               ;55
000018  4770              BX       lr
;;;65     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  smp_uart0_handle
                          %        132
                  uart0_rx_fifo
                          %        16
                  uart0_tx_fifo
                          %        16
                  uart0_tx_buffer
                          %        256
                  smp_uart1_handle
                          %        132
                  uart1_rx_fifo
                          %        16
                  uart1_tx_fifo
                          %        16
                  uart1_tx_buffer
                          %        256
                  uart0_dma_tx
                          %        72
                  uart0_dma_rx
                          %        72

                          AREA ||.data||, DATA, ALIGN=2

                  uart0_rx_buffer
000000  00                DCB      0x00
                  uart1_rx_buffer
000001  000000            DCB      0x00,0x00,0x00
                  uart0_evt_cb
                          DCD      0x00000000
                  uart1_evt_cb
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\SMP\\smp_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_smp_uart_c_62e21969____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___10_smp_uart_c_62e21969____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_smp_uart_c_62e21969____REVSH|
#line 507
|__asm___10_smp_uart_c_62e21969____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_smp_uart_c_62e21969____RRX|
#line 694
|__asm___10_smp_uart_c_62e21969____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
