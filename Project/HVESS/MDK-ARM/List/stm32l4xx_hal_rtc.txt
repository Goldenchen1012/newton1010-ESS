; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_rtc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_rtc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_rtc.c]
                          THUMB

                          AREA ||i.HAL_RTC_AlarmAEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTC_AlarmAEventCallback PROC
;;;2420     */
;;;2421   __weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;2422   {
;;;2423     /* Prevent unused argument(s) compilation warning */
;;;2424     UNUSED(hrtc);
;;;2425   
;;;2426     /* NOTE : This function should not be modified, when the callback is needed,
;;;2427               the HAL_RTC_AlarmAEventCallback could be implemented in the user file
;;;2428      */
;;;2429   }
;;;2430   
                          ENDP


                          AREA ||i.HAL_RTC_AlarmIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTC_AlarmIRQHandler PROC
;;;2339     */
;;;2340   void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;2341   {
000002  4604              MOV      r4,r0
;;;2342     /* Clear the EXTI's line Flag for RTC Alarm */
;;;2343     __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
000004  4913              LDR      r1,|L2.84|
000006  f44f2080          MOV      r0,#0x40000
00000a  6008              STR      r0,[r1,#0]
;;;2344   
;;;2345   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;2346     /* Get interrupt status */
;;;2347     uint32_t tmp = hrtc->Instance->MISR;
;;;2348   
;;;2349     if ((tmp & RTC_MISR_ALRAMF) != 0u)
;;;2350     {
;;;2351       /* Clear the AlarmA interrupt pending bit */
;;;2352       hrtc->Instance->SCR = RTC_SCR_CALRAF;
;;;2353   
;;;2354   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;2355       /* Call Compare Match registered Callback */
;;;2356       hrtc->AlarmAEventCallback(hrtc);
;;;2357   #else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;2358       HAL_RTC_AlarmAEventCallback(hrtc);
;;;2359   #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;2360     }
;;;2361   
;;;2362     if ((tmp & RTC_MISR_ALRBMF) != 0u)
;;;2363     {
;;;2364       /* Clear the AlarmB interrupt pending bit */
;;;2365       hrtc->Instance->SCR = RTC_SCR_CALRBF;
;;;2366   
;;;2367   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;2368       /* Call Compare Match registered Callback */
;;;2369       hrtc->AlarmBEventCallback(hrtc);
;;;2370   #else
;;;2371       HAL_RTCEx_AlarmBEventCallback(hrtc);
;;;2372   #endif
;;;2373     }
;;;2374   
;;;2375   #else /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2376   
;;;2377     /* Get the AlarmA interrupt source enable status */
;;;2378     if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != 0U)
00000c  6821              LDR      r1,[r4,#0]
00000e  6888              LDR      r0,[r1,#8]
000010  04c0              LSLS     r0,r0,#19
000012  d50b              BPL      |L2.44|
;;;2379     {
;;;2380       /* Get the pending status of the AlarmA Interrupt */
;;;2381       if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != 0U)
000014  68c8              LDR      r0,[r1,#0xc]
000016  05c0              LSLS     r0,r0,#23
000018  d508              BPL      |L2.44|
;;;2382       {
;;;2383         /* Clear the AlarmA interrupt pending bit */
;;;2384         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
00001a  68c8              LDR      r0,[r1,#0xc]
00001c  f0000080          AND      r0,r0,#0x80
000020  f46070c0          ORN      r0,r0,#0x180
000024  60c8              STR      r0,[r1,#0xc]
;;;2385   
;;;2386   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;2387         hrtc->AlarmAEventCallback(hrtc);
;;;2388   #else
;;;2389         HAL_RTC_AlarmAEventCallback(hrtc);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_RTC_AlarmAEventCallback
                  |L2.44|
;;;2390   #endif
;;;2391       }
;;;2392     }
;;;2393   
;;;2394     /* Get the AlarmB interrupt source enable status */
;;;2395     if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != 0U)
00002c  6821              LDR      r1,[r4,#0]
00002e  6888              LDR      r0,[r1,#8]
000030  0480              LSLS     r0,r0,#18
000032  d50b              BPL      |L2.76|
;;;2396     {
;;;2397       /* Get the pending status of the AlarmB Interrupt */
;;;2398       if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != 0U)
000034  68c8              LDR      r0,[r1,#0xc]
000036  0580              LSLS     r0,r0,#22
000038  d508              BPL      |L2.76|
;;;2399       {
;;;2400         /* Clear the AlarmB interrupt pending bit */
;;;2401         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
00003a  68c8              LDR      r0,[r1,#0xc]
00003c  f0000080          AND      r0,r0,#0x80
000040  f4607020          ORN      r0,r0,#0x280
000044  60c8              STR      r0,[r1,#0xc]
;;;2402   
;;;2403   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;2404         hrtc->AlarmBEventCallback(hrtc);
;;;2405   #else
;;;2406         HAL_RTCEx_AlarmBEventCallback(hrtc);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       HAL_RTCEx_AlarmBEventCallback
                  |L2.76|
;;;2407   #endif
;;;2408       }
;;;2409     }
;;;2410   #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2411   
;;;2412     /* Change RTC state */
;;;2413     hrtc->State = HAL_RTC_STATE_READY;
00004c  2001              MOVS     r0,#1
00004e  f8840021          STRB     r0,[r4,#0x21]
;;;2414   }
000052  bd10              POP      {r4,pc}
;;;2415   
                          ENDP

                  |L2.84|
                          DCD      0x40010414

                          AREA ||i.HAL_RTC_DST_Add1Hour||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DST_Add1Hour PROC
;;;2274     */
;;;2275   void HAL_RTC_DST_Add1Hour(RTC_HandleTypeDef *hrtc)
000000  6802              LDR      r2,[r0,#0]
;;;2276   {
;;;2277     UNUSED(hrtc);
;;;2278     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6251              STR      r1,[r2,#0x24]
000006  6802              LDR      r2,[r0,#0]
000008  2153              MOVS     r1,#0x53
00000a  6251              STR      r1,[r2,#0x24]
;;;2279     SET_BIT(RTC->CR, RTC_CR_ADD1H);
00000c  4904              LDR      r1,|L3.32|
00000e  680a              LDR      r2,[r1,#0]
000010  f4423280          ORR      r2,r2,#0x10000
000014  600a              STR      r2,[r1,#0]
;;;2280     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000016  6800              LDR      r0,[r0,#0]
000018  21ff              MOVS     r1,#0xff
00001a  6241              STR      r1,[r0,#0x24]
;;;2281   }
00001c  4770              BX       lr
;;;2282   
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x40002808

                          AREA ||i.HAL_RTC_DST_ClearStoreOperation||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DST_ClearStoreOperation PROC
;;;2315     */
;;;2316   void HAL_RTC_DST_ClearStoreOperation(RTC_HandleTypeDef *hrtc)
000000  6802              LDR      r2,[r0,#0]
;;;2317   {
;;;2318     UNUSED(hrtc);
;;;2319     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6251              STR      r1,[r2,#0x24]
000006  6802              LDR      r2,[r0,#0]
000008  2153              MOVS     r1,#0x53
00000a  6251              STR      r1,[r2,#0x24]
;;;2320     CLEAR_BIT(RTC->CR, RTC_CR_BKP);
00000c  4904              LDR      r1,|L4.32|
00000e  680a              LDR      r2,[r1,#0]
000010  f4222280          BIC      r2,r2,#0x40000
000014  600a              STR      r2,[r1,#0]
;;;2321     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000016  6800              LDR      r0,[r0,#0]
000018  21ff              MOVS     r1,#0xff
00001a  6241              STR      r1,[r0,#0x24]
;;;2322   }
00001c  4770              BX       lr
;;;2323   
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40002808

                          AREA ||i.HAL_RTC_DST_ReadStoreOperation||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DST_ReadStoreOperation PROC
;;;2328     */
;;;2329   uint32_t HAL_RTC_DST_ReadStoreOperation(RTC_HandleTypeDef *hrtc)
000000  4802              LDR      r0,|L5.12|
;;;2330   {
;;;2331     UNUSED(hrtc);
;;;2332     return READ_BIT(RTC->CR, RTC_CR_BKP);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;2333   }
000008  4770              BX       lr
;;;2334   
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40002808

                          AREA ||i.HAL_RTC_DST_SetStoreOperation||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DST_SetStoreOperation PROC
;;;2302     */
;;;2303   void HAL_RTC_DST_SetStoreOperation(RTC_HandleTypeDef *hrtc)
000000  6802              LDR      r2,[r0,#0]
;;;2304   {
;;;2305     UNUSED(hrtc);
;;;2306     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6251              STR      r1,[r2,#0x24]
000006  6802              LDR      r2,[r0,#0]
000008  2153              MOVS     r1,#0x53
00000a  6251              STR      r1,[r2,#0x24]
;;;2307     SET_BIT(RTC->CR, RTC_CR_BKP);
00000c  4904              LDR      r1,|L6.32|
00000e  680a              LDR      r2,[r1,#0]
000010  f4422280          ORR      r2,r2,#0x40000
000014  600a              STR      r2,[r1,#0]
;;;2308     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000016  6800              LDR      r0,[r0,#0]
000018  21ff              MOVS     r1,#0xff
00001a  6241              STR      r1,[r0,#0x24]
;;;2309   }
00001c  4770              BX       lr
;;;2310   
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40002808

                          AREA ||i.HAL_RTC_DST_Sub1Hour||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DST_Sub1Hour PROC
;;;2288     */
;;;2289   void HAL_RTC_DST_Sub1Hour(RTC_HandleTypeDef *hrtc)
000000  6802              LDR      r2,[r0,#0]
;;;2290   {
;;;2291     UNUSED(hrtc);
;;;2292     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6251              STR      r1,[r2,#0x24]
000006  6802              LDR      r2,[r0,#0]
000008  2153              MOVS     r1,#0x53
00000a  6251              STR      r1,[r2,#0x24]
;;;2293     SET_BIT(RTC->CR, RTC_CR_SUB1H);
00000c  4904              LDR      r1,|L7.32|
00000e  680a              LDR      r2,[r1,#0]
000010  f4423200          ORR      r2,r2,#0x20000
000014  600a              STR      r2,[r1,#0]
;;;2294     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000016  6800              LDR      r0,[r0,#0]
000018  21ff              MOVS     r1,#0xff
00001a  6241              STR      r1,[r0,#0x24]
;;;2295   }
00001c  4770              BX       lr
;;;2296   
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0x40002808

                          AREA ||i.HAL_RTC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DeInit PROC
;;;378      */
;;;379    HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;380    {
000002  4604              MOV      r4,r0
;;;381      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;382    
;;;383      /* Check the RTC peripheral state */
;;;384      if (hrtc != NULL)
000006  2c00              CMP      r4,#0
000008  d03c              BEQ      |L8.132|
;;;385      {
;;;386        /* Check the parameters */
;;;387        assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;388    
;;;389        /* Set RTC state */
;;;390        hrtc->State = HAL_RTC_STATE_BUSY;
00000a  2002              MOVS     r0,#2
00000c  f8840021          STRB     r0,[r4,#0x21]
;;;391    
;;;392        /* Disable the write protection for RTC registers */
;;;393        __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000010  6821              LDR      r1,[r4,#0]
000012  20ca              MOVS     r0,#0xca
000014  6248              STR      r0,[r1,#0x24]
000016  6821              LDR      r1,[r4,#0]
000018  2053              MOVS     r0,#0x53
00001a  6248              STR      r0,[r1,#0x24]
;;;394    
;;;395        /* Enter Initialization mode */
;;;396        status = RTC_EnterInitMode(hrtc);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       RTC_EnterInitMode
000022  4605              MOV      r5,r0
;;;397    
;;;398        if (status == HAL_OK)
000024  bb75              CBNZ     r5,|L8.132|
;;;399        {
;;;400          /* Reset all RTC CR register bits */
;;;401          hrtc->Instance->TR = 0x00000000U;
000026  6820              LDR      r0,[r4,#0]
000028  2600              MOVS     r6,#0
00002a  6006              STR      r6,[r0,#0]
;;;402          hrtc->Instance->DR = ((uint32_t)(RTC_DR_WDU_0 | RTC_DR_MU_0 | RTC_DR_DU_0));
00002c  6821              LDR      r1,[r4,#0]
00002e  f2421001          MOV      r0,#0x2101
000032  6048              STR      r0,[r1,#4]
;;;403          hrtc->Instance->CR &= 0x00000000U;
000034  6820              LDR      r0,[r4,#0]
000036  6881              LDR      r1,[r0,#8]
000038  6086              STR      r6,[r0,#8]
;;;404    
;;;405          hrtc->Instance->WUTR = RTC_WUTR_WUT;
00003a  6821              LDR      r1,[r4,#0]
00003c  f64f70ff          MOV      r0,#0xffff
000040  6148              STR      r0,[r1,#0x14]
;;;406          hrtc->Instance->PRER = ((uint32_t)(RTC_PRER_PREDIV_A | 0x000000FFU));
000042  6821              LDR      r1,[r4,#0]
000044  4810              LDR      r0,|L8.136|
000046  6108              STR      r0,[r1,#0x10]
;;;407          hrtc->Instance->ALRMAR = 0x00000000U;
000048  6820              LDR      r0,[r4,#0]
00004a  61c6              STR      r6,[r0,#0x1c]
;;;408          hrtc->Instance->ALRMBR = 0x00000000U;
00004c  6820              LDR      r0,[r4,#0]
00004e  6206              STR      r6,[r0,#0x20]
;;;409          hrtc->Instance->SHIFTR = 0x00000000U;
000050  6820              LDR      r0,[r4,#0]
000052  62c6              STR      r6,[r0,#0x2c]
;;;410          hrtc->Instance->CALR = 0x00000000U;
000054  6820              LDR      r0,[r4,#0]
000056  63c6              STR      r6,[r0,#0x3c]
;;;411          hrtc->Instance->ALRMASSR = 0x00000000U;
000058  6820              LDR      r0,[r4,#0]
00005a  6446              STR      r6,[r0,#0x44]
;;;412          hrtc->Instance->ALRMBSSR = 0x00000000U;
00005c  6820              LDR      r0,[r4,#0]
00005e  6486              STR      r6,[r0,#0x48]
;;;413    
;;;414          /* Exit initialization mode */
;;;415          status = RTC_ExitInitMode(hrtc);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       RTC_ExitInitMode
000066  4605              MOV      r5,r0
;;;416    
;;;417    
;;;418          if (status == HAL_OK)
000068  b965              CBNZ     r5,|L8.132|
;;;419          {
;;;420    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;421            /* Reset TAMP registers */
;;;422            ((TAMP_TypeDef *)((uint32_t)hrtc->Instance + hrtc->TampOffset))->CR1 = 0xFFFF0000U;
;;;423            ((TAMP_TypeDef *)((uint32_t)hrtc->Instance + hrtc->TampOffset))->CR2 = 0x00000000U;
;;;424    #else
;;;425            /* Reset Tamper configuration register */
;;;426            hrtc->Instance->TAMPCR = 0x00000000U;
00006a  6820              LDR      r0,[r4,#0]
00006c  6406              STR      r6,[r0,#0x40]
;;;427    
;;;428            /* Reset Option register */
;;;429            hrtc->Instance->OR = 0x00000000U;
00006e  6820              LDR      r0,[r4,#0]
000070  64c6              STR      r6,[r0,#0x4c]
;;;430    #endif
;;;431    
;;;432            /* Enable the write protection for RTC registers */
;;;433            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000072  6821              LDR      r1,[r4,#0]
000074  20ff              MOVS     r0,#0xff
000076  6248              STR      r0,[r1,#0x24]
;;;434    
;;;435    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;436            if (hrtc->MspDeInitCallback == NULL)
;;;437            {
;;;438              hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;439            }
;;;440    
;;;441            /* DeInit the low level hardware: CLOCK, NVIC.*/
;;;442            hrtc->MspDeInitCallback(hrtc);
;;;443    #else
;;;444            /* De-Initialize RTC MSP */
;;;445            HAL_RTC_MspDeInit(hrtc);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       HAL_RTC_MspDeInit
;;;446    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
;;;447    
;;;448            hrtc->State = HAL_RTC_STATE_RESET;
00007e  3420              ADDS     r4,r4,#0x20
000080  7066              STRB     r6,[r4,#1]
;;;449    
;;;450            /* Release Lock */
;;;451            __HAL_UNLOCK(hrtc);
000082  7026              STRB     r6,[r4,#0]
                  |L8.132|
;;;452          }
;;;453        }
;;;454      }
;;;455    
;;;456      return status;
000084  4628              MOV      r0,r5
;;;457    }
000086  bd70              POP      {r4-r6,pc}
;;;458    
                          ENDP

                  |L8.136|
                          DCD      0x007f00ff

                          AREA ||i.HAL_RTC_DeactivateAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DeactivateAlarm PROC
;;;2110     */
;;;2111   HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2112   {
000004  4604              MOV      r4,r0
;;;2113     /* Check the parameters */
;;;2114     assert_param(IS_RTC_ALARM(Alarm));
;;;2115   
;;;2116     /* Process Locked */
;;;2117     __HAL_LOCK(hrtc);
000006  f8940020          LDRB     r0,[r4,#0x20]
00000a  2801              CMP      r0,#1
00000c  d023              BEQ      |L9.86|
00000e  f04f0801          MOV      r8,#1
000012  f8848020          STRB     r8,[r4,#0x20]
;;;2118   
;;;2119     hrtc->State = HAL_RTC_STATE_BUSY;
000016  2002              MOVS     r0,#2
000018  f8840021          STRB     r0,[r4,#0x21]
;;;2120   
;;;2121     /* Disable the write protection for RTC registers */
;;;2122     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00001c  6822              LDR      r2,[r4,#0]
00001e  20ca              MOVS     r0,#0xca
000020  6250              STR      r0,[r2,#0x24]
000022  6822              LDR      r2,[r4,#0]
000024  2053              MOVS     r0,#0x53
000026  6250              STR      r0,[r2,#0x24]
;;;2123   
;;;2124     if (Alarm == RTC_ALARM_A)
000028  2600              MOVS     r6,#0
;;;2125     {
;;;2126       /* AlarmA */
;;;2127   #if defined (RTC_ALRMASSR_SSCLR)
;;;2128       CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
;;;2129   #endif
;;;2130   
;;;2131       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;2132   
;;;2133       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;2134       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
;;;2135   
;;;2136   #if defined (RTC_FLAG_ALRAWF)
;;;2137       uint32_t tickstart = HAL_GetTick();
;;;2138       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;2139       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
;;;2140       {
;;;2141         if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
;;;2142         {
;;;2143           /* Enable the write protection for RTC registers */
;;;2144           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00002a  27ff              MOVS     r7,#0xff
;;;2145   
;;;2146           hrtc->State = HAL_RTC_STATE_TIMEOUT;
00002c  f04f0903          MOV      r9,#3
000030  f44f7a7a          MOV      r10,#0x3e8            ;2141
000034  f5b17f80          CMP      r1,#0x100             ;2124
000038  d010              BEQ      |L9.92|
;;;2147   
;;;2148           /* Process Unlocked */
;;;2149           __HAL_UNLOCK(hrtc);
;;;2150   
;;;2151           return HAL_TIMEOUT;
;;;2152         }
;;;2153       }
;;;2154   #endif
;;;2155     }
;;;2156     else
;;;2157     {
;;;2158       /* AlarmB */
;;;2159   #if defined (RTC_ALRMBSSR_SSCLR)
;;;2160       CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMASSR_SSCLR);
;;;2161   #endif
;;;2162   
;;;2163       __HAL_RTC_ALARMB_DISABLE(hrtc);
00003a  6820              LDR      r0,[r4,#0]
00003c  6881              LDR      r1,[r0,#8]
00003e  f4217100          BIC      r1,r1,#0x200
000042  6081              STR      r1,[r0,#8]
;;;2164   
;;;2165       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;2166       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
000044  6820              LDR      r0,[r4,#0]
000046  6881              LDR      r1,[r0,#8]
000048  f4215100          BIC      r1,r1,#0x2000
00004c  6081              STR      r1,[r0,#8]
;;;2167   
;;;2168   #if defined (RTC_FLAG_ALRBWF)
;;;2169       uint32_t tickstart = HAL_GetTick();
00004e  f7fffffe          BL       HAL_GetTick
000052  4605              MOV      r5,r0
;;;2170       /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
;;;2171       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
000054  e02f              B        |L9.182|
                  |L9.86|
000056  2002              MOVS     r0,#2                 ;2117
                  |L9.88|
;;;2172       {
;;;2173         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;2174         {
;;;2175           /* Enable the write protection for RTC registers */
;;;2176           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;2177   
;;;2178           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;2179   
;;;2180           /* Process Unlocked */
;;;2181           __HAL_UNLOCK(hrtc);
;;;2182   
;;;2183           return HAL_TIMEOUT;
;;;2184         }
;;;2185       }
;;;2186   #endif
;;;2187     }
;;;2188     /* Enable the write protection for RTC registers */
;;;2189     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;2190   
;;;2191     hrtc->State = HAL_RTC_STATE_READY;
;;;2192   
;;;2193     /* Process Unlocked */
;;;2194     __HAL_UNLOCK(hrtc);
;;;2195   
;;;2196     return HAL_OK;
;;;2197   }
000058  e8bd87f0          POP      {r4-r10,pc}
                  |L9.92|
00005c  6820              LDR      r0,[r4,#0]            ;2131
00005e  6881              LDR      r1,[r0,#8]            ;2131
000060  f4217180          BIC      r1,r1,#0x100          ;2131
000064  6081              STR      r1,[r0,#8]            ;2131
000066  6820              LDR      r0,[r4,#0]            ;2134
000068  6881              LDR      r1,[r0,#8]            ;2134
00006a  f4215180          BIC      r1,r1,#0x1000         ;2134
00006e  6081              STR      r1,[r0,#8]            ;2134
000070  f7fffffe          BL       HAL_GetTick
000074  4605              MOV      r5,r0                 ;2137
000076  e00c              B        |L9.146|
                  |L9.120|
000078  f7fffffe          BL       HAL_GetTick
00007c  1b40              SUBS     r0,r0,r5              ;2141
00007e  4550              CMP      r0,r10                ;2141
000080  d907              BLS      |L9.146|
000082  6820              LDR      r0,[r4,#0]            ;2144
000084  6247              STR      r7,[r0,#0x24]         ;2144
000086  f8849021          STRB     r9,[r4,#0x21]         ;2146
00008a  f8846020          STRB     r6,[r4,#0x20]         ;2149
00008e  2003              MOVS     r0,#3                 ;2151
000090  e7e2              B        |L9.88|
                  |L9.146|
000092  6820              LDR      r0,[r4,#0]            ;2139
000094  68c0              LDR      r0,[r0,#0xc]          ;2139
000096  07c0              LSLS     r0,r0,#31             ;2139
000098  d0ee              BEQ      |L9.120|
00009a  e010              B        |L9.190|
                  |L9.156|
00009c  f7fffffe          BL       HAL_GetTick
0000a0  1b40              SUBS     r0,r0,r5              ;2173
0000a2  4550              CMP      r0,r10                ;2173
0000a4  d907              BLS      |L9.182|
0000a6  6820              LDR      r0,[r4,#0]            ;2176
0000a8  6247              STR      r7,[r0,#0x24]         ;2176
0000aa  f8849021          STRB     r9,[r4,#0x21]         ;2178
0000ae  f8846020          STRB     r6,[r4,#0x20]         ;2181
0000b2  2003              MOVS     r0,#3                 ;2183
0000b4  e7d0              B        |L9.88|
                  |L9.182|
0000b6  6820              LDR      r0,[r4,#0]            ;2171
0000b8  68c0              LDR      r0,[r0,#0xc]          ;2171
0000ba  0780              LSLS     r0,r0,#30             ;2171
0000bc  d5ee              BPL      |L9.156|
                  |L9.190|
0000be  6820              LDR      r0,[r4,#0]            ;2189
0000c0  6247              STR      r7,[r0,#0x24]         ;2189
0000c2  f8848021          STRB     r8,[r4,#0x21]         ;2191
0000c6  f8846020          STRB     r6,[r4,#0x20]         ;2194
0000ca  2000              MOVS     r0,#0                 ;2196
0000cc  e7c4              B        |L9.88|
;;;2198   
                          ENDP


                          AREA ||i.HAL_RTC_GetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetAlarm PROC
;;;2212     */
;;;2213   HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
000000  b510              PUSH     {r4,lr}
;;;2214   {
000002  460c              MOV      r4,r1
;;;2215     uint32_t tmpreg, subsecondtmpreg;
;;;2216   
;;;2217     /* Check the parameters */
;;;2218     assert_param(IS_RTC_FORMAT(Format));
;;;2219     assert_param(IS_RTC_ALARM(Alarm));
;;;2220   
;;;2221     if (Alarm == RTC_ALARM_A)
000004  f44f7180          MOV      r1,#0x100
000008  428a              CMP      r2,r1
00000a  d11d              BNE      |L10.72|
;;;2222     {
;;;2223       /* AlarmA */
;;;2224       sAlarm->Alarm = RTC_ALARM_A;
00000c  62a1              STR      r1,[r4,#0x28]
;;;2225   
;;;2226       tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
00000e  6801              LDR      r1,[r0,#0]
000010  69c8              LDR      r0,[r1,#0x1c]
;;;2227       subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR) & RTC_ALRMASSR_SS);
000012  6c49              LDR      r1,[r1,#0x44]
000014  f3c1010e          UBFX     r1,r1,#0,#15
;;;2228   
;;;2229       /* Fill the structure with the read parameters */
;;;2230       sAlarm->AlarmTime.Hours = (uint8_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> RTC_ALRMAR_HU_Pos);
000018  f3c04205          UBFX     r2,r0,#16,#6
00001c  7022              STRB     r2,[r4,#0]
;;;2231       sAlarm->AlarmTime.Minutes = (uint8_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> RTC_ALRMAR_MNU_Pos);
00001e  f3c02206          UBFX     r2,r0,#8,#7
000022  7062              STRB     r2,[r4,#1]
;;;2232       sAlarm->AlarmTime.Seconds = (uint8_t)((tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU)) >> RTC_ALRMAR_SU_Pos);
000024  f000027f          AND      r2,r0,#0x7f
000028  70a2              STRB     r2,[r4,#2]
;;;2233       sAlarm->AlarmTime.TimeFormat = (uint8_t)((tmpreg & RTC_ALRMAR_PM) >> RTC_ALRMAR_PM_Pos);
00002a  f3c05280          UBFX     r2,r0,#22,#1
00002e  70e2              STRB     r2,[r4,#3]
;;;2234       sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
000030  6061              STR      r1,[r4,#4]
;;;2235       sAlarm->AlarmDateWeekDay = (uint8_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> RTC_ALRMAR_DU_Pos);
000032  f3c06105          UBFX     r1,r0,#24,#6
000036  f8841024          STRB     r1,[r4,#0x24]
;;;2236       sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00003a  f0004180          AND      r1,r0,#0x40000000
00003e  6221              STR      r1,[r4,#0x20]
;;;2237       sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
000040  f0003080          AND      r0,r0,#0x80808080
000044  6160              STR      r0,[r4,#0x14]
000046  e01e              B        |L10.134|
                  |L10.72|
;;;2238     }
;;;2239     else
;;;2240     {
;;;2241       sAlarm->Alarm = RTC_ALARM_B;
000048  f44f7100          MOV      r1,#0x200
00004c  62a1              STR      r1,[r4,#0x28]
;;;2242   
;;;2243       tmpreg = (uint32_t)(hrtc->Instance->ALRMBR);
00004e  6801              LDR      r1,[r0,#0]
000050  6a08              LDR      r0,[r1,#0x20]
;;;2244       subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
000052  6c89              LDR      r1,[r1,#0x48]
000054  f3c1010e          UBFX     r1,r1,#0,#15
;;;2245   
;;;2246       /* Fill the structure with the read parameters */
;;;2247       sAlarm->AlarmTime.Hours = (uint8_t)((tmpreg & (RTC_ALRMBR_HT | RTC_ALRMBR_HU)) >> RTC_ALRMBR_HU_Pos);
000058  f3c04205          UBFX     r2,r0,#16,#6
00005c  7022              STRB     r2,[r4,#0]
;;;2248       sAlarm->AlarmTime.Minutes = (uint8_t)((tmpreg & (RTC_ALRMBR_MNT | RTC_ALRMBR_MNU)) >> RTC_ALRMBR_MNU_Pos);
00005e  f3c02206          UBFX     r2,r0,#8,#7
000062  7062              STRB     r2,[r4,#1]
;;;2249       sAlarm->AlarmTime.Seconds = (uint8_t)((tmpreg & (RTC_ALRMBR_ST | RTC_ALRMBR_SU)) >> RTC_ALRMBR_SU_Pos);
000064  f000027f          AND      r2,r0,#0x7f
000068  70a2              STRB     r2,[r4,#2]
;;;2250       sAlarm->AlarmTime.TimeFormat = (uint8_t)((tmpreg & RTC_ALRMBR_PM) >> RTC_ALRMBR_PM_Pos);
00006a  f3c05280          UBFX     r2,r0,#22,#1
00006e  70e2              STRB     r2,[r4,#3]
;;;2251       sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
000070  6061              STR      r1,[r4,#4]
;;;2252       sAlarm->AlarmDateWeekDay = (uint8_t)((tmpreg & (RTC_ALRMBR_DT | RTC_ALRMBR_DU)) >> RTC_ALRMBR_DU_Pos);
000072  f3c06105          UBFX     r1,r0,#24,#6
000076  f8841024          STRB     r1,[r4,#0x24]
;;;2253       sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMBR_WDSEL);
00007a  f0004180          AND      r1,r0,#0x40000000
00007e  6221              STR      r1,[r4,#0x20]
;;;2254       sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
000080  f0003080          AND      r0,r0,#0x80808080
000084  6160              STR      r0,[r4,#0x14]
                  |L10.134|
;;;2255     }
;;;2256   
;;;2257     if (Format == RTC_FORMAT_BIN)
000086  b98b              CBNZ     r3,|L10.172|
;;;2258     {
;;;2259       sAlarm->AlarmTime.Hours = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
000088  7820              LDRB     r0,[r4,#0]
00008a  f7fffffe          BL       RTC_Bcd2ToByte
00008e  7020              STRB     r0,[r4,#0]
;;;2260       sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
000090  7860              LDRB     r0,[r4,#1]
000092  f7fffffe          BL       RTC_Bcd2ToByte
000096  7060              STRB     r0,[r4,#1]
;;;2261       sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
000098  78a0              LDRB     r0,[r4,#2]
00009a  f7fffffe          BL       RTC_Bcd2ToByte
00009e  70a0              STRB     r0,[r4,#2]
;;;2262       sAlarm->AlarmDateWeekDay = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
0000a0  f8940024          LDRB     r0,[r4,#0x24]
0000a4  f7fffffe          BL       RTC_Bcd2ToByte
0000a8  f8840024          STRB     r0,[r4,#0x24]
                  |L10.172|
;;;2263     }
;;;2264   
;;;2265     return HAL_OK;
0000ac  2000              MOVS     r0,#0
;;;2266   }
0000ae  bd10              POP      {r4,pc}
;;;2267   
                          ENDP


                          AREA ||i.HAL_RTC_GetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_GetDate PROC
;;;1679     */
;;;1680   HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  b510              PUSH     {r4,lr}
;;;1681   {
000002  460b              MOV      r3,r1
;;;1682     uint32_t datetmpreg;
;;;1683   
;;;1684     /* Check the parameters */
;;;1685     assert_param(IS_RTC_FORMAT(Format));
;;;1686   
;;;1687     /* Get the DR register */
;;;1688     datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
000004  6800              LDR      r0,[r0,#0]
000006  6841              LDR      r1,[r0,#4]
000008  480d              LDR      r0,|L11.64|
00000a  4001              ANDS     r1,r1,r0
;;;1689   
;;;1690     /* Fill the structure fields with the read parameters */
;;;1691     sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos);
00000c  0c08              LSRS     r0,r1,#16
00000e  70d8              STRB     r0,[r3,#3]
;;;1692     sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
000010  f3c12404          UBFX     r4,r1,#8,#5
000014  705c              STRB     r4,[r3,#1]
;;;1693     sDate->Date = (uint8_t)((datetmpreg & (RTC_DR_DT | RTC_DR_DU)) >> RTC_DR_DU_Pos);
000016  f001043f          AND      r4,r1,#0x3f
00001a  709c              STRB     r4,[r3,#2]
;;;1694     sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> RTC_DR_WDU_Pos);
00001c  f3c13142          UBFX     r1,r1,#13,#3
000020  7019              STRB     r1,[r3,#0]
;;;1695   
;;;1696     /* Check the input parameters format */
;;;1697     if (Format == RTC_FORMAT_BIN)
000022  2a00              CMP      r2,#0
000024  d10a              BNE      |L11.60|
;;;1698     {
;;;1699       /* Convert the date structure parameters to Binary format */
;;;1700       sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
000026  f7fffffe          BL       RTC_Bcd2ToByte
00002a  70d8              STRB     r0,[r3,#3]
;;;1701       sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
00002c  7858              LDRB     r0,[r3,#1]
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  7058              STRB     r0,[r3,#1]
;;;1702       sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
000034  7898              LDRB     r0,[r3,#2]
000036  f7fffffe          BL       RTC_Bcd2ToByte
00003a  7098              STRB     r0,[r3,#2]
                  |L11.60|
;;;1703     }
;;;1704     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;1705   }
00003e  bd10              POP      {r4,pc}
;;;1706   
                          ENDP

                  |L11.64|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetState PROC
;;;2547     */
;;;2548   HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc)
000000  f8900021          LDRB     r0,[r0,#0x21]
;;;2549   {
;;;2550     /* Return RTC handle state */
;;;2551     return hrtc->State;
;;;2552   }
000004  4770              BX       lr
;;;2553   
                          ENDP


                          AREA ||i.HAL_RTC_GetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_GetTime PROC
;;;1551     */
;;;1552   HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  b510              PUSH     {r4,lr}
;;;1553   {
000002  460b              MOV      r3,r1
;;;1554     uint32_t tmpreg;
;;;1555   
;;;1556     /* Check the parameters */
;;;1557     assert_param(IS_RTC_FORMAT(Format));
;;;1558   
;;;1559     /* Get subseconds structure field from the corresponding register*/
;;;1560     sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
000004  6801              LDR      r1,[r0,#0]
000006  6a89              LDR      r1,[r1,#0x28]
000008  6059              STR      r1,[r3,#4]
;;;1561   
;;;1562     /* Get SecondFraction structure field from the corresponding register field*/
;;;1563     sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
00000a  6801              LDR      r1,[r0,#0]
00000c  6909              LDR      r1,[r1,#0x10]
00000e  f3c1010e          UBFX     r1,r1,#0,#15
000012  6099              STR      r1,[r3,#8]
;;;1564   
;;;1565     /* Get the TR register */
;;;1566     tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
000014  6800              LDR      r0,[r0,#0]
000016  6801              LDR      r1,[r0,#0]
000018  480d              LDR      r0,|L13.80|
00001a  4001              ANDS     r1,r1,r0
;;;1567   
;;;1568     /* Fill the structure fields with the read parameters */
;;;1569     sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> RTC_TR_HU_Pos);
00001c  f3c14005          UBFX     r0,r1,#16,#6
000020  7018              STRB     r0,[r3,#0]
;;;1570     sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
000022  f3c12406          UBFX     r4,r1,#8,#7
000026  705c              STRB     r4,[r3,#1]
;;;1571     sTime->Seconds = (uint8_t)((tmpreg & (RTC_TR_ST | RTC_TR_SU)) >> RTC_TR_SU_Pos);
000028  f001047f          AND      r4,r1,#0x7f
00002c  709c              STRB     r4,[r3,#2]
;;;1572     sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> RTC_TR_PM_Pos);
00002e  0d89              LSRS     r1,r1,#22
000030  70d9              STRB     r1,[r3,#3]
;;;1573   
;;;1574     /* Check the input parameters format */
;;;1575     if (Format == RTC_FORMAT_BIN)
000032  2a00              CMP      r2,#0
000034  d10a              BNE      |L13.76|
;;;1576     {
;;;1577       /* Convert the time structure parameters to Binary format */
;;;1578       sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
000036  f7fffffe          BL       RTC_Bcd2ToByte
00003a  7018              STRB     r0,[r3,#0]
;;;1579       sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
00003c  7858              LDRB     r0,[r3,#1]
00003e  f7fffffe          BL       RTC_Bcd2ToByte
000042  7058              STRB     r0,[r3,#1]
;;;1580       sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
000044  7898              LDRB     r0,[r3,#2]
000046  f7fffffe          BL       RTC_Bcd2ToByte
00004a  7098              STRB     r0,[r3,#2]
                  |L13.76|
;;;1581     }
;;;1582   
;;;1583     return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;1584   }
00004e  bd10              POP      {r4,pc}
;;;1585   
                          ENDP

                  |L13.80|
                          DCD      0x007f7f7f

                          AREA ||i.HAL_RTC_Init||, CODE, READONLY, ALIGN=2

                  HAL_RTC_Init PROC
;;;245      */
;;;246    HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248      HAL_StatusTypeDef status = HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;249    
;;;250      /* Check the RTC peripheral state */
;;;251      if (hrtc != NULL)
000006  2c00              CMP      r4,#0
000008  d044              BEQ      |L14.148|
;;;252      {
;;;253        /* Check the parameters */
;;;254        assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;255        assert_param(IS_RTC_HOUR_FORMAT(hrtc->Init.HourFormat));
;;;256        assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
;;;257        assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
;;;258        assert_param(IS_RTC_OUTPUT(hrtc->Init.OutPut));
;;;259        assert_param(IS_RTC_OUTPUT_REMAP(hrtc->Init.OutPutRemap));
;;;260        assert_param(IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
;;;261        assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
;;;262    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;263        assert_param(IS_RTC_OUTPUT_PULLUP(hrtc->Init.OutPutPullUp));
;;;264    #endif
;;;265    
;;;266    #if defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;267        assert_param(IS_RTC_BINARY_MODE(hrtc->Init.BinMode));
;;;268        assert_param(IS_RTC_BINARY_MIX_BCDU(hrtc->Init.BinMixBcdU));
;;;269    #endif
;;;270    
;;;271    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;272        if (hrtc->State == HAL_RTC_STATE_RESET)
;;;273        {
;;;274          /* Allocate lock resource and initialize it */
;;;275          hrtc->Lock = HAL_UNLOCKED;
;;;276          hrtc->AlarmAEventCallback          =  HAL_RTC_AlarmAEventCallback;             /* Legacy weak AlarmAEventCallback      */
;;;277          hrtc->AlarmBEventCallback          =  HAL_RTCEx_AlarmBEventCallback;           /* Legacy weak AlarmBEventCallback      */
;;;278          hrtc->TimeStampEventCallback       =  HAL_RTCEx_TimeStampEventCallback;        /* Legacy weak TimeStampEventCallback   */
;;;279          hrtc->WakeUpTimerEventCallback     =  HAL_RTCEx_WakeUpTimerEventCallback;      /* Legacy weak WakeUpTimerEventCallback */
;;;280    #if defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;281          hrtc->SSRUEventCallback            =  HAL_RTCEx_SSRUEventCallback;             /* Legacy weak SSRUEventCallback */
;;;282    #endif
;;;283    
;;;284    #if defined(RTC_TAMPER1_SUPPORT)
;;;285          hrtc->Tamper1EventCallback         =  HAL_RTCEx_Tamper1EventCallback;          /* Legacy weak Tamper1EventCallback     */
;;;286    #endif /* RTC_TAMPER1_SUPPORT */
;;;287          hrtc->Tamper2EventCallback         =  HAL_RTCEx_Tamper2EventCallback;          /* Legacy weak Tamper2EventCallback     */
;;;288    #if defined(RTC_TAMPER3_SUPPORT)
;;;289          hrtc->Tamper3EventCallback         =  HAL_RTCEx_Tamper3EventCallback;          /* Legacy weak Tamper3EventCallback     */
;;;290    #endif /* RTC_TAMPER3_SUPPORT */
;;;291    
;;;292          if (hrtc->MspInitCallback == NULL)
;;;293          {
;;;294            hrtc->MspInitCallback = HAL_RTC_MspInit;
;;;295          }
;;;296          /* Init the low level hardware */
;;;297          hrtc->MspInitCallback(hrtc);
;;;298    
;;;299          if (hrtc->MspDeInitCallback == NULL)
;;;300          {
;;;301            hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;302          }
;;;303        }
;;;304    #else /* #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;305        if (hrtc->State == HAL_RTC_STATE_RESET)
00000a  f8940021          LDRB     r0,[r4,#0x21]
00000e  b928              CBNZ     r0,|L14.28|
;;;306        {
;;;307          /* Allocate lock resource and initialize it */
;;;308          hrtc->Lock = HAL_UNLOCKED;
000010  2000              MOVS     r0,#0
000012  f8840020          STRB     r0,[r4,#0x20]
;;;309    
;;;310          /* Initialize RTC MSP */
;;;311          HAL_RTC_MspInit(hrtc);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_RTC_MspInit
                  |L14.28|
;;;312        }
;;;313    #endif /* #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;314    
;;;315    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;316        /* Process TAMP ip offset from RTC one */
;;;317        hrtc->TampOffset = (TAMP_BASE - RTC_BASE);
;;;318    #endif
;;;319        /* Set RTC state */
;;;320        hrtc->State = HAL_RTC_STATE_BUSY;
00001c  2002              MOVS     r0,#2
00001e  f8840021          STRB     r0,[r4,#0x21]
;;;321    
;;;322        /* Disable the write protection for RTC registers */
;;;323        __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000022  6821              LDR      r1,[r4,#0]
000024  20ca              MOVS     r0,#0xca
000026  6248              STR      r0,[r1,#0x24]
000028  6821              LDR      r1,[r4,#0]
00002a  2053              MOVS     r0,#0x53
00002c  6248              STR      r0,[r1,#0x24]
;;;324    
;;;325        /* Enter Initialization mode */
;;;326        status = RTC_EnterInitMode(hrtc);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       RTC_EnterInitMode
;;;327    
;;;328        if (status == HAL_OK)
000034  2800              CMP      r0,#0
000036  d12d              BNE      |L14.148|
;;;329        {
;;;330    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;331          /* Clear RTC_CR FMT, OSEL, POL and TAMPOE Bits */
;;;332          hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE);
;;;333    #else
;;;334          /* Clear RTC_CR FMT, OSEL and POL Bits */
;;;335          hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
000038  6820              LDR      r0,[r4,#0]
00003a  6881              LDR      r1,[r0,#8]
00003c  4a16              LDR      r2,|L14.152|
00003e  4011              ANDS     r1,r1,r2
000040  6081              STR      r1,[r0,#8]
;;;336    #endif
;;;337          /* Set RTC_CR register */
;;;338          hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
000042  6820              LDR      r0,[r4,#0]
000044  6881              LDR      r1,[r0,#8]
000046  6862              LDR      r2,[r4,#4]
000048  69a3              LDR      r3,[r4,#0x18]
00004a  4311              ORRS     r1,r1,r2
00004c  6922              LDR      r2,[r4,#0x10]
00004e  431a              ORRS     r2,r2,r3
000050  4311              ORRS     r1,r1,r2
000052  6081              STR      r1,[r0,#8]
;;;339    
;;;340          /* Configure the RTC PRER */
;;;341          hrtc->Instance->PRER = (hrtc->Init.SynchPrediv);
000054  6821              LDR      r1,[r4,#0]
000056  68e0              LDR      r0,[r4,#0xc]
000058  6108              STR      r0,[r1,#0x10]
;;;342          hrtc->Instance->PRER |= (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
00005a  6820              LDR      r0,[r4,#0]
00005c  6901              LDR      r1,[r0,#0x10]
00005e  8922              LDRH     r2,[r4,#8]
000060  ea414102          ORR      r1,r1,r2,LSL #16
000064  6101              STR      r1,[r0,#0x10]
;;;343    
;;;344    #if defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;345          /* Configure the Binary mode */
;;;346          MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
;;;347    #endif
;;;348    
;;;349          /* Exit Initialization mode */
;;;350          status = RTC_ExitInitMode(hrtc);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       RTC_ExitInitMode
;;;351    
;;;352          if (status == HAL_OK)
00006c  2800              CMP      r0,#0
00006e  d111              BNE      |L14.148|
;;;353          {
;;;354    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;355            hrtc->Instance->CR &= ~(RTC_CR_TAMPALRM_PU | RTC_CR_TAMPALRM_TYPE | RTC_CR_OUT2EN);
;;;356            hrtc->Instance->CR |= (hrtc->Init.OutPutPullUp | hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
;;;357    #else
;;;358            hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
000070  6821              LDR      r1,[r4,#0]
000072  6cca              LDR      r2,[r1,#0x4c]
000074  f0220203          BIC      r2,r2,#3
000078  64ca              STR      r2,[r1,#0x4c]
;;;359            hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
00007a  69e2              LDR      r2,[r4,#0x1c]
00007c  6961              LDR      r1,[r4,#0x14]
00007e  430a              ORRS     r2,r2,r1
000080  6821              LDR      r1,[r4,#0]
000082  6ccb              LDR      r3,[r1,#0x4c]
000084  431a              ORRS     r2,r2,r3
000086  64ca              STR      r2,[r1,#0x4c]
;;;360    #endif
;;;361    
;;;362            /* Enable the write protection for RTC registers */
;;;363            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000088  6822              LDR      r2,[r4,#0]
00008a  21ff              MOVS     r1,#0xff
00008c  6251              STR      r1,[r2,#0x24]
;;;364    
;;;365              hrtc->State = HAL_RTC_STATE_READY;
00008e  2101              MOVS     r1,#1
000090  f8841021          STRB     r1,[r4,#0x21]
                  |L14.148|
;;;366          }
;;;367        }
;;;368      }
;;;369    
;;;370      return status;
;;;371    }
000094  bd10              POP      {r4,pc}
;;;372    
                          ENDP

000096  0000              DCW      0x0000
                  |L14.152|
                          DCD      0xff8fffbf

                          AREA ||i.HAL_RTC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspDeInit PROC
;;;709      */
;;;710    __weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;711    {
;;;712      /* Prevent unused argument(s) compilation warning */
;;;713      UNUSED(hrtc);
;;;714    
;;;715      /* NOTE : This function should not be modified, when the callback is needed,
;;;716                the HAL_RTC_MspDeInit could be implemented in the user file
;;;717       */
;;;718    }
;;;719    
                          ENDP


                          AREA ||i.HAL_RTC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspInit PROC
;;;694      */
;;;695    __weak void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;696    {
;;;697      /* Prevent unused argument(s) compilation warning */
;;;698      UNUSED(hrtc);
;;;699    
;;;700      /* NOTE : This function should not be modified, when the callback is needed,
;;;701                the HAL_RTC_MspInit could be implemented in the user file
;;;702       */
;;;703    }
;;;704    
                          ENDP


                          AREA ||i.HAL_RTC_PollForAlarmAEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTC_PollForAlarmAEvent PROC
;;;2436     */
;;;2437   HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;2438   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2439   
;;;2440     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2441   
;;;2442     while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == 0U)
00000c  e007              B        |L17.30|
                  |L17.14|
;;;2443     {
;;;2444       if (Timeout != HAL_MAX_DELAY)
00000e  1c60              ADDS     r0,r4,#1
000010  d005              BEQ      |L17.30|
;;;2445       {
;;;2446         if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
000012  f7fffffe          BL       HAL_GetTick
000016  1b80              SUBS     r0,r0,r6
000018  42a0              CMP      r0,r4
00001a  d810              BHI      |L17.62|
00001c  b17c              CBZ      r4,|L17.62|
                  |L17.30|
00001e  6828              LDR      r0,[r5,#0]            ;2442
000020  68c0              LDR      r0,[r0,#0xc]          ;2442
000022  05c0              LSLS     r0,r0,#23             ;2442
000024  d5f3              BPL      |L17.14|
;;;2447         {
;;;2448           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;2449           return HAL_TIMEOUT;
;;;2450         }
;;;2451       }
;;;2452     }
;;;2453   
;;;2454     /* Clear the Alarm interrupt pending bit */
;;;2455     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
000026  6828              LDR      r0,[r5,#0]
000028  68c1              LDR      r1,[r0,#0xc]
00002a  f0010180          AND      r1,r1,#0x80
00002e  f46171c0          ORN      r1,r1,#0x180
000032  60c1              STR      r1,[r0,#0xc]
;;;2456   
;;;2457     /* Change RTC state */
;;;2458     hrtc->State = HAL_RTC_STATE_READY;
000034  2001              MOVS     r0,#1
000036  f8850021          STRB     r0,[r5,#0x21]
;;;2459   
;;;2460     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;2461   }
00003c  bd70              POP      {r4-r6,pc}
                  |L17.62|
00003e  2003              MOVS     r0,#3                 ;2448
000040  f8850021          STRB     r0,[r5,#0x21]         ;2448
000044  bd70              POP      {r4-r6,pc}
;;;2462   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_SetAlarm PROC
;;;1733     */
;;;1734   HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1735   {
000004  4604              MOV      r4,r0
000006  460b              MOV      r3,r1
;;;1736     uint32_t tmpreg, subsecondtmpreg;
;;;1737   
;;;1738     /* Check the parameters */
;;;1739     assert_param(IS_RTC_FORMAT(Format));
;;;1740     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1741     assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
;;;1742     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
;;;1743     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
;;;1744     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
;;;1745   
;;;1746     /* Process Locked */
;;;1747     __HAL_LOCK(hrtc);
000008  f8940020          LDRB     r0,[r4,#0x20]
00000c  2801              CMP      r0,#1
00000e  d046              BEQ      |L18.158|
000010  f04f0a01          MOV      r10,#1
000014  f884a020          STRB     r10,[r4,#0x20]
;;;1748   
;;;1749     hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f8840021          STRB     r0,[r4,#0x21]
;;;1750   
;;;1751     if (Format == RTC_FORMAT_BIN)
00001e  2600              MOVS     r6,#0
000020  b3e2              CBZ      r2,|L18.156|
;;;1752     {
;;;1753       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1754       {
;;;1755         assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
;;;1756         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1757       }
;;;1758       else
;;;1759       {
;;;1760         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1761         assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1762       }
;;;1763       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1764       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1765   
;;;1766       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1767       {
;;;1768         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
;;;1769       }
;;;1770       else
;;;1771       {
;;;1772         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
;;;1773       }
;;;1774       tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
;;;1775                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
;;;1776                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
;;;1777                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
;;;1778                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
;;;1779                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;1780                 ((uint32_t)sAlarm->AlarmMask));
;;;1781     }
;;;1782     else
;;;1783     {
;;;1784       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
000022  6820              LDR      r0,[r4,#0]
000024  6880              LDR      r0,[r0,#8]
000026  0640              LSLS     r0,r0,#25
000028  d400              BMI      |L18.44|
;;;1785       {
;;;1786         assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1787         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1788       }
;;;1789       else
;;;1790       {
;;;1791         sAlarm->AlarmTime.TimeFormat = 0x00U;
00002a  70de              STRB     r6,[r3,#3]
                  |L18.44|
;;;1792         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1793       }
;;;1794   
;;;1795       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1796       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1797   
;;;1798   #ifdef  USE_FULL_ASSERT
;;;1799       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1800       {
;;;1801         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1802       }
;;;1803       else
;;;1804       {
;;;1805         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1806       }
;;;1807   
;;;1808   #endif /* USE_FULL_ASSERT */
;;;1809       tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
00002c  7898              LDRB     r0,[r3,#2]
00002e  7819              LDRB     r1,[r3,#0]
000030  78da              LDRB     r2,[r3,#3]
000032  ea404001          ORR      r0,r0,r1,LSL #16
000036  7859              LDRB     r1,[r3,#1]
000038  0209              LSLS     r1,r1,#8
00003a  ea415182          ORR      r1,r1,r2,LSL #22
00003e  4308              ORRS     r0,r0,r1
000040  f8931024          LDRB     r1,[r3,#0x24]
000044  ea406501          ORR      r5,r0,r1,LSL #24
000048  6a18              LDR      r0,[r3,#0x20]
00004a  4305              ORRS     r5,r5,r0
00004c  6958              LDR      r0,[r3,#0x14]
00004e  4305              ORRS     r5,r5,r0
                  |L18.80|
;;;1810                 ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
;;;1811                 ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
;;;1812                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
;;;1813                 ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
;;;1814                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;1815                 ((uint32_t)sAlarm->AlarmMask));
;;;1816     }
;;;1817   
;;;1818     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;1819     subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
000050  685f              LDR      r7,[r3,#4]
000052  69d8              LDR      r0,[r3,#0x1c]
000054  4307              ORRS     r7,r7,r0
;;;1820   
;;;1821     /* Disable the write protection for RTC registers */
;;;1822     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000056  6821              LDR      r1,[r4,#0]
000058  20ca              MOVS     r0,#0xca
00005a  6248              STR      r0,[r1,#0x24]
00005c  6821              LDR      r1,[r4,#0]
00005e  2053              MOVS     r0,#0x53
000060  6248              STR      r0,[r1,#0x24]
;;;1823   
;;;1824     /* Configure the Alarm register */
;;;1825     if (sAlarm->Alarm == RTC_ALARM_A)
000062  6a98              LDR      r0,[r3,#0x28]
;;;1826     {
;;;1827       /* Disable the Alarm A interrupt */
;;;1828       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;1829       /* Clear flag alarm A */
;;;1830       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1831       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;1832       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
;;;1833   
;;;1834   #if defined (RTC_FLAG_ALRAWF)
;;;1835       uint32_t tickstart = HAL_GetTick();
;;;1836       /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
;;;1837       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
;;;1838       {
;;;1839         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1840         {
;;;1841           /* Enable the write protection for RTC registers */
;;;1842           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000064  f04f09ff          MOV      r9,#0xff
000068  f44f7b7a          MOV      r11,#0x3e8            ;1839
00006c  f5b07f80          CMP      r0,#0x100             ;1825
000070  d038              BEQ      |L18.228|
;;;1843   
;;;1844           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1845   
;;;1846           /* Process Unlocked */
;;;1847           __HAL_UNLOCK(hrtc);
;;;1848   
;;;1849           return HAL_TIMEOUT;
;;;1850         }
;;;1851       }
;;;1852   #endif
;;;1853   
;;;1854       hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
;;;1855       /* Configure the Alarm A Sub Second register */
;;;1856       hrtc->Instance->ALRMASSR = subsecondtmpreg;
;;;1857       /* Configure the Alarm state: Enable Alarm */
;;;1858       __HAL_RTC_ALARMA_ENABLE(hrtc);
;;;1859     }
;;;1860     else
;;;1861     {
;;;1862       /* Disable the Alarm B interrupt */
;;;1863       __HAL_RTC_ALARMB_DISABLE(hrtc);
000072  6820              LDR      r0,[r4,#0]
000074  6881              LDR      r1,[r0,#8]
000076  f4217100          BIC      r1,r1,#0x200
00007a  6081              STR      r1,[r0,#8]
;;;1864       /* Clear flag alarm B */
;;;1865       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
00007c  6820              LDR      r0,[r4,#0]
00007e  68c1              LDR      r1,[r0,#0xc]
000080  f0010180          AND      r1,r1,#0x80
000084  f4617120          ORN      r1,r1,#0x280
000088  60c1              STR      r1,[r0,#0xc]
;;;1866       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;1867       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
00008a  6820              LDR      r0,[r4,#0]
00008c  6881              LDR      r1,[r0,#8]
00008e  f4215100          BIC      r1,r1,#0x2000
000092  6081              STR      r1,[r0,#8]
;;;1868   
;;;1869   #if defined (RTC_FLAG_ALRBWF)
;;;1870       uint32_t tickstart = HAL_GetTick();
000094  f7fffffe          BL       HAL_GetTick
000098  4680              MOV      r8,r0
;;;1871       /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
;;;1872       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
00009a  e064              B        |L18.358|
                  |L18.156|
00009c  e002              B        |L18.164|
                  |L18.158|
00009e  2002              MOVS     r0,#2                 ;1747
                  |L18.160|
;;;1873       {
;;;1874         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1875         {
;;;1876           /* Enable the write protection for RTC registers */
;;;1877           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1878   
;;;1879           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1880   
;;;1881           /* Process Unlocked */
;;;1882           __HAL_UNLOCK(hrtc);
;;;1883   
;;;1884           return HAL_TIMEOUT;
;;;1885         }
;;;1886       }
;;;1887   #endif
;;;1888   
;;;1889       hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
;;;1890       /* Configure the Alarm B Sub Second register */
;;;1891       hrtc->Instance->ALRMBSSR = subsecondtmpreg;
;;;1892       /* Configure the Alarm state: Enable Alarm */
;;;1893       __HAL_RTC_ALARMB_ENABLE(hrtc);
;;;1894     }
;;;1895   
;;;1896     /* Enable the write protection for RTC registers */
;;;1897     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1898   
;;;1899     /* Change RTC state */
;;;1900     hrtc->State = HAL_RTC_STATE_READY;
;;;1901   
;;;1902     /* Process Unlocked */
;;;1903     __HAL_UNLOCK(hrtc);
;;;1904   
;;;1905     return HAL_OK;
;;;1906   }
0000a0  e8bd9ff0          POP      {r4-r12,pc}
                  |L18.164|
0000a4  6820              LDR      r0,[r4,#0]            ;1753
0000a6  6880              LDR      r0,[r0,#8]            ;1753
0000a8  0640              LSLS     r0,r0,#25             ;1753
0000aa  d400              BMI      |L18.174|
0000ac  70de              STRB     r6,[r3,#3]            ;1760
                  |L18.174|
0000ae  7818              LDRB     r0,[r3,#0]            ;1774
0000b0  f7fffffe          BL       RTC_ByteToBcd2
0000b4  0402              LSLS     r2,r0,#16             ;1774
0000b6  7858              LDRB     r0,[r3,#1]            ;1774
0000b8  f7fffffe          BL       RTC_ByteToBcd2
0000bc  ea422200          ORR      r2,r2,r0,LSL #8       ;1774
0000c0  7898              LDRB     r0,[r3,#2]            ;1774
0000c2  f7fffffe          BL       RTC_ByteToBcd2
0000c6  4302              ORRS     r2,r2,r0              ;1774
0000c8  78d8              LDRB     r0,[r3,#3]            ;1774
0000ca  ea425280          ORR      r2,r2,r0,LSL #22      ;1774
0000ce  f8930024          LDRB     r0,[r3,#0x24]         ;1774
0000d2  f7fffffe          BL       RTC_ByteToBcd2
0000d6  ea426500          ORR      r5,r2,r0,LSL #24      ;1774
0000da  6a18              LDR      r0,[r3,#0x20]         ;1774
0000dc  4305              ORRS     r5,r5,r0              ;1774
0000de  6958              LDR      r0,[r3,#0x14]         ;1774
0000e0  4305              ORRS     r5,r5,r0              ;1774
0000e2  e7b5              B        |L18.80|
                  |L18.228|
0000e4  6820              LDR      r0,[r4,#0]            ;1828
0000e6  6881              LDR      r1,[r0,#8]            ;1828
0000e8  f4217180          BIC      r1,r1,#0x100          ;1828
0000ec  6081              STR      r1,[r0,#8]            ;1828
0000ee  6820              LDR      r0,[r4,#0]            ;1830
0000f0  68c1              LDR      r1,[r0,#0xc]          ;1830
0000f2  f0010180          AND      r1,r1,#0x80           ;1830
0000f6  f46171c0          ORN      r1,r1,#0x180          ;1830
0000fa  60c1              STR      r1,[r0,#0xc]          ;1830
0000fc  6820              LDR      r0,[r4,#0]            ;1832
0000fe  6881              LDR      r1,[r0,#8]            ;1832
000100  f4215180          BIC      r1,r1,#0x1000         ;1832
000104  6081              STR      r1,[r0,#8]            ;1832
000106  f7fffffe          BL       HAL_GetTick
00010a  4680              MOV      r8,r0                 ;1835
00010c  e00e              B        |L18.300|
                  |L18.270|
00010e  f7fffffe          BL       HAL_GetTick
000112  eba00008          SUB      r0,r0,r8              ;1839
000116  4558              CMP      r0,r11                ;1839
000118  d908              BLS      |L18.300|
00011a  6820              LDR      r0,[r4,#0]            ;1842
00011c  f8c09024          STR      r9,[r0,#0x24]         ;1842
000120  2003              MOVS     r0,#3                 ;1844
000122  f8840021          STRB     r0,[r4,#0x21]         ;1844
000126  f8846020          STRB     r6,[r4,#0x20]         ;1847
00012a  e7b9              B        |L18.160|
                  |L18.300|
00012c  6820              LDR      r0,[r4,#0]            ;1837
00012e  68c0              LDR      r0,[r0,#0xc]          ;1837
000130  07c0              LSLS     r0,r0,#31             ;1837
000132  d0ec              BEQ      |L18.270|
000134  6820              LDR      r0,[r4,#0]            ;1854
000136  61c5              STR      r5,[r0,#0x1c]         ;1854
000138  6820              LDR      r0,[r4,#0]            ;1856
00013a  6447              STR      r7,[r0,#0x44]         ;1856
00013c  6820              LDR      r0,[r4,#0]            ;1858
00013e  6881              LDR      r1,[r0,#8]            ;1858
000140  f4417180          ORR      r1,r1,#0x100          ;1858
000144  6081              STR      r1,[r0,#8]            ;1858
000146  e01b              B        |L18.384|
                  |L18.328|
000148  f7fffffe          BL       HAL_GetTick
00014c  eba00008          SUB      r0,r0,r8              ;1874
000150  4558              CMP      r0,r11                ;1874
000152  d908              BLS      |L18.358|
000154  6820              LDR      r0,[r4,#0]            ;1877
000156  f8c09024          STR      r9,[r0,#0x24]         ;1877
00015a  2003              MOVS     r0,#3                 ;1879
00015c  f8840021          STRB     r0,[r4,#0x21]         ;1879
000160  f8846020          STRB     r6,[r4,#0x20]         ;1882
000164  e79c              B        |L18.160|
                  |L18.358|
000166  6820              LDR      r0,[r4,#0]            ;1872
000168  68c0              LDR      r0,[r0,#0xc]          ;1872
00016a  0780              LSLS     r0,r0,#30             ;1872
00016c  d5ec              BPL      |L18.328|
00016e  6820              LDR      r0,[r4,#0]            ;1889
000170  6205              STR      r5,[r0,#0x20]         ;1889
000172  6820              LDR      r0,[r4,#0]            ;1891
000174  6487              STR      r7,[r0,#0x48]         ;1891
000176  6820              LDR      r0,[r4,#0]            ;1893
000178  6881              LDR      r1,[r0,#8]            ;1893
00017a  f4417100          ORR      r1,r1,#0x200          ;1893
00017e  6081              STR      r1,[r0,#8]            ;1893
                  |L18.384|
000180  6820              LDR      r0,[r4,#0]            ;1897
000182  f8c09024          STR      r9,[r0,#0x24]         ;1897
000186  f884a021          STRB     r10,[r4,#0x21]        ;1900
00018a  f8846020          STRB     r6,[r4,#0x20]         ;1903
00018e  2000              MOVS     r0,#0                 ;1905
000190  e786              B        |L18.160|
;;;1907   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetAlarm_IT PROC
;;;1920     */
;;;1921   HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1922   {
000004  4604              MOV      r4,r0
000006  460b              MOV      r3,r1
;;;1923     uint32_t tmpreg, subsecondtmpreg;
;;;1924   
;;;1925     /* Check the parameters */
;;;1926     assert_param(IS_RTC_FORMAT(Format));
;;;1927     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1928     assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
;;;1929     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
;;;1930     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
;;;1931     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
;;;1932   
;;;1933     /* Process Locked */
;;;1934     __HAL_LOCK(hrtc);
000008  f8940020          LDRB     r0,[r4,#0x20]
00000c  2801              CMP      r0,#1
00000e  d041              BEQ      |L19.148|
000010  f04f0a01          MOV      r10,#1
000014  f884a020          STRB     r10,[r4,#0x20]
;;;1935   
;;;1936     hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f8840021          STRB     r0,[r4,#0x21]
;;;1937   
;;;1938     if (Format == RTC_FORMAT_BIN)
00001e  2600              MOVS     r6,#0
000020  b3ba              CBZ      r2,|L19.146|
;;;1939     {
;;;1940       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1941       {
;;;1942         assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
;;;1943         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1944       }
;;;1945       else
;;;1946       {
;;;1947         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1948         assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1949       }
;;;1950       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1951       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1952   
;;;1953       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1954       {
;;;1955         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
;;;1956       }
;;;1957       else
;;;1958       {
;;;1959         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
;;;1960       }
;;;1961   
;;;1962       tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
;;;1963                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
;;;1964                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
;;;1965                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
;;;1966                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
;;;1967                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;1968                 ((uint32_t)sAlarm->AlarmMask));
;;;1969     }
;;;1970     else
;;;1971     {
;;;1972       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
000022  6820              LDR      r0,[r4,#0]
000024  6880              LDR      r0,[r0,#8]
000026  0640              LSLS     r0,r0,#25
000028  d400              BMI      |L19.44|
;;;1973       {
;;;1974         assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1975         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1976       }
;;;1977       else
;;;1978       {
;;;1979         sAlarm->AlarmTime.TimeFormat = 0x00U;
00002a  70de              STRB     r6,[r3,#3]
                  |L19.44|
;;;1980         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1981       }
;;;1982   
;;;1983       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1984       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1985   
;;;1986   #ifdef  USE_FULL_ASSERT
;;;1987       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1988       {
;;;1989         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1990       }
;;;1991       else
;;;1992       {
;;;1993         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1994       }
;;;1995   
;;;1996   #endif /* USE_FULL_ASSERT */
;;;1997       tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
00002c  7898              LDRB     r0,[r3,#2]
00002e  7819              LDRB     r1,[r3,#0]
000030  78da              LDRB     r2,[r3,#3]
000032  ea404001          ORR      r0,r0,r1,LSL #16
000036  7859              LDRB     r1,[r3,#1]
000038  0209              LSLS     r1,r1,#8
00003a  ea415182          ORR      r1,r1,r2,LSL #22
00003e  4308              ORRS     r0,r0,r1
000040  f8931024          LDRB     r1,[r3,#0x24]
000044  ea406501          ORR      r5,r0,r1,LSL #24
000048  6a18              LDR      r0,[r3,#0x20]
00004a  4305              ORRS     r5,r5,r0
00004c  6958              LDR      r0,[r3,#0x14]
00004e  4305              ORRS     r5,r5,r0
                  |L19.80|
;;;1998                 ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
;;;1999                 ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
;;;2000                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
;;;2001                 ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
;;;2002                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;2003                 ((uint32_t)sAlarm->AlarmMask));
;;;2004     }
;;;2005     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;2006     subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
000050  685f              LDR      r7,[r3,#4]
000052  69d8              LDR      r0,[r3,#0x1c]
000054  4307              ORRS     r7,r7,r0
;;;2007   
;;;2008     /* Disable the write protection for RTC registers */
;;;2009     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000056  6821              LDR      r1,[r4,#0]
000058  20ca              MOVS     r0,#0xca
00005a  6248              STR      r0,[r1,#0x24]
00005c  6821              LDR      r1,[r4,#0]
00005e  2053              MOVS     r0,#0x53
000060  6248              STR      r0,[r1,#0x24]
;;;2010   
;;;2011     /* Configure the Alarm register */
;;;2012     if (sAlarm->Alarm == RTC_ALARM_A)
000062  6a98              LDR      r0,[r3,#0x28]
;;;2013     {
;;;2014       /* Disable the Alarm A interrupt */
;;;2015       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;2016   
;;;2017       /* Clear flag alarm A */
;;;2018       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;2019   
;;;2020   #if defined (RTC_FLAG_ALRAWF)
;;;2021       uint32_t tickstart = HAL_GetTick();
;;;2022       /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
;;;2023       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
;;;2024       {
;;;2025         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;2026         {
;;;2027           /* Enable the write protection for RTC registers */
;;;2028           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000064  f04f09ff          MOV      r9,#0xff
000068  f44f7b7a          MOV      r11,#0x3e8            ;2025
00006c  f5b07f80          CMP      r0,#0x100             ;2012
000070  d033              BEQ      |L19.218|
;;;2029   
;;;2030           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;2031   
;;;2032           /* Process Unlocked */
;;;2033           __HAL_UNLOCK(hrtc);
;;;2034   
;;;2035           return HAL_TIMEOUT;
;;;2036         }
;;;2037       }
;;;2038   #endif
;;;2039   
;;;2040       hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
;;;2041       /* Configure the Alarm A Sub Second register */
;;;2042       hrtc->Instance->ALRMASSR = subsecondtmpreg;
;;;2043       /* Configure the Alarm state: Enable Alarm */
;;;2044       __HAL_RTC_ALARMA_ENABLE(hrtc);
;;;2045       /* Configure the Alarm interrupt */
;;;2046       __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
;;;2047     }
;;;2048     else
;;;2049     {
;;;2050       /* Disable the Alarm B interrupt */
;;;2051       __HAL_RTC_ALARMB_DISABLE(hrtc);
000072  6820              LDR      r0,[r4,#0]
000074  6881              LDR      r1,[r0,#8]
000076  f4217100          BIC      r1,r1,#0x200
00007a  6081              STR      r1,[r0,#8]
;;;2052   
;;;2053       /* Clear flag alarm B */
;;;2054       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
00007c  6820              LDR      r0,[r4,#0]
00007e  68c1              LDR      r1,[r0,#0xc]
000080  f0010180          AND      r1,r1,#0x80
000084  f4617120          ORN      r1,r1,#0x280
000088  60c1              STR      r1,[r0,#0xc]
;;;2055   
;;;2056   #if defined (RTC_FLAG_ALRBWF)
;;;2057       uint32_t tickstart = HAL_GetTick();
00008a  f7fffffe          BL       HAL_GetTick
00008e  4680              MOV      r8,r0
;;;2058       /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
;;;2059       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
000090  e064              B        |L19.348|
                  |L19.146|
000092  e002              B        |L19.154|
                  |L19.148|
000094  2002              MOVS     r0,#2                 ;1934
                  |L19.150|
;;;2060       {
;;;2061         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;2062         {
;;;2063           /* Enable the write protection for RTC registers */
;;;2064           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;2065   
;;;2066           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;2067   
;;;2068           /* Process Unlocked */
;;;2069           __HAL_UNLOCK(hrtc);
;;;2070   
;;;2071           return HAL_TIMEOUT;
;;;2072         }
;;;2073       }
;;;2074   #endif
;;;2075   
;;;2076       hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
;;;2077       /* Configure the Alarm B Sub Second register */
;;;2078       hrtc->Instance->ALRMBSSR = subsecondtmpreg;
;;;2079       /* Configure the Alarm state: Enable Alarm */
;;;2080       __HAL_RTC_ALARMB_ENABLE(hrtc);
;;;2081       /* Configure the Alarm interrupt */
;;;2082       __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
;;;2083     }
;;;2084   
;;;2085     /* RTC Alarm Interrupt Configuration: EXTI configuration */
;;;2086     __HAL_RTC_ALARM_EXTI_ENABLE_IT();
;;;2087     __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
;;;2088   
;;;2089     /* Enable the write protection for RTC registers */
;;;2090     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;2091   
;;;2092     hrtc->State = HAL_RTC_STATE_READY;
;;;2093   
;;;2094     /* Process Unlocked */
;;;2095     __HAL_UNLOCK(hrtc);
;;;2096   
;;;2097     return HAL_OK;
;;;2098   }
000096  e8bd9ff0          POP      {r4-r12,pc}
                  |L19.154|
00009a  6820              LDR      r0,[r4,#0]            ;1940
00009c  6880              LDR      r0,[r0,#8]            ;1940
00009e  0640              LSLS     r0,r0,#25             ;1940
0000a0  d400              BMI      |L19.164|
0000a2  70de              STRB     r6,[r3,#3]            ;1947
                  |L19.164|
0000a4  7818              LDRB     r0,[r3,#0]            ;1962
0000a6  f7fffffe          BL       RTC_ByteToBcd2
0000aa  0402              LSLS     r2,r0,#16             ;1962
0000ac  7858              LDRB     r0,[r3,#1]            ;1962
0000ae  f7fffffe          BL       RTC_ByteToBcd2
0000b2  ea422200          ORR      r2,r2,r0,LSL #8       ;1962
0000b6  7898              LDRB     r0,[r3,#2]            ;1962
0000b8  f7fffffe          BL       RTC_ByteToBcd2
0000bc  4302              ORRS     r2,r2,r0              ;1962
0000be  78d8              LDRB     r0,[r3,#3]            ;1962
0000c0  ea425280          ORR      r2,r2,r0,LSL #22      ;1962
0000c4  f8930024          LDRB     r0,[r3,#0x24]         ;1962
0000c8  f7fffffe          BL       RTC_ByteToBcd2
0000cc  ea426500          ORR      r5,r2,r0,LSL #24      ;1962
0000d0  6a18              LDR      r0,[r3,#0x20]         ;1962
0000d2  4305              ORRS     r5,r5,r0              ;1962
0000d4  6958              LDR      r0,[r3,#0x14]         ;1962
0000d6  4305              ORRS     r5,r5,r0              ;1962
0000d8  e7ba              B        |L19.80|
                  |L19.218|
0000da  6820              LDR      r0,[r4,#0]            ;2015
0000dc  6881              LDR      r1,[r0,#8]            ;2015
0000de  f4217180          BIC      r1,r1,#0x100          ;2015
0000e2  6081              STR      r1,[r0,#8]            ;2015
0000e4  6820              LDR      r0,[r4,#0]            ;2018
0000e6  68c1              LDR      r1,[r0,#0xc]          ;2018
0000e8  f0010180          AND      r1,r1,#0x80           ;2018
0000ec  f46171c0          ORN      r1,r1,#0x180          ;2018
0000f0  60c1              STR      r1,[r0,#0xc]          ;2018
0000f2  f7fffffe          BL       HAL_GetTick
0000f6  4680              MOV      r8,r0                 ;2021
0000f8  e00e              B        |L19.280|
                  |L19.250|
0000fa  f7fffffe          BL       HAL_GetTick
0000fe  eba00008          SUB      r0,r0,r8              ;2025
000102  4558              CMP      r0,r11                ;2025
000104  d908              BLS      |L19.280|
000106  6820              LDR      r0,[r4,#0]            ;2028
000108  f8c09024          STR      r9,[r0,#0x24]         ;2028
00010c  2003              MOVS     r0,#3                 ;2030
00010e  f8840021          STRB     r0,[r4,#0x21]         ;2030
000112  f8846020          STRB     r6,[r4,#0x20]         ;2033
000116  e7be              B        |L19.150|
                  |L19.280|
000118  6820              LDR      r0,[r4,#0]            ;2023
00011a  68c0              LDR      r0,[r0,#0xc]          ;2023
00011c  07c0              LSLS     r0,r0,#31             ;2023
00011e  d0ec              BEQ      |L19.250|
000120  6820              LDR      r0,[r4,#0]            ;2040
000122  61c5              STR      r5,[r0,#0x1c]         ;2040
000124  6820              LDR      r0,[r4,#0]            ;2042
000126  6447              STR      r7,[r0,#0x44]         ;2042
000128  6820              LDR      r0,[r4,#0]            ;2044
00012a  6881              LDR      r1,[r0,#8]            ;2044
00012c  f4417180          ORR      r1,r1,#0x100          ;2044
000130  6081              STR      r1,[r0,#8]            ;2044
000132  6820              LDR      r0,[r4,#0]            ;2046
000134  6881              LDR      r1,[r0,#8]            ;2046
000136  f4415180          ORR      r1,r1,#0x1000         ;2046
00013a  6081              STR      r1,[r0,#8]            ;2046
00013c  e020              B        |L19.384|
                  |L19.318|
00013e  f7fffffe          BL       HAL_GetTick
000142  eba00008          SUB      r0,r0,r8              ;2061
000146  4558              CMP      r0,r11                ;2061
000148  d908              BLS      |L19.348|
00014a  6820              LDR      r0,[r4,#0]            ;2064
00014c  f8c09024          STR      r9,[r0,#0x24]         ;2064
000150  2003              MOVS     r0,#3                 ;2066
000152  f8840021          STRB     r0,[r4,#0x21]         ;2066
000156  f8846020          STRB     r6,[r4,#0x20]         ;2069
00015a  e79c              B        |L19.150|
                  |L19.348|
00015c  6820              LDR      r0,[r4,#0]            ;2059
00015e  68c0              LDR      r0,[r0,#0xc]          ;2059
000160  0780              LSLS     r0,r0,#30             ;2059
000162  d5ec              BPL      |L19.318|
000164  6820              LDR      r0,[r4,#0]            ;2076
000166  6205              STR      r5,[r0,#0x20]         ;2076
000168  6820              LDR      r0,[r4,#0]            ;2078
00016a  6487              STR      r7,[r0,#0x48]         ;2078
00016c  6820              LDR      r0,[r4,#0]            ;2080
00016e  6881              LDR      r1,[r0,#8]            ;2080
000170  f4417100          ORR      r1,r1,#0x200          ;2080
000174  6081              STR      r1,[r0,#8]            ;2080
000176  6820              LDR      r0,[r4,#0]            ;2082
000178  6881              LDR      r1,[r0,#8]            ;2082
00017a  f4415100          ORR      r1,r1,#0x2000         ;2082
00017e  6081              STR      r1,[r0,#8]            ;2082
                  |L19.384|
000180  4809              LDR      r0,|L19.424|
000182  6801              LDR      r1,[r0,#0]            ;2086
000184  f4412180          ORR      r1,r1,#0x40000        ;2086
000188  6001              STR      r1,[r0,#0]            ;2086
00018a  4807              LDR      r0,|L19.424|
00018c  3008              ADDS     r0,r0,#8              ;2087
00018e  6801              LDR      r1,[r0,#0]            ;2087
000190  f4412180          ORR      r1,r1,#0x40000        ;2087
000194  6001              STR      r1,[r0,#0]            ;2087
000196  6820              LDR      r0,[r4,#0]            ;2090
000198  f8c09024          STR      r9,[r0,#0x24]         ;2090
00019c  f884a021          STRB     r10,[r4,#0x21]        ;2092
0001a0  f8846020          STRB     r6,[r4,#0x20]         ;2095
0001a4  2000              MOVS     r0,#0                 ;2097
0001a6  e776              B        |L19.150|
;;;2099   
                          ENDP

                  |L19.424|
                          DCD      0x40010400

                          AREA ||i.HAL_RTC_SetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetDate PROC
;;;1595     */
;;;1596   HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;1597   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1598     uint32_t datetmpreg;
;;;1599     HAL_StatusTypeDef status;
;;;1600   
;;;1601     /* Check the parameters */
;;;1602     assert_param(IS_RTC_FORMAT(Format));
;;;1603   
;;;1604     /* Process Locked */
;;;1605     __HAL_LOCK(hrtc);
000006  f8940020          LDRB     r0,[r4,#0x20]
00000a  2801              CMP      r0,#1
00000c  d007              BEQ      |L20.30|
00000e  2601              MOVS     r6,#1
000010  f8846020          STRB     r6,[r4,#0x20]
;;;1606   
;;;1607     hrtc->State = HAL_RTC_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f8840021          STRB     r0,[r4,#0x21]
00001a  b112              CBZ      r2,|L20.34|
00001c  e008              B        |L20.48|
                  |L20.30|
00001e  2002              MOVS     r0,#2                 ;1605
;;;1608   
;;;1609     if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
;;;1610     {
;;;1611       sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
;;;1612     }
;;;1613   
;;;1614     assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));
;;;1615   
;;;1616     if (Format == RTC_FORMAT_BIN)
;;;1617     {
;;;1618       assert_param(IS_RTC_YEAR(sDate->Year));
;;;1619       assert_param(IS_RTC_MONTH(sDate->Month));
;;;1620       assert_param(IS_RTC_DATE(sDate->Date));
;;;1621   
;;;1622       datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
;;;1623                     ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
;;;1624                     ((uint32_t)RTC_ByteToBcd2(sDate->Date) << RTC_DR_DU_Pos) | \
;;;1625                     ((uint32_t)sDate->WeekDay << RTC_DR_WDU_Pos));
;;;1626     }
;;;1627     else
;;;1628     {
;;;1629       assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
;;;1630       assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
;;;1631       assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
;;;1632   
;;;1633       datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
;;;1634                     (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
;;;1635                     (((uint32_t)sDate->Date) << RTC_DR_DU_Pos) | \
;;;1636                     (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
;;;1637     }
;;;1638   
;;;1639     /* Disable the write protection for RTC registers */
;;;1640     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1641   
;;;1642     /* Enter Initialization mode */
;;;1643     status = RTC_EnterInitMode(hrtc);
;;;1644     if (status == HAL_OK)
;;;1645     {
;;;1646       /* Set the RTC_DR register */
;;;1647       hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
;;;1648   
;;;1649       /* Exit Initialization mode */
;;;1650       status = RTC_ExitInitMode(hrtc);
;;;1651     }
;;;1652   
;;;1653     /* Enable the write protection for RTC registers */
;;;1654     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1655   
;;;1656     if (status == HAL_OK)
;;;1657     {
;;;1658       hrtc->State = HAL_RTC_STATE_READY ;
;;;1659     }
;;;1660   
;;;1661     /* Process Unlocked */
;;;1662     __HAL_UNLOCK(hrtc);
;;;1663   
;;;1664     return status;
;;;1665   }
000020  bd70              POP      {r4-r6,pc}
                  |L20.34|
000022  7858              LDRB     r0,[r3,#1]            ;1609
000024  06c1              LSLS     r1,r0,#27             ;1609
000026  d503              BPL      |L20.48|
000028  f00000ef          AND      r0,r0,#0xef           ;1611
00002c  300a              ADDS     r0,r0,#0xa            ;1611
00002e  7058              STRB     r0,[r3,#1]            ;1611
                  |L20.48|
000030  b1a2              CBZ      r2,|L20.92|
000032  7898              LDRB     r0,[r3,#2]            ;1633
000034  78d9              LDRB     r1,[r3,#3]            ;1633
000036  ea404501          ORR      r5,r0,r1,LSL #16      ;1633
00003a  7858              LDRB     r0,[r3,#1]            ;1633
00003c  7819              LDRB     r1,[r3,#0]            ;1633
00003e  0200              LSLS     r0,r0,#8              ;1633
000040  ea403041          ORR      r0,r0,r1,LSL #13      ;1633
000044  4305              ORRS     r5,r5,r0              ;1633
                  |L20.70|
000046  6821              LDR      r1,[r4,#0]            ;1640
000048  20ca              MOVS     r0,#0xca              ;1640
00004a  6248              STR      r0,[r1,#0x24]         ;1640
00004c  6821              LDR      r1,[r4,#0]            ;1640
00004e  2053              MOVS     r0,#0x53              ;1640
000050  6248              STR      r0,[r1,#0x24]         ;1640
000052  4620              MOV      r0,r4                 ;1643
000054  f7fffffe          BL       RTC_EnterInitMode
000058  b188              CBZ      r0,|L20.126|
00005a  e017              B        |L20.140|
                  |L20.92|
00005c  78d8              LDRB     r0,[r3,#3]            ;1622
00005e  f7fffffe          BL       RTC_ByteToBcd2
000062  0402              LSLS     r2,r0,#16             ;1622
000064  7858              LDRB     r0,[r3,#1]            ;1622
000066  f7fffffe          BL       RTC_ByteToBcd2
00006a  ea422200          ORR      r2,r2,r0,LSL #8       ;1622
00006e  7898              LDRB     r0,[r3,#2]            ;1622
000070  f7fffffe          BL       RTC_ByteToBcd2
000074  4302              ORRS     r2,r2,r0              ;1622
000076  7818              LDRB     r0,[r3,#0]            ;1622
000078  ea423540          ORR      r5,r2,r0,LSL #13      ;1622
00007c  e7e3              B        |L20.70|
                  |L20.126|
00007e  4808              LDR      r0,|L20.160|
000080  4005              ANDS     r5,r5,r0              ;1647
000082  6820              LDR      r0,[r4,#0]            ;1647
000084  6045              STR      r5,[r0,#4]            ;1647
000086  4620              MOV      r0,r4                 ;1650
000088  f7fffffe          BL       RTC_ExitInitMode
                  |L20.140|
00008c  6822              LDR      r2,[r4,#0]            ;1654
00008e  21ff              MOVS     r1,#0xff              ;1654
000090  6251              STR      r1,[r2,#0x24]         ;1654
000092  b908              CBNZ     r0,|L20.152|
000094  f8846021          STRB     r6,[r4,#0x21]         ;1658
                  |L20.152|
000098  2100              MOVS     r1,#0                 ;1662
00009a  f8841020          STRB     r1,[r4,#0x20]         ;1662
00009e  bd70              POP      {r4-r6,pc}
;;;1666   
                          ENDP

                  |L20.160|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTC_SetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetTime PROC
;;;1441     */
;;;1442   HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1443   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;1444     uint32_t tmpreg;
;;;1445     HAL_StatusTypeDef status;
;;;1446   
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_RTC_FORMAT(Format));
;;;1449     assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
;;;1450     assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));
;;;1451   
;;;1452     /* Process Locked */
;;;1453     __HAL_LOCK(hrtc);
00000a  f8940020          LDRB     r0,[r4,#0x20]
00000e  2801              CMP      r0,#1
000010  d011              BEQ      |L21.54|
000012  2701              MOVS     r7,#1
000014  f8847020          STRB     r7,[r4,#0x20]
;;;1454   
;;;1455     hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f8840021          STRB     r0,[r4,#0x21]
;;;1456   
;;;1457     /* Disable the write protection for RTC registers */
;;;1458     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00001e  6821              LDR      r1,[r4,#0]
000020  20ca              MOVS     r0,#0xca
000022  6248              STR      r0,[r1,#0x24]
000024  6821              LDR      r1,[r4,#0]
000026  2053              MOVS     r0,#0x53
000028  6248              STR      r0,[r1,#0x24]
;;;1459   
;;;1460     /* Enter Initialization mode */
;;;1461     status = RTC_EnterInitMode(hrtc);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       RTC_EnterInitMode
;;;1462     if (status == HAL_OK)
000030  2600              MOVS     r6,#0
000032  b118              CBZ      r0,|L21.60|
000034  e027              B        |L21.134|
                  |L21.54|
000036  2002              MOVS     r0,#2                 ;1453
                  |L21.56|
;;;1463     {
;;;1464       if (Format == RTC_FORMAT_BIN)
;;;1465       {
;;;1466         if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1467         {
;;;1468           assert_param(IS_RTC_HOUR12(sTime->Hours));
;;;1469           assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
;;;1470         }
;;;1471         else
;;;1472         {
;;;1473           sTime->TimeFormat = 0x00U;
;;;1474           assert_param(IS_RTC_HOUR24(sTime->Hours));
;;;1475         }
;;;1476         assert_param(IS_RTC_MINUTES(sTime->Minutes));
;;;1477         assert_param(IS_RTC_SECONDS(sTime->Seconds));
;;;1478   
;;;1479         tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
;;;1480                             ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
;;;1481                             ((uint32_t)RTC_ByteToBcd2(sTime->Seconds) << RTC_TR_SU_Pos) | \
;;;1482                             (((uint32_t)sTime->TimeFormat) << RTC_TR_PM_Pos));
;;;1483       }
;;;1484       else
;;;1485       {
;;;1486         if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1487         {
;;;1488           assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
;;;1489           assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
;;;1490         }
;;;1491         else
;;;1492         {
;;;1493           sTime->TimeFormat = 0x00U;
;;;1494           assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
;;;1495         }
;;;1496         assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
;;;1497         assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
;;;1498         tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
;;;1499                   ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
;;;1500                   ((uint32_t)(sTime->Seconds) << RTC_TR_SU_Pos) | \
;;;1501                   ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
;;;1502       }
;;;1503   
;;;1504       /* Set the RTC_TR register */
;;;1505       hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
;;;1506   
;;;1507       /* Clear the bits to be configured */
;;;1508       hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BKP);
;;;1509   
;;;1510       /* Configure the RTC_CR register */
;;;1511       hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
;;;1512   
;;;1513       /* Exit Initialization mode */
;;;1514       status = RTC_ExitInitMode(hrtc);
;;;1515     }
;;;1516   
;;;1517     /* Enable the write protection for RTC registers */
;;;1518     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1519   
;;;1520     if (status == HAL_OK)
;;;1521     {
;;;1522       hrtc->State = HAL_RTC_STATE_READY;
;;;1523     }
;;;1524   
;;;1525     /* Process Unlocked */
;;;1526     __HAL_UNLOCK(hrtc);
;;;1527   
;;;1528     return status;
;;;1529   }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L21.60|
00003c  f1b80f00          CMP      r8,#0                 ;1464
000040  d026              BEQ      |L21.144|
000042  6820              LDR      r0,[r4,#0]            ;1486
000044  6880              LDR      r0,[r0,#8]            ;1486
000046  0640              LSLS     r0,r0,#25             ;1486
000048  d400              BMI      |L21.76|
00004a  70ee              STRB     r6,[r5,#3]            ;1493
                  |L21.76|
00004c  78a8              LDRB     r0,[r5,#2]            ;1498
00004e  7829              LDRB     r1,[r5,#0]            ;1498
000050  78ea              LDRB     r2,[r5,#3]            ;1498
000052  ea404001          ORR      r0,r0,r1,LSL #16      ;1498
000056  7869              LDRB     r1,[r5,#1]            ;1498
000058  0209              LSLS     r1,r1,#8              ;1498
00005a  ea415182          ORR      r1,r1,r2,LSL #22      ;1498
00005e  4308              ORRS     r0,r0,r1              ;1498
                  |L21.96|
000060  4919              LDR      r1,|L21.200|
000062  4008              ANDS     r0,r0,r1              ;1505
000064  6821              LDR      r1,[r4,#0]            ;1505
000066  6008              STR      r0,[r1,#0]            ;1505
000068  6820              LDR      r0,[r4,#0]            ;1508
00006a  6881              LDR      r1,[r0,#8]            ;1508
00006c  f4212180          BIC      r1,r1,#0x40000        ;1508
000070  6081              STR      r1,[r0,#8]            ;1508
000072  e9d51003          LDRD     r1,r0,[r5,#0xc]       ;1511
000076  4301              ORRS     r1,r1,r0              ;1511
000078  6820              LDR      r0,[r4,#0]            ;1511
00007a  6882              LDR      r2,[r0,#8]            ;1511
00007c  4311              ORRS     r1,r1,r2              ;1511
00007e  6081              STR      r1,[r0,#8]            ;1511
000080  4620              MOV      r0,r4                 ;1514
000082  f7fffffe          BL       RTC_ExitInitMode
                  |L21.134|
000086  6822              LDR      r2,[r4,#0]            ;1518
000088  21ff              MOVS     r1,#0xff              ;1518
00008a  6251              STR      r1,[r2,#0x24]         ;1518
00008c  b1b0              CBZ      r0,|L21.188|
00008e  e017              B        |L21.192|
                  |L21.144|
000090  6820              LDR      r0,[r4,#0]            ;1466
000092  6880              LDR      r0,[r0,#8]            ;1466
000094  0640              LSLS     r0,r0,#25             ;1466
000096  d400              BMI      |L21.154|
000098  70ee              STRB     r6,[r5,#3]            ;1473
                  |L21.154|
00009a  7828              LDRB     r0,[r5,#0]            ;1479
00009c  f7fffffe          BL       RTC_ByteToBcd2
0000a0  0402              LSLS     r2,r0,#16             ;1479
0000a2  7868              LDRB     r0,[r5,#1]            ;1479
0000a4  f7fffffe          BL       RTC_ByteToBcd2
0000a8  ea422200          ORR      r2,r2,r0,LSL #8       ;1479
0000ac  78a8              LDRB     r0,[r5,#2]            ;1479
0000ae  f7fffffe          BL       RTC_ByteToBcd2
0000b2  4302              ORRS     r2,r2,r0              ;1479
0000b4  78e8              LDRB     r0,[r5,#3]            ;1479
0000b6  ea425080          ORR      r0,r2,r0,LSL #22      ;1479
0000ba  e7d1              B        |L21.96|
                  |L21.188|
0000bc  f8847021          STRB     r7,[r4,#0x21]         ;1522
                  |L21.192|
0000c0  f8846020          STRB     r6,[r4,#0x20]         ;1526
0000c4  e7b8              B        |L21.56|
;;;1530   
                          ENDP

0000c6  0000              DCW      0x0000
                  |L21.200|
                          DCD      0x007f7f7f

                          AREA ||i.HAL_RTC_WaitForSynchro||, CODE, READONLY, ALIGN=1

                  HAL_RTC_WaitForSynchro PROC
;;;2495     */
;;;2496   HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;2497   {
000002  4605              MOV      r5,r0
;;;2498     uint32_t tickstart;
;;;2499   
;;;2500     /* Clear RSF flag */
;;;2501   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;2502     hrtc->Instance->ICSR &= (uint32_t)RTC_RSF_MASK;
;;;2503   #else
;;;2504     hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
000004  6828              LDR      r0,[r5,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101a0          BIC      r1,r1,#0xa0
00000c  60c1              STR      r1,[r0,#0xc]
;;;2505   #endif
;;;2506   
;;;2507     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4604              MOV      r4,r0
;;;2508   
;;;2509     /* Wait the registers to be synchronised */
;;;2510   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;2511     while ((hrtc->Instance->ICSR & RTC_ICSR_RSF) == 0U)
;;;2512   #else
;;;2513     while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
;;;2514   #endif
;;;2515     {
;;;2516       if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
000014  f44f767a          MOV      r6,#0x3e8
000018  e006              B        |L22.40|
                  |L22.26|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b00              SUBS     r0,r0,r4
000020  42b0              CMP      r0,r6
000022  d901              BLS      |L22.40|
;;;2517       {
;;;2518         return HAL_TIMEOUT;
000024  2003              MOVS     r0,#3
;;;2519       }
;;;2520     }
;;;2521   
;;;2522     return HAL_OK;
;;;2523   }
000026  bd70              POP      {r4-r6,pc}
                  |L22.40|
000028  6828              LDR      r0,[r5,#0]            ;2513
00002a  68c0              LDR      r0,[r0,#0xc]          ;2513
00002c  0680              LSLS     r0,r0,#26             ;2513
00002e  d5f4              BPL      |L22.26|
000030  2000              MOVS     r0,#0                 ;2522
000032  bd70              POP      {r4-r6,pc}
;;;2524   
                          ENDP


                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2684     */
;;;2685   uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;2686   {
;;;2687     uint8_t tmp;
;;;2688     tmp = ((Value & 0xF0U) >> 4U) * 10U;
000002  eb010181          ADD      r1,r1,r1,LSL #2
000006  0049              LSLS     r1,r1,#1
;;;2689     return (tmp + (Value & 0x0FU));
000008  f000000f          AND      r0,r0,#0xf
00000c  4408              ADD      r0,r0,r1
00000e  b2c0              UXTB     r0,r0
;;;2690   }
000010  4770              BX       lr
;;;2691   
                          ENDP


                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2665     */
;;;2666   uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;2667   {
000002  e002              B        |L24.10|
                  |L24.4|
;;;2668     uint32_t bcdhigh = 0U;
;;;2669     uint8_t temp = Value;
;;;2670   
;;;2671     while (temp >= 10U)
;;;2672     {
;;;2673       bcdhigh++;
000004  1c49              ADDS     r1,r1,#1
;;;2674       temp -= 10U;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c0              UXTB     r0,r0
                  |L24.10|
00000a  280a              CMP      r0,#0xa               ;2671
00000c  d2fa              BCS      |L24.4|
;;;2675     }
;;;2676   
;;;2677     return ((uint8_t)(bcdhigh << 4U) | temp);
00000e  0709              LSLS     r1,r1,#28
000010  ea406011          ORR      r0,r0,r1,LSR #24
;;;2678   }
000014  4770              BX       lr
;;;2679   
                          ENDP


                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=1

                  RTC_EnterInitMode PROC
;;;2571     */
;;;2572   HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2573   {
000004  4604              MOV      r4,r0
;;;2574     uint32_t tickstart;
;;;2575     HAL_StatusTypeDef status = HAL_OK;
000006  2500              MOVS     r5,#0
;;;2576   
;;;2577     /* Check if the Initialization mode is set */
;;;2578   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;2579     if ((hrtc->Instance->ICSR & RTC_ICSR_INITF) == 0U)
;;;2580     {
;;;2581       /* Set the Initialization mode */
;;;2582       SET_BIT(hrtc->Instance->ICSR, RTC_ICSR_INIT);
;;;2583   
;;;2584       tickstart = HAL_GetTick();
;;;2585       /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;2586       while ((READ_BIT(hrtc->Instance->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
;;;2587       {
;;;2588         if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
;;;2589         {
;;;2590           status = HAL_TIMEOUT;
;;;2591           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;2592         }
;;;2593       }
;;;2594     }
;;;2595   #else /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2596     if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
000008  6820              LDR      r0,[r4,#0]
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  0649              LSLS     r1,r1,#25
00000e  d416              BMI      |L25.62|
;;;2597     {
;;;2598       /* Set the Initialization mode */
;;;2599       hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
000010  1e69              SUBS     r1,r5,#1
000012  60c1              STR      r1,[r0,#0xc]
;;;2600   
;;;2601       tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4606              MOV      r6,r0
;;;2602       /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;2603       while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
;;;2604       {
;;;2605         if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
00001a  f44f787a          MOV      r8,#0x3e8
;;;2606         {
;;;2607           status = HAL_TIMEOUT;
00001e  2703              MOVS     r7,#3
000020  e007              B        |L25.50|
                  |L25.34|
000022  f7fffffe          BL       HAL_GetTick
000026  1b80              SUBS     r0,r0,r6              ;2605
000028  4540              CMP      r0,r8                 ;2605
00002a  d902              BLS      |L25.50|
00002c  2503              MOVS     r5,#3
;;;2608           hrtc->State = HAL_RTC_STATE_TIMEOUT;
00002e  f8847021          STRB     r7,[r4,#0x21]
                  |L25.50|
000032  6820              LDR      r0,[r4,#0]            ;2603
000034  68c0              LDR      r0,[r0,#0xc]          ;2603
000036  0640              LSLS     r0,r0,#25             ;2603
000038  d401              BMI      |L25.62|
00003a  2d03              CMP      r5,#3                 ;2603
00003c  d1f1              BNE      |L25.34|
                  |L25.62|
;;;2609         }
;;;2610       }
;;;2611     }
;;;2612   #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2613   
;;;2614     return status;
00003e  4628              MOV      r0,r5
;;;2615   }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;2616   
                          ENDP


                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;2621     */
;;;2622   HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2623   {
000004  4605              MOV      r5,r0
;;;2624     HAL_StatusTypeDef status = HAL_OK;
000006  2400              MOVS     r4,#0
;;;2625   
;;;2626     /* Exit Initialization mode */
;;;2627   #if defined(STM32L412xx) || defined(STM32L422xx) || defined(STM32L4P5xx) || defined(STM32L4Q5xx)
;;;2628     CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
;;;2629   #else
;;;2630     /* Exit Initialization mode */
;;;2631     CLEAR_BIT(RTC->ISR, RTC_ISR_INIT);
000008  4812              LDR      r0,|L26.84|
00000a  6801              LDR      r1,[r0,#0]
00000c  f0210180          BIC      r1,r1,#0x80
000010  6001              STR      r1,[r0,#0]
;;;2632   #endif
;;;2633   
;;;2634     /* If CR_BYPSHAD bit = 0, wait for synchro */
;;;2635     if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
000012  1f06              SUBS     r6,r0,#4
000014  6830              LDR      r0,[r6,#0]
;;;2636     {
;;;2637       if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;2638       {
;;;2639         hrtc->State = HAL_RTC_STATE_TIMEOUT;
000016  f04f0703          MOV      r7,#3
00001a  0680              LSLS     r0,r0,#26             ;2635
00001c  d407              BMI      |L26.46|
00001e  4628              MOV      r0,r5                 ;2637
000020  f7fffffe          BL       HAL_RTC_WaitForSynchro
000024  b190              CBZ      r0,|L26.76|
000026  f8857021          STRB     r7,[r5,#0x21]
;;;2640         status = HAL_TIMEOUT;
00002a  2403              MOVS     r4,#3
00002c  e00e              B        |L26.76|
                  |L26.46|
;;;2641       }
;;;2642     }
;;;2643     else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry */
;;;2644     {
;;;2645       /* Clear BYPSHAD bit */
;;;2646       CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
00002e  6830              LDR      r0,[r6,#0]
000030  f0200020          BIC      r0,r0,#0x20
000034  6030              STR      r0,[r6,#0]
;;;2647       if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       HAL_RTC_WaitForSynchro
00003c  b110              CBZ      r0,|L26.68|
;;;2648       {
;;;2649         hrtc->State = HAL_RTC_STATE_TIMEOUT;
00003e  f8857021          STRB     r7,[r5,#0x21]
;;;2650         status = HAL_TIMEOUT;
000042  2403              MOVS     r4,#3
                  |L26.68|
;;;2651       }
;;;2652       /* Restore BYPSHAD bit */
;;;2653       SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
000044  6830              LDR      r0,[r6,#0]
000046  f0400020          ORR      r0,r0,#0x20
00004a  6030              STR      r0,[r6,#0]
                  |L26.76|
;;;2654     }
;;;2655   
;;;2656     return status;
00004c  4620              MOV      r0,r4
;;;2657   }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;2658   
                          ENDP

000052  0000              DCW      0x0000
                  |L26.84|
                          DCD      0x4000280c

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rtc_c_c7052556____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_rtc_c_c7052556____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rtc_c_c7052556____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_rtc_c_c7052556____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rtc_c_c7052556____RRX|
#line 694
|__asm___19_stm32l4xx_hal_rtc_c_c7052556____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
