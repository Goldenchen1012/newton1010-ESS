; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\appserialuartdavinci.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\appserialuartdavinci.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\AppCommunication\AppSerialUartDavinci.c]
                          THUMB

                          AREA ||i.DavinciUart_cb||, CODE, READONLY, ALIGN=2

                  DavinciUart_cb PROC
;;;80     
;;;81     void DavinciUart_cb(uart_evt_type p_evt){
000000  2800              CMP      r0,#0
000002  d103              BNE      |L1.12|
;;;82       switch(p_evt){
;;;83         case UART_DATA_READY:
;;;84           /* received data handle */
;;;85          Davinci_uart_rx_cnt++;
000004  4802              LDR      r0,|L1.16|
000006  8841              LDRH     r1,[r0,#2]  ; Davinci_uart_rx_cnt
000008  1c49              ADDS     r1,r1,#1
00000a  8041              STRH     r1,[r0,#2]
                  |L1.12|
;;;86         break;
;;;87         case UART_TX_EMPTY:
;;;88           /* Data transmission complete handle */
;;;89         break;
;;;90         case UART_COMMUNICATION_ERR:
;;;91           /* occurred during reception */
;;;92         break;
;;;93         case UART_BUFFER_FULL:
;;;94           /* occurred UART buffer full */
;;;95         break;    
;;;96         default:
;;;97         break;
;;;98       }
;;;99     }
00000c  4770              BX       lr
;;;100    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      ||.data||

                          AREA ||i.appSerialUartDavinciOpen||, CODE, READONLY, ALIGN=2

                  appSerialUartDavinciOpen PROC
;;;498    
;;;499    void appSerialUartDavinciOpen(void)
000000  b510              PUSH     {r4,lr}
;;;500    {
;;;501    	if(smp_uart_init(&mDavinci_uart, DavinciUart_cb)==SMP_SUCCESS){
000002  4905              LDR      r1,|L2.24|
000004  4805              LDR      r0,|L2.28|
000006  f7fffffe          BL       smp_uart_init
;;;502          //SMP_PRINT("smp uart initial success!\r\n");
;;;503    	 }else{
;;;504          //SMP_PRINT("smp uart initial fail!\r\n");
;;;505      	}  
;;;506    
;;;507      	LibSwTimerOpen(appSerialUartDavinciTimerHandler, 0);
00000a  e8bd4010          POP      {r4,lr}
00000e  2100              MOVS     r1,#0
000010  4803              LDR      r0,|L2.32|
000012  f7ffbffe          B.W      LibSwTimerOpen
;;;508    }
;;;509    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      DavinciUart_cb
                  |L2.28|
                          DCD      ||.data||+0x10
                  |L2.32|
                          DCD      appSerialUartDavinciTimerHandler

                          AREA ||i.appSerialUartDavinciTimerHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  appSerialUartDavinciTimerHandler PROC
;;;465      
;;;466    void appSerialUartDavinciTimerHandler(__far void *dest, uint16_t evt, void *vDataPtr)
000000  b500              PUSH     {lr}
;;;467    {
000002  b099              SUB      sp,sp,#0x64
;;;468    	static	uint8_t	count = 0;
;;;469    	
;;;470    	//GPIOD->ODR |= GPIO_PIN_14;
;;;471    //	if(ReportScuUartMessage)
;;;472    //		ReportScuUartMessage();
;;;473    	if(evt == LIB_SW_TIMER_EVT_SW_1MS)
000004  290a              CMP      r1,#0xa
000006  d014              BEQ      |L3.50|
;;;474    	{
;;;475    		
;;;476    	}
;;;477    	else if(evt == LIB_SW_TIMER_EVT_SW_10MS_3)
000008  2903              CMP      r1,#3
00000a  d112              BNE      |L3.50|
;;;478    	{
;;;479    		appSerialUartPackageJudgee();
00000c  f7fffffe          BL       appSerialUartPackageJudgee
;;;480    		
;;;481    		count++;
000010  4909              LDR      r1,|L3.56|
000012  7808              LDRB     r0,[r1,#0]  ; count
000014  1c40              ADDS     r0,r0,#1
000016  b2c0              UXTB     r0,r0
000018  7008              STRB     r0,[r1,#0]
;;;482    		if(count >= 100)	
00001a  2864              CMP      r0,#0x64
00001c  d309              BCC      |L3.50|
;;;483    		{
;;;484    			count = 0;
00001e  2000              MOVS     r0,#0
000020  7008              STRB     r0,[r1,#0]
;;;485    			SubIndex = 0;
000022  8088              STRH     r0,[r1,#4]
;;;486    //			ReportScuUartMessage = appSerialUartSendCellVoltage;
;;;487    //			GPIOC->ODR ^= GPIO_PIN_6;
;;;488    			{
;;;489    				static	uint8_t ccc=0;
;;;490    				char	str[100];			
;;;491    				sprintf(str,"Uart Brocast:%d",ccc++);
000024  784a              LDRB     r2,[r1,#1]  ; ccc
000026  1c50              ADDS     r0,r2,#1
000028  7048              STRB     r0,[r1,#1]
00002a  a104              ADR      r1,|L3.60|
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       __2sprintf
                  |L3.50|
;;;492    //				appSerialUartSendMessage(str);
;;;493    			}
;;;494    		}
;;;495    	}
;;;496    	//GPIOD->ODR &= ~GPIO_PIN_14;
;;;497    }
000032  b019              ADD      sp,sp,#0x64
000034  bd00              POP      {pc}
;;;498    
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      ||.data||
                  |L3.60|
00003c  55617274          DCB      "Uart Brocast:%d",0
000040  2042726f
000044  63617374
000048  3a256400

                          AREA ||i.appSerialUartPackageJudgee||, CODE, READONLY, ALIGN=2

                  appSerialUartPackageJudgee PROC
;;;423    
;;;424    static void appSerialUartPackageJudgee(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;425    {
;;;426    	uint8_t	i,ch;
;;;427    	
;;;428    	for(i=0; i<200; i++)
000002  2500              MOVS     r5,#0
;;;429    	{
;;;430    		 if(smp_uart_get(&mDavinci_uart, &ch) != SMP_SUCCESS)
;;;431    		 	break;
;;;432    		if(HvEssUartDecodeBuf.Status == 0)
000004  4c1b              LDR      r4,|L4.116|
000006  2600              MOVS     r6,#0                 ;428
                  |L4.8|
000008  4669              MOV      r1,sp                 ;430
00000a  481b              LDR      r0,|L4.120|
00000c  f7fffffe          BL       smp_uart_get
000010  2800              CMP      r0,#0                 ;430
000012  d10a              BNE      |L4.42|
000014  7820              LDRB     r0,[r4,#0]  ; HvEssUartDecodeBuf
000016  b148              CBZ      r0,|L4.44|
;;;433    		{
;;;434    			if(ch == 0x5A)
;;;435    			{
;;;436    				HvEssUartDecodeBuf.Status = 1;
;;;437    				HvEssUartDecodeBuf.Index = 0;
;;;438    				HvEssUartDecodeBuf.Checksum = 0;
;;;439    			}
;;;440    		}
;;;441    		else if(HvEssUartDecodeBuf.Status == 1)
000018  2801              CMP      r0,#1
00001a  d010              BEQ      |L4.62|
;;;442    		{
;;;443    			HvEssUartDecodeBuf.Checksum ^= ch;
;;;444    			HvEssUartDecodeBuf.Buffer[HvEssUartDecodeBuf.Index++] = ch;
;;;445    			if(HvEssUartDecodeBuf.Index >= HvEssUartDecodeBuf.Buffer[0])
;;;446    			{
;;;447    				HvEssUartDecodeBuf.Status = 2;
;;;448    			}
;;;449    		}
;;;450    		else if(HvEssUartDecodeBuf.Status == 2)
00001c  2802              CMP      r0,#2
00001e  d01f              BEQ      |L4.96|
;;;451    		{
;;;452    			if(ch==0x69 && HvEssUartDecodeBuf.Checksum==0)
;;;453    			{
;;;454    				appSerialUartPackageParser();
;;;455    				//appSerialUartSendMessage("Uart Brocast");		
;;;456    			}			
;;;457    			HvEssUartDecodeBuf.Status = 0;
;;;458    		}
;;;459    		else
;;;460    			HvEssUartDecodeBuf.Status = 0;
000020  7026              STRB     r6,[r4,#0]
                  |L4.34|
000022  1c6d              ADDS     r5,r5,#1              ;428
000024  b2ed              UXTB     r5,r5                 ;428
000026  2dc8              CMP      r5,#0xc8              ;428
000028  d3ee              BCC      |L4.8|
                  |L4.42|
;;;461    	}
;;;462    }
00002a  bdf8              POP      {r3-r7,pc}
                  |L4.44|
00002c  f89d0000          LDRB     r0,[sp,#0]            ;434
000030  285a              CMP      r0,#0x5a              ;434
000032  d1f6              BNE      |L4.34|
000034  2001              MOVS     r0,#1                 ;436
000036  7020              STRB     r0,[r4,#0]            ;436
000038  8066              STRH     r6,[r4,#2]            ;437
00003a  7126              STRB     r6,[r4,#4]            ;438
00003c  e7f1              B        |L4.34|
                  |L4.62|
00003e  7920              LDRB     r0,[r4,#4]            ;443  ; HvEssUartDecodeBuf
000040  f89d1000          LDRB     r1,[sp,#0]            ;443
000044  4048              EORS     r0,r0,r1              ;443
000046  7120              STRB     r0,[r4,#4]            ;443
000048  8860              LDRH     r0,[r4,#2]            ;444  ; HvEssUartDecodeBuf
00004a  1c42              ADDS     r2,r0,#1              ;444
00004c  4420              ADD      r0,r0,r4              ;444
00004e  8062              STRH     r2,[r4,#2]            ;444
000050  7141              STRB     r1,[r0,#5]            ;444
000052  8860              LDRH     r0,[r4,#2]            ;445  ; HvEssUartDecodeBuf
000054  7961              LDRB     r1,[r4,#5]            ;445  ; HvEssUartDecodeBuf
000056  4288              CMP      r0,r1                 ;445
000058  d3e3              BCC      |L4.34|
00005a  2002              MOVS     r0,#2                 ;447
00005c  7020              STRB     r0,[r4,#0]            ;447
00005e  e7e0              B        |L4.34|
                  |L4.96|
000060  f89d0000          LDRB     r0,[sp,#0]            ;452
000064  2869              CMP      r0,#0x69              ;452
000066  d103              BNE      |L4.112|
000068  7920              LDRB     r0,[r4,#4]            ;452  ; HvEssUartDecodeBuf
00006a  b908              CBNZ     r0,|L4.112|
00006c  f7fffffe          BL       appSerialUartPackageParser
                  |L4.112|
000070  7026              STRB     r6,[r4,#0]            ;457
000072  e7d6              B        |L4.34|
;;;463    /* Public function prototypes -----------------------------------------------*/
                          ENDP

                  |L4.116|
                          DCD      ||area_number.10||
                  |L4.120|
                          DCD      ||.data||+0x10

                          AREA ||i.appSerialUartPackageParser||, CODE, READONLY, ALIGN=2

                  appSerialUartPackageParser PROC
;;;366    
;;;367    static void appSerialUartPackageParser(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;368    {
;;;369    	uint8_t		cell,ntc;
;;;370    	uint8_t 	index;
;;;371    	tIbyte		CellVoltage;
;;;372    	static tLbyte		cur;
;;;373    	static int32_t		i32;
;;;374    	
;;;375    	if(HvEssUartDecodeBuf.Buffer[1] != 'U')
000002  4e36              LDR      r6,|L5.220|
000004  79b0              LDRB     r0,[r6,#6]  ; HvEssUartDecodeBuf
000006  2855              CMP      r0,#0x55
000008  d126              BNE      |L5.88|
;;;376    		return;
;;;377    	switch(HvEssUartDecodeBuf.Buffer[2])
00000a  79f0              LDRB     r0,[r6,#7]  ; HvEssUartDecodeBuf
00000c  2853              CMP      r0,#0x53
00000e  d123              BNE      |L5.88|
;;;378    	{
;;;379    	case 'S'://cimu
;;;380    		switch(HvEssUartDecodeBuf.Buffer[3])
000010  7a30              LDRB     r0,[r6,#8]  ; HvEssUartDecodeBuf
000012  2843              CMP      r0,#0x43
000014  d006              BEQ      |L5.36|
000016  2849              CMP      r0,#0x49
000018  d042              BEQ      |L5.160|
00001a  284e              CMP      r0,#0x4e
00001c  d11c              BNE      |L5.88|
;;;381    		{
;;;382    		case 'C':	//cell voltage
;;;383    			cell = 0;
;;;384    			for(index = 4; index<(HvEssUartDecodeBuf.Buffer[0]-1);)
;;;385    			{
;;;386    				CellVoltage.b[0] = HvEssUartDecodeBuf.Buffer[index++];
;;;387    				CellVoltage.b[1] = HvEssUartDecodeBuf.Buffer[index++];
;;;388    				halAfeSetCellVoltage(cell++, CellVoltage.i);				
;;;389    			}
;;;390    			break;
;;;391    		case 'N':	//ntc
;;;392    			ntc = 0;
00001e  2500              MOVS     r5,#0
;;;393    			for(index = 4; index<(HvEssUartDecodeBuf.Buffer[0]-1);)
000020  2404              MOVS     r4,#4
000022  e038              B        |L5.150|
                  |L5.36|
000024  2500              MOVS     r5,#0                 ;383
000026  2404              MOVS     r4,#4                 ;384
000028  e012              B        |L5.80|
                  |L5.42|
00002a  1c60              ADDS     r0,r4,#1              ;386
00002c  19a1              ADDS     r1,r4,r6              ;386
00002e  b2c0              UXTB     r0,r0                 ;386
000030  7949              LDRB     r1,[r1,#5]            ;386
000032  f88d1000          STRB     r1,[sp,#0]            ;386
000036  1c41              ADDS     r1,r0,#1              ;387
000038  4430              ADD      r0,r0,r6              ;387
00003a  b2cc              UXTB     r4,r1                 ;387
00003c  7940              LDRB     r0,[r0,#5]            ;387
00003e  f88d0001          STRB     r0,[sp,#1]            ;387
000042  4628              MOV      r0,r5                 ;388
000044  1c6d              ADDS     r5,r5,#1              ;388
000046  f8bd1000          LDRH     r1,[sp,#0]            ;388
00004a  b2ed              UXTB     r5,r5                 ;388
00004c  f7fffffe          BL       halAfeSetCellVoltage
                  |L5.80|
000050  7970              LDRB     r0,[r6,#5]            ;384  ; HvEssUartDecodeBuf
000052  1e40              SUBS     r0,r0,#1              ;384
000054  42a0              CMP      r0,r4                 ;384
000056  dce8              BGT      |L5.42|
                  |L5.88|
;;;394    			{
;;;395    				CellVoltage.b[0] = HvEssUartDecodeBuf.Buffer[index++];
;;;396    				CellVoltage.b[1] = HvEssUartDecodeBuf.Buffer[index++];
;;;397    				
;;;398    				CellVoltage.i /= 100;
;;;399    				CellVoltage.i = LibTemperatureToVoltage(CellVoltage.i);
;;;400    				
;;;401    				halAfeSetNtcAdcData(ntc++, CellVoltage.i);				
;;;402    			}
;;;403    			break;
;;;404    		case 'I':	//current
;;;405    			index = 4;
;;;406    			cur.b[0] = HvEssUartDecodeBuf.Buffer[index++];
;;;407    			cur.b[1] = HvEssUartDecodeBuf.Buffer[index++];
;;;408    			cur.b[2] = HvEssUartDecodeBuf.Buffer[index++];
;;;409    			cur.b[3] = HvEssUartDecodeBuf.Buffer[index++];
;;;410    			
;;;411    			i32 = (LONG)(cur.l&0xfffffffL);
;;;412    			if(cur.b[3] & 0x80L)		//charge 
;;;413    			{
;;;414    				i32 *= -1;
;;;415    			}
;;;416    			HalAfeSetCurrentValue(0, i32);
;;;417    
;;;418    			break;
;;;419    		}
;;;420    		break;		
;;;421    	}
;;;422    }
000058  bdf8              POP      {r3-r7,pc}
                  |L5.90|
00005a  1c60              ADDS     r0,r4,#1              ;395
00005c  19a1              ADDS     r1,r4,r6              ;395
00005e  b2c0              UXTB     r0,r0                 ;395
000060  7949              LDRB     r1,[r1,#5]            ;395
000062  f88d1000          STRB     r1,[sp,#0]            ;395
000066  1c41              ADDS     r1,r0,#1              ;396
000068  4430              ADD      r0,r0,r6              ;396
00006a  b2cc              UXTB     r4,r1                 ;396
00006c  7940              LDRB     r0,[r0,#5]            ;396
00006e  f88d0001          STRB     r0,[sp,#1]            ;396
000072  f8bd0000          LDRH     r0,[sp,#0]            ;398
000076  2164              MOVS     r1,#0x64              ;398
000078  fbb0f0f1          UDIV     r0,r0,r1              ;398
00007c  9000              STR      r0,[sp,#0]            ;398
00007e  f9bd0000          LDRSH    r0,[sp,#0]            ;399
000082  f7fffffe          BL       LibTemperatureToVoltage
000086  9000              STR      r0,[sp,#0]            ;399
000088  462a              MOV      r2,r5                 ;401
00008a  1c6d              ADDS     r5,r5,#1              ;401
00008c  4601              MOV      r1,r0                 ;401
00008e  b2ed              UXTB     r5,r5                 ;401
000090  4610              MOV      r0,r2                 ;401
000092  f7fffffe          BL       halAfeSetNtcAdcData
                  |L5.150|
000096  7970              LDRB     r0,[r6,#5]            ;393  ; HvEssUartDecodeBuf
000098  1e40              SUBS     r0,r0,#1              ;393
00009a  42a0              CMP      r0,r4                 ;393
00009c  dcdd              BGT      |L5.90|
00009e  bdf8              POP      {r3-r7,pc}
                  |L5.160|
0000a0  480e              LDR      r0,|L5.220|
0000a2  7a41              LDRB     r1,[r0,#9]            ;406
0000a4  480e              LDR      r0,|L5.224|
0000a6  7001              STRB     r1,[r0,#0]            ;406
0000a8  490c              LDR      r1,|L5.220|
0000aa  7a89              LDRB     r1,[r1,#0xa]          ;407
0000ac  7041              STRB     r1,[r0,#1]            ;407
0000ae  490b              LDR      r1,|L5.220|
0000b0  7ac9              LDRB     r1,[r1,#0xb]          ;408
0000b2  7081              STRB     r1,[r0,#2]            ;408
0000b4  4909              LDR      r1,|L5.220|
0000b6  7b09              LDRB     r1,[r1,#0xc]          ;409
0000b8  70c1              STRB     r1,[r0,#3]            ;409
0000ba  4a09              LDR      r2,|L5.224|
0000bc  6800              LDR      r0,[r0,#0]            ;411  ; cur
0000be  3a08              SUBS     r2,r2,#8              ;411
0000c0  f0204070          BIC      r0,r0,#0xf0000000     ;411
0000c4  60d0              STR      r0,[r2,#0xc]          ;411  ; i32
0000c6  0609              LSLS     r1,r1,#24             ;412
0000c8  d501              BPL      |L5.206|
0000ca  4240              RSBS     r0,r0,#0              ;414
0000cc  60d0              STR      r0,[r2,#0xc]          ;414  ; i32
                  |L5.206|
0000ce  68d1              LDR      r1,[r2,#0xc]          ;416  ; i32
0000d0  e8bd40f8          POP      {r3-r7,lr}            ;416
0000d4  2000              MOVS     r0,#0                 ;416
0000d6  f7ffbffe          B.W      HalAfeSetCurrentValue
;;;423    
                          ENDP

0000da  0000              DCW      0x0000
                  |L5.220|
                          DCD      ||area_number.10||
                  |L5.224|
                          DCD      ||.data||+0x8

                          AREA ||i.appSerialUartSendMessage||, CODE, READONLY, ALIGN=2

                  appSerialUartSendMessage PROC
;;;341    
;;;342    void appSerialUartSendMessage(uint8_t *str)
000000  b5f0              PUSH     {r4-r7,lr}
;;;343    {
000002  b0c1              SUB      sp,sp,#0x104
000004  4607              MOV      r7,r0
;;;344    	BYTE	buffer[256];
;;;345    	BYTE	i,len,checksum,index;
;;;346    	
;;;347    	len = strlen((char *)str);
000006  4638              MOV      r0,r7
000008  f7fffffe          BL       strlen
00000c  b2c5              UXTB     r5,r0
;;;348    	buffer[0] = 0x5A;
00000e  205a              MOVS     r0,#0x5a
000010  f88d0004          STRB     r0,[sp,#4]
;;;349    	buffer[1] = len+4;
000014  1d28              ADDS     r0,r5,#4
000016  b2c0              UXTB     r0,r0
000018  f88d0005          STRB     r0,[sp,#5]
;;;350    	buffer[2] = 'T';
00001c  2154              MOVS     r1,#0x54
00001e  f88d1006          STRB     r1,[sp,#6]
;;;351    	checksum = 'T';
;;;352    	checksum ^= buffer[1];
000022  f0800354          EOR      r3,r0,#0x54
;;;353    	index = 3;
000026  2103              MOVS     r1,#3
;;;354    	for(i=0;i<len;i++)
000028  2200              MOVS     r2,#0
00002a  ae01              ADD      r6,sp,#4              ;344
00002c  e007              B        |L6.62|
                  |L6.46|
;;;355    	{
;;;356    		buffer[index++]=str[i];
00002e  4608              MOV      r0,r1
000030  5cbc              LDRB     r4,[r7,r2]
000032  1c49              ADDS     r1,r1,#1
000034  b2c9              UXTB     r1,r1
000036  5434              STRB     r4,[r6,r0]
;;;357    		checksum^=str[i];
000038  4063              EORS     r3,r3,r4
00003a  1c52              ADDS     r2,r2,#1              ;354
00003c  b2d2              UXTB     r2,r2                 ;354
                  |L6.62|
00003e  42aa              CMP      r2,r5                 ;354
000040  d3f5              BCC      |L6.46|
;;;358    	}
;;;359    	buffer[index++]=0;
000042  2200              MOVS     r2,#0
000044  1c48              ADDS     r0,r1,#1
000046  b2c0              UXTB     r0,r0
000048  5472              STRB     r2,[r6,r1]
;;;360    	buffer[index++]=checksum;
00004a  1c41              ADDS     r1,r0,#1
00004c  b2c9              UXTB     r1,r1
00004e  5433              STRB     r3,[r6,r0]
;;;361    	buffer[index++]=0x69;
000050  2269              MOVS     r2,#0x69
000052  1c48              ADDS     r0,r1,#1
000054  b2c5              UXTB     r5,r0
000056  5472              STRB     r2,[r6,r1]
;;;362    	
;;;363    	for(i=0; i<index; i++)
000058  2400              MOVS     r4,#0
00005a  e005              B        |L6.104|
                  |L6.92|
;;;364    		smp_uart_put(&mDavinci_uart, buffer[i]);
00005c  5d31              LDRB     r1,[r6,r4]
00005e  4804              LDR      r0,|L6.112|
000060  f7fffffe          BL       smp_uart_put
000064  1c64              ADDS     r4,r4,#1              ;363
000066  b2e4              UXTB     r4,r4                 ;363
                  |L6.104|
000068  42ac              CMP      r4,r5                 ;363
00006a  d3f7              BCC      |L6.92|
;;;365    }
00006c  b041              ADD      sp,sp,#0x104
00006e  bdf0              POP      {r4-r7,pc}
;;;366    
                          ENDP

                  |L6.112|
                          DCD      ||.data||+0x10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  Davinci_uart_tx_buffer
                          %        2000

                          AREA ||area_number.9||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.9||, ||.bss||
                  Davinci_uart_rx_buffer
                          %        500

                          AREA ||area_number.10||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.bss||
                  HvEssUartDecodeBuf
                          %        306

                          AREA ||.data||, DATA, ALIGN=2

                  count
000000  00                DCB      0x00
                  ||ccc||
000001  00                DCB      0x00
                  Davinci_uart_rx_cnt
000002  0000              DCW      0x0000
                  SubIndex
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  ||cur||
                          DCD      0x00000000
                  i32
                          DCD      0x00000000
                  mDavinci_uart
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x0001c200
000018  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      Davinci_uart_rx_buffer
                          DCD      0x000007d0
                          DCD      Davinci_uart_tx_buffer
                          DCD      0x000001f4

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  ReportScuUartMessage
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\AppCommunication\\AppSerialUartDavinci.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_AppSerialUartDavinci_c_286ab4e6____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_AppSerialUartDavinci_c_286ab4e6____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_AppSerialUartDavinci_c_286ab4e6____REVSH|
#line 507
|__asm___22_AppSerialUartDavinci_c_286ab4e6____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_AppSerialUartDavinci_c_286ab4e6____RRX|
#line 694
|__asm___22_AppSerialUartDavinci_c_286ab4e6____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
