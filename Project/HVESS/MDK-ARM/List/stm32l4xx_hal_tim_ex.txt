; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_tim_ex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_tim_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_Break2Callback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_Break2Callback PROC
;;;2534     */
;;;2535   __weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2536   {
;;;2537     /* Prevent unused argument(s) compilation warning */
;;;2538     UNUSED(htim);
;;;2539   
;;;2540     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2541               the HAL_TIMEx_Break2Callback could be implemented in the user file
;;;2542      */
;;;2543   }
;;;2544   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;2519     */
;;;2520   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2521   {
;;;2522     /* Prevent unused argument(s) compilation warning */
;;;2523     UNUSED(htim);
;;;2524   
;;;2525     /* NOTE : This function should not be modified, when the callback is needed,
;;;2526               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;2527      */
;;;2528   }
;;;2529   
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutCallback PROC
;;;2490     */
;;;2491   __weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2492   {
;;;2493     /* Prevent unused argument(s) compilation warning */
;;;2494     UNUSED(htim);
;;;2495   
;;;2496     /* NOTE : This function should not be modified, when the callback is needed,
;;;2497               the HAL_TIMEx_CommutCallback could be implemented in the user file
;;;2498      */
;;;2499   }
;;;2500   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutHalfCpltCallback PROC
;;;2504     */
;;;2505   __weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2506   {
;;;2507     /* Prevent unused argument(s) compilation warning */
;;;2508     UNUSED(htim);
;;;2509   
;;;2510     /* NOTE : This function should not be modified, when the callback is needed,
;;;2511               the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file
;;;2512      */
;;;2513   }
;;;2514   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1979     */
;;;1980   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
000000  b530              PUSH     {r4,r5,lr}
;;;1981                                                   TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
;;;1982   {
;;;1983     /* Keep this variable initialized to 0 as it is used to configure BDTR register */
;;;1984     uint32_t tmpbdtr = 0U;
;;;1985   
;;;1986     /* Check the parameters */
;;;1987     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1988     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1989     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1990     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1991     assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
;;;1992     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1993     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1994     assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
;;;1995     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1996   
;;;1997     /* Check input state */
;;;1998     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d03a              BEQ      |L5.128|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;1999   
;;;2000     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2001        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2002   
;;;2003     /* Set the BDTR bits */
;;;2004     MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
000010  68ca              LDR      r2,[r1,#0xc]
000012  2400              MOVS     r4,#0
;;;2005     MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
000014  688b              LDR      r3,[r1,#8]
000016  f4227240          BIC      r2,r2,#0x300
00001a  431a              ORRS     r2,r2,r3
;;;2006     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
00001c  684b              LDR      r3,[r1,#4]
00001e  f4226280          BIC      r2,r2,#0x400
000022  431a              ORRS     r2,r2,r3
;;;2007     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
000024  680b              LDR      r3,[r1,#0]
000026  f4226200          BIC      r2,r2,#0x800
00002a  431a              ORRS     r2,r2,r3
;;;2008     MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
00002c  690b              LDR      r3,[r1,#0x10]
00002e  f4225280          BIC      r2,r2,#0x1000
000032  431a              ORRS     r2,r2,r3
;;;2009     MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
000034  694b              LDR      r3,[r1,#0x14]
000036  f4225200          BIC      r2,r2,#0x2000
00003a  431a              ORRS     r2,r2,r3
;;;2010     MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
00003c  6a8b              LDR      r3,[r1,#0x28]
00003e  f4224280          BIC      r2,r2,#0x4000
000042  431a              ORRS     r2,r2,r3
;;;2011     MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
000044  8b0b              LDRH     r3,[r1,#0x18]
000046  f4222270          BIC      r2,r2,#0xf0000
00004a  ea424203          ORR      r2,r2,r3,LSL #16
;;;2012   
;;;2013     if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
00004e  4d0d              LDR      r5,|L5.132|
000050  6803              LDR      r3,[r0,#0]
000052  42ab              CMP      r3,r5
000054  d002              BEQ      |L5.92|
000056  4d0c              LDR      r5,|L5.136|
000058  42ab              CMP      r3,r5
00005a  d10c              BNE      |L5.118|
                  |L5.92|
;;;2014     {
;;;2015       /* Check the parameters */
;;;2016       assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
;;;2017       assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
;;;2018       assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
;;;2019   
;;;2020       /* Set the BREAK2 input related BDTR bits */
;;;2021       MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
00005c  8c8d              LDRH     r5,[r1,#0x24]
00005e  f4220270          BIC      r2,r2,#0xf00000
000062  ea425205          ORR      r2,r2,r5,LSL #20
;;;2022       MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
000066  69cd              LDR      r5,[r1,#0x1c]
000068  f0227280          BIC      r2,r2,#0x1000000
00006c  432a              ORRS     r2,r2,r5
;;;2023       MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
00006e  6a09              LDR      r1,[r1,#0x20]
000070  f0227200          BIC      r2,r2,#0x2000000
000074  430a              ORRS     r2,r2,r1
                  |L5.118|
;;;2024     }
;;;2025   
;;;2026     /* Set TIMx_BDTR */
;;;2027     htim->Instance->BDTR = tmpbdtr;
000076  645a              STR      r2,[r3,#0x44]
;;;2028   
;;;2029     __HAL_UNLOCK(htim);
000078  f880403c          STRB     r4,[r0,#0x3c]
;;;2030   
;;;2031     return HAL_OK;
00007c  2000              MOVS     r0,#0
;;;2032   }
00007e  bd30              POP      {r4,r5,pc}
                  |L5.128|
000080  2002              MOVS     r0,#2                 ;1998
000082  bd30              POP      {r4,r5,pc}
;;;2033   
                          ENDP

                  |L5.132|
                          DCD      0x40012c00
                  |L5.136|
                          DCD      0x40013400

                          AREA ||i.HAL_TIMEx_ConfigBreakInput||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakInput PROC
;;;2043     */
;;;2044   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2045                                                uint32_t BreakInput,
;;;2046                                                TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)
;;;2047   
;;;2048   {
;;;2049     uint32_t tmporx;
;;;2050     uint32_t bkin_enable_mask;
;;;2051     uint32_t bkin_polarity_mask;
;;;2052     uint32_t bkin_enable_bitpos;
;;;2053     uint32_t bkin_polarity_bitpos;
;;;2054   
;;;2055     /* Check the parameters */
;;;2056     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;2057     assert_param(IS_TIM_BREAKINPUT(BreakInput));
;;;2058     assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));
;;;2059     assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));
;;;2060   #if defined(DFSDM1_Channel0)
;;;2061     if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
000004  6813              LDR      r3,[r2,#0]
;;;2062     {
;;;2063       assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));
;;;2064     }
;;;2065   #else
;;;2066     assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));
;;;2067   #endif /* DFSDM1_Channel0 */
;;;2068   
;;;2069     /* Check input state */
;;;2070     __HAL_LOCK(htim);
000006  f890303c          LDRB     r3,[r0,#0x3c]
00000a  2b01              CMP      r3,#1
00000c  d014              BEQ      |L6.56|
00000e  2301              MOVS     r3,#1
000010  f880303c          STRB     r3,[r0,#0x3c]
;;;2071   
;;;2072     switch (sBreakInputConfig->Source)
000014  6817              LDR      r7,[r2,#0]
000016  2f01              CMP      r7,#1
000018  d011              BEQ      |L6.62|
00001a  2f02              CMP      r7,#2
00001c  d014              BEQ      |L6.72|
00001e  2f04              CMP      r7,#4
000020  d017              BEQ      |L6.82|
000022  2f08              CMP      r7,#8
000024  d01a              BEQ      |L6.92|
;;;2073     {
;;;2074       case TIM_BREAKINPUTSOURCE_BKIN:
;;;2075       {
;;;2076         bkin_enable_mask = TIM1_OR2_BKINE;
;;;2077         bkin_enable_bitpos = TIM1_OR2_BKINE_Pos;
;;;2078         bkin_polarity_mask = TIM1_OR2_BKINP;
;;;2079         bkin_polarity_bitpos = TIM1_OR2_BKINP_Pos;
;;;2080         break;
;;;2081       }
;;;2082       case TIM_BREAKINPUTSOURCE_COMP1:
;;;2083       {
;;;2084         bkin_enable_mask = TIM1_OR2_BKCMP1E;
;;;2085         bkin_enable_bitpos = TIM1_OR2_BKCMP1E_Pos;
;;;2086         bkin_polarity_mask = TIM1_OR2_BKCMP1P;
;;;2087         bkin_polarity_bitpos = TIM1_OR2_BKCMP1P_Pos;
;;;2088         break;
;;;2089       }
;;;2090       case TIM_BREAKINPUTSOURCE_COMP2:
;;;2091       {
;;;2092         bkin_enable_mask = TIM1_OR2_BKCMP2E;
;;;2093         bkin_enable_bitpos = TIM1_OR2_BKCMP2E_Pos;
;;;2094         bkin_polarity_mask = TIM1_OR2_BKCMP2P;
;;;2095         bkin_polarity_bitpos = TIM1_OR2_BKCMP2P_Pos;
;;;2096         break;
;;;2097       }
;;;2098   #if defined(DFSDM1_Channel0)
;;;2099       case TIM_BREAKINPUTSOURCE_DFSDM1:
;;;2100       {
;;;2101         bkin_enable_mask = TIM1_OR2_BKDF1BK0E;
;;;2102         bkin_enable_bitpos = 8U;
;;;2103         bkin_polarity_mask = 0U;
;;;2104         bkin_polarity_bitpos = 0U;
;;;2105         break;
;;;2106       }
;;;2107   #endif /* DFSDM1_Channel0 */
;;;2108   
;;;2109       default:
;;;2110       {
;;;2111         bkin_enable_mask = 0U;
000026  2300              MOVS     r3,#0
;;;2112         bkin_polarity_mask = 0U;
000028  2400              MOVS     r4,#0
;;;2113         bkin_enable_bitpos = 0U;
00002a  2600              MOVS     r6,#0
;;;2114         bkin_polarity_bitpos = 0U;
00002c  2500              MOVS     r5,#0
                  |L6.46|
;;;2115         break;
;;;2116       }
;;;2117     }
;;;2118   
;;;2119     switch (BreakInput)
00002e  2901              CMP      r1,#1
000030  d01a              BEQ      |L6.104|
000032  2902              CMP      r1,#2
000034  d142              BNE      |L6.188|
000036  e02c              B        |L6.146|
                  |L6.56|
000038  2002              MOVS     r0,#2                 ;2070
                  |L6.58|
;;;2120     {
;;;2121       case TIM_BREAKINPUT_BRK:
;;;2122       {
;;;2123         /* Get the TIMx_OR2 register value */
;;;2124         tmporx = htim->Instance->OR2;
;;;2125   
;;;2126         /* Enable the break input */
;;;2127         tmporx &= ~bkin_enable_mask;
;;;2128         tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
;;;2129   
;;;2130         /* Set the break input polarity */
;;;2131   #if defined(DFSDM1_Channel0)
;;;2132         if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
;;;2133   #endif /* DFSDM1_Channel0 */
;;;2134           {
;;;2135             tmporx &= ~bkin_polarity_mask;
;;;2136             tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
;;;2137           }
;;;2138   
;;;2139         /* Set TIMx_OR2 */
;;;2140         htim->Instance->OR2 = tmporx;
;;;2141         break;
;;;2142       }
;;;2143       case TIM_BREAKINPUT_BRK2:
;;;2144       {
;;;2145         /* Get the TIMx_OR3 register value */
;;;2146         tmporx = htim->Instance->OR3;
;;;2147   
;;;2148         /* Enable the break input */
;;;2149         tmporx &= ~bkin_enable_mask;
;;;2150         tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
;;;2151   
;;;2152         /* Set the break input polarity */
;;;2153   #if defined(DFSDM1_Channel0)
;;;2154         if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
;;;2155   #endif /* DFSDM1_Channel0 */
;;;2156           {
;;;2157             tmporx &= ~bkin_polarity_mask;
;;;2158             tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
;;;2159           }
;;;2160   
;;;2161         /* Set TIMx_OR3 */
;;;2162         htim->Instance->OR3 = tmporx;
;;;2163         break;
;;;2164       }
;;;2165       default:
;;;2166         break;
;;;2167     }
;;;2168   
;;;2169     __HAL_UNLOCK(htim);
;;;2170   
;;;2171     return HAL_OK;
;;;2172   }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.62|
00003e  2301              MOVS     r3,#1                 ;2076
000040  2600              MOVS     r6,#0                 ;2077
000042  025c              LSLS     r4,r3,#9              ;2078
000044  2509              MOVS     r5,#9                 ;2079
000046  e7f2              B        |L6.46|
                  |L6.72|
000048  2302              MOVS     r3,#2                 ;2084
00004a  2601              MOVS     r6,#1                 ;2085
00004c  025c              LSLS     r4,r3,#9              ;2086
00004e  250a              MOVS     r5,#0xa               ;2087
000050  e7ed              B        |L6.46|
                  |L6.82|
000052  2304              MOVS     r3,#4                 ;2092
000054  2602              MOVS     r6,#2                 ;2093
000056  025c              LSLS     r4,r3,#9              ;2094
000058  250b              MOVS     r5,#0xb               ;2095
00005a  e7e8              B        |L6.46|
                  |L6.92|
00005c  f44f7380          MOV      r3,#0x100             ;2101
000060  2608              MOVS     r6,#8                 ;2102
000062  2400              MOVS     r4,#0                 ;2103
000064  2500              MOVS     r5,#0                 ;2104
000066  e7e2              B        |L6.46|
                  |L6.104|
000068  f8d0c000          LDR      r12,[r0,#0]           ;2124
00006c  f8dc8060          LDR      r8,[r12,#0x60]        ;2124
000070  ea280803          BIC      r8,r8,r3              ;2127
000074  6851              LDR      r1,[r2,#4]            ;2128
000076  40b1              LSLS     r1,r1,r6              ;2128
000078  4019              ANDS     r1,r1,r3              ;2128
00007a  ea410108          ORR      r1,r1,r8              ;2128
00007e  2f08              CMP      r7,#8                 ;2132
000080  d004              BEQ      |L6.140|
000082  43a1              BICS     r1,r1,r4              ;2135
000084  6892              LDR      r2,[r2,#8]            ;2136
000086  40aa              LSLS     r2,r2,r5              ;2136
000088  4022              ANDS     r2,r2,r4              ;2136
00008a  4311              ORRS     r1,r1,r2              ;2136
                  |L6.140|
00008c  f8cc1060          STR      r1,[r12,#0x60]        ;2140
000090  e014              B        |L6.188|
                  |L6.146|
000092  f8d0c000          LDR      r12,[r0,#0]           ;2146
000096  f8dc8064          LDR      r8,[r12,#0x64]        ;2146
00009a  ea280803          BIC      r8,r8,r3              ;2149
00009e  6851              LDR      r1,[r2,#4]            ;2150
0000a0  40b1              LSLS     r1,r1,r6              ;2150
0000a2  4019              ANDS     r1,r1,r3              ;2150
0000a4  ea410108          ORR      r1,r1,r8              ;2150
0000a8  2f08              CMP      r7,#8                 ;2154
0000aa  d005              BEQ      |L6.184|
0000ac  ea210304          BIC      r3,r1,r4              ;2157
0000b0  6891              LDR      r1,[r2,#8]            ;2158
0000b2  40a9              LSLS     r1,r1,r5              ;2158
0000b4  4021              ANDS     r1,r1,r4              ;2158
0000b6  4319              ORRS     r1,r1,r3              ;2158
                  |L6.184|
0000b8  f8cc1064          STR      r1,[r12,#0x64]        ;2162
                  |L6.188|
0000bc  2100              MOVS     r1,#0                 ;2169
0000be  f880103c          STRB     r1,[r0,#0x3c]         ;2169
0000c2  2000              MOVS     r0,#0                 ;2171
0000c4  e7b9              B        |L6.58|
;;;2173   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutEvent PROC
;;;1744     */
;;;1745   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
000000  b510              PUSH     {r4,lr}
;;;1746                                                 uint32_t  CommutationSource)
;;;1747   {
;;;1748     /* Check the parameters */
;;;1749     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1750     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1751   
;;;1752     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L7.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L7.36|
;;;1753   
;;;1754     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L7.36|
;;;1755         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L7.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L7.36|
00001e  e00a              B        |L7.54|
                  |L7.32|
000020  2002              MOVS     r0,#2                 ;1752
;;;1756     {
;;;1757       /* Select the Input trigger */
;;;1758       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1759       htim->Instance->SMCR |= InputTrigger;
;;;1760     }
;;;1761   
;;;1762     /* Select the Capture Compare preload feature */
;;;1763     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1764     /* Select the Commutation event source */
;;;1765     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1766     htim->Instance->CR2 |= CommutationSource;
;;;1767   
;;;1768     /* Disable Commutation Interrupt */
;;;1769     __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
;;;1770   
;;;1771     /* Disable Commutation DMA request */
;;;1772     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
;;;1773   
;;;1774     __HAL_UNLOCK(htim);
;;;1775   
;;;1776     return HAL_OK;
;;;1777   }
000022  bd10              POP      {r4,pc}
                  |L7.36|
000024  6803              LDR      r3,[r0,#0]            ;1758
000026  689c              LDR      r4,[r3,#8]            ;1758
000028  f0240470          BIC      r4,r4,#0x70           ;1758
00002c  609c              STR      r4,[r3,#8]            ;1758
00002e  6803              LDR      r3,[r0,#0]            ;1759
000030  689c              LDR      r4,[r3,#8]            ;1759
000032  430c              ORRS     r4,r4,r1              ;1759
000034  609c              STR      r4,[r3,#8]            ;1759
                  |L7.54|
000036  6801              LDR      r1,[r0,#0]            ;1763
000038  684b              LDR      r3,[r1,#4]            ;1763
00003a  f0430301          ORR      r3,r3,#1              ;1763
00003e  604b              STR      r3,[r1,#4]            ;1763
000040  6801              LDR      r1,[r0,#0]            ;1765
000042  684b              LDR      r3,[r1,#4]            ;1765
000044  f0230304          BIC      r3,r3,#4              ;1765
000048  604b              STR      r3,[r1,#4]            ;1765
00004a  6801              LDR      r1,[r0,#0]            ;1766
00004c  684b              LDR      r3,[r1,#4]            ;1766
00004e  4313              ORRS     r3,r3,r2              ;1766
000050  604b              STR      r3,[r1,#4]            ;1766
000052  6801              LDR      r1,[r0,#0]            ;1769
000054  68ca              LDR      r2,[r1,#0xc]          ;1769
000056  f0220220          BIC      r2,r2,#0x20           ;1769
00005a  60ca              STR      r2,[r1,#0xc]          ;1769
00005c  6801              LDR      r1,[r0,#0]            ;1772
00005e  68ca              LDR      r2,[r1,#0xc]          ;1772
000060  f4225200          BIC      r2,r2,#0x2000         ;1772
000064  60ca              STR      r2,[r1,#0xc]          ;1772
000066  2100              MOVS     r1,#0                 ;1774
000068  f880103c          STRB     r1,[r0,#0x3c]         ;1774
00006c  2000              MOVS     r0,#0                 ;1776
00006e  bd10              POP      {r4,pc}
;;;1778   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutEvent_DMA PROC
;;;1857     */
;;;1858   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
000000  b510              PUSH     {r4,lr}
;;;1859                                                     uint32_t  CommutationSource)
;;;1860   {
;;;1861     /* Check the parameters */
;;;1862     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1863     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1864   
;;;1865     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L8.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L8.36|
;;;1866   
;;;1867     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L8.36|
;;;1868         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L8.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L8.36|
00001e  e00a              B        |L8.54|
                  |L8.32|
000020  2002              MOVS     r0,#2                 ;1865
;;;1869     {
;;;1870       /* Select the Input trigger */
;;;1871       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1872       htim->Instance->SMCR |= InputTrigger;
;;;1873     }
;;;1874   
;;;1875     /* Select the Capture Compare preload feature */
;;;1876     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1877     /* Select the Commutation event source */
;;;1878     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1879     htim->Instance->CR2 |= CommutationSource;
;;;1880   
;;;1881     /* Enable the Commutation DMA Request */
;;;1882     /* Set the DMA Commutation Callback */
;;;1883     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;1884     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
;;;1885     /* Set the DMA error callback */
;;;1886     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
;;;1887   
;;;1888     /* Disable Commutation Interrupt */
;;;1889     __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
;;;1890   
;;;1891     /* Enable the Commutation DMA Request */
;;;1892     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1893   
;;;1894     __HAL_UNLOCK(htim);
;;;1895   
;;;1896     return HAL_OK;
;;;1897   }
000022  bd10              POP      {r4,pc}
                  |L8.36|
000024  6803              LDR      r3,[r0,#0]            ;1871
000026  689c              LDR      r4,[r3,#8]            ;1871
000028  f0240470          BIC      r4,r4,#0x70           ;1871
00002c  609c              STR      r4,[r3,#8]            ;1871
00002e  6803              LDR      r3,[r0,#0]            ;1872
000030  689c              LDR      r4,[r3,#8]            ;1872
000032  430c              ORRS     r4,r4,r1              ;1872
000034  609c              STR      r4,[r3,#8]            ;1872
                  |L8.54|
000036  6801              LDR      r1,[r0,#0]            ;1876
000038  684b              LDR      r3,[r1,#4]            ;1876
00003a  f0430301          ORR      r3,r3,#1              ;1876
00003e  604b              STR      r3,[r1,#4]            ;1876
000040  6801              LDR      r1,[r0,#0]            ;1878
000042  684b              LDR      r3,[r1,#4]            ;1878
000044  f0230304          BIC      r3,r3,#4              ;1878
000048  604b              STR      r3,[r1,#4]            ;1878
00004a  6801              LDR      r1,[r0,#0]            ;1879
00004c  684b              LDR      r3,[r1,#4]            ;1879
00004e  4313              ORRS     r3,r3,r2              ;1879
000050  604b              STR      r3,[r1,#4]            ;1879
000052  6b42              LDR      r2,[r0,#0x34]         ;1883
000054  490b              LDR      r1,|L8.132|
000056  62d1              STR      r1,[r2,#0x2c]         ;1883
000058  6b42              LDR      r2,[r0,#0x34]         ;1884
00005a  490b              LDR      r1,|L8.136|
00005c  6311              STR      r1,[r2,#0x30]         ;1884
00005e  6b42              LDR      r2,[r0,#0x34]         ;1886
000060  490a              LDR      r1,|L8.140|
000062  6351              STR      r1,[r2,#0x34]         ;1886
000064  6801              LDR      r1,[r0,#0]            ;1889
000066  68ca              LDR      r2,[r1,#0xc]          ;1889
000068  f0220220          BIC      r2,r2,#0x20           ;1889
00006c  60ca              STR      r2,[r1,#0xc]          ;1889
00006e  6801              LDR      r1,[r0,#0]            ;1892
000070  68ca              LDR      r2,[r1,#0xc]          ;1892
000072  f4425200          ORR      r2,r2,#0x2000         ;1892
000076  60ca              STR      r2,[r1,#0xc]          ;1892
000078  2100              MOVS     r1,#0                 ;1894
00007a  f880103c          STRB     r1,[r0,#0x3c]         ;1894
00007e  2000              MOVS     r0,#0                 ;1896
000080  bd10              POP      {r4,pc}
;;;1898   
                          ENDP

000082  0000              DCW      0x0000
                  |L8.132|
                          DCD      TIMEx_DMACommutationCplt
                  |L8.136|
                          DCD      TIMEx_DMACommutationHalfCplt
                  |L8.140|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutEvent_IT PROC
;;;1800     */
;;;1801   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
000000  b510              PUSH     {r4,lr}
;;;1802                                                    uint32_t  CommutationSource)
;;;1803   {
;;;1804     /* Check the parameters */
;;;1805     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1806     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1807   
;;;1808     __HAL_LOCK(htim);
000002  f890303c          LDRB     r3,[r0,#0x3c]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L9.32|
00000a  2301              MOVS     r3,#1
00000c  f880303c          STRB     r3,[r0,#0x3c]
000010  b141              CBZ      r1,|L9.36|
;;;1809   
;;;1810     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L9.36|
;;;1811         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L9.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L9.36|
00001e  e00a              B        |L9.54|
                  |L9.32|
000020  2002              MOVS     r0,#2                 ;1808
;;;1812     {
;;;1813       /* Select the Input trigger */
;;;1814       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1815       htim->Instance->SMCR |= InputTrigger;
;;;1816     }
;;;1817   
;;;1818     /* Select the Capture Compare preload feature */
;;;1819     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1820     /* Select the Commutation event source */
;;;1821     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1822     htim->Instance->CR2 |= CommutationSource;
;;;1823   
;;;1824     /* Disable Commutation DMA request */
;;;1825     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
;;;1826   
;;;1827     /* Enable the Commutation Interrupt */
;;;1828     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1829   
;;;1830     __HAL_UNLOCK(htim);
;;;1831   
;;;1832     return HAL_OK;
;;;1833   }
000022  bd10              POP      {r4,pc}
                  |L9.36|
000024  6803              LDR      r3,[r0,#0]            ;1814
000026  689c              LDR      r4,[r3,#8]            ;1814
000028  f0240470          BIC      r4,r4,#0x70           ;1814
00002c  609c              STR      r4,[r3,#8]            ;1814
00002e  6803              LDR      r3,[r0,#0]            ;1815
000030  689c              LDR      r4,[r3,#8]            ;1815
000032  430c              ORRS     r4,r4,r1              ;1815
000034  609c              STR      r4,[r3,#8]            ;1815
                  |L9.54|
000036  6801              LDR      r1,[r0,#0]            ;1819
000038  684b              LDR      r3,[r1,#4]            ;1819
00003a  f0430301          ORR      r3,r3,#1              ;1819
00003e  604b              STR      r3,[r1,#4]            ;1819
000040  6801              LDR      r1,[r0,#0]            ;1821
000042  684b              LDR      r3,[r1,#4]            ;1821
000044  f0230304          BIC      r3,r3,#4              ;1821
000048  604b              STR      r3,[r1,#4]            ;1821
00004a  6801              LDR      r1,[r0,#0]            ;1822
00004c  684b              LDR      r3,[r1,#4]            ;1822
00004e  4313              ORRS     r3,r3,r2              ;1822
000050  604b              STR      r3,[r1,#4]            ;1822
000052  6801              LDR      r1,[r0,#0]            ;1825
000054  68ca              LDR      r2,[r1,#0xc]          ;1825
000056  f4225200          BIC      r2,r2,#0x2000         ;1825
00005a  60ca              STR      r2,[r1,#0xc]          ;1825
00005c  6801              LDR      r1,[r0,#0]            ;1828
00005e  68ca              LDR      r2,[r1,#0xc]          ;1828
000060  f0420220          ORR      r2,r2,#0x20           ;1828
000064  60ca              STR      r2,[r1,#0xc]          ;1828
000066  2100              MOVS     r1,#0                 ;1830
000068  f880103c          STRB     r1,[r0,#0x3c]         ;1830
00006c  2000              MOVS     r0,#0                 ;1832
00006e  bd10              POP      {r4,pc}
;;;1834   
                          ENDP


                          AREA ||i.HAL_TIMEx_GetChannelNState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_GetChannelNState PROC
;;;2582     */
;;;2583   HAL_TIM_ChannelStateTypeDef HAL_TIMEx_GetChannelNState(TIM_HandleTypeDef *htim,  uint32_t ChannelN)
000000  2900              CMP      r1,#0
;;;2584   {
000002  d006              BEQ      |L10.18|
;;;2585     HAL_TIM_ChannelStateTypeDef channel_state;
;;;2586   
;;;2587     /* Check the parameters */
;;;2588     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, ChannelN));
;;;2589   
;;;2590     channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);
000004  2904              CMP      r1,#4
000006  d007              BEQ      |L10.24|
000008  2908              CMP      r1,#8
00000a  d008              BEQ      |L10.30|
00000c  f8900047          LDRB     r0,[r0,#0x47]
;;;2591   
;;;2592     return channel_state;
;;;2593   }
000010  4770              BX       lr
                  |L10.18|
000012  f8900044          LDRB     r0,[r0,#0x44]         ;2590
000016  4770              BX       lr
                  |L10.24|
000018  f8900045          LDRB     r0,[r0,#0x45]         ;2590
00001c  4770              BX       lr
                  |L10.30|
00001e  f8900046          LDRB     r0,[r0,#0x46]         ;2590
000022  4770              BX       lr
;;;2594   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_GroupChannel5||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_GroupChannel5 PROC
;;;2440     */
;;;2441   HAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t Channels)
000000  b510              PUSH     {r4,lr}
;;;2442   {
;;;2443     /* Check parameters */
;;;2444     assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));
;;;2445     assert_param(IS_TIM_GROUPCH5(Channels));
;;;2446   
;;;2447     /* Process Locked */
;;;2448     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d014              BEQ      |L11.52|
00000a  2401              MOVS     r4,#1
00000c  f8004f3c          STRB     r4,[r0,#0x3c]!
;;;2449   
;;;2450     htim->State = HAL_TIM_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  7042              STRB     r2,[r0,#1]
;;;2451   
;;;2452     /* Clear GC5Cx bit fields */
;;;2453     htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);
000014  f8502c3c          LDR      r2,[r0,#-0x3c]
000018  6d93              LDR      r3,[r2,#0x58]
00001a  f0234360          BIC      r3,r3,#0xe0000000
00001e  6593              STR      r3,[r2,#0x58]
;;;2454   
;;;2455     /* Set GC5Cx bit fields */
;;;2456     htim->Instance->CCR5 |= Channels;
000020  f8502c3c          LDR      r2,[r0,#-0x3c]
000024  6d93              LDR      r3,[r2,#0x58]
000026  430b              ORRS     r3,r3,r1
000028  6593              STR      r3,[r2,#0x58]
;;;2457   
;;;2458     /* Change the htim state */
;;;2459     htim->State = HAL_TIM_STATE_READY;
00002a  7044              STRB     r4,[r0,#1]
;;;2460   
;;;2461     __HAL_UNLOCK(htim);
00002c  2100              MOVS     r1,#0
00002e  7001              STRB     r1,[r0,#0]
;;;2462   
;;;2463     return HAL_OK;
000030  2000              MOVS     r0,#0
;;;2464   }
000032  bd10              POP      {r4,pc}
                  |L11.52|
000034  2002              MOVS     r0,#2                 ;2448
000036  bd10              POP      {r4,pc}
;;;2465   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;237      */
;;;238    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;239    {
000002  4604              MOV      r4,r0
;;;240      /* Check the parameters */
;;;241      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;242    
;;;243      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;244    
;;;245      /* Disable the TIM Peripheral Clock */
;;;246      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L12.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L12.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L12.38|
;;;247    
;;;248    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;249      if (htim->HallSensor_MspDeInitCallback == NULL)
;;;250      {
;;;251        htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;
;;;252      }
;;;253      /* DeInit the low level hardware */
;;;254      htim->HallSensor_MspDeInitCallback(htim);
;;;255    #else
;;;256      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;257      HAL_TIMEx_HallSensor_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;258    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;259    
;;;260      /* Change the DMA burst operation state */
;;;261      htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7320              STRB     r0,[r4,#0xc]
;;;262    
;;;263      /* Change the TIM channels state */
;;;264      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
000032  70a0              STRB     r0,[r4,#2]
;;;265      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
000034  70e0              STRB     r0,[r4,#3]
;;;266      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
000036  7220              STRB     r0,[r4,#8]
;;;267      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
000038  7260              STRB     r0,[r4,#9]
;;;268    
;;;269      /* Change TIM state */
;;;270      htim->State = HAL_TIM_STATE_RESET;
00003a  7060              STRB     r0,[r4,#1]
;;;271    
;;;272      /* Release Lock */
;;;273      __HAL_UNLOCK(htim);
00003c  7020              STRB     r0,[r4,#0]
;;;274    
;;;275      return HAL_OK;
;;;276    }
00003e  bd10              POP      {r4,pc}
;;;277    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;2567     */
;;;2568   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;2569   {
;;;2570     return htim->State;
;;;2571   }
000004  4770              BX       lr
;;;2572   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Init PROC
;;;136      */
;;;137    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;138    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;139      TIM_OC_InitTypeDef OC_Config;
;;;140    
;;;141      /* Check the TIM handle allocation */
;;;142      if (htim == NULL)
000008  2c00              CMP      r4,#0
00000a  d004              BEQ      |L14.22|
;;;143      {
;;;144        return HAL_ERROR;
;;;145      }
;;;146    
;;;147      /* Check the parameters */
;;;148      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;149      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;150      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;151      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;152      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;153      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;154      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;155    
;;;156      if (htim->State == HAL_TIM_STATE_RESET)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2600              MOVS     r6,#0
000012  b118              CBZ      r0,|L14.28|
000014  e007              B        |L14.38|
                  |L14.22|
000016  2001              MOVS     r0,#1                 ;144
                  |L14.24|
;;;157      {
;;;158        /* Allocate lock resource and initialize it */
;;;159        htim->Lock = HAL_UNLOCKED;
;;;160    
;;;161    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;162        /* Reset interrupt callbacks to legacy week callbacks */
;;;163        TIM_ResetCallback(htim);
;;;164    
;;;165        if (htim->HallSensor_MspInitCallback == NULL)
;;;166        {
;;;167          htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;
;;;168        }
;;;169        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;170        htim->HallSensor_MspInitCallback(htim);
;;;171    #else
;;;172        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;173        HAL_TIMEx_HallSensor_MspInit(htim);
;;;174    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;175      }
;;;176    
;;;177      /* Set the TIM state */
;;;178      htim->State = HAL_TIM_STATE_BUSY;
;;;179    
;;;180      /* Configure the Time base in the Encoder Mode */
;;;181      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;182    
;;;183      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;184      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
;;;185    
;;;186      /* Reset the IC1PSC Bits */
;;;187      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;188      /* Set the IC1PSC value */
;;;189      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
;;;190    
;;;191      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;192      htim->Instance->CR2 |= TIM_CR2_TI1S;
;;;193    
;;;194      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;195      htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;196      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
;;;197    
;;;198      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
;;;199      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;200      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
;;;201    
;;;202      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;203      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
;;;204      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;205      OC_Config.OCMode = TIM_OCMODE_PWM2;
;;;206      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
;;;207      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;208      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;209      OC_Config.Pulse = sConfig->Commutation_Delay;
;;;210    
;;;211      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
;;;212    
;;;213      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;214        register to 101 */
;;;215      htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;216      htim->Instance->CR2 |= TIM_TRGO_OC2REF;
;;;217    
;;;218      /* Initialize the DMA burst operation state */
;;;219      htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
;;;220    
;;;221      /* Initialize the TIM channels state */
;;;222      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
;;;223      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
;;;224      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
;;;225      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
;;;226    
;;;227      /* Initialize the TIM state*/
;;;228      htim->State = HAL_TIM_STATE_READY;
;;;229    
;;;230      return HAL_OK;
;;;231    }
000018  b008              ADD      sp,sp,#0x20
00001a  bd70              POP      {r4-r6,pc}
                  |L14.28|
00001c  f884603c          STRB     r6,[r4,#0x3c]         ;159
000020  4620              MOV      r0,r4                 ;173
000022  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
                  |L14.38|
000026  2002              MOVS     r0,#2                 ;178
000028  f884003d          STRB     r0,[r4,#0x3d]         ;178
00002c  1d21              ADDS     r1,r4,#4              ;181
00002e  6820              LDR      r0,[r4,#0]            ;181
000030  f7fffffe          BL       TIM_Base_SetConfig
000034  68ab              LDR      r3,[r5,#8]            ;184
000036  6829              LDR      r1,[r5,#0]            ;184
000038  2203              MOVS     r2,#3                 ;184
00003a  6820              LDR      r0,[r4,#0]            ;184
00003c  f7fffffe          BL       TIM_TI1_SetConfig
000040  6820              LDR      r0,[r4,#0]            ;187
000042  6981              LDR      r1,[r0,#0x18]         ;187
000044  f021010c          BIC      r1,r1,#0xc            ;187
000048  6181              STR      r1,[r0,#0x18]         ;187
00004a  6820              LDR      r0,[r4,#0]            ;189
00004c  6981              LDR      r1,[r0,#0x18]         ;189
00004e  686a              LDR      r2,[r5,#4]            ;189
000050  4311              ORRS     r1,r1,r2              ;189
000052  6181              STR      r1,[r0,#0x18]         ;189
000054  6820              LDR      r0,[r4,#0]            ;192
000056  6841              LDR      r1,[r0,#4]            ;192
000058  f0410180          ORR      r1,r1,#0x80           ;192
00005c  6041              STR      r1,[r0,#4]            ;192
00005e  6820              LDR      r0,[r4,#0]            ;195
000060  6881              LDR      r1,[r0,#8]            ;195
000062  f0210170          BIC      r1,r1,#0x70           ;195
000066  6081              STR      r1,[r0,#8]            ;195
000068  6820              LDR      r0,[r4,#0]            ;196
00006a  6881              LDR      r1,[r0,#8]            ;196
00006c  f0410140          ORR      r1,r1,#0x40           ;196
000070  6081              STR      r1,[r0,#8]            ;196
000072  6820              LDR      r0,[r4,#0]            ;199
000074  6881              LDR      r1,[r0,#8]            ;199
000076  4a17              LDR      r2,|L14.212|
000078  4011              ANDS     r1,r1,r2              ;199
00007a  6081              STR      r1,[r0,#8]            ;199
00007c  6820              LDR      r0,[r4,#0]            ;200
00007e  6881              LDR      r1,[r0,#8]            ;200
000080  f0410104          ORR      r1,r1,#4              ;200
000084  6081              STR      r1,[r0,#8]            ;200
000086  9605              STR      r6,[sp,#0x14]         ;203
000088  9606              STR      r6,[sp,#0x18]         ;204
00008a  2070              MOVS     r0,#0x70              ;205
00008c  9001              STR      r0,[sp,#4]            ;205
00008e  9607              STR      r6,[sp,#0x1c]         ;206
000090  9604              STR      r6,[sp,#0x10]         ;207
000092  9603              STR      r6,[sp,#0xc]          ;208
000094  68e8              LDR      r0,[r5,#0xc]          ;209
000096  9002              STR      r0,[sp,#8]            ;209
000098  a901              ADD      r1,sp,#4              ;211
00009a  6820              LDR      r0,[r4,#0]            ;211
00009c  f7fffffe          BL       TIM_OC2_SetConfig
0000a0  6820              LDR      r0,[r4,#0]            ;215
0000a2  6841              LDR      r1,[r0,#4]            ;215
0000a4  f0210170          BIC      r1,r1,#0x70           ;215
0000a8  6041              STR      r1,[r0,#4]            ;215
0000aa  6820              LDR      r0,[r4,#0]            ;216
0000ac  6841              LDR      r1,[r0,#4]            ;216
0000ae  f0410150          ORR      r1,r1,#0x50           ;216
0000b2  6041              STR      r1,[r0,#4]            ;216
0000b4  2001              MOVS     r0,#1                 ;219
0000b6  f8840048          STRB     r0,[r4,#0x48]         ;219
0000ba  f884003e          STRB     r0,[r4,#0x3e]         ;222
0000be  f884003f          STRB     r0,[r4,#0x3f]         ;223
0000c2  f8840044          STRB     r0,[r4,#0x44]         ;224
0000c6  f8840045          STRB     r0,[r4,#0x45]         ;225
0000ca  f884003d          STRB     r0,[r4,#0x3d]         ;228
0000ce  2000              MOVS     r0,#0                 ;230
0000d0  e7a2              B        |L14.24|
;;;232    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L14.212|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;297      */
;;;298    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;299    {
;;;300      /* Prevent unused argument(s) compilation warning */
;;;301      UNUSED(htim);
;;;302    
;;;303      /* NOTE : This function should not be modified, when the callback is needed,
;;;304                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;305       */
;;;306    }
;;;307    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;282      */
;;;283    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;284    {
;;;285      /* Prevent unused argument(s) compilation warning */
;;;286      UNUSED(htim);
;;;287    
;;;288      /* NOTE : This function should not be modified, when the callback is needed,
;;;289                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;290       */
;;;291    }
;;;292    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start PROC
;;;312      */
;;;313    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;314    {
000002  4604              MOV      r4,r0
;;;315      uint32_t tmpsmcr;
;;;316      HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
000004  f8141f3e          LDRB     r1,[r4,#0x3e]!
;;;317      HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
000008  7862              LDRB     r2,[r4,#1]
;;;318      HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
00000a  79a0              LDRB     r0,[r4,#6]
;;;319      HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
00000c  79e3              LDRB     r3,[r4,#7]
00000e  3c3e              SUBS     r4,r4,#0x3e
;;;320    
;;;321      /* Check the parameters */
;;;322      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;323    
;;;324      /* Check the TIM channels state */
;;;325      if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000010  2901              CMP      r1,#1
000012  d105              BNE      |L17.32|
;;;326          || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
000014  2a01              CMP      r2,#1
000016  d103              BNE      |L17.32|
;;;327          || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L17.32|
;;;328          || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
00001c  2b01              CMP      r3,#1
00001e  d001              BEQ      |L17.36|
                  |L17.32|
;;;329      {
;;;330        return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;331      }
;;;332    
;;;333      /* Set the TIM channels state */
;;;334      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;335      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;336      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;337      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;338    
;;;339      /* Enable the Input Capture channel 1
;;;340      (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;341      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;342    
;;;343      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;344      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;345      {
;;;346        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;347        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;348        {
;;;349          __HAL_TIM_ENABLE(htim);
;;;350        }
;;;351      }
;;;352      else
;;;353      {
;;;354        __HAL_TIM_ENABLE(htim);
;;;355      }
;;;356    
;;;357      /* Return function status */
;;;358      return HAL_OK;
;;;359    }
000022  bd10              POP      {r4,pc}
                  |L17.36|
000024  2002              MOVS     r0,#2                 ;334
000026  f8040f3e          STRB     r0,[r4,#0x3e]!        ;334
00002a  7060              STRB     r0,[r4,#1]            ;335
00002c  71a0              STRB     r0,[r4,#6]            ;336
00002e  71e0              STRB     r0,[r4,#7]            ;337
000030  f8540c3e          LDR      r0,[r4,#-0x3e]        ;341
000034  2201              MOVS     r2,#1                 ;341
000036  2100              MOVS     r1,#0                 ;341
000038  f7fffffe          BL       TIM_CCxChannelCmd
00003c  f8540c3e          LDR      r0,[r4,#-0x3e]        ;344
000040  4913              LDR      r1,|L17.144|
000042  4288              CMP      r0,r1                 ;344
000044  d011              BEQ      |L17.106|
000046  f1b04f80          CMP      r0,#0x40000000        ;344
00004a  d00e              BEQ      |L17.106|
00004c  4911              LDR      r1,|L17.148|
00004e  4288              CMP      r0,r1                 ;344
000050  d00b              BEQ      |L17.106|
000052  4911              LDR      r1,|L17.152|
000054  4288              CMP      r0,r1                 ;344
000056  d008              BEQ      |L17.106|
000058  4910              LDR      r1,|L17.156|
00005a  4288              CMP      r0,r1                 ;344
00005c  d005              BEQ      |L17.106|
00005e  4910              LDR      r1,|L17.160|
000060  4288              CMP      r0,r1                 ;344
000062  d002              BEQ      |L17.106|
000064  490f              LDR      r1,|L17.164|
000066  4288              CMP      r0,r1                 ;344
000068  d10c              BNE      |L17.132|
                  |L17.106|
00006a  6881              LDR      r1,[r0,#8]            ;346
00006c  4a0e              LDR      r2,|L17.168|
00006e  4011              ANDS     r1,r1,r2              ;346
000070  2906              CMP      r1,#6                 ;347
000072  d00b              BEQ      |L17.140|
000074  f5b13f80          CMP      r1,#0x10000           ;347
000078  d008              BEQ      |L17.140|
00007a  6801              LDR      r1,[r0,#0]            ;349
00007c  f0410101          ORR      r1,r1,#1              ;349
000080  6001              STR      r1,[r0,#0]            ;349
000082  e003              B        |L17.140|
                  |L17.132|
000084  6801              LDR      r1,[r0,#0]            ;354
000086  f0410101          ORR      r1,r1,#1              ;354
00008a  6001              STR      r1,[r0,#0]            ;354
                  |L17.140|
00008c  2000              MOVS     r0,#0                 ;358
00008e  bd10              POP      {r4,pc}
;;;360    
                          ENDP

                  |L17.144|
                          DCD      0x40012c00
                  |L17.148|
                          DCD      0x40000400
                  |L17.152|
                          DCD      0x40000800
                  |L17.156|
                          DCD      0x40000c00
                  |L17.160|
                          DCD      0x40013400
                  |L17.164|
                          DCD      0x40014000
                  |L17.168|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;480      */
;;;481    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;483      uint32_t tmpsmcr;
;;;484      HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
000008  f894003e          LDRB     r0,[r4,#0x3e]
;;;485      HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
00000c  f8941044          LDRB     r1,[r4,#0x44]
;;;486    
;;;487      /* Check the parameters */
;;;488      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;489    
;;;490      /* Set the TIM channel state */
;;;491      if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
000010  2802              CMP      r0,#2
000012  d004              BEQ      |L18.30|
;;;492          || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
000014  2902              CMP      r1,#2
000016  d002              BEQ      |L18.30|
;;;493      {
;;;494        return HAL_BUSY;
;;;495      }
;;;496      else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
000018  2801              CMP      r0,#1
00001a  d002              BEQ      |L18.34|
00001c  e003              B        |L18.38|
                  |L18.30|
00001e  2002              MOVS     r0,#2                 ;494
;;;497               && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
;;;498      {
;;;499        if ((pData == NULL) && (Length > 0U))
;;;500        {
;;;501          return HAL_ERROR;
;;;502        }
;;;503        else
;;;504        {
;;;505          TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;506          TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;507        }
;;;508      }
;;;509      else
;;;510      {
;;;511        return HAL_ERROR;
;;;512      }
;;;513    
;;;514      /* Enable the Input Capture channel 1
;;;515        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;516      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;517    
;;;518      /* Set the DMA Input Capture 1 Callbacks */
;;;519      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;520      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;521      /* Set the DMA error callback */
;;;522      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;523    
;;;524      /* Enable the DMA channel for Capture 1*/
;;;525      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
;;;526      {
;;;527        /* Return error status */
;;;528        return HAL_ERROR;
;;;529      }
;;;530      /* Enable the capture compare 1 Interrupt */
;;;531      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;532    
;;;533      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;534      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;535      {
;;;536        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;537        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;538        {
;;;539          __HAL_TIM_ENABLE(htim);
;;;540        }
;;;541      }
;;;542      else
;;;543      {
;;;544        __HAL_TIM_ENABLE(htim);
;;;545      }
;;;546    
;;;547      /* Return function status */
;;;548      return HAL_OK;
;;;549    }
000020  bd70              POP      {r4-r6,pc}
                  |L18.34|
000022  2901              CMP      r1,#1                 ;497
000024  d001              BEQ      |L18.42|
                  |L18.38|
000026  2001              MOVS     r0,#1                 ;511
000028  bd70              POP      {r4-r6,pc}
                  |L18.42|
00002a  b916              CBNZ     r6,|L18.50|
00002c  b10d              CBZ      r5,|L18.50|
00002e  2001              MOVS     r0,#1                 ;501
000030  bd70              POP      {r4-r6,pc}
                  |L18.50|
000032  2002              MOVS     r0,#2                 ;505
000034  f884003e          STRB     r0,[r4,#0x3e]         ;505
000038  f8840044          STRB     r0,[r4,#0x44]         ;506
00003c  2201              MOVS     r2,#1                 ;516
00003e  2100              MOVS     r1,#0                 ;516
000040  6820              LDR      r0,[r4,#0]            ;516
000042  f7fffffe          BL       TIM_CCxChannelCmd
000046  6a61              LDR      r1,[r4,#0x24]         ;519
000048  481f              LDR      r0,|L18.200|
00004a  62c8              STR      r0,[r1,#0x2c]         ;519
00004c  6a61              LDR      r1,[r4,#0x24]         ;520
00004e  481f              LDR      r0,|L18.204|
000050  6308              STR      r0,[r1,#0x30]         ;520
000052  6a61              LDR      r1,[r4,#0x24]         ;522
000054  481e              LDR      r0,|L18.208|
000056  6348              STR      r0,[r1,#0x34]         ;522
000058  6821              LDR      r1,[r4,#0]            ;525
00005a  462b              MOV      r3,r5                 ;525
00005c  3134              ADDS     r1,r1,#0x34           ;525
00005e  4632              MOV      r2,r6                 ;525
000060  6a60              LDR      r0,[r4,#0x24]         ;525
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  b108              CBZ      r0,|L18.108|
000068  2001              MOVS     r0,#1                 ;528
00006a  bd70              POP      {r4-r6,pc}
                  |L18.108|
00006c  6820              LDR      r0,[r4,#0]            ;531
00006e  68c1              LDR      r1,[r0,#0xc]          ;531
000070  f4417100          ORR      r1,r1,#0x200          ;531
000074  60c1              STR      r1,[r0,#0xc]          ;531
000076  4917              LDR      r1,|L18.212|
000078  6820              LDR      r0,[r4,#0]            ;534
00007a  4288              CMP      r0,r1                 ;534
00007c  d011              BEQ      |L18.162|
00007e  f1b04f80          CMP      r0,#0x40000000        ;534
000082  d00e              BEQ      |L18.162|
000084  4914              LDR      r1,|L18.216|
000086  4288              CMP      r0,r1                 ;534
000088  d00b              BEQ      |L18.162|
00008a  4914              LDR      r1,|L18.220|
00008c  4288              CMP      r0,r1                 ;534
00008e  d008              BEQ      |L18.162|
000090  4913              LDR      r1,|L18.224|
000092  4288              CMP      r0,r1                 ;534
000094  d005              BEQ      |L18.162|
000096  4913              LDR      r1,|L18.228|
000098  4288              CMP      r0,r1                 ;534
00009a  d002              BEQ      |L18.162|
00009c  4912              LDR      r1,|L18.232|
00009e  4288              CMP      r0,r1                 ;534
0000a0  d10c              BNE      |L18.188|
                  |L18.162|
0000a2  6881              LDR      r1,[r0,#8]            ;536
0000a4  4a11              LDR      r2,|L18.236|
0000a6  4011              ANDS     r1,r1,r2              ;536
0000a8  2906              CMP      r1,#6                 ;537
0000aa  d00b              BEQ      |L18.196|
0000ac  f5b13f80          CMP      r1,#0x10000           ;537
0000b0  d008              BEQ      |L18.196|
0000b2  6801              LDR      r1,[r0,#0]            ;539
0000b4  f0410101          ORR      r1,r1,#1              ;539
0000b8  6001              STR      r1,[r0,#0]            ;539
0000ba  e003              B        |L18.196|
                  |L18.188|
0000bc  6801              LDR      r1,[r0,#0]            ;544
0000be  f0410101          ORR      r1,r1,#1              ;544
0000c2  6001              STR      r1,[r0,#0]            ;544
                  |L18.196|
0000c4  2000              MOVS     r0,#0                 ;548
0000c6  bd70              POP      {r4-r6,pc}
;;;550    
                          ENDP

                  |L18.200|
                          DCD      TIM_DMACaptureCplt
                  |L18.204|
                          DCD      TIM_DMACaptureHalfCplt
                  |L18.208|
                          DCD      TIM_DMAError
                  |L18.212|
                          DCD      0x40012c00
                  |L18.216|
                          DCD      0x40000400
                  |L18.220|
                          DCD      0x40000800
                  |L18.224|
                          DCD      0x40000c00
                  |L18.228|
                          DCD      0x40013400
                  |L18.232|
                          DCD      0x40014000
                  |L18.236|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;392      */
;;;393    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;394    {
000002  4604              MOV      r4,r0
;;;395      uint32_t tmpsmcr;
;;;396      HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
000004  f8140f3e          LDRB     r0,[r4,#0x3e]!
;;;397      HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
000008  7861              LDRB     r1,[r4,#1]
;;;398      HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
00000a  79a2              LDRB     r2,[r4,#6]
;;;399      HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
00000c  79e3              LDRB     r3,[r4,#7]
00000e  3c3e              SUBS     r4,r4,#0x3e
;;;400    
;;;401      /* Check the parameters */
;;;402      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;403    
;;;404      /* Check the TIM channels state */
;;;405      if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000010  2801              CMP      r0,#1
000012  d105              BNE      |L19.32|
;;;406          || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
000014  2901              CMP      r1,#1
000016  d103              BNE      |L19.32|
;;;407          || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000018  2a01              CMP      r2,#1
00001a  d101              BNE      |L19.32|
;;;408          || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
00001c  2b01              CMP      r3,#1
00001e  d001              BEQ      |L19.36|
                  |L19.32|
;;;409      {
;;;410        return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;411      }
;;;412    
;;;413      /* Set the TIM channels state */
;;;414      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;415      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;416      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;417      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;418    
;;;419      /* Enable the capture compare Interrupts 1 event */
;;;420      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;421    
;;;422      /* Enable the Input Capture channel 1
;;;423        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;424      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;425    
;;;426      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;427      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;428      {
;;;429        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;430        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;431        {
;;;432          __HAL_TIM_ENABLE(htim);
;;;433        }
;;;434      }
;;;435      else
;;;436      {
;;;437        __HAL_TIM_ENABLE(htim);
;;;438      }
;;;439    
;;;440      /* Return function status */
;;;441      return HAL_OK;
;;;442    }
000022  bd10              POP      {r4,pc}
                  |L19.36|
000024  2002              MOVS     r0,#2                 ;414
000026  f884003e          STRB     r0,[r4,#0x3e]         ;414
00002a  f884003f          STRB     r0,[r4,#0x3f]         ;415
00002e  f8840044          STRB     r0,[r4,#0x44]         ;416
000032  f8840045          STRB     r0,[r4,#0x45]         ;417
000036  6820              LDR      r0,[r4,#0]            ;420
000038  68c1              LDR      r1,[r0,#0xc]          ;420
00003a  f0410102          ORR      r1,r1,#2              ;420
00003e  60c1              STR      r1,[r0,#0xc]          ;420
000040  2201              MOVS     r2,#1                 ;424
000042  2100              MOVS     r1,#0                 ;424
000044  6820              LDR      r0,[r4,#0]            ;424
000046  f7fffffe          BL       TIM_CCxChannelCmd
00004a  4914              LDR      r1,|L19.156|
00004c  6820              LDR      r0,[r4,#0]            ;427
00004e  4288              CMP      r0,r1                 ;427
000050  d011              BEQ      |L19.118|
000052  f1b04f80          CMP      r0,#0x40000000        ;427
000056  d00e              BEQ      |L19.118|
000058  4911              LDR      r1,|L19.160|
00005a  4288              CMP      r0,r1                 ;427
00005c  d00b              BEQ      |L19.118|
00005e  4911              LDR      r1,|L19.164|
000060  4288              CMP      r0,r1                 ;427
000062  d008              BEQ      |L19.118|
000064  4910              LDR      r1,|L19.168|
000066  4288              CMP      r0,r1                 ;427
000068  d005              BEQ      |L19.118|
00006a  4910              LDR      r1,|L19.172|
00006c  4288              CMP      r0,r1                 ;427
00006e  d002              BEQ      |L19.118|
000070  490f              LDR      r1,|L19.176|
000072  4288              CMP      r0,r1                 ;427
000074  d10c              BNE      |L19.144|
                  |L19.118|
000076  6881              LDR      r1,[r0,#8]            ;429
000078  4a0e              LDR      r2,|L19.180|
00007a  4011              ANDS     r1,r1,r2              ;429
00007c  2906              CMP      r1,#6                 ;430
00007e  d00b              BEQ      |L19.152|
000080  f5b13f80          CMP      r1,#0x10000           ;430
000084  d008              BEQ      |L19.152|
000086  6801              LDR      r1,[r0,#0]            ;432
000088  f0410101          ORR      r1,r1,#1              ;432
00008c  6001              STR      r1,[r0,#0]            ;432
00008e  e003              B        |L19.152|
                  |L19.144|
000090  6801              LDR      r1,[r0,#0]            ;437
000092  f0410101          ORR      r1,r1,#1              ;437
000096  6001              STR      r1,[r0,#0]            ;437
                  |L19.152|
000098  2000              MOVS     r0,#0                 ;441
00009a  bd10              POP      {r4,pc}
;;;443    
                          ENDP

                  |L19.156|
                          DCD      0x40012c00
                  |L19.160|
                          DCD      0x40000400
                  |L19.164|
                          DCD      0x40000800
                  |L19.168|
                          DCD      0x40000c00
                  |L19.172|
                          DCD      0x40013400
                  |L19.176|
                          DCD      0x40014000
                  |L19.180|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;365      */
;;;366    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;367    {
000002  4604              MOV      r4,r0
;;;368      /* Check the parameters */
;;;369      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;370    
;;;371      /* Disable the Input Capture channels 1, 2 and 3
;;;372        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;373      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;374    
;;;375      /* Disable the Peripheral */
;;;376      __HAL_TIM_DISABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  f2411211          MOV      r2,#0x1111
000016  4211              TST      r1,r2
000018  d107              BNE      |L20.42|
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  1092              ASRS     r2,r2,#2
00001e  4211              TST      r1,r2
000020  d103              BNE      |L20.42|
000022  6801              LDR      r1,[r0,#0]
000024  f0210101          BIC      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
                  |L20.42|
;;;377    
;;;378      /* Set the TIM channels state */
;;;379      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00002a  2001              MOVS     r0,#1
00002c  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;380      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000030  7060              STRB     r0,[r4,#1]
;;;381      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000032  71a0              STRB     r0,[r4,#6]
;;;382      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000034  71e0              STRB     r0,[r4,#7]
;;;383    
;;;384      /* Return function status */
;;;385      return HAL_OK;
000036  2000              MOVS     r0,#0
;;;386    }
000038  bd10              POP      {r4,pc}
;;;387    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;555      */
;;;556    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;557    {
000002  4604              MOV      r4,r0
;;;558      /* Check the parameters */
;;;559      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;560    
;;;561      /* Disable the Input Capture channel 1
;;;562        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;563      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;564    
;;;565    
;;;566      /* Disable the capture compare Interrupts 1 event */
;;;567      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4217100          BIC      r1,r1,#0x200
000016  60c1              STR      r1,[r0,#0xc]
;;;568    
;;;569      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000018  6a60              LDR      r0,[r4,#0x24]
00001a  f7fffffe          BL       HAL_DMA_Abort_IT
;;;570    
;;;571      /* Disable the Peripheral */
;;;572      __HAL_TIM_DISABLE(htim);
00001e  6820              LDR      r0,[r4,#0]
000020  6a01              LDR      r1,[r0,#0x20]
000022  f2411211          MOV      r2,#0x1111
000026  4211              TST      r1,r2
000028  d107              BNE      |L21.58|
00002a  6a01              LDR      r1,[r0,#0x20]
00002c  1092              ASRS     r2,r2,#2
00002e  4211              TST      r1,r2
000030  d103              BNE      |L21.58|
000032  6801              LDR      r1,[r0,#0]
000034  f0210101          BIC      r1,r1,#1
000038  6001              STR      r1,[r0,#0]
                  |L21.58|
;;;573    
;;;574      /* Set the TIM channel state */
;;;575      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00003a  2001              MOVS     r0,#1
00003c  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;576      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000040  71a0              STRB     r0,[r4,#6]
;;;577    
;;;578      /* Return function status */
;;;579      return HAL_OK;
000042  2000              MOVS     r0,#0
;;;580    }
000044  bd10              POP      {r4,pc}
;;;581    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;448      */
;;;449    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;450    {
000002  4604              MOV      r4,r0
;;;451      /* Check the parameters */
;;;452      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;453    
;;;454      /* Disable the Input Capture channel 1
;;;455        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;456      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;457    
;;;458      /* Disable the capture compare Interrupts event */
;;;459      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210102          BIC      r1,r1,#2
000016  60c1              STR      r1,[r0,#0xc]
;;;460    
;;;461      /* Disable the Peripheral */
;;;462      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L22.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L22.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L22.52|
;;;463    
;;;464      /* Set the TIM channels state */
;;;465      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000034  2001              MOVS     r0,#1
000036  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;466      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00003a  7060              STRB     r0,[r4,#1]
;;;467      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00003c  71a0              STRB     r0,[r4,#6]
;;;468      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00003e  71e0              STRB     r0,[r4,#7]
;;;469    
;;;470      /* Return function status */
;;;471      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;472    }
000042  bd10              POP      {r4,pc}
;;;473    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1906     */
;;;1907   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1908                                                           TIM_MasterConfigTypeDef *sMasterConfig)
;;;1909   {
;;;1910     uint32_t tmpcr2;
;;;1911     uint32_t tmpsmcr;
;;;1912   
;;;1913     /* Check the parameters */
;;;1914     assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
;;;1915     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1916     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1917   
;;;1918     /* Check input state */
;;;1919     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d037              BEQ      |L23.122|
00000a  2601              MOVS     r6,#1
00000c  f880603c          STRB     r6,[r0,#0x3c]
;;;1920   
;;;1921     /* Change the handler state */
;;;1922     htim->State = HAL_TIM_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  f880203d          STRB     r2,[r0,#0x3d]
;;;1923   
;;;1924     /* Get the TIMx CR2 register value */
;;;1925     tmpcr2 = htim->Instance->CR2;
000016  6803              LDR      r3,[r0,#0]
000018  685a              LDR      r2,[r3,#4]
;;;1926   
;;;1927     /* Get the TIMx SMCR register value */
;;;1928     tmpsmcr = htim->Instance->SMCR;
00001a  689c              LDR      r4,[r3,#8]
;;;1929   
;;;1930     /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
;;;1931     if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
00001c  4f18              LDR      r7,|L23.128|
00001e  f8dfc064          LDR      r12,|L23.132|
000022  42bb              CMP      r3,r7
000024  d001              BEQ      |L23.42|
000026  4563              CMP      r3,r12
000028  d103              BNE      |L23.50|
                  |L23.42|
;;;1932     {
;;;1933       /* Check the parameters */
;;;1934       assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
;;;1935   
;;;1936       /* Clear the MMS2 bits */
;;;1937       tmpcr2 &= ~TIM_CR2_MMS2;
00002a  f4220570          BIC      r5,r2,#0xf00000
;;;1938       /* Select the TRGO2 source*/
;;;1939       tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
00002e  684a              LDR      r2,[r1,#4]
000030  432a              ORRS     r2,r2,r5
                  |L23.50|
;;;1940     }
;;;1941   
;;;1942     /* Reset the MMS Bits */
;;;1943     tmpcr2 &= ~TIM_CR2_MMS;
000032  f0220570          BIC      r5,r2,#0x70
;;;1944     /* Select the TRGO source */
;;;1945     tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
000036  680a              LDR      r2,[r1,#0]
000038  432a              ORRS     r2,r2,r5
;;;1946   
;;;1947     /* Update TIMx CR2 */
;;;1948     htim->Instance->CR2 = tmpcr2;
00003a  605a              STR      r2,[r3,#4]
;;;1949   
;;;1950     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
00003c  6802              LDR      r2,[r0,#0]
00003e  42ba              CMP      r2,r7
000040  d010              BEQ      |L23.100|
000042  f1b24f80          CMP      r2,#0x40000000
000046  d00d              BEQ      |L23.100|
000048  4b0f              LDR      r3,|L23.136|
00004a  429a              CMP      r2,r3
00004c  d00a              BEQ      |L23.100|
00004e  4b0f              LDR      r3,|L23.140|
000050  429a              CMP      r2,r3
000052  d007              BEQ      |L23.100|
000054  4b0e              LDR      r3,|L23.144|
000056  429a              CMP      r2,r3
000058  d004              BEQ      |L23.100|
00005a  4562              CMP      r2,r12
00005c  d002              BEQ      |L23.100|
00005e  4b0d              LDR      r3,|L23.148|
000060  429a              CMP      r2,r3
000062  d104              BNE      |L23.110|
                  |L23.100|
;;;1951     {
;;;1952       /* Reset the MSM Bit */
;;;1953       tmpsmcr &= ~TIM_SMCR_MSM;
000064  f0240380          BIC      r3,r4,#0x80
;;;1954       /* Set master mode */
;;;1955       tmpsmcr |= sMasterConfig->MasterSlaveMode;
000068  6889              LDR      r1,[r1,#8]
00006a  4319              ORRS     r1,r1,r3
;;;1956   
;;;1957       /* Update TIMx SMCR */
;;;1958       htim->Instance->SMCR = tmpsmcr;
00006c  6091              STR      r1,[r2,#8]
                  |L23.110|
;;;1959     }
;;;1960   
;;;1961     /* Change the htim state */
;;;1962     htim->State = HAL_TIM_STATE_READY;
00006e  303c              ADDS     r0,r0,#0x3c
000070  7046              STRB     r6,[r0,#1]
;;;1963   
;;;1964     __HAL_UNLOCK(htim);
000072  2100              MOVS     r1,#0
000074  7001              STRB     r1,[r0,#0]
;;;1965   
;;;1966     return HAL_OK;
000076  2000              MOVS     r0,#0
;;;1967   }
000078  bdf0              POP      {r4-r7,pc}
                  |L23.122|
00007a  2002              MOVS     r0,#2                 ;1919
00007c  bdf0              POP      {r4-r7,pc}
;;;1968   
                          ENDP

00007e  0000              DCW      0x0000
                  |L23.128|
                          DCD      0x40012c00
                  |L23.132|
                          DCD      0x40013400
                  |L23.136|
                          DCD      0x40000400
                  |L23.140|
                          DCD      0x40000800
                  |L23.144|
                          DCD      0x40000c00
                  |L23.148|
                          DCD      0x40014000

                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start PROC
;;;616      */
;;;617    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;618    {
000002  4604              MOV      r4,r0
;;;619      uint32_t tmpsmcr;
;;;620    
;;;621      /* Check the parameters */
;;;622      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;623    
;;;624      /* Check the TIM complementary channel state */
;;;625      if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L24.28|
000008  2904              CMP      r1,#4
00000a  d00a              BEQ      |L24.34|
00000c  2908              CMP      r1,#8
00000e  d00b              BEQ      |L24.40|
000010  f8940047          LDRB     r0,[r4,#0x47]
                  |L24.20|
000014  2801              CMP      r0,#1
000016  d00a              BEQ      |L24.46|
;;;626      {
;;;627        return HAL_ERROR;
000018  2001              MOVS     r0,#1
;;;628      }
;;;629    
;;;630      /* Set the TIM complementary channel state */
;;;631      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;632    
;;;633      /* Enable the Capture compare channel N */
;;;634      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;635    
;;;636      /* Enable the Main Output */
;;;637      __HAL_TIM_MOE_ENABLE(htim);
;;;638    
;;;639      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;640      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;641      {
;;;642        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;643        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;644        {
;;;645          __HAL_TIM_ENABLE(htim);
;;;646        }
;;;647      }
;;;648      else
;;;649      {
;;;650        __HAL_TIM_ENABLE(htim);
;;;651      }
;;;652    
;;;653      /* Return function status */
;;;654      return HAL_OK;
;;;655    }
00001a  bd10              POP      {r4,pc}
                  |L24.28|
00001c  f8940044          LDRB     r0,[r4,#0x44]         ;625
000020  e7f8              B        |L24.20|
                  |L24.34|
000022  f8940045          LDRB     r0,[r4,#0x45]         ;625
000026  e7f5              B        |L24.20|
                  |L24.40|
000028  f8940046          LDRB     r0,[r4,#0x46]         ;625
00002c  e7f2              B        |L24.20|
                  |L24.46|
00002e  2002              MOVS     r0,#2                 ;631
000030  b389              CBZ      r1,|L24.150|
000032  2904              CMP      r1,#4                 ;631
000034  d033              BEQ      |L24.158|
000036  2908              CMP      r1,#8                 ;631
000038  d034              BEQ      |L24.164|
00003a  f8840047          STRB     r0,[r4,#0x47]         ;631
                  |L24.62|
00003e  2204              MOVS     r2,#4                 ;634
000040  6820              LDR      r0,[r4,#0]            ;634
000042  f7fffffe          BL       TIM_CCxNChannelCmd
000046  6820              LDR      r0,[r4,#0]            ;637
000048  6c41              LDR      r1,[r0,#0x44]         ;637
00004a  f4414100          ORR      r1,r1,#0x8000         ;637
00004e  6441              STR      r1,[r0,#0x44]         ;637
000050  4919              LDR      r1,|L24.184|
000052  6820              LDR      r0,[r4,#0]            ;640
000054  4288              CMP      r0,r1                 ;640
000056  d011              BEQ      |L24.124|
000058  f1b04f80          CMP      r0,#0x40000000        ;640
00005c  d00e              BEQ      |L24.124|
00005e  4917              LDR      r1,|L24.188|
000060  4288              CMP      r0,r1                 ;640
000062  d00b              BEQ      |L24.124|
000064  4916              LDR      r1,|L24.192|
000066  4288              CMP      r0,r1                 ;640
000068  d008              BEQ      |L24.124|
00006a  4916              LDR      r1,|L24.196|
00006c  4288              CMP      r0,r1                 ;640
00006e  d005              BEQ      |L24.124|
000070  4915              LDR      r1,|L24.200|
000072  4288              CMP      r0,r1                 ;640
000074  d002              BEQ      |L24.124|
000076  4915              LDR      r1,|L24.204|
000078  4288              CMP      r0,r1                 ;640
00007a  d116              BNE      |L24.170|
                  |L24.124|
00007c  6881              LDR      r1,[r0,#8]            ;642
00007e  4a14              LDR      r2,|L24.208|
000080  4011              ANDS     r1,r1,r2              ;642
000082  2906              CMP      r1,#6                 ;643
000084  d015              BEQ      |L24.178|
000086  f5b13f80          CMP      r1,#0x10000           ;643
00008a  d012              BEQ      |L24.178|
00008c  6801              LDR      r1,[r0,#0]            ;645
00008e  f0410101          ORR      r1,r1,#1              ;645
000092  6001              STR      r1,[r0,#0]            ;645
000094  e00d              B        |L24.178|
                  |L24.150|
000096  e7ff              B        |L24.152|
                  |L24.152|
000098  f8840044          STRB     r0,[r4,#0x44]         ;631
00009c  e7cf              B        |L24.62|
                  |L24.158|
00009e  f8840045          STRB     r0,[r4,#0x45]         ;631
0000a2  e7cc              B        |L24.62|
                  |L24.164|
0000a4  f8840046          STRB     r0,[r4,#0x46]         ;631
0000a8  e7c9              B        |L24.62|
                  |L24.170|
0000aa  6801              LDR      r1,[r0,#0]            ;650
0000ac  f0410101          ORR      r1,r1,#1              ;650
0000b0  6001              STR      r1,[r0,#0]            ;650
                  |L24.178|
0000b2  2000              MOVS     r0,#0                 ;654
0000b4  bd10              POP      {r4,pc}
;;;656    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L24.184|
                          DCD      0x40012c00
                  |L24.188|
                          DCD      0x40000400
                  |L24.192|
                          DCD      0x40000800
                  |L24.196|
                          DCD      0x40000c00
                  |L24.200|
                          DCD      0x40013400
                  |L24.204|
                          DCD      0x40014000
                  |L24.208|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;850      */
;;;851    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;852    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  4611              MOV      r1,r2
;;;853      uint32_t tmpsmcr;
;;;854    
;;;855      /* Check the parameters */
;;;856      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;857    
;;;858      /* Set the TIM complementary channel state */
;;;859      if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
00000a  2d00              CMP      r5,#0
00000c  d013              BEQ      |L25.54|
00000e  2d04              CMP      r5,#4
000010  d014              BEQ      |L25.60|
000012  2d08              CMP      r5,#8
000014  d015              BEQ      |L25.66|
000016  f8940047          LDRB     r0,[r4,#0x47]
                  |L25.26|
00001a  2802              CMP      r0,#2
00001c  d014              BEQ      |L25.72|
;;;860      {
;;;861        return HAL_BUSY;
;;;862      }
;;;863      else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
00001e  b1ad              CBZ      r5,|L25.76|
000020  2d04              CMP      r5,#4
000022  d016              BEQ      |L25.82|
000024  2d08              CMP      r5,#8
000026  d017              BEQ      |L25.88|
000028  f8940047          LDRB     r0,[r4,#0x47]
                  |L25.44|
00002c  2801              CMP      r0,#1
00002e  d016              BEQ      |L25.94|
;;;864      {
;;;865        if ((pData == NULL) && (Length > 0U))
;;;866        {
;;;867          return HAL_ERROR;
;;;868        }
;;;869        else
;;;870        {
;;;871          TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;872        }
;;;873      }
;;;874      else
;;;875      {
;;;876        return HAL_ERROR;
000030  2001              MOVS     r0,#1
                  |L25.50|
;;;877      }
;;;878    
;;;879      switch (Channel)
;;;880      {
;;;881        case TIM_CHANNEL_1:
;;;882        {
;;;883          /* Set the DMA compare callbacks */
;;;884          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
;;;885          htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;886    
;;;887          /* Set the DMA error callback */
;;;888          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
;;;889    
;;;890          /* Enable the DMA channel */
;;;891          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;892          {
;;;893            /* Return error status */
;;;894            return HAL_ERROR;
;;;895          }
;;;896          /* Enable the TIM Output Compare DMA request */
;;;897          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;898          break;
;;;899        }
;;;900    
;;;901        case TIM_CHANNEL_2:
;;;902        {
;;;903          /* Set the DMA compare callbacks */
;;;904          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
;;;905          htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;906    
;;;907          /* Set the DMA error callback */
;;;908          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
;;;909    
;;;910          /* Enable the DMA channel */
;;;911          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;912          {
;;;913            /* Return error status */
;;;914            return HAL_ERROR;
;;;915          }
;;;916          /* Enable the TIM Output Compare DMA request */
;;;917          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;918          break;
;;;919        }
;;;920    
;;;921        case TIM_CHANNEL_3:
;;;922        {
;;;923          /* Set the DMA compare callbacks */
;;;924          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
;;;925          htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;926    
;;;927          /* Set the DMA error callback */
;;;928          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
;;;929    
;;;930          /* Enable the DMA channel */
;;;931          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;932          {
;;;933            /* Return error status */
;;;934            return HAL_ERROR;
;;;935          }
;;;936          /* Enable the TIM Output Compare DMA request */
;;;937          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;938          break;
;;;939        }
;;;940    
;;;941        default:
;;;942          break;
;;;943      }
;;;944    
;;;945      /* Enable the Capture compare channel N */
;;;946      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;947    
;;;948      /* Enable the Main Output */
;;;949      __HAL_TIM_MOE_ENABLE(htim);
;;;950    
;;;951      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;952      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;953      {
;;;954        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;955        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;956        {
;;;957          __HAL_TIM_ENABLE(htim);
;;;958        }
;;;959      }
;;;960      else
;;;961      {
;;;962        __HAL_TIM_ENABLE(htim);
;;;963      }
;;;964    
;;;965      /* Return function status */
;;;966      return HAL_OK;
;;;967    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L25.54|
000036  f8940044          LDRB     r0,[r4,#0x44]         ;859
00003a  e7ee              B        |L25.26|
                  |L25.60|
00003c  f8940045          LDRB     r0,[r4,#0x45]         ;859
000040  e7eb              B        |L25.26|
                  |L25.66|
000042  f8940046          LDRB     r0,[r4,#0x46]         ;859
000046  e7e8              B        |L25.26|
                  |L25.72|
000048  2002              MOVS     r0,#2                 ;861
00004a  e7f2              B        |L25.50|
                  |L25.76|
00004c  f8940044          LDRB     r0,[r4,#0x44]         ;863
000050  e7ec              B        |L25.44|
                  |L25.82|
000052  f8940045          LDRB     r0,[r4,#0x45]         ;863
000056  e7e9              B        |L25.44|
                  |L25.88|
000058  f8940046          LDRB     r0,[r4,#0x46]         ;863
00005c  e7e6              B        |L25.44|
                  |L25.94|
00005e  b911              CBNZ     r1,|L25.102|
000060  b10b              CBZ      r3,|L25.102|
000062  2001              MOVS     r0,#1                 ;867
000064  e7e5              B        |L25.50|
                  |L25.102|
000066  2002              MOVS     r0,#2                 ;861
000068  b135              CBZ      r5,|L25.120|
00006a  2d04              CMP      r5,#4                 ;871
00006c  d007              BEQ      |L25.126|
00006e  2d08              CMP      r5,#8                 ;871
000070  d008              BEQ      |L25.132|
000072  f8840047          STRB     r0,[r4,#0x47]         ;871
000076  e007              B        |L25.136|
                  |L25.120|
000078  f8840044          STRB     r0,[r4,#0x44]         ;871
00007c  e004              B        |L25.136|
                  |L25.126|
00007e  f8840045          STRB     r0,[r4,#0x45]         ;871
000082  e001              B        |L25.136|
                  |L25.132|
000084  f8840046          STRB     r0,[r4,#0x46]         ;871
                  |L25.136|
000088  483b              LDR      r0,|L25.376|
00008a  4a3c              LDR      r2,|L25.380|
00008c  4e3c              LDR      r6,|L25.384|
00008e  b125              CBZ      r5,|L25.154|
000090  2d04              CMP      r5,#4                 ;879
000092  d016              BEQ      |L25.194|
000094  2d08              CMP      r5,#8                 ;879
000096  d13b              BNE      |L25.272|
000098  e027              B        |L25.234|
                  |L25.154|
00009a  6a67              LDR      r7,[r4,#0x24]         ;884
00009c  62f8              STR      r0,[r7,#0x2c]         ;884
00009e  6a60              LDR      r0,[r4,#0x24]         ;885
0000a0  6302              STR      r2,[r0,#0x30]         ;885
0000a2  6a60              LDR      r0,[r4,#0x24]         ;888
0000a4  6346              STR      r6,[r0,#0x34]         ;888
0000a6  6822              LDR      r2,[r4,#0]            ;891
0000a8  6a60              LDR      r0,[r4,#0x24]         ;891
0000aa  3234              ADDS     r2,r2,#0x34           ;891
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  b108              CBZ      r0,|L25.182|
0000b2  2001              MOVS     r0,#1                 ;894
0000b4  e7bd              B        |L25.50|
                  |L25.182|
0000b6  6820              LDR      r0,[r4,#0]            ;897
0000b8  68c1              LDR      r1,[r0,#0xc]          ;897
0000ba  f4417100          ORR      r1,r1,#0x200          ;897
0000be  60c1              STR      r1,[r0,#0xc]          ;897
0000c0  e026              B        |L25.272|
                  |L25.194|
0000c2  6aa7              LDR      r7,[r4,#0x28]         ;904
0000c4  62f8              STR      r0,[r7,#0x2c]         ;904
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;905
0000c8  6302              STR      r2,[r0,#0x30]         ;905
0000ca  6aa0              LDR      r0,[r4,#0x28]         ;908
0000cc  6346              STR      r6,[r0,#0x34]         ;908
0000ce  6822              LDR      r2,[r4,#0]            ;911
0000d0  6aa0              LDR      r0,[r4,#0x28]         ;911
0000d2  3238              ADDS     r2,r2,#0x38           ;911
0000d4  f7fffffe          BL       HAL_DMA_Start_IT
0000d8  b108              CBZ      r0,|L25.222|
0000da  2001              MOVS     r0,#1                 ;914
0000dc  e7a9              B        |L25.50|
                  |L25.222|
0000de  6820              LDR      r0,[r4,#0]            ;917
0000e0  68c1              LDR      r1,[r0,#0xc]          ;917
0000e2  f4416180          ORR      r1,r1,#0x400          ;917
0000e6  60c1              STR      r1,[r0,#0xc]          ;917
0000e8  e012              B        |L25.272|
                  |L25.234|
0000ea  6ae7              LDR      r7,[r4,#0x2c]         ;924
0000ec  62f8              STR      r0,[r7,#0x2c]         ;924
0000ee  6ae0              LDR      r0,[r4,#0x2c]         ;925
0000f0  6302              STR      r2,[r0,#0x30]         ;925
0000f2  6ae0              LDR      r0,[r4,#0x2c]         ;928
0000f4  6346              STR      r6,[r0,#0x34]         ;928
0000f6  6822              LDR      r2,[r4,#0]            ;931
0000f8  6ae0              LDR      r0,[r4,#0x2c]         ;931
0000fa  323c              ADDS     r2,r2,#0x3c           ;931
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  b108              CBZ      r0,|L25.262|
000102  2001              MOVS     r0,#1                 ;934
000104  e795              B        |L25.50|
                  |L25.262|
000106  6820              LDR      r0,[r4,#0]            ;937
000108  68c1              LDR      r1,[r0,#0xc]          ;937
00010a  f4416100          ORR      r1,r1,#0x800          ;937
00010e  60c1              STR      r1,[r0,#0xc]          ;937
                  |L25.272|
000110  2204              MOVS     r2,#4                 ;946
000112  4629              MOV      r1,r5                 ;946
000114  6820              LDR      r0,[r4,#0]            ;946
000116  f7fffffe          BL       TIM_CCxNChannelCmd
00011a  6820              LDR      r0,[r4,#0]            ;949
00011c  6c41              LDR      r1,[r0,#0x44]         ;949
00011e  f4414100          ORR      r1,r1,#0x8000         ;949
000122  6441              STR      r1,[r0,#0x44]         ;949
000124  4917              LDR      r1,|L25.388|
000126  6820              LDR      r0,[r4,#0]            ;952
000128  4288              CMP      r0,r1                 ;952
00012a  d011              BEQ      |L25.336|
00012c  f1b04f80          CMP      r0,#0x40000000        ;952
000130  d00e              BEQ      |L25.336|
000132  4915              LDR      r1,|L25.392|
000134  4288              CMP      r0,r1                 ;952
000136  d00b              BEQ      |L25.336|
000138  4914              LDR      r1,|L25.396|
00013a  4288              CMP      r0,r1                 ;952
00013c  d008              BEQ      |L25.336|
00013e  4914              LDR      r1,|L25.400|
000140  4288              CMP      r0,r1                 ;952
000142  d005              BEQ      |L25.336|
000144  4913              LDR      r1,|L25.404|
000146  4288              CMP      r0,r1                 ;952
000148  d002              BEQ      |L25.336|
00014a  4913              LDR      r1,|L25.408|
00014c  4288              CMP      r0,r1                 ;952
00014e  d10c              BNE      |L25.362|
                  |L25.336|
000150  6881              LDR      r1,[r0,#8]            ;954
000152  4a12              LDR      r2,|L25.412|
000154  4011              ANDS     r1,r1,r2              ;954
000156  2906              CMP      r1,#6                 ;955
000158  d00b              BEQ      |L25.370|
00015a  f5b13f80          CMP      r1,#0x10000           ;955
00015e  d008              BEQ      |L25.370|
000160  6801              LDR      r1,[r0,#0]            ;957
000162  f0410101          ORR      r1,r1,#1              ;957
000166  6001              STR      r1,[r0,#0]            ;957
000168  e003              B        |L25.370|
                  |L25.362|
00016a  6801              LDR      r1,[r0,#0]            ;962
00016c  f0410101          ORR      r1,r1,#1              ;962
000170  6001              STR      r1,[r0,#0]            ;962
                  |L25.370|
000172  2000              MOVS     r0,#0                 ;966
000174  e75d              B        |L25.50|
;;;968    
                          ENDP

000176  0000              DCW      0x0000
                  |L25.376|
                          DCD      TIM_DMADelayPulseNCplt
                  |L25.380|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L25.384|
                          DCD      TIM_DMAErrorCCxN
                  |L25.388|
                          DCD      0x40012c00
                  |L25.392|
                          DCD      0x40000400
                  |L25.396|
                          DCD      0x40000800
                  |L25.400|
                          DCD      0x40000c00
                  |L25.404|
                          DCD      0x40013400
                  |L25.408|
                          DCD      0x40014000
                  |L25.412|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_IT PROC
;;;699      */
;;;700    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;701    {
000002  4604              MOV      r4,r0
;;;702      uint32_t tmpsmcr;
;;;703    
;;;704      /* Check the parameters */
;;;705      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;706    
;;;707      /* Check the TIM complementary channel state */
;;;708      if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L26.28|
000008  2904              CMP      r1,#4
00000a  d00a              BEQ      |L26.34|
00000c  2908              CMP      r1,#8
00000e  d00b              BEQ      |L26.40|
000010  f8940047          LDRB     r0,[r4,#0x47]
                  |L26.20|
000014  2801              CMP      r0,#1
000016  d00a              BEQ      |L26.46|
;;;709      {
;;;710        return HAL_ERROR;
000018  2001              MOVS     r0,#1
;;;711      }
;;;712    
;;;713      /* Set the TIM complementary channel state */
;;;714      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;715    
;;;716      switch (Channel)
;;;717      {
;;;718        case TIM_CHANNEL_1:
;;;719        {
;;;720          /* Enable the TIM Output Compare interrupt */
;;;721          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;722          break;
;;;723        }
;;;724    
;;;725        case TIM_CHANNEL_2:
;;;726        {
;;;727          /* Enable the TIM Output Compare interrupt */
;;;728          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;729          break;
;;;730        }
;;;731    
;;;732        case TIM_CHANNEL_3:
;;;733        {
;;;734          /* Enable the TIM Output Compare interrupt */
;;;735          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;736          break;
;;;737        }
;;;738    
;;;739    
;;;740        default:
;;;741          break;
;;;742      }
;;;743    
;;;744      /* Enable the TIM Break interrupt */
;;;745      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
;;;746    
;;;747      /* Enable the Capture compare channel N */
;;;748      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;749    
;;;750      /* Enable the Main Output */
;;;751      __HAL_TIM_MOE_ENABLE(htim);
;;;752    
;;;753      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;754      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;755      {
;;;756        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;757        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;758        {
;;;759          __HAL_TIM_ENABLE(htim);
;;;760        }
;;;761      }
;;;762      else
;;;763      {
;;;764        __HAL_TIM_ENABLE(htim);
;;;765      }
;;;766    
;;;767      /* Return function status */
;;;768      return HAL_OK;
;;;769    }
00001a  bd10              POP      {r4,pc}
                  |L26.28|
00001c  f8940044          LDRB     r0,[r4,#0x44]         ;708
000020  e7f8              B        |L26.20|
                  |L26.34|
000022  f8940045          LDRB     r0,[r4,#0x45]         ;708
000026  e7f5              B        |L26.20|
                  |L26.40|
000028  f8940046          LDRB     r0,[r4,#0x46]         ;708
00002c  e7f2              B        |L26.20|
                  |L26.46|
00002e  2002              MOVS     r0,#2                 ;714
000030  b159              CBZ      r1,|L26.74|
000032  2904              CMP      r1,#4                 ;714
000034  d00c              BEQ      |L26.80|
000036  2908              CMP      r1,#8                 ;714
000038  d00d              BEQ      |L26.86|
00003a  f8840047          STRB     r0,[r4,#0x47]         ;714
                  |L26.62|
00003e  b169              CBZ      r1,|L26.92|
000040  2904              CMP      r1,#4                 ;716
000042  d011              BEQ      |L26.104|
000044  2908              CMP      r1,#8                 ;716
000046  d11a              BNE      |L26.126|
000048  e014              B        |L26.116|
                  |L26.74|
00004a  f8840044          STRB     r0,[r4,#0x44]         ;714
00004e  e7f6              B        |L26.62|
                  |L26.80|
000050  f8840045          STRB     r0,[r4,#0x45]         ;714
000054  e7f3              B        |L26.62|
                  |L26.86|
000056  f8840046          STRB     r0,[r4,#0x46]         ;714
00005a  e7f0              B        |L26.62|
                  |L26.92|
00005c  6820              LDR      r0,[r4,#0]            ;721
00005e  68c2              LDR      r2,[r0,#0xc]          ;721
000060  f0420202          ORR      r2,r2,#2              ;721
000064  60c2              STR      r2,[r0,#0xc]          ;721
000066  e00a              B        |L26.126|
                  |L26.104|
000068  6820              LDR      r0,[r4,#0]            ;728
00006a  68c2              LDR      r2,[r0,#0xc]          ;728
00006c  f0420204          ORR      r2,r2,#4              ;728
000070  60c2              STR      r2,[r0,#0xc]          ;728
000072  e004              B        |L26.126|
                  |L26.116|
000074  6820              LDR      r0,[r4,#0]            ;735
000076  68c2              LDR      r2,[r0,#0xc]          ;735
000078  f0420208          ORR      r2,r2,#8              ;735
00007c  60c2              STR      r2,[r0,#0xc]          ;735
                  |L26.126|
00007e  6820              LDR      r0,[r4,#0]            ;745
000080  68c2              LDR      r2,[r0,#0xc]          ;745
000082  f0420280          ORR      r2,r2,#0x80           ;745
000086  60c2              STR      r2,[r0,#0xc]          ;745
000088  2204              MOVS     r2,#4                 ;748
00008a  6820              LDR      r0,[r4,#0]            ;748
00008c  f7fffffe          BL       TIM_CCxNChannelCmd
000090  6820              LDR      r0,[r4,#0]            ;751
000092  6c41              LDR      r1,[r0,#0x44]         ;751
000094  f4414100          ORR      r1,r1,#0x8000         ;751
000098  6441              STR      r1,[r0,#0x44]         ;751
00009a  4914              LDR      r1,|L26.236|
00009c  6820              LDR      r0,[r4,#0]            ;754
00009e  4288              CMP      r0,r1                 ;754
0000a0  d011              BEQ      |L26.198|
0000a2  f1b04f80          CMP      r0,#0x40000000        ;754
0000a6  d00e              BEQ      |L26.198|
0000a8  4911              LDR      r1,|L26.240|
0000aa  4288              CMP      r0,r1                 ;754
0000ac  d00b              BEQ      |L26.198|
0000ae  4911              LDR      r1,|L26.244|
0000b0  4288              CMP      r0,r1                 ;754
0000b2  d008              BEQ      |L26.198|
0000b4  4910              LDR      r1,|L26.248|
0000b6  4288              CMP      r0,r1                 ;754
0000b8  d005              BEQ      |L26.198|
0000ba  4910              LDR      r1,|L26.252|
0000bc  4288              CMP      r0,r1                 ;754
0000be  d002              BEQ      |L26.198|
0000c0  490f              LDR      r1,|L26.256|
0000c2  4288              CMP      r0,r1                 ;754
0000c4  d10c              BNE      |L26.224|
                  |L26.198|
0000c6  6881              LDR      r1,[r0,#8]            ;756
0000c8  4a0e              LDR      r2,|L26.260|
0000ca  4011              ANDS     r1,r1,r2              ;756
0000cc  2906              CMP      r1,#6                 ;757
0000ce  d00b              BEQ      |L26.232|
0000d0  f5b13f80          CMP      r1,#0x10000           ;757
0000d4  d008              BEQ      |L26.232|
0000d6  6801              LDR      r1,[r0,#0]            ;759
0000d8  f0410101          ORR      r1,r1,#1              ;759
0000dc  6001              STR      r1,[r0,#0]            ;759
0000de  e003              B        |L26.232|
                  |L26.224|
0000e0  6801              LDR      r1,[r0,#0]            ;764
0000e2  f0410101          ORR      r1,r1,#1              ;764
0000e6  6001              STR      r1,[r0,#0]            ;764
                  |L26.232|
0000e8  2000              MOVS     r0,#0                 ;768
0000ea  bd10              POP      {r4,pc}
;;;770    
                          ENDP

                  |L26.236|
                          DCD      0x40012c00
                  |L26.240|
                          DCD      0x40000400
                  |L26.244|
                          DCD      0x40000800
                  |L26.248|
                          DCD      0x40000c00
                  |L26.252|
                          DCD      0x40013400
                  |L26.256|
                          DCD      0x40014000
                  |L26.260|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;667      */
;;;668    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;669    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;670      /* Check the parameters */
;;;671      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;672    
;;;673      /* Disable the Capture compare channel N */
;;;674      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;675    
;;;676      /* Disable the Main Output */
;;;677      __HAL_TIM_MOE_DISABLE(htim);
000010  6820              LDR      r0,[r4,#0]
000012  6a03              LDR      r3,[r0,#0x20]
000014  f2411111          MOV      r1,#0x1111
000018  420b              TST      r3,r1
00001a  f2404244          MOV      r2,#0x444
00001e  d106              BNE      |L27.46|
000020  6a03              LDR      r3,[r0,#0x20]
000022  4213              TST      r3,r2
000024  d103              BNE      |L27.46|
000026  6c43              LDR      r3,[r0,#0x44]
000028  f4234300          BIC      r3,r3,#0x8000
00002c  6443              STR      r3,[r0,#0x44]
                  |L27.46|
;;;678    
;;;679      /* Disable the Peripheral */
;;;680      __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  420b              TST      r3,r1
000034  d106              BNE      |L27.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d103              BNE      |L27.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L27.68|
;;;681    
;;;682      /* Set the TIM complementary channel state */
;;;683      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000044  2001              MOVS     r0,#1
000046  b13d              CBZ      r5,|L27.88|
000048  2d04              CMP      r5,#4
00004a  d008              BEQ      |L27.94|
00004c  2d08              CMP      r5,#8
00004e  d009              BEQ      |L27.100|
000050  f8840047          STRB     r0,[r4,#0x47]
                  |L27.84|
;;;684    
;;;685      /* Return function status */
;;;686      return HAL_OK;
000054  2000              MOVS     r0,#0
;;;687    }
000056  bd70              POP      {r4-r6,pc}
                  |L27.88|
000058  f8840044          STRB     r0,[r4,#0x44]         ;683
00005c  e7fa              B        |L27.84|
                  |L27.94|
00005e  f8840045          STRB     r0,[r4,#0x45]         ;683
000062  e7f7              B        |L27.84|
                  |L27.100|
000064  f8840046          STRB     r0,[r4,#0x46]         ;683
000068  e7f4              B        |L27.84|
;;;688    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;979      */
;;;980    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;981    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;982      /* Check the parameters */
;;;983      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;984    
;;;985      switch (Channel)
;;;986      {
;;;987        case TIM_CHANNEL_1:
;;;988        {
;;;989          /* Disable the TIM Output Compare DMA request */
;;;990          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;985
00000a  d004              BEQ      |L28.22|
00000c  2d04              CMP      r5,#4                 ;985
00000e  d00a              BEQ      |L28.38|
000010  2d08              CMP      r5,#8                 ;985
000012  d117              BNE      |L28.68|
000014  e00f              B        |L28.54|
                  |L28.22|
000016  68c1              LDR      r1,[r0,#0xc]
000018  f4217100          BIC      r1,r1,#0x200
00001c  60c1              STR      r1,[r0,#0xc]
;;;991          (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00001e  6a60              LDR      r0,[r4,#0x24]
000020  f7fffffe          BL       HAL_DMA_Abort_IT
;;;992          break;
000024  e00e              B        |L28.68|
                  |L28.38|
;;;993        }
;;;994    
;;;995        case TIM_CHANNEL_2:
;;;996        {
;;;997          /* Disable the TIM Output Compare DMA request */
;;;998          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000026  68c1              LDR      r1,[r0,#0xc]
000028  f4216180          BIC      r1,r1,#0x400
00002c  60c1              STR      r1,[r0,#0xc]
;;;999          (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1000         break;
000034  e006              B        |L28.68|
                  |L28.54|
;;;1001       }
;;;1002   
;;;1003       case TIM_CHANNEL_3:
;;;1004       {
;;;1005         /* Disable the TIM Output Compare DMA request */
;;;1006         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000036  68c1              LDR      r1,[r0,#0xc]
000038  f4216100          BIC      r1,r1,#0x800
00003c  60c1              STR      r1,[r0,#0xc]
;;;1007         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L28.68|
;;;1008         break;
;;;1009       }
;;;1010   
;;;1011       default:
;;;1012         break;
;;;1013     }
;;;1014   
;;;1015     /* Disable the Capture compare channel N */
;;;1016     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000044  2200              MOVS     r2,#0
000046  4629              MOV      r1,r5
000048  6820              LDR      r0,[r4,#0]
00004a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1017   
;;;1018     /* Disable the Main Output */
;;;1019     __HAL_TIM_MOE_DISABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6a01              LDR      r1,[r0,#0x20]
000052  f2411211          MOV      r2,#0x1111
000056  4211              TST      r1,r2
000058  f2404344          MOV      r3,#0x444
00005c  d106              BNE      |L28.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4219              TST      r1,r3
000062  d103              BNE      |L28.108|
000064  6c41              LDR      r1,[r0,#0x44]
000066  f4214100          BIC      r1,r1,#0x8000
00006a  6441              STR      r1,[r0,#0x44]
                  |L28.108|
;;;1020   
;;;1021     /* Disable the Peripheral */
;;;1022     __HAL_TIM_DISABLE(htim);
00006c  6820              LDR      r0,[r4,#0]
00006e  6a01              LDR      r1,[r0,#0x20]
000070  4211              TST      r1,r2
000072  d106              BNE      |L28.130|
000074  6a01              LDR      r1,[r0,#0x20]
000076  4219              TST      r1,r3
000078  d103              BNE      |L28.130|
00007a  6801              LDR      r1,[r0,#0]
00007c  f0210101          BIC      r1,r1,#1
000080  6001              STR      r1,[r0,#0]
                  |L28.130|
;;;1023   
;;;1024     /* Set the TIM complementary channel state */
;;;1025     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000082  2001              MOVS     r0,#1
000084  b13d              CBZ      r5,|L28.150|
000086  2d04              CMP      r5,#4
000088  d008              BEQ      |L28.156|
00008a  2d08              CMP      r5,#8
00008c  d009              BEQ      |L28.162|
00008e  f8840047          STRB     r0,[r4,#0x47]
                  |L28.146|
;;;1026   
;;;1027     /* Return function status */
;;;1028     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;1029   }
000094  bd70              POP      {r4-r6,pc}
                  |L28.150|
000096  f8840044          STRB     r0,[r4,#0x44]         ;1025
00009a  e7fa              B        |L28.146|
                  |L28.156|
00009c  f8840045          STRB     r0,[r4,#0x45]         ;1025
0000a0  e7f7              B        |L28.146|
                  |L28.162|
0000a2  f8840046          STRB     r0,[r4,#0x46]         ;1025
0000a6  e7f4              B        |L28.146|
;;;1030   
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;781      */
;;;782    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;783    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;784      uint32_t tmpccer;
;;;785      /* Check the parameters */
;;;786      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;787    
;;;788      switch (Channel)
;;;789      {
;;;790        case TIM_CHANNEL_1:
;;;791        {
;;;792          /* Disable the TIM Output Compare interrupt */
;;;793          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;788
00000a  d004              BEQ      |L29.22|
00000c  2d04              CMP      r5,#4                 ;788
00000e  d007              BEQ      |L29.32|
000010  2d08              CMP      r5,#8                 ;788
000012  d10e              BNE      |L29.50|
000014  e009              B        |L29.42|
                  |L29.22|
000016  68c1              LDR      r1,[r0,#0xc]
000018  f0210102          BIC      r1,r1,#2
00001c  60c1              STR      r1,[r0,#0xc]
;;;794          break;
00001e  e008              B        |L29.50|
                  |L29.32|
;;;795        }
;;;796    
;;;797        case TIM_CHANNEL_2:
;;;798        {
;;;799          /* Disable the TIM Output Compare interrupt */
;;;800          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0210104          BIC      r1,r1,#4
000026  60c1              STR      r1,[r0,#0xc]
;;;801          break;
000028  e003              B        |L29.50|
                  |L29.42|
;;;802        }
;;;803    
;;;804        case TIM_CHANNEL_3:
;;;805        {
;;;806          /* Disable the TIM Output Compare interrupt */
;;;807          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f0210108          BIC      r1,r1,#8
000030  60c1              STR      r1,[r0,#0xc]
                  |L29.50|
;;;808          break;
;;;809        }
;;;810    
;;;811        default:
;;;812          break;
;;;813      }
;;;814    
;;;815      /* Disable the Capture compare channel N */
;;;816      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000032  2200              MOVS     r2,#0
000034  4629              MOV      r1,r5
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       TIM_CCxNChannelCmd
;;;817    
;;;818      /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;819      tmpccer = htim->Instance->CCER;
00003c  6820              LDR      r0,[r4,#0]
00003e  6a02              LDR      r2,[r0,#0x20]
;;;820      if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
000040  f2404144          MOV      r1,#0x444
000044  420a              TST      r2,r1
000046  d103              BNE      |L29.80|
;;;821      {
;;;822        __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000048  68c2              LDR      r2,[r0,#0xc]
00004a  f0220280          BIC      r2,r2,#0x80
00004e  60c2              STR      r2,[r0,#0xc]
                  |L29.80|
;;;823      }
;;;824    
;;;825      /* Disable the Main Output */
;;;826      __HAL_TIM_MOE_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  f2411211          MOV      r2,#0x1111
000058  4213              TST      r3,r2
00005a  d106              BNE      |L29.106|
00005c  6a03              LDR      r3,[r0,#0x20]
00005e  420b              TST      r3,r1
000060  d103              BNE      |L29.106|
000062  6c43              LDR      r3,[r0,#0x44]
000064  f4234300          BIC      r3,r3,#0x8000
000068  6443              STR      r3,[r0,#0x44]
                  |L29.106|
;;;827    
;;;828      /* Disable the Peripheral */
;;;829      __HAL_TIM_DISABLE(htim);
00006a  6820              LDR      r0,[r4,#0]
00006c  6a03              LDR      r3,[r0,#0x20]
00006e  4213              TST      r3,r2
000070  d106              BNE      |L29.128|
000072  6a02              LDR      r2,[r0,#0x20]
000074  420a              TST      r2,r1
000076  d103              BNE      |L29.128|
000078  6801              LDR      r1,[r0,#0]
00007a  f0210101          BIC      r1,r1,#1
00007e  6001              STR      r1,[r0,#0]
                  |L29.128|
;;;830    
;;;831      /* Set the TIM complementary channel state */
;;;832      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000080  2001              MOVS     r0,#1
000082  b13d              CBZ      r5,|L29.148|
000084  2d04              CMP      r5,#4
000086  d008              BEQ      |L29.154|
000088  2d08              CMP      r5,#8
00008a  d009              BEQ      |L29.160|
00008c  f8840047          STRB     r0,[r4,#0x47]
                  |L29.144|
;;;833    
;;;834      /* Return function status */
;;;835      return HAL_OK;
000090  2000              MOVS     r0,#0
;;;836    }
000092  bd70              POP      {r4-r6,pc}
                  |L29.148|
000094  f8840044          STRB     r0,[r4,#0x44]         ;832
000098  e7fa              B        |L29.144|
                  |L29.154|
00009a  f8840045          STRB     r0,[r4,#0x45]         ;832
00009e  e7f7              B        |L29.144|
                  |L29.160|
0000a0  f8840046          STRB     r0,[r4,#0x46]         ;832
0000a4  e7f4              B        |L29.144|
;;;837    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1521     */
;;;1522   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1523   {
000002  4604              MOV      r4,r0
;;;1524     uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L30.28|
000008  2500              MOVS     r5,#0
                  |L30.10|
;;;1525     HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
00000a  f8140f3e          LDRB     r0,[r4,#0x3e]!
;;;1526     HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
00000e  7862              LDRB     r2,[r4,#1]
;;;1527     HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
000010  79a3              LDRB     r3,[r4,#6]
;;;1528     HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
000012  79e6              LDRB     r6,[r4,#7]
000014  3c3e              SUBS     r4,r4,#0x3e
;;;1529   
;;;1530     /* Check the parameters */
;;;1531     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1532   
;;;1533     /* Check the TIM channels state */
;;;1534      if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000016  2801              CMP      r0,#1
000018  d108              BNE      |L30.44|
00001a  e001              B        |L30.32|
                  |L30.28|
00001c  2504              MOVS     r5,#4                 ;1524
00001e  e7f4              B        |L30.10|
                  |L30.32|
;;;1535         || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
000020  2a01              CMP      r2,#1
000022  d103              BNE      |L30.44|
;;;1536         || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000024  2b01              CMP      r3,#1
000026  d101              BNE      |L30.44|
;;;1537         || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
000028  2e01              CMP      r6,#1
00002a  d001              BEQ      |L30.48|
                  |L30.44|
;;;1538     {
;;;1539       return HAL_ERROR;
00002c  2001              MOVS     r0,#1
;;;1540     }
;;;1541   
;;;1542     /* Set the TIM channels state */
;;;1543     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1544     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1545     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1546     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1547   
;;;1548     /* Enable the complementary One Pulse output channel and the Input Capture channel */
;;;1549     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
;;;1550     TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
;;;1551   
;;;1552     /* Enable the Main Output */
;;;1553     __HAL_TIM_MOE_ENABLE(htim);
;;;1554   
;;;1555     /* Return function status */
;;;1556     return HAL_OK;
;;;1557   }
00002e  bd70              POP      {r4-r6,pc}
                  |L30.48|
000030  2002              MOVS     r0,#2                 ;1543
000032  f884003e          STRB     r0,[r4,#0x3e]         ;1543
000036  f884003f          STRB     r0,[r4,#0x3f]         ;1544
00003a  f8840044          STRB     r0,[r4,#0x44]         ;1545
00003e  f8840045          STRB     r0,[r4,#0x45]         ;1546
000042  2204              MOVS     r2,#4                 ;1549
000044  6820              LDR      r0,[r4,#0]            ;1549
000046  f7fffffe          BL       TIM_CCxNChannelCmd
00004a  2201              MOVS     r2,#1                 ;1550
00004c  4629              MOV      r1,r5                 ;1550
00004e  6820              LDR      r0,[r4,#0]            ;1550
000050  f7fffffe          BL       TIM_CCxChannelCmd
000054  6820              LDR      r0,[r4,#0]            ;1553
000056  6c41              LDR      r1,[r0,#0x44]         ;1553
000058  f4414100          ORR      r1,r1,#0x8000         ;1553
00005c  6441              STR      r1,[r0,#0x44]         ;1553
00005e  2000              MOVS     r0,#0                 ;1556
000060  bd70              POP      {r4-r6,pc}
;;;1558   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1609     */
;;;1610   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1611   {
000002  4604              MOV      r4,r0
;;;1612     uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L31.28|
000008  2500              MOVS     r5,#0
                  |L31.10|
;;;1613     HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
00000a  f8143f3e          LDRB     r3,[r4,#0x3e]!
;;;1614     HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
00000e  7866              LDRB     r6,[r4,#1]
;;;1615     HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
000010  79a0              LDRB     r0,[r4,#6]
;;;1616     HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
000012  79e2              LDRB     r2,[r4,#7]
000014  3c3e              SUBS     r4,r4,#0x3e
;;;1617   
;;;1618     /* Check the parameters */
;;;1619     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1620   
;;;1621     /* Check the TIM channels state */
;;;1622      if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000016  2b01              CMP      r3,#1
000018  d108              BNE      |L31.44|
00001a  e001              B        |L31.32|
                  |L31.28|
00001c  2504              MOVS     r5,#4                 ;1612
00001e  e7f4              B        |L31.10|
                  |L31.32|
;;;1623         || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
000020  2e01              CMP      r6,#1
000022  d103              BNE      |L31.44|
;;;1624         || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000024  2801              CMP      r0,#1
000026  d101              BNE      |L31.44|
;;;1625         || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
000028  2a01              CMP      r2,#1
00002a  d001              BEQ      |L31.48|
                  |L31.44|
;;;1626     {
;;;1627       return HAL_ERROR;
00002c  2001              MOVS     r0,#1
;;;1628     }
;;;1629   
;;;1630     /* Set the TIM channels state */
;;;1631     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1632     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1633     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1634     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1635   
;;;1636     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1637     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;1638   
;;;1639     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1640     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;1641   
;;;1642     /* Enable the complementary One Pulse output channel and the Input Capture channel */
;;;1643     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
;;;1644     TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
;;;1645   
;;;1646     /* Enable the Main Output */
;;;1647     __HAL_TIM_MOE_ENABLE(htim);
;;;1648   
;;;1649     /* Return function status */
;;;1650     return HAL_OK;
;;;1651   }
00002e  bd70              POP      {r4-r6,pc}
                  |L31.48|
000030  2002              MOVS     r0,#2                 ;1631
000032  f884003e          STRB     r0,[r4,#0x3e]         ;1631
000036  f884003f          STRB     r0,[r4,#0x3f]         ;1632
00003a  f8840044          STRB     r0,[r4,#0x44]         ;1633
00003e  f8840045          STRB     r0,[r4,#0x45]         ;1634
000042  6820              LDR      r0,[r4,#0]            ;1637
000044  68c2              LDR      r2,[r0,#0xc]          ;1637
000046  f0420202          ORR      r2,r2,#2              ;1637
00004a  60c2              STR      r2,[r0,#0xc]          ;1637
00004c  6820              LDR      r0,[r4,#0]            ;1640
00004e  68c2              LDR      r2,[r0,#0xc]          ;1640
000050  f0420204          ORR      r2,r2,#4              ;1640
000054  60c2              STR      r2,[r0,#0xc]          ;1640
000056  2204              MOVS     r2,#4                 ;1643
000058  6820              LDR      r0,[r4,#0]            ;1643
00005a  f7fffffe          BL       TIM_CCxNChannelCmd
00005e  2201              MOVS     r2,#1                 ;1644
000060  4629              MOV      r1,r5                 ;1644
000062  6820              LDR      r0,[r4,#0]            ;1644
000064  f7fffffe          BL       TIM_CCxChannelCmd
000068  6820              LDR      r0,[r4,#0]            ;1647
00006a  6c41              LDR      r1,[r0,#0x44]         ;1647
00006c  f4414100          ORR      r1,r1,#0x8000         ;1647
000070  6441              STR      r1,[r0,#0x44]         ;1647
000072  2000              MOVS     r0,#0                 ;1650
000074  bd70              POP      {r4-r6,pc}
;;;1652   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1570     */
;;;1571   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1572   {
000002  4604              MOV      r4,r0
;;;1573     uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
000004  2900              CMP      r1,#0
000006  d02b              BEQ      |L32.96|
000008  2500              MOVS     r5,#0
                  |L32.10|
;;;1574   
;;;1575     /* Check the parameters */
;;;1576     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1577   
;;;1578     /* Disable the complementary One Pulse output channel and the Input Capture channel */
;;;1579     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
00000a  2200              MOVS     r2,#0
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1580     TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
000012  2200              MOVS     r2,#0
000014  4629              MOV      r1,r5
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       TIM_CCxChannelCmd
;;;1581   
;;;1582     /* Disable the Main Output */
;;;1583     __HAL_TIM_MOE_DISABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6a01              LDR      r1,[r0,#0x20]
000020  f2411311          MOV      r3,#0x1111
000024  4219              TST      r1,r3
000026  f2404244          MOV      r2,#0x444
00002a  d106              BNE      |L32.58|
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  4211              TST      r1,r2
000030  d103              BNE      |L32.58|
000032  6c41              LDR      r1,[r0,#0x44]
000034  f4214100          BIC      r1,r1,#0x8000
000038  6441              STR      r1,[r0,#0x44]
                  |L32.58|
;;;1584   
;;;1585     /* Disable the Peripheral */
;;;1586     __HAL_TIM_DISABLE(htim);
00003a  6820              LDR      r0,[r4,#0]
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4219              TST      r1,r3
000040  d106              BNE      |L32.80|
000042  6a01              LDR      r1,[r0,#0x20]
000044  4211              TST      r1,r2
000046  d103              BNE      |L32.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L32.80|
;;;1587   
;;;1588     /* Set the TIM  channels state */
;;;1589     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000050  2001              MOVS     r0,#1
000052  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;1590     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000056  7060              STRB     r0,[r4,#1]
;;;1591     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000058  71a0              STRB     r0,[r4,#6]
;;;1592     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00005a  71e0              STRB     r0,[r4,#7]
;;;1593   
;;;1594     /* Return function status */
;;;1595     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;1596   }
00005e  bd70              POP      {r4-r6,pc}
                  |L32.96|
000060  2504              MOVS     r5,#4                 ;1573
000062  e7d2              B        |L32.10|
;;;1597   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1664     */
;;;1665   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1666   {
000002  4604              MOV      r4,r0
;;;1667     uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
000004  2900              CMP      r1,#0
000006  d035              BEQ      |L33.116|
000008  2500              MOVS     r5,#0
                  |L33.10|
;;;1668   
;;;1669     /* Check the parameters */
;;;1670     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1671   
;;;1672     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1673     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000a  6820              LDR      r0,[r4,#0]
00000c  68c2              LDR      r2,[r0,#0xc]
00000e  f0220202          BIC      r2,r2,#2
000012  60c2              STR      r2,[r0,#0xc]
;;;1674   
;;;1675     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1676     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000014  6820              LDR      r0,[r4,#0]
000016  68c2              LDR      r2,[r0,#0xc]
000018  f0220204          BIC      r2,r2,#4
00001c  60c2              STR      r2,[r0,#0xc]
;;;1677   
;;;1678     /* Disable the complementary One Pulse output channel and the Input Capture channel */
;;;1679     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
00001e  2200              MOVS     r2,#0
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1680     TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  4629              MOV      r1,r5
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1681   
;;;1682     /* Disable the Main Output */
;;;1683     __HAL_TIM_MOE_DISABLE(htim);
000030  6820              LDR      r0,[r4,#0]
000032  6a02              LDR      r2,[r0,#0x20]
000034  f2411311          MOV      r3,#0x1111
000038  421a              TST      r2,r3
00003a  f2404144          MOV      r1,#0x444
00003e  d106              BNE      |L33.78|
000040  6a02              LDR      r2,[r0,#0x20]
000042  420a              TST      r2,r1
000044  d103              BNE      |L33.78|
000046  6c42              LDR      r2,[r0,#0x44]
000048  f4224200          BIC      r2,r2,#0x8000
00004c  6442              STR      r2,[r0,#0x44]
                  |L33.78|
;;;1684   
;;;1685     /* Disable the Peripheral */
;;;1686     __HAL_TIM_DISABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6a02              LDR      r2,[r0,#0x20]
000052  421a              TST      r2,r3
000054  d106              BNE      |L33.100|
000056  6a02              LDR      r2,[r0,#0x20]
000058  420a              TST      r2,r1
00005a  d103              BNE      |L33.100|
00005c  6801              LDR      r1,[r0,#0]
00005e  f0210101          BIC      r1,r1,#1
000062  6001              STR      r1,[r0,#0]
                  |L33.100|
;;;1687   
;;;1688     /* Set the TIM  channels state */
;;;1689     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000064  2001              MOVS     r0,#1
000066  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;1690     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00006a  7060              STRB     r0,[r4,#1]
;;;1691     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00006c  71a0              STRB     r0,[r4,#6]
;;;1692     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00006e  71e0              STRB     r0,[r4,#7]
;;;1693   
;;;1694     /* Return function status */
;;;1695     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1696   }
000072  bd70              POP      {r4-r6,pc}
                  |L33.116|
000074  2504              MOVS     r5,#4                 ;1667
000076  e7c8              B        |L33.10|
;;;1697   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start PROC
;;;1074     */
;;;1075   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1076   {
000002  4604              MOV      r4,r0
;;;1077     uint32_t tmpsmcr;
;;;1078   
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1081   
;;;1082     /* Check the TIM complementary channel state */
;;;1083     if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L34.28|
000008  2904              CMP      r1,#4
00000a  d00a              BEQ      |L34.34|
00000c  2908              CMP      r1,#8
00000e  d00b              BEQ      |L34.40|
000010  f8940047          LDRB     r0,[r4,#0x47]
                  |L34.20|
000014  2801              CMP      r0,#1
000016  d00a              BEQ      |L34.46|
;;;1084     {
;;;1085       return HAL_ERROR;
000018  2001              MOVS     r0,#1
;;;1086     }
;;;1087   
;;;1088     /* Set the TIM complementary channel state */
;;;1089     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1090   
;;;1091     /* Enable the complementary PWM output  */
;;;1092     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1093   
;;;1094     /* Enable the Main Output */
;;;1095     __HAL_TIM_MOE_ENABLE(htim);
;;;1096   
;;;1097     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1098     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;1099     {
;;;1100       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1101       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1102       {
;;;1103         __HAL_TIM_ENABLE(htim);
;;;1104       }
;;;1105     }
;;;1106     else
;;;1107     {
;;;1108       __HAL_TIM_ENABLE(htim);
;;;1109     }
;;;1110   
;;;1111     /* Return function status */
;;;1112     return HAL_OK;
;;;1113   }
00001a  bd10              POP      {r4,pc}
                  |L34.28|
00001c  f8940044          LDRB     r0,[r4,#0x44]         ;1083
000020  e7f8              B        |L34.20|
                  |L34.34|
000022  f8940045          LDRB     r0,[r4,#0x45]         ;1083
000026  e7f5              B        |L34.20|
                  |L34.40|
000028  f8940046          LDRB     r0,[r4,#0x46]         ;1083
00002c  e7f2              B        |L34.20|
                  |L34.46|
00002e  2002              MOVS     r0,#2                 ;1089
000030  b389              CBZ      r1,|L34.150|
000032  2904              CMP      r1,#4                 ;1089
000034  d033              BEQ      |L34.158|
000036  2908              CMP      r1,#8                 ;1089
000038  d034              BEQ      |L34.164|
00003a  f8840047          STRB     r0,[r4,#0x47]         ;1089
                  |L34.62|
00003e  2204              MOVS     r2,#4                 ;1092
000040  6820              LDR      r0,[r4,#0]            ;1092
000042  f7fffffe          BL       TIM_CCxNChannelCmd
000046  6820              LDR      r0,[r4,#0]            ;1095
000048  6c41              LDR      r1,[r0,#0x44]         ;1095
00004a  f4414100          ORR      r1,r1,#0x8000         ;1095
00004e  6441              STR      r1,[r0,#0x44]         ;1095
000050  4919              LDR      r1,|L34.184|
000052  6820              LDR      r0,[r4,#0]            ;1098
000054  4288              CMP      r0,r1                 ;1098
000056  d011              BEQ      |L34.124|
000058  f1b04f80          CMP      r0,#0x40000000        ;1098
00005c  d00e              BEQ      |L34.124|
00005e  4917              LDR      r1,|L34.188|
000060  4288              CMP      r0,r1                 ;1098
000062  d00b              BEQ      |L34.124|
000064  4916              LDR      r1,|L34.192|
000066  4288              CMP      r0,r1                 ;1098
000068  d008              BEQ      |L34.124|
00006a  4916              LDR      r1,|L34.196|
00006c  4288              CMP      r0,r1                 ;1098
00006e  d005              BEQ      |L34.124|
000070  4915              LDR      r1,|L34.200|
000072  4288              CMP      r0,r1                 ;1098
000074  d002              BEQ      |L34.124|
000076  4915              LDR      r1,|L34.204|
000078  4288              CMP      r0,r1                 ;1098
00007a  d116              BNE      |L34.170|
                  |L34.124|
00007c  6881              LDR      r1,[r0,#8]            ;1100
00007e  4a14              LDR      r2,|L34.208|
000080  4011              ANDS     r1,r1,r2              ;1100
000082  2906              CMP      r1,#6                 ;1101
000084  d015              BEQ      |L34.178|
000086  f5b13f80          CMP      r1,#0x10000           ;1101
00008a  d012              BEQ      |L34.178|
00008c  6801              LDR      r1,[r0,#0]            ;1103
00008e  f0410101          ORR      r1,r1,#1              ;1103
000092  6001              STR      r1,[r0,#0]            ;1103
000094  e00d              B        |L34.178|
                  |L34.150|
000096  e7ff              B        |L34.152|
                  |L34.152|
000098  f8840044          STRB     r0,[r4,#0x44]         ;1089
00009c  e7cf              B        |L34.62|
                  |L34.158|
00009e  f8840045          STRB     r0,[r4,#0x45]         ;1089
0000a2  e7cc              B        |L34.62|
                  |L34.164|
0000a4  f8840046          STRB     r0,[r4,#0x46]         ;1089
0000a8  e7c9              B        |L34.62|
                  |L34.170|
0000aa  6801              LDR      r1,[r0,#0]            ;1108
0000ac  f0410101          ORR      r1,r1,#1              ;1108
0000b0  6001              STR      r1,[r0,#0]            ;1108
                  |L34.178|
0000b2  2000              MOVS     r0,#0                 ;1112
0000b4  bd10              POP      {r4,pc}
;;;1114   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L34.184|
                          DCD      0x40012c00
                  |L34.188|
                          DCD      0x40000400
                  |L34.192|
                          DCD      0x40000800
                  |L34.196|
                          DCD      0x40000c00
                  |L34.200|
                          DCD      0x40013400
                  |L34.204|
                          DCD      0x40014000
                  |L34.208|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1307     */
;;;1308   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1309   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  4611              MOV      r1,r2
;;;1310     uint32_t tmpsmcr;
;;;1311   
;;;1312     /* Check the parameters */
;;;1313     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1314   
;;;1315     /* Set the TIM complementary channel state */
;;;1316     if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
00000a  2d00              CMP      r5,#0
00000c  d013              BEQ      |L35.54|
00000e  2d04              CMP      r5,#4
000010  d014              BEQ      |L35.60|
000012  2d08              CMP      r5,#8
000014  d015              BEQ      |L35.66|
000016  f8940047          LDRB     r0,[r4,#0x47]
                  |L35.26|
00001a  2802              CMP      r0,#2
00001c  d014              BEQ      |L35.72|
;;;1317     {
;;;1318       return HAL_BUSY;
;;;1319     }
;;;1320     else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
00001e  b1ad              CBZ      r5,|L35.76|
000020  2d04              CMP      r5,#4
000022  d016              BEQ      |L35.82|
000024  2d08              CMP      r5,#8
000026  d017              BEQ      |L35.88|
000028  f8940047          LDRB     r0,[r4,#0x47]
                  |L35.44|
00002c  2801              CMP      r0,#1
00002e  d016              BEQ      |L35.94|
;;;1321     {
;;;1322       if ((pData == NULL) && (Length > 0U))
;;;1323       {
;;;1324         return HAL_ERROR;
;;;1325       }
;;;1326       else
;;;1327       {
;;;1328         TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1329       }
;;;1330     }
;;;1331     else
;;;1332     {
;;;1333       return HAL_ERROR;
000030  2001              MOVS     r0,#1
                  |L35.50|
;;;1334     }
;;;1335   
;;;1336     switch (Channel)
;;;1337     {
;;;1338       case TIM_CHANNEL_1:
;;;1339       {
;;;1340         /* Set the DMA compare callbacks */
;;;1341         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
;;;1342         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1343   
;;;1344         /* Set the DMA error callback */
;;;1345         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
;;;1346   
;;;1347         /* Enable the DMA channel */
;;;1348         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;1349         {
;;;1350           /* Return error status */
;;;1351           return HAL_ERROR;
;;;1352         }
;;;1353         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1354         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1355         break;
;;;1356       }
;;;1357   
;;;1358       case TIM_CHANNEL_2:
;;;1359       {
;;;1360         /* Set the DMA compare callbacks */
;;;1361         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
;;;1362         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1363   
;;;1364         /* Set the DMA error callback */
;;;1365         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
;;;1366   
;;;1367         /* Enable the DMA channel */
;;;1368         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;1369         {
;;;1370           /* Return error status */
;;;1371           return HAL_ERROR;
;;;1372         }
;;;1373         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1374         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1375         break;
;;;1376       }
;;;1377   
;;;1378       case TIM_CHANNEL_3:
;;;1379       {
;;;1380         /* Set the DMA compare callbacks */
;;;1381         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
;;;1382         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1383   
;;;1384         /* Set the DMA error callback */
;;;1385         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
;;;1386   
;;;1387         /* Enable the DMA channel */
;;;1388         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;1389         {
;;;1390           /* Return error status */
;;;1391           return HAL_ERROR;
;;;1392         }
;;;1393         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1394         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1395         break;
;;;1396       }
;;;1397   
;;;1398       default:
;;;1399         break;
;;;1400     }
;;;1401   
;;;1402     /* Enable the complementary PWM output  */
;;;1403     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1404   
;;;1405     /* Enable the Main Output */
;;;1406     __HAL_TIM_MOE_ENABLE(htim);
;;;1407   
;;;1408     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1409     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;1410     {
;;;1411       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1412       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1413       {
;;;1414         __HAL_TIM_ENABLE(htim);
;;;1415       }
;;;1416     }
;;;1417     else
;;;1418     {
;;;1419       __HAL_TIM_ENABLE(htim);
;;;1420     }
;;;1421   
;;;1422     /* Return function status */
;;;1423     return HAL_OK;
;;;1424   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L35.54|
000036  f8940044          LDRB     r0,[r4,#0x44]         ;1316
00003a  e7ee              B        |L35.26|
                  |L35.60|
00003c  f8940045          LDRB     r0,[r4,#0x45]         ;1316
000040  e7eb              B        |L35.26|
                  |L35.66|
000042  f8940046          LDRB     r0,[r4,#0x46]         ;1316
000046  e7e8              B        |L35.26|
                  |L35.72|
000048  2002              MOVS     r0,#2                 ;1318
00004a  e7f2              B        |L35.50|
                  |L35.76|
00004c  f8940044          LDRB     r0,[r4,#0x44]         ;1320
000050  e7ec              B        |L35.44|
                  |L35.82|
000052  f8940045          LDRB     r0,[r4,#0x45]         ;1320
000056  e7e9              B        |L35.44|
                  |L35.88|
000058  f8940046          LDRB     r0,[r4,#0x46]         ;1320
00005c  e7e6              B        |L35.44|
                  |L35.94|
00005e  b911              CBNZ     r1,|L35.102|
000060  b10b              CBZ      r3,|L35.102|
000062  2001              MOVS     r0,#1                 ;1324
000064  e7e5              B        |L35.50|
                  |L35.102|
000066  2002              MOVS     r0,#2                 ;1318
000068  b135              CBZ      r5,|L35.120|
00006a  2d04              CMP      r5,#4                 ;1328
00006c  d007              BEQ      |L35.126|
00006e  2d08              CMP      r5,#8                 ;1328
000070  d008              BEQ      |L35.132|
000072  f8840047          STRB     r0,[r4,#0x47]         ;1328
000076  e007              B        |L35.136|
                  |L35.120|
000078  f8840044          STRB     r0,[r4,#0x44]         ;1328
00007c  e004              B        |L35.136|
                  |L35.126|
00007e  f8840045          STRB     r0,[r4,#0x45]         ;1328
000082  e001              B        |L35.136|
                  |L35.132|
000084  f8840046          STRB     r0,[r4,#0x46]         ;1328
                  |L35.136|
000088  483b              LDR      r0,|L35.376|
00008a  4a3c              LDR      r2,|L35.380|
00008c  4e3c              LDR      r6,|L35.384|
00008e  b125              CBZ      r5,|L35.154|
000090  2d04              CMP      r5,#4                 ;1336
000092  d016              BEQ      |L35.194|
000094  2d08              CMP      r5,#8                 ;1336
000096  d13b              BNE      |L35.272|
000098  e027              B        |L35.234|
                  |L35.154|
00009a  6a67              LDR      r7,[r4,#0x24]         ;1341
00009c  62f8              STR      r0,[r7,#0x2c]         ;1341
00009e  6a60              LDR      r0,[r4,#0x24]         ;1342
0000a0  6302              STR      r2,[r0,#0x30]         ;1342
0000a2  6a60              LDR      r0,[r4,#0x24]         ;1345
0000a4  6346              STR      r6,[r0,#0x34]         ;1345
0000a6  6822              LDR      r2,[r4,#0]            ;1348
0000a8  6a60              LDR      r0,[r4,#0x24]         ;1348
0000aa  3234              ADDS     r2,r2,#0x34           ;1348
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  b108              CBZ      r0,|L35.182|
0000b2  2001              MOVS     r0,#1                 ;1351
0000b4  e7bd              B        |L35.50|
                  |L35.182|
0000b6  6820              LDR      r0,[r4,#0]            ;1354
0000b8  68c1              LDR      r1,[r0,#0xc]          ;1354
0000ba  f4417100          ORR      r1,r1,#0x200          ;1354
0000be  60c1              STR      r1,[r0,#0xc]          ;1354
0000c0  e026              B        |L35.272|
                  |L35.194|
0000c2  6aa7              LDR      r7,[r4,#0x28]         ;1361
0000c4  62f8              STR      r0,[r7,#0x2c]         ;1361
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;1362
0000c8  6302              STR      r2,[r0,#0x30]         ;1362
0000ca  6aa0              LDR      r0,[r4,#0x28]         ;1365
0000cc  6346              STR      r6,[r0,#0x34]         ;1365
0000ce  6822              LDR      r2,[r4,#0]            ;1368
0000d0  6aa0              LDR      r0,[r4,#0x28]         ;1368
0000d2  3238              ADDS     r2,r2,#0x38           ;1368
0000d4  f7fffffe          BL       HAL_DMA_Start_IT
0000d8  b108              CBZ      r0,|L35.222|
0000da  2001              MOVS     r0,#1                 ;1371
0000dc  e7a9              B        |L35.50|
                  |L35.222|
0000de  6820              LDR      r0,[r4,#0]            ;1374
0000e0  68c1              LDR      r1,[r0,#0xc]          ;1374
0000e2  f4416180          ORR      r1,r1,#0x400          ;1374
0000e6  60c1              STR      r1,[r0,#0xc]          ;1374
0000e8  e012              B        |L35.272|
                  |L35.234|
0000ea  6ae7              LDR      r7,[r4,#0x2c]         ;1381
0000ec  62f8              STR      r0,[r7,#0x2c]         ;1381
0000ee  6ae0              LDR      r0,[r4,#0x2c]         ;1382
0000f0  6302              STR      r2,[r0,#0x30]         ;1382
0000f2  6ae0              LDR      r0,[r4,#0x2c]         ;1385
0000f4  6346              STR      r6,[r0,#0x34]         ;1385
0000f6  6822              LDR      r2,[r4,#0]            ;1388
0000f8  6ae0              LDR      r0,[r4,#0x2c]         ;1388
0000fa  323c              ADDS     r2,r2,#0x3c           ;1388
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  b108              CBZ      r0,|L35.262|
000102  2001              MOVS     r0,#1                 ;1391
000104  e795              B        |L35.50|
                  |L35.262|
000106  6820              LDR      r0,[r4,#0]            ;1394
000108  68c1              LDR      r1,[r0,#0xc]          ;1394
00010a  f4416100          ORR      r1,r1,#0x800          ;1394
00010e  60c1              STR      r1,[r0,#0xc]          ;1394
                  |L35.272|
000110  2204              MOVS     r2,#4                 ;1403
000112  4629              MOV      r1,r5                 ;1403
000114  6820              LDR      r0,[r4,#0]            ;1403
000116  f7fffffe          BL       TIM_CCxNChannelCmd
00011a  6820              LDR      r0,[r4,#0]            ;1406
00011c  6c41              LDR      r1,[r0,#0x44]         ;1406
00011e  f4414100          ORR      r1,r1,#0x8000         ;1406
000122  6441              STR      r1,[r0,#0x44]         ;1406
000124  4917              LDR      r1,|L35.388|
000126  6820              LDR      r0,[r4,#0]            ;1409
000128  4288              CMP      r0,r1                 ;1409
00012a  d011              BEQ      |L35.336|
00012c  f1b04f80          CMP      r0,#0x40000000        ;1409
000130  d00e              BEQ      |L35.336|
000132  4915              LDR      r1,|L35.392|
000134  4288              CMP      r0,r1                 ;1409
000136  d00b              BEQ      |L35.336|
000138  4914              LDR      r1,|L35.396|
00013a  4288              CMP      r0,r1                 ;1409
00013c  d008              BEQ      |L35.336|
00013e  4914              LDR      r1,|L35.400|
000140  4288              CMP      r0,r1                 ;1409
000142  d005              BEQ      |L35.336|
000144  4913              LDR      r1,|L35.404|
000146  4288              CMP      r0,r1                 ;1409
000148  d002              BEQ      |L35.336|
00014a  4913              LDR      r1,|L35.408|
00014c  4288              CMP      r0,r1                 ;1409
00014e  d10c              BNE      |L35.362|
                  |L35.336|
000150  6881              LDR      r1,[r0,#8]            ;1411
000152  4a12              LDR      r2,|L35.412|
000154  4011              ANDS     r1,r1,r2              ;1411
000156  2906              CMP      r1,#6                 ;1412
000158  d00b              BEQ      |L35.370|
00015a  f5b13f80          CMP      r1,#0x10000           ;1412
00015e  d008              BEQ      |L35.370|
000160  6801              LDR      r1,[r0,#0]            ;1414
000162  f0410101          ORR      r1,r1,#1              ;1414
000166  6001              STR      r1,[r0,#0]            ;1414
000168  e003              B        |L35.370|
                  |L35.362|
00016a  6801              LDR      r1,[r0,#0]            ;1419
00016c  f0410101          ORR      r1,r1,#1              ;1419
000170  6001              STR      r1,[r0,#0]            ;1419
                  |L35.370|
000172  2000              MOVS     r0,#0                 ;1423
000174  e75d              B        |L35.50|
;;;1425   
                          ENDP

000176  0000              DCW      0x0000
                  |L35.376|
                          DCD      TIM_DMADelayPulseNCplt
                  |L35.380|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L35.384|
                          DCD      TIM_DMAErrorCCxN
                  |L35.388|
                          DCD      0x40012c00
                  |L35.392|
                          DCD      0x40000400
                  |L35.396|
                          DCD      0x40000800
                  |L35.400|
                          DCD      0x40000c00
                  |L35.404|
                          DCD      0x40013400
                  |L35.408|
                          DCD      0x40014000
                  |L35.412|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;1156     */
;;;1157   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1158   {
000002  4604              MOV      r4,r0
;;;1159     uint32_t tmpsmcr;
;;;1160   
;;;1161     /* Check the parameters */
;;;1162     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1163   
;;;1164     /* Check the TIM complementary channel state */
;;;1165     if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L36.28|
000008  2904              CMP      r1,#4
00000a  d00a              BEQ      |L36.34|
00000c  2908              CMP      r1,#8
00000e  d00b              BEQ      |L36.40|
000010  f8940047          LDRB     r0,[r4,#0x47]
                  |L36.20|
000014  2801              CMP      r0,#1
000016  d00a              BEQ      |L36.46|
;;;1166     {
;;;1167       return HAL_ERROR;
000018  2001              MOVS     r0,#1
;;;1168     }
;;;1169   
;;;1170     /* Set the TIM complementary channel state */
;;;1171     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1172   
;;;1173     switch (Channel)
;;;1174     {
;;;1175       case TIM_CHANNEL_1:
;;;1176       {
;;;1177         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1178         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;1179         break;
;;;1180       }
;;;1181   
;;;1182       case TIM_CHANNEL_2:
;;;1183       {
;;;1184         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1185         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;1186         break;
;;;1187       }
;;;1188   
;;;1189       case TIM_CHANNEL_3:
;;;1190       {
;;;1191         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1192         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1193         break;
;;;1194       }
;;;1195   
;;;1196       default:
;;;1197         break;
;;;1198     }
;;;1199   
;;;1200     /* Enable the TIM Break interrupt */
;;;1201     __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
;;;1202   
;;;1203     /* Enable the complementary PWM output  */
;;;1204     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1205   
;;;1206     /* Enable the Main Output */
;;;1207     __HAL_TIM_MOE_ENABLE(htim);
;;;1208   
;;;1209     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1210     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;1211     {
;;;1212       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1213       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1214       {
;;;1215         __HAL_TIM_ENABLE(htim);
;;;1216       }
;;;1217     }
;;;1218     else
;;;1219     {
;;;1220       __HAL_TIM_ENABLE(htim);
;;;1221     }
;;;1222   
;;;1223     /* Return function status */
;;;1224     return HAL_OK;
;;;1225   }
00001a  bd10              POP      {r4,pc}
                  |L36.28|
00001c  f8940044          LDRB     r0,[r4,#0x44]         ;1165
000020  e7f8              B        |L36.20|
                  |L36.34|
000022  f8940045          LDRB     r0,[r4,#0x45]         ;1165
000026  e7f5              B        |L36.20|
                  |L36.40|
000028  f8940046          LDRB     r0,[r4,#0x46]         ;1165
00002c  e7f2              B        |L36.20|
                  |L36.46|
00002e  2002              MOVS     r0,#2                 ;1171
000030  b159              CBZ      r1,|L36.74|
000032  2904              CMP      r1,#4                 ;1171
000034  d00c              BEQ      |L36.80|
000036  2908              CMP      r1,#8                 ;1171
000038  d00d              BEQ      |L36.86|
00003a  f8840047          STRB     r0,[r4,#0x47]         ;1171
                  |L36.62|
00003e  b169              CBZ      r1,|L36.92|
000040  2904              CMP      r1,#4                 ;1173
000042  d011              BEQ      |L36.104|
000044  2908              CMP      r1,#8                 ;1173
000046  d11a              BNE      |L36.126|
000048  e014              B        |L36.116|
                  |L36.74|
00004a  f8840044          STRB     r0,[r4,#0x44]         ;1171
00004e  e7f6              B        |L36.62|
                  |L36.80|
000050  f8840045          STRB     r0,[r4,#0x45]         ;1171
000054  e7f3              B        |L36.62|
                  |L36.86|
000056  f8840046          STRB     r0,[r4,#0x46]         ;1171
00005a  e7f0              B        |L36.62|
                  |L36.92|
00005c  6820              LDR      r0,[r4,#0]            ;1178
00005e  68c2              LDR      r2,[r0,#0xc]          ;1178
000060  f0420202          ORR      r2,r2,#2              ;1178
000064  60c2              STR      r2,[r0,#0xc]          ;1178
000066  e00a              B        |L36.126|
                  |L36.104|
000068  6820              LDR      r0,[r4,#0]            ;1185
00006a  68c2              LDR      r2,[r0,#0xc]          ;1185
00006c  f0420204          ORR      r2,r2,#4              ;1185
000070  60c2              STR      r2,[r0,#0xc]          ;1185
000072  e004              B        |L36.126|
                  |L36.116|
000074  6820              LDR      r0,[r4,#0]            ;1192
000076  68c2              LDR      r2,[r0,#0xc]          ;1192
000078  f0420208          ORR      r2,r2,#8              ;1192
00007c  60c2              STR      r2,[r0,#0xc]          ;1192
                  |L36.126|
00007e  6820              LDR      r0,[r4,#0]            ;1201
000080  68c2              LDR      r2,[r0,#0xc]          ;1201
000082  f0420280          ORR      r2,r2,#0x80           ;1201
000086  60c2              STR      r2,[r0,#0xc]          ;1201
000088  2204              MOVS     r2,#4                 ;1204
00008a  6820              LDR      r0,[r4,#0]            ;1204
00008c  f7fffffe          BL       TIM_CCxNChannelCmd
000090  6820              LDR      r0,[r4,#0]            ;1207
000092  6c41              LDR      r1,[r0,#0x44]         ;1207
000094  f4414100          ORR      r1,r1,#0x8000         ;1207
000098  6441              STR      r1,[r0,#0x44]         ;1207
00009a  4914              LDR      r1,|L36.236|
00009c  6820              LDR      r0,[r4,#0]            ;1210
00009e  4288              CMP      r0,r1                 ;1210
0000a0  d011              BEQ      |L36.198|
0000a2  f1b04f80          CMP      r0,#0x40000000        ;1210
0000a6  d00e              BEQ      |L36.198|
0000a8  4911              LDR      r1,|L36.240|
0000aa  4288              CMP      r0,r1                 ;1210
0000ac  d00b              BEQ      |L36.198|
0000ae  4911              LDR      r1,|L36.244|
0000b0  4288              CMP      r0,r1                 ;1210
0000b2  d008              BEQ      |L36.198|
0000b4  4910              LDR      r1,|L36.248|
0000b6  4288              CMP      r0,r1                 ;1210
0000b8  d005              BEQ      |L36.198|
0000ba  4910              LDR      r1,|L36.252|
0000bc  4288              CMP      r0,r1                 ;1210
0000be  d002              BEQ      |L36.198|
0000c0  490f              LDR      r1,|L36.256|
0000c2  4288              CMP      r0,r1                 ;1210
0000c4  d10c              BNE      |L36.224|
                  |L36.198|
0000c6  6881              LDR      r1,[r0,#8]            ;1212
0000c8  4a0e              LDR      r2,|L36.260|
0000ca  4011              ANDS     r1,r1,r2              ;1212
0000cc  2906              CMP      r1,#6                 ;1213
0000ce  d00b              BEQ      |L36.232|
0000d0  f5b13f80          CMP      r1,#0x10000           ;1213
0000d4  d008              BEQ      |L36.232|
0000d6  6801              LDR      r1,[r0,#0]            ;1215
0000d8  f0410101          ORR      r1,r1,#1              ;1215
0000dc  6001              STR      r1,[r0,#0]            ;1215
0000de  e003              B        |L36.232|
                  |L36.224|
0000e0  6801              LDR      r1,[r0,#0]            ;1220
0000e2  f0410101          ORR      r1,r1,#1              ;1220
0000e6  6001              STR      r1,[r0,#0]            ;1220
                  |L36.232|
0000e8  2000              MOVS     r0,#0                 ;1224
0000ea  bd10              POP      {r4,pc}
;;;1226   
                          ENDP

                  |L36.236|
                          DCD      0x40012c00
                  |L36.240|
                          DCD      0x40000400
                  |L36.244|
                          DCD      0x40000800
                  |L36.248|
                          DCD      0x40000c00
                  |L36.252|
                          DCD      0x40013400
                  |L36.256|
                          DCD      0x40014000
                  |L36.260|
                          DCD      0x00010007

                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;1124     */
;;;1125   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1126   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1129   
;;;1130     /* Disable the complementary PWM output  */
;;;1131     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1132   
;;;1133     /* Disable the Main Output */
;;;1134     __HAL_TIM_MOE_DISABLE(htim);
000010  6820              LDR      r0,[r4,#0]
000012  6a03              LDR      r3,[r0,#0x20]
000014  f2411111          MOV      r1,#0x1111
000018  420b              TST      r3,r1
00001a  f2404244          MOV      r2,#0x444
00001e  d106              BNE      |L37.46|
000020  6a03              LDR      r3,[r0,#0x20]
000022  4213              TST      r3,r2
000024  d103              BNE      |L37.46|
000026  6c43              LDR      r3,[r0,#0x44]
000028  f4234300          BIC      r3,r3,#0x8000
00002c  6443              STR      r3,[r0,#0x44]
                  |L37.46|
;;;1135   
;;;1136     /* Disable the Peripheral */
;;;1137     __HAL_TIM_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  420b              TST      r3,r1
000034  d106              BNE      |L37.68|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d103              BNE      |L37.68|
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
                  |L37.68|
;;;1138   
;;;1139     /* Set the TIM complementary channel state */
;;;1140     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000044  2001              MOVS     r0,#1
000046  b13d              CBZ      r5,|L37.88|
000048  2d04              CMP      r5,#4
00004a  d008              BEQ      |L37.94|
00004c  2d08              CMP      r5,#8
00004e  d009              BEQ      |L37.100|
000050  f8840047          STRB     r0,[r4,#0x47]
                  |L37.84|
;;;1141   
;;;1142     /* Return function status */
;;;1143     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1144   }
000056  bd70              POP      {r4-r6,pc}
                  |L37.88|
000058  f8840044          STRB     r0,[r4,#0x44]         ;1140
00005c  e7fa              B        |L37.84|
                  |L37.94|
00005e  f8840045          STRB     r0,[r4,#0x45]         ;1140
000062  e7f7              B        |L37.84|
                  |L37.100|
000064  f8840046          STRB     r0,[r4,#0x46]         ;1140
000068  e7f4              B        |L37.84|
;;;1145   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1436     */
;;;1437   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1438   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1439     /* Check the parameters */
;;;1440     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1441   
;;;1442     switch (Channel)
;;;1443     {
;;;1444       case TIM_CHANNEL_1:
;;;1445       {
;;;1446         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1447         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;1442
00000a  d004              BEQ      |L38.22|
00000c  2d04              CMP      r5,#4                 ;1442
00000e  d00a              BEQ      |L38.38|
000010  2d08              CMP      r5,#8                 ;1442
000012  d117              BNE      |L38.68|
000014  e00f              B        |L38.54|
                  |L38.22|
000016  68c1              LDR      r1,[r0,#0xc]
000018  f4217100          BIC      r1,r1,#0x200
00001c  60c1              STR      r1,[r0,#0xc]
;;;1448         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00001e  6a60              LDR      r0,[r4,#0x24]
000020  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1449         break;
000024  e00e              B        |L38.68|
                  |L38.38|
;;;1450       }
;;;1451   
;;;1452       case TIM_CHANNEL_2:
;;;1453       {
;;;1454         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1455         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000026  68c1              LDR      r1,[r0,#0xc]
000028  f4216180          BIC      r1,r1,#0x400
00002c  60c1              STR      r1,[r0,#0xc]
;;;1456         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1457         break;
000034  e006              B        |L38.68|
                  |L38.54|
;;;1458       }
;;;1459   
;;;1460       case TIM_CHANNEL_3:
;;;1461       {
;;;1462         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1463         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000036  68c1              LDR      r1,[r0,#0xc]
000038  f4216100          BIC      r1,r1,#0x800
00003c  60c1              STR      r1,[r0,#0xc]
;;;1464         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L38.68|
;;;1465         break;
;;;1466       }
;;;1467   
;;;1468       default:
;;;1469         break;
;;;1470     }
;;;1471   
;;;1472     /* Disable the complementary PWM output */
;;;1473     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000044  2200              MOVS     r2,#0
000046  4629              MOV      r1,r5
000048  6820              LDR      r0,[r4,#0]
00004a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1474   
;;;1475     /* Disable the Main Output */
;;;1476     __HAL_TIM_MOE_DISABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6a01              LDR      r1,[r0,#0x20]
000052  f2411211          MOV      r2,#0x1111
000056  4211              TST      r1,r2
000058  f2404344          MOV      r3,#0x444
00005c  d106              BNE      |L38.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4219              TST      r1,r3
000062  d103              BNE      |L38.108|
000064  6c41              LDR      r1,[r0,#0x44]
000066  f4214100          BIC      r1,r1,#0x8000
00006a  6441              STR      r1,[r0,#0x44]
                  |L38.108|
;;;1477   
;;;1478     /* Disable the Peripheral */
;;;1479     __HAL_TIM_DISABLE(htim);
00006c  6820              LDR      r0,[r4,#0]
00006e  6a01              LDR      r1,[r0,#0x20]
000070  4211              TST      r1,r2
000072  d106              BNE      |L38.130|
000074  6a01              LDR      r1,[r0,#0x20]
000076  4219              TST      r1,r3
000078  d103              BNE      |L38.130|
00007a  6801              LDR      r1,[r0,#0]
00007c  f0210101          BIC      r1,r1,#1
000080  6001              STR      r1,[r0,#0]
                  |L38.130|
;;;1480   
;;;1481     /* Set the TIM complementary channel state */
;;;1482     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000082  2001              MOVS     r0,#1
000084  b13d              CBZ      r5,|L38.150|
000086  2d04              CMP      r5,#4
000088  d008              BEQ      |L38.156|
00008a  2d08              CMP      r5,#8
00008c  d009              BEQ      |L38.162|
00008e  f8840047          STRB     r0,[r4,#0x47]
                  |L38.146|
;;;1483   
;;;1484     /* Return function status */
;;;1485     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;1486   }
000094  bd70              POP      {r4-r6,pc}
                  |L38.150|
000096  f8840044          STRB     r0,[r4,#0x44]         ;1482
00009a  e7fa              B        |L38.146|
                  |L38.156|
00009c  f8840045          STRB     r0,[r4,#0x45]         ;1482
0000a0  e7f7              B        |L38.146|
                  |L38.162|
0000a2  f8840046          STRB     r0,[r4,#0x46]         ;1482
0000a6  e7f4              B        |L38.146|
;;;1487   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;1237     */
;;;1238   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1239   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1240     uint32_t tmpccer;
;;;1241   
;;;1242     /* Check the parameters */
;;;1243     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1244   
;;;1245     switch (Channel)
;;;1246     {
;;;1247       case TIM_CHANNEL_1:
;;;1248       {
;;;1249         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1250         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;1245
00000a  d004              BEQ      |L39.22|
00000c  2d04              CMP      r5,#4                 ;1245
00000e  d007              BEQ      |L39.32|
000010  2d08              CMP      r5,#8                 ;1245
000012  d10e              BNE      |L39.50|
000014  e009              B        |L39.42|
                  |L39.22|
000016  68c1              LDR      r1,[r0,#0xc]
000018  f0210102          BIC      r1,r1,#2
00001c  60c1              STR      r1,[r0,#0xc]
;;;1251         break;
00001e  e008              B        |L39.50|
                  |L39.32|
;;;1252       }
;;;1253   
;;;1254       case TIM_CHANNEL_2:
;;;1255       {
;;;1256         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1257         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000020  68c1              LDR      r1,[r0,#0xc]
000022  f0210104          BIC      r1,r1,#4
000026  60c1              STR      r1,[r0,#0xc]
;;;1258         break;
000028  e003              B        |L39.50|
                  |L39.42|
;;;1259       }
;;;1260   
;;;1261       case TIM_CHANNEL_3:
;;;1262       {
;;;1263         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1264         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f0210108          BIC      r1,r1,#8
000030  60c1              STR      r1,[r0,#0xc]
                  |L39.50|
;;;1265         break;
;;;1266       }
;;;1267   
;;;1268       default:
;;;1269         break;
;;;1270     }
;;;1271   
;;;1272     /* Disable the complementary PWM output  */
;;;1273     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000032  2200              MOVS     r2,#0
000034  4629              MOV      r1,r5
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1274   
;;;1275     /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;1276     tmpccer = htim->Instance->CCER;
00003c  6820              LDR      r0,[r4,#0]
00003e  6a02              LDR      r2,[r0,#0x20]
;;;1277     if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
000040  f2404144          MOV      r1,#0x444
000044  420a              TST      r2,r1
000046  d103              BNE      |L39.80|
;;;1278     {
;;;1279       __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000048  68c2              LDR      r2,[r0,#0xc]
00004a  f0220280          BIC      r2,r2,#0x80
00004e  60c2              STR      r2,[r0,#0xc]
                  |L39.80|
;;;1280     }
;;;1281   
;;;1282     /* Disable the Main Output */
;;;1283     __HAL_TIM_MOE_DISABLE(htim);
000050  6820              LDR      r0,[r4,#0]
000052  6a03              LDR      r3,[r0,#0x20]
000054  f2411211          MOV      r2,#0x1111
000058  4213              TST      r3,r2
00005a  d106              BNE      |L39.106|
00005c  6a03              LDR      r3,[r0,#0x20]
00005e  420b              TST      r3,r1
000060  d103              BNE      |L39.106|
000062  6c43              LDR      r3,[r0,#0x44]
000064  f4234300          BIC      r3,r3,#0x8000
000068  6443              STR      r3,[r0,#0x44]
                  |L39.106|
;;;1284   
;;;1285     /* Disable the Peripheral */
;;;1286     __HAL_TIM_DISABLE(htim);
00006a  6820              LDR      r0,[r4,#0]
00006c  6a03              LDR      r3,[r0,#0x20]
00006e  4213              TST      r3,r2
000070  d106              BNE      |L39.128|
000072  6a02              LDR      r2,[r0,#0x20]
000074  420a              TST      r2,r1
000076  d103              BNE      |L39.128|
000078  6801              LDR      r1,[r0,#0]
00007a  f0210101          BIC      r1,r1,#1
00007e  6001              STR      r1,[r0,#0]
                  |L39.128|
;;;1287   
;;;1288     /* Set the TIM complementary channel state */
;;;1289     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000080  2001              MOVS     r0,#1
000082  b13d              CBZ      r5,|L39.148|
000084  2d04              CMP      r5,#4
000086  d008              BEQ      |L39.154|
000088  2d08              CMP      r5,#8
00008a  d009              BEQ      |L39.160|
00008c  f8840047          STRB     r0,[r4,#0x47]
                  |L39.144|
;;;1290   
;;;1291     /* Return function status */
;;;1292     return HAL_OK;
000090  2000              MOVS     r0,#0
;;;1293   }
000092  bd70              POP      {r4-r6,pc}
                  |L39.148|
000094  f8840044          STRB     r0,[r4,#0x44]         ;1289
000098  e7fa              B        |L39.144|
                  |L39.154|
00009a  f8840045          STRB     r0,[r4,#0x45]         ;1289
00009e  e7f7              B        |L39.144|
                  |L39.160|
0000a0  f8840046          STRB     r0,[r4,#0x46]         ;1289
0000a4  e7f4              B        |L39.144|
;;;1294   
                          ENDP


                          AREA ||i.HAL_TIMEx_RemapConfig||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_RemapConfig PROC
;;;2395     */
;;;2396   HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
000000  b510              PUSH     {r4,lr}
;;;2397   {
;;;2398     uint32_t tmpor1;
;;;2399     uint32_t tmpor2;
;;;2400   
;;;2401     __HAL_LOCK(htim);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d01f              BEQ      |L40.74|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;2402   
;;;2403     /* Check parameters */
;;;2404     assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
;;;2405     assert_param(IS_TIM_REMAP(Remap));
;;;2406   
;;;2407     /* Set ETR_SEL bit field (if required) */
;;;2408     if (IS_TIM_ETRSEL_INSTANCE(htim->Instance))
000010  4b0f              LDR      r3,|L40.80|
000012  6802              LDR      r2,[r0,#0]
000014  429a              CMP      r2,r3
000016  d008              BEQ      |L40.42|
000018  f1b24f80          CMP      r2,#0x40000000
00001c  d005              BEQ      |L40.42|
00001e  4b0d              LDR      r3,|L40.84|
000020  429a              CMP      r2,r3
000022  d002              BEQ      |L40.42|
000024  4b0c              LDR      r3,|L40.88|
000026  429a              CMP      r2,r3
000028  d106              BNE      |L40.56|
                  |L40.42|
;;;2409     {
;;;2410       tmpor2 = htim->Instance->OR2;
00002a  6e13              LDR      r3,[r2,#0x60]
;;;2411       tmpor2 &= ~TIM1_OR2_ETRSEL_Msk;
00002c  f42334e0          BIC      r4,r3,#0x1c000
;;;2412       tmpor2 |= (Remap & TIM1_OR2_ETRSEL_Msk);
000030  f40133e0          AND      r3,r1,#0x1c000
000034  4323              ORRS     r3,r3,r4
;;;2413   
;;;2414       /* Set TIMx_OR2 */
;;;2415       htim->Instance->OR2 = tmpor2;
000036  6613              STR      r3,[r2,#0x60]
                  |L40.56|
;;;2416     }
;;;2417   
;;;2418     /* Set other remapping capabilities */
;;;2419     tmpor1 = Remap;
;;;2420     tmpor1 &= ~TIM1_OR2_ETRSEL_Msk;
000038  f42131e0          BIC      r1,r1,#0x1c000
;;;2421   
;;;2422     /* Set TIMx_OR1 */
;;;2423     htim->Instance->OR1 = tmpor1;
00003c  6802              LDR      r2,[r0,#0]
00003e  6511              STR      r1,[r2,#0x50]
;;;2424   
;;;2425     __HAL_UNLOCK(htim);
000040  2100              MOVS     r1,#0
000042  f880103c          STRB     r1,[r0,#0x3c]
;;;2426   
;;;2427     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;2428   }
000048  bd10              POP      {r4,pc}
                  |L40.74|
00004a  2002              MOVS     r0,#2                 ;2401
00004c  bd10              POP      {r4,pc}
;;;2429   
                          ENDP

00004e  0000              DCW      0x0000
                  |L40.80|
                          DCD      0x40012c00
                  |L40.84|
                          DCD      0x40000400
                  |L40.88|
                          DCD      0x40013400

                          AREA ||i.TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationCplt PROC
;;;2611     */
;;;2612   void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2613   {
;;;2614     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2615   
;;;2616     /* Change the htim state */
;;;2617     htim->State = HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;2618   
;;;2619   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2620     htim->CommutationCallback(htim);
;;;2621   #else
;;;2622     HAL_TIMEx_CommutCallback(htim);
00000a  f7fffffe          BL       HAL_TIMEx_CommutCallback
;;;2623   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2624   }
00000e  bd10              POP      {r4,pc}
;;;2625   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationHalfCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationHalfCplt PROC
;;;2630     */
;;;2631   void TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2632   {
;;;2633     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2634   
;;;2635     /* Change the htim state */
;;;2636     htim->State = HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;2637   
;;;2638   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2639     htim->CommutationHalfCpltCallback(htim);
;;;2640   #else
;;;2641     HAL_TIMEx_CommutHalfCpltCallback(htim);
00000a  f7fffffe          BL       HAL_TIMEx_CommutHalfCpltCallback
;;;2642   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2643   }
00000e  bd10              POP      {r4,pc}
;;;2644   
                          ENDP


                          AREA ||i.TIM_CCxNChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNChannelCmd PROC
;;;2754     */
;;;2755   static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
000000  b510              PUSH     {r4,lr}
;;;2756   {
;;;2757     uint32_t tmp;
;;;2758   
;;;2759     tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
000002  f001011f          AND      r1,r1,#0x1f
000006  2304              MOVS     r3,#4
000008  408b              LSLS     r3,r3,r1
;;;2760   
;;;2761     /* Reset the CCxNE Bit */
;;;2762     TIMx->CCER &=  ~tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  6204              STR      r4,[r0,#0x20]
;;;2763   
;;;2764     /* Set or reset the CCxNE Bit */
;;;2765     TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
000010  6a03              LDR      r3,[r0,#0x20]
000012  408a              LSLS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  6203              STR      r3,[r0,#0x20]
;;;2766   }
000018  bd10              POP      {r4,pc}
;;;2767   /**
                          ENDP


                          AREA ||i.TIM_DMADelayPulseNCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseNCplt PROC
;;;2650     */
;;;2651   static void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2652   {
;;;2653     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;2654   
;;;2655     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
;;;2656     {
;;;2657       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000004  2101              MOVS     r1,#1
000006  6a62              LDR      r2,[r4,#0x24]         ;2655
000008  4282              CMP      r2,r0                 ;2655
00000a  d105              BNE      |L44.24|
00000c  7721              STRB     r1,[r4,#0x1c]
;;;2658   
;;;2659       if (hdma->Init.Mode == DMA_NORMAL)
00000e  69c0              LDR      r0,[r0,#0x1c]
000010  b9f8              CBNZ     r0,|L44.82|
;;;2660       {
;;;2661         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000012  f8841044          STRB     r1,[r4,#0x44]
000016  e01c              B        |L44.82|
                  |L44.24|
;;;2662       }
;;;2663     }
;;;2664     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa2              LDR      r2,[r4,#0x28]
00001a  4282              CMP      r2,r0
00001c  d106              BNE      |L44.44|
;;;2665     {
;;;2666       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2202              MOVS     r2,#2
000020  7722              STRB     r2,[r4,#0x1c]
;;;2667   
;;;2668       if (hdma->Init.Mode == DMA_NORMAL)
000022  69c0              LDR      r0,[r0,#0x1c]
000024  b9a8              CBNZ     r0,|L44.82|
;;;2669       {
;;;2670         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000026  f8841045          STRB     r1,[r4,#0x45]
00002a  e012              B        |L44.82|
                  |L44.44|
;;;2671       }
;;;2672     }
;;;2673     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00002c  6ae2              LDR      r2,[r4,#0x2c]
00002e  4282              CMP      r2,r0
000030  d106              BNE      |L44.64|
;;;2674     {
;;;2675       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000032  2204              MOVS     r2,#4
000034  7722              STRB     r2,[r4,#0x1c]
;;;2676   
;;;2677       if (hdma->Init.Mode == DMA_NORMAL)
000036  69c0              LDR      r0,[r0,#0x1c]
000038  b958              CBNZ     r0,|L44.82|
;;;2678       {
;;;2679         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
00003a  f8841046          STRB     r1,[r4,#0x46]
00003e  e008              B        |L44.82|
                  |L44.64|
;;;2680       }
;;;2681     }
;;;2682     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000040  6b22              LDR      r2,[r4,#0x30]
000042  4282              CMP      r2,r0
000044  d105              BNE      |L44.82|
;;;2683     {
;;;2684       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000046  2208              MOVS     r2,#8
000048  7722              STRB     r2,[r4,#0x1c]
;;;2685   
;;;2686       if (hdma->Init.Mode == DMA_NORMAL)
00004a  69c0              LDR      r0,[r0,#0x1c]
00004c  b908              CBNZ     r0,|L44.82|
;;;2687       {
;;;2688         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
00004e  f8841047          STRB     r1,[r4,#0x47]
                  |L44.82|
;;;2689       }
;;;2690     }
;;;2691     else
;;;2692     {
;;;2693       /* nothing to do */
;;;2694     }
;;;2695   
;;;2696   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2697     htim->PWM_PulseFinishedCallback(htim);
;;;2698   #else
;;;2699     HAL_TIM_PWM_PulseFinishedCallback(htim);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;2700   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2701   
;;;2702     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000058  2000              MOVS     r0,#0
00005a  7720              STRB     r0,[r4,#0x1c]
;;;2703   }
00005c  bd10              POP      {r4,pc}
;;;2704   
                          ENDP


                          AREA ||i.TIM_DMAErrorCCxN||, CODE, READONLY, ALIGN=1

                  TIM_DMAErrorCCxN PROC
;;;2709     */
;;;2710   static void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2711   {
;;;2712     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;2713   
;;;2714     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
;;;2715     {
;;;2716       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000004  2101              MOVS     r1,#1
000006  6a62              LDR      r2,[r4,#0x24]         ;2714
000008  4282              CMP      r2,r0                 ;2714
00000a  d103              BNE      |L45.20|
00000c  7721              STRB     r1,[r4,#0x1c]
;;;2717       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00000e  f8841044          STRB     r1,[r4,#0x44]
000012  e00e              B        |L45.50|
                  |L45.20|
;;;2718     }
;;;2719     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6aa2              LDR      r2,[r4,#0x28]
000016  4282              CMP      r2,r0
000018  d104              BNE      |L45.36|
;;;2720     {
;;;2721       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  7720              STRB     r0,[r4,#0x1c]
;;;2722       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00001e  f8841045          STRB     r1,[r4,#0x45]
000022  e006              B        |L45.50|
                  |L45.36|
;;;2723     }
;;;2724     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae2              LDR      r2,[r4,#0x2c]
000026  4282              CMP      r2,r0
000028  d103              BNE      |L45.50|
;;;2725     {
;;;2726       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
;;;2727       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
00002e  f8841046          STRB     r1,[r4,#0x46]
                  |L45.50|
;;;2728     }
;;;2729     else
;;;2730     {
;;;2731       /* nothing to do */
;;;2732     }
;;;2733   
;;;2734   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2735     htim->ErrorCallback(htim);
;;;2736   #else
;;;2737     HAL_TIM_ErrorCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;2738   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2739   
;;;2740     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  7720              STRB     r0,[r4,#0x1c]
;;;2741   }
00003c  bd10              POP      {r4,pc}
;;;2742   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_tim_ex_c_e8ef3920____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 507
|__asm___22_stm32l4xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_tim_ex_c_e8ef3920____RRX|
#line 694
|__asm___22_stm32l4xx_hal_tim_ex_c_e8ef3920____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
