; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_rcc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_rcc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1745     */
;;;1746   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1747   {
;;;1748     /* NOTE : This function should not be modified, when the callback is needed,
;;;1749               the HAL_RCC_CSSCallback should be implemented in the user file
;;;1750      */
;;;1751   }
;;;1752   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;1105     */
;;;1106   HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1107   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1108     uint32_t tickstart;
;;;1109   #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;1110       defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1111     uint32_t hpre = RCC_SYSCLK_DIV1;
;;;1112   #endif
;;;1113     HAL_StatusTypeDef status;
;;;1114   
;;;1115     /* Check Null pointer */
;;;1116     if(RCC_ClkInitStruct == NULL)
000008  2c00              CMP      r4,#0
00000a  d017              BEQ      |L2.60|
;;;1117     {
;;;1118       return HAL_ERROR;
;;;1119     }
;;;1120   
;;;1121     /* Check the parameters */
;;;1122     assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;1123     assert_param(IS_FLASH_LATENCY(FLatency));
;;;1124   
;;;1125     /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
;;;1126       must be correctly programmed according to the frequency of the CPU clock
;;;1127       (HCLK) and the supply voltage of the device. */
;;;1128   
;;;1129     /* Increasing the number of wait states because of higher CPU frequency */
;;;1130     if(FLatency > __HAL_FLASH_GET_LATENCY())
00000c  f8df8124          LDR      r8,|L2.308|
000010  f8d80000          LDR      r0,[r8,#0]
000014  f0000007          AND      r0,r0,#7
000018  42a8              CMP      r0,r5
00001a  d211              BCS      |L2.64|
;;;1131     {
;;;1132       /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;1133       __HAL_FLASH_SET_LATENCY(FLatency);
00001c  f8d80000          LDR      r0,[r8,#0]
000020  f0200007          BIC      r0,r0,#7
000024  4328              ORRS     r0,r0,r5
000026  f8c80000          STR      r0,[r8,#0]
;;;1134   
;;;1135       /* Check that the new number of wait states is taken into account to access the Flash
;;;1136       memory by reading the FLASH_ACR register */
;;;1137       if(__HAL_FLASH_GET_LATENCY() != FLatency)
00002a  f8d80000          LDR      r0,[r8,#0]
00002e  f0000007          AND      r0,r0,#7
000032  42a8              CMP      r0,r5
000034  d004              BEQ      |L2.64|
;;;1138       {
;;;1139         return HAL_ERROR;
000036  2001              MOVS     r0,#1
                  |L2.56|
;;;1140       }
;;;1141     }
;;;1142   
;;;1143     /*------------------------- SYSCLK Configuration ---------------------------*/
;;;1144     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
;;;1145     {
;;;1146       assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;1147   
;;;1148       /* PLL is selected as System Clock Source */
;;;1149       if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;1150       {
;;;1151         /* Check the PLL ready flag */
;;;1152         if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
;;;1153         {
;;;1154           return HAL_ERROR;
;;;1155         }
;;;1156   #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;1157       defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1158         /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
;;;1159         /* Compute target PLL output frequency */
;;;1160         if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
;;;1161         {
;;;1162           if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
;;;1163           {
;;;1164             /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
;;;1165             MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
;;;1166             hpre = RCC_SYSCLK_DIV2;
;;;1167           }
;;;1168           else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
;;;1169           {
;;;1170             /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
;;;1171             MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
;;;1172             hpre = RCC_SYSCLK_DIV2;
;;;1173           }
;;;1174           else
;;;1175           {
;;;1176             /* nothing to do */
;;;1177           }
;;;1178         }
;;;1179   #endif
;;;1180       }
;;;1181       else
;;;1182       {
;;;1183         /* HSE is selected as System Clock Source */
;;;1184         if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
;;;1185         {
;;;1186           /* Check the HSE ready flag */
;;;1187           if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
;;;1188           {
;;;1189             return HAL_ERROR;
;;;1190           }
;;;1191         }
;;;1192         /* MSI is selected as System Clock Source */
;;;1193         else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
;;;1194         {
;;;1195           /* Check the MSI ready flag */
;;;1196           if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
;;;1197           {
;;;1198             return HAL_ERROR;
;;;1199           }
;;;1200         }
;;;1201         /* HSI is selected as System Clock Source */
;;;1202         else
;;;1203         {
;;;1204           /* Check the HSI ready flag */
;;;1205           if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
;;;1206           {
;;;1207             return HAL_ERROR;
;;;1208           }
;;;1209         }
;;;1210   #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;1211       defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1212         /* Overshoot management when going down from PLL as SYSCLK source and frequency above 80Mhz */
;;;1213         if(HAL_RCC_GetSysClockFreq() > 80000000U)
;;;1214         {
;;;1215           /* Intermediate step with HCLK prescaler 2 necessary before to go under 80Mhz */
;;;1216           MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
;;;1217           hpre = RCC_SYSCLK_DIV2;
;;;1218         }
;;;1219   #endif
;;;1220   
;;;1221       }
;;;1222   
;;;1223       MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
;;;1224   
;;;1225       /* Get Start Tick*/
;;;1226       tickstart = HAL_GetTick();
;;;1227   
;;;1228       while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
;;;1229       {
;;;1230         if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;1231         {
;;;1232           return HAL_TIMEOUT;
;;;1233         }
;;;1234       }
;;;1235     }
;;;1236   
;;;1237     /*-------------------------- HCLK Configuration --------------------------*/
;;;1238     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
;;;1239     {
;;;1240       assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;1241       MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
;;;1242     }
;;;1243   #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;1244       defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1245     else
;;;1246     {
;;;1247       /* Is intermediate HCLK prescaler 2 applied internally, complete with HCLK prescaler 1 */
;;;1248       if(hpre == RCC_SYSCLK_DIV2)
;;;1249       {
;;;1250         MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
;;;1251       }
;;;1252     }
;;;1253   #endif
;;;1254   
;;;1255     /* Decreasing the number of wait states because of lower CPU frequency */
;;;1256     if(FLatency < __HAL_FLASH_GET_LATENCY())
;;;1257     {
;;;1258       /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;1259       __HAL_FLASH_SET_LATENCY(FLatency);
;;;1260   
;;;1261       /* Check that the new number of wait states is taken into account to access the Flash
;;;1262       memory by reading the FLASH_ACR register */
;;;1263       if(__HAL_FLASH_GET_LATENCY() != FLatency)
;;;1264       {
;;;1265         return HAL_ERROR;
;;;1266       }
;;;1267     }
;;;1268   
;;;1269     /*-------------------------- PCLK1 Configuration ---------------------------*/
;;;1270     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;1271     {
;;;1272       assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;1273       MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;1274     }
;;;1275   
;;;1276     /*-------------------------- PCLK2 Configuration ---------------------------*/
;;;1277     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;1278     {
;;;1279       assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;1280       MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
;;;1281     }
;;;1282   
;;;1283     /* Update the SystemCoreClock global variable */
;;;1284     SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
;;;1285   
;;;1286     /* Configure the source of time base considering new system clocks settings*/
;;;1287     status = HAL_InitTick(uwTickPrio);
;;;1288   
;;;1289     return status;
;;;1290   }
000038  e8bd87f0          POP      {r4-r10,pc}
                  |L2.60|
00003c  2001              MOVS     r0,#1                 ;1118
00003e  e7fb              B        |L2.56|
                  |L2.64|
000040  7820              LDRB     r0,[r4,#0]            ;1144
000042  4e3d              LDR      r6,|L2.312|
000044  07c0              LSLS     r0,r0,#31             ;1144
000046  d032              BEQ      |L2.174|
000048  6860              LDR      r0,[r4,#4]            ;1149
00004a  2803              CMP      r0,#3                 ;1149
00004c  d007              BEQ      |L2.94|
00004e  2802              CMP      r0,#2                 ;1184
000050  d00a              BEQ      |L2.104|
000052  b170              CBZ      r0,|L2.114|
000054  6831              LDR      r1,[r6,#0]            ;1205
000056  0549              LSLS     r1,r1,#21             ;1205
000058  d410              BMI      |L2.124|
00005a  2001              MOVS     r0,#1                 ;1207
00005c  e7ec              B        |L2.56|
                  |L2.94|
00005e  6831              LDR      r1,[r6,#0]            ;1152
000060  0189              LSLS     r1,r1,#6              ;1152
000062  d40b              BMI      |L2.124|
000064  2001              MOVS     r0,#1                 ;1154
000066  e7e7              B        |L2.56|
                  |L2.104|
000068  6831              LDR      r1,[r6,#0]            ;1187
00006a  0389              LSLS     r1,r1,#14             ;1187
00006c  d406              BMI      |L2.124|
00006e  2001              MOVS     r0,#1                 ;1189
000070  e7e2              B        |L2.56|
                  |L2.114|
000072  6831              LDR      r1,[r6,#0]            ;1196
000074  0789              LSLS     r1,r1,#30             ;1196
000076  d401              BMI      |L2.124|
000078  2001              MOVS     r0,#1                 ;1198
00007a  e7dd              B        |L2.56|
                  |L2.124|
00007c  68b1              LDR      r1,[r6,#8]            ;1223
00007e  f0210103          BIC      r1,r1,#3              ;1223
000082  4301              ORRS     r1,r1,r0              ;1223
000084  60b1              STR      r1,[r6,#8]            ;1223
000086  f7fffffe          BL       HAL_GetTick
00008a  4607              MOV      r7,r0                 ;1226
00008c  f2413988          MOV      r9,#0x1388            ;1230
000090  e006              B        |L2.160|
                  |L2.146|
000092  f7fffffe          BL       HAL_GetTick
000096  1bc0              SUBS     r0,r0,r7              ;1230
000098  4548              CMP      r0,r9                 ;1230
00009a  d901              BLS      |L2.160|
00009c  2003              MOVS     r0,#3                 ;1232
00009e  e7cb              B        |L2.56|
                  |L2.160|
0000a0  68b0              LDR      r0,[r6,#8]            ;1228
0000a2  6861              LDR      r1,[r4,#4]            ;1228
0000a4  f000000c          AND      r0,r0,#0xc            ;1228
0000a8  ebb00f81          CMP      r0,r1,LSL #2          ;1228
0000ac  d1f1              BNE      |L2.146|
                  |L2.174|
0000ae  7820              LDRB     r0,[r4,#0]            ;1238
0000b0  0780              LSLS     r0,r0,#30             ;1238
0000b2  d505              BPL      |L2.192|
0000b4  68b0              LDR      r0,[r6,#8]            ;1241
0000b6  68a1              LDR      r1,[r4,#8]            ;1241
0000b8  f02000f0          BIC      r0,r0,#0xf0           ;1241
0000bc  4308              ORRS     r0,r0,r1              ;1241
0000be  60b0              STR      r0,[r6,#8]            ;1241
                  |L2.192|
0000c0  f8d80000          LDR      r0,[r8,#0]            ;1256
0000c4  f0000007          AND      r0,r0,#7              ;1256
0000c8  42a8              CMP      r0,r5                 ;1256
0000ca  d90e              BLS      |L2.234|
0000cc  f8d80000          LDR      r0,[r8,#0]            ;1259
0000d0  f0200007          BIC      r0,r0,#7              ;1259
0000d4  4328              ORRS     r0,r0,r5              ;1259
0000d6  f8c80000          STR      r0,[r8,#0]            ;1259
0000da  f8d80000          LDR      r0,[r8,#0]            ;1263
0000de  f0000007          AND      r0,r0,#7              ;1263
0000e2  42a8              CMP      r0,r5                 ;1263
0000e4  d001              BEQ      |L2.234|
0000e6  2001              MOVS     r0,#1                 ;1265
0000e8  e7a6              B        |L2.56|
                  |L2.234|
0000ea  7820              LDRB     r0,[r4,#0]            ;1270
0000ec  0740              LSLS     r0,r0,#29             ;1270
0000ee  d505              BPL      |L2.252|
0000f0  68b0              LDR      r0,[r6,#8]            ;1273
0000f2  68e1              LDR      r1,[r4,#0xc]          ;1273
0000f4  f42060e0          BIC      r0,r0,#0x700          ;1273
0000f8  4308              ORRS     r0,r0,r1              ;1273
0000fa  60b0              STR      r0,[r6,#8]            ;1273
                  |L2.252|
0000fc  7820              LDRB     r0,[r4,#0]            ;1277
0000fe  0700              LSLS     r0,r0,#28             ;1277
000100  d506              BPL      |L2.272|
000102  68b0              LDR      r0,[r6,#8]            ;1280
000104  6921              LDR      r1,[r4,#0x10]         ;1280
000106  f4205060          BIC      r0,r0,#0x3800         ;1280
00010a  ea4000c1          ORR      r0,r0,r1,LSL #3       ;1280
00010e  60b0              STR      r0,[r6,#8]            ;1280
                  |L2.272|
000110  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000114  68b1              LDR      r1,[r6,#8]            ;1284
000116  4a09              LDR      r2,|L2.316|
000118  f3c11103          UBFX     r1,r1,#4,#4           ;1284
00011c  5c51              LDRB     r1,[r2,r1]            ;1284
00011e  f001011f          AND      r1,r1,#0x1f           ;1284
000122  40c8              LSRS     r0,r0,r1              ;1284
000124  4906              LDR      r1,|L2.320|
000126  6008              STR      r0,[r1,#0]            ;1284  ; SystemCoreClock
000128  4806              LDR      r0,|L2.324|
00012a  6800              LDR      r0,[r0,#0]            ;1287  ; uwTickPrio
00012c  e8bd47f0          POP      {r4-r10,lr}           ;1287
000130  f7ffbffe          B.W      HAL_InitTick
;;;1291   
                          ENDP

                  |L2.308|
                          DCD      0x40022000
                  |L2.312|
                          DCD      0x40021000
                  |L2.316|
                          DCD      AHBPrescTable
                  |L2.320|
                          DCD      SystemCoreClock
                  |L2.324|
                          DCD      uwTickPrio

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;266      */
;;;267    HAL_StatusTypeDef HAL_RCC_DeInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;268    {
;;;269      uint32_t tickstart;
;;;270    
;;;271      /* Reset to default System clock */
;;;272      /* Set MSION bit */
;;;273      SET_BIT(RCC->CR, RCC_CR_MSION);
000004  4c34              LDR      r4,|L3.216|
000006  6820              LDR      r0,[r4,#0]
000008  f0400001          ORR      r0,r0,#1
00000c  6020              STR      r0,[r4,#0]
;;;274    
;;;275      /* Insure MSIRDY bit is set before writing default MSIRANGE value */
;;;276      /* Get start tick */
;;;277      tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;278    
;;;279      /* Wait till MSI is ready */
;;;280      while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
000014  e007              B        |L3.38|
                  |L3.22|
;;;281      {
;;;282        if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
000016  f7fffffe          BL       HAL_GetTick
00001a  1b40              SUBS     r0,r0,r5
00001c  2802              CMP      r0,#2
00001e  d902              BLS      |L3.38|
;;;283        {
;;;284          return HAL_TIMEOUT;
000020  2003              MOVS     r0,#3
                  |L3.34|
;;;285        }
;;;286      }
;;;287    
;;;288      /* Set MSIRANGE default value */
;;;289      MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
;;;290    
;;;291      /* Reset CFGR register (MSI is selected as system clock source) */
;;;292      CLEAR_REG(RCC->CFGR);
;;;293    
;;;294      /* Update the SystemCoreClock global variable for MSI as system clock source */
;;;295      SystemCoreClock = MSI_VALUE;
;;;296    
;;;297      /* Configure the source of time base considering new system clock settings  */
;;;298      if(HAL_InitTick(uwTickPrio) != HAL_OK)
;;;299      {
;;;300        return HAL_ERROR;
;;;301      }
;;;302    
;;;303      /* Insure MSI selected as system clock source */
;;;304      /* Get start tick */
;;;305      tickstart = HAL_GetTick();
;;;306    
;;;307      /* Wait till system clock source is ready */
;;;308      while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
;;;309      {
;;;310        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;311        {
;;;312          return HAL_TIMEOUT;
;;;313        }
;;;314      }
;;;315    
;;;316      /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
;;;317    #if defined(RCC_PLLSAI2_SUPPORT)
;;;318    
;;;319      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
;;;320    
;;;321    #elif defined(RCC_PLLSAI1_SUPPORT)
;;;322    
;;;323      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON | RCC_CR_PLLSAI1ON);
;;;324    
;;;325    #else
;;;326    
;;;327      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON);
;;;328    
;;;329    #endif /* RCC_PLLSAI2_SUPPORT */
;;;330    
;;;331      /* Insure PLLRDY, PLLSAI1RDY and PLLSAI2RDY (if present) are reset */
;;;332      /* Get start tick */
;;;333      tickstart = HAL_GetTick();
;;;334    
;;;335    #if defined(RCC_PLLSAI2_SUPPORT)
;;;336    
;;;337      while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY) != 0U)
;;;338    
;;;339    #elif defined(RCC_PLLSAI1_SUPPORT)
;;;340    
;;;341      while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY) != 0U)
;;;342    
;;;343    #else
;;;344    
;;;345      while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
;;;346    
;;;347    #endif
;;;348      {
;;;349        if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;350        {
;;;351          return HAL_TIMEOUT;
;;;352        }
;;;353      }
;;;354    
;;;355      /* Reset PLLCFGR register */
;;;356      CLEAR_REG(RCC->PLLCFGR);
;;;357      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
;;;358    
;;;359    #if defined(RCC_PLLSAI1_SUPPORT)
;;;360    
;;;361      /* Reset PLLSAI1CFGR register */
;;;362      CLEAR_REG(RCC->PLLSAI1CFGR);
;;;363      SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
;;;364    
;;;365    #endif /* RCC_PLLSAI1_SUPPORT */
;;;366    
;;;367    #if defined(RCC_PLLSAI2_SUPPORT)
;;;368    
;;;369      /* Reset PLLSAI2CFGR register */
;;;370      CLEAR_REG(RCC->PLLSAI2CFGR);
;;;371      SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
;;;372    
;;;373    #endif /* RCC_PLLSAI2_SUPPORT */
;;;374    
;;;375      /* Reset HSEBYP bit */
;;;376      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
;;;377    
;;;378      /* Disable all interrupts */
;;;379      CLEAR_REG(RCC->CIER);
;;;380    
;;;381      /* Clear all interrupt flags */
;;;382      WRITE_REG(RCC->CICR, 0xFFFFFFFFU);
;;;383    
;;;384      /* Clear all reset flags */
;;;385      SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;386    
;;;387      return HAL_OK;
;;;388    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L3.38|
000026  6820              LDR      r0,[r4,#0]            ;280
000028  0780              LSLS     r0,r0,#30             ;280
00002a  d5f4              BPL      |L3.22|
00002c  6820              LDR      r0,[r4,#0]            ;289
00002e  f02000f0          BIC      r0,r0,#0xf0           ;289
000032  f0400060          ORR      r0,r0,#0x60           ;289
000036  6020              STR      r0,[r4,#0]            ;289
000038  2700              MOVS     r7,#0                 ;292
00003a  60a7              STR      r7,[r4,#8]            ;292
00003c  4928              LDR      r1,|L3.224|
00003e  4827              LDR      r0,|L3.220|
000040  6008              STR      r0,[r1,#0]            ;295  ; SystemCoreClock
000042  4828              LDR      r0,|L3.228|
000044  6800              LDR      r0,[r0,#0]            ;298  ; uwTickPrio
000046  f7fffffe          BL       HAL_InitTick
00004a  b108              CBZ      r0,|L3.80|
00004c  2001              MOVS     r0,#1                 ;300
00004e  e7e8              B        |L3.34|
                  |L3.80|
000050  f7fffffe          BL       HAL_GetTick
000054  4605              MOV      r5,r0                 ;305
000056  f2413688          MOV      r6,#0x1388            ;310
00005a  e006              B        |L3.106|
                  |L3.92|
00005c  f7fffffe          BL       HAL_GetTick
000060  1b40              SUBS     r0,r0,r5              ;310
000062  42b0              CMP      r0,r6                 ;310
000064  d901              BLS      |L3.106|
000066  2003              MOVS     r0,#3                 ;312
000068  e7db              B        |L3.34|
                  |L3.106|
00006a  68a0              LDR      r0,[r4,#8]            ;308
00006c  f0100f0c          TST      r0,#0xc               ;308
000070  d1f4              BNE      |L3.92|
000072  6820              LDR      r0,[r4,#0]            ;319
000074  491c              LDR      r1,|L3.232|
000076  4008              ANDS     r0,r0,r1              ;319
000078  6020              STR      r0,[r4,#0]            ;319
00007a  f7fffffe          BL       HAL_GetTick
00007e  4605              MOV      r5,r0                 ;333
000080  e006              B        |L3.144|
                  |L3.130|
000082  f7fffffe          BL       HAL_GetTick
000086  1b40              SUBS     r0,r0,r5              ;349
000088  2802              CMP      r0,#2                 ;349
00008a  d901              BLS      |L3.144|
00008c  2003              MOVS     r0,#3                 ;351
00008e  e7c8              B        |L3.34|
                  |L3.144|
000090  6820              LDR      r0,[r4,#0]            ;337
000092  f0105f28          TST      r0,#0x2a000000        ;337
000096  d1f4              BNE      |L3.130|
000098  60e7              STR      r7,[r4,#0xc]          ;356
00009a  68e0              LDR      r0,[r4,#0xc]          ;357
00009c  f4405080          ORR      r0,r0,#0x1000         ;357
0000a0  60e0              STR      r0,[r4,#0xc]          ;357
0000a2  6127              STR      r7,[r4,#0x10]         ;362
0000a4  6920              LDR      r0,[r4,#0x10]         ;363
0000a6  f4405080          ORR      r0,r0,#0x1000         ;363
0000aa  6120              STR      r0,[r4,#0x10]         ;363
0000ac  6167              STR      r7,[r4,#0x14]         ;370
0000ae  6960              LDR      r0,[r4,#0x14]         ;371
0000b0  f4405080          ORR      r0,r0,#0x1000         ;371
0000b4  6160              STR      r0,[r4,#0x14]         ;371
0000b6  6820              LDR      r0,[r4,#0]            ;376
0000b8  f4202080          BIC      r0,r0,#0x40000        ;376
0000bc  6020              STR      r0,[r4,#0]            ;376
0000be  61a7              STR      r7,[r4,#0x18]         ;379
0000c0  f04f30ff          MOV      r0,#0xffffffff        ;382
0000c4  6220              STR      r0,[r4,#0x20]         ;382
0000c6  f8d40094          LDR      r0,[r4,#0x94]         ;385
0000ca  f4400000          ORR      r0,r0,#0x800000       ;385
0000ce  f8c40094          STR      r0,[r4,#0x94]         ;385
0000d2  2000              MOVS     r0,#0                 ;387
0000d4  e7a5              B        |L3.34|
;;;389    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L3.216|
                          DCD      0x40021000
                  |L3.220|
                          DCD      0x003d0900
                  |L3.224|
                          DCD      SystemCoreClock
                  |L3.228|
                          DCD      uwTickPrio
                  |L3.232|
                          DCD      0xeafef4ff

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;1718     */
;;;1719   void HAL_RCC_EnableCSS(void)
000000  4802              LDR      r0,|L4.12|
;;;1720   {
;;;1721     SET_BIT(RCC->CR, RCC_CR_CSSON) ;
000002  6801              LDR      r1,[r0,#0]
000004  f4412100          ORR      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;1722   }
00000a  4770              BX       lr
;;;1723   
                          ENDP

                  |L4.12|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1683     */
;;;1684   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1685   {
;;;1686     /* Check the parameters */
;;;1687     assert_param(RCC_ClkInitStruct != (void  *)NULL);
;;;1688     assert_param(pFLatency != (void *)NULL);
;;;1689   
;;;1690     /* Set all possible values for the Clock type parameter --------------------*/
;;;1691     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
000002  6002              STR      r2,[r0,#0]
;;;1692   
;;;1693     /* Get the SYSCLK configuration --------------------------------------------*/
;;;1694     RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
000004  4a0b              LDR      r2,|L5.52|
000006  6893              LDR      r3,[r2,#8]
000008  f0030303          AND      r3,r3,#3
00000c  6043              STR      r3,[r0,#4]
;;;1695   
;;;1696     /* Get the HCLK configuration ----------------------------------------------*/
;;;1697     RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
00000e  6893              LDR      r3,[r2,#8]
000010  f00303f0          AND      r3,r3,#0xf0
000014  6083              STR      r3,[r0,#8]
;;;1698   
;;;1699     /* Get the APB1 configuration ----------------------------------------------*/
;;;1700     RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
000016  6893              LDR      r3,[r2,#8]
000018  f40363e0          AND      r3,r3,#0x700
00001c  60c3              STR      r3,[r0,#0xc]
;;;1701   
;;;1702     /* Get the APB2 configuration ----------------------------------------------*/
;;;1703     RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
00001e  6892              LDR      r2,[r2,#8]
000020  f4025260          AND      r2,r2,#0x3800
000024  08d2              LSRS     r2,r2,#3
000026  6102              STR      r2,[r0,#0x10]
;;;1704   
;;;1705     /* Get the Flash Wait State (Latency) configuration ------------------------*/
;;;1706     *pFLatency = __HAL_FLASH_GET_LATENCY();
000028  4803              LDR      r0,|L5.56|
00002a  6800              LDR      r0,[r0,#0]
00002c  f0000007          AND      r0,r0,#7
000030  6008              STR      r0,[r1,#0]
;;;1707   }
000032  4770              BX       lr
;;;1708   
                          ENDP

                  |L5.52|
                          DCD      0x40021000
                  |L5.56|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1488     */
;;;1489   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L6.8|
;;;1490   {
;;;1491     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1492   }
000004  4770              BX       lr
;;;1493   
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1524     */
;;;1525   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b510              PUSH     {r4,lr}
;;;1526   {
;;;1527     /* Check the parameters */
;;;1528     assert_param(RCC_OscInitStruct != (void *)NULL);
;;;1529   
;;;1530     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1531   #if defined(RCC_HSI48_SUPPORT)
;;;1532     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
000002  213f              MOVS     r1,#0x3f
000004  6001              STR      r1,[r0,#0]
;;;1533                                         RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSI48;
;;;1534   #else
;;;1535     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
;;;1536                                         RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1537   #endif /* RCC_HSI48_SUPPORT */
;;;1538   
;;;1539     /* Get the HSE configuration -----------------------------------------------*/
;;;1540     if(READ_BIT(RCC->CR, RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000006  4937              LDR      r1,|L7.228|
000008  680a              LDR      r2,[r1,#0]
00000a  0353              LSLS     r3,r2,#13
00000c  f04f0200          MOV      r2,#0
000010  d503              BPL      |L7.26|
;;;1541     {
;;;1542       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000012  f44f23a0          MOV      r3,#0x50000
000016  6043              STR      r3,[r0,#4]
000018  e007              B        |L7.42|
                  |L7.26|
;;;1543     }
;;;1544     else if(READ_BIT(RCC->CR, RCC_CR_HSEON) == RCC_CR_HSEON)
00001a  680b              LDR      r3,[r1,#0]
00001c  03db              LSLS     r3,r3,#15
00001e  d503              BPL      |L7.40|
;;;1545     {
;;;1546       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
000020  f44f3380          MOV      r3,#0x10000
000024  6043              STR      r3,[r0,#4]
000026  e000              B        |L7.42|
                  |L7.40|
;;;1547     }
;;;1548     else
;;;1549     {
;;;1550       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000028  6042              STR      r2,[r0,#4]
                  |L7.42|
;;;1551     }
;;;1552   
;;;1553      /* Get the MSI configuration -----------------------------------------------*/
;;;1554     if(READ_BIT(RCC->CR, RCC_CR_MSION) == RCC_CR_MSION)
00002a  680b              LDR      r3,[r1,#0]
00002c  07dc              LSLS     r4,r3,#31
;;;1555     {
;;;1556       RCC_OscInitStruct->MSIState = RCC_MSI_ON;
00002e  f04f0301          MOV      r3,#1
000032  d001              BEQ      |L7.56|
000034  6183              STR      r3,[r0,#0x18]
000036  e000              B        |L7.58|
                  |L7.56|
;;;1557     }
;;;1558     else
;;;1559     {
;;;1560       RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
000038  6182              STR      r2,[r0,#0x18]
                  |L7.58|
;;;1561     }
;;;1562   
;;;1563     RCC_OscInitStruct->MSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos;
00003a  684c              LDR      r4,[r1,#4]
00003c  f3c42407          UBFX     r4,r4,#8,#8
000040  61c4              STR      r4,[r0,#0x1c]
;;;1564     RCC_OscInitStruct->MSIClockRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
000042  680c              LDR      r4,[r1,#0]
000044  f00404f0          AND      r4,r4,#0xf0
000048  6204              STR      r4,[r0,#0x20]
;;;1565   
;;;1566     /* Get the HSI configuration -----------------------------------------------*/
;;;1567     if(READ_BIT(RCC->CR, RCC_CR_HSION) == RCC_CR_HSION)
00004a  680c              LDR      r4,[r1,#0]
00004c  05e4              LSLS     r4,r4,#23
00004e  d503              BPL      |L7.88|
;;;1568     {
;;;1569       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000050  f44f7480          MOV      r4,#0x100
000054  60c4              STR      r4,[r0,#0xc]
000056  e000              B        |L7.90|
                  |L7.88|
;;;1570     }
;;;1571     else
;;;1572     {
;;;1573       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
000058  60c2              STR      r2,[r0,#0xc]
                  |L7.90|
;;;1574     }
;;;1575   
;;;1576     RCC_OscInitStruct->HSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_HSITRIM) >> RCC_ICSCR_HSITRIM_Pos;
00005a  684c              LDR      r4,[r1,#4]
00005c  f3c46406          UBFX     r4,r4,#24,#7
000060  6104              STR      r4,[r0,#0x10]
;;;1577   
;;;1578     /* Get the LSE configuration -----------------------------------------------*/
;;;1579     if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000062  f8d14090          LDR      r4,[r1,#0x90]
000066  0764              LSLS     r4,r4,#29
000068  d502              BPL      |L7.112|
;;;1580     {
;;;1581   #if defined(RCC_BDCR_LSESYSDIS)
;;;1582       if((RCC->BDCR & RCC_BDCR_LSESYSDIS) == RCC_BDCR_LSESYSDIS)
;;;1583       {
;;;1584         RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS_RTC_ONLY;
;;;1585       }
;;;1586       else
;;;1587   #endif /* RCC_BDCR_LSESYSDIS */
;;;1588       {
;;;1589         RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
00006a  2405              MOVS     r4,#5
00006c  6084              STR      r4,[r0,#8]
00006e  e006              B        |L7.126|
                  |L7.112|
;;;1590       }
;;;1591     }
;;;1592     else if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
000070  f8d14090          LDR      r4,[r1,#0x90]
000074  07e4              LSLS     r4,r4,#31
000076  d001              BEQ      |L7.124|
;;;1593     {
;;;1594   #if defined(RCC_BDCR_LSESYSDIS)
;;;1595       if((RCC->BDCR & RCC_BDCR_LSESYSDIS) == RCC_BDCR_LSESYSDIS)
;;;1596       {
;;;1597         RCC_OscInitStruct->LSEState = RCC_LSE_ON_RTC_ONLY;
;;;1598       }
;;;1599       else
;;;1600   #endif /* RCC_BDCR_LSESYSDIS */
;;;1601       {
;;;1602         RCC_OscInitStruct->LSEState = RCC_LSE_ON;
000078  6083              STR      r3,[r0,#8]
00007a  e000              B        |L7.126|
                  |L7.124|
;;;1603       }
;;;1604     }
;;;1605     else
;;;1606     {
;;;1607       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
00007c  6082              STR      r2,[r0,#8]
                  |L7.126|
;;;1608     }
;;;1609   
;;;1610     /* Get the LSI configuration -----------------------------------------------*/
;;;1611     if(READ_BIT(RCC->CSR, RCC_CSR_LSION) == RCC_CSR_LSION)
00007e  f8d14094          LDR      r4,[r1,#0x94]
000082  07e4              LSLS     r4,r4,#31
000084  d001              BEQ      |L7.138|
;;;1612     {
;;;1613       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000086  6143              STR      r3,[r0,#0x14]
000088  e000              B        |L7.140|
                  |L7.138|
;;;1614     }
;;;1615     else
;;;1616     {
;;;1617       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
00008a  6142              STR      r2,[r0,#0x14]
                  |L7.140|
;;;1618     }
;;;1619   #if defined(RCC_CSR_LSIPREDIV)
;;;1620   
;;;1621     /* Get the LSI configuration -----------------------------------------------*/
;;;1622     if((RCC->CSR & RCC_CSR_LSIPREDIV) == RCC_CSR_LSIPREDIV)
;;;1623     {
;;;1624       RCC_OscInitStruct->LSIDiv = RCC_LSI_DIV128;
;;;1625     }
;;;1626     else
;;;1627     {
;;;1628       RCC_OscInitStruct->LSIDiv = RCC_LSI_DIV1;
;;;1629     }
;;;1630   #endif /* RCC_CSR_LSIPREDIV */
;;;1631   
;;;1632   #if defined(RCC_HSI48_SUPPORT)
;;;1633     /* Get the HSI48 configuration ---------------------------------------------*/
;;;1634     if(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON) == RCC_CRRCR_HSI48ON)
00008c  f8d14098          LDR      r4,[r1,#0x98]
000090  07e4              LSLS     r4,r4,#31
000092  d001              BEQ      |L7.152|
;;;1635     {
;;;1636       RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
000094  6243              STR      r3,[r0,#0x24]
000096  e000              B        |L7.154|
                  |L7.152|
;;;1637     }
;;;1638     else
;;;1639     {
;;;1640       RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
000098  6242              STR      r2,[r0,#0x24]
                  |L7.154|
;;;1641     }
;;;1642   #else
;;;1643     RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
;;;1644   #endif /* RCC_HSI48_SUPPORT */
;;;1645   
;;;1646     /* Get the PLL configuration -----------------------------------------------*/
;;;1647     if(READ_BIT(RCC->CR, RCC_CR_PLLON) == RCC_CR_PLLON)
00009a  680a              LDR      r2,[r1,#0]
00009c  01d2              LSLS     r2,r2,#7
00009e  d502              BPL      |L7.166|
;;;1648     {
;;;1649       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
0000a0  2202              MOVS     r2,#2
0000a2  6282              STR      r2,[r0,#0x28]
0000a4  e000              B        |L7.168|
                  |L7.166|
;;;1650     }
;;;1651     else
;;;1652     {
;;;1653       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
0000a6  6283              STR      r3,[r0,#0x28]
                  |L7.168|
;;;1654     }
;;;1655     RCC_OscInitStruct->PLL.PLLSource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
0000a8  68ca              LDR      r2,[r1,#0xc]
0000aa  f0020203          AND      r2,r2,#3
0000ae  62c2              STR      r2,[r0,#0x2c]
;;;1656     RCC_OscInitStruct->PLL.PLLM = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
0000b0  68ca              LDR      r2,[r1,#0xc]
0000b2  f3c21202          UBFX     r2,r2,#4,#3
0000b6  1c52              ADDS     r2,r2,#1
0000b8  6302              STR      r2,[r0,#0x30]
;;;1657     RCC_OscInitStruct->PLL.PLLN = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
0000ba  68ca              LDR      r2,[r1,#0xc]
0000bc  f3c22206          UBFX     r2,r2,#8,#7
0000c0  6342              STR      r2,[r0,#0x34]
;;;1658     RCC_OscInitStruct->PLL.PLLQ = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
0000c2  68ca              LDR      r2,[r1,#0xc]
0000c4  f3c25241          UBFX     r2,r2,#21,#2
0000c8  1c52              ADDS     r2,r2,#1
0000ca  0052              LSLS     r2,r2,#1
0000cc  63c2              STR      r2,[r0,#0x3c]
;;;1659     RCC_OscInitStruct->PLL.PLLR = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) << 1U);
0000ce  68ca              LDR      r2,[r1,#0xc]
0000d0  f3c26241          UBFX     r2,r2,#25,#2
0000d4  1c52              ADDS     r2,r2,#1
0000d6  0052              LSLS     r2,r2,#1
0000d8  6402              STR      r2,[r0,#0x40]
;;;1660   #if defined(RCC_PLLP_SUPPORT)
;;;1661   #if defined(RCC_PLLP_DIV_2_31_SUPPORT)
;;;1662     RCC_OscInitStruct->PLL.PLLP = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
0000da  68c9              LDR      r1,[r1,#0xc]
0000dc  0ec9              LSRS     r1,r1,#27
0000de  6381              STR      r1,[r0,#0x38]
;;;1663   #else
;;;1664     if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
;;;1665     {
;;;1666       RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV17;
;;;1667     }
;;;1668     else
;;;1669     {
;;;1670       RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV7;
;;;1671     }
;;;1672   #endif /* RCC_PLLP_DIV_2_31_SUPPORT */
;;;1673   #endif /* RCC_PLLP_SUPPORT */
;;;1674   }
0000e0  bd10              POP      {r4,pc}
;;;1675   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L7.228|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1499     */
;;;1500   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  b500              PUSH     {lr}
;;;1501   {
;;;1502     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1503     return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
000002  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000006  4905              LDR      r1,|L8.28|
000008  6889              LDR      r1,[r1,#8]
00000a  4a05              LDR      r2,|L8.32|
00000c  f3c12102          UBFX     r1,r1,#8,#3
000010  5c51              LDRB     r1,[r2,r1]
000012  f001011f          AND      r1,r1,#0x1f
000016  40c8              LSRS     r0,r0,r1
;;;1504   }
000018  bd00              POP      {pc}
;;;1505   
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40021000
                  |L8.32|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1511     */
;;;1512   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  b500              PUSH     {lr}
;;;1513   {
;;;1514     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1515     return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
000002  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000006  4905              LDR      r1,|L9.28|
000008  6889              LDR      r1,[r1,#8]
00000a  4a05              LDR      r2,|L9.32|
00000c  f3c121c2          UBFX     r1,r1,#11,#3
000010  5c51              LDRB     r1,[r2,r1]
000012  f001011f          AND      r1,r1,#0x1f
000016  40c8              LSRS     r0,r0,r1
;;;1516   }
000018  bd00              POP      {pc}
;;;1517   
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40021000
                  |L9.32|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;1400     */
;;;1401   uint32_t HAL_RCC_GetSysClockFreq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1402   {
;;;1403     uint32_t msirange = 0U, sysclockfreq = 0U;
000002  2200              MOVS     r2,#0
000004  2000              MOVS     r0,#0
;;;1404     uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
;;;1405     uint32_t sysclk_source, pll_oscsource;
;;;1406   
;;;1407     sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
000006  4b24              LDR      r3,|L10.152|
000008  6899              LDR      r1,[r3,#8]
00000a  f001010c          AND      r1,r1,#0xc
;;;1408     pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
00000e  68dc              LDR      r4,[r3,#0xc]
000010  f0040403          AND      r4,r4,#3
;;;1409   
;;;1410     if((sysclk_source == RCC_CFGR_SWS_MSI) ||
;;;1411        ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
;;;1412     {
;;;1413       /* MSI or PLL with MSI source used as system clock source */
;;;1414   
;;;1415       /* Get SYSCLK source */
;;;1416       if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
;;;1417       { /* MSISRANGE from RCC_CSR applies */
;;;1418         msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
;;;1419       }
;;;1420       else
;;;1421       { /* MSIRANGE from RCC_CR applies */
;;;1422         msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
;;;1423       }
;;;1424       /*MSI frequency range in HZ*/
;;;1425       msirange = MSIRangeTable[msirange];
;;;1426   
;;;1427       if(sysclk_source == RCC_CFGR_SWS_MSI)
;;;1428       {
;;;1429         /* MSI used as system clock source */
;;;1430         sysclockfreq = msirange;
;;;1431       }
;;;1432     }
;;;1433     else if(sysclk_source == RCC_CFGR_SWS_HSI)
;;;1434     {
;;;1435       /* HSI used as system clock source */
;;;1436       sysclockfreq = HSI_VALUE;
000014  4d21              LDR      r5,|L10.156|
;;;1437     }
;;;1438     else if(sysclk_source == RCC_CFGR_SWS_HSE)
;;;1439     {
;;;1440       /* HSE used as system clock source */
;;;1441       sysclockfreq = HSE_VALUE;
000016  106e              ASRS     r6,r5,#1
000018  2900              CMP      r1,#0                 ;1410
00001a  d008              BEQ      |L10.46|
00001c  290c              CMP      r1,#0xc               ;1411
00001e  d101              BNE      |L10.36|
000020  2c01              CMP      r4,#1                 ;1411
000022  d004              BEQ      |L10.46|
                  |L10.36|
000024  2904              CMP      r1,#4                 ;1433
000026  d013              BEQ      |L10.80|
000028  2908              CMP      r1,#8                 ;1438
00002a  d013              BEQ      |L10.84|
00002c  e013              B        |L10.86|
                  |L10.46|
00002e  681a              LDR      r2,[r3,#0]            ;1416
000030  0712              LSLS     r2,r2,#28             ;1416
000032  d404              BMI      |L10.62|
000034  f8d32094          LDR      r2,[r3,#0x94]         ;1418
000038  f3c22203          UBFX     r2,r2,#8,#4           ;1418
00003c  e002              B        |L10.68|
                  |L10.62|
00003e  681a              LDR      r2,[r3,#0]            ;1422
000040  f3c21203          UBFX     r2,r2,#4,#4           ;1422
                  |L10.68|
000044  4c16              LDR      r4,|L10.160|
000046  f8542022          LDR      r2,[r4,r2,LSL #2]     ;1425
00004a  b921              CBNZ     r1,|L10.86|
00004c  4610              MOV      r0,r2                 ;1430
00004e  e002              B        |L10.86|
                  |L10.80|
000050  4628              MOV      r0,r5                 ;1436
000052  e000              B        |L10.86|
                  |L10.84|
000054  4630              MOV      r0,r6
                  |L10.86|
;;;1442     }
;;;1443     else
;;;1444     {
;;;1445       /* unexpected case: sysclockfreq at 0 */
;;;1446     }
;;;1447   
;;;1448     if(sysclk_source == RCC_CFGR_SWS_PLL)
000056  290c              CMP      r1,#0xc
000058  d118              BNE      |L10.140|
;;;1449     {
;;;1450       /* PLL used as system clock  source */
;;;1451   
;;;1452       /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
;;;1453       SYSCLK = PLL_VCO / PLLR
;;;1454       */
;;;1455       pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
00005a  68d8              LDR      r0,[r3,#0xc]
00005c  f0000003          AND      r0,r0,#3
;;;1456   
;;;1457       switch (pllsource)
000060  2802              CMP      r0,#2
000062  d014              BEQ      |L10.142|
000064  2803              CMP      r0,#3
000066  d014              BEQ      |L10.146|
;;;1458       {
;;;1459       case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
;;;1460         pllvco = HSI_VALUE;
;;;1461         break;
;;;1462   
;;;1463       case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
;;;1464         pllvco = HSE_VALUE;
;;;1465         break;
;;;1466   
;;;1467       case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
;;;1468       default:
;;;1469         pllvco = msirange;
000068  4610              MOV      r0,r2
                  |L10.106|
;;;1470         break;
;;;1471       }
;;;1472       pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
00006a  68d9              LDR      r1,[r3,#0xc]
00006c  f3c11102          UBFX     r1,r1,#4,#3
000070  1c49              ADDS     r1,r1,#1
;;;1473       pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
000072  68da              LDR      r2,[r3,#0xc]
000074  f3c22206          UBFX     r2,r2,#8,#7
000078  4342              MULS     r2,r0,r2
00007a  fbb2f0f1          UDIV     r0,r2,r1
;;;1474       pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
00007e  68d9              LDR      r1,[r3,#0xc]
000080  f3c16141          UBFX     r1,r1,#25,#2
000084  1c49              ADDS     r1,r1,#1
000086  0049              LSLS     r1,r1,#1
;;;1475       sysclockfreq = pllvco / pllr;
000088  fbb0f0f1          UDIV     r0,r0,r1
                  |L10.140|
;;;1476     }
;;;1477   
;;;1478     return sysclockfreq;
;;;1479   }
00008c  bd70              POP      {r4-r6,pc}
                  |L10.142|
00008e  4628              MOV      r0,r5                 ;1460
000090  e7eb              B        |L10.106|
                  |L10.146|
000092  4630              MOV      r0,r6                 ;1464
000094  e7e9              B        |L10.106|
;;;1480   
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
                          DCD      0x40021000
                  |L10.156|
                          DCD      0x00f42400
                  |L10.160|
                          DCD      MSIRangeTable

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;1341     */
;;;1342   void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b570              PUSH     {r4-r6,lr}
;;;1343   {
000002  b086              SUB      sp,sp,#0x18
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1344     GPIO_InitTypeDef GPIO_InitStruct;
;;;1345   
;;;1346     /* Check the parameters */
;;;1347     assert_param(IS_RCC_MCO(RCC_MCOx));
;;;1348     assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;1349     assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;1350   
;;;1351     /* Prevent unused argument(s) compilation warning if no assert_param check */
;;;1352     UNUSED(RCC_MCOx);
;;;1353   
;;;1354     /* MCO Clock Enable */
;;;1355     __MCO1_CLK_ENABLE();
000008  4c0e              LDR      r4,|L11.68|
00000a  6ce0              LDR      r0,[r4,#0x4c]
00000c  f0400001          ORR      r0,r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  6ce0              LDR      r0,[r4,#0x4c]
000014  f0000001          AND      r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;1356   
;;;1357     /* Configue the MCO1 pin in alternate function mode */
;;;1358     GPIO_InitStruct.Pin = MCO1_PIN;
00001a  15a0              ASRS     r0,r4,#22
00001c  9001              STR      r0,[sp,#4]
;;;1359     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00001e  2002              MOVS     r0,#2
000020  9002              STR      r0,[sp,#8]
;;;1360     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000022  9004              STR      r0,[sp,#0x10]
;;;1361     GPIO_InitStruct.Pull = GPIO_NOPULL;
000024  2000              MOVS     r0,#0
000026  9003              STR      r0,[sp,#0xc]
;;;1362     GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
000028  9005              STR      r0,[sp,#0x14]
;;;1363     HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
00002a  a901              ADD      r1,sp,#4
00002c  f04f4090          MOV      r0,#0x48000000
000030  f7fffffe          BL       HAL_GPIO_Init
;;;1364   
;;;1365     /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
;;;1366     MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv ));
000034  68a0              LDR      r0,[r4,#8]
000036  4335              ORRS     r5,r5,r6
000038  f02040fe          BIC      r0,r0,#0x7f000000
00003c  4328              ORRS     r0,r0,r5
00003e  60a0              STR      r0,[r4,#8]
;;;1367   }
000040  b006              ADD      sp,sp,#0x18
000042  bd70              POP      {r4-r6,pc}
;;;1368   
                          ENDP

                  |L11.68|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1728     */
;;;1729   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1730   {
;;;1731     /* Check RCC CSSF interrupt flag  */
;;;1732     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c04              LDR      r4,|L12.20|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  05c0              LSLS     r0,r0,#23
000008  d503              BPL      |L12.18|
;;;1733     {
;;;1734       /* RCC Clock Security System interrupt user callback */
;;;1735       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1736   
;;;1737       /* Clear RCC CSS pending bit */
;;;1738       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  15a0              ASRS     r0,r4,#22
000010  6220              STR      r0,[r4,#0x20]
                  |L12.18|
;;;1739     }
;;;1740   }
000012  bd10              POP      {r4,pc}
;;;1741   
                          ENDP

                  |L12.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;404      */
;;;405    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;406    {
000004  4604              MOV      r4,r0
;;;407      uint32_t tickstart;
;;;408      HAL_StatusTypeDef status;
;;;409      uint32_t sysclk_source, pll_config;
;;;410    
;;;411      /* Check Null pointer */
;;;412      if(RCC_OscInitStruct == NULL)
000006  2c00              CMP      r4,#0
000008  d00d              BEQ      |L13.38|
;;;413      {
;;;414        return HAL_ERROR;
;;;415      }
;;;416    
;;;417      /* Check the parameters */
;;;418      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;419    
;;;420      sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
00000a  4ef7              LDR      r6,|L13.1000|
00000c  68b0              LDR      r0,[r6,#8]
00000e  f000050c          AND      r5,r0,#0xc
;;;421      pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
000012  68f0              LDR      r0,[r6,#0xc]
000014  f0000703          AND      r7,r0,#3
;;;422    
;;;423      /*----------------------------- MSI Configuration --------------------------*/
;;;424      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
000018  7820              LDRB     r0,[r4,#0]
00001a  06c0              LSLS     r0,r0,#27
00001c  d56a              BPL      |L13.244|
;;;425      {
;;;426        /* Check the parameters */
;;;427        assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
;;;428        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
;;;429        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
;;;430    
;;;431        /* Check if MSI is used as system clock or as PLL source when PLL is selected as system clock */
;;;432        if((sysclk_source == RCC_CFGR_SWS_MSI) ||
00001e  b195              CBZ      r5,|L13.70|
;;;433           ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
000020  2d0c              CMP      r5,#0xc
000022  d003              BEQ      |L13.44|
000024  e004              B        |L13.48|
                  |L13.38|
000026  2001              MOVS     r0,#1                 ;414
                  |L13.40|
;;;434        {
;;;435          if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
;;;436          {
;;;437            return HAL_ERROR;
;;;438          }
;;;439    
;;;440           /* Otherwise, just the calibration and MSI range change are allowed */
;;;441          else
;;;442          {
;;;443            /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
;;;444               must be correctly programmed according to the frequency of the CPU clock
;;;445               (HCLK) and the supply voltage of the device. */
;;;446            if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
;;;447            {
;;;448              /* First increase number of wait states update if necessary */
;;;449              if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
;;;450              {
;;;451                return HAL_ERROR;
;;;452              }
;;;453    
;;;454              /* Selects the Multiple Speed oscillator (MSI) clock range .*/
;;;455              __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
;;;456              /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
;;;457              __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
;;;458            }
;;;459            else
;;;460            {
;;;461              /* Else, keep current flash latency while decreasing applies */
;;;462              /* Selects the Multiple Speed oscillator (MSI) clock range .*/
;;;463              __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
;;;464              /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
;;;465              __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
;;;466    
;;;467              /* Decrease number of wait states update if necessary */
;;;468              /* Only possible when MSI is the System clock source  */
;;;469              if(sysclk_source == RCC_CFGR_SWS_MSI)
;;;470              {
;;;471                if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
;;;472                {
;;;473                  return HAL_ERROR;
;;;474                }
;;;475              }
;;;476            }
;;;477    
;;;478            /* Update the SystemCoreClock global variable */
;;;479            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
;;;480    
;;;481            /* Configure the source of time base considering new system clocks settings*/
;;;482            status = HAL_InitTick(uwTickPrio);
;;;483            if(status != HAL_OK)
;;;484            {
;;;485              return status;
;;;486            }
;;;487          }
;;;488        }
;;;489        else
;;;490        {
;;;491          /* Check the MSI State */
;;;492          if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
;;;493          {
;;;494            /* Enable the Internal High Speed oscillator (MSI). */
;;;495            __HAL_RCC_MSI_ENABLE();
;;;496    
;;;497            /* Get timeout */
;;;498            tickstart = HAL_GetTick();
;;;499    
;;;500            /* Wait till MSI is ready */
;;;501            while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
;;;502            {
;;;503              if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
;;;504              {
;;;505                return HAL_TIMEOUT;
;;;506              }
;;;507            }
;;;508             /* Selects the Multiple Speed oscillator (MSI) clock range .*/
;;;509            __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
;;;510             /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
;;;511            __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
;;;512    
;;;513          }
;;;514          else
;;;515          {
;;;516            /* Disable the Internal High Speed oscillator (MSI). */
;;;517            __HAL_RCC_MSI_DISABLE();
;;;518    
;;;519            /* Get timeout */
;;;520            tickstart = HAL_GetTick();
;;;521    
;;;522            /* Wait till MSI is ready */
;;;523            while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
;;;524            {
;;;525              if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
;;;526              {
;;;527                return HAL_TIMEOUT;
;;;528              }
;;;529            }
;;;530          }
;;;531        }
;;;532      }
;;;533      /*------------------------------- HSE Configuration ------------------------*/
;;;534      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
;;;535      {
;;;536        /* Check the parameters */
;;;537        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;538    
;;;539        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;540        if((sysclk_source == RCC_CFGR_SWS_HSE) ||
;;;541           ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
;;;542        {
;;;543          if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
;;;544          {
;;;545            return HAL_ERROR;
;;;546          }
;;;547        }
;;;548        else
;;;549        {
;;;550          /* Set the new HSE configuration ---------------------------------------*/
;;;551          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
;;;552    
;;;553          /* Check the HSE State */
;;;554          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
;;;555          {
;;;556            /* Get Start Tick*/
;;;557            tickstart = HAL_GetTick();
;;;558    
;;;559            /* Wait till HSE is ready */
;;;560            while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
;;;561            {
;;;562              if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
;;;563              {
;;;564                return HAL_TIMEOUT;
;;;565              }
;;;566            }
;;;567          }
;;;568          else
;;;569          {
;;;570            /* Get Start Tick*/
;;;571            tickstart = HAL_GetTick();
;;;572    
;;;573            /* Wait till HSE is disabled */
;;;574            while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
;;;575            {
;;;576              if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
;;;577              {
;;;578                return HAL_TIMEOUT;
;;;579              }
;;;580            }
;;;581          }
;;;582        }
;;;583      }
;;;584      /*----------------------------- HSI Configuration --------------------------*/
;;;585      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
;;;586      {
;;;587        /* Check the parameters */
;;;588        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;589        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;590    
;;;591        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
;;;592        if((sysclk_source == RCC_CFGR_SWS_HSI) ||
;;;593           ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
;;;594        {
;;;595          /* When HSI is used as system clock it will not be disabled */
;;;596          if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
;;;597          {
;;;598            return HAL_ERROR;
;;;599          }
;;;600          /* Otherwise, just the calibration is allowed */
;;;601          else
;;;602          {
;;;603            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;604            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;605          }
;;;606        }
;;;607        else
;;;608        {
;;;609          /* Check the HSI State */
;;;610          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
;;;611          {
;;;612            /* Enable the Internal High Speed oscillator (HSI). */
;;;613            __HAL_RCC_HSI_ENABLE();
;;;614    
;;;615            /* Get Start Tick*/
;;;616            tickstart = HAL_GetTick();
;;;617    
;;;618            /* Wait till HSI is ready */
;;;619            while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
;;;620            {
;;;621              if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
;;;622              {
;;;623                return HAL_TIMEOUT;
;;;624              }
;;;625            }
;;;626    
;;;627            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;628            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;629          }
;;;630          else
;;;631          {
;;;632            /* Disable the Internal High Speed oscillator (HSI). */
;;;633            __HAL_RCC_HSI_DISABLE();
;;;634    
;;;635            /* Get Start Tick*/
;;;636            tickstart = HAL_GetTick();
;;;637    
;;;638            /* Wait till HSI is disabled */
;;;639            while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
;;;640            {
;;;641              if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
;;;642              {
;;;643                return HAL_TIMEOUT;
;;;644              }
;;;645            }
;;;646          }
;;;647        }
;;;648      }
;;;649      /*------------------------------ LSI Configuration -------------------------*/
;;;650      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
;;;651      {
;;;652        /* Check the parameters */
;;;653        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;654    
;;;655        /* Check the LSI State */
;;;656        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
;;;657        {
;;;658    #if defined(RCC_CSR_LSIPREDIV)
;;;659          uint32_t csr_temp = RCC->CSR;
;;;660    
;;;661          /* Check LSI division factor */
;;;662          assert_param(IS_RCC_LSIDIV(RCC_OscInitStruct->LSIDiv));
;;;663    
;;;664          if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPREDIV))
;;;665          {
;;;666            if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
;;;667                ((csr_temp & RCC_CSR_LSION) != RCC_CSR_LSION))
;;;668            {
;;;669               /* If LSIRDY is set while LSION is not enabled,
;;;670                  LSIPREDIV can't be updated  */
;;;671              return HAL_ERROR;
;;;672            }
;;;673    
;;;674            /* Turn off LSI before changing RCC_CSR_LSIPREDIV */
;;;675            if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
;;;676            {
;;;677              __HAL_RCC_LSI_DISABLE();
;;;678    
;;;679              /* Get Start Tick*/
;;;680              tickstart = HAL_GetTick();
;;;681    
;;;682              /* Wait till LSI is disabled */
;;;683              while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
;;;684              {
;;;685                if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
;;;686                {
;;;687                  return HAL_TIMEOUT;
;;;688                }
;;;689              }
;;;690            }
;;;691    
;;;692            /* Set LSI division factor */
;;;693            MODIFY_REG(RCC->CSR, RCC_CSR_LSIPREDIV, RCC_OscInitStruct->LSIDiv);
;;;694          }
;;;695    #endif /* RCC_CSR_LSIPREDIV */
;;;696    
;;;697          /* Enable the Internal Low Speed oscillator (LSI). */
;;;698          __HAL_RCC_LSI_ENABLE();
;;;699    
;;;700          /* Get Start Tick*/
;;;701          tickstart = HAL_GetTick();
;;;702    
;;;703          /* Wait till LSI is ready */
;;;704          while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
;;;705          {
;;;706            if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
;;;707            {
;;;708              return HAL_TIMEOUT;
;;;709            }
;;;710          }
;;;711        }
;;;712        else
;;;713        {
;;;714          /* Disable the Internal Low Speed oscillator (LSI). */
;;;715          __HAL_RCC_LSI_DISABLE();
;;;716    
;;;717          /* Get Start Tick*/
;;;718          tickstart = HAL_GetTick();
;;;719    
;;;720          /* Wait till LSI is disabled */
;;;721          while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
;;;722          {
;;;723            if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
;;;724            {
;;;725              return HAL_TIMEOUT;
;;;726            }
;;;727          }
;;;728        }
;;;729      }
;;;730      /*------------------------------ LSE Configuration -------------------------*/
;;;731      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
;;;732      {
;;;733        FlagStatus       pwrclkchanged = RESET;
;;;734    
;;;735        /* Check the parameters */
;;;736        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;737    
;;;738        /* Update LSE configuration in Backup Domain control register    */
;;;739        /* Requires to enable write access to Backup Domain of necessary */
;;;740        if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
;;;741        {
;;;742          __HAL_RCC_PWR_CLK_ENABLE();
;;;743          pwrclkchanged = SET;
;;;744        }
;;;745    
;;;746        if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
;;;747        {
;;;748          /* Enable write access to Backup domain */
;;;749          SET_BIT(PWR->CR1, PWR_CR1_DBP);
;;;750    
;;;751          /* Wait for Backup domain Write protection disable */
;;;752          tickstart = HAL_GetTick();
;;;753    
;;;754          while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
;;;755          {
;;;756            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
;;;757            {
;;;758              return HAL_TIMEOUT;
;;;759            }
;;;760          }
;;;761        }
;;;762    
;;;763        /* Set the new LSE configuration -----------------------------------------*/
;;;764    #if defined(RCC_BDCR_LSESYSDIS)
;;;765        if((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
;;;766        {
;;;767          /* Set LSESYSDIS bit according to LSE propagation option (enabled or disabled) */
;;;768          MODIFY_REG(RCC->BDCR, RCC_BDCR_LSESYSDIS, (RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSDIS));
;;;769    
;;;770          if((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
;;;771          {
;;;772            /* LSE oscillator bypass enable */
;;;773            SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
;;;774            SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
;;;775          }
;;;776          else
;;;777          {
;;;778            /* LSE oscillator enable */
;;;779            SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
;;;780          }
;;;781        }
;;;782        else
;;;783        {
;;;784          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
;;;785          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
;;;786        }
;;;787    #else
;;;788        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
;;;789    #endif /* RCC_BDCR_LSESYSDIS */
;;;790    
;;;791        /* Check the LSE State */
;;;792        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
;;;793        {
;;;794          /* Get Start Tick*/
;;;795          tickstart = HAL_GetTick();
;;;796    
;;;797          /* Wait till LSE is ready */
;;;798          while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
;;;799          {
;;;800            if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;801            {
;;;802              return HAL_TIMEOUT;
;;;803            }
;;;804          }
;;;805        }
;;;806        else
;;;807        {
;;;808          /* Get Start Tick*/
;;;809          tickstart = HAL_GetTick();
;;;810    
;;;811          /* Wait till LSE is disabled */
;;;812          while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
;;;813          {
;;;814            if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;815            {
;;;816              return HAL_TIMEOUT;
;;;817            }
;;;818          }
;;;819    
;;;820    #if defined(RCC_BDCR_LSESYSDIS)
;;;821          /* By default, stop disabling LSE propagation */
;;;822          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSDIS);
;;;823    #endif /* RCC_BDCR_LSESYSDIS */
;;;824        }
;;;825    
;;;826        /* Restore clock configuration if changed */
;;;827        if(pwrclkchanged == SET)
;;;828        {
;;;829          __HAL_RCC_PWR_CLK_DISABLE();
;;;830        }
;;;831      }
;;;832    #if defined(RCC_HSI48_SUPPORT)
;;;833      /*------------------------------ HSI48 Configuration -----------------------*/
;;;834      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
;;;835      {
;;;836        /* Check the parameters */
;;;837        assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
;;;838    
;;;839        /* Check the LSI State */
;;;840        if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
;;;841        {
;;;842          /* Enable the Internal Low Speed oscillator (HSI48). */
;;;843          __HAL_RCC_HSI48_ENABLE();
;;;844    
;;;845          /* Get Start Tick*/
;;;846          tickstart = HAL_GetTick();
;;;847    
;;;848          /* Wait till HSI48 is ready */
;;;849          while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
;;;850          {
;;;851            if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
;;;852            {
;;;853              return HAL_TIMEOUT;
;;;854            }
;;;855          }
;;;856        }
;;;857        else
;;;858        {
;;;859          /* Disable the Internal Low Speed oscillator (HSI48). */
;;;860          __HAL_RCC_HSI48_DISABLE();
;;;861    
;;;862          /* Get Start Tick*/
;;;863          tickstart = HAL_GetTick();
;;;864    
;;;865          /* Wait till HSI48 is disabled */
;;;866          while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
;;;867          {
;;;868            if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
;;;869            {
;;;870              return HAL_TIMEOUT;
;;;871            }
;;;872          }
;;;873        }
;;;874      }
;;;875    #endif /* RCC_HSI48_SUPPORT */
;;;876      /*-------------------------------- PLL Configuration -----------------------*/
;;;877      /* Check the parameters */
;;;878      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;879    
;;;880      if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
;;;881      {
;;;882        /* PLL On ? */
;;;883        if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
;;;884        {
;;;885          /* Check the parameters */
;;;886          assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;887          assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
;;;888          assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
;;;889    #if defined(RCC_PLLP_SUPPORT)
;;;890          assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
;;;891    #endif /* RCC_PLLP_SUPPORT */
;;;892          assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
;;;893          assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
;;;894    
;;;895          /* Do nothing if PLL configuration is the unchanged */
;;;896          pll_config = RCC->PLLCFGR;
;;;897          if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
;;;898             (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
;;;899             (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
;;;900    #if defined(RCC_PLLP_SUPPORT)
;;;901    #if defined(RCC_PLLP_DIV_2_31_SUPPORT)
;;;902             (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
;;;903    #else
;;;904             (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
;;;905    #endif
;;;906    #endif
;;;907             (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
;;;908             (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
;;;909          {
;;;910            /* Check if the PLL is used as system clock or not */
;;;911            if(sysclk_source != RCC_CFGR_SWS_PLL)
;;;912            {
;;;913    #if defined(RCC_PLLSAI1_SUPPORT) || defined(RCC_PLLSAI2_SUPPORT)
;;;914              /* Check if main PLL can be updated */
;;;915              /* Not possible if the source is shared by other enabled PLLSAIx */
;;;916              if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
;;;917    #if defined(RCC_PLLSAI2_SUPPORT)
;;;918                 || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
;;;919    #endif
;;;920                )
;;;921              {
;;;922                return HAL_ERROR;
;;;923              }
;;;924              else
;;;925    #endif /* RCC_PLLSAI1_SUPPORT || RCC_PLLSAI2_SUPPORT */
;;;926              {
;;;927                /* Disable the main PLL. */
;;;928                __HAL_RCC_PLL_DISABLE();
;;;929    
;;;930                /* Get Start Tick*/
;;;931                tickstart = HAL_GetTick();
;;;932    
;;;933                /* Wait till PLL is ready */
;;;934                while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
;;;935                {
;;;936                  if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;937                  {
;;;938                    return HAL_TIMEOUT;
;;;939                  }
;;;940                }
;;;941    
;;;942                /* Configure the main PLL clock source, multiplication and division factors. */
;;;943                __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;944                                     RCC_OscInitStruct->PLL.PLLM,
;;;945                                     RCC_OscInitStruct->PLL.PLLN,
;;;946    #if defined(RCC_PLLP_SUPPORT)
;;;947                                     RCC_OscInitStruct->PLL.PLLP,
;;;948    #endif
;;;949                                     RCC_OscInitStruct->PLL.PLLQ,
;;;950                                     RCC_OscInitStruct->PLL.PLLR);
;;;951    
;;;952                /* Enable the main PLL. */
;;;953                __HAL_RCC_PLL_ENABLE();
;;;954    
;;;955                /* Enable PLL System Clock output. */
;;;956                __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
;;;957    
;;;958                /* Get Start Tick*/
;;;959                tickstart = HAL_GetTick();
;;;960    
;;;961                /* Wait till PLL is ready */
;;;962                while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
;;;963                {
;;;964                  if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;965                  {
;;;966                    return HAL_TIMEOUT;
;;;967                  }
;;;968                }
;;;969              }
;;;970            }
;;;971            else
;;;972            {
;;;973              /* PLL is already used as System core clock */
;;;974              return HAL_ERROR;
;;;975            }
;;;976          }
;;;977          else
;;;978          {
;;;979            /* PLL configuration is unchanged */
;;;980            /* Re-enable PLL if it was disabled (ie. low power mode) */
;;;981            if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
;;;982            {
;;;983              /* Enable the main PLL. */
;;;984              __HAL_RCC_PLL_ENABLE();
;;;985    
;;;986              /* Enable PLL System Clock output. */
;;;987              __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
;;;988    
;;;989              /* Get Start Tick*/
;;;990              tickstart = HAL_GetTick();
;;;991    
;;;992              /* Wait till PLL is ready */
;;;993              while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
;;;994              {
;;;995                if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;996                {
;;;997                  return HAL_TIMEOUT;
;;;998                }
;;;999              }
;;;1000           }
;;;1001         }
;;;1002       }
;;;1003       else
;;;1004       {
;;;1005         /* Check that PLL is not used as system clock or not */
;;;1006         if(sysclk_source != RCC_CFGR_SWS_PLL)
;;;1007         {
;;;1008           /* Disable the main PLL. */
;;;1009           __HAL_RCC_PLL_DISABLE();
;;;1010   
;;;1011           /* Disable all PLL outputs to save power if no PLLs on */
;;;1012   #if defined(RCC_PLLSAI1_SUPPORT) && defined(RCC_CR_PLLSAI2RDY)
;;;1013           if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
;;;1014           {
;;;1015             MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;1016           }
;;;1017   #elif defined(RCC_PLLSAI1_SUPPORT)
;;;1018           if(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
;;;1019           {
;;;1020             MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;1021           }
;;;1022   #else
;;;1023           MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
;;;1024   #endif /* RCC_PLLSAI1_SUPPORT && RCC_CR_PLLSAI2RDY */
;;;1025   
;;;1026   #if defined(RCC_PLLSAI2_SUPPORT)
;;;1027           __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
;;;1028   #elif defined(RCC_PLLSAI1_SUPPORT)
;;;1029           __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
;;;1030   #else
;;;1031           __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK);
;;;1032   #endif /* RCC_PLLSAI2_SUPPORT */
;;;1033   
;;;1034           /* Get Start Tick*/
;;;1035           tickstart = HAL_GetTick();
;;;1036   
;;;1037           /* Wait till PLL is disabled */
;;;1038           while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
;;;1039           {
;;;1040             if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
;;;1041             {
;;;1042               return HAL_TIMEOUT;
;;;1043             }
;;;1044           }
;;;1045         }
;;;1046         else
;;;1047         {
;;;1048           /* PLL is already used as System core clock */
;;;1049           return HAL_ERROR;
;;;1050         }
;;;1051       }
;;;1052     }
;;;1053     return HAL_OK;
;;;1054   }
000028  e8bd83f8          POP      {r3-r9,pc}
                  |L13.44|
00002c  2f01              CMP      r7,#1                 ;433
00002e  d00a              BEQ      |L13.70|
                  |L13.48|
000030  69a0              LDR      r0,[r4,#0x18]         ;492
000032  2800              CMP      r0,#0                 ;492
000034  d07d              BEQ      |L13.306|
000036  6830              LDR      r0,[r6,#0]            ;495
000038  f0400001          ORR      r0,r0,#1              ;495
00003c  6030              STR      r0,[r6,#0]            ;495
00003e  f7fffffe          BL       HAL_GetTick
000042  4680              MOV      r8,r0                 ;498
000044  e05f              B        |L13.262|
                  |L13.70|
000046  6830              LDR      r0,[r6,#0]            ;435
000048  0780              LSLS     r0,r0,#30             ;435
00004a  d501              BPL      |L13.80|
00004c  69a0              LDR      r0,[r4,#0x18]         ;435
00004e  b138              CBZ      r0,|L13.96|
                  |L13.80|
000050  6a20              LDR      r0,[r4,#0x20]         ;446
000052  6831              LDR      r1,[r6,#0]            ;446
000054  0709              LSLS     r1,r1,#28             ;446
000056  d505              BPL      |L13.100|
000058  6831              LDR      r1,[r6,#0]            ;446
00005a  f00101f0          AND      r1,r1,#0xf0           ;446
00005e  e006              B        |L13.110|
                  |L13.96|
000060  2001              MOVS     r0,#1                 ;437
000062  e7e1              B        |L13.40|
                  |L13.100|
000064  f8d61094          LDR      r1,[r6,#0x94]         ;446
000068  f4016170          AND      r1,r1,#0xf00          ;446
00006c  0909              LSRS     r1,r1,#4              ;446
                  |L13.110|
00006e  4288              CMP      r0,r1                 ;446
000070  d916              BLS      |L13.160|
000072  f7fffffe          BL       RCC_SetFlashLatencyFromMSIRange
000076  b108              CBZ      r0,|L13.124|
000078  2001              MOVS     r0,#1                 ;451
00007a  e7d5              B        |L13.40|
                  |L13.124|
00007c  6830              LDR      r0,[r6,#0]            ;455
00007e  f0400008          ORR      r0,r0,#8              ;455
000082  6030              STR      r0,[r6,#0]            ;455
000084  6830              LDR      r0,[r6,#0]            ;455
000086  6a21              LDR      r1,[r4,#0x20]         ;455
000088  f02000f0          BIC      r0,r0,#0xf0           ;455
00008c  4308              ORRS     r0,r0,r1              ;455
00008e  6030              STR      r0,[r6,#0]            ;455
000090  6870              LDR      r0,[r6,#4]            ;457
000092  69e1              LDR      r1,[r4,#0x1c]         ;457
000094  f420407f          BIC      r0,r0,#0xff00         ;457
000098  ea402001          ORR      r0,r0,r1,LSL #8       ;457
00009c  6070              STR      r0,[r6,#4]            ;457
00009e  e017              B        |L13.208|
                  |L13.160|
0000a0  6830              LDR      r0,[r6,#0]            ;463
0000a2  f0400008          ORR      r0,r0,#8              ;463
0000a6  6030              STR      r0,[r6,#0]            ;463
0000a8  6830              LDR      r0,[r6,#0]            ;463
0000aa  6a21              LDR      r1,[r4,#0x20]         ;463
0000ac  f02000f0          BIC      r0,r0,#0xf0           ;463
0000b0  4308              ORRS     r0,r0,r1              ;463
0000b2  6030              STR      r0,[r6,#0]            ;463
0000b4  6870              LDR      r0,[r6,#4]            ;465
0000b6  69e1              LDR      r1,[r4,#0x1c]         ;465
0000b8  f420407f          BIC      r0,r0,#0xff00         ;465
0000bc  ea402001          ORR      r0,r0,r1,LSL #8       ;465
0000c0  6070              STR      r0,[r6,#4]            ;465
0000c2  b92d              CBNZ     r5,|L13.208|
0000c4  6a20              LDR      r0,[r4,#0x20]         ;471
0000c6  f7fffffe          BL       RCC_SetFlashLatencyFromMSIRange
0000ca  b108              CBZ      r0,|L13.208|
0000cc  2001              MOVS     r0,#1                 ;473
0000ce  e7ab              B        |L13.40|
                  |L13.208|
0000d0  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0000d4  68b1              LDR      r1,[r6,#8]            ;479
0000d6  4ac5              LDR      r2,|L13.1004|
0000d8  f3c11103          UBFX     r1,r1,#4,#4           ;479
0000dc  5c51              LDRB     r1,[r2,r1]            ;479
0000de  f001011f          AND      r1,r1,#0x1f           ;479
0000e2  40c8              LSRS     r0,r0,r1              ;479
0000e4  49c2              LDR      r1,|L13.1008|
0000e6  6008              STR      r0,[r1,#0]            ;479  ; SystemCoreClock
0000e8  48c2              LDR      r0,|L13.1012|
0000ea  6800              LDR      r0,[r0,#0]            ;482  ; uwTickPrio
0000ec  f7fffffe          BL       HAL_InitTick
0000f0  2800              CMP      r0,#0                 ;483
0000f2  d199              BNE      |L13.40|
                  |L13.244|
0000f4  e030              B        |L13.344|
                  |L13.246|
0000f6  f7fffffe          BL       HAL_GetTick
0000fa  eba00008          SUB      r0,r0,r8              ;503
0000fe  2802              CMP      r0,#2                 ;503
000100  d901              BLS      |L13.262|
000102  2003              MOVS     r0,#3                 ;505
000104  e790              B        |L13.40|
                  |L13.262|
000106  6830              LDR      r0,[r6,#0]            ;501
000108  0780              LSLS     r0,r0,#30             ;501
00010a  d5f4              BPL      |L13.246|
00010c  6830              LDR      r0,[r6,#0]            ;509
00010e  f0400008          ORR      r0,r0,#8              ;509
000112  6030              STR      r0,[r6,#0]            ;509
000114  6830              LDR      r0,[r6,#0]            ;509
000116  6a21              LDR      r1,[r4,#0x20]         ;509
000118  f02000f0          BIC      r0,r0,#0xf0           ;509
00011c  4308              ORRS     r0,r0,r1              ;509
00011e  6030              STR      r0,[r6,#0]            ;509
000120  6870              LDR      r0,[r6,#4]            ;511
000122  f420417f          BIC      r1,r0,#0xff00         ;511
000126  69e0              LDR      r0,[r4,#0x1c]         ;511
000128  ea412000          ORR      r0,r1,r0,LSL #8       ;511
00012c  6070              STR      r0,[r6,#4]            ;511
00012e  e013              B        |L13.344|
000130  e7ff              B        |L13.306|
                  |L13.306|
000132  6830              LDR      r0,[r6,#0]            ;517
000134  f0200001          BIC      r0,r0,#1              ;517
000138  6030              STR      r0,[r6,#0]            ;517
00013a  f7fffffe          BL       HAL_GetTick
00013e  4680              MOV      r8,r0                 ;520
000140  e007              B        |L13.338|
                  |L13.322|
000142  f7fffffe          BL       HAL_GetTick
000146  eba00008          SUB      r0,r0,r8              ;525
00014a  2802              CMP      r0,#2                 ;525
00014c  d901              BLS      |L13.338|
00014e  2003              MOVS     r0,#3                 ;527
000150  e76a              B        |L13.40|
                  |L13.338|
000152  6830              LDR      r0,[r6,#0]            ;523
000154  0780              LSLS     r0,r0,#30             ;523
000156  d4f4              BMI      |L13.322|
                  |L13.344|
000158  7820              LDRB     r0,[r4,#0]            ;534
00015a  07c0              LSLS     r0,r0,#31             ;534
00015c  d04a              BEQ      |L13.500|
00015e  2d08              CMP      r5,#8                 ;540
000160  d018              BEQ      |L13.404|
000162  2d0c              CMP      r5,#0xc               ;541
000164  d101              BNE      |L13.362|
000166  2f03              CMP      r7,#3                 ;541
000168  d014              BEQ      |L13.404|
                  |L13.362|
00016a  6860              LDR      r0,[r4,#4]            ;551
00016c  f5b03f80          CMP      r0,#0x10000           ;551
000170  d017              BEQ      |L13.418|
000172  f5b02fa0          CMP      r0,#0x50000           ;551
000176  d019              BEQ      |L13.428|
000178  6830              LDR      r0,[r6,#0]            ;551
00017a  f4203080          BIC      r0,r0,#0x10000        ;551
00017e  6030              STR      r0,[r6,#0]            ;551
000180  6830              LDR      r0,[r6,#0]            ;551
000182  f4202080          BIC      r0,r0,#0x40000        ;551
000186  6030              STR      r0,[r6,#0]            ;551
                  |L13.392|
000188  6860              LDR      r0,[r4,#4]            ;554
00018a  b320              CBZ      r0,|L13.470|
00018c  f7fffffe          BL       HAL_GetTick
000190  4680              MOV      r8,r0                 ;557
000192  e01c              B        |L13.462|
                  |L13.404|
000194  6830              LDR      r0,[r6,#0]            ;543
000196  0380              LSLS     r0,r0,#14             ;543
000198  d52c              BPL      |L13.500|
00019a  6860              LDR      r0,[r4,#4]            ;543
00019c  bb50              CBNZ     r0,|L13.500|
00019e  2001              MOVS     r0,#1                 ;545
0001a0  e742              B        |L13.40|
                  |L13.418|
0001a2  6830              LDR      r0,[r6,#0]            ;551
0001a4  f4403080          ORR      r0,r0,#0x10000        ;551
0001a8  6030              STR      r0,[r6,#0]            ;551
0001aa  e7ed              B        |L13.392|
                  |L13.428|
0001ac  6830              LDR      r0,[r6,#0]            ;551
0001ae  f4402080          ORR      r0,r0,#0x40000        ;551
0001b2  6030              STR      r0,[r6,#0]            ;551
0001b4  6830              LDR      r0,[r6,#0]            ;551
0001b6  f4403080          ORR      r0,r0,#0x10000        ;551
0001ba  6030              STR      r0,[r6,#0]            ;551
0001bc  e7e4              B        |L13.392|
                  |L13.446|
0001be  f7fffffe          BL       HAL_GetTick
0001c2  eba00008          SUB      r0,r0,r8              ;562
0001c6  2864              CMP      r0,#0x64              ;562
0001c8  d901              BLS      |L13.462|
0001ca  2003              MOVS     r0,#3                 ;564
0001cc  e72c              B        |L13.40|
                  |L13.462|
0001ce  6830              LDR      r0,[r6,#0]            ;560
0001d0  0380              LSLS     r0,r0,#14             ;560
0001d2  d5f4              BPL      |L13.446|
0001d4  e00e              B        |L13.500|
                  |L13.470|
0001d6  f7fffffe          BL       HAL_GetTick
0001da  4680              MOV      r8,r0                 ;571
0001dc  e007              B        |L13.494|
                  |L13.478|
0001de  f7fffffe          BL       HAL_GetTick
0001e2  eba00008          SUB      r0,r0,r8              ;576
0001e6  2864              CMP      r0,#0x64              ;576
0001e8  d901              BLS      |L13.494|
0001ea  2003              MOVS     r0,#3                 ;578
0001ec  e71c              B        |L13.40|
                  |L13.494|
0001ee  6830              LDR      r0,[r6,#0]            ;574
0001f0  0380              LSLS     r0,r0,#14             ;574
0001f2  d4f4              BMI      |L13.478|
                  |L13.500|
0001f4  7820              LDRB     r0,[r4,#0]            ;585
0001f6  0780              LSLS     r0,r0,#30             ;585
0001f8  d542              BPL      |L13.640|
0001fa  2d04              CMP      r5,#4                 ;592
0001fc  d00d              BEQ      |L13.538|
0001fe  2d0c              CMP      r5,#0xc               ;593
000200  d101              BNE      |L13.518|
000202  2f02              CMP      r7,#2                 ;593
000204  d009              BEQ      |L13.538|
                  |L13.518|
000206  68e0              LDR      r0,[r4,#0xc]          ;610
000208  b340              CBZ      r0,|L13.604|
00020a  6830              LDR      r0,[r6,#0]            ;613
00020c  f4407080          ORR      r0,r0,#0x100          ;613
000210  6030              STR      r0,[r6,#0]            ;613
000212  f7fffffe          BL       HAL_GetTick
000216  4607              MOV      r7,r0                 ;616
000218  e015              B        |L13.582|
                  |L13.538|
00021a  6830              LDR      r0,[r6,#0]            ;596
00021c  0540              LSLS     r0,r0,#21             ;596
00021e  d501              BPL      |L13.548|
000220  68e0              LDR      r0,[r4,#0xc]          ;596
000222  b138              CBZ      r0,|L13.564|
                  |L13.548|
000224  6870              LDR      r0,[r6,#4]            ;604
000226  7c21              LDRB     r1,[r4,#0x10]         ;604
000228  f02040fe          BIC      r0,r0,#0x7f000000     ;604
00022c  ea406001          ORR      r0,r0,r1,LSL #24      ;604
000230  6070              STR      r0,[r6,#4]            ;604
000232  e025              B        |L13.640|
                  |L13.564|
000234  2001              MOVS     r0,#1                 ;598
000236  e6f7              B        |L13.40|
                  |L13.568|
000238  f7fffffe          BL       HAL_GetTick
00023c  1bc0              SUBS     r0,r0,r7              ;621
00023e  2802              CMP      r0,#2                 ;621
000240  d901              BLS      |L13.582|
000242  2003              MOVS     r0,#3                 ;623
000244  e6f0              B        |L13.40|
                  |L13.582|
000246  6830              LDR      r0,[r6,#0]            ;619
000248  0540              LSLS     r0,r0,#21             ;619
00024a  d5f5              BPL      |L13.568|
00024c  6870              LDR      r0,[r6,#4]            ;628
00024e  7c21              LDRB     r1,[r4,#0x10]         ;628
000250  f02040fe          BIC      r0,r0,#0x7f000000     ;628
000254  ea406001          ORR      r0,r0,r1,LSL #24      ;628
000258  6070              STR      r0,[r6,#4]            ;628
00025a  e011              B        |L13.640|
                  |L13.604|
00025c  6830              LDR      r0,[r6,#0]            ;633
00025e  f4207080          BIC      r0,r0,#0x100          ;633
000262  6030              STR      r0,[r6,#0]            ;633
000264  f7fffffe          BL       HAL_GetTick
000268  4607              MOV      r7,r0                 ;636
00026a  e006              B        |L13.634|
                  |L13.620|
00026c  f7fffffe          BL       HAL_GetTick
000270  1bc0              SUBS     r0,r0,r7              ;641
000272  2802              CMP      r0,#2                 ;641
000274  d901              BLS      |L13.634|
000276  2003              MOVS     r0,#3                 ;643
000278  e6d6              B        |L13.40|
                  |L13.634|
00027a  6830              LDR      r0,[r6,#0]            ;639
00027c  0540              LSLS     r0,r0,#21             ;639
00027e  d4f5              BMI      |L13.620|
                  |L13.640|
000280  7820              LDRB     r0,[r4,#0]            ;650
000282  0700              LSLS     r0,r0,#28             ;650
000284  d52c              BPL      |L13.736|
000286  6960              LDR      r0,[r4,#0x14]         ;656
000288  b1a8              CBZ      r0,|L13.694|
00028a  f8d60094          LDR      r0,[r6,#0x94]         ;698
00028e  f0400001          ORR      r0,r0,#1              ;698
000292  f8c60094          STR      r0,[r6,#0x94]         ;698
000296  f7fffffe          BL       HAL_GetTick
00029a  4607              MOV      r7,r0                 ;701
00029c  e006              B        |L13.684|
                  |L13.670|
00029e  f7fffffe          BL       HAL_GetTick
0002a2  1bc0              SUBS     r0,r0,r7              ;706
0002a4  2802              CMP      r0,#2                 ;706
0002a6  d901              BLS      |L13.684|
0002a8  2003              MOVS     r0,#3                 ;708
0002aa  e6bd              B        |L13.40|
                  |L13.684|
0002ac  f8d60094          LDR      r0,[r6,#0x94]         ;704
0002b0  0780              LSLS     r0,r0,#30             ;704
0002b2  d5f4              BPL      |L13.670|
0002b4  e014              B        |L13.736|
                  |L13.694|
0002b6  f8d60094          LDR      r0,[r6,#0x94]         ;715
0002ba  f0200001          BIC      r0,r0,#1              ;715
0002be  f8c60094          STR      r0,[r6,#0x94]         ;715
0002c2  f7fffffe          BL       HAL_GetTick
0002c6  4607              MOV      r7,r0                 ;718
0002c8  e006              B        |L13.728|
                  |L13.714|
0002ca  f7fffffe          BL       HAL_GetTick
0002ce  1bc0              SUBS     r0,r0,r7              ;723
0002d0  2802              CMP      r0,#2                 ;723
0002d2  d901              BLS      |L13.728|
0002d4  2003              MOVS     r0,#3                 ;725
0002d6  e6a7              B        |L13.40|
                  |L13.728|
0002d8  f8d60094          LDR      r0,[r6,#0x94]         ;721
0002dc  0780              LSLS     r0,r0,#30             ;721
0002de  d4f4              BMI      |L13.714|
                  |L13.736|
0002e0  7820              LDRB     r0,[r4,#0]            ;731
0002e2  0740              LSLS     r0,r0,#29             ;731
0002e4  d570              BPL      |L13.968|
0002e6  f04f0800          MOV      r8,#0                 ;733
0002ea  6db0              LDR      r0,[r6,#0x58]         ;740
0002ec  00c0              LSLS     r0,r0,#3              ;740
0002ee  d409              BMI      |L13.772|
0002f0  6db0              LDR      r0,[r6,#0x58]         ;742
0002f2  f0405080          ORR      r0,r0,#0x10000000     ;742
0002f6  65b0              STR      r0,[r6,#0x58]         ;742
0002f8  6db0              LDR      r0,[r6,#0x58]         ;742
0002fa  f0005080          AND      r0,r0,#0x10000000     ;742
0002fe  9000              STR      r0,[sp,#0]            ;742
000300  f04f0801          MOV      r8,#1                 ;743
                  |L13.772|
000304  4f3c              LDR      r7,|L13.1016|
000306  6838              LDR      r0,[r7,#0]            ;746
000308  05c0              LSLS     r0,r0,#23             ;746
00030a  d412              BMI      |L13.818|
00030c  6838              LDR      r0,[r7,#0]            ;749
00030e  f4407080          ORR      r0,r0,#0x100          ;749
000312  6038              STR      r0,[r7,#0]            ;749
000314  f7fffffe          BL       HAL_GetTick
000318  4681              MOV      r9,r0                 ;752
00031a  e007              B        |L13.812|
                  |L13.796|
00031c  f7fffffe          BL       HAL_GetTick
000320  eba00009          SUB      r0,r0,r9              ;756
000324  2802              CMP      r0,#2                 ;756
000326  d901              BLS      |L13.812|
000328  2003              MOVS     r0,#3                 ;758
00032a  e67d              B        |L13.40|
                  |L13.812|
00032c  6838              LDR      r0,[r7,#0]            ;754
00032e  05c0              LSLS     r0,r0,#23             ;754
000330  d5f4              BPL      |L13.796|
                  |L13.818|
000332  68a0              LDR      r0,[r4,#8]            ;788
000334  2801              CMP      r0,#1                 ;788
000336  d013              BEQ      |L13.864|
000338  2805              CMP      r0,#5                 ;788
00033a  d018              BEQ      |L13.878|
00033c  f8560f90          LDR      r0,[r6,#0x90]!        ;788
000340  f0200001          BIC      r0,r0,#1              ;788
000344  6030              STR      r0,[r6,#0]            ;788
000346  6830              LDR      r0,[r6,#0]            ;788
000348  f0200004          BIC      r0,r0,#4              ;788
00034c  f8460990          STR      r0,[r6],#-0x90        ;788
                  |L13.848|
000350  68a0              LDR      r0,[r4,#8]            ;792
000352  f2413988          MOV      r9,#0x1388            ;800
000356  b308              CBZ      r0,|L13.924|
000358  f7fffffe          BL       HAL_GetTick
00035c  4607              MOV      r7,r0                 ;795
00035e  e018              B        |L13.914|
                  |L13.864|
000360  f8d60090          LDR      r0,[r6,#0x90]         ;788
000364  f0400001          ORR      r0,r0,#1              ;788
000368  f8c60090          STR      r0,[r6,#0x90]         ;788
00036c  e7f0              B        |L13.848|
                  |L13.878|
00036e  f8560f90          LDR      r0,[r6,#0x90]!        ;788
000372  f0400004          ORR      r0,r0,#4              ;788
000376  6030              STR      r0,[r6,#0]            ;788
000378  6830              LDR      r0,[r6,#0]            ;788
00037a  f0400001          ORR      r0,r0,#1              ;788
00037e  f8460990          STR      r0,[r6],#-0x90        ;788
000382  e7e5              B        |L13.848|
                  |L13.900|
000384  f7fffffe          BL       HAL_GetTick
000388  1bc0              SUBS     r0,r0,r7              ;800
00038a  4548              CMP      r0,r9                 ;800
00038c  d901              BLS      |L13.914|
00038e  2003              MOVS     r0,#3                 ;802
000390  e64a              B        |L13.40|
                  |L13.914|
000392  f8d60090          LDR      r0,[r6,#0x90]         ;798
000396  0780              LSLS     r0,r0,#30             ;798
000398  d5f4              BPL      |L13.900|
00039a  e00e              B        |L13.954|
                  |L13.924|
00039c  f7fffffe          BL       HAL_GetTick
0003a0  4607              MOV      r7,r0                 ;809
0003a2  e006              B        |L13.946|
                  |L13.932|
0003a4  f7fffffe          BL       HAL_GetTick
0003a8  1bc0              SUBS     r0,r0,r7              ;814
0003aa  4548              CMP      r0,r9                 ;814
0003ac  d901              BLS      |L13.946|
0003ae  2003              MOVS     r0,#3                 ;816
0003b0  e63a              B        |L13.40|
                  |L13.946|
0003b2  f8d60090          LDR      r0,[r6,#0x90]         ;812
0003b6  0780              LSLS     r0,r0,#30             ;812
0003b8  d4f4              BMI      |L13.932|
                  |L13.954|
0003ba  f1b80f01          CMP      r8,#1                 ;827
0003be  d103              BNE      |L13.968|
0003c0  6db0              LDR      r0,[r6,#0x58]         ;829
0003c2  f0205080          BIC      r0,r0,#0x10000000     ;829
0003c6  65b0              STR      r0,[r6,#0x58]         ;829
                  |L13.968|
0003c8  7820              LDRB     r0,[r4,#0]            ;834
0003ca  0680              LSLS     r0,r0,#26             ;834
0003cc  d537              BPL      |L13.1086|
0003ce  6a60              LDR      r0,[r4,#0x24]         ;840
0003d0  b300              CBZ      r0,|L13.1044|
0003d2  f8d60098          LDR      r0,[r6,#0x98]         ;843
0003d6  f0400001          ORR      r0,r0,#1              ;843
0003da  f8c60098          STR      r0,[r6,#0x98]         ;843
0003de  f7fffffe          BL       HAL_GetTick
0003e2  4607              MOV      r7,r0                 ;846
0003e4  e011              B        |L13.1034|
0003e6  0000              DCW      0x0000
                  |L13.1000|
                          DCD      0x40021000
                  |L13.1004|
                          DCD      AHBPrescTable
                  |L13.1008|
                          DCD      SystemCoreClock
                  |L13.1012|
                          DCD      uwTickPrio
                  |L13.1016|
                          DCD      0x40007000
                  |L13.1020|
0003fc  f7fffffe          BL       HAL_GetTick
000400  1bc0              SUBS     r0,r0,r7              ;851
000402  2802              CMP      r0,#2                 ;851
000404  d901              BLS      |L13.1034|
000406  2003              MOVS     r0,#3                 ;853
000408  e60e              B        |L13.40|
                  |L13.1034|
00040a  f8d60098          LDR      r0,[r6,#0x98]         ;849
00040e  0780              LSLS     r0,r0,#30             ;849
000410  d5f4              BPL      |L13.1020|
000412  e014              B        |L13.1086|
                  |L13.1044|
000414  f8d60098          LDR      r0,[r6,#0x98]         ;860
000418  f0200001          BIC      r0,r0,#1              ;860
00041c  f8c60098          STR      r0,[r6,#0x98]         ;860
000420  f7fffffe          BL       HAL_GetTick
000424  4607              MOV      r7,r0                 ;863
000426  e006              B        |L13.1078|
                  |L13.1064|
000428  f7fffffe          BL       HAL_GetTick
00042c  1bc0              SUBS     r0,r0,r7              ;868
00042e  2802              CMP      r0,#2                 ;868
000430  d901              BLS      |L13.1078|
000432  2003              MOVS     r0,#3                 ;870
000434  e5f8              B        |L13.40|
                  |L13.1078|
000436  f8d60098          LDR      r0,[r6,#0x98]         ;866
00043a  0780              LSLS     r0,r0,#30             ;866
00043c  d4f4              BMI      |L13.1064|
                  |L13.1086|
00043e  6aa0              LDR      r0,[r4,#0x28]         ;880
000440  b3f0              CBZ      r0,|L13.1216|
000442  2802              CMP      r0,#2                 ;883
000444  d00a              BEQ      |L13.1116|
000446  2d0c              CMP      r5,#0xc               ;1006
000448  d07a              BEQ      |L13.1344|
00044a  6830              LDR      r0,[r6,#0]            ;1009
00044c  f0207080          BIC      r0,r0,#0x1000000      ;1009
000450  6030              STR      r0,[r6,#0]            ;1009
000452  6830              LDR      r0,[r6,#0]            ;1013
000454  f0105f20          TST      r0,#0x28000000        ;1013
000458  d073              BEQ      |L13.1346|
00045a  e09e              B        |L13.1434|
                  |L13.1116|
00045c  68f0              LDR      r0,[r6,#0xc]          ;896
00045e  6ae2              LDR      r2,[r4,#0x2c]         ;897
000460  f0000103          AND      r1,r0,#3              ;897
000464  f04f37ff          MOV      r7,#0xffffffff        ;907
000468  4291              CMP      r1,r2                 ;897
00046a  d124              BNE      |L13.1206|
00046c  6b21              LDR      r1,[r4,#0x30]         ;898
00046e  f0000270          AND      r2,r0,#0x70           ;898
000472  1e49              SUBS     r1,r1,#1              ;898
000474  ebb21f01          CMP      r2,r1,LSL #4          ;898
000478  d11d              BNE      |L13.1206|
00047a  6b62              LDR      r2,[r4,#0x34]         ;899
00047c  f40041fe          AND      r1,r0,#0x7f00         ;899
000480  ebb12f02          CMP      r1,r2,LSL #8          ;899
000484  d117              BNE      |L13.1206|
000486  f8942038          LDRB     r2,[r4,#0x38]         ;902
00048a  f0004178          AND      r1,r0,#0xf8000000     ;902
00048e  ebb16fc2          CMP      r1,r2,LSL #27         ;902
000492  d110              BNE      |L13.1206|
000494  8fa2              LDRH     r2,[r4,#0x3c]         ;907
000496  f40001c0          AND      r1,r0,#0x600000       ;907
00049a  eb070252          ADD      r2,r7,r2,LSR #1       ;907
00049e  ebb15f42          CMP      r1,r2,LSL #21         ;907
0004a2  d108              BNE      |L13.1206|
0004a4  f8941040          LDRB     r1,[r4,#0x40]         ;908
0004a8  f00060c0          AND      r0,r0,#0x6000000      ;908
0004ac  eb070151          ADD      r1,r7,r1,LSR #1       ;908
0004b0  ebb06f41          CMP      r0,r1,LSL #25         ;908
0004b4  d053              BEQ      |L13.1374|
                  |L13.1206|
0004b6  2d0c              CMP      r5,#0xc               ;911
0004b8  d04f              BEQ      |L13.1370|
0004ba  6830              LDR      r0,[r6,#0]            ;916
0004bc  0140              LSLS     r0,r0,#5              ;916
0004be  e000              B        |L13.1218|
                  |L13.1216|
0004c0  e066              B        |L13.1424|
                  |L13.1218|
0004c2  d402              BMI      |L13.1226|
0004c4  6830              LDR      r0,[r6,#0]            ;918
0004c6  00c0              LSLS     r0,r0,#3              ;918
0004c8  d501              BPL      |L13.1230|
                  |L13.1226|
0004ca  2001              MOVS     r0,#1                 ;922
0004cc  e5ac              B        |L13.40|
                  |L13.1230|
0004ce  6830              LDR      r0,[r6,#0]            ;928
0004d0  f0207080          BIC      r0,r0,#0x1000000      ;928
0004d4  6030              STR      r0,[r6,#0]            ;928
0004d6  f7fffffe          BL       HAL_GetTick
0004da  4605              MOV      r5,r0                 ;931
0004dc  e006              B        |L13.1260|
                  |L13.1246|
0004de  f7fffffe          BL       HAL_GetTick
0004e2  1b40              SUBS     r0,r0,r5              ;936
0004e4  2802              CMP      r0,#2                 ;936
0004e6  d901              BLS      |L13.1260|
0004e8  2003              MOVS     r0,#3                 ;938
0004ea  e59d              B        |L13.40|
                  |L13.1260|
0004ec  6830              LDR      r0,[r6,#0]            ;934
0004ee  0180              LSLS     r0,r0,#6              ;934
0004f0  d4f5              BMI      |L13.1246|
0004f2  f8541f2c          LDR      r1,[r4,#0x2c]!        ;943
0004f6  6860              LDR      r0,[r4,#4]            ;943
0004f8  8a22              LDRH     r2,[r4,#0x10]         ;943
0004fa  1e40              SUBS     r0,r0,#1              ;943
0004fc  ea411000          ORR      r0,r1,r0,LSL #4       ;943
000500  68a1              LDR      r1,[r4,#8]            ;943
000502  eb070252          ADD      r2,r7,r2,LSR #1       ;943
000506  0209              LSLS     r1,r1,#8              ;943
000508  ea415142          ORR      r1,r1,r2,LSL #21      ;943
00050c  4308              ORRS     r0,r0,r1              ;943
00050e  7d21              LDRB     r1,[r4,#0x14]         ;943
000510  eb070151          ADD      r1,r7,r1,LSR #1       ;943
000514  ea406041          ORR      r0,r0,r1,LSL #25      ;943
000518  7b21              LDRB     r1,[r4,#0xc]          ;943
00051a  ea4060c1          ORR      r0,r0,r1,LSL #27      ;943
00051e  68f1              LDR      r1,[r6,#0xc]          ;943
000520  4a29              LDR      r2,|L13.1480|
000522  4011              ANDS     r1,r1,r2              ;943
000524  4308              ORRS     r0,r0,r1              ;943
000526  60f0              STR      r0,[r6,#0xc]          ;943
000528  6830              LDR      r0,[r6,#0]            ;953
00052a  f0407080          ORR      r0,r0,#0x1000000      ;953
00052e  6030              STR      r0,[r6,#0]            ;953
000530  68f0              LDR      r0,[r6,#0xc]          ;956
000532  f0407080          ORR      r0,r0,#0x1000000      ;956
000536  60f0              STR      r0,[r6,#0xc]          ;956
000538  f7fffffe          BL       HAL_GetTick
00053c  4604              MOV      r4,r0                 ;959
00053e  e008              B        |L13.1362|
                  |L13.1344|
000540  e03f              B        |L13.1474|
                  |L13.1346|
000542  e026              B        |L13.1426|
                  |L13.1348|
000544  f7fffffe          BL       HAL_GetTick
000548  1b00              SUBS     r0,r0,r4              ;964
00054a  2802              CMP      r0,#2                 ;964
00054c  d901              BLS      |L13.1362|
00054e  2003              MOVS     r0,#3                 ;966
000550  e56a              B        |L13.40|
                  |L13.1362|
000552  6830              LDR      r0,[r6,#0]            ;962
000554  0180              LSLS     r0,r0,#6              ;962
000556  d5f5              BPL      |L13.1348|
000558  e031              B        |L13.1470|
                  |L13.1370|
00055a  2001              MOVS     r0,#1                 ;974
00055c  e564              B        |L13.40|
                  |L13.1374|
00055e  6830              LDR      r0,[r6,#0]            ;981
000560  0180              LSLS     r0,r0,#6              ;981
000562  d42c              BMI      |L13.1470|
000564  6830              LDR      r0,[r6,#0]            ;984
000566  f0407080          ORR      r0,r0,#0x1000000      ;984
00056a  6030              STR      r0,[r6,#0]            ;984
00056c  68f0              LDR      r0,[r6,#0xc]          ;987
00056e  f0407080          ORR      r0,r0,#0x1000000      ;987
000572  60f0              STR      r0,[r6,#0xc]          ;987
000574  f7fffffe          BL       HAL_GetTick
000578  4604              MOV      r4,r0                 ;990
00057a  e006              B        |L13.1418|
                  |L13.1404|
00057c  f7fffffe          BL       HAL_GetTick
000580  1b00              SUBS     r0,r0,r4              ;995
000582  2802              CMP      r0,#2                 ;995
000584  d901              BLS      |L13.1418|
000586  2003              MOVS     r0,#3                 ;997
000588  e54e              B        |L13.40|
                  |L13.1418|
00058a  6830              LDR      r0,[r6,#0]            ;993
00058c  0180              LSLS     r0,r0,#6              ;993
00058e  d5f5              BPL      |L13.1404|
                  |L13.1424|
000590  e015              B        |L13.1470|
                  |L13.1426|
000592  68f0              LDR      r0,[r6,#0xc]          ;1015
000594  f0200003          BIC      r0,r0,#3              ;1015
000598  60f0              STR      r0,[r6,#0xc]          ;1015
                  |L13.1434|
00059a  68f0              LDR      r0,[r6,#0xc]          ;1027
00059c  490b              LDR      r1,|L13.1484|
00059e  4008              ANDS     r0,r0,r1              ;1027
0005a0  60f0              STR      r0,[r6,#0xc]          ;1027
0005a2  f7fffffe          BL       HAL_GetTick
0005a6  4604              MOV      r4,r0                 ;1035
0005a8  e006              B        |L13.1464|
                  |L13.1450|
0005aa  f7fffffe          BL       HAL_GetTick
0005ae  1b00              SUBS     r0,r0,r4              ;1040
0005b0  2802              CMP      r0,#2                 ;1040
0005b2  d901              BLS      |L13.1464|
0005b4  2003              MOVS     r0,#3                 ;1042
0005b6  e537              B        |L13.40|
                  |L13.1464|
0005b8  6830              LDR      r0,[r6,#0]            ;1038
0005ba  0180              LSLS     r0,r0,#6              ;1038
0005bc  d4f5              BMI      |L13.1450|
                  |L13.1470|
0005be  2000              MOVS     r0,#0                 ;1053
0005c0  e532              B        |L13.40|
                  |L13.1474|
0005c2  2001              MOVS     r0,#1                 ;1049
0005c4  e530              B        |L13.40|
;;;1055   
                          ENDP

0005c6  0000              DCW      0x0000
                  |L13.1480|
                          DCD      0x019d808c
                  |L13.1484|
                          DCD      0xfeeeffff

                          AREA ||i.RCC_SetFlashLatencyFromMSIRange||, CODE, READONLY, ALIGN=2

                  RCC_SetFlashLatencyFromMSIRange PROC
;;;1770     */
;;;1771   static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1772   {
000002  4605              MOV      r5,r0
;;;1773     uint32_t vos;
;;;1774     uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
000004  2400              MOVS     r4,#0
;;;1775   
;;;1776     if(__HAL_RCC_PWR_IS_CLK_ENABLED())
000006  4e1d              LDR      r6,|L14.124|
000008  6db0              LDR      r0,[r6,#0x58]
00000a  00c0              LSLS     r0,r0,#3
00000c  d502              BPL      |L14.20|
;;;1777     {
;;;1778       vos = HAL_PWREx_GetVoltageRange();
00000e  f7fffffe          BL       HAL_PWREx_GetVoltageRange
000012  e00d              B        |L14.48|
                  |L14.20|
;;;1779     }
;;;1780     else
;;;1781     {
;;;1782       __HAL_RCC_PWR_CLK_ENABLE();
000014  6db0              LDR      r0,[r6,#0x58]
000016  f0405080          ORR      r0,r0,#0x10000000
00001a  65b0              STR      r0,[r6,#0x58]
00001c  6db0              LDR      r0,[r6,#0x58]
00001e  f0005080          AND      r0,r0,#0x10000000
000022  9000              STR      r0,[sp,#0]
;;;1783       vos = HAL_PWREx_GetVoltageRange();
000024  f7fffffe          BL       HAL_PWREx_GetVoltageRange
;;;1784       __HAL_RCC_PWR_CLK_DISABLE();
000028  6db1              LDR      r1,[r6,#0x58]
00002a  f0215180          BIC      r1,r1,#0x10000000
00002e  65b1              STR      r1,[r6,#0x58]
                  |L14.48|
;;;1785     }
;;;1786   
;;;1787     if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
000030  f5b07f00          CMP      r0,#0x200
000034  d004              BEQ      |L14.64|
;;;1788     {
;;;1789       if(msirange > RCC_MSIRANGE_8)
;;;1790       {
;;;1791         /* MSI > 16Mhz */
;;;1792         if(msirange > RCC_MSIRANGE_10)
;;;1793         {
;;;1794           /* MSI 48Mhz */
;;;1795           latency = FLASH_LATENCY_2; /* 2WS */
;;;1796         }
;;;1797         else
;;;1798         {
;;;1799           /* MSI 24Mhz or 32Mhz */
;;;1800           latency = FLASH_LATENCY_1; /* 1WS */
;;;1801         }
;;;1802       }
;;;1803       /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
;;;1804     }
;;;1805     else
;;;1806     {
;;;1807   #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;1808       defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;1809       if(msirange >= RCC_MSIRANGE_8)
;;;1810       {
;;;1811         /* MSI >= 16Mhz */
;;;1812         latency = FLASH_LATENCY_2; /* 2WS */
;;;1813       }
;;;1814       else
;;;1815       {
;;;1816         if(msirange == RCC_MSIRANGE_7)
;;;1817         {
;;;1818           /* MSI 8Mhz */
;;;1819           latency = FLASH_LATENCY_1; /* 1WS */
;;;1820         }
;;;1821         /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
;;;1822       }
;;;1823   #else
;;;1824       if(msirange > RCC_MSIRANGE_8)
000036  2d80              CMP      r5,#0x80
000038  d90a              BLS      |L14.80|
;;;1825       {
;;;1826         /* MSI > 16Mhz */
;;;1827         latency = FLASH_LATENCY_3; /* 3WS */
00003a  f04f0403          MOV      r4,#3
00003e  e00d              B        |L14.92|
                  |L14.64|
000040  2d80              CMP      r5,#0x80              ;1789
000042  d90b              BLS      |L14.92|
000044  2da0              CMP      r5,#0xa0              ;1792
000046  d901              BLS      |L14.76|
000048  2402              MOVS     r4,#2                 ;1795
00004a  e007              B        |L14.92|
                  |L14.76|
00004c  2401              MOVS     r4,#1                 ;1800
00004e  e005              B        |L14.92|
                  |L14.80|
;;;1828       }
;;;1829       else
;;;1830       {
;;;1831         if(msirange == RCC_MSIRANGE_8)
000050  d101              BNE      |L14.86|
;;;1832         {
;;;1833           /* MSI 16Mhz */
;;;1834           latency = FLASH_LATENCY_2; /* 2WS */
000052  2402              MOVS     r4,#2
000054  e002              B        |L14.92|
                  |L14.86|
;;;1835         }
;;;1836         else if(msirange == RCC_MSIRANGE_7)
000056  2d70              CMP      r5,#0x70
000058  d100              BNE      |L14.92|
;;;1837         {
;;;1838           /* MSI 8Mhz */
;;;1839           latency = FLASH_LATENCY_1; /* 1WS */
00005a  2401              MOVS     r4,#1
                  |L14.92|
;;;1840         }
;;;1841         /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
;;;1842       }
;;;1843   #endif
;;;1844     }
;;;1845   
;;;1846     __HAL_FLASH_SET_LATENCY(latency);
00005c  4808              LDR      r0,|L14.128|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210107          BIC      r1,r1,#7
000064  4321              ORRS     r1,r1,r4
000066  6001              STR      r1,[r0,#0]
;;;1847   
;;;1848     /* Check that the new number of wait states is taken into account to access the Flash
;;;1849        memory by reading the FLASH_ACR register */
;;;1850     if(__HAL_FLASH_GET_LATENCY() != latency)
000068  6800              LDR      r0,[r0,#0]
00006a  f0000007          AND      r0,r0,#7
00006e  42a0              CMP      r0,r4
000070  d001              BEQ      |L14.118|
;;;1851     {
;;;1852       return HAL_ERROR;
000072  2001              MOVS     r0,#1
;;;1853     }
;;;1854   
;;;1855     return HAL_OK;
;;;1856   }
000074  bdf8              POP      {r3-r7,pc}
                  |L14.118|
000076  2000              MOVS     r0,#0                 ;1855
000078  bdf8              POP      {r3-r7,pc}
;;;1857   
                          ENDP

00007a  0000              DCW      0x0000
                  |L14.124|
                          DCD      0x40021000
                  |L14.128|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____RRX|
#line 694
|__asm___19_stm32l4xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
