L 1 "..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_ll_opamp.c"
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_opamp.c
N  * @author  MCD Application Team
N  * @brief   OPAMP LL module driver
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 0L
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32l4xx_ll_opamp.h"
S
S#ifdef  USE_FULL_ASSERT
S  #include "stm32_assert.h"
S#else
S  #define assert_param(expr) ((void)0U)
S#endif
S
S/** @addtogroup STM32L4xx_LL_Driver
S  * @{
S  */
S
S#if defined (OPAMP1) || defined (OPAMP2)
S
S/** @addtogroup OPAMP_LL OPAMP
S  * @{
S  */
S
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/* Private macros ------------------------------------------------------------*/
S
S/** @addtogroup OPAMP_LL_Private_Macros
S  * @{
S  */
S
S/* Check of parameters for configuration of OPAMP hierarchical scope:         */
S/* OPAMP instance.                                                            */
S
S#define IS_LL_OPAMP_POWER_MODE(__POWER_MODE__)                                 \
S  (   ((__POWER_MODE__) == LL_OPAMP_POWERMODE_NORMAL)                          \
S   || ((__POWER_MODE__) == LL_OPAMP_POWERMODE_LOWPOWER))
X#define IS_LL_OPAMP_POWER_MODE(__POWER_MODE__)                                   (   ((__POWER_MODE__) == LL_OPAMP_POWERMODE_NORMAL)                             || ((__POWER_MODE__) == LL_OPAMP_POWERMODE_LOWPOWER))
S
S#define IS_LL_OPAMP_FUNCTIONAL_MODE(__FUNCTIONAL_MODE__)                       \
S  (   ((__FUNCTIONAL_MODE__) == LL_OPAMP_MODE_STANDALONE)                      \
S   || ((__FUNCTIONAL_MODE__) == LL_OPAMP_MODE_FOLLOWER)                        \
S   || ((__FUNCTIONAL_MODE__) == LL_OPAMP_MODE_PGA)                             \
S  )
X#define IS_LL_OPAMP_FUNCTIONAL_MODE(__FUNCTIONAL_MODE__)                         (   ((__FUNCTIONAL_MODE__) == LL_OPAMP_MODE_STANDALONE)                         || ((__FUNCTIONAL_MODE__) == LL_OPAMP_MODE_FOLLOWER)                           || ((__FUNCTIONAL_MODE__) == LL_OPAMP_MODE_PGA)                               )
S
S/* Note: Comparator non-inverting inputs parameters are the same on all       */
S/*       OPAMP instances.                                                     */
S/*       However, comparator instance kept as macro parameter for             */
S/*       compatibility with other STM32 families.                             */
S#define IS_LL_OPAMP_INPUT_NONINVERTING(__OPAMPX__, __INPUT_NONINVERTING__)     \
S  (   ((__INPUT_NONINVERTING__) == LL_OPAMP_INPUT_NONINVERT_IO0)               \
S   || ((__INPUT_NONINVERTING__) == LL_OPAMP_INPUT_NONINV_DAC1_CH1)             \
S  )
X#define IS_LL_OPAMP_INPUT_NONINVERTING(__OPAMPX__, __INPUT_NONINVERTING__)       (   ((__INPUT_NONINVERTING__) == LL_OPAMP_INPUT_NONINVERT_IO0)                  || ((__INPUT_NONINVERTING__) == LL_OPAMP_INPUT_NONINV_DAC1_CH1)               )
S
S/* Note: Comparator non-inverting inputs parameters are the same on all       */
S/*       OPAMP instances.                                                     */
S/*       However, comparator instance kept as macro parameter for             */
S/*       compatibility with other STM32 families.                             */
S#define IS_LL_OPAMP_INPUT_INVERTING(__OPAMPX__, __INPUT_INVERTING__)           \
S  (   ((__INPUT_INVERTING__) == LL_OPAMP_INPUT_INVERT_IO0)                     \
S   || ((__INPUT_INVERTING__) == LL_OPAMP_INPUT_INVERT_IO1)                     \
S   || ((__INPUT_INVERTING__) == LL_OPAMP_INPUT_INVERT_CONNECT_NO)              \
S  )
X#define IS_LL_OPAMP_INPUT_INVERTING(__OPAMPX__, __INPUT_INVERTING__)             (   ((__INPUT_INVERTING__) == LL_OPAMP_INPUT_INVERT_IO0)                        || ((__INPUT_INVERTING__) == LL_OPAMP_INPUT_INVERT_IO1)                        || ((__INPUT_INVERTING__) == LL_OPAMP_INPUT_INVERT_CONNECT_NO)                )
S
S/**
S  * @}
S  */
S
S
S/* Private function prototypes -----------------------------------------------*/
S
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup OPAMP_LL_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup OPAMP_LL_EF_Init
S  * @{
S  */
S
S/**
S  * @brief  De-initialize registers of the selected OPAMP instance
S  *         to their default reset values.
S  * @param  OPAMPx OPAMP instance
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: OPAMP registers are de-initialized
S  *          - ERROR: OPAMP registers are not de-initialized
S  */
SErrorStatus LL_OPAMP_DeInit(OPAMP_TypeDef* OPAMPx)
S{
S  ErrorStatus status = SUCCESS;
S
S  /* Check the parameters */
S  assert_param(IS_OPAMP_ALL_INSTANCE(OPAMPx));
S
S  LL_OPAMP_WriteReg(OPAMPx, CSR, 0x00000000U);
S
S  return status;
S}
S
S/**
S  * @brief  Initialize some features of OPAMP instance.
S  * @note   This function reset bit of calibration mode to ensure
S  *         to be in functional mode, in order to have OPAMP parameters
S  *         (inputs selection, ...) set with the corresponding OPAMP mode
S  *         to be effective.
S  * @note   This function configures features of the selected OPAMP instance.
S  *         Some features are also available at scope OPAMP common instance
S  *         (common to several OPAMP instances).
S  *         Refer to functions having argument "OPAMPxy_COMMON" as parameter.
S  * @param  OPAMPx OPAMP instance
S  * @param  OPAMP_InitStruct Pointer to a @ref LL_OPAMP_InitTypeDef structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: OPAMP registers are initialized
S  *          - ERROR: OPAMP registers are not initialized
S  */
SErrorStatus LL_OPAMP_Init(OPAMP_TypeDef *OPAMPx, LL_OPAMP_InitTypeDef *OPAMP_InitStruct)
S{
S  /* Check the parameters */
S  assert_param(IS_OPAMP_ALL_INSTANCE(OPAMPx));
S  assert_param(IS_LL_OPAMP_POWER_MODE(OPAMP_InitStruct->PowerMode));
S  assert_param(IS_LL_OPAMP_FUNCTIONAL_MODE(OPAMP_InitStruct->FunctionalMode));
S  assert_param(IS_LL_OPAMP_INPUT_NONINVERTING(OPAMPx, OPAMP_InitStruct->InputNonInverting));
S
S  /* Note: OPAMP inverting input can be used with OPAMP in mode standalone    */
S  /*       or PGA with external capacitors for filtering circuit.             */
S  /*       Otherwise (OPAMP in mode follower), OPAMP inverting input is       */
S  /*       not used (not connected to GPIO pin).                              */
S  if(OPAMP_InitStruct->FunctionalMode != LL_OPAMP_MODE_FOLLOWER)
S  {
S    assert_param(IS_LL_OPAMP_INPUT_INVERTING(OPAMPx, OPAMP_InitStruct->InputInverting));
S  }
S
S  /* Configuration of OPAMP instance :                                        */
S  /*  - PowerMode                                                             */
S  /*  - Functional mode                                                       */
S  /*  - Input non-inverting                                                   */
S  /*  - Input inverting                                                       */
S  /* Note: Bit OPAMP_CSR_CALON reset to ensure to be in functional mode.      */
S  if(OPAMP_InitStruct->FunctionalMode != LL_OPAMP_MODE_FOLLOWER)
S  {
S    MODIFY_REG(OPAMPx->CSR,
S                 OPAMP_CSR_OPALPM
S               | OPAMP_CSR_OPAMODE
S               | OPAMP_CSR_CALON
S               | OPAMP_CSR_VMSEL
S               | OPAMP_CSR_VPSEL
S              ,
S                 (OPAMP_InitStruct->PowerMode & OPAMP_POWERMODE_CSR_BIT_MASK)
S               | OPAMP_InitStruct->FunctionalMode
S               | OPAMP_InitStruct->InputNonInverting
S               | OPAMP_InitStruct->InputInverting
S              );
S  }
S  else
S  {
S    MODIFY_REG(OPAMPx->CSR,
S                 OPAMP_CSR_OPALPM
S               | OPAMP_CSR_OPAMODE
S               | OPAMP_CSR_CALON
S               | OPAMP_CSR_VMSEL
S               | OPAMP_CSR_VPSEL
S              ,
S                 (OPAMP_InitStruct->PowerMode & OPAMP_POWERMODE_CSR_BIT_MASK)
S               | LL_OPAMP_MODE_FOLLOWER
S               | OPAMP_InitStruct->InputNonInverting
S               | LL_OPAMP_INPUT_INVERT_CONNECT_NO
S              );
S  }
S
S  return SUCCESS;
S}
S
S/**
S  * @brief Set each @ref LL_OPAMP_InitTypeDef field to default value.
S  * @param OPAMP_InitStruct pointer to a @ref LL_OPAMP_InitTypeDef structure
S  *                         whose fields will be set to default values.
S  * @retval None
S  */
Svoid LL_OPAMP_StructInit(LL_OPAMP_InitTypeDef *OPAMP_InitStruct)
S{
S  /* Set OPAMP_InitStruct fields to default values */
S  OPAMP_InitStruct->PowerMode         = LL_OPAMP_POWERMODE_NORMAL;
S  OPAMP_InitStruct->FunctionalMode    = LL_OPAMP_MODE_FOLLOWER;
S  OPAMP_InitStruct->InputNonInverting = LL_OPAMP_INPUT_NONINVERT_IO0;
S  /* Note: Parameter discarded if OPAMP in functional mode follower,          */
S  /*       set anyway to its default value.                                   */
S  OPAMP_InitStruct->InputInverting    = LL_OPAMP_INPUT_INVERT_CONNECT_NO;
S}
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S#endif /* OPAMP1 || OPAMP2 */
S
S/**
S  * @}
S  */
S
N#endif /* USE_FULL_LL_DRIVER */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
