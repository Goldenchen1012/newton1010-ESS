; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\main.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\User\main.c]
                          THUMB

                          AREA ||i.Error_Handler||, CODE, READONLY, ALIGN=1

                  Error_Handler PROC
;;;1407     */
;;;1408   void Error_Handler(void)
000000  4770              BX       lr
;;;1409   {
;;;1410     /* Suspend tick */
;;;1411    // HAL_SuspendTick();
;;;1412     
;;;1413     /* Turn LED2 */
;;;1414     //BSP_LED_On(LED2);
;;;1415     //while (1)
;;;1416    // {
;;;1417     ///}
;;;1418   	return;
;;;1419   }
;;;1420   
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_Callback PROC
;;;1451     */
;;;1452   void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;1453   {
;;;1454     if (GPIO_Pin == USER_BUTTON_PIN)
000002  f5b05f00          CMP      r0,#0x2000
000006  d108              BNE      |L2.26|
;;;1455     {
;;;1456       /* Reconfigure LED1 */
;;;1457       BSP_LED_Init(LED1); 
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       BSP_LED_Init
;;;1458       /* Switch on LED1 */
;;;1459       BSP_LED_On(LED1);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       BSP_LED_On
;;;1460       
;;;1461       /**/
;;;1462       button_pressed = 1;
000014  4901              LDR      r1,|L2.28|
000016  2001              MOVS     r0,#1
000018  6148              STR      r0,[r1,#0x14]  ; button_pressed
                  |L2.26|
;;;1463       
;;;1464     }
;;;1465   }
00001a  bd10              POP      {r4,pc}
;;;1466   
                          ENDP

                  |L2.28|
                          DCD      ||area_number.28||

                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=2

                  HAL_SYSTICK_Callback PROC
;;;1429     */
;;;1430   void HAL_SYSTICK_Callback(void)
000000  b510              PUSH     {r4,lr}
;;;1431   {
;;;1432     HAL_IncTick();
000002  f7fffffe          BL       HAL_IncTick
;;;1433   
;;;1434     if (TimingDelay != 0)
000006  4c06              LDR      r4,|L3.32|
000008  6aa0              LDR      r0,[r4,#0x28]  ; TimingDelay
00000a  b118              CBZ      r0,|L3.20|
;;;1435     {
;;;1436       TimingDelay--;
00000c  6aa0              LDR      r0,[r4,#0x28]  ; TimingDelay
00000e  1e40              SUBS     r0,r0,#1
000010  62a0              STR      r0,[r4,#0x28]  ; TimingDelay
;;;1437     }
;;;1438     else
;;;1439     {
;;;1440       /* Toggle LED1 */
;;;1441       BSP_LED_Toggle(LED1);
;;;1442       TimingDelay = LED_TOGGLE_DELAY;
;;;1443     }
;;;1444   }
000012  bd10              POP      {r4,pc}
                  |L3.20|
000014  2000              MOVS     r0,#0                 ;1441
000016  f7fffffe          BL       BSP_LED_Toggle
00001a  2064              MOVS     r0,#0x64              ;1442
00001c  62a0              STR      r0,[r4,#0x28]         ;1442  ; TimingDelay
00001e  bd10              POP      {r4,pc}
;;;1445   
                          ENDP

                  |L3.32|
                          DCD      ||area_number.28||

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;1420   
;;;1421   void SysTick_Handler(void)
000000  f7ffbffe          B.W      HAL_IncTick
;;;1422   {
;;;1423   	HAL_IncTick();
;;;1424   }
;;;1425   /**
                          ENDP


                          AREA ||i.SystemClock_Config_24MHz||, CODE, READONLY, ALIGN=1

                  SystemClock_Config_24MHz PROC
;;;1273   
;;;1274   void SystemClock_Config_24MHz(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1275   {
000002  b097              SUB      sp,sp,#0x5c
;;;1276     RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  a812              ADD      r0,sp,#0x48
000008  f7fffffe          BL       __aeabi_memclr4
;;;1277     RCC_OscInitTypeDef RCC_OscInitStruct = {0};
00000c  2144              MOVS     r1,#0x44
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memclr4
;;;1278   
;;;1279     /* Select MSI as system clock source */
;;;1280     RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;
000014  2401              MOVS     r4,#1
000016  9412              STR      r4,[sp,#0x48]
;;;1281     RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; 
000018  2500              MOVS     r5,#0
00001a  9513              STR      r5,[sp,#0x4c]
;;;1282     if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
00001c  2103              MOVS     r1,#3
00001e  a812              ADD      r0,sp,#0x48
000020  f7fffffe          BL       HAL_RCC_ClockConfig
000024  b108              CBZ      r0,|L5.42|
;;;1283     {
;;;1284       /* Initialization Error */
;;;1285       Error_Handler();
000026  f7fffffe          BL       Error_Handler
                  |L5.42|
;;;1286     }
;;;1287   
;;;1288     /* Update MSI to 24Mhz (RCC_MSIRANGE_9) */
;;;1289     RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
00002a  2010              MOVS     r0,#0x10
00002c  9001              STR      r0,[sp,#4]
;;;1290     RCC_OscInitStruct.MSIState = RCC_MSI_ON;
00002e  9407              STR      r4,[sp,#0x1c]
;;;1291     RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_9;
000030  2090              MOVS     r0,#0x90
000032  9009              STR      r0,[sp,#0x24]
;;;1292     RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
000034  9508              STR      r5,[sp,#0x20]
;;;1293     RCC_OscInitStruct.PLL.PLLState = RCC_PLL_OFF;
000036  940b              STR      r4,[sp,#0x2c]
;;;1294     if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
000038  a801              ADD      r0,sp,#4
00003a  f7fffffe          BL       HAL_RCC_OscConfig
00003e  2800              CMP      r0,#0
000040  d001              BEQ      |L5.70|
;;;1295     {
;;;1296       /* Initialization Error */
;;;1297       Error_Handler();
000042  f7fffffe          BL       Error_Handler
                  |L5.70|
;;;1298     }
;;;1299   }
000046  b017              ADD      sp,sp,#0x5c
000048  bd30              POP      {r4,r5,pc}
;;;1300   
                          ENDP


                          AREA ||i.SystemClock_Config_80MHz||, CODE, READONLY, ALIGN=1

                  SystemClock_Config_80MHz PROC
;;;1319     */
;;;1320   void SystemClock_Config_80MHz(void)
000000  b510              PUSH     {r4,lr}
;;;1321   {
000002  b096              SUB      sp,sp,#0x58
;;;1322     RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  a811              ADD      r0,sp,#0x44
000008  f7fffffe          BL       __aeabi_memclr4
;;;1323     RCC_OscInitTypeDef RCC_OscInitStruct = {0};
00000c  2144              MOVS     r1,#0x44
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;1324   
;;;1325     /* MSI is enabled after System reset, activate PLL with MSI as source */
;;;1326     RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
000014  2010              MOVS     r0,#0x10
000016  9000              STR      r0,[sp,#0]
;;;1327     RCC_OscInitStruct.MSIState = RCC_MSI_ON;
000018  2001              MOVS     r0,#1
00001a  9006              STR      r0,[sp,#0x18]
;;;1328     RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
00001c  2160              MOVS     r1,#0x60
00001e  9108              STR      r1,[sp,#0x20]
;;;1329     RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
000020  2400              MOVS     r4,#0
000022  9407              STR      r4,[sp,#0x1c]
;;;1330     RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
000024  2102              MOVS     r1,#2
000026  910a              STR      r1,[sp,#0x28]
;;;1331     RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
000028  900b              STR      r0,[sp,#0x2c]
;;;1332     RCC_OscInitStruct.PLL.PLLM = 1;
00002a  900c              STR      r0,[sp,#0x30]
;;;1333     RCC_OscInitStruct.PLL.PLLN = 40;
00002c  2028              MOVS     r0,#0x28
00002e  900d              STR      r0,[sp,#0x34]
;;;1334     RCC_OscInitStruct.PLL.PLLR = 2;
000030  9110              STR      r1,[sp,#0x40]
;;;1335     RCC_OscInitStruct.PLL.PLLP = 7;
000032  2007              MOVS     r0,#7
000034  900e              STR      r0,[sp,#0x38]
;;;1336     RCC_OscInitStruct.PLL.PLLQ = 4;
000036  2004              MOVS     r0,#4
000038  900f              STR      r0,[sp,#0x3c]
;;;1337     if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       HAL_RCC_OscConfig
000040  b108              CBZ      r0,|L6.70|
;;;1338     {
;;;1339       /* Initialization Error */
;;;1340       Error_Handler();
000042  f7fffffe          BL       Error_Handler
                  |L6.70|
;;;1341     }
;;;1342     
;;;1343     /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
;;;1344        clocks dividers */
;;;1345     RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
000046  200f              MOVS     r0,#0xf
000048  9011              STR      r0,[sp,#0x44]
;;;1346     RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
00004a  2003              MOVS     r0,#3
00004c  9012              STR      r0,[sp,#0x48]
;;;1347     RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
00004e  9413              STR      r4,[sp,#0x4c]
;;;1348     RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;  
000050  9414              STR      r4,[sp,#0x50]
;;;1349     RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;  
000052  9415              STR      r4,[sp,#0x54]
;;;1350     if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
000054  2104              MOVS     r1,#4
000056  a811              ADD      r0,sp,#0x44
000058  f7fffffe          BL       HAL_RCC_ClockConfig
00005c  2800              CMP      r0,#0
00005e  d001              BEQ      |L6.100|
;;;1351     {
;;;1352       /* Initialization Error */
;;;1353       Error_Handler();
000060  f7fffffe          BL       Error_Handler
                  |L6.100|
;;;1354     }
;;;1355   }
000064  b016              ADD      sp,sp,#0x58
000066  bd10              POP      {r4,pc}
;;;1356   
                          ENDP


                          AREA ||i.SystemClock_Config_HSE_80MHz||, CODE, READONLY, ALIGN=1

                  SystemClock_Config_HSE_80MHz PROC
;;;1356   
;;;1357   void SystemClock_Config_HSE_80MHz(void)
000000  b510              PUSH     {r4,lr}
;;;1358   {
000002  b096              SUB      sp,sp,#0x58
;;;1359     RCC_OscInitTypeDef RCC_OscInitStruct = {0};
000004  2144              MOVS     r1,#0x44
000006  a805              ADD      r0,sp,#0x14
000008  f7fffffe          BL       __aeabi_memclr4
;;;1360     RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
00000c  2114              MOVS     r1,#0x14
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;1361   
;;;1362     /** Configure the main internal regulator output voltage
;;;1363     */
;;;1364     if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
000014  f44f7000          MOV      r0,#0x200
000018  f7fffffe          BL       HAL_PWREx_ControlVoltageScaling
00001c  b108              CBZ      r0,|L7.34|
;;;1365     {
;;;1366       Error_Handler();
00001e  f7fffffe          BL       Error_Handler
                  |L7.34|
;;;1367     }
;;;1368     /** Initializes the RCC Oscillators according to the specified parameters
;;;1369     * in the RCC_OscInitTypeDef structure.
;;;1370     */
;;;1371     RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
000022  2009              MOVS     r0,#9
000024  9005              STR      r0,[sp,#0x14]
;;;1372     RCC_OscInitStruct.HSEState = RCC_HSE_ON;
000026  f44f3080          MOV      r0,#0x10000
00002a  9006              STR      r0,[sp,#0x18]
;;;1373     RCC_OscInitStruct.LSIState = RCC_LSI_ON;
00002c  2101              MOVS     r1,#1
00002e  910a              STR      r1,[sp,#0x28]
;;;1374     RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
000030  2002              MOVS     r0,#2
000032  900f              STR      r0,[sp,#0x3c]
;;;1375     RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
000034  2403              MOVS     r4,#3
000036  9410              STR      r4,[sp,#0x40]
;;;1376     RCC_OscInitStruct.PLL.PLLM = 1;
000038  9111              STR      r1,[sp,#0x44]
;;;1377     RCC_OscInitStruct.PLL.PLLN = 40;
00003a  2128              MOVS     r1,#0x28
00003c  9112              STR      r1,[sp,#0x48]
;;;1378     RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
00003e  9013              STR      r0,[sp,#0x4c]
;;;1379     RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
000040  9014              STR      r0,[sp,#0x50]
;;;1380     RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV4;
000042  2004              MOVS     r0,#4
000044  9015              STR      r0,[sp,#0x54]
;;;1381     if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
000046  a805              ADD      r0,sp,#0x14
000048  f7fffffe          BL       HAL_RCC_OscConfig
00004c  b108              CBZ      r0,|L7.82|
;;;1382     {
;;;1383       Error_Handler();
00004e  f7fffffe          BL       Error_Handler
                  |L7.82|
;;;1384     }
;;;1385     /** Initializes the CPU, AHB and APB buses clocks
;;;1386     */
;;;1387     RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
000052  200f              MOVS     r0,#0xf
000054  9000              STR      r0,[sp,#0]
;;;1388                                 |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
;;;1389     RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
000056  9401              STR      r4,[sp,#4]
;;;1390     RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
000058  2000              MOVS     r0,#0
00005a  9002              STR      r0,[sp,#8]
;;;1391     RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
00005c  9003              STR      r0,[sp,#0xc]
;;;1392     RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
00005e  9004              STR      r0,[sp,#0x10]
;;;1393   
;;;1394     if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
000060  2104              MOVS     r1,#4
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       HAL_RCC_ClockConfig
000068  2800              CMP      r0,#0
00006a  d001              BEQ      |L7.112|
;;;1395     {
;;;1396       Error_Handler();
00006c  f7fffffe          BL       Error_Handler
                  |L7.112|
;;;1397     }
;;;1398   }
000070  b016              ADD      sp,sp,#0x58
000072  bd10              POP      {r4,pc}
;;;1399   
                          ENDP


                          AREA ||i.app_flash_log_event_handler||, CODE, READONLY, ALIGN=2

                  app_flash_log_event_handler PROC
;;;468    
;;;469    void app_flash_log_event_handler(smp_log_evt_type p_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;470    {
;;;471    	switch(p_evt){
;;;472    		case SMP_LOG_EVENT_SECTOR_HEADER_LOAD_DONE:
;;;473    				LOG_CYAN("load head\r\n");
;;;474    				LOG_CYAN("header %x\r\n",header_package.header[0]);
000002  4c83              LDR      r4,|L8.528|
000004  2807              CMP      r0,#7                 ;471
000006  d267              BCS      |L8.216|
000008  e8dff000          TBB      [pc,r0]               ;471
00000c  6704e4ca          DCB      0x67,0x04,0xe4,0xca
000010  ef66f800          DCB      0xef,0x66,0xf8,0x00
000014  a07f              ADR      r0,|L8.532|
000016  9000              STR      r0,[sp,#0]            ;473
000018  a37f              ADR      r3,|L8.536|
00001a  a280              ADR      r2,|L8.540|
00001c  a181              ADR      r1,|L8.548|
00001e  2000              MOVS     r0,#0                 ;473
000020  f7fffffe          BL       SEGGER_RTT_printf
000024  a17b              ADR      r1,|L8.532|
000026  7820              LDRB     r0,[r4,#0]  ; header_package
000028  e9cd0100          STRD     r0,r1,[sp,#0]
00002c  a37a              ADR      r3,|L8.536|
00002e  a27b              ADR      r2,|L8.540|
000030  a181              ADR      r1,|L8.568|
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       SEGGER_RTT_printf
;;;475    				LOG_CYAN("header %x\r\n",header_package.header[1]);
000038  a176              ADR      r1,|L8.532|
00003a  7860              LDRB     r0,[r4,#1]  ; header_package
00003c  e9cd0100          STRD     r0,r1,[sp,#0]
000040  a375              ADR      r3,|L8.536|
000042  a276              ADR      r2,|L8.540|
000044  a17c              ADR      r1,|L8.568|
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       SEGGER_RTT_printf
;;;476    				LOG_CYAN("header %x\r\n",header_package.header[2]);
00004c  a171              ADR      r1,|L8.532|
00004e  78a0              LDRB     r0,[r4,#2]  ; header_package
000050  e9cd0100          STRD     r0,r1,[sp,#0]
000054  a370              ADR      r3,|L8.536|
000056  a271              ADR      r2,|L8.540|
000058  a177              ADR      r1,|L8.568|
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       SEGGER_RTT_printf
;;;477    				LOG_CYAN("header %x\r\n",header_package.header[3]);
000060  a16c              ADR      r1,|L8.532|
000062  78e0              LDRB     r0,[r4,#3]  ; header_package
000064  e9cd0100          STRD     r0,r1,[sp,#0]
000068  a36b              ADR      r3,|L8.536|
00006a  a26c              ADR      r2,|L8.540|
00006c  a172              ADR      r1,|L8.568|
00006e  2000              MOVS     r0,#0
000070  f7fffffe          BL       SEGGER_RTT_printf
;;;478    				LOG_CYAN("reflash head page%x\r\n",header_package.reflash_memory_head_page);
000074  a167              ADR      r1,|L8.532|
000076  88a0              LDRH     r0,[r4,#4]  ; header_package
000078  e9cd0100          STRD     r0,r1,[sp,#0]
00007c  a366              ADR      r3,|L8.536|
00007e  a267              ADR      r2,|L8.540|
000080  a172              ADR      r1,|L8.588|
000082  2000              MOVS     r0,#0
000084  f7fffffe          BL       SEGGER_RTT_printf
;;;479    				LOG_CYAN("reflash current page%x\r\n",header_package.reflash_memory_current_page);
000088  a162              ADR      r1,|L8.532|
00008a  88e0              LDRH     r0,[r4,#6]  ; header_package
00008c  e9cd0100          STRD     r0,r1,[sp,#0]
000090  a361              ADR      r3,|L8.536|
000092  a262              ADR      r2,|L8.540|
000094  a174              ADR      r1,|L8.616|
000096  2000              MOVS     r0,#0
000098  f7fffffe          BL       SEGGER_RTT_printf
;;;480    				LOG_CYAN("reflash cnt%d\r\n",header_package.reflash_total_log_cnt);
00009c  a15d              ADR      r1,|L8.532|
00009e  8920              LDRH     r0,[r4,#8]  ; header_package
0000a0  e9cd0100          STRD     r0,r1,[sp,#0]
0000a4  a35c              ADR      r3,|L8.536|
0000a6  a25d              ADR      r2,|L8.540|
0000a8  a177              ADR      r1,|L8.648|
0000aa  2000              MOVS     r0,#0
0000ac  f7fffffe          BL       SEGGER_RTT_printf
;;;481    				LOG_CYAN("fix curent page%x\r\n",header_package.fix_memory_current_page);
0000b0  a158              ADR      r1,|L8.532|
0000b2  8960              LDRH     r0,[r4,#0xa]  ; header_package
0000b4  e9cd0100          STRD     r0,r1,[sp,#0]
0000b8  a357              ADR      r3,|L8.536|
0000ba  a258              ADR      r2,|L8.540|
0000bc  a178              ADR      r1,|L8.672|
0000be  2000              MOVS     r0,#0
0000c0  f7fffffe          BL       SEGGER_RTT_printf
;;;482    				LOG_CYAN("fix cnt%d\r\n",header_package.fix_total_log_cnt);
0000c4  a153              ADR      r1,|L8.532|
0000c6  89a0              LDRH     r0,[r4,#0xc]  ; header_package
0000c8  e9cd0100          STRD     r0,r1,[sp,#0]
0000cc  a352              ADR      r3,|L8.536|
0000ce  a253              ADR      r2,|L8.540|
0000d0  a17a              ADR      r1,|L8.700|
0000d2  2000              MOVS     r0,#0
0000d4  f7fffffe          BL       SEGGER_RTT_printf
                  |L8.216|
;;;483    		break;
;;;484    		case SMP_LOG_EVENT_SECTOR_HEADER_SAVE_DONE:
;;;485    				LOG_CYAN("save head\r\n");
;;;486    				LOG_CYAN("header %x\r\n",header_package.header[0]);
;;;487    				LOG_CYAN("header %x\r\n",header_package.header[1]);
;;;488    				LOG_CYAN("header %x\r\n",header_package.header[2]);
;;;489    				LOG_CYAN("header %x\r\n",header_package.header[3]);
;;;490    				LOG_CYAN("reflash head page%x\r\n",header_package.reflash_memory_head_page);
;;;491    				LOG_CYAN("reflash cnt%x\r\n",header_package.reflash_memory_current_page);
;;;492    				LOG_CYAN("reflash cnt%d\r\n",header_package.reflash_total_log_cnt);
;;;493    				LOG_CYAN("fix curent page%x\r\n",header_package.fix_memory_current_page);
;;;494    				LOG_CYAN("fix cnt%d\r\n",header_package.fix_total_log_cnt);
;;;495    		break;
;;;496    		case SMP_LOG_EVENT_PAGE_LOAD_DONE:
;;;497    				LOG_CYAN("page load\r\n");
;;;498    				for(int i = 0; i < 256;i++){				
;;;499    					LOG_CYAN("%d,%x\r\n",i,page_data_buffer[i]);
;;;500    				}
;;;501    		break;
;;;502    		case SMP_LOG_EVENT_PAGE_SAVE_DONE:
;;;503    				LOG_CYAN("page save\r\n");
;;;504    		break;
;;;505    		case SMP_LOG_EVENT_MEMORY_FULL:
;;;506    				LOG_CYAN("fix memory full\r\n");
;;;507    		break;
;;;508    		case SMP_LOG_EVENT_ERROR:
;;;509    				LOG_CYAN("Error\r\n");
;;;510    		break;
;;;511    		default:
;;;512    		break;
;;;513    	}
;;;514    }
0000d8  bd3e              POP      {r1-r5,pc}
0000da  a04e              ADR      r0,|L8.532|
0000dc  9000              STR      r0,[sp,#0]            ;485
0000de  a34e              ADR      r3,|L8.536|
0000e0  a24e              ADR      r2,|L8.540|
0000e2  a17b              ADR      r1,|L8.720|
0000e4  2000              MOVS     r0,#0                 ;485
0000e6  f7fffffe          BL       SEGGER_RTT_printf
0000ea  a14a              ADR      r1,|L8.532|
0000ec  7820              LDRB     r0,[r4,#0]            ;486  ; header_package
0000ee  e9cd0100          STRD     r0,r1,[sp,#0]         ;486
0000f2  a349              ADR      r3,|L8.536|
0000f4  a249              ADR      r2,|L8.540|
0000f6  a150              ADR      r1,|L8.568|
0000f8  2000              MOVS     r0,#0                 ;486
0000fa  f7fffffe          BL       SEGGER_RTT_printf
0000fe  a145              ADR      r1,|L8.532|
000100  7860              LDRB     r0,[r4,#1]            ;487  ; header_package
000102  e9cd0100          STRD     r0,r1,[sp,#0]         ;487
000106  a344              ADR      r3,|L8.536|
000108  a244              ADR      r2,|L8.540|
00010a  a14b              ADR      r1,|L8.568|
00010c  2000              MOVS     r0,#0                 ;487
00010e  f7fffffe          BL       SEGGER_RTT_printf
000112  a140              ADR      r1,|L8.532|
000114  78a0              LDRB     r0,[r4,#2]            ;488  ; header_package
000116  e9cd0100          STRD     r0,r1,[sp,#0]         ;488
00011a  a33f              ADR      r3,|L8.536|
00011c  a23f              ADR      r2,|L8.540|
00011e  a146              ADR      r1,|L8.568|
000120  2000              MOVS     r0,#0                 ;488
000122  f7fffffe          BL       SEGGER_RTT_printf
000126  a13b              ADR      r1,|L8.532|
000128  78e0              LDRB     r0,[r4,#3]            ;489  ; header_package
00012a  e9cd0100          STRD     r0,r1,[sp,#0]         ;489
00012e  a33a              ADR      r3,|L8.536|
000130  a23a              ADR      r2,|L8.540|
000132  a141              ADR      r1,|L8.568|
000134  2000              MOVS     r0,#0                 ;489
000136  f7fffffe          BL       SEGGER_RTT_printf
00013a  a136              ADR      r1,|L8.532|
00013c  88a0              LDRH     r0,[r4,#4]            ;490  ; header_package
00013e  e9cd0100          STRD     r0,r1,[sp,#0]         ;490
000142  a335              ADR      r3,|L8.536|
000144  a235              ADR      r2,|L8.540|
000146  a141              ADR      r1,|L8.588|
000148  2000              MOVS     r0,#0                 ;490
00014a  f7fffffe          BL       SEGGER_RTT_printf
00014e  a131              ADR      r1,|L8.532|
000150  88e0              LDRH     r0,[r4,#6]            ;491  ; header_package
000152  e9cd0100          STRD     r0,r1,[sp,#0]         ;491
000156  a330              ADR      r3,|L8.536|
000158  a230              ADR      r2,|L8.540|
00015a  a162              ADR      r1,|L8.740|
00015c  2000              MOVS     r0,#0                 ;491
00015e  f7fffffe          BL       SEGGER_RTT_printf
000162  a12c              ADR      r1,|L8.532|
000164  8920              LDRH     r0,[r4,#8]            ;492  ; header_package
000166  e9cd0100          STRD     r0,r1,[sp,#0]         ;492
00016a  a32b              ADR      r3,|L8.536|
00016c  a22b              ADR      r2,|L8.540|
00016e  a146              ADR      r1,|L8.648|
000170  2000              MOVS     r0,#0                 ;492
000172  f7fffffe          BL       SEGGER_RTT_printf
000176  a127              ADR      r1,|L8.532|
000178  8960              LDRH     r0,[r4,#0xa]          ;493  ; header_package
00017a  e9cd0100          STRD     r0,r1,[sp,#0]         ;493
00017e  a326              ADR      r3,|L8.536|
000180  a226              ADR      r2,|L8.540|
000182  a147              ADR      r1,|L8.672|
000184  2000              MOVS     r0,#0                 ;493
000186  f7fffffe          BL       SEGGER_RTT_printf
00018a  a122              ADR      r1,|L8.532|
00018c  89a0              LDRH     r0,[r4,#0xc]          ;494  ; header_package
00018e  e9cd0100          STRD     r0,r1,[sp,#0]         ;494
000192  a321              ADR      r3,|L8.536|
000194  a221              ADR      r2,|L8.540|
000196  a149              ADR      r1,|L8.700|
000198  2000              MOVS     r0,#0                 ;494
00019a  f7fffffe          BL       SEGGER_RTT_printf
00019e  bd3e              POP      {r1-r5,pc}
0001a0  a01c              ADR      r0,|L8.532|
0001a2  9000              STR      r0,[sp,#0]            ;497
0001a4  a31c              ADR      r3,|L8.536|
0001a6  a21d              ADR      r2,|L8.540|
0001a8  a154              ADR      r1,|L8.764|
0001aa  2000              MOVS     r0,#0                 ;497
0001ac  f7fffffe          BL       SEGGER_RTT_printf
0001b0  2400              MOVS     r4,#0                 ;498
0001b2  4d17              LDR      r5,|L8.528|
0001b4  3510              ADDS     r5,r5,#0x10           ;499
                  |L8.438|
0001b6  a117              ADR      r1,|L8.532|
0001b8  5d28              LDRB     r0,[r5,r4]            ;499
0001ba  9102              STR      r1,[sp,#8]            ;499
0001bc  e9cd4000          STRD     r4,r0,[sp,#0]         ;499
0001c0  a315              ADR      r3,|L8.536|
0001c2  a216              ADR      r2,|L8.540|
0001c4  a152              ADR      r1,|L8.784|
0001c6  2000              MOVS     r0,#0                 ;499
0001c8  f7fffffe          BL       SEGGER_RTT_printf
0001cc  1c64              ADDS     r4,r4,#1              ;498
0001ce  2cff              CMP      r4,#0xff              ;498
0001d0  ddf1              BLE      |L8.438|
0001d2  bd3e              POP      {r1-r5,pc}
0001d4  a00f              ADR      r0,|L8.532|
0001d6  9000              STR      r0,[sp,#0]            ;503
0001d8  a30f              ADR      r3,|L8.536|
0001da  a210              ADR      r2,|L8.540|
0001dc  a150              ADR      r1,|L8.800|
0001de  2000              MOVS     r0,#0                 ;503
0001e0  f7fffffe          BL       SEGGER_RTT_printf
                  |L8.484|
0001e4  bd3e              POP      {r1-r5,pc}
0001e6  e009              B        |L8.508|
0001e8  e7ff              B        |L8.490|
                  |L8.490|
0001ea  a00a              ADR      r0,|L8.532|
0001ec  9000              STR      r0,[sp,#0]            ;506
0001ee  a30a              ADR      r3,|L8.536|
0001f0  a20a              ADR      r2,|L8.540|
0001f2  a150              ADR      r1,|L8.820|
0001f4  2000              MOVS     r0,#0                 ;506
0001f6  f7fffffe          BL       SEGGER_RTT_printf
0001fa  e7f3              B        |L8.484|
                  |L8.508|
0001fc  a005              ADR      r0,|L8.532|
0001fe  9000              STR      r0,[sp,#0]            ;509
000200  a305              ADR      r3,|L8.536|
000202  a206              ADR      r2,|L8.540|
000204  a151              ADR      r1,|L8.844|
000206  2000              MOVS     r0,#0                 ;509
000208  f7fffffe          BL       SEGGER_RTT_printf
00020c  e7ea              B        |L8.484|
;;;515    #endif
                          ENDP

00020e  0000              DCW      0x0000
                  |L8.528|
                          DCD      ||area_number.23||+0xd4
                  |L8.532|
000214  1b5b306d          DCB      27,"[0m"
                  |L8.536|
000218  00                DCB      0
000219  00                DCB      0
00021a  00                DCB      0
00021b  00                DCB      0
                  |L8.540|
00021c  1b5b313b          DCB      27,"[1;36m",0
000220  33366d00
                  |L8.548|
000224  25732573          DCB      "%s%sload head\r\n%s",0
000228  6c6f6164
00022c  20686561
000230  640d0a25
000234  7300    
000236  00                DCB      0
000237  00                DCB      0
                  |L8.568|
000238  25732573          DCB      "%s%sheader %x\r\n%s",0
00023c  68656164
000240  65722025
000244  780d0a25
000248  7300    
00024a  00                DCB      0
00024b  00                DCB      0
                  |L8.588|
00024c  25732573          DCB      "%s%sreflash head page%x\r\n%s",0
000250  7265666c
000254  61736820
000258  68656164
00025c  20706167
000260  6525780d
000264  0a257300
                  |L8.616|
000268  25732573          DCB      "%s%sreflash current page%x\r\n%s",0
00026c  7265666c
000270  61736820
000274  63757272
000278  656e7420
00027c  70616765
000280  25780d0a
000284  257300  
000287  00                DCB      0
                  |L8.648|
000288  25732573          DCB      "%s%sreflash cnt%d\r\n%s",0
00028c  7265666c
000290  61736820
000294  636e7425
000298  640d0a25
00029c  7300    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L8.672|
0002a0  25732573          DCB      "%s%sfix curent page%x\r\n%s",0
0002a4  66697820
0002a8  63757265
0002ac  6e742070
0002b0  61676525
0002b4  780d0a25
0002b8  7300    
0002ba  00                DCB      0
0002bb  00                DCB      0
                  |L8.700|
0002bc  25732573          DCB      "%s%sfix cnt%d\r\n%s",0
0002c0  66697820
0002c4  636e7425
0002c8  640d0a25
0002cc  7300    
0002ce  00                DCB      0
0002cf  00                DCB      0
                  |L8.720|
0002d0  25732573          DCB      "%s%ssave head\r\n%s",0
0002d4  73617665
0002d8  20686561
0002dc  640d0a25
0002e0  7300    
0002e2  00                DCB      0
0002e3  00                DCB      0
                  |L8.740|
0002e4  25732573          DCB      "%s%sreflash cnt%x\r\n%s",0
0002e8  7265666c
0002ec  61736820
0002f0  636e7425
0002f4  780d0a25
0002f8  7300    
0002fa  00                DCB      0
0002fb  00                DCB      0
                  |L8.764|
0002fc  25732573          DCB      "%s%spage load\r\n%s",0
000300  70616765
000304  206c6f61
000308  640d0a25
00030c  7300    
00030e  00                DCB      0
00030f  00                DCB      0
                  |L8.784|
000310  25732573          DCB      "%s%s%d,%x\r\n%s",0
000314  25642c25
000318  780d0a25
00031c  7300    
00031e  00                DCB      0
00031f  00                DCB      0
                  |L8.800|
000320  25732573          DCB      "%s%spage save\r\n%s",0
000324  70616765
000328  20736176
00032c  650d0a25
000330  7300    
000332  00                DCB      0
000333  00                DCB      0
                  |L8.820|
000334  25732573          DCB      "%s%sfix memory full\r\n%s",0
000338  66697820
00033c  6d656d6f
000340  72792066
000344  756c6c0d
000348  0a257300
                  |L8.844|
00034c  25732573          DCB      "%s%sError\r\n%s",0
000350  4572726f
000354  720d0a25
000358  7300    
00035a  00                DCB      0
00035b  00                DCB      0

                          AREA ||i.app_imr_ads7946_callBack||, CODE, READONLY, ALIGN=2

                  app_imr_ads7946_callBack PROC
;;;244    IRM_Recv_CB_t irm_fun_ptr = 0;
;;;245    static void app_imr_ads7946_callBack(uint8_t *pDat, uint8_t size)
000000  b082              SUB      sp,sp,#8
;;;246    {
;;;247    	tIbyte	AdcValue;
;;;248    	static float volt_data;
;;;249    	static float adc_bits;
;;;250      adc_bits = (float)(1<<ADS7946_RESOLUTION_B); 	
000002  4a13              LDR      r2,|L9.80|
000004  ed9f0a11          VLDR     s0,|L9.76|
000008  ed820a09          VSTR     s0,[r2,#0x24]
;;;251    	
;;;252    	AdcValue.b[1] = pDat[2];
00000c  7881              LDRB     r1,[r0,#2]
00000e  f88d1005          STRB     r1,[sp,#5]
;;;253    	AdcValue.b[0] = pDat[3];
000012  78c0              LDRB     r0,[r0,#3]
000014  f88d0004          STRB     r0,[sp,#4]
;;;254    	AdcValue.i >>= 3;
000018  f8bd0004          LDRH     r0,[sp,#4]
00001c  08c0              LSRS     r0,r0,#3
00001e  9001              STR      r0,[sp,#4]
;;;255    	
;;;256    	if(irm_fun_ptr !=NULL){
000020  6991              LDR      r1,[r2,#0x18]  ; irm_fun_ptr
000022  2900              CMP      r1,#0
000024  d00f              BEQ      |L9.70|
;;;257    	    volt_data = (float)(AdcValue.i)/adc_bits * ADS7946_VREF;
000026  ee000a90          VMOV     s1,r0
00002a  eef80a60          VCVT.F32.U32 s1,s1
00002e  ee801a80          VDIV.F32 s2,s1,s0
000032  eeb10a04          VMOV.F32 s0,#5.00000000
000036  ee210a00          VMUL.F32 s0,s2,s0
00003a  ed820a08          VSTR     s0,[r2,#0x20]
;;;258    		  irm_fun_ptr(&volt_data);
00003e  f1020020          ADD      r0,r2,#0x20
000042  b002              ADD      sp,sp,#8
000044  4708              BX       r1
                  |L9.70|
;;;259    	}
;;;260    	
;;;261    }
000046  b002              ADD      sp,sp,#8
000048  4770              BX       lr
;;;262    
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
00004c  46800000          DCFS     0x46800000 ; 16384
                  |L9.80|
                          DCD      ||area_number.28||

                          AREA ||i.app_irm_get_device_init_cb||, CODE, READONLY, ALIGN=1

                  app_irm_get_device_init_cb PROC
;;;279    
;;;280    void app_irm_get_device_init_cb(void){
000000  f7ffbffe          B.W      smp_ADS7946_init
;;;281        smp_ADS7946_init();
;;;282    }
;;;283    //--------------------------------------------------
                          ENDP


                          AREA ||i.app_irm_rxdata_cb||, CODE, READONLY, ALIGN=2

                  app_irm_rxdata_cb PROC
;;;165    //--------------------------------------------------
;;;166    uint8_t app_irm_rxdata_cb(IRMonitoring_Resistor_t *irm_res_data, IRMonitoring_event_cb_type irm_event){
000000  b51c              PUSH     {r2-r4,lr}
;;;167    
;;;168      static IRMonitoring_Resistor_t temp_irm_data;
;;;169      static float temp_irm_vstack;
;;;170    	
;;;171     	switch(irm_event)
;;;172     	{
;;;173     	case IRM_EVENT_BALANCE:
;;;174        temp_irm_data = *irm_res_data;
000002  4b13              LDR      r3,|L11.80|
000004  2900              CMP      r1,#0                 ;171
000006  d004              BEQ      |L11.18|
000008  2901              CMP      r1,#1                 ;171
00000a  d006              BEQ      |L11.26|
00000c  2902              CMP      r1,#2                 ;171
00000e  d10c              BNE      |L11.42|
000010  e007              B        |L11.34|
                  |L11.18|
000012  c805              LDM      r0,{r0,r2}
000014  e9c3020f          STRD     r0,r2,[r3,#0x3c]
;;;175    		break;
000018  e007              B        |L11.42|
                  |L11.26|
;;;176     	case IRM_EVENT_UNBALANCE:
;;;177        temp_irm_data = *irm_res_data;
00001a  c805              LDM      r0,{r0,r2}
00001c  e9c3020f          STRD     r0,r2,[r3,#0x3c]
;;;178    		break;
000020  e003              B        |L11.42|
                  |L11.34|
;;;179     	case IRM_EVENT_GET_VSTACK:
;;;180        temp_irm_vstack = irm_res_data->V_stack;
000022  ed900a01          VLDR     s0,[r0,#4]
000026  ed830a07          VSTR     s0,[r3,#0x1c]
                  |L11.42|
;;;181    		break;	
;;;182     	case IRM_EVENT_OTHER_ERR:
;;;183    
;;;184    		break;
;;;185      }
;;;186    	
;;;187    	#if 1
;;;188    	SEGGER_RTT_printf(0,"IRM EVENT=%d, Vstack=%d, Rn=%d, Rp=%d\r\n", irm_event, (int)(temp_irm_data.V_stack), temp_irm_data.Rn_kohm, temp_irm_data.Rp_kohm);
00002a  4809              LDR      r0,|L11.80|
00002c  303c              ADDS     r0,r0,#0x3c
00002e  8802              LDRH     r2,[r0,#0]  ; temp_irm_data
000030  8843              LDRH     r3,[r0,#2]  ; temp_irm_data
000032  e9cd3200          STRD     r3,r2,[sp,#0]
000036  ed900a01          VLDR     s0,[r0,#4]
00003a  460a              MOV      r2,r1
00003c  a105              ADR      r1,|L11.84|
00003e  eebd0ac0          VCVT.S32.F32 s0,s0
000042  2000              MOVS     r0,#0
000044  ee103a10          VMOV     r3,s0
000048  f7fffffe          BL       SEGGER_RTT_printf
;;;189    	#endif
;;;190    	
;;;191    	return 0;
00004c  2000              MOVS     r0,#0
;;;192    }
00004e  bd1c              POP      {r2-r4,pc}
;;;193    //--------------------------------------------------
                          ENDP

                  |L11.80|
                          DCD      ||area_number.28||
                  |L11.84|
000054  49524d20          DCB      "IRM EVENT=%d, Vstack=%d, Rn=%d, Rp=%d\r\n",0
000058  4556454e
00005c  543d2564
000060  2c205673
000064  7461636b
000068  3d25642c
00006c  20526e3d
000070  25642c20
000074  52703d25
000078  640d0a00

                          AREA ||i.app_irm_sw1_gpio||, CODE, READONLY, ALIGN=2

                  app_irm_sw1_gpio PROC
;;;219    
;;;220    void app_irm_sw1_gpio(IRMonitoring_SW_enum on_off){
000000  4906              LDR      r1,|L12.28|
;;;221        if(on_off == IRM_SW_ON){
000002  2801              CMP      r0,#1
000004  d004              BEQ      |L12.16|
;;;222    	      BSP_IRM_SW1_ON();
;;;223    	  }else{
;;;224    		    BSP_IRM_SW1_OFF();
000006  6808              LDR      r0,[r1,#0]
000008  f4204080          BIC      r0,r0,#0x4000
00000c  6008              STR      r0,[r1,#0]
;;;225    		}
;;;226    }
00000e  4770              BX       lr
                  |L12.16|
000010  6808              LDR      r0,[r1,#0]            ;222
000012  f4404080          ORR      r0,r0,#0x4000         ;222
000016  6008              STR      r0,[r1,#0]            ;222
000018  4770              BX       lr
;;;227    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x48000c14

                          AREA ||i.app_irm_sw2_gpio||, CODE, READONLY, ALIGN=2

                  app_irm_sw2_gpio PROC
;;;227    
;;;228    void app_irm_sw2_gpio(IRMonitoring_SW_enum on_off){
000000  4906              LDR      r1,|L13.28|
;;;229        if(on_off == IRM_SW_ON){
000002  2801              CMP      r0,#1
000004  d004              BEQ      |L13.16|
;;;230    	      BSP_IRM_SW2_ON();
;;;231    	  }else{
;;;232    		    BSP_IRM_SW2_OFF();
000006  6808              LDR      r0,[r1,#0]
000008  f4204000          BIC      r0,r0,#0x8000
00000c  6008              STR      r0,[r1,#0]
;;;233    		}
;;;234    }
00000e  4770              BX       lr
                  |L13.16|
000010  6808              LDR      r0,[r1,#0]            ;230
000012  f4404000          ORR      r0,r0,#0x8000         ;230
000016  6008              STR      r0,[r1,#0]            ;230
000018  4770              BX       lr
;;;235    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x48000c14

                          AREA ||i.app_irm_sw3_gpio||, CODE, READONLY, ALIGN=2

                  app_irm_sw3_gpio PROC
;;;235    
;;;236    void app_irm_sw3_gpio(IRMonitoring_SW_enum on_off){
000000  4906              LDR      r1,|L14.28|
;;;237        if(on_off == IRM_SW_ON){
000002  2801              CMP      r0,#1
000004  d004              BEQ      |L14.16|
;;;238    	      BSP_IRM_SW3_ON();
;;;239    	  }else{
;;;240    		    BSP_IRM_SW3_OFF();
000006  6808              LDR      r0,[r1,#0]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6008              STR      r0,[r1,#0]
;;;241    		}
;;;242    }
00000e  4770              BX       lr
                  |L14.16|
000010  6808              LDR      r0,[r1,#0]            ;238
000012  f0400040          ORR      r0,r0,#0x40           ;238
000016  6008              STR      r0,[r1,#0]            ;238
000018  4770              BX       lr
;;;243    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x48000814

                          AREA ||i.app_irm_sw_gpio_init_cb||, CODE, READONLY, ALIGN=2

                  app_irm_sw_gpio_init_cb PROC
;;;194    
;;;195    void app_irm_sw_gpio_init_cb(void){
000000  b570              PUSH     {r4-r6,lr}
000002  b086              SUB      sp,sp,#0x18
;;;196        GPIO_InitTypeDef GPIO_InitStructure;
;;;197    	
;;;198    	  // Control SW1~SW3 GPIO setting
;;;199    	  //-------------------------------------------------
;;;200    	  GPIO_InitStructure.Pin   = BSP_IRM_SW1_PIN;
000004  f44f4080          MOV      r0,#0x4000
000008  9001              STR      r0,[sp,#4]
;;;201    	  GPIO_InitStructure.Mode  = GPIO_MODE_OUTPUT_PP;
00000a  2401              MOVS     r4,#1
00000c  9402              STR      r4,[sp,#8]
;;;202    	  GPIO_InitStructure.Pull  = GPIO_PULLUP;
00000e  9403              STR      r4,[sp,#0xc]
;;;203    	  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
000010  2502              MOVS     r5,#2
000012  9504              STR      r5,[sp,#0x10]
;;;204    	  HAL_GPIO_Init(BSP_IRM_SW1_PORT, &GPIO_InitStructure); 	
000014  4e0c              LDR      r6,|L15.72|
000016  a901              ADD      r1,sp,#4
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       HAL_GPIO_Init
;;;205    
;;;206     	  GPIO_InitStructure.Pin   = BSP_IRM_SW2_PIN;
00001e  03e1              LSLS     r1,r4,#15
000020  9101              STR      r1,[sp,#4]
;;;207    	  GPIO_InitStructure.Mode  = GPIO_MODE_OUTPUT_PP;
000022  9402              STR      r4,[sp,#8]
;;;208    	  GPIO_InitStructure.Pull  = GPIO_PULLUP;
000024  9403              STR      r4,[sp,#0xc]
;;;209    	  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
000026  9504              STR      r5,[sp,#0x10]
;;;210    	  HAL_GPIO_Init(BSP_IRM_SW2_PORT, &GPIO_InitStructure); 	
000028  a901              ADD      r1,sp,#4
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       HAL_GPIO_Init
;;;211    	
;;;212     	  GPIO_InitStructure.Pin   = BSP_IRM_SW3_PIN;
000030  2040              MOVS     r0,#0x40
000032  9001              STR      r0,[sp,#4]
;;;213    	  GPIO_InitStructure.Mode  = GPIO_MODE_OUTPUT_PP;
000034  9402              STR      r4,[sp,#8]
;;;214    	  GPIO_InitStructure.Pull  = GPIO_PULLUP;
000036  9403              STR      r4,[sp,#0xc]
;;;215    	  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
000038  9504              STR      r5,[sp,#0x10]
;;;216    	  HAL_GPIO_Init(BSP_IRM_SW3_PORT, &GPIO_InitStructure); 	
00003a  a901              ADD      r1,sp,#4
00003c  4803              LDR      r0,|L15.76|
00003e  f7fffffe          BL       HAL_GPIO_Init
;;;217    	  //-------------------------------------------------
;;;218    }
000042  b006              ADD      sp,sp,#0x18
000044  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP

000046  0000              DCW      0x0000
                  |L15.72|
                          DCD      0x48000c00
                  |L15.76|
                          DCD      0x48000800

                          AREA ||i.app_irm_trigger_voltage_data_cb||, CODE, READONLY, ALIGN=2

                  app_irm_trigger_voltage_data_cb PROC
;;;266    
;;;267    IRMonitoring_event_read_cb_type app_irm_trigger_voltage_data_cb(void){
000000  b510              PUSH     {r4,lr}
;;;268    	  static int8_t res;
;;;269    		
;;;270        res = smp_ADS7946_get_data(channel_0,CS_0,app_imr_ads7946_callBack);
000002  2100              MOVS     r1,#0
000004  4a05              LDR      r2,|L16.28|
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       smp_ADS7946_get_data
00000c  4904              LDR      r1,|L16.32|
00000e  71c8              STRB     r0,[r1,#7]
;;;271    	  
;;;272    	  if(res == SMP_SUCCESS){
000010  b108              CBZ      r0,|L16.22|
;;;273    		    return(IRM_OK);	
;;;274    		}else{
;;;275    		    return(IRM_BUSY);
000012  2000              MOVS     r0,#0
;;;276    		}
;;;277    	
;;;278    }
000014  bd10              POP      {r4,pc}
                  |L16.22|
000016  2001              MOVS     r0,#1                 ;273
000018  bd10              POP      {r4,pc}
;;;279    
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      app_imr_ads7946_callBack
                  |L16.32|
                          DCD      ||area_number.28||

                          AREA ||i.irm_data_ready_cb||, CODE, READONLY, ALIGN=2

                  irm_data_ready_cb PROC
;;;262    
;;;263    void irm_data_ready_cb(IRM_Recv_CB_t rcv_ptr){
000000  4901              LDR      r1,|L17.8|
;;;264    	irm_fun_ptr = rcv_ptr;
000002  6188              STR      r0,[r1,#0x18]  ; irm_fun_ptr
;;;265    }
000004  4770              BX       lr
;;;266    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      ||area_number.28||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;521      */
;;;522    int main(void)
000000  b08e              SUB      sp,sp,#0x38
;;;523    {
;;;524    #ifdef NO_DELAY_TOWARDS_SMPS
;;;525      static uint32_t counter = 0; 
;;;526    #endif
;;;527      
;;;528    	uint32_t		del;
;;;529      GPIO_InitTypeDef GPIO_InitStructure;
;;;530    
;;;531    	uint32_t SMPS_status = 0;
;;;532    	uint32_t resumed_from_standby = 0;
;;;533    	
;;;534    	/* STM32L4xx HAL library initialization:
;;;535           - Configure the Flash prefetch
;;;536           - Systick timer is configured by default as source of time base, but user 
;;;537             can eventually implement his proper time base source (a general purpose 
;;;538             timer for example or other time source), keeping in mind that Time base 
;;;539             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
;;;540             handled in milliseconds basis.
;;;541           - Set NVIC Group Priority to 4
;;;542           - Low Level Initialization
;;;543      */
;;;544    		
;;;545    	NVIC->ICER[0]=0xFFFFFFFF;
000002  48f8              LDR      r0,|L18.996|
000004  f04f31ff          MOV      r1,#0xffffffff
000008  6001              STR      r1,[r0,#0]
;;;546    	NVIC->ICER[1]=0xFFFFFFFF;
00000a  6041              STR      r1,[r0,#4]
;;;547    	NVIC->ICER[2]=0xFFFFFFFF;
00000c  6081              STR      r1,[r0,#8]
;;;548    	
;;;549      HalBspInit();
00000e  f7fffffe          BL       HalBspInit
;;;550    	#if 0
;;;551      HAL_Init();
;;;552      #endif
;;;553    
;;;554      /* Configure the system clock to 80 MHz(HSI / HSE) */
;;;555    	#if 0
;;;556      //SystemClock_Config_80MHz();
;;;557    	#endif
;;;558      SystemClock_Config_HSE_80MHz();
000012  f7fffffe          BL       SystemClock_Config_HSE_80MHz
;;;559    	
;;;560    	smp_DMA_Init();
000016  f7fffffe          BL       smp_DMA_Init
;;;561    	__HAL_RCC_GPIOA_CLK_ENABLE();
00001a  48f3              LDR      r0,|L18.1000|
00001c  6cc1              LDR      r1,[r0,#0x4c]
00001e  f0410101          ORR      r1,r1,#1
000022  64c1              STR      r1,[r0,#0x4c]
000024  6cc1              LDR      r1,[r0,#0x4c]
000026  f0010101          AND      r1,r1,#1
00002a  9107              STR      r1,[sp,#0x1c]
;;;562    	__HAL_RCC_GPIOB_CLK_ENABLE();
00002c  6cc1              LDR      r1,[r0,#0x4c]
00002e  f0410102          ORR      r1,r1,#2
000032  64c1              STR      r1,[r0,#0x4c]
000034  6cc1              LDR      r1,[r0,#0x4c]
000036  f0010102          AND      r1,r1,#2
00003a  9107              STR      r1,[sp,#0x1c]
;;;563    	__HAL_RCC_GPIOC_CLK_ENABLE();
00003c  6cc1              LDR      r1,[r0,#0x4c]
00003e  f0410104          ORR      r1,r1,#4
000042  64c1              STR      r1,[r0,#0x4c]
000044  6cc1              LDR      r1,[r0,#0x4c]
000046  f0010104          AND      r1,r1,#4
00004a  9107              STR      r1,[sp,#0x1c]
;;;564    	__HAL_RCC_GPIOD_CLK_ENABLE();
00004c  6cc1              LDR      r1,[r0,#0x4c]
00004e  f0410108          ORR      r1,r1,#8
000052  64c1              STR      r1,[r0,#0x4c]
000054  6cc1              LDR      r1,[r0,#0x4c]
000056  f0010108          AND      r1,r1,#8
00005a  9107              STR      r1,[sp,#0x1c]
;;;565    	__HAL_RCC_GPIOE_CLK_ENABLE();	
00005c  6cc1              LDR      r1,[r0,#0x4c]
00005e  f0410110          ORR      r1,r1,#0x10
000062  64c1              STR      r1,[r0,#0x4c]
000064  6cc1              LDR      r1,[r0,#0x4c]
000066  f0010110          AND      r1,r1,#0x10
00006a  9107              STR      r1,[sp,#0x1c]
;;;566    	__HAL_RCC_RTCAPB_CLK_ENABLE();
00006c  6d81              LDR      r1,[r0,#0x58]
00006e  f4416180          ORR      r1,r1,#0x400
000072  6581              STR      r1,[r0,#0x58]
000074  6d80              LDR      r0,[r0,#0x58]
000076  f4006080          AND      r0,r0,#0x400
00007a  9007              STR      r0,[sp,#0x1c]
;;;567    
;;;568      #if 0
;;;569      HAL_RCC_MCOConfig( RCC_MCO1 ,RCC_MCO1SOURCE_SYSCLK, RCC_MCODIV_16);          //Output SYSCLK to GPIOA PIN8
;;;570      #endif
;;;571    	
;;;572    	GPIO_InitStructure.Pin = 0x1F;                                               //GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3;
;;;573    	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
00007c  f04f0801          MOV      r8,#1
000080  f8cd8028          STR      r8,[sp,#0x28]
;;;574    	GPIO_InitStructure.Pull = GPIO_PULLUP;
000084  f8cd802c          STR      r8,[sp,#0x2c]
;;;575    	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
000088  2402              MOVS     r4,#2
00008a  940c              STR      r4,[sp,#0x30]
;;;576    	#if 0
;;;577      HAL_GPIO_Init(GPIOA, &GPIO_InitStructure); 
;;;578    	#endif
;;;579    	
;;;580    	GPIO_InitStructure.Pin = GPIO_PIN_13 | GPIO_PIN_14 |GPIO_PIN_15;
00008c  f44f4060          MOV      r0,#0xe000
000090  9009              STR      r0,[sp,#0x24]
;;;581    	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;582    	GPIO_InitStructure.Pull = GPIO_PULLUP;
;;;583    	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;584    	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure); 
000092  a909              ADD      r1,sp,#0x24
000094  48d5              LDR      r0,|L18.1004|
000096  f7fffffe          BL       HAL_GPIO_Init
;;;585    
;;;586    	GPIO_InitStructure.Pin = GPIO_PIN_10 | GPIO_PIN_11;
;;;587    	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
00009a  f8cd8028          STR      r8,[sp,#0x28]
;;;588    	GPIO_InitStructure.Pull = GPIO_PULLUP;
00009e  f8cd802c          STR      r8,[sp,#0x2c]
;;;589    	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
0000a2  940c              STR      r4,[sp,#0x30]
;;;590    	#if 0
;;;591      HAL_GPIO_Init(GPIOB, &GPIO_InitStructure); 
;;;592      #endif
;;;593    	
;;;594    	GPIO_InitStructure.Pin = GPIO_PIN_6;
0000a4  2040              MOVS     r0,#0x40
0000a6  9009              STR      r0,[sp,#0x24]
;;;595    	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;596    	GPIO_InitStructure.Pull = GPIO_PULLUP;
;;;597    	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;598    	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure); 
0000a8  a909              ADD      r1,sp,#0x24
0000aa  48d1              LDR      r0,|L18.1008|
0000ac  f7fffffe          BL       HAL_GPIO_Init
;;;599    	
;;;600    	GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
;;;601    	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
0000b0  f8cd8028          STR      r8,[sp,#0x28]
;;;602    	GPIO_InitStructure.Pull = GPIO_PULLUP;
0000b4  f8cd802c          STR      r8,[sp,#0x2c]
;;;603    	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
0000b8  940c              STR      r4,[sp,#0x30]
;;;604      #if 0
;;;605      HAL_GPIO_Init(GPIOB, &GPIO_InitStructure); 
;;;606      #endif
;;;607    	
;;;608    	GPIO_InitStructure.Pin = GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;
0000ba  f44f5060          MOV      r0,#0x3800
0000be  9009              STR      r0,[sp,#0x24]
;;;609    	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;610    	GPIO_InitStructure.Pull = GPIO_PULLUP;
;;;611    	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;612    	HAL_GPIO_Init(GPIOE, &GPIO_InitStructure); 
0000c0  a909              ADD      r1,sp,#0x24
0000c2  48cc              LDR      r0,|L18.1012|
0000c4  f7fffffe          BL       HAL_GPIO_Init
;;;613      HAL_Delay(200);
0000c8  20c8              MOVS     r0,#0xc8
0000ca  f7fffffe          BL       HAL_Delay
;;;614    	
;;;615    	SEGGER_RTT_Init();
0000ce  f7fffffe          BL       SEGGER_RTT_Init
;;;616    	SEGGER_RTT_printf(0,"  start\r\n" );
0000d2  a1c9              ADR      r1,|L18.1016|
0000d4  2000              MOVS     r0,#0
0000d6  f7fffffe          BL       SEGGER_RTT_printf
;;;617    	
;;;618      // MAX7219 LCD Maritex Test
;;;619    	//-------------------------------------------
;;;620    	#ifdef G_TEST_MAX7219_LCD_MARITEX
;;;621      maxInit(4,0);
0000da  2100              MOVS     r1,#0
0000dc  2004              MOVS     r0,#4
0000de  f7fffffe          BL       maxInit
;;;622    	HAL_Delay(500);
0000e2  f44f74fa          MOV      r4,#0x1f4
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       HAL_Delay
;;;623    	MAX7219_All_Display(0xFF);
0000ec  20ff              MOVS     r0,#0xff
0000ee  f7fffffe          BL       MAX7219_All_Display
;;;624    	HAL_Delay(500);
0000f2  4620              MOV      r0,r4
0000f4  f7fffffe          BL       HAL_Delay
;;;625    	MAX7219_All_Display(0x00);
0000f8  2000              MOVS     r0,#0
0000fa  f7fffffe          BL       MAX7219_All_Display
;;;626    	HAL_Delay(500);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       HAL_Delay
;;;627    	MAX7219_Display_1();
000104  f7fffffe          BL       MAX7219_Display_1
;;;628    	HAL_Delay(1000);
000108  0060              LSLS     r0,r4,#1
00010a  f7fffffe          BL       HAL_Delay
;;;629    	#endif
;;;630      //-------------------------------------------
;;;631    
;;;632    	appProjectOpen();
00010e  f7fffffe          BL       appProjectOpen
;;;633    	LibSwTimerClearCount();
000112  f7fffffe          BL       LibSwTimerClearCount
;;;634    	
;;;635    	// MCU UART3 Test
;;;636    	//-------------------------------------------
;;;637      appSerialUartSendMessage("12345678");
000116  a0bb              ADR      r0,|L18.1028|
000118  f7fffffe          BL       appSerialUartSendMessage
;;;638    	//-------------------------------------------
;;;639    	
;;;640    	// MX25LXX Flash Test
;;;641    	//------------------------------------------
;;;642    	#ifdef G_TEST_MX25LXX_FLASH
;;;643    	res = smp_mx25l_flash_init();
00011c  f7fffffe          BL       smp_mx25l_flash_init
000120  4ebb              LDR      r6,|L18.1040|
000122  72b0              STRB     r0,[r6,#0xa]
;;;644    	#endif
;;;645    	//------------------------------------------
;;;646    	
;;;647    	// AD7946 SPI ADC Test
;;;648    	//------------------------------------------
;;;649    	#ifdef G_TEST_AD7946_ADC 
;;;650    	smp_ADS7946_init();
000124  f7fffffe          BL       smp_ADS7946_init
;;;651    	#endif
;;;652    	//------------------------------------------
;;;653    	
;;;654    	//ADC Test
;;;655    	//------------------------------------------
;;;656    	#ifdef G_TEST_INT_ADC
;;;657    	static	uint16_t	app_adc_temp[10];
;;;658    	extern bsp_adc_init_io_config bsp_in_adc_ch[5];
;;;659    	
;;;660    	test_cont = 0;
000128  f04f0900          MOV      r9,#0
00012c  f8a69010          STRH     r9,[r6,#0x10]
;;;661    	smp_adc_adc_para_init(adc1);                            //Initial ADC 
000130  2000              MOVS     r0,#0
000132  f7fffffe          BL       smp_adc_adc_para_init
;;;662    	while(1){
;;;663    		hal_internal_adc_get(&app_adc_temp[0] ,adc1 , bsp_in_adc_ch[0]);
000136  4cb8              LDR      r4,|L18.1048|
000138  4db6              LDR      r5,|L18.1044|
;;;664    		hal_internal_adc_get(&app_adc_temp[1] ,adc1 , bsp_in_adc_ch[1]);
;;;665    		hal_internal_adc_get(&app_adc_temp[2] ,adc1 , bsp_in_adc_ch[2]);
;;;666    		hal_internal_adc_get(&app_adc_temp[3] ,adc1 , bsp_in_adc_ch[3]);
;;;667    		hal_internal_adc_get(&app_adc_temp[4] ,adc1 , bsp_in_adc_ch[4]);
00013a  f1040708          ADD      r7,r4,#8
                  |L18.318|
00013e  2100              MOVS     r1,#0                 ;663
000140  e9d52300          LDRD     r2,r3,[r5,#0]         ;663
000144  48b4              LDR      r0,|L18.1048|
000146  f7fffffe          BL       hal_internal_adc_get
00014a  e9d52302          LDRD     r2,r3,[r5,#8]         ;664
00014e  2100              MOVS     r1,#0                 ;664
000150  1ca0              ADDS     r0,r4,#2              ;664
000152  f7fffffe          BL       hal_internal_adc_get
000156  e9d52304          LDRD     r2,r3,[r5,#0x10]      ;665
00015a  2100              MOVS     r1,#0                 ;665
00015c  1d20              ADDS     r0,r4,#4              ;665
00015e  f7fffffe          BL       hal_internal_adc_get
000162  e9d52306          LDRD     r2,r3,[r5,#0x18]      ;666
000166  2100              MOVS     r1,#0                 ;666
000168  1da0              ADDS     r0,r4,#6              ;666
00016a  f7fffffe          BL       hal_internal_adc_get
00016e  e9d52308          LDRD     r2,r3,[r5,#0x20]
000172  2100              MOVS     r1,#0
000174  4638              MOV      r0,r7
000176  f7fffffe          BL       hal_internal_adc_get
;;;668    		
;;;669    		LOG_BLUE("TEST ADC#%04d %04d,%04d,%04d,%04d,%04d\r\n", test_cont,app_adc_temp[0],app_adc_temp[1],app_adc_temp[2],app_adc_temp[3],app_adc_temp[4]);
00017a  a3a8              ADR      r3,|L18.1052|
00017c  8920              LDRH     r0,[r4,#8]  ; app_adc_temp
00017e  88e1              LDRH     r1,[r4,#6]  ; app_adc_temp
000180  88a2              LDRH     r2,[r4,#4]  ; app_adc_temp
000182  e9cd0305          STRD     r0,r3,[sp,#0x14]
000186  e9cd2103          STRD     r2,r1,[sp,#0xc]
00018a  8820              LDRH     r0,[r4,#0]  ; app_adc_temp
00018c  8861              LDRH     r1,[r4,#2]  ; app_adc_temp
00018e  8a32              LDRH     r2,[r6,#0x10]  ; test_cont
000190  e9cd2000          STRD     r2,r0,[sp,#0]
000194  9102              STR      r1,[sp,#8]
000196  a39d              ADR      r3,|L18.1036|
000198  a2a2              ADR      r2,|L18.1060|
00019a  a1a4              ADR      r1,|L18.1068|
00019c  2000              MOVS     r0,#0
00019e  f7fffffe          BL       SEGGER_RTT_printf
;;;670    		
;;;671    		drv_bq796xx_delay_ms(50);
0001a2  2032              MOVS     r0,#0x32
0001a4  f7fffffe          BL       drv_bq796xx_delay_ms
;;;672    		
;;;673    		test_cont++;
0001a8  8a30              LDRH     r0,[r6,#0x10]  ; test_cont
0001aa  1c40              ADDS     r0,r0,#1
0001ac  b280              UXTH     r0,r0
0001ae  8230              STRH     r0,[r6,#0x10]
;;;674    		if(test_cont>=50) break;
0001b0  2832              CMP      r0,#0x32
0001b2  d3c4              BCC      |L18.318|
;;;675    	}
;;;676      #endif 
;;;677      //------------------------------------------
;;;678    	
;;;679      // BQ96XX Setting Init without step Test
;;;680      //----------------------------------------------------------------------------------
;;;681    	#ifdef G_TEST_BQ796XX_SETTING_INIT_WITHOUT_STEP
;;;682      drv_bq796xx_init_default_load(bq796xx_default);
0001b4  4aa9              LDR      r2,|L18.1116|
0001b6  6810              LDR      r0,[r2,#0]  ; bq796xx_default
0001b8  9005              STR      r0,[sp,#0x14]
0001ba  6851              LDR      r1,[r2,#4]  ; bq796xx_default
0001bc  9106              STR      r1,[sp,#0x18]
0001be  8913              LDRH     r3,[r2,#8]  ; bq796xx_default
0001c0  f8ad301c          STRH     r3,[sp,#0x1c]
0001c4  7a92              LDRB     r2,[r2,#0xa]  ; bq796xx_default
0001c6  f88d201e          STRB     r2,[sp,#0x1e]
0001ca  9a07              LDR      r2,[sp,#0x1c]
0001cc  f7fffffe          BL       drv_bq796xx_init_default_load
;;;683    
;;;684    	drv_bq796xx_init();
0001d0  f7fffffe          BL       drv_bq796xx_init
;;;685    
;;;686    	bq796xx_event_RegisteCB(app_afe_cb);
0001d4  48a2              LDR      r0,|L18.1120|
0001d6  f7fffffe          BL       bq796xx_event_RegisteCB
;;;687    	GPIOD->ODR &= ~GPIO_PIN_14;
0001da  4f84              LDR      r7,|L18.1004|
0001dc  3714              ADDS     r7,r7,#0x14
0001de  6838              LDR      r0,[r7,#0]
0001e0  f4204080          BIC      r0,r0,#0x4000
0001e4  6038              STR      r0,[r7,#0]
;;;688    	
;;;689    	bq_count_temp = smp_time_count_get();
0001e6  f7fffffe          BL       smp_time_count_get
0001ea  4d9e              LDR      r5,|L18.1124|
0001ec  8028              STRH     r0,[r5,#0]
;;;690    	
;;;691    	res = drv_bq796xx_start_setting(BMU_TOTAL_BOARDS, DIR_NORTH);
0001ee  2100              MOVS     r1,#0
0001f0  200d              MOVS     r0,#0xd
0001f2  f7fffffe          BL       drv_bq796xx_start_setting
0001f6  72b0              STRB     r0,[r6,#0xa]
;;;692      
;;;693    	#if 0
;;;694    	res = drv_bq796xx_start_setting(BMU_TOTAL_BOARDS, DIR_SOUTH);
;;;695      #endif 
;;;696    	
;;;697    	drv_bq796xx_Read_Stack_FaultSummary(0);
0001f8  2000              MOVS     r0,#0
0001fa  f7fffffe          BL       drv_bq796xx_Read_Stack_FaultSummary
;;;698    	drv_bq796xx_delay_ms(10);
0001fe  200a              MOVS     r0,#0xa
000200  f7fffffe          BL       drv_bq796xx_delay_ms
;;;699    				
;;;700      for(int k=0; k<10*BMU_TOTAL_BOARDS; k++){			
000204  2400              MOVS     r4,#0
                  |L18.518|
;;;701    	    res = drv_bq796xx_data_frame_parser(); 	
000206  f7fffffe          BL       drv_bq796xx_data_frame_parser
00020a  72b0              STRB     r0,[r6,#0xa]
00020c  1c64              ADDS     r4,r4,#1              ;700
00020e  2c82              CMP      r4,#0x82              ;700
000210  dbf9              BLT      |L18.518|
;;;702    	}
;;;703    	#endif
;;;704    	
;;;705    	#ifdef G_TEST_BQ796XX_SETTING_INIT_WITH_STEP
;;;706      //----------------------------------------------------------------------------------
;;;707    	for(int k = 0; k<10 ; k++){
000212  2400              MOVS     r4,#0
;;;708    	    afe_steps = 0;
;;;709    	    cnt_delay = 0;
000214  4d94              LDR      r5,|L18.1128|
000216  f8dfb254          LDR      r11,|L18.1132|
00021a  46ca              MOV      r10,r9                ;708
                  |L18.540|
00021c  f88ba000          STRB     r10,[r11,#0]          ;708
000220  f885a000          STRB     r10,[r5,#0]
;;;710    		  res = 0;
000224  f886a00a          STRB     r10,[r6,#0xa]
;;;711    		 
;;;712    		  smp_time_count_set(0);
000228  2000              MOVS     r0,#0
00022a  f7fffffe          BL       smp_time_count_set
;;;713    		
;;;714    		  if((k%2)==0){			
00022e  07e0              LSLS     r0,r4,#31
000230  d00b              BEQ      |L18.586|
;;;715              dir_state = DIR_NORTH;
;;;716    			}else{
;;;717    			    dir_state = DIR_SOUTH;
000232  2001              MOVS     r0,#1
000234  73f0              STRB     r0,[r6,#0xf]
                  |L18.566|
;;;718    			}	
;;;719    			
;;;720    			++wake_cnt;
000236  79b0              LDRB     r0,[r6,#6]  ; wake_cnt
000238  1c40              ADDS     r0,r0,#1
00023a  b2c0              UXTB     r0,r0
00023c  71b0              STRB     r0,[r6,#6]
;;;721    			if(wake_cnt>=3){
00023e  2803              CMP      r0,#3
000240  d306              BCC      |L18.592|
;;;722    			   wake_sw = WAKE_TONE_DISABLE;
000242  488b              LDR      r0,|L18.1136|
000244  f880a000          STRB     r10,[r0,#0]
000248  e005              B        |L18.598|
                  |L18.586|
00024a  f886a00f          STRB     r10,[r6,#0xf]         ;715
00024e  e7f2              B        |L18.566|
                  |L18.592|
;;;723    			}else{
;;;724    			   wake_sw = WAKE_TONE_ENABLE;
000250  4887              LDR      r0,|L18.1136|
000252  2101              MOVS     r1,#1
000254  7001              STRB     r1,[r0,#0]
                  |L18.598|
;;;725    			}
;;;726    		
;;;727    			
;;;728    			wake_sw = WAKE_TONE_ENABLE;
000256  4986              LDR      r1,|L18.1136|
000258  2001              MOVS     r0,#1
00025a  7008              STRB     r0,[r1,#0]
                  |L18.604|
;;;729    			
;;;730    			#if 0
;;;731    			dir_state = DIR_NORTH;
;;;732    			#endif 
;;;733    			
;;;734    	    while(1){	
;;;735    		      GPIOD->ODR ^= GPIO_PIN_13;
00025c  6838              LDR      r0,[r7,#0]
00025e  f4805000          EOR      r0,r0,#0x2000
000262  6038              STR      r0,[r7,#0]
;;;736    		  
;;;737    		      if(cnt_delay==0){
000264  7828              LDRB     r0,[r5,#0]  ; cnt_delay
000266  b9d0              CBNZ     r0,|L18.670|
;;;738    	            res = drv_bq796xx_Init_Steps(wake_sw,&afe_steps, bq796xx_default.bmu_total_num , dir_state, &step_com_f , &before_d_ms);
000268  f8df8208          LDR      r8,|L18.1140|
00026c  f8df9208          LDR      r9,|L18.1144|
000270  487a              LDR      r0,|L18.1116|
000272  e9cd9800          STRD     r9,r8,[sp,#0]
000276  7a82              LDRB     r2,[r0,#0xa]  ; bq796xx_default
000278  487d              LDR      r0,|L18.1136|
00027a  7bf3              LDRB     r3,[r6,#0xf]  ; dir_state
00027c  497b              LDR      r1,|L18.1132|
00027e  7800              LDRB     r0,[r0,#0]  ; wake_sw
000280  f7fffffe          BL       drv_bq796xx_Init_Steps
000284  72b0              STRB     r0,[r6,#0xa]
;;;739    				      cnt_delay = before_d_ms;
000286  f8980000          LDRB     r0,[r8,#0]  ; before_d_ms
00028a  7028              STRB     r0,[r5,#0]
;;;740    					    if(step_com_f == 1){
00028c  f8990000          LDRB     r0,[r9,#0]  ; step_com_f
000290  2801              CMP      r0,#1
000292  d104              BNE      |L18.670|
;;;741    		              ++afe_steps;
000294  f89b0000          LDRB     r0,[r11,#0]  ; afe_steps
000298  1c40              ADDS     r0,r0,#1
00029a  f88b0000          STRB     r0,[r11,#0]
                  |L18.670|
;;;742    			        }
;;;743    			    }
;;;744      		    GPIOD->ODR ^= GPIO_PIN_13;
00029e  6838              LDR      r0,[r7,#0]
0002a0  f4805000          EOR      r0,r0,#0x2000
0002a4  6038              STR      r0,[r7,#0]
;;;745     			
;;;746              if(bq_count_temp !=smp_time_count_get()){	   
0002a6  f7fffffe          BL       smp_time_count_get
0002aa  f8df81b8          LDR      r8,|L18.1124|
0002ae  f8b81000          LDRH     r1,[r8,#0]  ; bq_count_temp
0002b2  4288              CMP      r0,r1
0002b4  d007              BEQ      |L18.710|
;;;747    				     bq_count_temp = smp_time_count_get();
0002b6  f7fffffe          BL       smp_time_count_get
0002ba  f8a80000          STRH     r0,[r8,#0]
;;;748    				     if(cnt_delay>0){
0002be  7828              LDRB     r0,[r5,#0]  ; cnt_delay
0002c0  b108              CBZ      r0,|L18.710|
;;;749    					         --cnt_delay;
0002c2  1e40              SUBS     r0,r0,#1
0002c4  7028              STRB     r0,[r5,#0]
                  |L18.710|
;;;750    				     }
;;;751    			    }
;;;752    		
;;;753    		      if((res>=0) && (afe_steps > AFE_RUN_AUX_ADC)){
0002c6  f89b0000          LDRB     r0,[r11,#0]  ; afe_steps
0002ca  282a              CMP      r0,#0x2a
0002cc  d9c6              BLS      |L18.604|
;;;754    				    break;
;;;755    		      }
;;;756    	    }
;;;757    	
;;;758       	  GPIOD->ODR |= GPIO_PIN_14;
0002ce  6838              LDR      r0,[r7,#0]
0002d0  f4404080          ORR      r0,r0,#0x4000
0002d4  6038              STR      r0,[r7,#0]
;;;759    
;;;760    			if(dir_state == DIR_NORTH){
0002d6  7bf0              LDRB     r0,[r6,#0xf]  ; dir_state
0002d8  2800              CMP      r0,#0
0002da  d07d              BEQ      |L18.984|
;;;761    			    north_res = res & 0x7F;
;;;762    			}else{
;;;763    			    south_res = res & 0x7F;
0002dc  7ab1              LDRB     r1,[r6,#0xa]  ; res
0002de  f001017f          AND      r1,r1,#0x7f
0002e2  7071              STRB     r1,[r6,#1]
                  |L18.740|
;;;764    			}
;;;765    			
;;;766    			test_init_rec_bmu_num[dir_state][res & 0x7F]++;
0002e4  eb000180          ADD      r1,r0,r0,LSL #2
0002e8  484b              LDR      r0,|L18.1048|
0002ea  38a0              SUBS     r0,r0,#0xa0
0002ec  eb001201          ADD      r2,r0,r1,LSL #4
0002f0  7ab0              LDRB     r0,[r6,#0xa]  ; res
0002f2  f000017f          AND      r1,r0,#0x7f
0002f6  f8323011          LDRH     r3,[r2,r1,LSL #1]
0002fa  1c5b              ADDS     r3,r3,#1
0002fc  f8223011          STRH     r3,[r2,r1,LSL #1]
;;;767    			
;;;768    			bmu_is_ring = ((res & 0x80)>> 7);                                        //Results MSB is  0 = Non Ring, 1= Ring. 
000300  09c0              LSRS     r0,r0,#7
000302  7130              STRB     r0,[r6,#4]
;;;769    
;;;770    			SEGGER_RTT_printf(0,"BMU Init#%04d N=%d,S=%d\r\n", k, north_res, south_res);
000304  7870              LDRB     r0,[r6,#1]  ; south_res
000306  9000              STR      r0,[sp,#0]
000308  7833              LDRB     r3,[r6,#0]  ; north_res
00030a  4622              MOV      r2,r4
00030c  a15b              ADR      r1,|L18.1148|
00030e  2000              MOVS     r0,#0
000310  f7fffffe          BL       SEGGER_RTT_printf
;;;771    			
;;;772    	    test_cont = 0;
000314  f8a6a010          STRH     r10,[r6,#0x10]
000318  f8df8140          LDR      r8,|L18.1116|
                  |L18.796|
;;;773    	    while(1){
;;;774    				 drv_bq796xx_clear_fifobuffer();
00031c  f7fffffe          BL       drv_bq796xx_clear_fifobuffer
;;;775    	       drv_bq796xx_Read_AFE_ALL_VCELL(STACK, 0, 0);                          //Stack(BMU #1,#2) Read all VCell 1~16(Main ADC).
000320  2200              MOVS     r2,#0
000322  4611              MOV      r1,r2
000324  2001              MOVS     r0,#1
000326  f7fffffe          BL       drv_bq796xx_Read_AFE_ALL_VCELL
;;;776    				 drv_bq796xx_delay_ms(1*bq796xx_default.bmu_total_num);                //Please set  delay > (n X BMU conut) ms
00032a  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
00032e  f7fffffe          BL       drv_bq796xx_delay_ms
;;;777    				 
;;;778    				 drv_bq796xx_Read_AFE_ALL_ADC(STACK, 0, 0);                            //Stack(BMU #1,#2) Read all AUX ADC   (GPIO1~8).
000332  2200              MOVS     r2,#0
000334  4611              MOV      r1,r2
000336  2001              MOVS     r0,#1
000338  f7fffffe          BL       drv_bq796xx_Read_AFE_ALL_ADC
;;;779    	       drv_bq796xx_delay_ms(1*bq796xx_default.bmu_total_num);                //Please set  delay > (n X BMU conut) ms
00033c  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
000340  f7fffffe          BL       drv_bq796xx_delay_ms
;;;780    		
;;;781    				 drv_bq796xx_Read_Stack_FaultSummary(0);                               //Stack read Fault summary status.
000344  2000              MOVS     r0,#0
000346  f7fffffe          BL       drv_bq796xx_Read_Stack_FaultSummary
;;;782    				 drv_bq796xx_delay_ms(1*bq796xx_default.bmu_total_num);                //Please set  delay > (n X BMU conut) ms
00034a  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
00034e  f7fffffe          BL       drv_bq796xx_delay_ms
;;;783    
;;;784    				 for(int ki =0; ki<10*BMU_TOTAL_BOARDS; ki++){
000352  f04f0900          MOV      r9,#0
                  |L18.854|
;;;785    				     res = drv_bq796xx_data_frame_parser();
000356  f7fffffe          BL       drv_bq796xx_data_frame_parser
00035a  72b0              STRB     r0,[r6,#0xa]
00035c  f1090901          ADD      r9,r9,#1              ;784
000360  f1b90f82          CMP      r9,#0x82              ;784
000364  dbf7              BLT      |L18.854|
;;;786    				 }					 
;;;787    		     
;;;788    				 if(test_cont >=2) break;
000366  8a30              LDRH     r0,[r6,#0x10]  ; test_cont
000368  2802              CMP      r0,#2
00036a  d339              BCC      |L18.992|
00036c  1c64              ADDS     r4,r4,#1              ;707
00036e  2c0a              CMP      r4,#0xa               ;707
000370  f6ffaf54          BLT      |L18.540|
;;;789    		     test_cont++;
;;;790    	    }	
;;;791      }
;;;792      //---------------------------------------------------------------------------------
;;;793      #endif
;;;794    	
;;;795    	// BQ796XX Cell Balance function Test
;;;796    	//----------------------------------------------------------------------------------
;;;797    	#ifdef G_TEST_BQ796XX_CELL_BALANCE_FUNC
;;;798      drv_bq796xx_CellBalance_1to8_clear(STACK, 0 , 1);
;;;799      drv_bq796xx_CellBalance_9to16_clear(STACK, 0 , 1);
;;;800    	 
;;;801      //Test Cell balance
;;;802      //Setting BMU=0x01, Cell 1,5,15,16 enable cell balance func =10s.
;;;803      cb_en1 =((1 << 4) | (1 << 0));
;;;804      cb_en2 =((1 << 3) | (1 << 1));				
;;;805    	drv_bq796xx_CellBalance_1to8_set( 0x01, cb_en1,CB_TIME_10S,1);
;;;806      drv_bq796xx_CellBalance_9to16_set(0x01, cb_en2,CB_TIME_10S,1);		
;;;807    	
;;;808      //Setting BMU=0x02, Cell 1,5 enable cell balance func=10s.
;;;809    	drv_bq796xx_CellBalance_1to8_set(0x02, cb_en2,CB_TIME_10S,1);
;;;810    	
;;;811    	while(1){
;;;812    	  //Starting cell balance, cell balance active until CB_CELLXX TIME, then this bit be self-clearing.
;;;813    	  drv_bq796xx_Stack_CellBalanceStarting(CB_MANUAL, 1);
;;;814    		drv_bq796xx_delay_ms(10);
;;;815    		test_cont++;
;;;816    		if(test_cont>100) break;
;;;817    	}
;;;818    	#endif
;;;819    	//----------------------------------------------------------------------------------
;;;820      
;;;821    	// BQ796XX  Direction check North/South BMU number Test with step.
;;;822    	//----------------------------------------------------------------------------------
;;;823    	#ifdef G_TEST_BQ796XX_DIRECTION_CHECK_BMU_WITH_STEP
;;;824    	north_res = 0;
000374  46d1              MOV      r9,r10
000376  f886a000          STRB     r10,[r6,#0]
;;;825    	south_res = 0;
00037a  f8869001          STRB     r9,[r6,#1]
;;;826    	bmu_is_ring = 0;
00037e  f8869004          STRB     r9,[r6,#4]
;;;827    
;;;828      for(long int k = 0; k<100; k++){
000382  2400              MOVS     r4,#0
                  |L18.900|
;;;829    	    dir_afe_steps = 0;
000384  4635              MOV      r5,r6
000386  f886900b          STRB     r9,[r6,#0xb]
;;;830    	    dir_cnt_delay = 0;
00038a  f885900e          STRB     r9,[r5,#0xe]
;;;831    		  dir_res = 0;
00038e  f8859002          STRB     r9,[r5,#2]
;;;832    		
;;;833    		  drv_bq796xx_clear_fifobuffer();
000392  f7fffffe          BL       drv_bq796xx_clear_fifobuffer
;;;834    		  smp_time_count_set(0);
000396  2000              MOVS     r0,#0
000398  f7fffffe          BL       smp_time_count_set
;;;835    		  
;;;836    		  if((k%2)==0){			
00039c  07e0              LSLS     r0,r4,#31
00039e  d020              BEQ      |L18.994|
;;;837              dir_state = DIR_NORTH;
;;;838    			}else{
;;;839    			    dir_state = DIR_SOUTH;
0003a0  2001              MOVS     r0,#1
0003a2  73e8              STRB     r0,[r5,#0xf]
                  |L18.932|
;;;840    			}		
;;;841    	    
;;;842          //Check these condition, if it is true then skip auto addressing.
;;;843          //-------------------------------------------------------------			
;;;844    			if( (north_res ==bq796xx_default.bmu_total_num) || (south_res ==bq796xx_default.bmu_total_num) || ((north_res+ south_res)==bq796xx_default.bmu_total_num)){
0003a4  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
0003a8  7829              LDRB     r1,[r5,#0]  ; north_res
0003aa  4288              CMP      r0,r1
0003ac  d005              BEQ      |L18.954|
0003ae  786a              LDRB     r2,[r5,#1]  ; south_res
0003b0  4290              CMP      r0,r2
0003b2  d002              BEQ      |L18.954|
0003b4  440a              ADD      r2,r2,r1
0003b6  4282              CMP      r2,r0
0003b8  d17d              BNE      |L18.1206|
                  |L18.954|
;;;845    		      if((k%2)==0){			
0003ba  07e0              LSLS     r0,r4,#31
0003bc  d079              BEQ      |L18.1202|
;;;846                  ns_bmu_cnt = north_res;    //Skip autoaddressing	
;;;847    			    }else{
;;;848    			        ns_bmu_cnt = south_res;    //Skip autoaddressing	
0003be  7868              LDRB     r0,[r5,#1]  ; south_res
0003c0  70e8              STRB     r0,[r5,#3]
                  |L18.962|
;;;849    			    }
;;;850    					
;;;851    					++ns_recheck_cnt;
0003c2  7968              LDRB     r0,[r5,#5]  ; ns_recheck_cnt
0003c4  1c40              ADDS     r0,r0,#1
0003c6  b2c0              UXTB     r0,r0
0003c8  7168              STRB     r0,[r5,#5]
;;;852    					
;;;853    					if(ns_recheck_cnt>=50){
0003ca  2832              CMP      r0,#0x32
0003cc  d307              BCC      |L18.990|
;;;854    						  ns_bmu_cnt = 0;   //Re autoaddressing	
0003ce  f8859003          STRB     r9,[r5,#3]
;;;855    						 if(ns_recheck_cnt>=51) ns_recheck_cnt = 0;
0003d2  2833              CMP      r0,#0x33
0003d4  d303              BCC      |L18.990|
0003d6  e000              B        |L18.986|
                  |L18.984|
0003d8  e060              B        |L18.1180|
                  |L18.986|
0003da  f8859005          STRB     r9,[r5,#5]
                  |L18.990|
0003de  e0bb              B        |L18.1368|
                  |L18.992|
0003e0  e061              B        |L18.1190|
                  |L18.994|
0003e2  e063              B        |L18.1196|
                  |L18.996|
                          DCD      0xe000e180
                  |L18.1000|
                          DCD      0x40021000
                  |L18.1004|
                          DCD      0x48000c00
                  |L18.1008|
                          DCD      0x48000800
                  |L18.1012|
                          DCD      0x48001000
                  |L18.1016|
0003f8  20207374          DCB      "  start\r\n",0
0003fc  6172740d
000400  0a00    
000402  00                DCB      0
000403  00                DCB      0
                  |L18.1028|
000404  31323334          DCB      "12345678"
000408  35363738
                  |L18.1036|
00040c  00                DCB      0
00040d  00                DCB      0
00040e  00                DCB      0
00040f  00                DCB      0
                  |L18.1040|
                          DCD      ||area_number.28||
                  |L18.1044|
                          DCD      bsp_in_adc_ch
                  |L18.1048|
                          DCD      ||area_number.23||+0xa0
                  |L18.1052|
00041c  1b5b306d          DCB      27,"[0m",0
000420  00      
000421  00                DCB      0
000422  00                DCB      0
000423  00                DCB      0
                  |L18.1060|
000424  1b5b313b          DCB      27,"[1;34m",0
000428  33346d00
                  |L18.1068|
00042c  25732573          DCB      "%s%sTEST ADC#%04d %04d,%04d,%04d,%04d,%04d\r\n%s",0
000430  54455354
000434  20414443
000438  23253034
00043c  64202530
000440  34642c25
000444  3034642c
000448  25303464
00044c  2c253034
000450  642c2530
000454  34640d0a
000458  257300  
00045b  00                DCB      0
                  |L18.1116|
                          DCD      bq796xx_default
                  |L18.1120|
                          DCD      app_afe_cb
                  |L18.1124|
                          DCD      bq_count_temp
                  |L18.1128|
                          DCD      cnt_delay
                  |L18.1132|
                          DCD      afe_steps
                  |L18.1136|
                          DCD      wake_sw
                  |L18.1140|
                          DCD      before_d_ms
                  |L18.1144|
                          DCD      step_com_f
                  |L18.1148|
00047c  424d5520          DCB      "BMU Init#%04d N=%d,S=%d\r\n",0
000480  496e6974
000484  23253034
000488  64204e3d
00048c  25642c53
000490  3d25640d
000494  0a00    
000496  00                DCB      0
000497  00                DCB      0
000498  e00d              B        |L18.1206|
00049a  e00a              B        |L18.1202|
                  |L18.1180|
00049c  7ab1              LDRB     r1,[r6,#0xa]          ;761  ; res
00049e  f001017f          AND      r1,r1,#0x7f           ;761
0004a2  7031              STRB     r1,[r6,#0]            ;761
0004a4  e71e              B        |L18.740|
                  |L18.1190|
0004a6  1c40              ADDS     r0,r0,#1              ;789
0004a8  8230              STRH     r0,[r6,#0x10]         ;789
0004aa  e737              B        |L18.796|
                  |L18.1196|
0004ac  f885900f          STRB     r9,[r5,#0xf]          ;837
0004b0  e778              B        |L18.932|
                  |L18.1202|
0004b2  70e9              STRB     r1,[r5,#3]            ;846
0004b4  e785              B        |L18.962|
                  |L18.1206|
;;;856    					}
;;;857    			}else{
;;;858    					ns_bmu_cnt = 0;   //Re autoaddressing	
0004b6  f8859003          STRB     r9,[r5,#3]
0004ba  e04d              B        |L18.1368|
                  |L18.1212|
;;;859    			}	
;;;860    			//-------------------------------------------------------------
;;;861    	    while(1){	
;;;862    		      GPIOD->ODR ^= GPIO_PIN_13;
;;;863    		 
;;;864    		      if(dir_cnt_delay==0){
;;;865    						
;;;866    						  ns_bmu_cnt = 0;  //Re autoaddressing
0004bc  4648              MOV      r0,r9
0004be  f8859003          STRB     r9,[r5,#3]
;;;867    						
;;;868                  dir_res = drv_bq796xx_direction_set_steps(ns_bmu_cnt, &dir_afe_steps, bq796xx_default.bmu_total_num , dir_state, &dir_step_com_f , &dir_before_d_ms);							
0004c2  497e              LDR      r1,|L18.1724|
0004c4  1e4a              SUBS     r2,r1,#1
0004c6  e9cd2100          STRD     r2,r1,[sp,#0]
0004ca  f898200a          LDRB     r2,[r8,#0xa]  ; bq796xx_default
0004ce  7beb              LDRB     r3,[r5,#0xf]  ; dir_state
0004d0  1e89              SUBS     r1,r1,#2
0004d2  f7fffffe          BL       drv_bq796xx_direction_set_steps
0004d6  70a8              STRB     r0,[r5,#2]
;;;869    						  dir_cnt_delay=dir_before_d_ms;
0004d8  7b68              LDRB     r0,[r5,#0xd]  ; dir_before_d_ms
0004da  73a8              STRB     r0,[r5,#0xe]
;;;870    					    if(dir_step_com_f == 1){
0004dc  7b28              LDRB     r0,[r5,#0xc]  ; dir_step_com_f
0004de  2801              CMP      r0,#1
0004e0  d102              BNE      |L18.1256|
;;;871    		              ++dir_afe_steps;
0004e2  7ae8              LDRB     r0,[r5,#0xb]  ; dir_afe_steps
0004e4  1c40              ADDS     r0,r0,#1
0004e6  72e8              STRB     r0,[r5,#0xb]
                  |L18.1256|
;;;872    			        }
;;;873    			    }
;;;874      		    GPIOD->ODR ^= GPIO_PIN_13;
0004e8  6838              LDR      r0,[r7,#0]
0004ea  f4805000          EOR      r0,r0,#0x2000
0004ee  6038              STR      r0,[r7,#0]
;;;875     			
;;;876              if(dir_bq_count_temp !=smp_time_count_get()){	   
0004f0  f7fffffe          BL       smp_time_count_get
0004f4  8a69              LDRH     r1,[r5,#0x12]  ; dir_bq_count_temp
0004f6  4288              CMP      r0,r1
0004f8  d006              BEQ      |L18.1288|
;;;877    				     dir_bq_count_temp = smp_time_count_get();
0004fa  f7fffffe          BL       smp_time_count_get
0004fe  8268              STRH     r0,[r5,#0x12]
;;;878    				     if(dir_cnt_delay>0){
000500  7ba8              LDRB     r0,[r5,#0xe]  ; dir_cnt_delay
000502  b108              CBZ      r0,|L18.1288|
;;;879    					     --dir_cnt_delay;
000504  1e40              SUBS     r0,r0,#1
000506  73a8              STRB     r0,[r5,#0xe]
                  |L18.1288|
;;;880    				     }
;;;881    			    }
;;;882    		
;;;883    		      if((dir_res>=0) && (dir_afe_steps > SETDIR_AFE_RUN_AUX_ADC)){
000508  7ae8              LDRB     r0,[r5,#0xb]  ; dir_afe_steps
00050a  2812              CMP      r0,#0x12
00050c  d924              BLS      |L18.1368|
;;;884    				    break;
;;;885    		      }
;;;886    	    }
;;;887    			
;;;888    			if(dir_state == DIR_NORTH){
00050e  7be8              LDRB     r0,[r5,#0xf]  ; dir_state
000510  b350              CBZ      r0,|L18.1384|
;;;889    			    north_res = dir_res & 0x7F;
;;;890    			}else{
;;;891    			    south_res = dir_res & 0x7F;
000512  78a8              LDRB     r0,[r5,#2]  ; dir_res
000514  f000007f          AND      r0,r0,#0x7f
000518  7068              STRB     r0,[r5,#1]
                  |L18.1306|
;;;892    			}
;;;893    			
;;;894    			bmu_is_ring = ((dir_res & 0x80)>> 7);                                       //Results MSB is  0 = Non Ring, 1= Ring. 
00051a  78a8              LDRB     r0,[r5,#2]  ; dir_res
00051c  09c0              LSRS     r0,r0,#7
00051e  7128              STRB     r0,[r5,#4]
;;;895    			
;;;896    			LOG_GREEN("BMU CHK#%04d N=%d,S=%d,Ring=%d\r\n", k, north_res, south_res , bmu_is_ring);
000520  f2af1108          ADR      r1,|L18.1052|
000524  786a              LDRB     r2,[r5,#1]  ; south_res
000526  782b              LDRB     r3,[r5,#0]  ; north_res
000528  e9cd2002          STRD     r2,r0,[sp,#8]
00052c  e9cd4300          STRD     r4,r3,[sp,#0]
000530  9104              STR      r1,[sp,#0x10]
000532  f2af1328          ADR      r3,|L18.1036|
000536  a262              ADR      r2,|L18.1728|
000538  a163              ADR      r1,|L18.1736|
00053a  2000              MOVS     r0,#0
00053c  f7fffffe          BL       SEGGER_RTT_printf
;;;897    			
;;;898    			if(dir_res>=2){
000540  78a8              LDRB     r0,[r5,#2]  ; dir_res
000542  2802              CMP      r0,#2
000544  d315              BCC      |L18.1394|
;;;899    			   test_dir_ok[dir_state]++;
000546  495d              LDR      r1,|L18.1724|
000548  7be8              LDRB     r0,[r5,#0xf]  ; dir_state
00054a  311f              ADDS     r1,r1,#0x1f
00054c  f8512020          LDR      r2,[r1,r0,LSL #2]
000550  1c52              ADDS     r2,r2,#1
000552  f8412020          STR      r2,[r1,r0,LSL #2]
000556  e014              B        |L18.1410|
                  |L18.1368|
000558  6838              LDR      r0,[r7,#0]            ;862
00055a  f4805000          EOR      r0,r0,#0x2000         ;862
00055e  6038              STR      r0,[r7,#0]            ;862
000560  7ba8              LDRB     r0,[r5,#0xe]          ;864  ; dir_cnt_delay
000562  2800              CMP      r0,#0                 ;861
000564  d1c0              BNE      |L18.1256|
000566  e7a9              B        |L18.1212|
                  |L18.1384|
000568  78a8              LDRB     r0,[r5,#2]            ;889  ; dir_res
00056a  f000007f          AND      r0,r0,#0x7f           ;889
00056e  7028              STRB     r0,[r5,#0]            ;889
000570  e7d3              B        |L18.1306|
                  |L18.1394|
;;;900    			}else{
;;;901    			   test_dir_fail[dir_state]++;
000572  4952              LDR      r1,|L18.1724|
000574  7be8              LDRB     r0,[r5,#0xf]  ; dir_state
000576  3127              ADDS     r1,r1,#0x27
000578  f8512020          LDR      r2,[r1,r0,LSL #2]
00057c  1c52              ADDS     r2,r2,#1
00057e  f8412020          STR      r2,[r1,r0,LSL #2]
                  |L18.1410|
;;;902    			}
;;;903    			
;;;904    			drv_bq796xx_delay_ms(dir_state+1);
000582  7be8              LDRB     r0,[r5,#0xf]  ; dir_state
000584  46aa              MOV      r10,r5
000586  1c40              ADDS     r0,r0,#1
000588  f7fffffe          BL       drv_bq796xx_delay_ms
;;;905    			
;;;906    			dir_step_com_f = 0;
00058c  f88a900c          STRB     r9,[r10,#0xc]
;;;907    			dir_before_d_ms = 0;
000590  f88a900d          STRB     r9,[r10,#0xd]
;;;908    			
;;;909    			test_cont = 0;
000594  f8aa9010          STRH     r9,[r10,#0x10]
                  |L18.1432|
;;;910    	    while(1){
;;;911    				 drv_bq796xx_clear_fifobuffer();
000598  f7fffffe          BL       drv_bq796xx_clear_fifobuffer
;;;912    				
;;;913    	       drv_bq796xx_Read_AFE_ALL_VCELL(STACK, 0, 0);                               //Stack(BMU #1,#2) Read all VCell 1~16(Main ADC).
00059c  2200              MOVS     r2,#0
00059e  4611              MOV      r1,r2
0005a0  2001              MOVS     r0,#1
0005a2  f7fffffe          BL       drv_bq796xx_Read_AFE_ALL_VCELL
;;;914    				 drv_bq796xx_delay_ms(1*bq796xx_default.bmu_total_num);                     //Please set  delay > (n X BMU conut) ms
0005a6  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
0005aa  f7fffffe          BL       drv_bq796xx_delay_ms
;;;915    				
;;;916    				 drv_bq796xx_Read_AFE_ALL_ADC(STACK, 0, 0);                                 //Stack(BMU #1,#2) Read all AUX ADC   (GPIO1~8).
0005ae  2200              MOVS     r2,#0
0005b0  4611              MOV      r1,r2
0005b2  2001              MOVS     r0,#1
0005b4  f7fffffe          BL       drv_bq796xx_Read_AFE_ALL_ADC
;;;917    		     drv_bq796xx_delay_ms(1*bq796xx_default.bmu_total_num);                     //Please set  delay > (n X BMU conut) ms
0005b8  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
0005bc  f7fffffe          BL       drv_bq796xx_delay_ms
;;;918    				
;;;919    				 drv_bq796xx_Read_Stack_FaultSummary(0);                                    //Stack read Fault summary status.
0005c0  2000              MOVS     r0,#0
0005c2  f7fffffe          BL       drv_bq796xx_Read_Stack_FaultSummary
;;;920    				 drv_bq796xx_delay_ms(1*bq796xx_default.bmu_total_num);                     //Please set  delay > (n X BMU conut) ms
0005c6  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
0005ca  f7fffffe          BL       drv_bq796xx_delay_ms
;;;921    				
;;;922    				 for(int ki =0; ki<10*BMU_TOTAL_BOARDS; ki++){
0005ce  2500              MOVS     r5,#0
                  |L18.1488|
;;;923    				     res = drv_bq796xx_data_frame_parser();
0005d0  f7fffffe          BL       drv_bq796xx_data_frame_parser
0005d4  f88a000a          STRB     r0,[r10,#0xa]
0005d8  1c6d              ADDS     r5,r5,#1              ;922
0005da  2d82              CMP      r5,#0x82              ;922
0005dc  dbf8              BLT      |L18.1488|
;;;924    				 }					 
;;;925    		     
;;;926    				 if(test_cont >=2) break;
0005de  f8ba0010          LDRH     r0,[r10,#0x10]  ; test_cont
0005e2  2802              CMP      r0,#2
0005e4  d346              BCC      |L18.1652|
;;;927    		     test_cont++;
;;;928    	    }
;;;929    			
;;;930    			dir_step_com_f = 0;
0005e6  f88a900c          STRB     r9,[r10,#0xc]
;;;931    			dir_before_d_ms = 0;
0005ea  f88a900d          STRB     r9,[r10,#0xd]
0005ee  1c64              ADDS     r4,r4,#1              ;828
0005f0  2c64              CMP      r4,#0x64              ;828
0005f2  f6ffaec7          BLT      |L18.900|
;;;932      }
;;;933      //------------------------------------------------------------------------------------------		
;;;934    
;;;935    	#endif
;;;936      //------------------------------------------------------------------------------------------
;;;937    
;;;938      apiFuCheckMagicCode();
0005f6  f7fffffe          BL       apiFuCheckMagicCode
;;;939    	
;;;940      for(int k=0 ;k<64; k++){
0005fa  2400              MOVS     r4,#0
                  |L18.1532|
;;;941    	    drv_bq796xx_Read_Stack_FaultSummary(0);                                    //Stack read Fault summary status.
0005fc  2000              MOVS     r0,#0
0005fe  f7fffffe          BL       drv_bq796xx_Read_Stack_FaultSummary
;;;942    	    drv_bq796xx_delay_ms(2*bq796xx_default.bmu_total_num);                     //Please set  delay > (n X BMU conut) ms
000602  f898000a          LDRB     r0,[r8,#0xa]  ; bq796xx_default
000606  0040              LSLS     r0,r0,#1
000608  f7fffffe          BL       drv_bq796xx_delay_ms
00060c  1c64              ADDS     r4,r4,#1              ;940
00060e  2c40              CMP      r4,#0x40              ;940
000610  dbf4              BLT      |L18.1532|
;;;943      }
;;;944    
;;;945    	drv_bq796xx_clear_fifobuffer();
000612  f7fffffe          BL       drv_bq796xx_clear_fifobuffer
;;;946    	 
;;;947    	//IRM Test(2021/12/21)
;;;948    	//----------------------------------------------------------------------------------------- 
;;;949    	#ifdef G_TEST_IRM_FUNCTION
;;;950    	//Register All callbasck function for IRM
;;;951    	app_irm_event_cb.SW_gpioinit_cb = app_irm_sw_gpio_init_cb;
000616  4837              LDR      r0,|L18.1780|
000618  4d35              LDR      r5,|L18.1776|
00061a  6005              STR      r5,[r0,#0]  ; app_irm_event_cb
;;;952    	app_irm_event_cb.SW_gpio_crtl_cb[0]=app_irm_sw1_gpio; 
00061c  4c36              LDR      r4,|L18.1784|
00061e  6044              STR      r4,[r0,#4]  ; app_irm_event_cb
;;;953    	app_irm_event_cb.SW_gpio_crtl_cb[1]=app_irm_sw2_gpio;
000620  4936              LDR      r1,|L18.1788|
000622  6081              STR      r1,[r0,#8]  ; app_irm_event_cb
;;;954    	app_irm_event_cb.SW_gpio_crtl_cb[2]=app_irm_sw3_gpio; 
000624  4936              LDR      r1,|L18.1792|
000626  60c1              STR      r1,[r0,#0xc]  ; app_irm_event_cb
;;;955    	app_irm_event_cb.GetVoltDeviceInit_cb = app_irm_get_device_init_cb;
000628  4936              LDR      r1,|L18.1796|
00062a  6101              STR      r1,[r0,#0x10]  ; app_irm_event_cb
;;;956    	app_irm_event_cb.TriggerData_cb = app_irm_trigger_voltage_data_cb;
00062c  4936              LDR      r1,|L18.1800|
00062e  6141              STR      r1,[r0,#0x14]  ; app_irm_event_cb
;;;957    	app_irm_event_cb.irm_outdata = app_irm_rxdata_cb;
000630  4936              LDR      r1,|L18.1804|
000632  6181              STR      r1,[r0,#0x18]  ; app_irm_event_cb
;;;958    	app_irm_event_cb.DataReady_cb = irm_data_ready_cb;
000634  4936              LDR      r1,|L18.1808|
000636  61c1              STR      r1,[r0,#0x1c]  ; app_irm_event_cb
;;;959    	
;;;960    	//Open IRM function, Setting 2s= IRM detection period, 100ms = IRM switch SW1~Sw3 waitting time. 
;;;961    	res = apiIRMonitoringOpen(2, 100, app_irm_event_cb);
000638  f1000108          ADD      r1,r0,#8
00063c  2218              MOVS     r2,#0x18
00063e  4668              MOV      r0,sp
000640  f7fffffe          BL       __aeabi_memcpy4
000644  4623              MOV      r3,r4
000646  462a              MOV      r2,r5
000648  2164              MOVS     r1,#0x64
00064a  2002              MOVS     r0,#2
00064c  f7fffffe          BL       apiIRMonitoringOpen
000650  72b0              STRB     r0,[r6,#0xa]
;;;962    	
;;;963    	//Get current Vstack, IRM use callback notification Vstack.
;;;964    	apiIRMonitoringGetVstack();
000652  f7fffffe          BL       apiIRMonitoringGetVstack
;;;965    	#endif
;;;966    	//-------------------------------------------------------------------------------------- 
;;;967    	
;;;968    	//Event log Test (2022/01/04)
;;;969    	//--------------------------------------------------------------------------------------
;;;970    	#ifdef G_TEST_EVENT_LOG_FUNC
;;;971    	smp_mx25l_status mx251_status;
;;;972    	smp_mx25l_flash_init();
000656  f7fffffe          BL       smp_mx25l_flash_init
;;;973    	
;;;974    	uint16_t test_event_log_cnt = 0;
00065a  2400              MOVS     r4,#0
;;;975    	
;;;976    	app_flash_log_managment_init(app_flash_log_event_handler);
00065c  482d              LDR      r0,|L18.1812|
00065e  f7fffffe          BL       app_flash_log_managment_init
;;;977    	HAL_Delay(1000);
000662  f44f707a          MOV      r0,#0x3e8
000666  f7fffffe          BL       HAL_Delay
00066a  f44f76fa          MOV      r6,#0x1f4             ;622
;;;978    	while(test_event_log_cnt<300)
00066e  f44f7596          MOV      r5,#0x12c
000672  e01e              B        |L18.1714|
                  |L18.1652|
000674  1c40              ADDS     r0,r0,#1              ;927
000676  f8aa0010          STRH     r0,[r10,#0x10]        ;927
00067a  e78d              B        |L18.1432|
                  |L18.1660|
;;;979    	{
;;;980    		
;;;981    	  smp_mx25l_flash_read_status(&mx251_status);
00067c  a808              ADD      r0,sp,#0x20
00067e  f7fffffe          BL       smp_mx25l_flash_read_status
;;;982    		if((mx251_status.status1&STATUS_WRITE_IN_PROGRESS)==0){		
000682  f89d0020          LDRB     r0,[sp,#0x20]
000686  07c0              LSLS     r0,r0,#31
000688  d101              BNE      |L18.1678|
;;;983    			 MX25L_SPI_send_command();
00068a  f7fffffe          BL       MX25L_SPI_send_command
                  |L18.1678|
;;;984    		}
;;;985        
;;;986    		test_uart_rx_process();
00068e  f7fffffe          BL       test_uart_rx_process
;;;987    		
;;;988    		test_event_log_cnt++;
000692  1c64              ADDS     r4,r4,#1
000694  b2a4              UXTH     r4,r4
;;;989    		HAL_Delay(500);
000696  4630              MOV      r0,r6
000698  f7fffffe          BL       HAL_Delay
;;;990    		LOG_WHITE("Event log#%d transfer\r\n", test_event_log_cnt);
00069c  f2af2084          ADR      r0,|L18.1052|
0006a0  f2af2398          ADR      r3,|L18.1036|
0006a4  e9cd4000          STRD     r4,r0,[sp,#0]
0006a8  a21b              ADR      r2,|L18.1816|
0006aa  a11d              ADR      r1,|L18.1824|
0006ac  2000              MOVS     r0,#0
0006ae  f7fffffe          BL       SEGGER_RTT_printf
                  |L18.1714|
0006b2  42ac              CMP      r4,r5                 ;978
0006b4  d3e2              BCC      |L18.1660|
                  |L18.1718|
;;;991    	}
;;;992    	#endif
;;;993    	//--------------------------------------------------------------------------------------
;;;994    	
;;;995    	while(1)
;;;996    	{
;;;997    		#if 0
;;;998    		GPIOD->ODR |= GPIO_PIN_13;
;;;999    		#endif
;;;1000   		
;;;1001   		LibSwTimerHandle();
0006b6  f7fffffe          BL       LibSwTimerHandle
0006ba  e7fc              B        |L18.1718|
;;;1002   		
;;;1003   		#if 0
;;;1004   		GPIOD->ODR &= ~GPIO_PIN_13;
;;;1005   		GPIOD->ODR ^= GPIO_PIN_14;
;;;1006       GPIOB->ODR ^= GPIO_PIN_6;
;;;1007   	
;;;1008       GPIOA->ODR ^= GPIO_PIN_4;//(GPIO_PIN_0 |1 );//| GPIO_PIN_1 | GPIO_PIN_2);
;;;1009       for(del=0; del<2000000; del++);
;;;1010   		GPIOD->ODR ^= GPIO_PIN_13;
;;;1011       GPIOC->ODR ^= GPIO_PIN_6;
;;;1012   
;;;1013       GPIOB->ODR ^= (GPIO_PIN_10 | GPIO_PIN_11);// |  GPIO_PIN_11);
;;;1014       GPIOB->ODR ^= (GPIO_PIN_11);// |  GPIO_PIN_11);
;;;1015   		#endif
;;;1016   	}
;;;1017   
;;;1018   #if	0	
;;;1019     /* Configure LED1, and LED2 */
;;;1020     BSP_LED_Init(LED1);
;;;1021     BSP_LED_Init(LED2);
;;;1022   
;;;1023     /* Check if the system was resumed from Standby mode */ 
;;;1024     if (__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET)
;;;1025     {
;;;1026       /* Clear Standby flag */
;;;1027       __HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB);
;;;1028   
;;;1029       resumed_from_standby = 1;
;;;1030         
;;;1031       /* Wait that user release the User push-button */
;;;1032       BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);
;;;1033       while(BSP_PB_GetState(BUTTON_USER) == GPIO_PIN_SET){}       
;;;1034   
;;;1035   #ifndef NO_DELAY_TOWARDS_SMPS 
;;;1036       HAL_Delay(2500);
;;;1037   #endif
;;;1038     } 
;;;1039     else
;;;1040     {
;;;1041       /* User push-button (External line 13) will be used to wakeup the system from Standby mode */
;;;1042       BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
;;;1043   
;;;1044       /* Configure the system clock to 80 MHz */
;;;1045       SystemClock_Config_80MHz();
;;;1046    
;;;1047       /* Insert 5 seconds delay */
;;;1048       /* Delay at wake-up       */
;;;1049       HAL_Delay(5000);
;;;1050       
;;;1051       /* ------------------------------------------ */
;;;1052   
;;;1053       SMPS_status = BSP_SMPS_DeInit();
;;;1054       if (SMPS_status != SMPS_OK)
;;;1055       {
;;;1056         Error_Handler();
;;;1057       }
;;;1058   
;;;1059     }
;;;1060     
;;;1061     SMPS_status = BSP_SMPS_Init(PWR_REGULATOR_VOLTAGE_SCALE2);
;;;1062     if (SMPS_status != SMPS_OK)
;;;1063     {
;;;1064       Error_Handler();
;;;1065     } 
;;;1066   			  
;;;1067     if (resumed_from_standby == 0)
;;;1068     {
;;;1069       /* ------------------------------------------ */
;;;1070       SystemClock_Config_24MHz(); 
;;;1071   
;;;1072   #ifndef NO_DELAY_TOWARDS_SMPS     
;;;1073       /* Insert 3 seconds delay */
;;;1074       HAL_Delay(3000);
;;;1075   #endif
;;;1076       
;;;1077       /********************************/
;;;1078       /* After reset                  */
;;;1079       /* 24 MHZ                       */		
;;;1080       /* PWR_REGULATOR_VOLTAGE_SCALE1 */
;;;1081       /* SMPS IS OFF                  */
;;;1082       /********************************/
;;;1083     }
;;;1084     
;;;1085     /* ------------------------------------------ */
;;;1086     
;;;1087     /* PWR_REGULATOR_VOLTAGE_SCALE2 only with AD SMPS */		
;;;1088     SMPS_status = HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE2);
;;;1089     if (SMPS_status != SMPS_OK)  
;;;1090     {
;;;1091       Error_Handler();
;;;1092     } 
;;;1093   
;;;1094   #ifndef NO_DELAY_TOWARDS_SMPS 
;;;1095     /* Insert 2 seconds delay */
;;;1096     HAL_Delay(2000);
;;;1097   #endif
;;;1098        
;;;1099     /********************************/
;;;1100     /* After reset                  */
;;;1101     /* 24 MHZ                       */		
;;;1102     /* PWR_REGULATOR_VOLTAGE_SCALE2 */
;;;1103     /* SMPS IS OFF                  */
;;;1104     /********************************/
;;;1105     /*             OR               */
;;;1106     /********************************/
;;;1107     /* Wake up from standby         */
;;;1108     /* 4 MHZ                        */		
;;;1109     /* PWR_REGULATOR_VOLTAGE_SCALE2 */
;;;1110     /* SMPS IS OFF                  */
;;;1111     /********************************/
;;;1112     
;;;1113     /* ------------------------------------------ */
;;;1114     
;;;1115     /* Enable SMPS */
;;;1116     /* Check of PG but not blocking */
;;;1117     SMPS_status = BSP_SMPS_Enable (0 , 1);  
;;;1118   
;;;1119   #ifdef NO_DELAY_TOWARDS_SMPS
;;;1120     while (SMPS_OK != BSP_SMPS_Supply_Enable (0,1))
;;;1121     {
;;;1122       counter++;
;;;1123     }   
;;;1124   #else
;;;1125     /* Check of Power Good */
;;;1126     SMPS_status = BSP_SMPS_Supply_Enable (10 , 1); 
;;;1127     
;;;1128     if (SMPS_status != SMPS_OK)
;;;1129     {
;;;1130       Error_Handler();
;;;1131     } 
;;;1132   #endif  
;;;1133     
;;;1134   #ifndef NO_DELAY_TOWARDS_SMPS 
;;;1135     /* Insert 1 second delay */
;;;1136     HAL_Delay(1000);
;;;1137   #endif
;;;1138   
;;;1139     /********************************/
;;;1140     /* After reset                  */
;;;1141     /* 24 MHZ                       */		
;;;1142     /* PWR_REGULATOR_VOLTAGE_SCALE2 */
;;;1143     /* SMPS IS ON                  */
;;;1144     /********************************/
;;;1145     /*             OR               */
;;;1146     /********************************/
;;;1147     /* Wake up from standby         */
;;;1148     /* 4 MHZ                        */		
;;;1149     /* PWR_REGULATOR_VOLTAGE_SCALE2 */
;;;1150     /* SMPS IS ON                  */
;;;1151     /********************************/
;;;1152     
;;;1153     /* ------------------------------------------ */
;;;1154     
;;;1155     SystemClock_Config_80MHz(); 
;;;1156      
;;;1157     /********************************/
;;;1158     /* 80 MHZ                       */		
;;;1159     /* PWR_REGULATOR_VOLTAGE_SCALE2 */
;;;1160     /* SMPS IS ON                  */
;;;1161     /********************************/
;;;1162     
;;;1163     /* ------------------------------------------ */
;;;1164     
;;;1165     /* Enable Power Clock */
;;;1166     __HAL_RCC_PWR_CLK_ENABLE();
;;;1167     
;;;1168     while (1)
;;;1169     {
;;;1170   
;;;1171     /* ------------------ GPIO ------------------ */
;;;1172       
;;;1173     /* Turn OFF LED's */
;;;1174     BSP_LED_Off(LED1);
;;;1175     BSP_LED_Off(LED2);
;;;1176   
;;;1177     /* Enable GPIOs clock */
;;;1178     __HAL_RCC_GPIOA_CLK_ENABLE();
;;;1179     __HAL_RCC_GPIOB_CLK_ENABLE();
;;;1180     __HAL_RCC_GPIOD_CLK_ENABLE();
;;;1181     __HAL_RCC_GPIOE_CLK_ENABLE();
;;;1182     __HAL_RCC_GPIOF_CLK_ENABLE();
;;;1183     __HAL_RCC_GPIOG_CLK_ENABLE();        
;;;1184     __HAL_RCC_GPIOH_CLK_ENABLE();
;;;1185     __HAL_RCC_GPIOI_CLK_ENABLE();
;;;1186   
;;;1187     /* Set all GPIO in analog state to reduce power consumption,                */
;;;1188     /*   except GPIOC to keep user button interrupt enabled                     */
;;;1189     /* Note: Debug using ST-Link is not possible during the execution of this   */
;;;1190     /*       example because communication between ST-link and the device       */
;;;1191     /*       under test is done through UART. All GPIO pins are disabled (set   */
;;;1192     /*       to analog input mode) including  UART I/O pins.                    */
;;;1193     GPIO_InitStructure.Pin = GPIO_PIN_All;
;;;1194     GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
;;;1195     GPIO_InitStructure.Pull = GPIO_NOPULL;
;;;1196   
;;;1197     HAL_GPIO_Init(GPIOA, &GPIO_InitStructure); 
;;;1198     HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;1199     HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;1200     HAL_GPIO_Init(GPIOD, &GPIO_InitStructure); 
;;;1201     HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
;;;1202     HAL_GPIO_Init(GPIOF, &GPIO_InitStructure); 
;;;1203     HAL_GPIO_Init(GPIOG, &GPIO_InitStructure); 
;;;1204     HAL_GPIO_Init(GPIOH, &GPIO_InitStructure);
;;;1205     HAL_GPIO_Init(GPIOI, &GPIO_InitStructure);
;;;1206    
;;;1207     /* Disable GPIOs clock */
;;;1208     __HAL_RCC_GPIOA_CLK_DISABLE();
;;;1209     __HAL_RCC_GPIOB_CLK_DISABLE();
;;;1210     __HAL_RCC_GPIOC_CLK_DISABLE();
;;;1211     __HAL_RCC_GPIOD_CLK_DISABLE();
;;;1212     __HAL_RCC_GPIOE_CLK_DISABLE();
;;;1213     __HAL_RCC_GPIOF_CLK_DISABLE();  
;;;1214     __HAL_RCC_GPIOG_CLK_DISABLE();  
;;;1215     __HAL_RCC_GPIOH_CLK_DISABLE();
;;;1216     __HAL_RCC_GPIOI_CLK_DISABLE();
;;;1217   
;;;1218     /* Wait that user release the User push-button */
;;;1219     while(BSP_PB_GetState(BUTTON_USER) == GPIO_PIN_SET){}
;;;1220       
;;;1221     /* Disable all used wakeup sources: WKUP pin */
;;;1222     HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN2);
;;;1223     
;;;1224     /* Clear wake up Flag */
;;;1225     __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WUF2);
;;;1226       
;;;1227     /* Enable wakeup pin WKUP2 */
;;;1228     HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN2_HIGH);  
;;;1229     
;;;1230     /* Insert 10 seconds delay */
;;;1231     HAL_Delay(10000);
;;;1232   
;;;1233     SystemClock_Config_24MHz();
;;;1234   
;;;1235     /* wait 100 ms */
;;;1236     HAL_Delay(100);
;;;1237     
;;;1238     BSP_SMPS_Supply_Disable();
;;;1239     
;;;1240     /* wait 100 ms */
;;;1241     HAL_Delay(100);
;;;1242     
;;;1243     BSP_SMPS_Disable(); 
;;;1244      
;;;1245     /* wait 100 ms */
;;;1246     HAL_Delay(100);
;;;1247     
;;;1248     /* NO NEED OF                                                 */
;;;1249     /* HAL_PWREx_EnableGPIOPullUp (PWR_GPIO_SMPS, PWR_GPIO_ENABLE */
;;;1250     /* HAL_PWREx_EnablePullUpPullDownConfig();                    */
;;;1251     /* AS DONE IN BSP_SMPS_Enable                                 */ 
;;;1252    
;;;1253     /* Enter STANDBY mode */
;;;1254     HAL_PWR_EnterSTANDBYMode();
;;;1255      
;;;1256     /* ... STANDBY mode ... */    
;;;1257     }
;;;1258     #endif
;;;1259   }
;;;1260   
                          ENDP

                  |L18.1724|
                          DCD      ||area_number.28||+0xd
                  |L18.1728|
0006c0  1b5b313b          DCB      27,"[1;32m",0
0006c4  33326d00
                  |L18.1736|
0006c8  25732573          DCB      "%s%sBMU CHK#%04d N=%d,S=%d,Ring=%d\r\n%s",0
0006cc  424d5520
0006d0  43484b23
0006d4  25303464
0006d8  204e3d25
0006dc  642c533d
0006e0  25642c52
0006e4  696e673d
0006e8  25640d0a
0006ec  257300  
0006ef  00                DCB      0
                  |L18.1776|
                          DCD      app_irm_sw_gpio_init_cb
                  |L18.1780|
                          DCD      ||area_number.23||+0xb4
                  |L18.1784|
                          DCD      app_irm_sw1_gpio
                  |L18.1788|
                          DCD      app_irm_sw2_gpio
                  |L18.1792|
                          DCD      app_irm_sw3_gpio
                  |L18.1796|
                          DCD      app_irm_get_device_init_cb
                  |L18.1800|
                          DCD      app_irm_trigger_voltage_data_cb
                  |L18.1804|
                          DCD      app_irm_rxdata_cb
                  |L18.1808|
                          DCD      irm_data_ready_cb
                  |L18.1812|
                          DCD      app_flash_log_event_handler
                  |L18.1816|
000718  1b5b313b          DCB      27,"[1;37m",0
00071c  33376d00
                  |L18.1824|
000720  25732573          DCB      "%s%sEvent log#%d transfer\r\n%s",0
000724  4576656e
000728  74206c6f
00072c  67232564
000730  20747261
000734  6e736665
000738  720d0a25
00073c  7300    
00073e  00                DCB      0
00073f  00                DCB      0

                          AREA ||i.smp_DMA_Init||, CODE, READONLY, ALIGN=2

                  smp_DMA_Init PROC
;;;284    
;;;285    static void smp_DMA_Init(void)
000000  b508              PUSH     {r3,lr}
;;;286    {
;;;287    	/* DMA controller clock enable */
;;;288    	BSP_SPI1_DMAx_CLK_ENABLE();
000002  4825              LDR      r0,|L19.152|
000004  6c81              LDR      r1,[r0,#0x48]
000006  f0410101          ORR      r1,r1,#1
00000a  6481              STR      r1,[r0,#0x48]
00000c  6c81              LDR      r1,[r0,#0x48]
00000e  f0010101          AND      r1,r1,#1
000012  9100              STR      r1,[sp,#0]
;;;289    	BSP_SPI2_DMAx_CLK_ENABLE();
000014  6c81              LDR      r1,[r0,#0x48]
000016  f0410101          ORR      r1,r1,#1
00001a  6481              STR      r1,[r0,#0x48]
00001c  6c81              LDR      r1,[r0,#0x48]
00001e  f0010101          AND      r1,r1,#1
000022  9100              STR      r1,[sp,#0]
;;;290    	BSP_SPI3_DMAx_CLK_ENABLE();
000024  6c81              LDR      r1,[r0,#0x48]
000026  f0410102          ORR      r1,r1,#2
00002a  6481              STR      r1,[r0,#0x48]
00002c  6c80              LDR      r0,[r0,#0x48]
00002e  f0000002          AND      r0,r0,#2
000032  9000              STR      r0,[sp,#0]
;;;291    	/* DMA interrupt init */
;;;292    	/* DMA1_Channel2_IRQn interrupt configuration */
;;;293    	HAL_NVIC_SetPriority(BSP_SPI1_DMA_RX_IRQn, 0, 0);
000034  2200              MOVS     r2,#0
000036  4611              MOV      r1,r2
000038  200c              MOVS     r0,#0xc
00003a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;294    	HAL_NVIC_EnableIRQ(BSP_SPI1_DMA_RX_IRQn);
00003e  200c              MOVS     r0,#0xc
000040  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;295    	/* DMA1_Channel3_IRQn interrupt configuration */
;;;296    	HAL_NVIC_SetPriority(BSP_SPI1_DMA_TX_IRQn, 0, 0);
000044  2200              MOVS     r2,#0
000046  4611              MOV      r1,r2
000048  200d              MOVS     r0,#0xd
00004a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;297    	HAL_NVIC_EnableIRQ(BSP_SPI1_DMA_TX_IRQn);
00004e  200d              MOVS     r0,#0xd
000050  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;298    	/* DMA1_Channel4_IRQn interrupt configuration */
;;;299    	HAL_NVIC_SetPriority(BSP_SPI2_DMA_RX_IRQn, 0, 0);
000054  2200              MOVS     r2,#0
000056  4611              MOV      r1,r2
000058  200e              MOVS     r0,#0xe
00005a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;300    	HAL_NVIC_EnableIRQ(BSP_SPI2_DMA_RX_IRQn);
00005e  200e              MOVS     r0,#0xe
000060  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;301    	/* DMA1_Channel5_IRQn interrupt configuration */
;;;302    	HAL_NVIC_SetPriority(BSP_SPI2_DMA_TX_IRQn, 0, 0);
000064  2200              MOVS     r2,#0
000066  4611              MOV      r1,r2
000068  200f              MOVS     r0,#0xf
00006a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;303    	HAL_NVIC_EnableIRQ(BSP_SPI2_DMA_TX_IRQn);
00006e  200f              MOVS     r0,#0xf
000070  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;304    	/* DMA2_Channel1_IRQn interrupt configuration */
;;;305    	HAL_NVIC_SetPriority(BSP_SPI3_DMA_RX_IRQn, 0, 0);
000074  2200              MOVS     r2,#0
000076  4611              MOV      r1,r2
000078  2038              MOVS     r0,#0x38
00007a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;306    	HAL_NVIC_EnableIRQ(BSP_SPI3_DMA_RX_IRQn);
00007e  2038              MOVS     r0,#0x38
000080  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;307    	/* DMA2_Channel2_IRQn interrupt configuration */
;;;308    	HAL_NVIC_SetPriority(BSP_SPI3_DMA_TX_IRQn, 0, 0);
000084  2200              MOVS     r2,#0
000086  4611              MOV      r1,r2
000088  2039              MOVS     r0,#0x39
00008a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;309    	HAL_NVIC_EnableIRQ(BSP_SPI3_DMA_TX_IRQn);
00008e  e8bd4008          POP      {r3,lr}
000092  2039              MOVS     r0,#0x39
000094  f7ffbffe          B.W      HAL_NVIC_EnableIRQ
;;;310    
;;;311    }
;;;312    
                          ENDP

                  |L19.152|
                          DCD      0x40021000

                          AREA ||i.test_uart_rx_process||, CODE, READONLY, ALIGN=2

                  test_uart_rx_process PROC
;;;436    uint16_t kk = 0;
;;;437    void test_uart_rx_process(void)
000000  b538              PUSH     {r3-r5,lr}
;;;438    {
;;;439    static uint8_t rx_data = 0;
;;;440    static int8_t fifo_res;
;;;441    	
;;;442    	if(Davinci_uart_rx_cnt>0){
000002  4c25              LDR      r4,|L20.152|
000004  8820              LDRH     r0,[r4,#0]  ; Davinci_uart_rx_cnt
000006  2800              CMP      r0,#0
000008  d044              BEQ      |L20.148|
;;;443    		fifo_res = smp_uart_get(&mDavinci_uart, &rx_data);
00000a  4924              LDR      r1,|L20.156|
00000c  4824              LDR      r0,|L20.160|
00000e  f7fffffe          BL       smp_uart_get
000012  4922              LDR      r1,|L20.156|
000014  3908              SUBS     r1,r1,#8
000016  7248              STRB     r0,[r1,#9]
;;;444    		--Davinci_uart_rx_cnt;
000018  8822              LDRH     r2,[r4,#0]  ; Davinci_uart_rx_cnt
00001a  1e52              SUBS     r2,r2,#1
00001c  8022              STRH     r2,[r4,#0]
;;;445    		if(fifo_res == SMP_SUCCESS)
00001e  2800              CMP      r0,#0
000020  d138              BNE      |L20.148|
;;;446    		{	
;;;447          switch(rx_data){
000022  7a08              LDRB     r0,[r1,#8]  ; rx_data
000024  2841              CMP      r0,#0x41
000026  d011              BEQ      |L20.76|
000028  2842              CMP      r0,#0x42
00002a  d01b              BEQ      |L20.100|
00002c  2843              CMP      r0,#0x43
00002e  d025              BEQ      |L20.124|
000030  2844              CMP      r0,#0x44
000032  d12f              BNE      |L20.148|
;;;448    			case 'A':	
;;;449    				LOG_YELLOW("EVENT_LOG Clean ALL Memory\r\n");
;;;450    				app_flash_log_managment_clean_all_memory();
;;;451    			  break; 
;;;452    			case 'B':
;;;453    				LOG_YELLOW("EVENT_LOG Clean REFLASH Memory\r\n");
;;;454    				app_flash_log_managment_clean_reflash_memory();
;;;455    			  break;
;;;456    			case 'C':		
;;;457    				LOG_YELLOW("EVENT_LOG Clean FIX Memory\r\n");
;;;458    				app_flash_log_managment_clean_fix_memory();
;;;459    			  break;
;;;460    			case 'D':
;;;461    				LOG_YELLOW("EVENT_LOG Clean HEAD\r\n");
000034  a01b              ADR      r0,|L20.164|
000036  9000              STR      r0,[sp,#0]
000038  a31b              ADR      r3,|L20.168|
00003a  a21c              ADR      r2,|L20.172|
00003c  a11d              ADR      r1,|L20.180|
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       SEGGER_RTT_printf
;;;462    				app_flash_log_managment_clean_head();
000044  e8bd4038          POP      {r3-r5,lr}
000048  f7ffbffe          B.W      app_flash_log_managment_clean_head
                  |L20.76|
00004c  a015              ADR      r0,|L20.164|
00004e  9000              STR      r0,[sp,#0]            ;449
000050  a315              ADR      r3,|L20.168|
000052  a216              ADR      r2,|L20.172|
000054  a11f              ADR      r1,|L20.212|
000056  2000              MOVS     r0,#0                 ;449
000058  f7fffffe          BL       SEGGER_RTT_printf
00005c  e8bd4038          POP      {r3-r5,lr}            ;450
000060  f7ffbffe          B.W      app_flash_log_managment_clean_all_memory
                  |L20.100|
000064  a00f              ADR      r0,|L20.164|
000066  9000              STR      r0,[sp,#0]            ;453
000068  a30f              ADR      r3,|L20.168|
00006a  a210              ADR      r2,|L20.172|
00006c  a122              ADR      r1,|L20.248|
00006e  2000              MOVS     r0,#0                 ;453
000070  f7fffffe          BL       SEGGER_RTT_printf
000074  e8bd4038          POP      {r3-r5,lr}            ;454
000078  f7ffbffe          B.W      app_flash_log_managment_clean_reflash_memory
                  |L20.124|
00007c  a009              ADR      r0,|L20.164|
00007e  9000              STR      r0,[sp,#0]            ;457
000080  a309              ADR      r3,|L20.168|
000082  a20a              ADR      r2,|L20.172|
000084  a126              ADR      r1,|L20.288|
000086  2000              MOVS     r0,#0                 ;457
000088  f7fffffe          BL       SEGGER_RTT_printf
00008c  e8bd4038          POP      {r3-r5,lr}            ;458
000090  f7ffbffe          B.W      app_flash_log_managment_clean_fix_memory
                  |L20.148|
;;;463    			  break;
;;;464    		  }
;;;465    		}
;;;466    	}
;;;467    }
000094  bd38              POP      {r3-r5,pc}
;;;468    
                          ENDP

000096  0000              DCW      0x0000
                  |L20.152|
                          DCD      Davinci_uart_rx_cnt
                  |L20.156|
                          DCD      ||area_number.28||+0x8
                  |L20.160|
                          DCD      mDavinci_uart
                  |L20.164|
0000a4  1b5b306d          DCB      27,"[0m"
                  |L20.168|
0000a8  00                DCB      0
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L20.172|
0000ac  1b5b313b          DCB      27,"[1;33m",0
0000b0  33336d00
                  |L20.180|
0000b4  25732573          DCB      "%s%sEVENT_LOG Clean HEAD\r\n%s",0
0000b8  4556454e
0000bc  545f4c4f
0000c0  4720436c
0000c4  65616e20
0000c8  48454144
0000cc  0d0a2573
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L20.212|
0000d4  25732573          DCB      "%s%sEVENT_LOG Clean ALL Memory\r\n%s",0
0000d8  4556454e
0000dc  545f4c4f
0000e0  4720436c
0000e4  65616e20
0000e8  414c4c20
0000ec  4d656d6f
0000f0  72790d0a
0000f4  257300  
0000f7  00                DCB      0
                  |L20.248|
0000f8  25732573          DCB      "%s%sEVENT_LOG Clean REFLASH Memory\r\n%s",0
0000fc  4556454e
000100  545f4c4f
000104  4720436c
000108  65616e20
00010c  5245464c
000110  41534820
000114  4d656d6f
000118  72790d0a
00011c  257300  
00011f  00                DCB      0
                  |L20.288|
000120  25732573          DCB      "%s%sEVENT_LOG Clean FIX Memory\r\n%s",0
000124  4556454e
000128  545f4c4f
00012c  4720436c
000130  65616e20
000134  46495820
000138  4d656d6f
00013c  72790d0a
000140  257300  
000143  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  app_adc_temp
                          %        10

                          AREA ||area_number.23||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.bss||
                  test_init_rec_bmu_num
                          %        160
                  |symbol_number.73|
                          %        20
                  app_irm_event_cb
                          %        32
                  header_package
                          %        16
                  page_data_buffer
                          %        256

                          AREA ||.data||, DATA, ALIGN=0

                  num
000000  00                DCB      0x00

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  d_payload
000000  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||area_number.27||, DATA, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.data||
                  null_payload
000000  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||area_number.28||, DATA, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.data||
                  north_res
000000  00                DCB      0x00
                  south_res
000001  00                DCB      0x00
                  dir_res
000002  00                DCB      0x00
                  ns_bmu_cnt
000003  00                DCB      0x00
                  bmu_is_ring
000004  00                DCB      0x00
                  ns_recheck_cnt
000005  00                DCB      0x00
                  wake_cnt
000006  00                DCB      0x00
                  ||res||
000007  00                DCB      0x00
                  rx_data
000008  00                DCB      0x00
                  fifo_res
000009  00                DCB      0x00
                  |symbol_number.210|
00000a  00                DCB      0x00
                  dir_afe_steps
00000b  00                DCB      0x00
                  dir_step_com_f
00000c  00                DCB      0x00
                  dir_before_d_ms
00000d  00                DCB      0x00
                  dir_cnt_delay
00000e  00                DCB      0x00
                  dir_state
00000f  00                DCB      0x00
                  test_cont
000010  0000              DCW      0x0000
                  dir_bq_count_temp
000012  0000              DCB      0x00,0x00
                  button_pressed
                          DCD      0x00000000
                  irm_fun_ptr
                          DCD      0x00000000
                  temp_irm_vstack
                          DCD      0x00000000
                  volt_data
                          DCD      0x00000000
                  adc_bits
                          DCD      0x00000000
                  TimingDelay
                          DCD      0x00000000
                  test_dir_ok
                          DCD      0x00000000
                          DCD      0x00000000
                  test_dir_fail
                          DCD      0x00000000
                          DCD      0x00000000
                  temp_irm_data
                          %        8

                          AREA ||area_number.29||, DATA, ALIGN=0

                          EXPORTAS ||area_number.29||, ||.data||
                  bmu_dir
000000  00                DCB      0x00

                          AREA ||area_number.30||, DATA, ALIGN=1

                          EXPORTAS ||area_number.30||, ||.data||
                  bmu_dir_cnt
000000  0000              DCW      0x0000

                          AREA ||area_number.31||, DATA, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.data||
                  irm_get_vstack_cont
                          DCD      0x00000000

                          AREA ||area_number.32||, DATA, ALIGN=1

                          EXPORTAS ||area_number.32||, ||.data||
                  ||kk||
000000  0000              DCW      0x0000

                          AREA ||area_number.33||, DATA, ALIGN=0

                          EXPORTAS ||area_number.33||, ||.data||
                  cb_en1
000000  00                DCB      0x00

                          AREA ||area_number.34||, DATA, ALIGN=0

                          EXPORTAS ||area_number.34||, ||.data||
                  cb_en2
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_num____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___6_main_c_num____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_num____REVSH|
#line 507
|__asm___6_main_c_num____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_num____RRX|
#line 694
|__asm___6_main_c_num____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
