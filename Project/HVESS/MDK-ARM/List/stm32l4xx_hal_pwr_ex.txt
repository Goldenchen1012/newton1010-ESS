; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_pwr_ex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_pwr_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ConfigPVM||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ConfigPVM PROC
;;;967      */
;;;968    HAL_StatusTypeDef HAL_PWREx_ConfigPVM(PWR_PVMTypeDef *sConfigPVM)
000000  b570              PUSH     {r4-r6,lr}
;;;969    {
;;;970      HAL_StatusTypeDef status = HAL_OK;
000002  2200              MOVS     r2,#0
;;;971    
;;;972      /* Check the parameters */
;;;973      assert_param(IS_PWR_PVM_TYPE(sConfigPVM->PVMType));
;;;974      assert_param(IS_PWR_PVM_MODE(sConfigPVM->Mode));
;;;975    
;;;976    
;;;977      /* Configure EXTI 35 to 38 interrupts if so required:
;;;978         scan thru PVMType to detect which PVMx is set and
;;;979         configure the corresponding EXTI line accordingly. */
;;;980      switch (sConfigPVM->PVMType)
;;;981      {
;;;982    #if defined(PWR_CR2_PVME1)
;;;983        case PWR_PVM_1:
;;;984          /* Clear any previous config. Keep it clear if no event or IT mode is selected */
;;;985          __HAL_PWR_PVM1_EXTI_DISABLE_EVENT();
000004  4b63              LDR      r3,|L1.404|
;;;986          __HAL_PWR_PVM1_EXTI_DISABLE_IT();
;;;987          __HAL_PWR_PVM1_EXTI_DISABLE_FALLING_EDGE();
000006  4d63              LDR      r5,|L1.404|
000008  6801              LDR      r1,[r0,#0]            ;980
00000a  1f1e              SUBS     r6,r3,#4              ;986
00000c  3508              ADDS     r5,r5,#8
;;;988          __HAL_PWR_PVM1_EXTI_DISABLE_RISING_EDGE();
00000e  1d1c              ADDS     r4,r3,#4
000010  2910              CMP      r1,#0x10              ;980
000012  d008              BEQ      |L1.38|
000014  2920              CMP      r1,#0x20              ;980
000016  d033              BEQ      |L1.128|
000018  2940              CMP      r1,#0x40              ;980
00001a  d05e              BEQ      |L1.218|
00001c  2980              CMP      r1,#0x80              ;980
00001e  d07d              BEQ      |L1.284|
;;;989    
;;;990          /* Configure interrupt mode */
;;;991          if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
;;;992          {
;;;993            __HAL_PWR_PVM1_EXTI_ENABLE_IT();
;;;994          }
;;;995    
;;;996          /* Configure event mode */
;;;997          if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
;;;998          {
;;;999            __HAL_PWR_PVM1_EXTI_ENABLE_EVENT();
;;;1000         }
;;;1001   
;;;1002         /* Configure the edge */
;;;1003         if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
;;;1004         {
;;;1005           __HAL_PWR_PVM1_EXTI_ENABLE_RISING_EDGE();
;;;1006         }
;;;1007   
;;;1008         if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
;;;1009         {
;;;1010           __HAL_PWR_PVM1_EXTI_ENABLE_FALLING_EDGE();
;;;1011         }
;;;1012         break;
;;;1013   #endif /* PWR_CR2_PVME1 */
;;;1014   
;;;1015   #if defined(PWR_CR2_PVME2)
;;;1016       case PWR_PVM_2:
;;;1017         /* Clear any previous config. Keep it clear if no event or IT mode is selected */
;;;1018         __HAL_PWR_PVM2_EXTI_DISABLE_EVENT();
;;;1019         __HAL_PWR_PVM2_EXTI_DISABLE_IT();
;;;1020         __HAL_PWR_PVM2_EXTI_DISABLE_FALLING_EDGE();
;;;1021         __HAL_PWR_PVM2_EXTI_DISABLE_RISING_EDGE();
;;;1022   
;;;1023         /* Configure interrupt mode */
;;;1024         if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
;;;1025         {
;;;1026           __HAL_PWR_PVM2_EXTI_ENABLE_IT();
;;;1027         }
;;;1028   
;;;1029         /* Configure event mode */
;;;1030         if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
;;;1031         {
;;;1032           __HAL_PWR_PVM2_EXTI_ENABLE_EVENT();
;;;1033         }
;;;1034   
;;;1035         /* Configure the edge */
;;;1036         if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
;;;1037         {
;;;1038           __HAL_PWR_PVM2_EXTI_ENABLE_RISING_EDGE();
;;;1039         }
;;;1040   
;;;1041         if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
;;;1042         {
;;;1043           __HAL_PWR_PVM2_EXTI_ENABLE_FALLING_EDGE();
;;;1044         }
;;;1045         break;
;;;1046   #endif /* PWR_CR2_PVME2 */
;;;1047   
;;;1048       case PWR_PVM_3:
;;;1049         /* Clear any previous config. Keep it clear if no event or IT mode is selected */
;;;1050         __HAL_PWR_PVM3_EXTI_DISABLE_EVENT();
;;;1051         __HAL_PWR_PVM3_EXTI_DISABLE_IT();
;;;1052         __HAL_PWR_PVM3_EXTI_DISABLE_FALLING_EDGE();
;;;1053         __HAL_PWR_PVM3_EXTI_DISABLE_RISING_EDGE();
;;;1054   
;;;1055         /* Configure interrupt mode */
;;;1056         if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
;;;1057         {
;;;1058           __HAL_PWR_PVM3_EXTI_ENABLE_IT();
;;;1059         }
;;;1060   
;;;1061         /* Configure event mode */
;;;1062         if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
;;;1063         {
;;;1064           __HAL_PWR_PVM3_EXTI_ENABLE_EVENT();
;;;1065         }
;;;1066   
;;;1067         /* Configure the edge */
;;;1068         if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
;;;1069         {
;;;1070           __HAL_PWR_PVM3_EXTI_ENABLE_RISING_EDGE();
;;;1071         }
;;;1072   
;;;1073         if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
;;;1074         {
;;;1075           __HAL_PWR_PVM3_EXTI_ENABLE_FALLING_EDGE();
;;;1076         }
;;;1077         break;
;;;1078   
;;;1079       case PWR_PVM_4:
;;;1080         /* Clear any previous config. Keep it clear if no event or IT mode is selected */
;;;1081         __HAL_PWR_PVM4_EXTI_DISABLE_EVENT();
;;;1082         __HAL_PWR_PVM4_EXTI_DISABLE_IT();
;;;1083         __HAL_PWR_PVM4_EXTI_DISABLE_FALLING_EDGE();
;;;1084         __HAL_PWR_PVM4_EXTI_DISABLE_RISING_EDGE();
;;;1085   
;;;1086         /* Configure interrupt mode */
;;;1087         if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
;;;1088         {
;;;1089           __HAL_PWR_PVM4_EXTI_ENABLE_IT();
;;;1090         }
;;;1091   
;;;1092         /* Configure event mode */
;;;1093         if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
;;;1094         {
;;;1095           __HAL_PWR_PVM4_EXTI_ENABLE_EVENT();
;;;1096         }
;;;1097   
;;;1098         /* Configure the edge */
;;;1099         if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
;;;1100         {
;;;1101           __HAL_PWR_PVM4_EXTI_ENABLE_RISING_EDGE();
;;;1102         }
;;;1103   
;;;1104         if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
;;;1105         {
;;;1106           __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
;;;1107         }
;;;1108         break;
;;;1109   
;;;1110       default:
;;;1111         status = HAL_ERROR;
000020  2201              MOVS     r2,#1
                  |L1.34|
;;;1112         break;
;;;1113     }
;;;1114   
;;;1115     return status;
000022  4610              MOV      r0,r2
;;;1116   }
000024  bd70              POP      {r4-r6,pc}
                  |L1.38|
000026  6819              LDR      r1,[r3,#0]            ;985
000028  f0210108          BIC      r1,r1,#8              ;985
00002c  6019              STR      r1,[r3,#0]            ;985
00002e  6831              LDR      r1,[r6,#0]            ;986
000030  f0210108          BIC      r1,r1,#8              ;986
000034  6031              STR      r1,[r6,#0]            ;986
000036  6829              LDR      r1,[r5,#0]            ;987
000038  f0210108          BIC      r1,r1,#8              ;987
00003c  6029              STR      r1,[r5,#0]            ;987
00003e  6821              LDR      r1,[r4,#0]            ;988
000040  f0210108          BIC      r1,r1,#8              ;988
000044  6021              STR      r1,[r4,#0]            ;988
000046  6841              LDR      r1,[r0,#4]            ;991
000048  03c9              LSLS     r1,r1,#15             ;991
00004a  d503              BPL      |L1.84|
00004c  6831              LDR      r1,[r6,#0]            ;993
00004e  f0410108          ORR      r1,r1,#8              ;993
000052  6031              STR      r1,[r6,#0]            ;993
                  |L1.84|
000054  6841              LDR      r1,[r0,#4]            ;997
000056  0389              LSLS     r1,r1,#14             ;997
000058  d503              BPL      |L1.98|
00005a  6819              LDR      r1,[r3,#0]            ;999
00005c  f0410108          ORR      r1,r1,#8              ;999
000060  6019              STR      r1,[r3,#0]            ;999
                  |L1.98|
000062  7901              LDRB     r1,[r0,#4]            ;1003
000064  07c9              LSLS     r1,r1,#31             ;1003
000066  d003              BEQ      |L1.112|
000068  6821              LDR      r1,[r4,#0]            ;1005
00006a  f0410108          ORR      r1,r1,#8              ;1005
00006e  6021              STR      r1,[r4,#0]            ;1005
                  |L1.112|
000070  7900              LDRB     r0,[r0,#4]            ;1008
000072  0780              LSLS     r0,r0,#30             ;1008
000074  d5d5              BPL      |L1.34|
000076  6828              LDR      r0,[r5,#0]            ;1010
000078  f0400008          ORR      r0,r0,#8              ;1010
00007c  6028              STR      r0,[r5,#0]            ;1010
                  |L1.126|
00007e  e7d0              B        |L1.34|
                  |L1.128|
000080  6819              LDR      r1,[r3,#0]            ;1018
000082  f0210110          BIC      r1,r1,#0x10           ;1018
000086  6019              STR      r1,[r3,#0]            ;1018
000088  6831              LDR      r1,[r6,#0]            ;1019
00008a  f0210110          BIC      r1,r1,#0x10           ;1019
00008e  6031              STR      r1,[r6,#0]            ;1019
000090  6829              LDR      r1,[r5,#0]            ;1020
000092  f0210110          BIC      r1,r1,#0x10           ;1020
000096  6029              STR      r1,[r5,#0]            ;1020
000098  6821              LDR      r1,[r4,#0]            ;1021
00009a  f0210110          BIC      r1,r1,#0x10           ;1021
00009e  6021              STR      r1,[r4,#0]            ;1021
0000a0  6841              LDR      r1,[r0,#4]            ;1024
0000a2  03c9              LSLS     r1,r1,#15             ;1024
0000a4  d503              BPL      |L1.174|
0000a6  6831              LDR      r1,[r6,#0]            ;1026
0000a8  f0410110          ORR      r1,r1,#0x10           ;1026
0000ac  6031              STR      r1,[r6,#0]            ;1026
                  |L1.174|
0000ae  6841              LDR      r1,[r0,#4]            ;1030
0000b0  0389              LSLS     r1,r1,#14             ;1030
0000b2  d503              BPL      |L1.188|
0000b4  6819              LDR      r1,[r3,#0]            ;1032
0000b6  f0410110          ORR      r1,r1,#0x10           ;1032
0000ba  6019              STR      r1,[r3,#0]            ;1032
                  |L1.188|
0000bc  7901              LDRB     r1,[r0,#4]            ;1036
0000be  07c9              LSLS     r1,r1,#31             ;1036
0000c0  d003              BEQ      |L1.202|
0000c2  6821              LDR      r1,[r4,#0]            ;1038
0000c4  f0410110          ORR      r1,r1,#0x10           ;1038
0000c8  6021              STR      r1,[r4,#0]            ;1038
                  |L1.202|
0000ca  7900              LDRB     r0,[r0,#4]            ;1041
0000cc  0780              LSLS     r0,r0,#30             ;1041
0000ce  d5a8              BPL      |L1.34|
0000d0  6828              LDR      r0,[r5,#0]            ;1043
0000d2  f0400010          ORR      r0,r0,#0x10           ;1043
0000d6  6028              STR      r0,[r5,#0]            ;1043
                  |L1.216|
0000d8  e7a3              B        |L1.34|
                  |L1.218|
0000da  6819              LDR      r1,[r3,#0]            ;1050
0000dc  f0210120          BIC      r1,r1,#0x20           ;1050
0000e0  6019              STR      r1,[r3,#0]            ;1050
0000e2  6831              LDR      r1,[r6,#0]            ;1051
0000e4  f0210120          BIC      r1,r1,#0x20           ;1051
0000e8  6031              STR      r1,[r6,#0]            ;1051
0000ea  6829              LDR      r1,[r5,#0]            ;1052
0000ec  f0210120          BIC      r1,r1,#0x20           ;1052
0000f0  6029              STR      r1,[r5,#0]            ;1052
0000f2  6821              LDR      r1,[r4,#0]            ;1053
0000f4  f0210120          BIC      r1,r1,#0x20           ;1053
0000f8  6021              STR      r1,[r4,#0]            ;1053
0000fa  6841              LDR      r1,[r0,#4]            ;1056
0000fc  03c9              LSLS     r1,r1,#15             ;1056
0000fe  d503              BPL      |L1.264|
000100  6831              LDR      r1,[r6,#0]            ;1058
000102  f0410120          ORR      r1,r1,#0x20           ;1058
000106  6031              STR      r1,[r6,#0]            ;1058
                  |L1.264|
000108  6841              LDR      r1,[r0,#4]            ;1062
00010a  0389              LSLS     r1,r1,#14             ;1062
00010c  d503              BPL      |L1.278|
00010e  6819              LDR      r1,[r3,#0]            ;1064
000110  f0410120          ORR      r1,r1,#0x20           ;1064
000114  6019              STR      r1,[r3,#0]            ;1064
                  |L1.278|
000116  7901              LDRB     r1,[r0,#4]            ;1068
000118  07c9              LSLS     r1,r1,#31             ;1068
00011a  e000              B        |L1.286|
                  |L1.284|
00011c  e00c              B        |L1.312|
                  |L1.286|
00011e  d003              BEQ      |L1.296|
000120  6821              LDR      r1,[r4,#0]            ;1070
000122  f0410120          ORR      r1,r1,#0x20           ;1070
000126  6021              STR      r1,[r4,#0]            ;1070
                  |L1.296|
000128  7900              LDRB     r0,[r0,#4]            ;1073
00012a  0780              LSLS     r0,r0,#30             ;1073
00012c  d5a7              BPL      |L1.126|
00012e  6828              LDR      r0,[r5,#0]            ;1075
000130  f0400020          ORR      r0,r0,#0x20           ;1075
000134  6028              STR      r0,[r5,#0]            ;1075
000136  e774              B        |L1.34|
                  |L1.312|
000138  6819              LDR      r1,[r3,#0]            ;1081
00013a  f0210140          BIC      r1,r1,#0x40           ;1081
00013e  6019              STR      r1,[r3,#0]            ;1081
000140  6831              LDR      r1,[r6,#0]            ;1082
000142  f0210140          BIC      r1,r1,#0x40           ;1082
000146  6031              STR      r1,[r6,#0]            ;1082
000148  6829              LDR      r1,[r5,#0]            ;1083
00014a  f0210140          BIC      r1,r1,#0x40           ;1083
00014e  6029              STR      r1,[r5,#0]            ;1083
000150  6821              LDR      r1,[r4,#0]            ;1084
000152  f0210140          BIC      r1,r1,#0x40           ;1084
000156  6021              STR      r1,[r4,#0]            ;1084
000158  6841              LDR      r1,[r0,#4]            ;1087
00015a  03c9              LSLS     r1,r1,#15             ;1087
00015c  d503              BPL      |L1.358|
00015e  6831              LDR      r1,[r6,#0]            ;1089
000160  f0410140          ORR      r1,r1,#0x40           ;1089
000164  6031              STR      r1,[r6,#0]            ;1089
                  |L1.358|
000166  6841              LDR      r1,[r0,#4]            ;1093
000168  0389              LSLS     r1,r1,#14             ;1093
00016a  d503              BPL      |L1.372|
00016c  6819              LDR      r1,[r3,#0]            ;1095
00016e  f0410140          ORR      r1,r1,#0x40           ;1095
000172  6019              STR      r1,[r3,#0]            ;1095
                  |L1.372|
000174  7901              LDRB     r1,[r0,#4]            ;1099
000176  07c9              LSLS     r1,r1,#31             ;1099
000178  d003              BEQ      |L1.386|
00017a  6821              LDR      r1,[r4,#0]            ;1101
00017c  f0410140          ORR      r1,r1,#0x40           ;1101
000180  6021              STR      r1,[r4,#0]            ;1101
                  |L1.386|
000182  7900              LDRB     r0,[r0,#4]            ;1104
000184  0780              LSLS     r0,r0,#30             ;1104
000186  d5a7              BPL      |L1.216|
000188  6828              LDR      r0,[r5,#0]            ;1106
00018a  f0400040          ORR      r0,r0,#0x40           ;1106
00018e  6028              STR      r0,[r5,#0]            ;1106
000190  e747              B        |L1.34|
;;;1117   
                          ENDP

000192  0000              DCW      0x0000
                  |L1.404|
                          DCD      0x40010424

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;163      */
;;;164    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  4917              LDR      r1,|L2.96|
;;;165    {
;;;166      uint32_t wait_loop_index;
;;;167    
;;;168      assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
;;;169    
;;;170    #if defined(PWR_CR5_R1MODE)
;;;171      if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
;;;172      {
;;;173        /* If current range is range 2 */
;;;174        if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
;;;175        {
;;;176          /* Make sure Range 1 Boost is enabled */
;;;177          CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
;;;178    
;;;179          /* Set Range 1 */
;;;180          MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
;;;181    
;;;182          /* Wait until VOSF is cleared */
;;;183          wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
;;;184          while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
;;;185          {
;;;186            wait_loop_index--;
;;;187          }
;;;188          if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
;;;189          {
;;;190            return HAL_TIMEOUT;
;;;191          }
;;;192        }
;;;193        /* If current range is range 1 normal or boost mode */
;;;194        else
;;;195        {
;;;196          /* Enable Range 1 Boost (no issue if bit already reset) */
;;;197          CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
;;;198        }
;;;199      }
;;;200      else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
;;;201      {
;;;202        /* If current range is range 2 */
;;;203        if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
;;;204        {
;;;205          /* Make sure Range 1 Boost is disabled */
;;;206          SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
;;;207    
;;;208          /* Set Range 1 */
;;;209          MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
;;;210    
;;;211          /* Wait until VOSF is cleared */
;;;212          wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
;;;213          while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
;;;214          {
;;;215            wait_loop_index--;
;;;216          }
;;;217          if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
;;;218          {
;;;219            return HAL_TIMEOUT;
;;;220          }
;;;221        }
;;;222         /* If current range is range 1 normal or boost mode */
;;;223        else
;;;224        {
;;;225          /* Disable Range 1 Boost (no issue if bit already set) */
;;;226          SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
;;;227        }
;;;228      }
;;;229      else
;;;230      {
;;;231        /* Set Range 2 */
;;;232        MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
;;;233        /* No need to wait for VOSF to be cleared for this transition */
;;;234        /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
;;;235      }
;;;236    
;;;237    #else
;;;238    
;;;239      /* If Set Range 1 */
;;;240      if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
000002  f5b07f00          CMP      r0,#0x200
000006  d00c              BEQ      |L2.34|
;;;241      {
;;;242        if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
;;;243        {
;;;244          /* Set Range 1 */
;;;245          MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
;;;246    
;;;247          /* Wait until VOSF is cleared */
;;;248          wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
;;;249          while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
;;;250          {
;;;251            wait_loop_index--;
;;;252          }
;;;253          if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
;;;254          {
;;;255            return HAL_TIMEOUT;
;;;256          }
;;;257        }
;;;258      }
;;;259      else
;;;260      {
;;;261        if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
000008  6808              LDR      r0,[r1,#0]
00000a  f3c02041          UBFX     r0,r0,#9,#2
00000e  2802              CMP      r0,#2
000010  d005              BEQ      |L2.30|
;;;262        {
;;;263          /* Set Range 2 */
;;;264          MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
000012  6808              LDR      r0,[r1,#0]
000014  f42060c0          BIC      r0,r0,#0x600
000018  f4406080          ORR      r0,r0,#0x400
00001c  6008              STR      r0,[r1,#0]
                  |L2.30|
;;;265          /* No need to wait for VOSF to be cleared for this transition */
;;;266        }
;;;267      }
;;;268    #endif
;;;269    
;;;270      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;271    }
000020  4770              BX       lr
                  |L2.34|
000022  6808              LDR      r0,[r1,#0]            ;242
000024  f3c02041          UBFX     r0,r0,#9,#2           ;242
000028  2801              CMP      r0,#1                 ;242
00002a  d0f8              BEQ      |L2.30|
00002c  6808              LDR      r0,[r1,#0]            ;245
00002e  f42060c0          BIC      r0,r0,#0x600          ;245
000032  f4407000          ORR      r0,r0,#0x200          ;245
000036  6008              STR      r0,[r1,#0]            ;245
000038  480a              LDR      r0,|L2.100|
00003a  2232              MOVS     r2,#0x32              ;248
00003c  6800              LDR      r0,[r0,#0]            ;248  ; SystemCoreClock
00003e  4350              MULS     r0,r2,r0              ;248
000040  4a09              LDR      r2,|L2.104|
000042  fbb0f0f2          UDIV     r0,r0,r2              ;248
000046  1c40              ADDS     r0,r0,#1              ;248
000048  e000              B        |L2.76|
                  |L2.74|
00004a  1e40              SUBS     r0,r0,#1              ;251
                  |L2.76|
00004c  694a              LDR      r2,[r1,#0x14]         ;249
00004e  0552              LSLS     r2,r2,#21             ;249
000050  d501              BPL      |L2.86|
000052  2800              CMP      r0,#0                 ;249
000054  d1f9              BNE      |L2.74|
                  |L2.86|
000056  6948              LDR      r0,[r1,#0x14]         ;253
000058  0540              LSLS     r0,r0,#21             ;253
00005a  d5e0              BPL      |L2.30|
00005c  2003              MOVS     r0,#3                 ;255
00005e  4770              BX       lr
;;;272    
                          ENDP

                  |L2.96|
                          DCD      0x40007000
                  |L2.100|
                          DCD      SystemCoreClock
                  |L2.104|
                          DCD      0x000f4240

                          AREA ||i.HAL_PWREx_DisableBatteryCharging||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBatteryCharging PROC
;;;298      */
;;;299    void HAL_PWREx_DisableBatteryCharging(void)
000000  4802              LDR      r0,|L3.12|
;;;300    {
;;;301      CLEAR_BIT(PWR->CR4, PWR_CR4_VBE);
000002  68c1              LDR      r1,[r0,#0xc]
000004  f4217180          BIC      r1,r1,#0x100
000008  60c1              STR      r1,[r0,#0xc]
;;;302    }
00000a  4770              BX       lr
;;;303    
                          ENDP

                  |L3.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableGPIOPullDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableGPIOPullDown PROC
;;;634      */
;;;635    HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
000000  b510              PUSH     {r4,lr}
;;;636    {
000002  4603              MOV      r3,r0
;;;637      HAL_StatusTypeDef status = HAL_OK;
000004  2000              MOVS     r0,#0
;;;638    
;;;639      assert_param(IS_PWR_GPIO(GPIO));
;;;640      assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
;;;641    
;;;642      switch (GPIO)
;;;643      {
;;;644        case PWR_GPIO_A:
;;;645           CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));
000006  4a1c              LDR      r2,|L4.120|
000008  2b09              CMP      r3,#9                 ;642
00000a  d233              BCS      |L4.116|
00000c  e8dff003          TBB      [pc,r3]               ;642
000010  050b1115          DCB      0x05,0x0b,0x11,0x15
000014  191d2125          DCB      0x19,0x1d,0x21,0x25
000018  2c00              DCB      0x2c,0x00
00001a  6a53              LDR      r3,[r2,#0x24]
00001c  f4214120          BIC      r1,r1,#0xa000
000020  438b              BICS     r3,r3,r1
000022  6253              STR      r3,[r2,#0x24]
;;;646           break;
;;;647        case PWR_GPIO_B:
;;;648           CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
;;;649           break;
;;;650        case PWR_GPIO_C:
;;;651           CLEAR_BIT(PWR->PDCRC, GPIONumber);
;;;652           break;
;;;653    #if defined(GPIOD)
;;;654        case PWR_GPIO_D:
;;;655           CLEAR_BIT(PWR->PDCRD, GPIONumber);
;;;656           break;
;;;657    #endif
;;;658    #if defined(GPIOE)
;;;659        case PWR_GPIO_E:
;;;660           CLEAR_BIT(PWR->PDCRE, GPIONumber);
;;;661           break;
;;;662    #endif
;;;663    #if defined(GPIOF)
;;;664        case PWR_GPIO_F:
;;;665           CLEAR_BIT(PWR->PDCRF, GPIONumber);
;;;666           break;
;;;667    #endif
;;;668    #if defined(GPIOG)
;;;669        case PWR_GPIO_G:
;;;670           CLEAR_BIT(PWR->PDCRG, GPIONumber);
;;;671           break;
;;;672    #endif
;;;673        case PWR_GPIO_H:
;;;674    #if defined (STM32L496xx) || defined (STM32L4A6xx)
;;;675           CLEAR_BIT(PWR->PDCRH, ((GPIONumber & PWR_PORTH_AVAILABLE_PINS) & (~(PWR_GPIO_BIT_3))));
;;;676    #else
;;;677           CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
;;;678    #endif
;;;679           break;
;;;680    #if defined(GPIOI)
;;;681        case PWR_GPIO_I:
;;;682           CLEAR_BIT(PWR->PDCRI, (GPIONumber & PWR_PORTI_AVAILABLE_PINS));
;;;683           break;
;;;684    #endif
;;;685        default:
;;;686          status = HAL_ERROR;
;;;687          break;
;;;688      }
;;;689    
;;;690      return status;
;;;691    }
000024  bd10              POP      {r4,pc}
000026  6ad3              LDR      r3,[r2,#0x2c]         ;648
000028  f0210110          BIC      r1,r1,#0x10           ;648
00002c  438b              BICS     r3,r3,r1              ;648
00002e  62d3              STR      r3,[r2,#0x2c]         ;648
000030  bd10              POP      {r4,pc}
000032  6b53              LDR      r3,[r2,#0x34]         ;651
000034  438b              BICS     r3,r3,r1              ;651
000036  6353              STR      r3,[r2,#0x34]         ;651
000038  bd10              POP      {r4,pc}
00003a  6bd3              LDR      r3,[r2,#0x3c]         ;655
00003c  438b              BICS     r3,r3,r1              ;655
00003e  63d3              STR      r3,[r2,#0x3c]         ;655
000040  bd10              POP      {r4,pc}
000042  6c53              LDR      r3,[r2,#0x44]         ;660
000044  438b              BICS     r3,r3,r1              ;660
000046  6453              STR      r3,[r2,#0x44]         ;660
000048  bd10              POP      {r4,pc}
00004a  6cd3              LDR      r3,[r2,#0x4c]         ;665
00004c  438b              BICS     r3,r3,r1              ;665
00004e  64d3              STR      r3,[r2,#0x4c]         ;665
000050  bd10              POP      {r4,pc}
000052  6d53              LDR      r3,[r2,#0x54]         ;670
000054  438b              BICS     r3,r3,r1              ;670
000056  6553              STR      r3,[r2,#0x54]         ;670
000058  bd10              POP      {r4,pc}
00005a  6dd3              LDR      r3,[r2,#0x5c]         ;675
00005c  f64f74f7          MOV      r4,#0xfff7            ;675
000060  4021              ANDS     r1,r1,r4              ;675
000062  438b              BICS     r3,r3,r1              ;675
000064  65d3              STR      r3,[r2,#0x5c]         ;675
000066  bd10              POP      {r4,pc}
000068  6e53              LDR      r3,[r2,#0x64]         ;682
00006a  f3c1010b          UBFX     r1,r1,#0,#12          ;682
00006e  438b              BICS     r3,r3,r1              ;682
000070  6653              STR      r3,[r2,#0x64]         ;682
000072  bd10              POP      {r4,pc}
                  |L4.116|
000074  2001              MOVS     r0,#1                 ;686
000076  bd10              POP      {r4,pc}
;;;692    
                          ENDP

                  |L4.120|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableGPIOPullUp||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableGPIOPullUp PROC
;;;474      */
;;;475    HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
000000  b510              PUSH     {r4,lr}
;;;476    {
000002  4603              MOV      r3,r0
;;;477      HAL_StatusTypeDef status = HAL_OK;
000004  2000              MOVS     r0,#0
;;;478    
;;;479      assert_param(IS_PWR_GPIO(GPIO));
;;;480      assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
;;;481    
;;;482      switch (GPIO)
;;;483      {
;;;484        case PWR_GPIO_A:
;;;485           CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
000006  4a1a              LDR      r2,|L5.112|
000008  2b09              CMP      r3,#9                 ;482
00000a  d22f              BCS      |L5.108|
00000c  e8dff003          TBB      [pc,r3]               ;482
000010  050b0f13          DCB      0x05,0x0b,0x0f,0x13
000014  171b1f23          DCB      0x17,0x1b,0x1f,0x23
000018  2800              DCB      0x28,0x00
00001a  6a13              LDR      r3,[r2,#0x20]
00001c  f4214180          BIC      r1,r1,#0x4000
000020  438b              BICS     r3,r3,r1
000022  6213              STR      r3,[r2,#0x20]
;;;486           break;
;;;487        case PWR_GPIO_B:
;;;488           CLEAR_BIT(PWR->PUCRB, GPIONumber);
;;;489           break;
;;;490        case PWR_GPIO_C:
;;;491           CLEAR_BIT(PWR->PUCRC, GPIONumber);
;;;492           break;
;;;493    #if defined(GPIOD)
;;;494        case PWR_GPIO_D:
;;;495           CLEAR_BIT(PWR->PUCRD, GPIONumber);
;;;496           break;
;;;497    #endif
;;;498    #if defined(GPIOE)
;;;499        case PWR_GPIO_E:
;;;500           CLEAR_BIT(PWR->PUCRE, GPIONumber);
;;;501           break;
;;;502    #endif
;;;503    #if defined(GPIOF)
;;;504        case PWR_GPIO_F:
;;;505           CLEAR_BIT(PWR->PUCRF, GPIONumber);
;;;506           break;
;;;507    #endif
;;;508    #if defined(GPIOG)
;;;509        case PWR_GPIO_G:
;;;510           CLEAR_BIT(PWR->PUCRG, GPIONumber);
;;;511           break;
;;;512    #endif
;;;513        case PWR_GPIO_H:
;;;514           CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
;;;515           break;
;;;516    #if defined(GPIOI)
;;;517        case PWR_GPIO_I:
;;;518           CLEAR_BIT(PWR->PUCRI, (GPIONumber & PWR_PORTI_AVAILABLE_PINS));
;;;519           break;
;;;520    #endif
;;;521        default:
;;;522           status = HAL_ERROR;
;;;523           break;
;;;524      }
;;;525    
;;;526      return status;
;;;527    }
000024  bd10              POP      {r4,pc}
000026  6a93              LDR      r3,[r2,#0x28]         ;488
000028  438b              BICS     r3,r3,r1              ;488
00002a  6293              STR      r3,[r2,#0x28]         ;488
00002c  bd10              POP      {r4,pc}
00002e  6b13              LDR      r3,[r2,#0x30]         ;491
000030  438b              BICS     r3,r3,r1              ;491
000032  6313              STR      r3,[r2,#0x30]         ;491
000034  bd10              POP      {r4,pc}
000036  6b93              LDR      r3,[r2,#0x38]         ;495
000038  438b              BICS     r3,r3,r1              ;495
00003a  6393              STR      r3,[r2,#0x38]         ;495
00003c  bd10              POP      {r4,pc}
00003e  6c13              LDR      r3,[r2,#0x40]         ;500
000040  438b              BICS     r3,r3,r1              ;500
000042  6413              STR      r3,[r2,#0x40]         ;500
000044  bd10              POP      {r4,pc}
000046  6c93              LDR      r3,[r2,#0x48]         ;505
000048  438b              BICS     r3,r3,r1              ;505
00004a  6493              STR      r3,[r2,#0x48]         ;505
00004c  bd10              POP      {r4,pc}
00004e  6d13              LDR      r3,[r2,#0x50]         ;510
000050  438b              BICS     r3,r3,r1              ;510
000052  6513              STR      r3,[r2,#0x50]         ;510
000054  bd10              POP      {r4,pc}
000056  6d93              LDR      r3,[r2,#0x58]         ;514
000058  b289              UXTH     r1,r1                 ;514
00005a  438b              BICS     r3,r3,r1              ;514
00005c  6593              STR      r3,[r2,#0x58]         ;514
00005e  bd10              POP      {r4,pc}
000060  6e13              LDR      r3,[r2,#0x60]         ;518
000062  f3c1010b          UBFX     r1,r1,#0,#12          ;518
000066  438b              BICS     r3,r3,r1              ;518
000068  6613              STR      r3,[r2,#0x60]         ;518
00006a  bd10              POP      {r4,pc}
                  |L5.108|
00006c  2001              MOVS     r0,#1                 ;522
00006e  bd10              POP      {r4,pc}
;;;528    
                          ENDP

                  |L5.112|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableInternalWakeUpLine||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableInternalWakeUpLine PROC
;;;363      */
;;;364    void HAL_PWREx_DisableInternalWakeUpLine(void)
000000  4802              LDR      r0,|L6.12|
;;;365    {
;;;366      CLEAR_BIT(PWR->CR3, PWR_CR3_EIWF);
000002  6881              LDR      r1,[r0,#8]
000004  f4214100          BIC      r1,r1,#0x8000
000008  6081              STR      r1,[r0,#8]
;;;367    }
00000a  4770              BX       lr
;;;368    
                          ENDP

                  |L6.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableLowPowerRunMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableLowPowerRunMode PROC
;;;1144     */
;;;1145   HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
000000  490d              LDR      r1,|L7.56|
;;;1146   {
;;;1147     uint32_t wait_loop_index;
;;;1148   
;;;1149     /* Clear LPR bit */
;;;1150     CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
000002  6808              LDR      r0,[r1,#0]
000004  f4204080          BIC      r0,r0,#0x4000
000008  6008              STR      r0,[r1,#0]
;;;1151   
;;;1152     /* Wait until REGLPF is reset */
;;;1153     wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
00000a  480c              LDR      r0,|L7.60|
00000c  2232              MOVS     r2,#0x32
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  4350              MULS     r0,r2,r0
000012  4a0b              LDR      r2,|L7.64|
000014  fbb0f0f2          UDIV     r0,r0,r2
000018  1c40              ADDS     r0,r0,#1
00001a  e000              B        |L7.30|
                  |L7.28|
;;;1154     while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
;;;1155     {
;;;1156       wait_loop_index--;
00001c  1e40              SUBS     r0,r0,#1
                  |L7.30|
00001e  694a              LDR      r2,[r1,#0x14]         ;1154
000020  0592              LSLS     r2,r2,#22             ;1154
000022  d501              BPL      |L7.40|
000024  2800              CMP      r0,#0                 ;1154
000026  d1f9              BNE      |L7.28|
                  |L7.40|
;;;1157     }
;;;1158     if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
000028  6948              LDR      r0,[r1,#0x14]
00002a  0580              LSLS     r0,r0,#22
00002c  d501              BPL      |L7.50|
;;;1159     {
;;;1160       return HAL_TIMEOUT;
00002e  2003              MOVS     r0,#3
;;;1161     }
;;;1162   
;;;1163     return HAL_OK;
;;;1164   }
000030  4770              BX       lr
                  |L7.50|
000032  2000              MOVS     r0,#0                 ;1163
000034  4770              BX       lr
;;;1165   
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      0x40007000
                  |L7.60|
                          DCD      SystemCoreClock
                  |L7.64|
                          DCD      0x000f4240

                          AREA ||i.HAL_PWREx_DisablePVM1||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisablePVM1 PROC
;;;887      */
;;;888    void HAL_PWREx_DisablePVM1(void)
000000  4802              LDR      r0,|L8.12|
;;;889    {
;;;890      CLEAR_BIT(PWR->CR2, PWR_PVM_1);
000002  6841              LDR      r1,[r0,#4]
000004  f0210110          BIC      r1,r1,#0x10
000008  6041              STR      r1,[r0,#4]
;;;891    }
00000a  4770              BX       lr
;;;892    #endif /* PWR_CR2_PVME1 */
                          ENDP

                  |L8.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisablePVM2||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisablePVM2 PROC
;;;908      */
;;;909    void HAL_PWREx_DisablePVM2(void)
000000  4802              LDR      r0,|L9.12|
;;;910    {
;;;911      CLEAR_BIT(PWR->CR2, PWR_PVM_2);
000002  6841              LDR      r1,[r0,#4]
000004  f0210120          BIC      r1,r1,#0x20
000008  6041              STR      r1,[r0,#4]
;;;912    }
00000a  4770              BX       lr
;;;913    #endif /* PWR_CR2_PVME2 */
                          ENDP

                  |L9.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisablePVM3||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisablePVM3 PROC
;;;928      */
;;;929    void HAL_PWREx_DisablePVM3(void)
000000  4802              LDR      r0,|L10.12|
;;;930    {
;;;931      CLEAR_BIT(PWR->CR2, PWR_PVM_3);
000002  6841              LDR      r1,[r0,#4]
000004  f0210140          BIC      r1,r1,#0x40
000008  6041              STR      r1,[r0,#4]
;;;932    }
00000a  4770              BX       lr
;;;933    
                          ENDP

                  |L10.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisablePVM4||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisablePVM4 PROC
;;;947      */
;;;948    void HAL_PWREx_DisablePVM4(void)
000000  4802              LDR      r0,|L11.12|
;;;949    {
;;;950      CLEAR_BIT(PWR->CR2, PWR_PVM_4);
000002  6841              LDR      r1,[r0,#4]
000004  f0210180          BIC      r1,r1,#0x80
000008  6041              STR      r1,[r0,#4]
;;;951    }
00000a  4770              BX       lr
;;;952    
                          ENDP

                  |L11.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisablePullUpPullDownConfig||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisablePullUpPullDownConfig PROC
;;;716      */
;;;717    void HAL_PWREx_DisablePullUpPullDownConfig(void)
000000  4802              LDR      r0,|L12.12|
;;;718    {
;;;719      CLEAR_BIT(PWR->CR3, PWR_CR3_APC);
000002  6881              LDR      r1,[r0,#8]
000004  f4216180          BIC      r1,r1,#0x400
000008  6081              STR      r1,[r0,#8]
;;;720    }
00000a  4770              BX       lr
;;;721    
                          ENDP

                  |L12.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableSRAM2ContentRetention||, CODE, READONLY, ALIGN=1

                  HAL_PWREx_DisableSRAM2ContentRetention PROC
;;;736      */
;;;737    void HAL_PWREx_DisableSRAM2ContentRetention(void)
000000  2000              MOVS     r0,#0
;;;738    {
;;;739      (void) HAL_PWREx_SetSRAM2ContentRetention(PWR_NO_SRAM2_RETENTION);
000002  f7ffbffe          B.W      HAL_PWREx_SetSRAM2ContentRetention
;;;740    }
;;;741    
                          ENDP


                          AREA ||i.HAL_PWREx_DisableVddIO2||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableVddIO2 PROC
;;;342      */
;;;343    void HAL_PWREx_DisableVddIO2(void)
000000  4802              LDR      r0,|L14.12|
;;;344    {
;;;345      CLEAR_BIT(PWR->CR2, PWR_CR2_IOSV);
000002  6841              LDR      r1,[r0,#4]
000004  f4217100          BIC      r1,r1,#0x200
000008  6041              STR      r1,[r0,#4]
;;;346    }
00000a  4770              BX       lr
;;;347    #endif /* PWR_CR2_IOSV */
                          ENDP

                  |L14.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableVddUSB||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableVddUSB PROC
;;;320      */
;;;321    void HAL_PWREx_DisableVddUSB(void)
000000  4802              LDR      r0,|L15.12|
;;;322    {
;;;323      CLEAR_BIT(PWR->CR2, PWR_CR2_USV);
000002  6841              LDR      r1,[r0,#4]
000004  f4216180          BIC      r1,r1,#0x400
000008  6041              STR      r1,[r0,#4]
;;;324    }
00000a  4770              BX       lr
;;;325    #endif /* PWR_CR2_USV */
                          ENDP

                  |L15.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBatteryCharging||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBatteryCharging PROC
;;;282      */
;;;283    void HAL_PWREx_EnableBatteryCharging(uint32_t ResistorSelection)
000000  4905              LDR      r1,|L16.24|
;;;284    {
;;;285      assert_param(IS_PWR_BATTERY_RESISTOR_SELECT(ResistorSelection));
;;;286    
;;;287      /* Specify resistor selection */
;;;288      MODIFY_REG(PWR->CR4, PWR_CR4_VBRS, ResistorSelection);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227200          BIC      r2,r2,#0x200
000008  4302              ORRS     r2,r2,r0
00000a  60ca              STR      r2,[r1,#0xc]
;;;289    
;;;290      /* Enable battery charging */
;;;291      SET_BIT(PWR->CR4, PWR_CR4_VBE);
00000c  68c8              LDR      r0,[r1,#0xc]
00000e  f4407080          ORR      r0,r0,#0x100
000012  60c8              STR      r0,[r1,#0xc]
;;;292    }
000014  4770              BX       lr
;;;293    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableGPIOPullDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableGPIOPullDown PROC
;;;551      */
;;;552    HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
000000  b510              PUSH     {r4,lr}
;;;553    {
000002  4603              MOV      r3,r0
;;;554      HAL_StatusTypeDef status = HAL_OK;
000004  2000              MOVS     r0,#0
;;;555    
;;;556      assert_param(IS_PWR_GPIO(GPIO));
;;;557      assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
;;;558    
;;;559      switch (GPIO)
;;;560      {
;;;561        case PWR_GPIO_A:
;;;562           SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));
000006  4a2b              LDR      r2,|L17.180|
000008  2b09              CMP      r3,#9                 ;559
00000a  d251              BCS      |L17.176|
00000c  e8dff003          TBB      [pc,r3]               ;559
000010  05101920          DCB      0x05,0x10,0x19,0x20
000014  272e353c          DCB      0x27,0x2e,0x35,0x3c
000018  4700              DCB      0x47,0x00
00001a  6a53              LDR      r3,[r2,#0x24]
00001c  f4214420          BIC      r4,r1,#0xa000
000020  4323              ORRS     r3,r3,r4
000022  6253              STR      r3,[r2,#0x24]
;;;563           CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
000024  6a13              LDR      r3,[r2,#0x20]
000026  f4214180          BIC      r1,r1,#0x4000
00002a  438b              BICS     r3,r3,r1
00002c  6213              STR      r3,[r2,#0x20]
;;;564           break;
;;;565        case PWR_GPIO_B:
;;;566           SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
;;;567           CLEAR_BIT(PWR->PUCRB, GPIONumber);
;;;568           break;
;;;569        case PWR_GPIO_C:
;;;570           SET_BIT(PWR->PDCRC, GPIONumber);
;;;571           CLEAR_BIT(PWR->PUCRC, GPIONumber);
;;;572           break;
;;;573    #if defined(GPIOD)
;;;574        case PWR_GPIO_D:
;;;575           SET_BIT(PWR->PDCRD, GPIONumber);
;;;576           CLEAR_BIT(PWR->PUCRD, GPIONumber);
;;;577           break;
;;;578    #endif
;;;579    #if defined(GPIOE)
;;;580        case PWR_GPIO_E:
;;;581           SET_BIT(PWR->PDCRE, GPIONumber);
;;;582           CLEAR_BIT(PWR->PUCRE, GPIONumber);
;;;583           break;
;;;584    #endif
;;;585    #if defined(GPIOF)
;;;586        case PWR_GPIO_F:
;;;587           SET_BIT(PWR->PDCRF, GPIONumber);
;;;588           CLEAR_BIT(PWR->PUCRF, GPIONumber);
;;;589           break;
;;;590    #endif
;;;591    #if defined(GPIOG)
;;;592        case PWR_GPIO_G:
;;;593           SET_BIT(PWR->PDCRG, GPIONumber);
;;;594           CLEAR_BIT(PWR->PUCRG, GPIONumber);
;;;595           break;
;;;596    #endif
;;;597        case PWR_GPIO_H:
;;;598    #if defined (STM32L496xx) || defined (STM32L4A6xx)
;;;599           SET_BIT(PWR->PDCRH, ((GPIONumber & PWR_PORTH_AVAILABLE_PINS) & (~(PWR_GPIO_BIT_3))));
;;;600    #else
;;;601           SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
;;;602    #endif
;;;603           CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
;;;604           break;
;;;605    #if defined(GPIOI)
;;;606        case PWR_GPIO_I:
;;;607           SET_BIT(PWR->PDCRI, (GPIONumber & PWR_PORTI_AVAILABLE_PINS));
;;;608           CLEAR_BIT(PWR->PUCRI, (GPIONumber & PWR_PORTI_AVAILABLE_PINS));
;;;609           break;
;;;610    #endif
;;;611        default:
;;;612          status = HAL_ERROR;
;;;613          break;
;;;614      }
;;;615    
;;;616      return status;
;;;617    }
00002e  bd10              POP      {r4,pc}
000030  6ad3              LDR      r3,[r2,#0x2c]         ;566
000032  f0210410          BIC      r4,r1,#0x10           ;566
000036  4323              ORRS     r3,r3,r4              ;566
000038  62d3              STR      r3,[r2,#0x2c]         ;566
00003a  6a93              LDR      r3,[r2,#0x28]         ;567
00003c  438b              BICS     r3,r3,r1              ;567
00003e  6293              STR      r3,[r2,#0x28]         ;567
000040  bd10              POP      {r4,pc}
000042  6b53              LDR      r3,[r2,#0x34]         ;570
000044  430b              ORRS     r3,r3,r1              ;570
000046  6353              STR      r3,[r2,#0x34]         ;570
000048  6b13              LDR      r3,[r2,#0x30]         ;571
00004a  438b              BICS     r3,r3,r1              ;571
00004c  6313              STR      r3,[r2,#0x30]         ;571
00004e  bd10              POP      {r4,pc}
000050  6bd3              LDR      r3,[r2,#0x3c]         ;575
000052  430b              ORRS     r3,r3,r1              ;575
000054  63d3              STR      r3,[r2,#0x3c]         ;575
000056  6b93              LDR      r3,[r2,#0x38]         ;576
000058  438b              BICS     r3,r3,r1              ;576
00005a  6393              STR      r3,[r2,#0x38]         ;576
00005c  bd10              POP      {r4,pc}
00005e  6c53              LDR      r3,[r2,#0x44]         ;581
000060  430b              ORRS     r3,r3,r1              ;581
000062  6453              STR      r3,[r2,#0x44]         ;581
000064  6c13              LDR      r3,[r2,#0x40]         ;582
000066  438b              BICS     r3,r3,r1              ;582
000068  6413              STR      r3,[r2,#0x40]         ;582
00006a  bd10              POP      {r4,pc}
00006c  6cd3              LDR      r3,[r2,#0x4c]         ;587
00006e  430b              ORRS     r3,r3,r1              ;587
000070  64d3              STR      r3,[r2,#0x4c]         ;587
000072  6c93              LDR      r3,[r2,#0x48]         ;588
000074  438b              BICS     r3,r3,r1              ;588
000076  6493              STR      r3,[r2,#0x48]         ;588
000078  bd10              POP      {r4,pc}
00007a  6d53              LDR      r3,[r2,#0x54]         ;593
00007c  430b              ORRS     r3,r3,r1              ;593
00007e  6553              STR      r3,[r2,#0x54]         ;593
000080  6d13              LDR      r3,[r2,#0x50]         ;594
000082  438b              BICS     r3,r3,r1              ;594
000084  6513              STR      r3,[r2,#0x50]         ;594
000086  bd10              POP      {r4,pc}
000088  6dd3              LDR      r3,[r2,#0x5c]         ;599
00008a  f64f74f7          MOV      r4,#0xfff7            ;599
00008e  400c              ANDS     r4,r4,r1              ;599
000090  4323              ORRS     r3,r3,r4              ;599
000092  65d3              STR      r3,[r2,#0x5c]         ;599
000094  6d93              LDR      r3,[r2,#0x58]         ;603
000096  b289              UXTH     r1,r1                 ;603
000098  438b              BICS     r3,r3,r1              ;603
00009a  6593              STR      r3,[r2,#0x58]         ;603
00009c  bd10              POP      {r4,pc}
00009e  6e53              LDR      r3,[r2,#0x64]         ;607
0000a0  f3c1010b          UBFX     r1,r1,#0,#12          ;607
0000a4  430b              ORRS     r3,r3,r1              ;607
0000a6  6653              STR      r3,[r2,#0x64]         ;607
0000a8  6e13              LDR      r3,[r2,#0x60]         ;608
0000aa  438b              BICS     r3,r3,r1              ;608
0000ac  6613              STR      r3,[r2,#0x60]         ;608
0000ae  bd10              POP      {r4,pc}
                  |L17.176|
0000b0  2001              MOVS     r0,#1                 ;612
0000b2  bd10              POP      {r4,pc}
;;;618    
                          ENDP

                  |L17.180|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableGPIOPullUp||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableGPIOPullUp PROC
;;;391      */
;;;392    HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
000000  b510              PUSH     {r4,lr}
;;;393    {
000002  4603              MOV      r3,r0
;;;394      HAL_StatusTypeDef status = HAL_OK;
000004  2000              MOVS     r0,#0
;;;395    
;;;396      assert_param(IS_PWR_GPIO(GPIO));
;;;397      assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
;;;398    
;;;399      switch (GPIO)
;;;400      {
;;;401        case PWR_GPIO_A:
;;;402           SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
000006  4a2b              LDR      r2,|L18.180|
000008  2b09              CMP      r3,#9                 ;399
00000a  d251              BCS      |L18.176|
00000c  e8dff003          TBB      [pc,r3]               ;399
000010  05101920          DCB      0x05,0x10,0x19,0x20
000014  272e353c          DCB      0x27,0x2e,0x35,0x3c
000018  4700              DCB      0x47,0x00
00001a  6a13              LDR      r3,[r2,#0x20]
00001c  f4214480          BIC      r4,r1,#0x4000
000020  4323              ORRS     r3,r3,r4
000022  6213              STR      r3,[r2,#0x20]
;;;403           CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));
000024  6a53              LDR      r3,[r2,#0x24]
000026  f4214120          BIC      r1,r1,#0xa000
00002a  438b              BICS     r3,r3,r1
00002c  6253              STR      r3,[r2,#0x24]
;;;404           break;
;;;405        case PWR_GPIO_B:
;;;406           SET_BIT(PWR->PUCRB, GPIONumber);
;;;407           CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
;;;408           break;
;;;409        case PWR_GPIO_C:
;;;410           SET_BIT(PWR->PUCRC, GPIONumber);
;;;411           CLEAR_BIT(PWR->PDCRC, GPIONumber);
;;;412           break;
;;;413    #if defined(GPIOD)
;;;414        case PWR_GPIO_D:
;;;415           SET_BIT(PWR->PUCRD, GPIONumber);
;;;416           CLEAR_BIT(PWR->PDCRD, GPIONumber);
;;;417           break;
;;;418    #endif
;;;419    #if defined(GPIOE)
;;;420        case PWR_GPIO_E:
;;;421           SET_BIT(PWR->PUCRE, GPIONumber);
;;;422           CLEAR_BIT(PWR->PDCRE, GPIONumber);
;;;423           break;
;;;424    #endif
;;;425    #if defined(GPIOF)
;;;426        case PWR_GPIO_F:
;;;427           SET_BIT(PWR->PUCRF, GPIONumber);
;;;428           CLEAR_BIT(PWR->PDCRF, GPIONumber);
;;;429           break;
;;;430    #endif
;;;431    #if defined(GPIOG)
;;;432        case PWR_GPIO_G:
;;;433           SET_BIT(PWR->PUCRG, GPIONumber);
;;;434           CLEAR_BIT(PWR->PDCRG, GPIONumber);
;;;435           break;
;;;436    #endif
;;;437        case PWR_GPIO_H:
;;;438           SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
;;;439    #if defined (STM32L496xx) || defined (STM32L4A6xx)
;;;440           CLEAR_BIT(PWR->PDCRH, ((GPIONumber & PWR_PORTH_AVAILABLE_PINS) & (~(PWR_GPIO_BIT_3))));
;;;441    #else
;;;442           CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
;;;443    #endif
;;;444           break;
;;;445    #if defined(GPIOI)
;;;446        case PWR_GPIO_I:
;;;447           SET_BIT(PWR->PUCRI, (GPIONumber & PWR_PORTI_AVAILABLE_PINS));
;;;448           CLEAR_BIT(PWR->PDCRI, (GPIONumber & PWR_PORTI_AVAILABLE_PINS));
;;;449           break;
;;;450    #endif
;;;451        default:
;;;452          status = HAL_ERROR;
;;;453          break;
;;;454      }
;;;455    
;;;456      return status;
;;;457    }
00002e  bd10              POP      {r4,pc}
000030  6a93              LDR      r3,[r2,#0x28]         ;406
000032  430b              ORRS     r3,r3,r1              ;406
000034  6293              STR      r3,[r2,#0x28]         ;406
000036  6ad3              LDR      r3,[r2,#0x2c]         ;407
000038  f0210110          BIC      r1,r1,#0x10           ;407
00003c  438b              BICS     r3,r3,r1              ;407
00003e  62d3              STR      r3,[r2,#0x2c]         ;407
000040  bd10              POP      {r4,pc}
000042  6b13              LDR      r3,[r2,#0x30]         ;410
000044  430b              ORRS     r3,r3,r1              ;410
000046  6313              STR      r3,[r2,#0x30]         ;410
000048  6b53              LDR      r3,[r2,#0x34]         ;411
00004a  438b              BICS     r3,r3,r1              ;411
00004c  6353              STR      r3,[r2,#0x34]         ;411
00004e  bd10              POP      {r4,pc}
000050  6b93              LDR      r3,[r2,#0x38]         ;415
000052  430b              ORRS     r3,r3,r1              ;415
000054  6393              STR      r3,[r2,#0x38]         ;415
000056  6bd3              LDR      r3,[r2,#0x3c]         ;416
000058  438b              BICS     r3,r3,r1              ;416
00005a  63d3              STR      r3,[r2,#0x3c]         ;416
00005c  bd10              POP      {r4,pc}
00005e  6c13              LDR      r3,[r2,#0x40]         ;421
000060  430b              ORRS     r3,r3,r1              ;421
000062  6413              STR      r3,[r2,#0x40]         ;421
000064  6c53              LDR      r3,[r2,#0x44]         ;422
000066  438b              BICS     r3,r3,r1              ;422
000068  6453              STR      r3,[r2,#0x44]         ;422
00006a  bd10              POP      {r4,pc}
00006c  6c93              LDR      r3,[r2,#0x48]         ;427
00006e  430b              ORRS     r3,r3,r1              ;427
000070  6493              STR      r3,[r2,#0x48]         ;427
000072  6cd3              LDR      r3,[r2,#0x4c]         ;428
000074  438b              BICS     r3,r3,r1              ;428
000076  64d3              STR      r3,[r2,#0x4c]         ;428
000078  bd10              POP      {r4,pc}
00007a  6d13              LDR      r3,[r2,#0x50]         ;433
00007c  430b              ORRS     r3,r3,r1              ;433
00007e  6513              STR      r3,[r2,#0x50]         ;433
000080  6d53              LDR      r3,[r2,#0x54]         ;434
000082  438b              BICS     r3,r3,r1              ;434
000084  6553              STR      r3,[r2,#0x54]         ;434
000086  bd10              POP      {r4,pc}
000088  6d93              LDR      r3,[r2,#0x58]         ;438
00008a  b28c              UXTH     r4,r1                 ;438
00008c  4323              ORRS     r3,r3,r4              ;438
00008e  6593              STR      r3,[r2,#0x58]         ;438
000090  6dd3              LDR      r3,[r2,#0x5c]         ;440
000092  f64f74f7          MOV      r4,#0xfff7            ;440
000096  4021              ANDS     r1,r1,r4              ;440
000098  438b              BICS     r3,r3,r1              ;440
00009a  65d3              STR      r3,[r2,#0x5c]         ;440
00009c  bd10              POP      {r4,pc}
00009e  6e13              LDR      r3,[r2,#0x60]         ;447
0000a0  f3c1010b          UBFX     r1,r1,#0,#12          ;447
0000a4  430b              ORRS     r3,r3,r1              ;447
0000a6  6613              STR      r3,[r2,#0x60]         ;447
0000a8  6e53              LDR      r3,[r2,#0x64]         ;448
0000aa  438b              BICS     r3,r3,r1              ;448
0000ac  6653              STR      r3,[r2,#0x64]         ;448
0000ae  bd10              POP      {r4,pc}
                  |L18.176|
0000b0  2001              MOVS     r0,#1                 ;452
0000b2  bd10              POP      {r4,pc}
;;;458    
                          ENDP

                  |L18.180|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableInternalWakeUpLine||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableInternalWakeUpLine PROC
;;;353      */
;;;354    void HAL_PWREx_EnableInternalWakeUpLine(void)
000000  4802              LDR      r0,|L19.12|
;;;355    {
;;;356      SET_BIT(PWR->CR3, PWR_CR3_EIWF);
000002  6881              LDR      r1,[r0,#8]
000004  f4414100          ORR      r1,r1,#0x8000
000008  6081              STR      r1,[r0,#8]
;;;357    }
00000a  4770              BX       lr
;;;358    
                          ENDP

                  |L19.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableLowPowerRunMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableLowPowerRunMode PROC
;;;1129     */
;;;1130   void HAL_PWREx_EnableLowPowerRunMode(void)
000000  4802              LDR      r0,|L20.12|
;;;1131   {
;;;1132     /* Set Regulator parameter */
;;;1133     SET_BIT(PWR->CR1, PWR_CR1_LPR);
000002  6801              LDR      r1,[r0,#0]
000004  f4414180          ORR      r1,r1,#0x4000
000008  6001              STR      r1,[r0,#0]
;;;1134   }
00000a  4770              BX       lr
;;;1135   
                          ENDP

                  |L20.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnablePVM1||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnablePVM1 PROC
;;;878      */
;;;879    void HAL_PWREx_EnablePVM1(void)
000000  4802              LDR      r0,|L21.12|
;;;880    {
;;;881      SET_BIT(PWR->CR2, PWR_PVM_1);
000002  6841              LDR      r1,[r0,#4]
000004  f0410110          ORR      r1,r1,#0x10
000008  6041              STR      r1,[r0,#4]
;;;882    }
00000a  4770              BX       lr
;;;883    
                          ENDP

                  |L21.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnablePVM2||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnablePVM2 PROC
;;;899      */
;;;900    void HAL_PWREx_EnablePVM2(void)
000000  4802              LDR      r0,|L22.12|
;;;901    {
;;;902      SET_BIT(PWR->CR2, PWR_PVM_2);
000002  6841              LDR      r1,[r0,#4]
000004  f0410120          ORR      r1,r1,#0x20
000008  6041              STR      r1,[r0,#4]
;;;903    }
00000a  4770              BX       lr
;;;904    
                          ENDP

                  |L22.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnablePVM3||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnablePVM3 PROC
;;;919      */
;;;920    void HAL_PWREx_EnablePVM3(void)
000000  4802              LDR      r0,|L23.12|
;;;921    {
;;;922      SET_BIT(PWR->CR2, PWR_PVM_3);
000002  6841              LDR      r1,[r0,#4]
000004  f0410140          ORR      r1,r1,#0x40
000008  6041              STR      r1,[r0,#4]
;;;923    }
00000a  4770              BX       lr
;;;924    
                          ENDP

                  |L23.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnablePVM4||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnablePVM4 PROC
;;;938      */
;;;939    void HAL_PWREx_EnablePVM4(void)
000000  4802              LDR      r0,|L24.12|
;;;940    {
;;;941      SET_BIT(PWR->CR2, PWR_PVM_4);
000002  6841              LDR      r1,[r0,#4]
000004  f0410180          ORR      r1,r1,#0x80
000008  6041              STR      r1,[r0,#4]
;;;942    }
00000a  4770              BX       lr
;;;943    
                          ENDP

                  |L24.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnablePullUpPullDownConfig||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnablePullUpPullDownConfig PROC
;;;704      */
;;;705    void HAL_PWREx_EnablePullUpPullDownConfig(void)
000000  4802              LDR      r0,|L25.12|
;;;706    {
;;;707      SET_BIT(PWR->CR3, PWR_CR3_APC);
000002  6881              LDR      r1,[r0,#8]
000004  f4416180          ORR      r1,r1,#0x400
000008  6081              STR      r1,[r0,#8]
;;;708    }
00000a  4770              BX       lr
;;;709    
                          ENDP

                  |L25.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableSRAM2ContentRetention||, CODE, READONLY, ALIGN=1

                  HAL_PWREx_EnableSRAM2ContentRetention PROC
;;;727      */
;;;728    void HAL_PWREx_EnableSRAM2ContentRetention(void)
000000  f44f7080          MOV      r0,#0x100
;;;729    {
;;;730      (void) HAL_PWREx_SetSRAM2ContentRetention(PWR_FULL_SRAM2_RETENTION);
000004  f7ffbffe          B.W      HAL_PWREx_SetSRAM2ContentRetention
;;;731    }
;;;732    
                          ENDP


                          AREA ||i.HAL_PWREx_EnableVddIO2||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableVddIO2 PROC
;;;332      */
;;;333    void HAL_PWREx_EnableVddIO2(void)
000000  4802              LDR      r0,|L27.12|
;;;334    {
;;;335      SET_BIT(PWR->CR2, PWR_CR2_IOSV);
000002  6841              LDR      r1,[r0,#4]
000004  f4417100          ORR      r1,r1,#0x200
000008  6041              STR      r1,[r0,#4]
;;;336    }
00000a  4770              BX       lr
;;;337    
                          ENDP

                  |L27.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableVddUSB||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableVddUSB PROC
;;;310      */
;;;311    void HAL_PWREx_EnableVddUSB(void)
000000  4802              LDR      r0,|L28.12|
;;;312    {
;;;313      SET_BIT(PWR->CR2, PWR_CR2_USV);
000002  6841              LDR      r1,[r0,#4]
000004  f4416180          ORR      r1,r1,#0x400
000008  6041              STR      r1,[r0,#4]
;;;314    }
00000a  4770              BX       lr
;;;315    
                          ENDP

                  |L28.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterSHUTDOWNMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterSHUTDOWNMode PROC
;;;1334     */
;;;1335   void HAL_PWREx_EnterSHUTDOWNMode(void)
000000  4806              LDR      r0,|L29.28|
;;;1336   {
;;;1337   
;;;1338     /* Set Shutdown mode */
;;;1339     MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
000002  6801              LDR      r1,[r0,#0]
000004  f0210107          BIC      r1,r1,#7
000008  1d09              ADDS     r1,r1,#4
00000a  6001              STR      r1,[r0,#0]
;;;1340   
;;;1341     /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;1342     SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00000c  4804              LDR      r0,|L29.32|
00000e  6801              LDR      r1,[r0,#0]
000010  f0410104          ORR      r1,r1,#4
000014  6001              STR      r1,[r0,#0]
;;;1343   
;;;1344   /* This option is used to ensure that store operations are completed */
;;;1345   #if defined ( __CC_ARM)
;;;1346     __force_stores();
;;;1347   #endif
;;;1348     /* Request Wait For Interrupt */
;;;1349     __WFI();
000016  bf30              WFI      
;;;1350   }
000018  4770              BX       lr
;;;1351   
                          ENDP

00001a  0000              DCW      0x0000
                  |L29.28|
                          DCD      0x40007000
                  |L29.32|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_EnterSTOP0Mode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterSTOP0Mode PROC
;;;1188     */
;;;1189   void HAL_PWREx_EnterSTOP0Mode(uint8_t STOPEntry)
000000  490a              LDR      r1,|L30.44|
;;;1190   {
;;;1191     /* Check the parameters */
;;;1192     assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;1193   
;;;1194     /* Stop 0 mode with Main Regulator */
;;;1195     MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP0);
000002  680a              LDR      r2,[r1,#0]
000004  f0220207          BIC      r2,r2,#7
000008  600a              STR      r2,[r1,#0]
;;;1196   
;;;1197     /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;1198     SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00000a  4909              LDR      r1,|L30.48|
00000c  680a              LDR      r2,[r1,#0]
00000e  f0420204          ORR      r2,r2,#4
000012  600a              STR      r2,[r1,#0]
;;;1199   
;;;1200     /* Select Stop mode entry --------------------------------------------------*/
;;;1201     if(STOPEntry == PWR_STOPENTRY_WFI)
000014  2801              CMP      r0,#1
000016  d007              BEQ      |L30.40|
;;;1202     {
;;;1203       /* Request Wait For Interrupt */
;;;1204       __WFI();
;;;1205     }
;;;1206     else
;;;1207     {
;;;1208       /* Request Wait For Event */
;;;1209       __SEV();
000018  bf40              SEV      
;;;1210       __WFE();
00001a  bf20              WFE      
;;;1211       __WFE();
00001c  bf20              WFE      
                  |L30.30|
;;;1212     }
;;;1213   
;;;1214     /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;1215     CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00001e  6808              LDR      r0,[r1,#0]
000020  f0200004          BIC      r0,r0,#4
000024  6008              STR      r0,[r1,#0]
;;;1216   }
000026  4770              BX       lr
                  |L30.40|
000028  bf30              WFI                            ;1204
00002a  e7f8              B        |L30.30|
;;;1217   
                          ENDP

                  |L30.44|
                          DCD      0x40007000
                  |L30.48|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_EnterSTOP1Mode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterSTOP1Mode PROC
;;;1239     */
;;;1240   void HAL_PWREx_EnterSTOP1Mode(uint8_t STOPEntry)
000000  490b              LDR      r1,|L31.48|
;;;1241   {
;;;1242     /* Check the parameters */
;;;1243     assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;1244   
;;;1245     /* Stop 1 mode with Low-Power Regulator */
;;;1246     MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1);
000002  680a              LDR      r2,[r1,#0]
000004  f0220207          BIC      r2,r2,#7
000008  1c52              ADDS     r2,r2,#1
00000a  600a              STR      r2,[r1,#0]
;;;1247   
;;;1248     /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;1249     SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00000c  4909              LDR      r1,|L31.52|
00000e  680a              LDR      r2,[r1,#0]
000010  f0420204          ORR      r2,r2,#4
000014  600a              STR      r2,[r1,#0]
;;;1250   
;;;1251     /* Select Stop mode entry --------------------------------------------------*/
;;;1252     if(STOPEntry == PWR_STOPENTRY_WFI)
000016  2801              CMP      r0,#1
000018  d007              BEQ      |L31.42|
;;;1253     {
;;;1254       /* Request Wait For Interrupt */
;;;1255       __WFI();
;;;1256     }
;;;1257     else
;;;1258     {
;;;1259       /* Request Wait For Event */
;;;1260       __SEV();
00001a  bf40              SEV      
;;;1261       __WFE();
00001c  bf20              WFE      
;;;1262       __WFE();
00001e  bf20              WFE      
                  |L31.32|
;;;1263     }
;;;1264   
;;;1265     /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;1266     CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
000020  6808              LDR      r0,[r1,#0]
000022  f0200004          BIC      r0,r0,#4
000026  6008              STR      r0,[r1,#0]
;;;1267   }
000028  4770              BX       lr
                  |L31.42|
00002a  bf30              WFI                            ;1255
00002c  e7f8              B        |L31.32|
;;;1268   
                          ENDP

00002e  0000              DCW      0x0000
                  |L31.48|
                          DCD      0x40007000
                  |L31.52|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_EnterSTOP2Mode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterSTOP2Mode PROC
;;;1292     */
;;;1293   void HAL_PWREx_EnterSTOP2Mode(uint8_t STOPEntry)
000000  490b              LDR      r1,|L32.48|
;;;1294   {
;;;1295     /* Check the parameter */
;;;1296     assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;1297   
;;;1298     /* Set Stop mode 2 */
;;;1299     MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
000002  680a              LDR      r2,[r1,#0]
000004  f0220207          BIC      r2,r2,#7
000008  1c92              ADDS     r2,r2,#2
00000a  600a              STR      r2,[r1,#0]
;;;1300   
;;;1301     /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;1302     SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00000c  4909              LDR      r1,|L32.52|
00000e  680a              LDR      r2,[r1,#0]
000010  f0420204          ORR      r2,r2,#4
000014  600a              STR      r2,[r1,#0]
;;;1303   
;;;1304     /* Select Stop mode entry --------------------------------------------------*/
;;;1305     if(STOPEntry == PWR_STOPENTRY_WFI)
000016  2801              CMP      r0,#1
000018  d007              BEQ      |L32.42|
;;;1306     {
;;;1307       /* Request Wait For Interrupt */
;;;1308       __WFI();
;;;1309     }
;;;1310     else
;;;1311     {
;;;1312       /* Request Wait For Event */
;;;1313       __SEV();
00001a  bf40              SEV      
;;;1314       __WFE();
00001c  bf20              WFE      
;;;1315       __WFE();
00001e  bf20              WFE      
                  |L32.32|
;;;1316     }
;;;1317   
;;;1318     /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;1319     CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
000020  6808              LDR      r0,[r1,#0]
000022  f0200004          BIC      r0,r0,#4
000026  6008              STR      r0,[r1,#0]
;;;1320   }
000028  4770              BX       lr
                  |L32.42|
00002a  bf30              WFI                            ;1308
00002c  e7f8              B        |L32.32|
;;;1321   
                          ENDP

00002e  0000              DCW      0x0000
                  |L32.48|
                          DCD      0x40007000
                  |L32.52|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;114      */
;;;115    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L33.12|
;;;116    {
;;;117    #if defined(PWR_CR5_R1MODE)
;;;118        if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
;;;119        {
;;;120          return PWR_REGULATOR_VOLTAGE_SCALE2;
;;;121        }
;;;122        else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
;;;123        {
;;;124          /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
;;;125          return PWR_REGULATOR_VOLTAGE_SCALE1;
;;;126        }
;;;127        else
;;;128        {
;;;129          return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
;;;130        }
;;;131    #else
;;;132      return  (PWR->CR1 & PWR_CR1_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f40060c0          AND      r0,r0,#0x600
;;;133    #endif
;;;134    }
000008  4770              BX       lr
;;;135    
                          ENDP

00000a  0000              DCW      0x0000
                  |L33.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_PVD_PVM_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_PVD_PVM_IRQHandler PROC
;;;1359     */
;;;1360   void HAL_PWREx_PVD_PVM_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1361   {
;;;1362     /* Check PWR exti flag */
;;;1363     if(__HAL_PWR_PVD_EXTI_GET_FLAG() != 0x0U)
000002  4c14              LDR      r4,|L34.84|
000004  6820              LDR      r0,[r4,#0]
000006  03c0              LSLS     r0,r0,#15
000008  d504              BPL      |L34.20|
;;;1364     {
;;;1365       /* PWR PVD interrupt user callback */
;;;1366       HAL_PWR_PVDCallback();
00000a  f7fffffe          BL       HAL_PWR_PVDCallback
;;;1367   
;;;1368       /* Clear PVD exti pending bit */
;;;1369       __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
00000e  f44f3080          MOV      r0,#0x10000
000012  6020              STR      r0,[r4,#0]
                  |L34.20|
;;;1370     }
;;;1371     /* Next, successively check PVMx exti flags */
;;;1372   #if defined(PWR_CR2_PVME1)
;;;1373     if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != 0x0U)
000014  4c0f              LDR      r4,|L34.84|
000016  3420              ADDS     r4,r4,#0x20
000018  6820              LDR      r0,[r4,#0]
00001a  0700              LSLS     r0,r0,#28
00001c  d503              BPL      |L34.38|
;;;1374     {
;;;1375       /* PWR PVM1 interrupt user callback */
;;;1376       HAL_PWREx_PVM1Callback();
00001e  f7fffffe          BL       HAL_PWREx_PVM1Callback
;;;1377   
;;;1378       /* Clear PVM1 exti pending bit */
;;;1379       __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
000022  2008              MOVS     r0,#8
000024  6020              STR      r0,[r4,#0]
                  |L34.38|
;;;1380     }
;;;1381   #endif /* PWR_CR2_PVME1 */
;;;1382   #if defined(PWR_CR2_PVME2)
;;;1383     if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != 0x0U)
000026  6820              LDR      r0,[r4,#0]
000028  06c0              LSLS     r0,r0,#27
00002a  d503              BPL      |L34.52|
;;;1384     {
;;;1385       /* PWR PVM2 interrupt user callback */
;;;1386       HAL_PWREx_PVM2Callback();
00002c  f7fffffe          BL       HAL_PWREx_PVM2Callback
;;;1387   
;;;1388       /* Clear PVM2 exti pending bit */
;;;1389       __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
000030  2010              MOVS     r0,#0x10
000032  6020              STR      r0,[r4,#0]
                  |L34.52|
;;;1390     }
;;;1391   #endif /* PWR_CR2_PVME2 */
;;;1392     if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != 0x0U)
000034  6820              LDR      r0,[r4,#0]
000036  0680              LSLS     r0,r0,#26
000038  d503              BPL      |L34.66|
;;;1393     {
;;;1394       /* PWR PVM3 interrupt user callback */
;;;1395       HAL_PWREx_PVM3Callback();
00003a  f7fffffe          BL       HAL_PWREx_PVM3Callback
;;;1396   
;;;1397       /* Clear PVM3 exti pending bit */
;;;1398       __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
00003e  2020              MOVS     r0,#0x20
000040  6020              STR      r0,[r4,#0]
                  |L34.66|
;;;1399     }
;;;1400     if(__HAL_PWR_PVM4_EXTI_GET_FLAG() != 0x0U)
000042  6820              LDR      r0,[r4,#0]
000044  0640              LSLS     r0,r0,#25
000046  d503              BPL      |L34.80|
;;;1401     {
;;;1402       /* PWR PVM4 interrupt user callback */
;;;1403       HAL_PWREx_PVM4Callback();
000048  f7fffffe          BL       HAL_PWREx_PVM4Callback
;;;1404   
;;;1405       /* Clear PVM4 exti pending bit */
;;;1406       __HAL_PWR_PVM4_EXTI_CLEAR_FLAG();
00004c  2040              MOVS     r0,#0x40
00004e  6020              STR      r0,[r4,#0]
                  |L34.80|
;;;1407     }
;;;1408   }
000050  bd10              POP      {r4,pc}
;;;1409   
                          ENDP

000052  0000              DCW      0x0000
                  |L34.84|
                          DCD      0x40010414

                          AREA ||i.HAL_PWREx_PVM1Callback||, CODE, READONLY, ALIGN=1

                  HAL_PWREx_PVM1Callback PROC
;;;1415     */
;;;1416   __weak void HAL_PWREx_PVM1Callback(void)
000000  4770              BX       lr
;;;1417   {
;;;1418     /* NOTE : This function should not be modified; when the callback is needed,
;;;1419               HAL_PWREx_PVM1Callback() API can be implemented in the user file
;;;1420      */
;;;1421   }
;;;1422   #endif /* PWR_CR2_PVME1 */
                          ENDP


                          AREA ||i.HAL_PWREx_PVM2Callback||, CODE, READONLY, ALIGN=1

                  HAL_PWREx_PVM2Callback PROC
;;;1428     */
;;;1429   __weak void HAL_PWREx_PVM2Callback(void)
000000  4770              BX       lr
;;;1430   {
;;;1431     /* NOTE : This function should not be modified; when the callback is needed,
;;;1432               HAL_PWREx_PVM2Callback() API can be implemented in the user file
;;;1433      */
;;;1434   }
;;;1435   #endif /* PWR_CR2_PVME2 */
                          ENDP


                          AREA ||i.HAL_PWREx_PVM3Callback||, CODE, READONLY, ALIGN=1

                  HAL_PWREx_PVM3Callback PROC
;;;1440     */
;;;1441   __weak void HAL_PWREx_PVM3Callback(void)
000000  4770              BX       lr
;;;1442   {
;;;1443     /* NOTE : This function should not be modified; when the callback is needed,
;;;1444               HAL_PWREx_PVM3Callback() API can be implemented in the user file
;;;1445      */
;;;1446   }
;;;1447   
                          ENDP


                          AREA ||i.HAL_PWREx_PVM4Callback||, CODE, READONLY, ALIGN=1

                  HAL_PWREx_PVM4Callback PROC
;;;1451     */
;;;1452   __weak void HAL_PWREx_PVM4Callback(void)
000000  4770              BX       lr
;;;1453   {
;;;1454     /* NOTE : This function should not be modified; when the callback is needed,
;;;1455               HAL_PWREx_PVM4Callback() API can be implemented in the user file
;;;1456      */
;;;1457   }
;;;1458   
                          ENDP


                          AREA ||i.HAL_PWREx_SetSRAM2ContentRetention||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_SetSRAM2ContentRetention PROC
;;;751      */
;;;752    HAL_StatusTypeDef HAL_PWREx_SetSRAM2ContentRetention(uint32_t SRAM2Size)
000000  4909              LDR      r1,|L39.40|
;;;753    {
;;;754      assert_param(IS_PWR_SRAM2_RETENTION(SRAM2Size));
;;;755    
;;;756      if (SRAM2Size == PWR_NO_SRAM2_RETENTION)
000002  2800              CMP      r0,#0
000004  d004              BEQ      |L39.16|
;;;757      {
;;;758        CLEAR_BIT(PWR->CR3, PWR_CR3_RRS);
;;;759      }
;;;760      else if (SRAM2Size == PWR_FULL_SRAM2_RETENTION)
000006  f5b07f80          CMP      r0,#0x100
00000a  d006              BEQ      |L39.26|
;;;761      {
;;;762        MODIFY_REG(PWR->CR3, PWR_CR3_RRS, PWR_FULL_SRAM2_RETENTION);
;;;763      }
;;;764    #if defined(PWR_CR3_RRS_1)
;;;765      else if (SRAM2Size == PWR_4KBYTES_SRAM2_RETENTION)
;;;766      {
;;;767        MODIFY_REG(PWR->CR3, PWR_CR3_RRS, PWR_4KBYTES_SRAM2_RETENTION);
;;;768      }
;;;769    #endif /* PWR_CR3_RRS_1 */
;;;770      else {
;;;771        return HAL_ERROR;
00000c  2001              MOVS     r0,#1
;;;772      }
;;;773    
;;;774      return HAL_OK;
;;;775    }
00000e  4770              BX       lr
                  |L39.16|
000010  6888              LDR      r0,[r1,#8]            ;758
000012  f4207080          BIC      r0,r0,#0x100          ;758
000016  6088              STR      r0,[r1,#8]            ;758
000018  e003              B        |L39.34|
                  |L39.26|
00001a  6888              LDR      r0,[r1,#8]            ;762
00001c  f4407080          ORR      r0,r0,#0x100          ;762
000020  6088              STR      r0,[r1,#8]            ;762
                  |L39.34|
000022  2000              MOVS     r0,#0                 ;774
000024  4770              BX       lr
;;;776    
                          ENDP

000026  0000              DCW      0x0000
                  |L39.40|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_pwr_ex_c_93c7a9b9____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_pwr_ex_c_93c7a9b9____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_pwr_ex_c_93c7a9b9____REVSH|
#line 507
|__asm___22_stm32l4xx_hal_pwr_ex_c_93c7a9b9____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_pwr_ex_c_93c7a9b9____RRX|
#line 694
|__asm___22_stm32l4xx_hal_pwr_ex_c_93c7a9b9____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
