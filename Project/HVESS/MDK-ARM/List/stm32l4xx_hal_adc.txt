; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_adc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_adc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_ConversionStop||, CODE, READONLY, ALIGN=2

                  ADC_ConversionStop PROC
;;;3260     */
;;;3261   HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc, uint32_t ConversionGroup)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3262   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;3263     uint32_t tickstart;
;;;3264     uint32_t Conversion_Timeout_CPU_cycles = 0UL;
000008  2500              MOVS     r5,#0
;;;3265     uint32_t conversion_group_reassigned = ConversionGroup;
;;;3266     uint32_t tmp_ADC_CR_ADSTART_JADSTART;
;;;3267     uint32_t tmp_adc_is_conversion_on_going_regular;
;;;3268     uint32_t tmp_adc_is_conversion_on_going_injected;
;;;3269   
;;;3270     /* Check the parameters */
;;;3271     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;3272     assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));
;;;3273   
;;;3274     /* Verification if ADC is not already stopped (on regular and injected      */
;;;3275     /* groups) to bypass this function if not needed.                           */
;;;3276     tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000010  4607              MOV      r7,r0
;;;3277     tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
;;;3278     if ((tmp_adc_is_conversion_on_going_regular != 0UL)
000018  4307              ORRS     r7,r7,r0
00001a  d065              BEQ      |L1.232|
;;;3279         || (tmp_adc_is_conversion_on_going_injected != 0UL)
;;;3280        )
;;;3281     {
;;;3282       /* Particular case of continuous auto-injection mode combined with        */
;;;3283       /* auto-delay mode.                                                       */
;;;3284       /* In auto-injection mode, regular group stop ADC_CR_ADSTP is used (not   */
;;;3285       /* injected group stop ADC_CR_JADSTP).                                    */
;;;3286       /* Procedure to be followed: Wait until JEOS=1, clear JEOS, set ADSTP=1   */
;;;3287       /* (see reference manual).                                                */
;;;3288       if (((hadc->Instance->CFGR & ADC_CFGR_JAUTO) != 0UL)
00001c  6820              LDR      r0,[r4,#0]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  0189              LSLS     r1,r1,#6
000022  d51c              BPL      |L1.94|
;;;3289           && (hadc->Init.ContinuousConvMode == ENABLE)
000024  7e61              LDRB     r1,[r4,#0x19]
000026  2901              CMP      r1,#1
000028  d119              BNE      |L1.94|
;;;3290           && (hadc->Init.LowPowerAutoWait == ENABLE)
00002a  7e21              LDRB     r1,[r4,#0x18]
00002c  2901              CMP      r1,#1
00002e  d116              BNE      |L1.94|
;;;3291          )
;;;3292       {
;;;3293         /* Use stop of regular group */
;;;3294         conversion_group_reassigned = ADC_REGULAR_GROUP;
000030  2601              MOVS     r6,#1
;;;3295   
;;;3296         /* Wait until JEOS=1 (maximum Timeout: 4 injected conversions) */
;;;3297         while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
;;;3298         {
;;;3299           if (Conversion_Timeout_CPU_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES * 4UL))
000032  492e              LDR      r1,|L1.236|
000034  e00d              B        |L1.82|
                  |L1.54|
000036  428d              CMP      r5,r1
000038  d30a              BCC      |L1.80|
;;;3300           {
;;;3301             /* Update ADC state machine to error */
;;;3302             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
00003a  6da0              LDR      r0,[r4,#0x58]
00003c  f0400010          ORR      r0,r0,#0x10
000040  65a0              STR      r0,[r4,#0x58]
;;;3303   
;;;3304             /* Set ADC error code to ADC peripheral internal error */
;;;3305             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000042  6de0              LDR      r0,[r4,#0x5c]
000044  f0400001          ORR      r0,r0,#1
000048  65e0              STR      r0,[r4,#0x5c]
;;;3306   
;;;3307             return HAL_ERROR;
00004a  2001              MOVS     r0,#1
                  |L1.76|
;;;3308           }
;;;3309           Conversion_Timeout_CPU_cycles ++;
;;;3310         }
;;;3311   
;;;3312         /* Clear JEOS */
;;;3313         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
;;;3314       }
;;;3315   
;;;3316       /* Stop potential conversion on going on ADC group regular */
;;;3317       if (conversion_group_reassigned != ADC_INJECTED_GROUP)
;;;3318       {
;;;3319         /* Software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 */
;;;3320         if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
;;;3321         {
;;;3322           if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
;;;3323           {
;;;3324             /* Stop ADC group regular conversion */
;;;3325             LL_ADC_REG_StopConversion(hadc->Instance);
;;;3326           }
;;;3327         }
;;;3328       }
;;;3329   
;;;3330       /* Stop potential conversion on going on ADC group injected */
;;;3331       if (conversion_group_reassigned != ADC_REGULAR_GROUP)
;;;3332       {
;;;3333         /* Software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 */
;;;3334         if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
;;;3335         {
;;;3336           if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
;;;3337           {
;;;3338             /* Stop ADC group injected conversion */
;;;3339             LL_ADC_INJ_StopConversion(hadc->Instance);
;;;3340           }
;;;3341         }
;;;3342       }
;;;3343   
;;;3344       /* Selection of start and stop bits with respect to the regular or injected group */
;;;3345       switch (conversion_group_reassigned)
;;;3346       {
;;;3347         case ADC_REGULAR_INJECTED_GROUP:
;;;3348           tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
;;;3349           break;
;;;3350         case ADC_INJECTED_GROUP:
;;;3351           tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
;;;3352           break;
;;;3353         /* Case ADC_REGULAR_GROUP only*/
;;;3354         default:
;;;3355           tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
;;;3356           break;
;;;3357       }
;;;3358   
;;;3359       /* Wait for conversion effectively stopped */
;;;3360       tickstart = HAL_GetTick();
;;;3361   
;;;3362       while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
;;;3363       {
;;;3364         if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
;;;3365         {
;;;3366           /* New check to avoid false timeout detection in case of preemption */
;;;3367           if ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
;;;3368           {
;;;3369             /* Update ADC state machine to error */
;;;3370             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;3371   
;;;3372             /* Set ADC error code to ADC peripheral internal error */
;;;3373             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;3374   
;;;3375             return HAL_ERROR;
;;;3376           }
;;;3377         }
;;;3378       }
;;;3379   
;;;3380     }
;;;3381   
;;;3382     /* Return HAL status */
;;;3383     return HAL_OK;
;;;3384   }
00004c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.80|
000050  1c6d              ADDS     r5,r5,#1              ;3309
                  |L1.82|
000052  6802              LDR      r2,[r0,#0]            ;3297
000054  43d2              MVNS     r2,r2                 ;3297
000056  0652              LSLS     r2,r2,#25             ;3297
000058  d4ed              BMI      |L1.54|
00005a  2140              MOVS     r1,#0x40              ;3313
00005c  6001              STR      r1,[r0,#0]            ;3313
                  |L1.94|
00005e  4d24              LDR      r5,|L1.240|
000060  2e02              CMP      r6,#2                 ;3317
000062  d00d              BEQ      |L1.128|
000064  6820              LDR      r0,[r4,#0]            ;3320
000066  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00006a  b148              CBZ      r0,|L1.128|
00006c  6820              LDR      r0,[r4,#0]            ;3322
00006e  6881              LDR      r1,[r0,#8]            ;3322
000070  f3c10140          UBFX     r1,r1,#1,#1           ;3322
000074  b921              CBNZ     r1,|L1.128|
000076  6881              LDR      r1,[r0,#8]            ;3322
000078  4029              ANDS     r1,r1,r5              ;3322
00007a  f0410110          ORR      r1,r1,#0x10           ;3322
00007e  6081              STR      r1,[r0,#8]            ;3322
                  |L1.128|
000080  2e01              CMP      r6,#1                 ;3331
000082  d00d              BEQ      |L1.160|
000084  6820              LDR      r0,[r4,#0]            ;3334
000086  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
00008a  b148              CBZ      r0,|L1.160|
00008c  6820              LDR      r0,[r4,#0]            ;3336
00008e  6881              LDR      r1,[r0,#8]            ;3336
000090  f3c10140          UBFX     r1,r1,#1,#1           ;3336
000094  b921              CBNZ     r1,|L1.160|
000096  6881              LDR      r1,[r0,#8]            ;3336
000098  4029              ANDS     r1,r1,r5              ;3336
00009a  f0410120          ORR      r1,r1,#0x20           ;3336
00009e  6081              STR      r1,[r0,#8]            ;3336
                  |L1.160|
0000a0  2e02              CMP      r6,#2                 ;3345
0000a2  d008              BEQ      |L1.182|
0000a4  2e03              CMP      r6,#3                 ;3345
0000a6  d004              BEQ      |L1.178|
0000a8  2504              MOVS     r5,#4                 ;3355
                  |L1.170|
0000aa  f7fffffe          BL       HAL_GetTick
0000ae  4606              MOV      r6,r0                 ;3360
0000b0  e016              B        |L1.224|
                  |L1.178|
0000b2  250c              MOVS     r5,#0xc               ;3348
0000b4  e7f9              B        |L1.170|
                  |L1.182|
0000b6  2508              MOVS     r5,#8                 ;3351
0000b8  e7f7              B        |L1.170|
                  |L1.186|
0000ba  f7fffffe          BL       HAL_GetTick
0000be  1b80              SUBS     r0,r0,r6              ;3364
0000c0  2805              CMP      r0,#5                 ;3364
0000c2  d90d              BLS      |L1.224|
0000c4  6820              LDR      r0,[r4,#0]            ;3367
0000c6  6880              LDR      r0,[r0,#8]            ;3367
0000c8  4228              TST      r0,r5                 ;3367
0000ca  d009              BEQ      |L1.224|
0000cc  6da0              LDR      r0,[r4,#0x58]         ;3370
0000ce  f0400010          ORR      r0,r0,#0x10           ;3370
0000d2  65a0              STR      r0,[r4,#0x58]         ;3370
0000d4  6de0              LDR      r0,[r4,#0x5c]         ;3373
0000d6  f0400001          ORR      r0,r0,#1              ;3373
0000da  65e0              STR      r0,[r4,#0x5c]         ;3373
0000dc  2001              MOVS     r0,#1                 ;3375
0000de  e7b5              B        |L1.76|
                  |L1.224|
0000e0  6820              LDR      r0,[r4,#0]            ;3362
0000e2  6880              LDR      r0,[r0,#8]            ;3362
0000e4  4228              TST      r0,r5                 ;3362
0000e6  d1e8              BNE      |L1.186|
                  |L1.232|
0000e8  2000              MOVS     r0,#0                 ;3383
0000ea  e7af              B        |L1.76|
;;;3385   
                          ENDP

                  |L1.236|
                          DCD      0xa3400000
                  |L1.240|
                          DCD      0x7fffffc0

                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;3526     */
;;;3527   void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3528   {
;;;3529     /* Retrieve ADC handle corresponding to current DMA handle */
;;;3530     ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;3531   
;;;3532     /* Update state machine on conversion status if not in error state */
;;;3533     if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
000004  6da1              LDR      r1,[r4,#0x58]
000006  f0110f50          TST      r1,#0x50
00000a  d006              BEQ      |L2.26|
;;;3534     {
;;;3535       /* Set ADC state */
;;;3536       SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;3537   
;;;3538       /* Determine whether any further conversion upcoming on group regular     */
;;;3539       /* by external trigger, continuous mode or scan sequence on going         */
;;;3540       /* to disable interruption.                                               */
;;;3541       /* Is it the end of the regular sequence ? */
;;;3542       if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
;;;3543       {
;;;3544         /* Are conversions software-triggered ? */
;;;3545         if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
;;;3546         {
;;;3547           /* Is CONT bit set ? */
;;;3548           if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
;;;3549           {
;;;3550             /* CONT bit is not set, no more conversions expected */
;;;3551             CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;3552             if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
;;;3553             {
;;;3554               SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;3555             }
;;;3556           }
;;;3557         }
;;;3558       }
;;;3559       else
;;;3560       {
;;;3561         /* DMA End of Transfer interrupt was triggered but conversions sequence
;;;3562            is not over. If DMACFG is set to 0, conversions are stopped. */
;;;3563         if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMACFG) == 0UL)
;;;3564         {
;;;3565           /* DMACFG bit is not set, conversions are stopped. */
;;;3566           CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;3567           if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
;;;3568           {
;;;3569             SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;3570           }
;;;3571         }
;;;3572       }
;;;3573   
;;;3574       /* Conversion complete callback */
;;;3575   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;3576       hadc->ConvCpltCallback(hadc);
;;;3577   #else
;;;3578       HAL_ADC_ConvCpltCallback(hadc);
;;;3579   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;3580     }
;;;3581     else /* DMA and-or internal error occurred */
;;;3582     {
;;;3583       if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
00000c  6da1              LDR      r1,[r4,#0x58]
00000e  06c9              LSLS     r1,r1,#27
000010  d530              BPL      |L2.116|
;;;3584       {
;;;3585         /* Call HAL ADC Error Callback function */
;;;3586   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;3587         hadc->ErrorCallback(hadc);
;;;3588   #else
;;;3589         HAL_ADC_ErrorCallback(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;3590   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;3591       }
;;;3592       else
;;;3593       {
;;;3594         /* Call ADC DMA error callback */
;;;3595         hadc->DMA_Handle->XferErrorCallback(hdma);
;;;3596       }
;;;3597     }
;;;3598   }
000018  bd10              POP      {r4,pc}
                  |L2.26|
00001a  6da0              LDR      r0,[r4,#0x58]         ;3536
00001c  f4407000          ORR      r0,r0,#0x200          ;3536
000020  65a0              STR      r0,[r4,#0x58]         ;3536
000022  6820              LDR      r0,[r4,#0]            ;3542
000024  6801              LDR      r1,[r0,#0]            ;3542
000026  0709              LSLS     r1,r1,#28             ;3542
000028  d512              BPL      |L2.80|
00002a  f7fffffe          BL       LL_ADC_REG_IsTriggerSourceSWStart
00002e  b1e8              CBZ      r0,|L2.108|
000030  6820              LDR      r0,[r4,#0]            ;3548
000032  68c0              LDR      r0,[r0,#0xc]          ;3548
000034  0480              LSLS     r0,r0,#18             ;3548
000036  d419              BMI      |L2.108|
000038  6da0              LDR      r0,[r4,#0x58]         ;3551
00003a  f4207080          BIC      r0,r0,#0x100          ;3551
00003e  65a0              STR      r0,[r4,#0x58]         ;3551
000040  6da0              LDR      r0,[r4,#0x58]         ;3552
000042  04c0              LSLS     r0,r0,#19             ;3552
000044  d412              BMI      |L2.108|
000046  6da0              LDR      r0,[r4,#0x58]         ;3554
000048  f0400001          ORR      r0,r0,#1              ;3554
00004c  65a0              STR      r0,[r4,#0x58]         ;3554
00004e  e00d              B        |L2.108|
                  |L2.80|
000050  68c0              LDR      r0,[r0,#0xc]          ;3563
000052  0780              LSLS     r0,r0,#30             ;3563
000054  d40a              BMI      |L2.108|
000056  6da0              LDR      r0,[r4,#0x58]         ;3566
000058  f4207080          BIC      r0,r0,#0x100          ;3566
00005c  65a0              STR      r0,[r4,#0x58]         ;3566
00005e  6da0              LDR      r0,[r4,#0x58]         ;3567
000060  04c0              LSLS     r0,r0,#19             ;3567
000062  d403              BMI      |L2.108|
000064  6da0              LDR      r0,[r4,#0x58]         ;3569
000066  f0400001          ORR      r0,r0,#1              ;3569
00006a  65a0              STR      r0,[r4,#0x58]         ;3569
                  |L2.108|
00006c  4620              MOV      r0,r4                 ;3578
00006e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
000072  bd10              POP      {r4,pc}
                  |L2.116|
000074  6d21              LDR      r1,[r4,#0x50]         ;3595
000076  6b49              LDR      r1,[r1,#0x34]         ;3595
000078  e8bd4010          POP      {r4,lr}               ;3595
00007c  4708              BX       r1                    ;3595
;;;3599   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;3622     */
;;;3623   void ADC_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3624   {
;;;3625     /* Retrieve ADC handle corresponding to current DMA handle */
;;;3626     ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;3627   
;;;3628     /* Set ADC state */
;;;3629     SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
000004  6d81              LDR      r1,[r0,#0x58]
000006  f0410140          ORR      r1,r1,#0x40
00000a  6581              STR      r1,[r0,#0x58]
;;;3630   
;;;3631     /* Set ADC error code to DMA error */
;;;3632     SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
00000c  6dc1              LDR      r1,[r0,#0x5c]
00000e  f0410104          ORR      r1,r1,#4
000012  65c1              STR      r1,[r0,#0x5c]
;;;3633   
;;;3634     /* Error callback */
;;;3635   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;3636     hadc->ErrorCallback(hadc);
;;;3637   #else
;;;3638     HAL_ADC_ErrorCallback(hadc);
000014  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;3639   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;3640   }
000018  bd10              POP      {r4,pc}
;;;3641   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;3604     */
;;;3605   void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3606   {
;;;3607     /* Retrieve ADC handle corresponding to current DMA handle */
;;;3608     ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;3609   
;;;3610     /* Half conversion callback */
;;;3611   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;3612     hadc->ConvHalfCpltCallback(hadc);
;;;3613   #else
;;;3614     HAL_ADC_ConvHalfCpltCallback(hadc);
000004  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;3615   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;3616   }
000008  bd10              POP      {r4,pc}
;;;3617   
                          ENDP


                          AREA ||i.ADC_Disable||, CODE, READONLY, ALIGN=2

                  ADC_Disable PROC
;;;3464     */
;;;3465   HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;3466   {
000002  4604              MOV      r4,r0
;;;3467     uint32_t tickstart;
;;;3468     const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
000004  6820              LDR      r0,[r4,#0]
000006  6881              LDR      r1,[r0,#8]
000008  f3c10540          UBFX     r5,r1,#1,#1
;;;3469   
;;;3470     /* Verification if ADC is not already disabled:                             */
;;;3471     /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
;;;3472     /*       disabled.                                                          */
;;;3473     if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
00000c  f7fffffe          BL       LL_ADC_IsEnabled
000010  b378              CBZ      r0,|L5.114|
;;;3474         && (tmp_adc_is_disable_on_going == 0UL)
000012  bb75              CBNZ     r5,|L5.114|
;;;3475        )
;;;3476     {
;;;3477       /* Check if conditions to disable the ADC are fulfilled */
;;;3478       if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
000014  6820              LDR      r0,[r4,#0]
000016  6881              LDR      r1,[r0,#8]
000018  f001010d          AND      r1,r1,#0xd
00001c  2901              CMP      r1,#1
00001e  d009              BEQ      |L5.52|
;;;3479       {
;;;3480         /* Disable the ADC peripheral */
;;;3481         LL_ADC_Disable(hadc->Instance);
;;;3482         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
;;;3483       }
;;;3484       else
;;;3485       {
;;;3486         /* Update ADC state machine to error */
;;;3487         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000020  6da0              LDR      r0,[r4,#0x58]
000022  f0400010          ORR      r0,r0,#0x10
000026  65a0              STR      r0,[r4,#0x58]
;;;3488   
;;;3489         /* Set ADC error code to ADC peripheral internal error */
;;;3490         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000028  6de0              LDR      r0,[r4,#0x5c]
00002a  f0400001          ORR      r0,r0,#1
00002e  65e0              STR      r0,[r4,#0x5c]
;;;3491   
;;;3492         return HAL_ERROR;
000030  2001              MOVS     r0,#1
;;;3493       }
;;;3494   
;;;3495       /* Wait for ADC effectively disabled */
;;;3496       /* Get tick count */
;;;3497       tickstart = HAL_GetTick();
;;;3498   
;;;3499       while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
;;;3500       {
;;;3501         if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
;;;3502         {
;;;3503           /* New check to avoid false timeout detection in case of preemption */
;;;3504           if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
;;;3505           {
;;;3506             /* Update ADC state machine to error */
;;;3507             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;3508   
;;;3509             /* Set ADC error code to ADC peripheral internal error */
;;;3510             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;3511   
;;;3512             return HAL_ERROR;
;;;3513           }
;;;3514         }
;;;3515       }
;;;3516     }
;;;3517   
;;;3518     /* Return HAL status */
;;;3519     return HAL_OK;
;;;3520   }
000032  bd70              POP      {r4-r6,pc}
                  |L5.52|
000034  6881              LDR      r1,[r0,#8]
000036  4a12              LDR      r2,|L5.128|
000038  4011              ANDS     r1,r1,r2
00003a  1c89              ADDS     r1,r1,#2
00003c  6081              STR      r1,[r0,#8]
00003e  6821              LDR      r1,[r4,#0]            ;3482
000040  2003              MOVS     r0,#3                 ;3482
000042  6008              STR      r0,[r1,#0]            ;3482
000044  f7fffffe          BL       HAL_GetTick
000048  4605              MOV      r5,r0                 ;3497
00004a  e013              B        |L5.116|
                  |L5.76|
00004c  f7fffffe          BL       HAL_GetTick
000050  1b40              SUBS     r0,r0,r5              ;3501
000052  2802              CMP      r0,#2                 ;3501
000054  d90e              BLS      |L5.116|
000056  6820              LDR      r0,[r4,#0]            ;3504
000058  6880              LDR      r0,[r0,#8]            ;3504
00005a  07c0              LSLS     r0,r0,#31             ;3504
00005c  d00a              BEQ      |L5.116|
00005e  6da0              LDR      r0,[r4,#0x58]         ;3507
000060  f0400010          ORR      r0,r0,#0x10           ;3507
000064  65a0              STR      r0,[r4,#0x58]         ;3507
000066  6de0              LDR      r0,[r4,#0x5c]         ;3510
000068  f0400001          ORR      r0,r0,#1              ;3510
00006c  65e0              STR      r0,[r4,#0x5c]         ;3510
00006e  2001              MOVS     r0,#1                 ;3512
                  |L5.112|
000070  bd70              POP      {r4-r6,pc}
                  |L5.114|
000072  e003              B        |L5.124|
                  |L5.116|
000074  6820              LDR      r0,[r4,#0]            ;3499
000076  6880              LDR      r0,[r0,#8]            ;3499
000078  07c0              LSLS     r0,r0,#31             ;3499
00007a  d1e7              BNE      |L5.76|
                  |L5.124|
00007c  2000              MOVS     r0,#0                 ;3519
00007e  e7f7              B        |L5.112|
;;;3521   
                          ENDP

                  |L5.128|
                          DCD      0x7fffffc0

                          AREA ||i.ADC_Enable||, CODE, READONLY, ALIGN=2

                  ADC_Enable PROC
;;;3392     */
;;;3393   HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;3394   {
000002  4604              MOV      r4,r0
;;;3395     uint32_t tickstart;
;;;3396   
;;;3397     /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
;;;3398     /* enabling phase not yet completed: flag ADC ready not yet set).           */
;;;3399     /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
;;;3400     /* causes: ADC clock not running, ...).                                     */
;;;3401     if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       LL_ADC_IsEnabled
00000a  bba0              CBNZ     r0,|L6.118|
;;;3402     {
;;;3403       /* Check if conditions to enable the ADC are fulfilled */
;;;3404       if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  4a1d              LDR      r2,|L6.136|
000012  4211              TST      r1,r2
000014  d009              BEQ      |L6.42|
;;;3405                                  | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
;;;3406       {
;;;3407         /* Update ADC state machine to error */
;;;3408         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000016  6da0              LDR      r0,[r4,#0x58]
000018  f0400010          ORR      r0,r0,#0x10
00001c  65a0              STR      r0,[r4,#0x58]
;;;3409   
;;;3410         /* Set ADC error code to ADC peripheral internal error */
;;;3411         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
00001e  6de0              LDR      r0,[r4,#0x5c]
000020  f0400001          ORR      r0,r0,#1
000024  65e0              STR      r0,[r4,#0x5c]
;;;3412   
;;;3413         return HAL_ERROR;
000026  2001              MOVS     r0,#1
;;;3414       }
;;;3415   
;;;3416       /* Enable the ADC peripheral */
;;;3417       LL_ADC_Enable(hadc->Instance);
;;;3418   
;;;3419       /* Wait for ADC effectively enabled */
;;;3420       tickstart = HAL_GetTick();
;;;3421   
;;;3422       while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
;;;3423       {
;;;3424         /*  If ADEN bit is set less than 4 ADC clock cycles after the ADCAL bit
;;;3425             has been cleared (after a calibration), ADEN bit is reset by the
;;;3426             calibration logic.
;;;3427             The workaround is to continue setting ADEN until ADRDY is becomes 1.
;;;3428             Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
;;;3429             4 ADC clock cycle duration */
;;;3430         /* Note: Test of ADC enabled required due to hardware constraint to     */
;;;3431         /*       not enable ADC if already enabled.                             */
;;;3432         if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
;;;3433         {
;;;3434           LL_ADC_Enable(hadc->Instance);
;;;3435         }
;;;3436   
;;;3437         if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
;;;3438         {
;;;3439           /* New check to avoid false timeout detection in case of preemption */
;;;3440           if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
;;;3441           {
;;;3442             /* Update ADC state machine to error */
;;;3443             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;3444   
;;;3445             /* Set ADC error code to ADC peripheral internal error */
;;;3446             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;3447   
;;;3448             return HAL_ERROR;
;;;3449           }
;;;3450         }
;;;3451       }
;;;3452     }
;;;3453   
;;;3454     /* Return HAL status */
;;;3455     return HAL_OK;
;;;3456   }
000028  bd70              POP      {r4-r6,pc}
                  |L6.42|
00002a  6881              LDR      r1,[r0,#8]
00002c  4e16              LDR      r6,|L6.136|
00002e  3e7f              SUBS     r6,r6,#0x7f
000030  4031              ANDS     r1,r1,r6
000032  1c49              ADDS     r1,r1,#1
000034  6081              STR      r1,[r0,#8]
000036  f7fffffe          BL       HAL_GetTick
00003a  4605              MOV      r5,r0                 ;3420
00003c  e01c              B        |L6.120|
                  |L6.62|
00003e  f7fffffe          BL       LL_ADC_IsEnabled
000042  b920              CBNZ     r0,|L6.78|
000044  6820              LDR      r0,[r4,#0]            ;3434
000046  6881              LDR      r1,[r0,#8]            ;3434
000048  4031              ANDS     r1,r1,r6              ;3434
00004a  1c49              ADDS     r1,r1,#1              ;3434
00004c  6081              STR      r1,[r0,#8]            ;3434
                  |L6.78|
00004e  f7fffffe          BL       HAL_GetTick
000052  1b40              SUBS     r0,r0,r5              ;3437
000054  2802              CMP      r0,#2                 ;3437
000056  d90f              BLS      |L6.120|
000058  6820              LDR      r0,[r4,#0]            ;3440
00005a  6800              LDR      r0,[r0,#0]            ;3440
00005c  43c0              MVNS     r0,r0                 ;3440
00005e  07c0              LSLS     r0,r0,#31             ;3440
000060  d00a              BEQ      |L6.120|
000062  6da0              LDR      r0,[r4,#0x58]         ;3443
000064  f0400010          ORR      r0,r0,#0x10           ;3443
000068  65a0              STR      r0,[r4,#0x58]         ;3443
00006a  6de0              LDR      r0,[r4,#0x5c]         ;3446
00006c  f0400001          ORR      r0,r0,#1              ;3446
000070  65e0              STR      r0,[r4,#0x5c]         ;3446
000072  2001              MOVS     r0,#1                 ;3448
                  |L6.116|
000074  bd70              POP      {r4-r6,pc}
                  |L6.118|
000076  e004              B        |L6.130|
                  |L6.120|
000078  6820              LDR      r0,[r4,#0]            ;3422
00007a  6801              LDR      r1,[r0,#0]            ;3422
00007c  43c9              MVNS     r1,r1                 ;3422
00007e  07c9              LSLS     r1,r1,#31             ;3422
000080  d1dd              BNE      |L6.62|
                  |L6.130|
000082  2000              MOVS     r0,#0                 ;3455
000084  e7f6              B        |L6.116|
;;;3457   
                          ENDP

000086  0000              DCW      0x0000
                  |L6.136|
                          DCD      0x8000003f

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;2962     */
;;;2963   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef *hadc, ADC_AnalogWDGConfTypeDef *AnalogWDGConfig)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2964   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2965     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000008  f04f0a00          MOV      r10,#0
;;;2966     uint32_t tmpAWDHighThresholdShifted;
;;;2967     uint32_t tmpAWDLowThresholdShifted;
;;;2968     uint32_t tmp_adc_is_conversion_on_going_regular;
;;;2969     uint32_t tmp_adc_is_conversion_on_going_injected;
;;;2970   
;;;2971     /* Check the parameters */
;;;2972     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2973     assert_param(IS_ADC_ANALOG_WATCHDOG_NUMBER(AnalogWDGConfig->WatchdogNumber));
;;;2974     assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
;;;2975     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;2976   
;;;2977     if ((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
00000c  f44f0740          MOV      r7,#0xc00000
;;;2978         (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
000010  f04f78a0          MOV      r8,#0x1400000
;;;2979         (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC))
000014  f04f79e0          MOV      r9,#0x1c00000
;;;2980     {
;;;2981       assert_param(IS_ADC_CHANNEL(hadc, AnalogWDGConfig->Channel));
;;;2982     }
;;;2983   
;;;2984     /* Verify thresholds range */
;;;2985     if (hadc->Init.OversamplingMode == ENABLE)
;;;2986     {
;;;2987       /* Case of oversampling enabled: depending on ratio and shift configuration,
;;;2988          analog watchdog thresholds can be higher than ADC resolution.
;;;2989          Verify if thresholds are within maximum thresholds range. */
;;;2990       assert_param(IS_ADC_RANGE(ADC_RESOLUTION_12B, AnalogWDGConfig->HighThreshold));
;;;2991       assert_param(IS_ADC_RANGE(ADC_RESOLUTION_12B, AnalogWDGConfig->LowThreshold));
;;;2992     }
;;;2993     else
;;;2994     {
;;;2995       /* Verify if thresholds are within the selected ADC resolution */
;;;2996       assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), AnalogWDGConfig->HighThreshold));
;;;2997       assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), AnalogWDGConfig->LowThreshold));
;;;2998     }
;;;2999   
;;;3000     /* Process locked */
;;;3001     __HAL_LOCK(hadc);
000018  f8940054          LDRB     r0,[r4,#0x54]
00001c  2801              CMP      r0,#1
00001e  d017              BEQ      |L7.80|
000020  2601              MOVS     r6,#1
000022  f8846054          STRB     r6,[r4,#0x54]
;;;3002   
;;;3003     /* Parameters update conditioned to ADC state:                              */
;;;3004     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;3005     /* conversion on going on ADC groups regular and injected:                  */
;;;3006     /*  - Analog watchdog channels                                              */
;;;3007     /*  - Analog watchdog thresholds                                            */
;;;3008     tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00002c  4683              MOV      r11,r0
;;;3009     tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
;;;3010     if ((tmp_adc_is_conversion_on_going_regular == 0UL)
000034  ea5b0b00          ORRS     r11,r11,r0
000038  d00c              BEQ      |L7.84|
;;;3011         && (tmp_adc_is_conversion_on_going_injected == 0UL)
;;;3012        )
;;;3013     {
;;;3014       /* Analog watchdog configuration */
;;;3015       if (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
;;;3016       {
;;;3017         /* Configuration of analog watchdog:                                    */
;;;3018         /*  - Set the analog watchdog enable mode: one or overall group of      */
;;;3019         /*    channels, on groups regular and-or injected.                      */
;;;3020         switch (AnalogWDGConfig->WatchdogMode)
;;;3021         {
;;;3022           case ADC_ANALOGWATCHDOG_SINGLE_REG:
;;;3023             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, __LL_ADC_ANALOGWD_CHANNEL_GROUP(AnalogWDGConfig->Channel,
;;;3024                                             LL_ADC_GROUP_REGULAR));
;;;3025             break;
;;;3026   
;;;3027           case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
;;;3028             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, __LL_ADC_ANALOGWD_CHANNEL_GROUP(AnalogWDGConfig->Channel,
;;;3029                                             LL_ADC_GROUP_INJECTED));
;;;3030             break;
;;;3031   
;;;3032           case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
;;;3033             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, __LL_ADC_ANALOGWD_CHANNEL_GROUP(AnalogWDGConfig->Channel,
;;;3034                                             LL_ADC_GROUP_REGULAR_INJECTED));
;;;3035             break;
;;;3036   
;;;3037           case ADC_ANALOGWATCHDOG_ALL_REG:
;;;3038             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG);
;;;3039             break;
;;;3040   
;;;3041           case ADC_ANALOGWATCHDOG_ALL_INJEC:
;;;3042             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_INJ);
;;;3043             break;
;;;3044   
;;;3045           case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
;;;3046             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG_INJ);
;;;3047             break;
;;;3048   
;;;3049           default: /* ADC_ANALOGWATCHDOG_NONE */
;;;3050             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_DISABLE);
;;;3051             break;
;;;3052         }
;;;3053   
;;;3054         /* Shift the offset in function of the selected ADC resolution:         */
;;;3055         /* Thresholds have to be left-aligned on bit 11, the LSB (right bits)   */
;;;3056         /* are set to 0                                                         */
;;;3057         tmpAWDHighThresholdShifted = ADC_AWD1THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->HighThreshold);
;;;3058         tmpAWDLowThresholdShifted  = ADC_AWD1THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->LowThreshold);
;;;3059   
;;;3060         /* Set ADC analog watchdog thresholds value of both thresholds high and low */
;;;3061         LL_ADC_ConfigAnalogWDThresholds(hadc->Instance, AnalogWDGConfig->WatchdogNumber, tmpAWDHighThresholdShifted,
;;;3062                                         tmpAWDLowThresholdShifted);
;;;3063   
;;;3064         /* Update state, clear previous result related to AWD1 */
;;;3065         CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;3066   
;;;3067         /* Clear flag ADC analog watchdog */
;;;3068         /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
;;;3069         /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
;;;3070         /* (in case left enabled by previous ADC operations).                 */
;;;3071         LL_ADC_ClearFlag_AWD1(hadc->Instance);
;;;3072   
;;;3073         /* Configure ADC analog watchdog interrupt */
;;;3074         if (AnalogWDGConfig->ITMode == ENABLE)
;;;3075         {
;;;3076           LL_ADC_EnableIT_AWD1(hadc->Instance);
;;;3077         }
;;;3078         else
;;;3079         {
;;;3080           LL_ADC_DisableIT_AWD1(hadc->Instance);
;;;3081         }
;;;3082       }
;;;3083       /* Case of ADC_ANALOGWATCHDOG_2 or ADC_ANALOGWATCHDOG_3 */
;;;3084       else
;;;3085       {
;;;3086         switch (AnalogWDGConfig->WatchdogMode)
;;;3087         {
;;;3088           case ADC_ANALOGWATCHDOG_SINGLE_REG:
;;;3089           case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
;;;3090           case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
;;;3091             /* Update AWD by bitfield to keep the possibility to monitor        */
;;;3092             /* several channels by successive calls of this function.           */
;;;3093             if (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
;;;3094             {
;;;3095               SET_BIT(hadc->Instance->AWD2CR, (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(AnalogWDGConfig->Channel) & 0x1FUL)));
;;;3096             }
;;;3097             else
;;;3098             {
;;;3099               SET_BIT(hadc->Instance->AWD3CR, (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(AnalogWDGConfig->Channel) & 0x1FUL)));
;;;3100             }
;;;3101             break;
;;;3102   
;;;3103           case ADC_ANALOGWATCHDOG_ALL_REG:
;;;3104           case ADC_ANALOGWATCHDOG_ALL_INJEC:
;;;3105           case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
;;;3106             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, AnalogWDGConfig->WatchdogNumber, LL_ADC_AWD_ALL_CHANNELS_REG_INJ);
;;;3107             break;
;;;3108   
;;;3109           default: /* ADC_ANALOGWATCHDOG_NONE */
;;;3110             LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, AnalogWDGConfig->WatchdogNumber, LL_ADC_AWD_DISABLE);
;;;3111             break;
;;;3112         }
;;;3113   
;;;3114         /* Shift the thresholds in function of the selected ADC resolution      */
;;;3115         /* have to be left-aligned on bit 7, the LSB (right bits) are set to 0  */
;;;3116         tmpAWDHighThresholdShifted = ADC_AWD23THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->HighThreshold);
;;;3117         tmpAWDLowThresholdShifted  = ADC_AWD23THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->LowThreshold);
;;;3118   
;;;3119         /* Set ADC analog watchdog thresholds value of both thresholds high and low */
;;;3120         LL_ADC_ConfigAnalogWDThresholds(hadc->Instance, AnalogWDGConfig->WatchdogNumber, tmpAWDHighThresholdShifted,
;;;3121                                         tmpAWDLowThresholdShifted);
;;;3122   
;;;3123         if (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
;;;3124         {
;;;3125           /* Update state, clear previous result related to AWD2 */
;;;3126           CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD2);
;;;3127   
;;;3128           /* Clear flag ADC analog watchdog */
;;;3129           /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
;;;3130           /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
;;;3131           /* (in case left enabled by previous ADC operations).                 */
;;;3132           LL_ADC_ClearFlag_AWD2(hadc->Instance);
;;;3133   
;;;3134           /* Configure ADC analog watchdog interrupt */
;;;3135           if (AnalogWDGConfig->ITMode == ENABLE)
;;;3136           {
;;;3137             LL_ADC_EnableIT_AWD2(hadc->Instance);
;;;3138           }
;;;3139           else
;;;3140           {
;;;3141             LL_ADC_DisableIT_AWD2(hadc->Instance);
;;;3142           }
;;;3143         }
;;;3144         /* (AnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_3) */
;;;3145         else
;;;3146         {
;;;3147           /* Update state, clear previous result related to AWD3 */
;;;3148           CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD3);
;;;3149   
;;;3150           /* Clear flag ADC analog watchdog */
;;;3151           /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
;;;3152           /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
;;;3153           /* (in case left enabled by previous ADC operations).                 */
;;;3154           LL_ADC_ClearFlag_AWD3(hadc->Instance);
;;;3155   
;;;3156           /* Configure ADC analog watchdog interrupt */
;;;3157           if (AnalogWDGConfig->ITMode == ENABLE)
;;;3158           {
;;;3159             LL_ADC_EnableIT_AWD3(hadc->Instance);
;;;3160           }
;;;3161           else
;;;3162           {
;;;3163             LL_ADC_DisableIT_AWD3(hadc->Instance);
;;;3164           }
;;;3165         }
;;;3166       }
;;;3167   
;;;3168     }
;;;3169     /* If a conversion is on going on ADC group regular or injected, no update  */
;;;3170     /* could be done on neither of the AWD configuration structure parameters.  */
;;;3171     else
;;;3172     {
;;;3173       /* Update ADC state machine to error */
;;;3174       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00003a  6da0              LDR      r0,[r4,#0x58]
00003c  f0400020          ORR      r0,r0,#0x20
000040  65a0              STR      r0,[r4,#0x58]
;;;3175   
;;;3176       tmp_hal_status = HAL_ERROR;
000042  46b2              MOV      r10,r6
                  |L7.68|
;;;3177     }
;;;3178     /* Process unlocked */
;;;3179     __HAL_UNLOCK(hadc);
000044  2000              MOVS     r0,#0
000046  f8840054          STRB     r0,[r4,#0x54]
;;;3180   
;;;3181     /* Return function status */
;;;3182     return tmp_hal_status;
00004a  4650              MOV      r0,r10
                  |L7.76|
;;;3183   }
00004c  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.80|
000050  2002              MOVS     r0,#2                 ;3001
000052  e7fb              B        |L7.76|
                  |L7.84|
000054  488b              LDR      r0,|L7.644|
000056  6829              LDR      r1,[r5,#0]            ;3015
000058  4a8b              LDR      r2,|L7.648|
00005a  f44f0300          MOV      r3,#0x800000          ;3020
00005e  f04f7c80          MOV      r12,#0x1000000        ;3020
000062  f04f7ec0          MOV      lr,#0x1800000         ;3020
000066  4281              CMP      r1,r0                 ;3015
000068  d16e              BNE      |L7.328|
00006a  6869              LDR      r1,[r5,#4]            ;3020
00006c  4541              CMP      r1,r8                 ;3020
00006e  d027              BEQ      |L7.192|
000070  dc0c              BGT      |L7.140|
000072  4299              CMP      r1,r3                 ;3020
000074  d02f              BEQ      |L7.214|
000076  42b9              CMP      r1,r7                 ;3020
000078  d017              BEQ      |L7.170|
00007a  4561              CMP      r1,r12                ;3020
00007c  d138              BNE      |L7.240|
00007e  6823              LDR      r3,[r4,#0]            ;3042
000080  4601              MOV      r1,r0                 ;3042
000082  4a82              LDR      r2,|L7.652|
000084  4618              MOV      r0,r3                 ;3042
000086  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
00008a  e037              B        |L7.252|
                  |L7.140|
00008c  4571              CMP      r1,lr                 ;3020
00008e  d029              BEQ      |L7.228|
000090  4549              CMP      r1,r9                 ;3020
000092  d12d              BNE      |L7.240|
000094  68a9              LDR      r1,[r5,#8]            ;3033
000096  6823              LDR      r3,[r4,#0]            ;3033
000098  f021717c          BIC      r1,r1,#0x3f00000      ;3033
00009c  f04172e0          ORR      r2,r1,#0x1c00000      ;3033
0000a0  4601              MOV      r1,r0                 ;3033
0000a2  4618              MOV      r0,r3                 ;3033
0000a4  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
0000a8  e028              B        |L7.252|
                  |L7.170|
0000aa  68a9              LDR      r1,[r5,#8]            ;3023
0000ac  6823              LDR      r3,[r4,#0]            ;3023
0000ae  f021717c          BIC      r1,r1,#0x3f00000      ;3023
0000b2  f4410240          ORR      r2,r1,#0xc00000       ;3023
0000b6  4601              MOV      r1,r0                 ;3023
0000b8  4618              MOV      r0,r3                 ;3023
0000ba  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
0000be  e01d              B        |L7.252|
                  |L7.192|
0000c0  68a9              LDR      r1,[r5,#8]            ;3028
0000c2  6823              LDR      r3,[r4,#0]            ;3028
0000c4  f021717c          BIC      r1,r1,#0x3f00000      ;3028
0000c8  f04172a0          ORR      r2,r1,#0x1400000      ;3028
0000cc  4601              MOV      r1,r0                 ;3028
0000ce  4618              MOV      r0,r3                 ;3028
0000d0  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
0000d4  e012              B        |L7.252|
                  |L7.214|
0000d6  6823              LDR      r3,[r4,#0]            ;3038
0000d8  4601              MOV      r1,r0                 ;3038
0000da  4a6d              LDR      r2,|L7.656|
0000dc  4618              MOV      r0,r3                 ;3038
0000de  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
0000e2  e00b              B        |L7.252|
                  |L7.228|
0000e4  6823              LDR      r3,[r4,#0]            ;3046
0000e6  4601              MOV      r1,r0                 ;3046
0000e8  4618              MOV      r0,r3                 ;3046
0000ea  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
0000ee  e005              B        |L7.252|
                  |L7.240|
0000f0  6823              LDR      r3,[r4,#0]            ;3050
0000f2  4601              MOV      r1,r0                 ;3050
0000f4  2200              MOVS     r2,#0                 ;3050
0000f6  4618              MOV      r0,r3                 ;3050
0000f8  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
                  |L7.252|
0000fc  6820              LDR      r0,[r4,#0]            ;3057
0000fe  692a              LDR      r2,[r5,#0x10]         ;3057
000100  68c1              LDR      r1,[r0,#0xc]          ;3057
000102  f3c101c1          UBFX     r1,r1,#3,#2           ;3057
000106  0049              LSLS     r1,r1,#1              ;3057
000108  408a              LSLS     r2,r2,r1              ;3057
00010a  696b              LDR      r3,[r5,#0x14]         ;3058
00010c  68c1              LDR      r1,[r0,#0xc]          ;3058
00010e  f3c101c1          UBFX     r1,r1,#3,#2           ;3058
000112  0049              LSLS     r1,r1,#1              ;3058
000114  408b              LSLS     r3,r3,r1              ;3058
000116  6829              LDR      r1,[r5,#0]            ;3061
000118  f7fffffe          BL       LL_ADC_ConfigAnalogWDThresholds
00011c  6da0              LDR      r0,[r4,#0x58]         ;3065
00011e  f4203080          BIC      r0,r0,#0x10000        ;3065
000122  65a0              STR      r0,[r4,#0x58]         ;3065
000124  6820              LDR      r0,[r4,#0]            ;3071
000126  2180              MOVS     r1,#0x80              ;3071
000128  6001              STR      r1,[r0,#0]            ;3071
00012a  7b28              LDRB     r0,[r5,#0xc]          ;3074
00012c  2801              CMP      r0,#1                 ;3074
00012e  d005              BEQ      |L7.316|
000130  6820              LDR      r0,[r4,#0]            ;3080
000132  6841              LDR      r1,[r0,#4]            ;3080
000134  f0210180          BIC      r1,r1,#0x80           ;3080
000138  6041              STR      r1,[r0,#4]            ;3080
00013a  e783              B        |L7.68|
                  |L7.316|
00013c  6820              LDR      r0,[r4,#0]            ;3076
00013e  6841              LDR      r1,[r0,#4]            ;3076
000140  f0410180          ORR      r1,r1,#0x80           ;3076
000144  6041              STR      r1,[r0,#4]            ;3076
000146  e77d              B        |L7.68|
                  |L7.328|
000148  6868              LDR      r0,[r5,#4]            ;3086
00014a  f8dfb148          LDR      r11,|L7.660|
00014e  4540              CMP      r0,r8                 ;3086
000150  d00b              BEQ      |L7.362|
000152  dc06              BGT      |L7.354|
000154  4298              CMP      r0,r3                 ;3086
000156  d032              BEQ      |L7.446|
000158  42b8              CMP      r0,r7                 ;3086
00015a  d006              BEQ      |L7.362|
00015c  4560              CMP      r0,r12                ;3086
00015e  d132              BNE      |L7.454|
000160  e02d              B        |L7.446|
                  |L7.354|
000162  4570              CMP      r0,lr                 ;3086
000164  d02b              BEQ      |L7.446|
000166  4548              CMP      r0,r9                 ;3086
000168  d12d              BNE      |L7.454|
                  |L7.362|
00016a  4559              CMP      r1,r11                ;3093
00016c  d113              BNE      |L7.406|
00016e  6821              LDR      r1,[r4,#0]            ;3095
000170  f8d120a0          LDR      r2,[r1,#0xa0]         ;3095
000174  68a8              LDR      r0,[r5,#8]            ;3095
000176  0343              LSLS     r3,r0,#13             ;3095
000178  d00a              BEQ      |L7.400|
00017a  fa90f0a0          RBIT     r0,r0                 ;3095
00017e  fab0f080          CLZ      r0,r0                 ;3095
                  |L7.386|
000182  f000001f          AND      r0,r0,#0x1f           ;3095
000186  4086              LSLS     r6,r6,r0              ;3095
000188  4332              ORRS     r2,r2,r6              ;3095
00018a  f8c120a0          STR      r2,[r1,#0xa0]         ;3095
00018e  e01e              B        |L7.462|
                  |L7.400|
000190  f3c06084          UBFX     r0,r0,#26,#5          ;3095
000194  e7f5              B        |L7.386|
                  |L7.406|
000196  6821              LDR      r1,[r4,#0]            ;3099
000198  f8d120a4          LDR      r2,[r1,#0xa4]         ;3099
00019c  68a8              LDR      r0,[r5,#8]            ;3099
00019e  0343              LSLS     r3,r0,#13             ;3099
0001a0  d00a              BEQ      |L7.440|
0001a2  fa90f0a0          RBIT     r0,r0                 ;3099
0001a6  fab0f080          CLZ      r0,r0                 ;3099
                  |L7.426|
0001aa  f000001f          AND      r0,r0,#0x1f           ;3099
0001ae  4086              LSLS     r6,r6,r0              ;3099
0001b0  4332              ORRS     r2,r2,r6              ;3099
0001b2  f8c120a4          STR      r2,[r1,#0xa4]         ;3099
0001b6  e00a              B        |L7.462|
                  |L7.440|
0001b8  f3c06084          UBFX     r0,r0,#26,#5          ;3099
0001bc  e7f5              B        |L7.426|
                  |L7.446|
0001be  6820              LDR      r0,[r4,#0]            ;3106
0001c0  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
0001c4  e003              B        |L7.462|
                  |L7.454|
0001c6  2200              MOVS     r2,#0                 ;3110
0001c8  6820              LDR      r0,[r4,#0]            ;3110
0001ca  f7fffffe          BL       LL_ADC_SetAnalogWDMonitChannels
                  |L7.462|
0001ce  6820              LDR      r0,[r4,#0]            ;3116
0001d0  68c1              LDR      r1,[r0,#0xc]          ;3116
0001d2  f3c102c1          UBFX     r2,r1,#3,#2           ;3116
0001d6  2104              MOVS     r1,#4                 ;3116
0001d8  2a03              CMP      r2,#3                 ;3116
0001da  d00a              BEQ      |L7.498|
0001dc  692a              LDR      r2,[r5,#0x10]         ;3116
0001de  68c3              LDR      r3,[r0,#0xc]          ;3116
0001e0  f3c303c1          UBFX     r3,r3,#3,#2           ;3116
0001e4  425b              RSBS     r3,r3,#0              ;3116
0001e6  eb010343          ADD      r3,r1,r3,LSL #1       ;3116
0001ea  f003031f          AND      r3,r3,#0x1f           ;3116
0001ee  40da              LSRS     r2,r2,r3              ;3116
0001f0  e001              B        |L7.502|
                  |L7.498|
0001f2  692a              LDR      r2,[r5,#0x10]         ;3116
0001f4  0092              LSLS     r2,r2,#2              ;3116
                  |L7.502|
0001f6  68c3              LDR      r3,[r0,#0xc]          ;3117
0001f8  f3c303c1          UBFX     r3,r3,#3,#2           ;3117
0001fc  2b03              CMP      r3,#3                 ;3117
0001fe  d00a              BEQ      |L7.534|
000200  696b              LDR      r3,[r5,#0x14]         ;3117
000202  68c6              LDR      r6,[r0,#0xc]          ;3117
000204  f3c606c1          UBFX     r6,r6,#3,#2           ;3117
000208  4276              RSBS     r6,r6,#0              ;3117
00020a  eb010146          ADD      r1,r1,r6,LSL #1       ;3117
00020e  f001011f          AND      r1,r1,#0x1f           ;3117
000212  40cb              LSRS     r3,r3,r1              ;3117
000214  e001              B        |L7.538|
                  |L7.534|
000216  6969              LDR      r1,[r5,#0x14]         ;3117
000218  008b              LSLS     r3,r1,#2              ;3117
                  |L7.538|
00021a  6829              LDR      r1,[r5,#0]            ;3120
00021c  f7fffffe          BL       LL_ADC_ConfigAnalogWDThresholds
000220  6828              LDR      r0,[r5,#0]            ;3123
000222  4558              CMP      r0,r11                ;3123
000224  d116              BNE      |L7.596|
000226  6da0              LDR      r0,[r4,#0x58]         ;3126
000228  f4203000          BIC      r0,r0,#0x20000        ;3126
00022c  65a0              STR      r0,[r4,#0x58]         ;3126
00022e  6820              LDR      r0,[r4,#0]            ;3132
000230  f44f7180          MOV      r1,#0x100             ;3132
000234  6001              STR      r1,[r0,#0]            ;3132
000236  7b28              LDRB     r0,[r5,#0xc]          ;3135
000238  2801              CMP      r0,#1                 ;3135
00023a  d005              BEQ      |L7.584|
00023c  6820              LDR      r0,[r4,#0]            ;3141
00023e  6841              LDR      r1,[r0,#4]            ;3141
000240  f4217180          BIC      r1,r1,#0x100          ;3141
000244  6041              STR      r1,[r0,#4]            ;3141
000246  e6fd              B        |L7.68|
                  |L7.584|
000248  6820              LDR      r0,[r4,#0]            ;3137
00024a  6841              LDR      r1,[r0,#4]            ;3137
00024c  f4417180          ORR      r1,r1,#0x100          ;3137
000250  6041              STR      r1,[r0,#4]            ;3137
000252  e6f7              B        |L7.68|
                  |L7.596|
000254  6da0              LDR      r0,[r4,#0x58]         ;3148
000256  f4202080          BIC      r0,r0,#0x40000        ;3148
00025a  65a0              STR      r0,[r4,#0x58]         ;3148
00025c  6820              LDR      r0,[r4,#0]            ;3154
00025e  f44f7100          MOV      r1,#0x200             ;3154
000262  6001              STR      r1,[r0,#0]            ;3154
000264  7b28              LDRB     r0,[r5,#0xc]          ;3157
000266  2801              CMP      r0,#1                 ;3157
000268  d005              BEQ      |L7.630|
00026a  6820              LDR      r0,[r4,#0]            ;3163
00026c  6841              LDR      r1,[r0,#4]            ;3163
00026e  f4217100          BIC      r1,r1,#0x200          ;3163
000272  6041              STR      r1,[r0,#4]            ;3163
000274  e6e6              B        |L7.68|
                  |L7.630|
000276  6820              LDR      r0,[r4,#0]            ;3159
000278  6841              LDR      r1,[r0,#4]            ;3159
00027a  f4417100          ORR      r1,r1,#0x200          ;3159
00027e  6041              STR      r1,[r0,#4]            ;3159
000280  e6e0              B        |L7.68|
;;;3184   
                          ENDP

000282  0000              DCW      0x0000
                  |L7.644|
                          DCD      0x7dc00000
                  |L7.648|
                          DCD      0x0187ffff
                  |L7.652|
                          DCD      0x0107ffff
                  |L7.656|
                          DCD      0x0087ffff
                  |L7.660|
                          DCD      0x0017ffff

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;2705     */
;;;2706   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2707   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2708     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000008  2600              MOVS     r6,#0
;;;2709     uint32_t tmpOffsetShifted;
;;;2710     uint32_t tmp_config_internal_channel;
;;;2711     __IO uint32_t wait_loop_index = 0UL;
00000a  2700              MOVS     r7,#0
00000c  9700              STR      r7,[sp,#0]
;;;2712     uint32_t tmp_adc_is_conversion_on_going_regular;
;;;2713     uint32_t tmp_adc_is_conversion_on_going_injected;
;;;2714   
;;;2715     /* Check the parameters */
;;;2716     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2717     assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;2718     assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;2719     assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
;;;2720     assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
;;;2721     assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
;;;2722   
;;;2723     /* if ROVSE is set, the value of the OFFSETy_EN bit in ADCx_OFRy register is
;;;2724        ignored (considered as reset) */
;;;2725     assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
;;;2726   
;;;2727     /* Verification of channel number */
;;;2728     if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
00000e  f8df9404          LDR      r9,|L8.1044|
;;;2729     {
;;;2730       assert_param(IS_ADC_CHANNEL(hadc, sConfig->Channel));
;;;2731     }
;;;2732     else
;;;2733     {
;;;2734       assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
;;;2735     }
;;;2736   
;;;2737     /* Process locked */
;;;2738     __HAL_LOCK(hadc);
000012  f8940054          LDRB     r0,[r4,#0x54]
000016  2801              CMP      r0,#1
000018  d011              BEQ      |L8.62|
00001a  f04f0801          MOV      r8,#1
00001e  f8848054          STRB     r8,[r4,#0x54]
;;;2739   
;;;2740     /* Parameters update conditioned to ADC state:                              */
;;;2741     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;2742     /* conversion on going on regular group:                                    */
;;;2743     /*  - Channel number                                                        */
;;;2744     /*  - Channel rank                                                          */
;;;2745     if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000028  b158              CBZ      r0,|L8.66|
;;;2746     {
;;;2747   #if !defined (USE_FULL_ASSERT)
;;;2748       /* Correspondence for compatibility with legacy definition of             */
;;;2749       /* sequencer ranks in direct number format. This correspondence can       */
;;;2750       /* be done only on ranks 1 to 5 due to literal values.                    */
;;;2751       /* Note: Sequencer ranks in direct number format are no more used         */
;;;2752       /*       and are detected by activating USE_FULL_ASSERT feature.          */
;;;2753       if (sConfig->Rank <= 5U)
;;;2754       {
;;;2755         switch (sConfig->Rank)
;;;2756         {
;;;2757           case 2U:
;;;2758             sConfig->Rank = ADC_REGULAR_RANK_2;
;;;2759             break;
;;;2760           case 3U:
;;;2761             sConfig->Rank = ADC_REGULAR_RANK_3;
;;;2762             break;
;;;2763           case 4U:
;;;2764             sConfig->Rank = ADC_REGULAR_RANK_4;
;;;2765             break;
;;;2766           case 5U:
;;;2767             sConfig->Rank = ADC_REGULAR_RANK_5;
;;;2768             break;
;;;2769           /* case 1U */
;;;2770           default:
;;;2771             sConfig->Rank = ADC_REGULAR_RANK_1;
;;;2772             break;
;;;2773         }
;;;2774       }
;;;2775   #endif
;;;2776   
;;;2777       /* Set ADC group regular sequence: channel on the selected scan sequence rank */
;;;2778       LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
;;;2779   
;;;2780       /* Parameters update conditioned to ADC state:                              */
;;;2781       /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;2782       /* conversion on going on regular group:                                    */
;;;2783       /*  - Channel sampling time                                                 */
;;;2784       /*  - Channel offset                                                        */
;;;2785       tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
;;;2786       tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
;;;2787       if ((tmp_adc_is_conversion_on_going_regular == 0UL)
;;;2788           && (tmp_adc_is_conversion_on_going_injected == 0UL)
;;;2789          )
;;;2790       {
;;;2791   #if defined(ADC_SMPR1_SMPPLUS)
;;;2792         /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
;;;2793         if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
;;;2794         {
;;;2795           /* Set sampling time of the selected ADC channel */
;;;2796           LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
;;;2797   
;;;2798           /* Set ADC sampling time common configuration */
;;;2799           LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
;;;2800         }
;;;2801         else
;;;2802         {
;;;2803           /* Set sampling time of the selected ADC channel */
;;;2804           LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
;;;2805   
;;;2806           /* Set ADC sampling time common configuration */
;;;2807           LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
;;;2808         }
;;;2809   #else
;;;2810         /* Set sampling time of the selected ADC channel */
;;;2811         LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
;;;2812   #endif
;;;2813   
;;;2814         /* Configure the offset: offset enable/disable, channel, offset value */
;;;2815   
;;;2816         /* Shift the offset with respect to the selected ADC resolution. */
;;;2817         /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
;;;2818         tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
;;;2819   
;;;2820         if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
;;;2821         {
;;;2822           /* Set ADC selected offset number */
;;;2823           LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
;;;2824   
;;;2825         }
;;;2826         else
;;;2827         {
;;;2828           /* Scan each offset register to check if the selected channel is targeted. */
;;;2829           /* If this is the case, the corresponding offset number is disabled.       */
;;;2830           if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
;;;2831               == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
;;;2832           {
;;;2833             LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
;;;2834           }
;;;2835           if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
;;;2836               == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
;;;2837           {
;;;2838             LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
;;;2839           }
;;;2840           if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
;;;2841               == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
;;;2842           {
;;;2843             LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
;;;2844           }
;;;2845           if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
;;;2846               == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
;;;2847           {
;;;2848             LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
;;;2849           }
;;;2850         }
;;;2851       }
;;;2852   
;;;2853       /* Parameters update conditioned to ADC state:                              */
;;;2854       /* Parameters that can be updated only when ADC is disabled:                */
;;;2855       /*  - Single or differential mode                                           */
;;;2856       if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
;;;2857       {
;;;2858         /* Set mode single-ended or differential input of the selected ADC channel */
;;;2859         LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
;;;2860   
;;;2861         /* Configuration of differential mode */
;;;2862         if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
;;;2863         {
;;;2864           /* Set sampling time of the selected ADC channel */
;;;2865           /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
;;;2866           LL_ADC_SetChannelSamplingTime(hadc->Instance,
;;;2867                                         (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
;;;2868                                         sConfig->SamplingTime);
;;;2869         }
;;;2870   
;;;2871       }
;;;2872   
;;;2873       /* Management of internal measurement channels: Vbat/VrefInt/TempSensor.  */
;;;2874       /* If internal channel selected, enable dedicated internal buffers and    */
;;;2875       /* paths.                                                                 */
;;;2876       /* Note: these internal measurement paths can be disabled using           */
;;;2877       /* HAL_ADC_DeInit().                                                      */
;;;2878   
;;;2879       if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
;;;2880       {
;;;2881         tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;2882   
;;;2883         /* If the requested internal measurement path has already been enabled, */
;;;2884         /* bypass the configuration processing.                                 */
;;;2885         if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
;;;2886             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
;;;2887         {
;;;2888           if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
;;;2889           {
;;;2890             LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
;;;2891                                            LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
;;;2892   
;;;2893             /* Delay for temperature sensor stabilization time */
;;;2894             /* Wait loop initialization and execution */
;;;2895             /* Note: Variable divided by 2 to compensate partially              */
;;;2896             /*       CPU processing cycles, scaling in us split to not          */
;;;2897             /*       exceed 32 bits register capacity and handle low frequency. */
;;;2898             wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
;;;2899             while (wait_loop_index != 0UL)
;;;2900             {
;;;2901               wait_loop_index--;
;;;2902             }
;;;2903           }
;;;2904         }
;;;2905         else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
;;;2906         {
;;;2907           if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
;;;2908           {
;;;2909             LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
;;;2910                                            LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
;;;2911           }
;;;2912         }
;;;2913         else if ((sConfig->Channel == ADC_CHANNEL_VREFINT)
;;;2914                  && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
;;;2915         {
;;;2916           if (ADC_VREFINT_INSTANCE(hadc))
;;;2917           {
;;;2918             LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
;;;2919                                            LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
;;;2920           }
;;;2921         }
;;;2922         else
;;;2923         {
;;;2924           /* nothing to do */
;;;2925         }
;;;2926       }
;;;2927     }
;;;2928   
;;;2929     /* If a conversion is on going on regular group, no update on regular       */
;;;2930     /* channel could be done on neither of the channel configuration structure  */
;;;2931     /* parameters.                                                              */
;;;2932     else
;;;2933     {
;;;2934       /* Update ADC state machine to error */
;;;2935       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00002a  6da0              LDR      r0,[r4,#0x58]
00002c  f0400020          ORR      r0,r0,#0x20
000030  65a0              STR      r0,[r4,#0x58]
;;;2936   
;;;2937       tmp_hal_status = HAL_ERROR;
000032  2601              MOVS     r6,#1
                  |L8.52|
;;;2938     }
;;;2939   
;;;2940     /* Process unlocked */
;;;2941     __HAL_UNLOCK(hadc);
000034  f8847054          STRB     r7,[r4,#0x54]
;;;2942   
;;;2943     /* Return function status */
;;;2944     return tmp_hal_status;
000038  4630              MOV      r0,r6
                  |L8.58|
;;;2945   }
00003a  e8bd8ff8          POP      {r3-r11,pc}
                  |L8.62|
00003e  2002              MOVS     r0,#2                 ;2738
000040  e7fb              B        |L8.58|
                  |L8.66|
000042  6868              LDR      r0,[r5,#4]            ;2753
000044  2805              CMP      r0,#5                 ;2753
000046  d809              BHI      |L8.92|
000048  2802              CMP      r0,#2                 ;2755
00004a  d027              BEQ      |L8.156|
00004c  2803              CMP      r0,#3                 ;2755
00004e  d028              BEQ      |L8.162|
000050  2804              CMP      r0,#4                 ;2755
000052  d029              BEQ      |L8.168|
000054  2805              CMP      r0,#5                 ;2755
000056  d02a              BEQ      |L8.174|
000058  2006              MOVS     r0,#6                 ;2771
00005a  6068              STR      r0,[r5,#4]            ;2771
                  |L8.92|
00005c  88a9              LDRH     r1,[r5,#4]            ;2778
00005e  6820              LDR      r0,[r4,#0]            ;2778
000060  682a              LDR      r2,[r5,#0]            ;2778
000062  f4017340          AND      r3,r1,#0x300          ;2778
000066  eb001093          ADD      r0,r0,r3,LSR #6       ;2778
00006a  6b03              LDR      r3,[r0,#0x30]         ;2778
00006c  f001011f          AND      r1,r1,#0x1f           ;2778
000070  f04f0c1f          MOV      r12,#0x1f             ;2778
000074  fa0cfc01          LSL      r12,r12,r1            ;2778
000078  f3c26284          UBFX     r2,r2,#26,#5          ;2778
00007c  ea23030c          BIC      r3,r3,r12             ;2778
000080  408a              LSLS     r2,r2,r1              ;2778
000082  4313              ORRS     r3,r3,r2              ;2778
000084  6303              STR      r3,[r0,#0x30]         ;2778
000086  6820              LDR      r0,[r4,#0]            ;2785
000088  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00008c  4682              MOV      r10,r0                ;2785
00008e  6820              LDR      r0,[r4,#0]            ;2786
000090  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
000094  ea5a0a00          ORRS     r10,r10,r0            ;2787
000098  d00d              BEQ      |L8.182|
00009a  e0ad              B        |L8.504|
                  |L8.156|
00009c  200c              MOVS     r0,#0xc               ;2758
00009e  6068              STR      r0,[r5,#4]            ;2758
0000a0  e7dc              B        |L8.92|
                  |L8.162|
0000a2  2012              MOVS     r0,#0x12              ;2761
0000a4  6068              STR      r0,[r5,#4]            ;2761
0000a6  e7d9              B        |L8.92|
                  |L8.168|
0000a8  2018              MOVS     r0,#0x18              ;2764
0000aa  6068              STR      r0,[r5,#4]            ;2764
0000ac  e7d6              B        |L8.92|
                  |L8.174|
0000ae  f44f7080          MOV      r0,#0x100             ;2767
0000b2  6068              STR      r0,[r5,#4]            ;2767
0000b4  e7d2              B        |L8.92|
                  |L8.182|
0000b6  68aa              LDR      r2,[r5,#8]            ;2793
0000b8  f1b24f00          CMP      r2,#0x80000000        ;2793
0000bc  d022              BEQ      |L8.260|
0000be  6829              LDR      r1,[r5,#0]            ;2804
0000c0  6820              LDR      r0,[r4,#0]            ;2804
0000c2  f7fffffe          BL       LL_ADC_SetChannelSamplingTime
0000c6  6820              LDR      r0,[r4,#0]            ;2807
0000c8  6941              LDR      r1,[r0,#0x14]         ;2807
0000ca  f0214100          BIC      r1,r1,#0x80000000     ;2807
0000ce  6141              STR      r1,[r0,#0x14]         ;2807
                  |L8.208|
0000d0  6820              LDR      r0,[r4,#0]            ;2818
0000d2  696a              LDR      r2,[r5,#0x14]         ;2818
0000d4  68c1              LDR      r1,[r0,#0xc]          ;2818
0000d6  f3c101c1          UBFX     r1,r1,#3,#2           ;2818
0000da  0049              LSLS     r1,r1,#1              ;2818
0000dc  408a              LSLS     r2,r2,r1              ;2818
0000de  6929              LDR      r1,[r5,#0x10]         ;2820
0000e0  2904              CMP      r1,#4                 ;2820
0000e2  d01a              BEQ      |L8.282|
0000e4  682b              LDR      r3,[r5,#0]            ;2823
0000e6  eb000081          ADD      r0,r0,r1,LSL #2       ;2823
0000ea  6e01              LDR      r1,[r0,#0x60]         ;2823
0000ec  f8dfc328          LDR      r12,|L8.1048|
0000f0  f00343f8          AND      r3,r3,#0x7c000000     ;2823
0000f4  ea01010c          AND      r1,r1,r12             ;2823
0000f8  4313              ORRS     r3,r3,r2              ;2823
0000fa  4319              ORRS     r1,r1,r3              ;2823
0000fc  f0414100          ORR      r1,r1,#0x80000000     ;2823
000100  6601              STR      r1,[r0,#0x60]         ;2823
000102  e079              B        |L8.504|
                  |L8.260|
000104  6829              LDR      r1,[r5,#0]            ;2796
000106  2200              MOVS     r2,#0                 ;2796
000108  6820              LDR      r0,[r4,#0]            ;2796
00010a  f7fffffe          BL       LL_ADC_SetChannelSamplingTime
00010e  6820              LDR      r0,[r4,#0]            ;2799
000110  6941              LDR      r1,[r0,#0x14]         ;2799
000112  f0414100          ORR      r1,r1,#0x80000000     ;2799
000116  6141              STR      r1,[r0,#0x14]         ;2799
000118  e7da              B        |L8.208|
                  |L8.282|
00011a  2100              MOVS     r1,#0                 ;2830
00011c  f7fffffe          BL       LL_ADC_GetOffsetChannel
000120  0340              LSLS     r0,r0,#13             ;2830
000122  d06f              BEQ      |L8.516|
000124  2100              MOVS     r1,#0                 ;2830
000126  6820              LDR      r0,[r4,#0]            ;2830
000128  f7fffffe          BL       LL_ADC_GetOffsetChannel
00012c  fa90f0a0          RBIT     r0,r0                 ;2830
000130  fab0f180          CLZ      r1,r0                 ;2830
                  |L8.308|
000134  6828              LDR      r0,[r5,#0]            ;2830
000136  0342              LSLS     r2,r0,#13             ;2830
000138  d06b              BEQ      |L8.530|
00013a  fa90f0a0          RBIT     r0,r0                 ;2831
00013e  fab0f080          CLZ      r0,r0                 ;2831
                  |L8.322|
000142  4281              CMP      r1,r0                 ;2831
000144  d104              BNE      |L8.336|
000146  2200              MOVS     r2,#0                 ;2833
000148  4611              MOV      r1,r2                 ;2833
00014a  6820              LDR      r0,[r4,#0]            ;2833
00014c  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L8.336|
000150  2101              MOVS     r1,#1                 ;2835
000152  6820              LDR      r0,[r4,#0]            ;2835
000154  f7fffffe          BL       LL_ADC_GetOffsetChannel
000158  0340              LSLS     r0,r0,#13             ;2835
00015a  d05d              BEQ      |L8.536|
00015c  2101              MOVS     r1,#1                 ;2835
00015e  6820              LDR      r0,[r4,#0]            ;2835
000160  f7fffffe          BL       LL_ADC_GetOffsetChannel
000164  fa90f0a0          RBIT     r0,r0                 ;2835
000168  fab0f180          CLZ      r1,r0                 ;2835
                  |L8.364|
00016c  6828              LDR      r0,[r5,#0]            ;2835
00016e  0342              LSLS     r2,r0,#13             ;2835
000170  d059              BEQ      |L8.550|
000172  fa90f0a0          RBIT     r0,r0                 ;2836
000176  fab0f080          CLZ      r0,r0                 ;2836
                  |L8.378|
00017a  4281              CMP      r1,r0                 ;2836
00017c  d104              BNE      |L8.392|
00017e  2200              MOVS     r2,#0                 ;2838
000180  2101              MOVS     r1,#1                 ;2838
000182  6820              LDR      r0,[r4,#0]            ;2838
000184  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L8.392|
000188  2102              MOVS     r1,#2                 ;2840
00018a  6820              LDR      r0,[r4,#0]            ;2840
00018c  f7fffffe          BL       LL_ADC_GetOffsetChannel
000190  0340              LSLS     r0,r0,#13             ;2840
000192  d04b              BEQ      |L8.556|
000194  2102              MOVS     r1,#2                 ;2840
000196  6820              LDR      r0,[r4,#0]            ;2840
000198  f7fffffe          BL       LL_ADC_GetOffsetChannel
00019c  fa90f0a0          RBIT     r0,r0                 ;2840
0001a0  fab0f180          CLZ      r1,r0                 ;2840
                  |L8.420|
0001a4  6828              LDR      r0,[r5,#0]            ;2840
0001a6  0342              LSLS     r2,r0,#13             ;2840
0001a8  d047              BEQ      |L8.570|
0001aa  fa90f0a0          RBIT     r0,r0                 ;2841
0001ae  fab0f080          CLZ      r0,r0                 ;2841
                  |L8.434|
0001b2  4281              CMP      r1,r0                 ;2841
0001b4  d104              BNE      |L8.448|
0001b6  2200              MOVS     r2,#0                 ;2843
0001b8  2102              MOVS     r1,#2                 ;2843
0001ba  6820              LDR      r0,[r4,#0]            ;2843
0001bc  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L8.448|
0001c0  2103              MOVS     r1,#3                 ;2845
0001c2  6820              LDR      r0,[r4,#0]            ;2845
0001c4  f7fffffe          BL       LL_ADC_GetOffsetChannel
0001c8  0340              LSLS     r0,r0,#13             ;2845
0001ca  d039              BEQ      |L8.576|
0001cc  2103              MOVS     r1,#3                 ;2845
0001ce  6820              LDR      r0,[r4,#0]            ;2845
0001d0  f7fffffe          BL       LL_ADC_GetOffsetChannel
0001d4  fa90f0a0          RBIT     r0,r0                 ;2845
0001d8  fab0f180          CLZ      r1,r0                 ;2845
                  |L8.476|
0001dc  6828              LDR      r0,[r5,#0]            ;2845
0001de  0342              LSLS     r2,r0,#13             ;2845
0001e0  d035              BEQ      |L8.590|
0001e2  fa90f0a0          RBIT     r0,r0                 ;2846
0001e6  fab0f080          CLZ      r0,r0                 ;2846
                  |L8.490|
0001ea  4281              CMP      r1,r0                 ;2846
0001ec  d104              BNE      |L8.504|
0001ee  2200              MOVS     r2,#0                 ;2848
0001f0  2103              MOVS     r1,#3                 ;2848
0001f2  6820              LDR      r0,[r4,#0]            ;2848
0001f4  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L8.504|
0001f8  6820              LDR      r0,[r4,#0]            ;2856
0001fa  f7fffffe          BL       LL_ADC_IsEnabled
0001fe  b348              CBZ      r0,|L8.596|
000200  e0b1              B        |L8.870|
000202  e7ff              B        |L8.516|
                  |L8.516|
000204  2100              MOVS     r1,#0                 ;2830
000206  6820              LDR      r0,[r4,#0]            ;2830
000208  f7fffffe          BL       LL_ADC_GetOffsetChannel
00020c  f3c06184          UBFX     r1,r0,#26,#5          ;2830
000210  e790              B        |L8.308|
                  |L8.530|
000212  f3c06084          UBFX     r0,r0,#26,#5          ;2831
000216  e794              B        |L8.322|
                  |L8.536|
000218  2101              MOVS     r1,#1                 ;2835
00021a  6820              LDR      r0,[r4,#0]            ;2835
00021c  f7fffffe          BL       LL_ADC_GetOffsetChannel
000220  f3c06184          UBFX     r1,r0,#26,#5          ;2835
000224  e7a2              B        |L8.364|
                  |L8.550|
000226  f3c06084          UBFX     r0,r0,#26,#5          ;2836
00022a  e7a6              B        |L8.378|
                  |L8.556|
00022c  2102              MOVS     r1,#2                 ;2840
00022e  6820              LDR      r0,[r4,#0]            ;2840
000230  f7fffffe          BL       LL_ADC_GetOffsetChannel
000234  f3c06184          UBFX     r1,r0,#26,#5          ;2840
000238  e7b4              B        |L8.420|
                  |L8.570|
00023a  f3c06084          UBFX     r0,r0,#26,#5          ;2841
00023e  e7b8              B        |L8.434|
                  |L8.576|
000240  2103              MOVS     r1,#3                 ;2845
000242  6820              LDR      r0,[r4,#0]            ;2845
000244  f7fffffe          BL       LL_ADC_GetOffsetChannel
000248  f3c06184          UBFX     r1,r0,#26,#5          ;2845
00024c  e7c6              B        |L8.476|
                  |L8.590|
00024e  f3c06084          UBFX     r0,r0,#26,#5          ;2846
000252  e7ca              B        |L8.490|
                  |L8.596|
000254  6820              LDR      r0,[r4,#0]            ;2859
000256  7b2a              LDRB     r2,[r5,#0xc]          ;2859
000258  6829              LDR      r1,[r5,#0]            ;2859
00025a  f8503fb0          LDR      r3,[r0,#0xb0]!        ;2859
00025e  f3c10c12          UBFX     r12,r1,#0,#19         ;2859
000262  ea23030c          BIC      r3,r3,r12             ;2859
000266  f0020c18          AND      r12,r2,#0x18          ;2859
00026a  4a6c              LDR      r2,|L8.1052|
00026c  fa22f20c          LSR      r2,r2,r12             ;2859
000270  400a              ANDS     r2,r2,r1              ;2859
000272  4313              ORRS     r3,r3,r2              ;2859
000274  6003              STR      r3,[r0,#0]            ;2859
000276  68e8              LDR      r0,[r5,#0xc]          ;2862
000278  4548              CMP      r0,r9                 ;2862
00027a  d174              BNE      |L8.870|
00027c  6828              LDR      r0,[r5,#0]            ;2866
00027e  0341              LSLS     r1,r0,#13             ;2866
000280  d019              BEQ      |L8.694|
000282  fa90f1a0          RBIT     r1,r0                 ;2867
000286  fab1f181          CLZ      r1,r1                 ;2867
                  |L8.650|
00028a  1c49              ADDS     r1,r1,#1              ;2867
00028c  f001011f          AND      r1,r1,#0x1f           ;2867
000290  2909              CMP      r1,#9                 ;2867
000292  d831              BHI      |L8.760|
000294  0341              LSLS     r1,r0,#13             ;2867
000296  2900              CMP      r1,#0                 ;2867
000298  d010              BEQ      |L8.700|
00029a  fa90f1a0          RBIT     r1,r0                 ;2867
00029e  fab1f181          CLZ      r1,r1                 ;2867
                  |L8.674|
0002a2  f1010101          ADD      r1,r1,#1              ;2867
0002a6  f001011f          AND      r1,r1,#0x1f           ;2867
0002aa  fa08f801          LSL      r8,r8,r1              ;2867
0002ae  d108              BNE      |L8.706|
0002b0  f3c06184          UBFX     r1,r0,#26,#5          ;2867
0002b4  e009              B        |L8.714|
                  |L8.694|
0002b6  f3c06184          UBFX     r1,r0,#26,#5          ;2867
0002ba  e7e6              B        |L8.650|
                  |L8.700|
0002bc  f3c06184          UBFX     r1,r0,#26,#5          ;2867
0002c0  e7ef              B        |L8.674|
                  |L8.706|
0002c2  fa90f1a0          RBIT     r1,r0                 ;2867
0002c6  fab1f181          CLZ      r1,r1                 ;2867
                  |L8.714|
0002ca  f1010101          ADD      r1,r1,#1              ;2867
0002ce  f001011f          AND      r1,r1,#0x1f           ;2867
0002d2  ea486181          ORR      r1,r8,r1,LSL #26      ;2867
0002d6  d102              BNE      |L8.734|
0002d8  f3c06084          UBFX     r0,r0,#26,#5          ;2867
0002dc  e003              B        |L8.742|
                  |L8.734|
0002de  fa90f0a0          RBIT     r0,r0                 ;2867
0002e2  fab0f080          CLZ      r0,r0                 ;2867
                  |L8.742|
0002e6  f1000001          ADD      r0,r0,#1              ;2867
0002ea  f000001f          AND      r0,r0,#0x1f           ;2867
0002ee  eb000040          ADD      r0,r0,r0,LSL #1       ;2867
0002f2  ea415100          ORR      r1,r1,r0,LSL #20      ;2867
0002f6  e032              B        |L8.862|
                  |L8.760|
0002f8  ea4f3140          LSL      r1,r0,#13             ;2867
0002fc  2900              CMP      r1,#0                 ;2867
0002fe  d00d              BEQ      |L8.796|
000300  fa90f1a0          RBIT     r1,r0                 ;2867
000304  fab1f181          CLZ      r1,r1                 ;2867
                  |L8.776|
000308  f1010101          ADD      r1,r1,#1              ;2867
00030c  f001011f          AND      r1,r1,#0x1f           ;2867
000310  fa08f801          LSL      r8,r8,r1              ;2867
000314  d105              BNE      |L8.802|
000316  f3c06184          UBFX     r1,r0,#26,#5          ;2867
00031a  e006              B        |L8.810|
                  |L8.796|
00031c  f3c06184          UBFX     r1,r0,#26,#5          ;2867
000320  e7f2              B        |L8.776|
                  |L8.802|
000322  fa90f1a0          RBIT     r1,r0                 ;2867
000326  fab1f181          CLZ      r1,r1                 ;2867
                  |L8.810|
00032a  f1010101          ADD      r1,r1,#1              ;2867
00032e  f001011f          AND      r1,r1,#0x1f           ;2867
000332  ea486181          ORR      r1,r8,r1,LSL #26      ;2867
000336  d102              BNE      |L8.830|
000338  f3c06084          UBFX     r0,r0,#26,#5          ;2867
00033c  e003              B        |L8.838|
                  |L8.830|
00033e  fa90f0a0          RBIT     r0,r0                 ;2867
000342  fab0f080          CLZ      r0,r0                 ;2867
                  |L8.838|
000346  f1000001          ADD      r0,r0,#1              ;2867
00034a  f000001f          AND      r0,r0,#0x1f           ;2867
00034e  f1a0000a          SUB      r0,r0,#0xa            ;2867
000352  eb000040          ADD      r0,r0,r0,LSL #1       ;2867
000356  ea415000          ORR      r0,r1,r0,LSL #20      ;2867
00035a  f0407100          ORR      r1,r0,#0x2000000      ;2867
                  |L8.862|
00035e  68aa              LDR      r2,[r5,#8]            ;2867
000360  6820              LDR      r0,[r4,#0]            ;2867
000362  f7fffffe          BL       LL_ADC_SetChannelSamplingTime
                  |L8.870|
000366  482e              LDR      r0,|L8.1056|
000368  6829              LDR      r1,[r5,#0]            ;2879
00036a  4201              TST      r1,r0                 ;2879
00036c  f43fae62          BEQ      |L8.52|
000370  4a2c              LDR      r2,|L8.1060|
000372  6890              LDR      r0,[r2,#8]            ;2879
000374  f00070e0          AND      r0,r0,#0x1c00000      ;2879
000378  f8dfc0ac          LDR      r12,|L8.1064|
00037c  4b2b              LDR      r3,|L8.1068|
00037e  4d2c              LDR      r5,|L8.1072|
000380  4561              CMP      r1,r12                ;2885
000382  d121              BNE      |L8.968|
000384  ea5f2c00          LSLS     r12,r0,#8             ;2886
000388  d41e              BMI      |L8.968|
00038a  6821              LDR      r1,[r4,#0]            ;2888
00038c  4299              CMP      r1,r3                 ;2888
00038e  d002              BEQ      |L8.918|
000390  42a9              CMP      r1,r5                 ;2888
000392  f47fae4f          BNE      |L8.52|
                  |L8.918|
000396  f4400000          ORR      r0,r0,#0x800000       ;2890
00039a  6891              LDR      r1,[r2,#8]            ;2890
00039c  f02171e0          BIC      r1,r1,#0x1c00000      ;2890
0003a0  4301              ORRS     r1,r1,r0              ;2890
0003a2  6091              STR      r1,[r2,#8]            ;2890
0003a4  4823              LDR      r0,|L8.1076|
0003a6  4924              LDR      r1,|L8.1080|
0003a8  6800              LDR      r0,[r0,#0]            ;2898  ; SystemCoreClock
0003aa  fbb0f0f1          UDIV     r0,r0,r1              ;2898
0003ae  1c40              ADDS     r0,r0,#1              ;2898
0003b0  eb000040          ADD      r0,r0,r0,LSL #1       ;2898
0003b4  0080              LSLS     r0,r0,#2              ;2898
0003b6  9000              STR      r0,[sp,#0]            ;2898
0003b8  e002              B        |L8.960|
                  |L8.954|
0003ba  9800              LDR      r0,[sp,#0]            ;2901
0003bc  1e40              SUBS     r0,r0,#1              ;2901
0003be  9000              STR      r0,[sp,#0]            ;2901
                  |L8.960|
0003c0  9800              LDR      r0,[sp,#0]            ;2899
0003c2  2800              CMP      r0,#0                 ;2899
0003c4  d1f9              BNE      |L8.954|
                  |L8.966|
0003c6  e635              B        |L8.52|
                  |L8.968|
0003c8  f8dfc070          LDR      r12,|L8.1084|
0003cc  4561              CMP      r1,r12                ;2905
0003ce  d10f              BNE      |L8.1008|
0003d0  ea5f1cc0          LSLS     r12,r0,#7             ;2905
0003d4  d40c              BMI      |L8.1008|
0003d6  6821              LDR      r1,[r4,#0]            ;2907
0003d8  4299              CMP      r1,r3                 ;2907
0003da  d001              BEQ      |L8.992|
0003dc  42a9              CMP      r1,r5                 ;2907
0003de  d1f2              BNE      |L8.966|
                  |L8.992|
0003e0  f0407080          ORR      r0,r0,#0x1000000      ;2909
0003e4  6891              LDR      r1,[r2,#8]            ;2909
0003e6  f02171e0          BIC      r1,r1,#0x1c00000      ;2909
0003ea  4301              ORRS     r1,r1,r0              ;2909
0003ec  6091              STR      r1,[r2,#8]            ;2909
0003ee  e621              B        |L8.52|
                  |L8.1008|
0003f0  f06f4500          MVN      r5,#0x80000000        ;2913
0003f4  42e9              CMN      r1,r5                 ;2913
0003f6  d1e6              BNE      |L8.966|
0003f8  0241              LSLS     r1,r0,#9              ;2914
0003fa  d4e4              BMI      |L8.966|
0003fc  6821              LDR      r1,[r4,#0]            ;2916
0003fe  4299              CMP      r1,r3                 ;2916
000400  d1e1              BNE      |L8.966|
000402  f4400080          ORR      r0,r0,#0x400000       ;2918
000406  6891              LDR      r1,[r2,#8]            ;2918
000408  f02171e0          BIC      r1,r1,#0x1c00000      ;2918
00040c  4301              ORRS     r1,r1,r0              ;2918
00040e  6091              STR      r1,[r2,#8]            ;2918
000410  e610              B        |L8.52|
;;;2946   
                          ENDP

000412  0000              DCW      0x0000
                  |L8.1044|
                          DCD      0x407f0000
                  |L8.1048|
                          DCD      0x03fff000
                  |L8.1052|
                          DCD      0x0007ffff
                  |L8.1056|
                          DCD      0x80080000
                  |L8.1060|
                          DCD      0x50040300
                  |L8.1064|
                          DCD      0xc7520000
                  |L8.1068|
                          DCD      0x50040000
                  |L8.1072|
                          DCD      0x50040200
                  |L8.1076|
                          DCD      SystemCoreClock
                  |L8.1080|
                          DCD      0x00030d40
                  |L8.1084|
                          DCD      0xcb840000

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;2607     */
;;;2608   __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;2609   {
;;;2610     /* Prevent unused argument(s) compilation warning */
;;;2611     UNUSED(hadc);
;;;2612   
;;;2613     /* NOTE : This function should not be modified. When the callback is needed,
;;;2614               function HAL_ADC_ConvCpltCallback must be implemented in the user file.
;;;2615      */
;;;2616   }
;;;2617   
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;2622     */
;;;2623   __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;2624   {
;;;2625     /* Prevent unused argument(s) compilation warning */
;;;2626     UNUSED(hadc);
;;;2627   
;;;2628     /* NOTE : This function should not be modified. When the callback is needed,
;;;2629               function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
;;;2630     */
;;;2631   }
;;;2632   
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_ADC_DeInit PROC
;;;705      */
;;;706    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;707    {
000002  4604              MOV      r4,r0
;;;708      HAL_StatusTypeDef tmp_hal_status;
;;;709    
;;;710      /* Check ADC handle */
;;;711      if (hadc == NULL)
000004  2c00              CMP      r4,#0
000006  d010              BEQ      |L11.42|
;;;712      {
;;;713        return HAL_ERROR;
;;;714      }
;;;715    
;;;716      /* Check the parameters */
;;;717      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;718    
;;;719      /* Set ADC state */
;;;720      SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
000008  6da0              LDR      r0,[r4,#0x58]
00000a  f0400002          ORR      r0,r0,#2
00000e  65a0              STR      r0,[r4,#0x58]
;;;721    
;;;722      /* Stop potential conversion on going */
;;;723      tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
000010  2103              MOVS     r1,#3
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ConversionStop
000018  4605              MOV      r5,r0
;;;724    
;;;725      /* Disable ADC peripheral if conversions are effectively stopped            */
;;;726      /* Flush register JSQR: reset the queue sequencer when injected             */
;;;727      /* queue sequencer is enabled and ADC disabled.                             */
;;;728      /* The software and hardware triggers of the injected sequence are both     */
;;;729      /* internally disabled just after the completion of the last valid          */
;;;730      /* injected sequence.                                                       */
;;;731      SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JQM);
00001a  6820              LDR      r0,[r4,#0]
00001c  68c1              LDR      r1,[r0,#0xc]
00001e  f4411100          ORR      r1,r1,#0x200000
000022  60c1              STR      r1,[r0,#0xc]
;;;732    
;;;733      /* Disable ADC peripheral if conversions are effectively stopped */
;;;734      if (tmp_hal_status == HAL_OK)
000024  0028              MOVS     r0,r5
000026  d002              BEQ      |L11.46|
000028  e009              B        |L11.62|
                  |L11.42|
00002a  2001              MOVS     r0,#1                 ;713
;;;735      {
;;;736        /* Disable the ADC peripheral */
;;;737        tmp_hal_status = ADC_Disable(hadc);
;;;738    
;;;739        /* Check if ADC is effectively disabled */
;;;740        if (tmp_hal_status == HAL_OK)
;;;741        {
;;;742          /* Change ADC state */
;;;743          hadc->State = HAL_ADC_STATE_READY;
;;;744        }
;;;745      }
;;;746    
;;;747      /* Note: HAL ADC deInit is done independently of ADC conversion stop        */
;;;748      /*       and disable return status. In case of status fail, attempt to      */
;;;749      /*       perform deinitialization anyway and it is up user code in          */
;;;750      /*       in HAL_ADC_MspDeInit() to reset the ADC peripheral using           */
;;;751      /*       system RCC hard reset.                                             */
;;;752    
;;;753      /* ========== Reset ADC registers ========== */
;;;754      /* Reset register IER */
;;;755      __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 | ADC_IT_AWD1 |
;;;756                                  ADC_IT_JQOVF | ADC_IT_OVR  |
;;;757                                  ADC_IT_JEOS  | ADC_IT_JEOC |
;;;758                                  ADC_IT_EOS   | ADC_IT_EOC  |
;;;759                                  ADC_IT_EOSMP | ADC_IT_RDY));
;;;760    
;;;761      /* Reset register ISR */
;;;762      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 | ADC_FLAG_AWD1 |
;;;763                                  ADC_FLAG_JQOVF | ADC_FLAG_OVR  |
;;;764                                  ADC_FLAG_JEOS  | ADC_FLAG_JEOC |
;;;765                                  ADC_FLAG_EOS   | ADC_FLAG_EOC  |
;;;766                                  ADC_FLAG_EOSMP | ADC_FLAG_RDY));
;;;767    
;;;768      /* Reset register CR */
;;;769      /* Bits ADC_CR_JADSTP, ADC_CR_ADSTP, ADC_CR_JADSTART, ADC_CR_ADSTART,
;;;770         ADC_CR_ADCAL, ADC_CR_ADDIS and ADC_CR_ADEN are in access mode "read-set":
;;;771         no direct reset applicable.
;;;772         Update CR register to reset value where doable by software */
;;;773      CLEAR_BIT(hadc->Instance->CR, ADC_CR_ADVREGEN | ADC_CR_ADCALDIF);
;;;774      SET_BIT(hadc->Instance->CR, ADC_CR_DEEPPWD);
;;;775    
;;;776      /* Reset register CFGR */
;;;777      CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_FIELDS);
;;;778      SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);
;;;779    
;;;780      /* Reset register CFGR2 */
;;;781      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSM  | ADC_CFGR2_TROVS   | ADC_CFGR2_OVSS |
;;;782                ADC_CFGR2_OVSR  | ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSE);
;;;783    
;;;784      /* Reset register SMPR1 */
;;;785      CLEAR_BIT(hadc->Instance->SMPR1, ADC_SMPR1_FIELDS);
;;;786    
;;;787      /* Reset register SMPR2 */
;;;788      CLEAR_BIT(hadc->Instance->SMPR2, ADC_SMPR2_SMP18 | ADC_SMPR2_SMP17 | ADC_SMPR2_SMP16 |
;;;789                ADC_SMPR2_SMP15 | ADC_SMPR2_SMP14 | ADC_SMPR2_SMP13 |
;;;790                ADC_SMPR2_SMP12 | ADC_SMPR2_SMP11 | ADC_SMPR2_SMP10);
;;;791    
;;;792      /* Reset register TR1 */
;;;793      CLEAR_BIT(hadc->Instance->TR1, ADC_TR1_HT1 | ADC_TR1_LT1);
;;;794    
;;;795      /* Reset register TR2 */
;;;796      CLEAR_BIT(hadc->Instance->TR2, ADC_TR2_HT2 | ADC_TR2_LT2);
;;;797    
;;;798      /* Reset register TR3 */
;;;799      CLEAR_BIT(hadc->Instance->TR3, ADC_TR3_HT3 | ADC_TR3_LT3);
;;;800    
;;;801      /* Reset register SQR1 */
;;;802      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_SQ4 | ADC_SQR1_SQ3 | ADC_SQR1_SQ2 |
;;;803                ADC_SQR1_SQ1 | ADC_SQR1_L);
;;;804    
;;;805      /* Reset register SQR2 */
;;;806      CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7 |
;;;807                ADC_SQR2_SQ6 | ADC_SQR2_SQ5);
;;;808    
;;;809      /* Reset register SQR3 */
;;;810      CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ14 | ADC_SQR3_SQ13 | ADC_SQR3_SQ12 |
;;;811                ADC_SQR3_SQ11 | ADC_SQR3_SQ10);
;;;812    
;;;813      /* Reset register SQR4 */
;;;814      CLEAR_BIT(hadc->Instance->SQR4, ADC_SQR4_SQ16 | ADC_SQR4_SQ15);
;;;815    
;;;816      /* Register JSQR was reset when the ADC was disabled */
;;;817    
;;;818      /* Reset register DR */
;;;819      /* bits in access mode read only, no direct reset applicable*/
;;;820    
;;;821      /* Reset register OFR1 */
;;;822      CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1);
;;;823      /* Reset register OFR2 */
;;;824      CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_OFFSET2_EN | ADC_OFR2_OFFSET2_CH | ADC_OFR2_OFFSET2);
;;;825      /* Reset register OFR3 */
;;;826      CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_OFFSET3_EN | ADC_OFR3_OFFSET3_CH | ADC_OFR3_OFFSET3);
;;;827      /* Reset register OFR4 */
;;;828      CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_OFFSET4_EN | ADC_OFR4_OFFSET4_CH | ADC_OFR4_OFFSET4);
;;;829    
;;;830      /* Reset registers JDR1, JDR2, JDR3, JDR4 */
;;;831      /* bits in access mode read only, no direct reset applicable*/
;;;832    
;;;833      /* Reset register AWD2CR */
;;;834      CLEAR_BIT(hadc->Instance->AWD2CR, ADC_AWD2CR_AWD2CH);
;;;835    
;;;836      /* Reset register AWD3CR */
;;;837      CLEAR_BIT(hadc->Instance->AWD3CR, ADC_AWD3CR_AWD3CH);
;;;838    
;;;839      /* Reset register DIFSEL */
;;;840      CLEAR_BIT(hadc->Instance->DIFSEL, ADC_DIFSEL_DIFSEL);
;;;841    
;;;842      /* Reset register CALFACT */
;;;843      CLEAR_BIT(hadc->Instance->CALFACT, ADC_CALFACT_CALFACT_D | ADC_CALFACT_CALFACT_S);
;;;844    
;;;845    
;;;846      /* ========== Reset common ADC registers ========== */
;;;847    
;;;848      /* Software is allowed to change common parameters only when all the other
;;;849         ADCs are disabled.   */
;;;850      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
;;;851      {
;;;852        /* Reset configuration of ADC common register CCR:
;;;853          - clock mode: CKMODE, PRESCEN
;;;854          - multimode related parameters (when this feature is available): MDMA,
;;;855            DMACFG, DELAY, DUAL (set by HAL_ADCEx_MultiModeConfigChannel() API)
;;;856          - internal measurement paths: Vbat, temperature sensor, Vref (set into
;;;857            HAL_ADC_ConfigChannel() or HAL_ADCEx_InjectedConfigChannel() )
;;;858        */
;;;859        ADC_CLEAR_COMMON_CONTROL_REGISTER(hadc);
;;;860    
;;;861        /* ========== Hard reset ADC peripheral ========== */
;;;862        /* Performs a global reset of the entire ADC peripherals instances        */
;;;863        /* sharing the same common ADC instance: ADC state is forced to           */
;;;864        /* a similar state as after device power-on.                              */
;;;865        /* Note: A possible implementation is to add RCC bus reset of ADC         */
;;;866        /* (for example, using macro                                              */
;;;867        /*  __HAL_RCC_ADC..._FORCE_RESET()/..._RELEASE_RESET()/..._CLK_DISABLE()) */
;;;868        /* in function "void HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc)":         */
;;;869    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;870        if (hadc->MspDeInitCallback == NULL)
;;;871        {
;;;872          hadc->MspDeInitCallback = HAL_ADC_MspDeInit; /* Legacy weak MspDeInit  */
;;;873        }
;;;874    
;;;875        /* DeInit the low level hardware */
;;;876        hadc->MspDeInitCallback(hadc);
;;;877    #else
;;;878        /* DeInit the low level hardware */
;;;879        HAL_ADC_MspDeInit(hadc);
;;;880    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;881      }
;;;882    
;;;883      /* Set ADC error code to none */
;;;884      ADC_CLEAR_ERRORCODE(hadc);
;;;885    
;;;886      /* Reset injected channel configuration parameters */
;;;887      hadc->InjectionConfig.ContextQueue = 0;
;;;888      hadc->InjectionConfig.ChannelCount = 0;
;;;889    
;;;890      /* Set ADC state */
;;;891      hadc->State = HAL_ADC_STATE_RESET;
;;;892    
;;;893      /* Process unlocked */
;;;894      __HAL_UNLOCK(hadc);
;;;895    
;;;896      /* Return function status */
;;;897      return tmp_hal_status;
;;;898    }
00002c  bd70              POP      {r4-r6,pc}
                  |L11.46|
00002e  4620              MOV      r0,r4                 ;737
000030  f7fffffe          BL       ADC_Disable
000034  4605              MOV      r5,r0                 ;737
000036  0028              MOVS     r0,r5                 ;740
000038  d101              BNE      |L11.62|
00003a  2001              MOVS     r0,#1                 ;743
00003c  65a0              STR      r0,[r4,#0x58]         ;743
                  |L11.62|
00003e  6820              LDR      r0,[r4,#0]            ;755
000040  6841              LDR      r1,[r0,#4]            ;755
000042  f36f010a          BFC      r1,#0,#11             ;755
000046  6041              STR      r1,[r0,#4]            ;755
000048  6821              LDR      r1,[r4,#0]            ;762
00004a  f24070ff          MOV      r0,#0x7ff             ;762
00004e  6008              STR      r0,[r1,#0]            ;762
000050  6820              LDR      r0,[r4,#0]            ;773
000052  6881              LDR      r1,[r0,#8]            ;773
000054  f02141a0          BIC      r1,r1,#0x50000000     ;773
000058  6081              STR      r1,[r0,#8]            ;773
00005a  6820              LDR      r0,[r4,#0]            ;774
00005c  6881              LDR      r1,[r0,#8]            ;774
00005e  f0415100          ORR      r1,r1,#0x20000000     ;774
000062  6081              STR      r1,[r0,#8]            ;774
000064  6820              LDR      r0,[r4,#0]            ;777
000066  68c1              LDR      r1,[r0,#0xc]          ;777
000068  f0012180          AND      r1,r1,#0x80008000     ;777
00006c  60c1              STR      r1,[r0,#0xc]          ;777
00006e  6820              LDR      r0,[r4,#0]            ;778
000070  68c1              LDR      r1,[r0,#0xc]          ;778
000072  f0414100          ORR      r1,r1,#0x80000000     ;778
000076  60c1              STR      r1,[r0,#0xc]          ;778
000078  6820              LDR      r0,[r4,#0]            ;781
00007a  6901              LDR      r1,[r0,#0x10]         ;781
00007c  f36f010a          BFC      r1,#0,#11             ;781
000080  6101              STR      r1,[r0,#0x10]         ;781
000082  6820              LDR      r0,[r4,#0]            ;785
000084  6941              LDR      r1,[r0,#0x14]         ;785
000086  f0014180          AND      r1,r1,#0x40000000     ;785
00008a  6141              STR      r1,[r0,#0x14]         ;785
00008c  6820              LDR      r0,[r4,#0]            ;788
00008e  6981              LDR      r1,[r0,#0x18]         ;788
000090  f0014178          AND      r1,r1,#0xf8000000     ;788
000094  6181              STR      r1,[r0,#0x18]         ;788
000096  6820              LDR      r0,[r4,#0]            ;793
000098  6a01              LDR      r1,[r0,#0x20]         ;793
00009a  f00121f0          AND      r1,r1,#0xf000f000     ;793
00009e  6201              STR      r1,[r0,#0x20]         ;793
0000a0  6820              LDR      r0,[r4,#0]            ;796
0000a2  6a41              LDR      r1,[r0,#0x24]         ;796
0000a4  f00121ff          AND      r1,r1,#0xff00ff00     ;796
0000a8  6241              STR      r1,[r0,#0x24]         ;796
0000aa  6820              LDR      r0,[r4,#0]            ;799
0000ac  6a81              LDR      r1,[r0,#0x28]         ;799
0000ae  f00121ff          AND      r1,r1,#0xff00ff00     ;799
0000b2  6281              STR      r1,[r0,#0x28]         ;799
0000b4  6820              LDR      r0,[r4,#0]            ;802
0000b6  6b01              LDR      r1,[r0,#0x30]         ;802
0000b8  4a2e              LDR      r2,|L11.372|
0000ba  4011              ANDS     r1,r1,r2              ;802
0000bc  6301              STR      r1,[r0,#0x30]         ;802
0000be  6820              LDR      r0,[r4,#0]            ;806
0000c0  6b42              LDR      r2,[r0,#0x34]         ;806
0000c2  492c              LDR      r1,|L11.372|
0000c4  3910              SUBS     r1,r1,#0x10           ;806
0000c6  400a              ANDS     r2,r2,r1              ;806
0000c8  6342              STR      r2,[r0,#0x34]         ;806
0000ca  6820              LDR      r0,[r4,#0]            ;810
0000cc  6b82              LDR      r2,[r0,#0x38]         ;810
0000ce  400a              ANDS     r2,r2,r1              ;810
0000d0  6382              STR      r2,[r0,#0x38]         ;810
0000d2  6820              LDR      r0,[r4,#0]            ;814
0000d4  6bc1              LDR      r1,[r0,#0x3c]         ;814
0000d6  f24072df          MOV      r2,#0x7df             ;814
0000da  4391              BICS     r1,r1,r2              ;814
0000dc  63c1              STR      r1,[r0,#0x3c]         ;814
0000de  6820              LDR      r0,[r4,#0]            ;822
0000e0  6e02              LDR      r2,[r0,#0x60]         ;822
0000e2  4925              LDR      r1,|L11.376|
0000e4  400a              ANDS     r2,r2,r1              ;822
0000e6  6602              STR      r2,[r0,#0x60]         ;822
0000e8  6820              LDR      r0,[r4,#0]            ;824
0000ea  6e42              LDR      r2,[r0,#0x64]         ;824
0000ec  400a              ANDS     r2,r2,r1              ;824
0000ee  6642              STR      r2,[r0,#0x64]         ;824
0000f0  6820              LDR      r0,[r4,#0]            ;826
0000f2  6e82              LDR      r2,[r0,#0x68]         ;826
0000f4  400a              ANDS     r2,r2,r1              ;826
0000f6  6682              STR      r2,[r0,#0x68]         ;826
0000f8  6820              LDR      r0,[r4,#0]            ;828
0000fa  6ec2              LDR      r2,[r0,#0x6c]         ;828
0000fc  400a              ANDS     r2,r2,r1              ;828
0000fe  66c2              STR      r2,[r0,#0x6c]         ;828
000100  6820              LDR      r0,[r4,#0]            ;834
000102  f8501fa0          LDR      r1,[r0,#0xa0]!        ;834
000106  f36f0112          BFC      r1,#0,#19             ;834
00010a  6001              STR      r1,[r0,#0]            ;834
00010c  6820              LDR      r0,[r4,#0]            ;837
00010e  f8501fa4          LDR      r1,[r0,#0xa4]!        ;837
000112  f36f0112          BFC      r1,#0,#19             ;837
000116  6001              STR      r1,[r0,#0]            ;837
000118  6820              LDR      r0,[r4,#0]            ;840
00011a  f8501fb0          LDR      r1,[r0,#0xb0]!        ;840
00011e  f36f0112          BFC      r1,#0,#19             ;840
000122  6001              STR      r1,[r0,#0]            ;840
000124  6820              LDR      r0,[r4,#0]            ;843
000126  f8501fb4          LDR      r1,[r0,#0xb4]!        ;843
00012a  f021117f          BIC      r1,r1,#0x7f007f       ;843
00012e  6001              STR      r1,[r0,#0]            ;843
000130  4912              LDR      r1,|L11.380|
000132  6888              LDR      r0,[r1,#8]            ;843
000134  f3c00000          UBFX     r0,r0,#0,#1           ;843
000138  4a11              LDR      r2,|L11.384|
00013a  6892              LDR      r2,[r2,#8]            ;843
00013c  f3c20200          UBFX     r2,r2,#0,#1           ;843
000140  4310              ORRS     r0,r0,r2              ;850
000142  4a10              LDR      r2,|L11.388|
000144  6892              LDR      r2,[r2,#8]            ;850
000146  f3c20200          UBFX     r2,r2,#0,#1           ;850
00014a  4310              ORRS     r0,r0,r2              ;850
00014c  d108              BNE      |L11.352|
00014e  f8d10308          LDR      r0,[r1,#0x308]        ;859
000152  4a0d              LDR      r2,|L11.392|
000154  4010              ANDS     r0,r0,r2              ;859
000156  f8c10308          STR      r0,[r1,#0x308]        ;859
00015a  4620              MOV      r0,r4                 ;879
00015c  f7fffffe          BL       HAL_ADC_MspDeInit
                  |L11.352|
000160  2000              MOVS     r0,#0                 ;884
000162  65e0              STR      r0,[r4,#0x5c]         ;884
000164  6620              STR      r0,[r4,#0x60]         ;887
000166  6660              STR      r0,[r4,#0x64]         ;888
000168  65a0              STR      r0,[r4,#0x58]         ;891
00016a  f8840054          STRB     r0,[r4,#0x54]         ;894
00016e  4628              MOV      r0,r5                 ;897
000170  bd70              POP      {r4-r6,pc}
;;;899    
                          ENDP

000172  0000              DCW      0x0000
                  |L11.372|
                          DCD      0xe0820830
                  |L11.376|
                          DCD      0x03fff000
                  |L11.380|
                          DCD      0x50040000
                  |L11.384|
                          DCD      0x50040100
                  |L11.388|
                          DCD      0x50040200
                  |L11.392|
                          DCD      0xfe0010e0

                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;2659     */
;;;2660   __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;2661   {
;;;2662     /* Prevent unused argument(s) compilation warning */
;;;2663     UNUSED(hadc);
;;;2664   
;;;2665     /* NOTE : This function should not be modified. When the callback is needed,
;;;2666               function HAL_ADC_ErrorCallback must be implemented in the user file.
;;;2667     */
;;;2668   }
;;;2669   
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;3230     */
;;;3231   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  6dc0              LDR      r0,[r0,#0x5c]
;;;3232   {
;;;3233     /* Check the parameters */
;;;3234     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;3235   
;;;3236     return hadc->ErrorCode;
;;;3237   }
000002  4770              BX       lr
;;;3238   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;3216     */
;;;3217   uint32_t HAL_ADC_GetState(ADC_HandleTypeDef *hadc)
000000  6d80              LDR      r0,[r0,#0x58]
;;;3218   {
;;;3219     /* Check the parameters */
;;;3220     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;3221   
;;;3222     /* Return ADC handle state */
;;;3223     return hadc->State;
;;;3224   }
000002  4770              BX       lr
;;;3225   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;2218     */
;;;2219   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef *hadc)
000000  6800              LDR      r0,[r0,#0]
;;;2220   {
;;;2221     /* Check the parameters */
;;;2222     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2223   
;;;2224     /* Note: EOC flag is not cleared here by software because automatically     */
;;;2225     /*       cleared by hardware when reading register DR.                      */
;;;2226   
;;;2227     /* Return ADC converted value */
;;;2228     return hadc->Instance->DR;
000002  6c00              LDR      r0,[r0,#0x40]
;;;2229   }
000004  4770              BX       lr
;;;2230   
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_ADC_IRQHandler PROC
;;;2235     */
;;;2236   void HAL_ADC_IRQHandler(ADC_HandleTypeDef *hadc)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2237   {
000004  4604              MOV      r4,r0
;;;2238     uint32_t overrun_error = 0UL; /* flag set if overrun occurrence has to be considered as an error */
000006  f04f0800          MOV      r8,#0
;;;2239     uint32_t tmp_isr = hadc->Instance->ISR;
00000a  6820              LDR      r0,[r4,#0]
00000c  6805              LDR      r5,[r0,#0]
;;;2240     uint32_t tmp_ier = hadc->Instance->IER;
00000e  6846              LDR      r6,[r0,#4]
000010  489a              LDR      r0,|L16.636|
000012  6880              LDR      r0,[r0,#8]
000014  f000071f          AND      r7,r0,#0x1f
;;;2241     uint32_t tmp_adc_inj_is_trigger_source_sw_start;
;;;2242     uint32_t tmp_adc_reg_is_trigger_source_sw_start;
;;;2243     uint32_t tmp_cfgr;
;;;2244   #if defined(ADC_MULTIMODE_SUPPORT)
;;;2245     const ADC_TypeDef *tmpADC_Master;
;;;2246     uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;2247   #endif
;;;2248   
;;;2249     /* Check the parameters */
;;;2250     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2251     assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
;;;2252   
;;;2253     /* ========== Check End of Sampling flag for ADC group regular ========== */
;;;2254     if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
000018  07a8              LSLS     r0,r5,#30
00001a  d50e              BPL      |L16.58|
00001c  07b0              LSLS     r0,r6,#30
00001e  d50c              BPL      |L16.58|
;;;2255     {
;;;2256       /* Update state machine on end of sampling status if not in error state */
;;;2257       if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
000020  6da0              LDR      r0,[r4,#0x58]
000022  06c0              LSLS     r0,r0,#27
000024  d403              BMI      |L16.46|
;;;2258       {
;;;2259         /* Set ADC state */
;;;2260         SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
000026  6da0              LDR      r0,[r4,#0x58]
000028  f4406000          ORR      r0,r0,#0x800
00002c  65a0              STR      r0,[r4,#0x58]
                  |L16.46|
;;;2261       }
;;;2262   
;;;2263       /* End Of Sampling callback */
;;;2264   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2265       hadc->EndOfSamplingCallback(hadc);
;;;2266   #else
;;;2267       HAL_ADCEx_EndOfSamplingCallback(hadc);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_ADCEx_EndOfSamplingCallback
;;;2268   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2269   
;;;2270       /* Clear regular group conversion flag */
;;;2271       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
000034  6821              LDR      r1,[r4,#0]
000036  2002              MOVS     r0,#2
000038  6008              STR      r0,[r1,#0]
                  |L16.58|
;;;2272     }
;;;2273   
;;;2274     /* ====== Check ADC group regular end of unitary conversion sequence conversions ===== */
;;;2275     if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
;;;2276         (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
;;;2277     {
;;;2278       /* Update state machine on conversion status if not in error state */
;;;2279       if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
;;;2280       {
;;;2281         /* Set ADC state */
;;;2282         SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;2283       }
;;;2284   
;;;2285       /* Determine whether any further conversion upcoming on group regular     */
;;;2286       /* by external trigger, continuous mode or scan sequence on going         */
;;;2287       /* to disable interruption.                                               */
;;;2288       if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
;;;2289       {
;;;2290         /* Get relevant register CFGR in ADC instance of ADC master or slave    */
;;;2291         /* in function of multimode state (for devices with multimode           */
;;;2292         /* available).                                                          */
;;;2293   #if defined(ADC_MULTIMODE_SUPPORT)
;;;2294         if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
00003a  f8dfb244          LDR      r11,|L16.640|
00003e  f8df9244          LDR      r9,|L16.644|
000042  0768              LSLS     r0,r5,#29             ;2275
000044  d501              BPL      |L16.74|
000046  0770              LSLS     r0,r6,#29             ;2275
000048  d403              BMI      |L16.82|
                  |L16.74|
00004a  0728              LSLS     r0,r5,#28             ;2276
00004c  d537              BPL      |L16.190|
00004e  0730              LSLS     r0,r6,#28             ;2276
000050  d535              BPL      |L16.190|
                  |L16.82|
000052  6da0              LDR      r0,[r4,#0x58]         ;2279
000054  06c0              LSLS     r0,r0,#27             ;2279
000056  d403              BMI      |L16.96|
000058  6da0              LDR      r0,[r4,#0x58]         ;2282
00005a  f4407000          ORR      r0,r0,#0x200          ;2282
00005e  65a0              STR      r0,[r4,#0x58]         ;2282
                  |L16.96|
000060  6820              LDR      r0,[r4,#0]            ;2288
000062  f7fffffe          BL       LL_ADC_REG_IsTriggerSourceSWStart
000066  b320              CBZ      r0,|L16.178|
000068  6820              LDR      r0,[r4,#0]
00006a  4558              CMP      r0,r11
00006c  d101              BNE      |L16.114|
00006e  4649              MOV      r1,r9
000070  e000              B        |L16.116|
                  |L16.114|
000072  4601              MOV      r1,r0
                  |L16.116|
000074  4281              CMP      r1,r0
000076  d008              BEQ      |L16.138|
;;;2295             || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
000078  b13f              CBZ      r7,|L16.138|
;;;2296             || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
00007a  2f05              CMP      r7,#5
00007c  d005              BEQ      |L16.138|
;;;2297             || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
00007e  2f09              CMP      r7,#9
000080  d003              BEQ      |L16.138|
;;;2298            )
;;;2299         {
;;;2300           /* check CONT bit directly in handle ADC CFGR register */
;;;2301           tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;2302         }
;;;2303         else
;;;2304         {
;;;2305           /* else need to check Master ADC CONT bit */
;;;2306           tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
000082  4558              CMP      r0,r11
000084  d103              BNE      |L16.142|
000086  4649              MOV      r1,r9
000088  e002              B        |L16.144|
                  |L16.138|
00008a  68c1              LDR      r1,[r0,#0xc]          ;2301
00008c  e001              B        |L16.146|
                  |L16.142|
00008e  4601              MOV      r1,r0
                  |L16.144|
;;;2307           tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
000090  68c9              LDR      r1,[r1,#0xc]
                  |L16.146|
;;;2308         }
;;;2309   #else
;;;2310         tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;2311   #endif
;;;2312   
;;;2313         /* Carry on if continuous mode is disabled */
;;;2314         if (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) != ADC_CFGR_CONT)
000092  0489              LSLS     r1,r1,#18
000094  d40d              BMI      |L16.178|
;;;2315         {
;;;2316           /* If End of Sequence is reached, disable interrupts */
;;;2317           if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
000096  6801              LDR      r1,[r0,#0]
000098  0709              LSLS     r1,r1,#28
00009a  d50a              BPL      |L16.178|
;;;2318           {
;;;2319             /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit         */
;;;2320             /* ADSTART==0 (no conversion on going)                              */
;;;2321             if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
00009c  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
0000a0  b358              CBZ      r0,|L16.250|
;;;2322             {
;;;2323               /* Disable ADC end of sequence conversion interrupt */
;;;2324               /* Note: Overrun interrupt was enabled with EOC interrupt in      */
;;;2325               /* HAL_Start_IT(), but is not disabled here because can be used   */
;;;2326               /* by overrun IRQ process below.                                  */
;;;2327               __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
;;;2328   
;;;2329               /* Set ADC state */
;;;2330               CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;2331   
;;;2332               if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
;;;2333               {
;;;2334                 SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;2335               }
;;;2336             }
;;;2337             else
;;;2338             {
;;;2339               /* Change ADC state to error state */
;;;2340               SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
0000a2  6da0              LDR      r0,[r4,#0x58]
0000a4  f0400010          ORR      r0,r0,#0x10
0000a8  65a0              STR      r0,[r4,#0x58]
;;;2341   
;;;2342               /* Set ADC error code to ADC peripheral internal error */
;;;2343               SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
0000aa  6de0              LDR      r0,[r4,#0x5c]
0000ac  f0400001          ORR      r0,r0,#1
0000b0  65e0              STR      r0,[r4,#0x5c]
                  |L16.178|
;;;2344             }
;;;2345           }
;;;2346         }
;;;2347       }
;;;2348   
;;;2349       /* Conversion complete callback */
;;;2350       /* Note: Into callback function "HAL_ADC_ConvCpltCallback()",             */
;;;2351       /*       to determine if conversion has been triggered from EOC or EOS,   */
;;;2352       /*       possibility to use:                                              */
;;;2353       /*        " if ( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) "               */
;;;2354   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2355       hadc->ConvCpltCallback(hadc);
;;;2356   #else
;;;2357       HAL_ADC_ConvCpltCallback(hadc);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;2358   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2359   
;;;2360       /* Clear regular group conversion flag */
;;;2361       /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
;;;2362       /*       conversion flags clear induces the release of the preserved data.*/
;;;2363       /*       Therefore, if the preserved data value is needed, it must be     */
;;;2364       /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */
;;;2365       __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
0000b8  6821              LDR      r1,[r4,#0]
0000ba  200c              MOVS     r0,#0xc
0000bc  6008              STR      r0,[r1,#0]
                  |L16.190|
;;;2366     }
;;;2367   
;;;2368     /* ====== Check ADC group injected end of unitary conversion sequence conversions ===== */
;;;2369     if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
0000be  06a8              LSLS     r0,r5,#26
0000c0  d501              BPL      |L16.198|
0000c2  06b0              LSLS     r0,r6,#26
0000c4  d403              BMI      |L16.206|
                  |L16.198|
;;;2370         (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
0000c6  0668              LSLS     r0,r5,#25
0000c8  d556              BPL      |L16.376|
0000ca  0670              LSLS     r0,r6,#25
0000cc  d554              BPL      |L16.376|
                  |L16.206|
;;;2371     {
;;;2372       /* Update state machine on conversion status if not in error state */
;;;2373       if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
0000ce  6da0              LDR      r0,[r4,#0x58]
0000d0  06c0              LSLS     r0,r0,#27
0000d2  d403              BMI      |L16.220|
;;;2374       {
;;;2375         /* Set ADC state */
;;;2376         SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
0000d4  6da0              LDR      r0,[r4,#0x58]
0000d6  f4405000          ORR      r0,r0,#0x2000
0000da  65a0              STR      r0,[r4,#0x58]
                  |L16.220|
;;;2377       }
;;;2378   
;;;2379       /* Retrieve ADC configuration */
;;;2380       tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
0000dc  6820              LDR      r0,[r4,#0]
0000de  6cc1              LDR      r1,[r0,#0x4c]
0000e0  f0110fc0          TST      r1,#0xc0
0000e4  d01a              BEQ      |L16.284|
0000e6  f04f0a00          MOV      r10,#0
                  |L16.234|
;;;2381       tmp_adc_reg_is_trigger_source_sw_start = LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance);
0000ea  f7fffffe          BL       LL_ADC_REG_IsTriggerSourceSWStart
0000ee  4602              MOV      r2,r0
;;;2382       /* Get relevant register CFGR in ADC instance of ADC master or slave  */
;;;2383       /* in function of multimode state (for devices with multimode         */
;;;2384       /* available).                                                        */
;;;2385   #if defined(ADC_MULTIMODE_SUPPORT)
;;;2386       if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
0000f0  6820              LDR      r0,[r4,#0]
0000f2  4558              CMP      r0,r11
0000f4  d115              BNE      |L16.290|
0000f6  4649              MOV      r1,r9
0000f8  e014              B        |L16.292|
                  |L16.250|
0000fa  6820              LDR      r0,[r4,#0]            ;2327
0000fc  6841              LDR      r1,[r0,#4]            ;2327
0000fe  f021010c          BIC      r1,r1,#0xc            ;2327
000102  6041              STR      r1,[r0,#4]            ;2327
000104  6da0              LDR      r0,[r4,#0x58]         ;2330
000106  f4207080          BIC      r0,r0,#0x100          ;2330
00010a  65a0              STR      r0,[r4,#0x58]         ;2330
00010c  6da0              LDR      r0,[r4,#0x58]         ;2332
00010e  04c0              LSLS     r0,r0,#19             ;2332
000110  d4cf              BMI      |L16.178|
000112  6da0              LDR      r0,[r4,#0x58]         ;2334
000114  f0400001          ORR      r0,r0,#1              ;2334
000118  65a0              STR      r0,[r4,#0x58]         ;2334
00011a  e7ca              B        |L16.178|
                  |L16.284|
00011c  f04f0a01          MOV      r10,#1                ;2334
000120  e7e3              B        |L16.234|
                  |L16.290|
000122  4601              MOV      r1,r0
                  |L16.292|
000124  4281              CMP      r1,r0
000126  d065              BEQ      |L16.500|
;;;2387           || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
000128  b3f7              CBZ      r7,|L16.424|
;;;2388           || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
00012a  2f06              CMP      r7,#6
00012c  d062              BEQ      |L16.500|
;;;2389           || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
00012e  2f07              CMP      r7,#7
000130  d060              BEQ      |L16.500|
;;;2390          )
;;;2391       {
;;;2392         tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;2393       }
;;;2394       else
;;;2395       {
;;;2396         tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
000132  4558              CMP      r0,r11
000134  d000              BEQ      |L16.312|
000136  4681              MOV      r9,r0
                  |L16.312|
;;;2397         tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
000138  f8d9100c          LDR      r1,[r9,#0xc]
                  |L16.316|
;;;2398       }
;;;2399   #else
;;;2400       tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;2401   #endif
;;;2402   
;;;2403       /* Disable interruption if no further conversion upcoming by injected     */
;;;2404       /* external trigger or by automatic injected conversion with regular      */
;;;2405       /* group having no further conversion upcoming (same conditions as        */
;;;2406       /* regular group interruption disabling above),                           */
;;;2407       /* and if injected scan sequence is completed.                            */
;;;2408       if (tmp_adc_inj_is_trigger_source_sw_start != 0UL)
00013c  f1ba0f00          CMP      r10,#0
000140  d014              BEQ      |L16.364|
;;;2409       {
;;;2410         if ((READ_BIT(tmp_cfgr, ADC_CFGR_JAUTO) == 0UL) ||
000142  018b              LSLS     r3,r1,#6
000144  d502              BPL      |L16.332|
;;;2411             ((tmp_adc_reg_is_trigger_source_sw_start != 0UL) &&
000146  b18a              CBZ      r2,|L16.364|
;;;2412              (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) == 0UL)))
000148  048a              LSLS     r2,r1,#18
00014a  d40f              BMI      |L16.364|
                  |L16.332|
;;;2413         {
;;;2414           /* If End of Sequence is reached, disable interrupts */
;;;2415           if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
00014c  6802              LDR      r2,[r0,#0]
00014e  0652              LSLS     r2,r2,#25
000150  d50c              BPL      |L16.364|
;;;2416           {
;;;2417             /* Particular case if injected contexts queue is enabled:             */
;;;2418             /* when the last context has been fully processed, JSQR is reset      */
;;;2419             /* by the hardware. Even if no injected conversion is planned to come */
;;;2420             /* (queue empty, triggers are ignored), it can start again            */
;;;2421             /* immediately after setting a new context (JADSTART is still set).   */
;;;2422             /* Therefore, state of HAL ADC injected group is kept to busy.        */
;;;2423             if (READ_BIT(tmp_cfgr, ADC_CFGR_JQM) == 0UL)
000152  0289              LSLS     r1,r1,#10
000154  d40a              BMI      |L16.364|
;;;2424             {
;;;2425               /* Allowed to modify bits ADC_IT_JEOC/ADC_IT_JEOS only if bit       */
;;;2426               /* JADSTART==0 (no conversion on going)                             */
;;;2427               if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
000156  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
00015a  b330              CBZ      r0,|L16.426|
;;;2428               {
;;;2429                 /* Disable ADC end of sequence conversion interrupt  */
;;;2430                 __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
;;;2431   
;;;2432                 /* Set ADC state */
;;;2433                 CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
;;;2434   
;;;2435                 if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
;;;2436                 {
;;;2437                   SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;2438                 }
;;;2439               }
;;;2440               else
;;;2441               {
;;;2442                 /* Update ADC state machine to error */
;;;2443                 SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
00015c  6da0              LDR      r0,[r4,#0x58]
00015e  f0400010          ORR      r0,r0,#0x10
000162  65a0              STR      r0,[r4,#0x58]
;;;2444   
;;;2445                 /* Set ADC error code to ADC peripheral internal error */
;;;2446                 SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000164  6de0              LDR      r0,[r4,#0x5c]
000166  f0400001          ORR      r0,r0,#1
00016a  65e0              STR      r0,[r4,#0x5c]
                  |L16.364|
;;;2447               }
;;;2448             }
;;;2449           }
;;;2450         }
;;;2451       }
;;;2452   
;;;2453       /* Injected Conversion complete callback */
;;;2454       /* Note:  HAL_ADCEx_InjectedConvCpltCallback can resort to
;;;2455                 if (__HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_JEOS)) or
;;;2456                 if (__HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_JEOC)) to determine whether
;;;2457                 interruption has been triggered by end of conversion or end of
;;;2458                 sequence.    */
;;;2459   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2460       hadc->InjectedConvCpltCallback(hadc);
;;;2461   #else
;;;2462       HAL_ADCEx_InjectedConvCpltCallback(hadc);
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;2463   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2464   
;;;2465       /* Clear injected group conversion flag */
;;;2466       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
000172  6821              LDR      r1,[r4,#0]
000174  2060              MOVS     r0,#0x60
000176  6008              STR      r0,[r1,#0]
                  |L16.376|
;;;2467     }
;;;2468   
;;;2469     /* ========== Check Analog watchdog 1 flag ========== */
;;;2470     if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
000178  0628              LSLS     r0,r5,#24
00017a  d50b              BPL      |L16.404|
00017c  0630              LSLS     r0,r6,#24
00017e  d509              BPL      |L16.404|
;;;2471     {
;;;2472       /* Set ADC state */
;;;2473       SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
000180  6da0              LDR      r0,[r4,#0x58]
000182  f4403080          ORR      r0,r0,#0x10000
000186  65a0              STR      r0,[r4,#0x58]
;;;2474   
;;;2475       /* Level out of window 1 callback */
;;;2476   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2477       hadc->LevelOutOfWindowCallback(hadc);
;;;2478   #else
;;;2479       HAL_ADC_LevelOutOfWindowCallback(hadc);
000188  4620              MOV      r0,r4
00018a  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
;;;2480   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2481   
;;;2482       /* Clear ADC analog watchdog flag */
;;;2483       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
00018e  6821              LDR      r1,[r4,#0]
000190  2080              MOVS     r0,#0x80
000192  6008              STR      r0,[r1,#0]
                  |L16.404|
;;;2484     }
;;;2485   
;;;2486     /* ========== Check analog watchdog 2 flag ========== */
;;;2487     if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
000194  05e8              LSLS     r0,r5,#23
000196  d50f              BPL      |L16.440|
000198  05f0              LSLS     r0,r6,#23
00019a  d50d              BPL      |L16.440|
;;;2488     {
;;;2489       /* Set ADC state */
;;;2490       SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
00019c  6da0              LDR      r0,[r4,#0x58]
00019e  f4403000          ORR      r0,r0,#0x20000
0001a2  65a0              STR      r0,[r4,#0x58]
;;;2491   
;;;2492       /* Level out of window 2 callback */
;;;2493   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2494       hadc->LevelOutOfWindow2Callback(hadc);
;;;2495   #else
;;;2496       HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
0001a4  4620              MOV      r0,r4
0001a6  e001              B        |L16.428|
                  |L16.424|
0001a8  e024              B        |L16.500|
                  |L16.426|
0001aa  e025              B        |L16.504|
                  |L16.428|
0001ac  f7fffffe          BL       HAL_ADCEx_LevelOutOfWindow2Callback
;;;2497   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2498   
;;;2499       /* Clear ADC analog watchdog flag */
;;;2500       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
0001b0  6821              LDR      r1,[r4,#0]
0001b2  f44f7080          MOV      r0,#0x100
0001b6  6008              STR      r0,[r1,#0]
                  |L16.440|
;;;2501     }
;;;2502   
;;;2503     /* ========== Check analog watchdog 3 flag ========== */
;;;2504     if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
0001b8  05a8              LSLS     r0,r5,#22
0001ba  d50c              BPL      |L16.470|
0001bc  05b0              LSLS     r0,r6,#22
0001be  d50a              BPL      |L16.470|
;;;2505     {
;;;2506       /* Set ADC state */
;;;2507       SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
0001c0  6da0              LDR      r0,[r4,#0x58]
0001c2  f4402080          ORR      r0,r0,#0x40000
0001c6  65a0              STR      r0,[r4,#0x58]
;;;2508   
;;;2509       /* Level out of window 3 callback */
;;;2510   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2511       hadc->LevelOutOfWindow3Callback(hadc);
;;;2512   #else
;;;2513       HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
0001c8  4620              MOV      r0,r4
0001ca  f7fffffe          BL       HAL_ADCEx_LevelOutOfWindow3Callback
;;;2514   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2515   
;;;2516       /* Clear ADC analog watchdog flag */
;;;2517       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
0001ce  6821              LDR      r1,[r4,#0]
0001d0  f44f7000          MOV      r0,#0x200
0001d4  6008              STR      r0,[r1,#0]
                  |L16.470|
;;;2518     }
;;;2519   
;;;2520     /* ========== Check Overrun flag ========== */
;;;2521     if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
0001d6  06e8              LSLS     r0,r5,#27
0001d8  d539              BPL      |L16.590|
0001da  06f0              LSLS     r0,r6,#27
0001dc  d537              BPL      |L16.590|
;;;2522     {
;;;2523       /* If overrun is set to overwrite previous data (default setting),        */
;;;2524       /* overrun event is not considered as an error.                           */
;;;2525       /* (cf ref manual "Managing conversions without using the DMA and without */
;;;2526       /* overrun ")                                                             */
;;;2527       /* Exception for usage with DMA overrun event always considered as an     */
;;;2528       /* error.                                                                 */
;;;2529       if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
0001de  6b60              LDR      r0,[r4,#0x34]
0001e0  b1d8              CBZ      r0,|L16.538|
;;;2530       {
;;;2531         overrun_error = 1UL;
;;;2532       }
;;;2533       else
;;;2534       {
;;;2535         /* Check DMA configuration */
;;;2536   #if defined(ADC_MULTIMODE_SUPPORT)
;;;2537         if (tmp_multimode_config != LL_ADC_MULTI_INDEPENDENT)
0001e2  b1ef              CBZ      r7,|L16.544|
0001e4  4825              LDR      r0,|L16.636|
0001e6  6880              LDR      r0,[r0,#8]
0001e8  f4004060          AND      r0,r0,#0xe000
;;;2538         {
;;;2539           /* Multimode (when feature is available) is enabled,
;;;2540              Common Control Register MDMA bits must be checked. */
;;;2541           if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
0001ec  b1f0              CBZ      r0,|L16.556|
;;;2542           {
;;;2543             overrun_error = 1UL;
0001ee  f04f0801          MOV      r8,#1
0001f2  e01b              B        |L16.556|
                  |L16.500|
0001f4  68c1              LDR      r1,[r0,#0xc]          ;2392
0001f6  e7a1              B        |L16.316|
                  |L16.504|
0001f8  6820              LDR      r0,[r4,#0]            ;2430
0001fa  6841              LDR      r1,[r0,#4]            ;2430
0001fc  f0210160          BIC      r1,r1,#0x60           ;2430
000200  6041              STR      r1,[r0,#4]            ;2430
000202  6da0              LDR      r0,[r4,#0x58]         ;2433
000204  f4205080          BIC      r0,r0,#0x1000         ;2433
000208  65a0              STR      r0,[r4,#0x58]         ;2433
00020a  6da0              LDR      r0,[r4,#0x58]         ;2435
00020c  05c0              LSLS     r0,r0,#23             ;2435
00020e  d4ad              BMI      |L16.364|
000210  6da0              LDR      r0,[r4,#0x58]         ;2437
000212  f0400001          ORR      r0,r0,#1              ;2437
000216  65a0              STR      r0,[r4,#0x58]         ;2437
000218  e7a8              B        |L16.364|
                  |L16.538|
00021a  f04f0801          MOV      r8,#1                 ;2531
00021e  e005              B        |L16.556|
                  |L16.544|
;;;2544           }
;;;2545         }
;;;2546         else
;;;2547   #endif
;;;2548         {
;;;2549           /* Multimode not set or feature not available or ADC independent */
;;;2550           if ((hadc->Instance->CFGR & ADC_CFGR_DMAEN) != 0UL)
000220  6820              LDR      r0,[r4,#0]
000222  68c0              LDR      r0,[r0,#0xc]
000224  07c0              LSLS     r0,r0,#31
000226  d001              BEQ      |L16.556|
;;;2551           {
;;;2552             overrun_error = 1UL;
000228  f04f0801          MOV      r8,#1
                  |L16.556|
;;;2553           }
;;;2554         }
;;;2555       }
;;;2556   
;;;2557       if (overrun_error == 1UL)
00022c  f1b80f01          CMP      r8,#1
000230  d10a              BNE      |L16.584|
;;;2558       {
;;;2559         /* Change ADC state to error state */
;;;2560         SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
000232  6da0              LDR      r0,[r4,#0x58]
000234  f4406080          ORR      r0,r0,#0x400
000238  65a0              STR      r0,[r4,#0x58]
;;;2561   
;;;2562         /* Set ADC error code to overrun */
;;;2563         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
00023a  6de0              LDR      r0,[r4,#0x5c]
00023c  f0400002          ORR      r0,r0,#2
000240  65e0              STR      r0,[r4,#0x5c]
;;;2564   
;;;2565         /* Error callback */
;;;2566         /* Note: In case of overrun, ADC conversion data is preserved until     */
;;;2567         /*       flag OVR is reset.                                             */
;;;2568         /*       Therefore, old ADC conversion data can be retrieved in         */
;;;2569         /*       function "HAL_ADC_ErrorCallback()".                            */
;;;2570   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2571         hadc->ErrorCallback(hadc);
;;;2572   #else
;;;2573         HAL_ADC_ErrorCallback(hadc);
000242  4620              MOV      r0,r4
000244  f7fffffe          BL       HAL_ADC_ErrorCallback
                  |L16.584|
;;;2574   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2575       }
;;;2576   
;;;2577       /* Clear ADC overrun flag */
;;;2578       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
000248  6821              LDR      r1,[r4,#0]
00024a  2010              MOVS     r0,#0x10
00024c  6008              STR      r0,[r1,#0]
                  |L16.590|
;;;2579     }
;;;2580   
;;;2581     /* ========== Check Injected context queue overflow flag ========== */
;;;2582     if (((tmp_isr & ADC_FLAG_JQOVF) == ADC_FLAG_JQOVF) && ((tmp_ier & ADC_IT_JQOVF) == ADC_IT_JQOVF))
00024e  0568              LSLS     r0,r5,#21
000250  d512              BPL      |L16.632|
000252  0570              LSLS     r0,r6,#21
000254  d510              BPL      |L16.632|
;;;2583     {
;;;2584       /* Change ADC state to overrun state */
;;;2585       SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
000256  6da0              LDR      r0,[r4,#0x58]
000258  f4404080          ORR      r0,r0,#0x4000
00025c  65a0              STR      r0,[r4,#0x58]
;;;2586   
;;;2587       /* Set ADC error code to Injected context queue overflow */
;;;2588       SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
00025e  6de0              LDR      r0,[r4,#0x5c]
000260  f0400008          ORR      r0,r0,#8
000264  65e0              STR      r0,[r4,#0x5c]
;;;2589   
;;;2590       /* Clear the Injected context queue overflow flag */
;;;2591       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
000266  6821              LDR      r1,[r4,#0]
000268  f44f6080          MOV      r0,#0x400
00026c  6008              STR      r0,[r1,#0]
;;;2592   
;;;2593       /* Injected context queue overflow callback */
;;;2594   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2595       hadc->InjectedQueueOverflowCallback(hadc);
;;;2596   #else
;;;2597       HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
00026e  4620              MOV      r0,r4
000270  e8bd5ff0          POP      {r4-r12,lr}
000274  f7ffbffe          B.W      HAL_ADCEx_InjectedQueueOverflowCallback
                  |L16.632|
;;;2598   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2599     }
;;;2600   
;;;2601   }
000278  e8bd9ff0          POP      {r4-r12,pc}
;;;2602   
                          ENDP

                  |L16.636|
                          DCD      0x50040300
                  |L16.640|
                          DCD      0x50040100
                  |L16.644|
                          DCD      0x50040000

                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Init PROC
;;;400      */
;;;401    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;402    {
000002  4604              MOV      r4,r0
;;;403      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;404      uint32_t tmpCFGR;
;;;405      uint32_t tmp_adc_reg_is_conversion_on_going;
;;;406      __IO uint32_t wait_loop_index = 0UL;
000006  2600              MOVS     r6,#0
000008  9600              STR      r6,[sp,#0]
;;;407      uint32_t tmp_adc_is_conversion_on_going_regular;
;;;408      uint32_t tmp_adc_is_conversion_on_going_injected;
;;;409    
;;;410      /* Check ADC handle */
;;;411      if (hadc == NULL)
00000a  2c00              CMP      r4,#0
00000c  d002              BEQ      |L17.20|
;;;412      {
;;;413        return HAL_ERROR;
;;;414      }
;;;415    
;;;416      /* Check the parameters */
;;;417      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;418      assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
;;;419      assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
;;;420    #if defined(ADC_CFGR_DFSDMCFG) &&defined(DFSDM1_Channel0)
;;;421      assert_param(IS_ADC_DFSDMCFG_MODE(hadc));
;;;422    #endif
;;;423      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;424      assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
;;;425      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;426      assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;427      assert_param(IS_ADC_EXTTRIG(hadc, hadc->Init.ExternalTrigConv));
;;;428      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;429      assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
;;;430      assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
;;;431      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
;;;432      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
;;;433    
;;;434      if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
;;;435      {
;;;436        assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
;;;437        assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;438    
;;;439        if (hadc->Init.DiscontinuousConvMode == ENABLE)
;;;440        {
;;;441          assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;442        }
;;;443      }
;;;444    
;;;445      /* DISCEN and CONT bits cannot be set at the same time */
;;;446      assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
;;;447    
;;;448      /* Actions performed only if ADC is coming from state reset:                */
;;;449      /* - Initialization of ADC MSP                                              */
;;;450      if (hadc->State == HAL_ADC_STATE_RESET)
00000e  6da0              LDR      r0,[r4,#0x58]
000010  b110              CBZ      r0,|L17.24|
000012  e007              B        |L17.36|
                  |L17.20|
000014  2001              MOVS     r0,#1                 ;413
;;;451      {
;;;452    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;453        /* Init the ADC Callback settings */
;;;454        hadc->ConvCpltCallback              = HAL_ADC_ConvCpltCallback;                 /* Legacy weak callback */
;;;455        hadc->ConvHalfCpltCallback          = HAL_ADC_ConvHalfCpltCallback;             /* Legacy weak callback */
;;;456        hadc->LevelOutOfWindowCallback      = HAL_ADC_LevelOutOfWindowCallback;         /* Legacy weak callback */
;;;457        hadc->ErrorCallback                 = HAL_ADC_ErrorCallback;                    /* Legacy weak callback */
;;;458        hadc->InjectedConvCpltCallback      = HAL_ADCEx_InjectedConvCpltCallback;       /* Legacy weak callback */
;;;459        hadc->InjectedQueueOverflowCallback = HAL_ADCEx_InjectedQueueOverflowCallback;  /* Legacy weak callback */
;;;460        hadc->LevelOutOfWindow2Callback     = HAL_ADCEx_LevelOutOfWindow2Callback;      /* Legacy weak callback */
;;;461        hadc->LevelOutOfWindow3Callback     = HAL_ADCEx_LevelOutOfWindow3Callback;      /* Legacy weak callback */
;;;462        hadc->EndOfSamplingCallback         = HAL_ADCEx_EndOfSamplingCallback;          /* Legacy weak callback */
;;;463    
;;;464        if (hadc->MspInitCallback == NULL)
;;;465        {
;;;466          hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit  */
;;;467        }
;;;468    
;;;469        /* Init the low level hardware */
;;;470        hadc->MspInitCallback(hadc);
;;;471    #else
;;;472        /* Init the low level hardware */
;;;473        HAL_ADC_MspInit(hadc);
;;;474    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;475    
;;;476        /* Set ADC error code to none */
;;;477        ADC_CLEAR_ERRORCODE(hadc);
;;;478    
;;;479        /* Initialize Lock */
;;;480        hadc->Lock = HAL_UNLOCKED;
;;;481      }
;;;482    
;;;483      /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
;;;484      if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
;;;485      {
;;;486        /* Disable ADC deep power down mode */
;;;487        LL_ADC_DisableDeepPowerDown(hadc->Instance);
;;;488    
;;;489        /* System was in deep power down mode, calibration must
;;;490         be relaunched or a previously saved calibration factor
;;;491         re-applied once the ADC voltage regulator is enabled */
;;;492      }
;;;493    
;;;494      if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
;;;495      {
;;;496        /* Enable ADC internal voltage regulator */
;;;497        LL_ADC_EnableInternalRegulator(hadc->Instance);
;;;498    
;;;499        /* Note: Variable divided by 2 to compensate partially              */
;;;500        /*       CPU processing cycles, scaling in us split to not          */
;;;501        /*       exceed 32 bits register capacity and handle low frequency. */
;;;502        wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
;;;503        while (wait_loop_index != 0UL)
;;;504        {
;;;505          wait_loop_index--;
;;;506        }
;;;507      }
;;;508    
;;;509      /* Verification that ADC voltage regulator is correctly enabled, whether    */
;;;510      /* or not ADC is coming from state reset (if any potential problem of       */
;;;511      /* clocking, voltage regulator would not be enabled).                       */
;;;512      if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
;;;513      {
;;;514        /* Update ADC state machine to error */
;;;515        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;516    
;;;517        /* Set ADC error code to ADC peripheral internal error */
;;;518        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;519    
;;;520        tmp_hal_status = HAL_ERROR;
;;;521      }
;;;522    
;;;523      /* Configuration of ADC parameters if previous preliminary actions are      */
;;;524      /* correctly completed and if there is no conversion on going on regular    */
;;;525      /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
;;;526      /* called to update a parameter on the fly).                                */
;;;527      tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
;;;528    
;;;529      if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
;;;530          && (tmp_adc_reg_is_conversion_on_going == 0UL)
;;;531         )
;;;532      {
;;;533        /* Set ADC state */
;;;534        ADC_STATE_CLR_SET(hadc->State,
;;;535                          HAL_ADC_STATE_REG_BUSY,
;;;536                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;537    
;;;538        /* Configuration of common ADC parameters                                 */
;;;539    
;;;540        /* Parameters update conditioned to ADC state:                            */
;;;541        /* Parameters that can be updated only when ADC is disabled:              */
;;;542        /*  - clock configuration                                                 */
;;;543        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
;;;544        {
;;;545          if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
;;;546          {
;;;547            /* Reset configuration of ADC common register CCR:                      */
;;;548            /*                                                                      */
;;;549            /*   - ADC clock mode and ACC prescaler (CKMODE and PRESC bits)are set  */
;;;550            /*     according to adc->Init.ClockPrescaler. It selects the clock      */
;;;551            /*    source and sets the clock division factor.                        */
;;;552            /*                                                                      */
;;;553            /* Some parameters of this register are not reset, since they are set   */
;;;554            /* by other functions and must be kept in case of usage of this         */
;;;555            /* function on the fly (update of a parameter of ADC_InitTypeDef        */
;;;556            /* without needing to reconfigure all other ADC groups/channels         */
;;;557            /* parameters):                                                         */
;;;558            /*   - when multimode feature is available, multimode-related           */
;;;559            /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
;;;560            /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
;;;561            /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
;;;562            /*     (set into HAL_ADC_ConfigChannel() or                             */
;;;563            /*     HAL_ADCEx_InjectedConfigChannel() )                              */
;;;564            LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
;;;565          }
;;;566        }
;;;567    
;;;568        /* Configuration of ADC:                                                  */
;;;569        /*  - resolution                               Init.Resolution            */
;;;570        /*  - data alignment                           Init.DataAlign             */
;;;571        /*  - external trigger to start conversion     Init.ExternalTrigConv      */
;;;572        /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
;;;573        /*  - continuous conversion mode               Init.ContinuousConvMode    */
;;;574        /*  - overrun                                  Init.Overrun               */
;;;575        /*  - discontinuous mode                       Init.DiscontinuousConvMode */
;;;576        /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
;;;577        tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
;;;578                    hadc->Init.Overrun                                                     |
;;;579                    hadc->Init.DataAlign                                                   |
;;;580                    hadc->Init.Resolution                                                  |
;;;581                    ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
;;;582    
;;;583        if (hadc->Init.DiscontinuousConvMode == ENABLE)
;;;584        {
;;;585          tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
;;;586        }
;;;587    
;;;588        /* Enable external trigger if trigger selection is different of software  */
;;;589        /* start.                                                                 */
;;;590        /* Note: This configuration keeps the hardware feature of parameter       */
;;;591        /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
;;;592        /*       software start.                                                  */
;;;593        if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
;;;594        {
;;;595          tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
;;;596                      | hadc->Init.ExternalTrigConvEdge
;;;597                     );
;;;598        }
;;;599    
;;;600        /* Update Configuration Register CFGR */
;;;601        MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
;;;602    
;;;603        /* Parameters update conditioned to ADC state:                            */
;;;604        /* Parameters that can be updated when ADC is disabled or enabled without */
;;;605        /* conversion on going on regular and injected groups:                    */
;;;606        /*  - DMA continuous request          Init.DMAContinuousRequests          */
;;;607        /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
;;;608        /*  - Oversampling parameters         Init.Oversampling                   */
;;;609        tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
;;;610        tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
;;;611        if ((tmp_adc_is_conversion_on_going_regular == 0UL)
;;;612            && (tmp_adc_is_conversion_on_going_injected == 0UL)
;;;613           )
;;;614        {
;;;615          tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
;;;616                     ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
;;;617                     ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
;;;618    
;;;619          MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
;;;620    
;;;621          if (hadc->Init.OversamplingMode == ENABLE)
;;;622          {
;;;623            assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
;;;624            assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
;;;625            assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
;;;626            assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
;;;627    
;;;628            /* Configuration of Oversampler:                                      */
;;;629            /*  - Oversampling Ratio                                              */
;;;630            /*  - Right bit shift                                                 */
;;;631            /*  - Triggered mode                                                  */
;;;632            /*  - Oversampling mode (continued/resumed)                           */
;;;633            MODIFY_REG(hadc->Instance->CFGR2,
;;;634                       ADC_CFGR2_OVSR  |
;;;635                       ADC_CFGR2_OVSS  |
;;;636                       ADC_CFGR2_TROVS |
;;;637                       ADC_CFGR2_ROVSM,
;;;638                       ADC_CFGR2_ROVSE                       |
;;;639                       hadc->Init.Oversampling.Ratio         |
;;;640                       hadc->Init.Oversampling.RightBitShift |
;;;641                       hadc->Init.Oversampling.TriggeredMode |
;;;642                       hadc->Init.Oversampling.OversamplingStopReset
;;;643                      );
;;;644          }
;;;645          else
;;;646          {
;;;647            /* Disable ADC oversampling scope on ADC group regular */
;;;648            CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
;;;649          }
;;;650    
;;;651        }
;;;652    
;;;653        /* Configuration of regular group sequencer:                              */
;;;654        /* - if scan mode is disabled, regular channels sequence length is set to */
;;;655        /*   0x00: 1 channel converted (channel on regular rank 1)                */
;;;656        /*   Parameter "NbrOfConversion" is discarded.                            */
;;;657        /*   Note: Scan mode is not present by hardware on this device, but       */
;;;658        /*   emulated by software for alignment over all STM32 devices.           */
;;;659        /* - if scan mode is enabled, regular channels sequence length is set to  */
;;;660        /*   parameter "NbrOfConversion".                                         */
;;;661    
;;;662        if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
;;;663        {
;;;664          /* Set number of ranks in regular group sequencer */
;;;665          MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
;;;666        }
;;;667        else
;;;668        {
;;;669          CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
;;;670        }
;;;671    
;;;672        /* Initialize the ADC state */
;;;673        /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
;;;674        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
;;;675      }
;;;676      else
;;;677      {
;;;678        /* Update ADC state machine to error */
;;;679        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;680    
;;;681        tmp_hal_status = HAL_ERROR;
;;;682      }
;;;683    
;;;684      /* Return function status */
;;;685      return tmp_hal_status;
;;;686    }
000016  bdf8              POP      {r3-r7,pc}
                  |L17.24|
000018  4620              MOV      r0,r4                 ;473
00001a  f7fffffe          BL       HAL_ADC_MspInit
00001e  65e6              STR      r6,[r4,#0x5c]         ;477
000020  f8846054          STRB     r6,[r4,#0x54]         ;480
                  |L17.36|
000024  6820              LDR      r0,[r4,#0]            ;484
000026  6881              LDR      r1,[r0,#8]            ;484
000028  f3c17140          UBFX     r1,r1,#29,#1          ;484
00002c  b119              CBZ      r1,|L17.54|
00002e  6881              LDR      r1,[r0,#8]            ;484
000030  4a60              LDR      r2,|L17.436|
000032  4011              ANDS     r1,r1,r2              ;484
000034  6081              STR      r1,[r0,#8]            ;484
                  |L17.54|
000036  6820              LDR      r0,[r4,#0]            ;494
000038  6881              LDR      r1,[r0,#8]            ;494
00003a  f3c17100          UBFX     r1,r1,#28,#1          ;494
00003e  b9a1              CBNZ     r1,|L17.106|
000040  6881              LDR      r1,[r0,#8]            ;494
000042  4a5d              LDR      r2,|L17.440|
000044  4011              ANDS     r1,r1,r2              ;494
000046  f0415180          ORR      r1,r1,#0x10000000     ;494
00004a  6081              STR      r1,[r0,#8]            ;494
00004c  485b              LDR      r0,|L17.444|
00004e  495c              LDR      r1,|L17.448|
000050  6800              LDR      r0,[r0,#0]            ;502  ; SystemCoreClock
000052  fbb0f0f1          UDIV     r0,r0,r1              ;502
000056  1c40              ADDS     r0,r0,#1              ;502
000058  0040              LSLS     r0,r0,#1              ;502
00005a  9000              STR      r0,[sp,#0]            ;502
00005c  e002              B        |L17.100|
                  |L17.94|
00005e  9800              LDR      r0,[sp,#0]            ;505
000060  1e40              SUBS     r0,r0,#1              ;505
000062  9000              STR      r0,[sp,#0]            ;505
                  |L17.100|
000064  9800              LDR      r0,[sp,#0]            ;503
000066  2800              CMP      r0,#0                 ;503
000068  d1f9              BNE      |L17.94|
                  |L17.106|
00006a  6820              LDR      r0,[r4,#0]            ;512
00006c  6881              LDR      r1,[r0,#8]            ;512
00006e  f3c17100          UBFX     r1,r1,#28,#1          ;512
000072  b941              CBNZ     r1,|L17.134|
000074  6da1              LDR      r1,[r4,#0x58]         ;515
000076  f0410110          ORR      r1,r1,#0x10           ;515
00007a  65a1              STR      r1,[r4,#0x58]         ;515
00007c  6de1              LDR      r1,[r4,#0x5c]         ;518
00007e  f0410101          ORR      r1,r1,#1              ;518
000082  65e1              STR      r1,[r4,#0x5c]         ;518
000084  2501              MOVS     r5,#1                 ;520
                  |L17.134|
000086  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00008a  6da1              LDR      r1,[r4,#0x58]         ;529
00008c  06c9              LSLS     r1,r1,#27             ;529
00008e  d400              BMI      |L17.146|
000090  b130              CBZ      r0,|L17.160|
                  |L17.146|
000092  6da0              LDR      r0,[r4,#0x58]         ;679
000094  f0400010          ORR      r0,r0,#0x10           ;679
000098  65a0              STR      r0,[r4,#0x58]         ;679
00009a  2501              MOVS     r5,#1                 ;681
                  |L17.156|
00009c  4628              MOV      r0,r5                 ;685
00009e  bdf8              POP      {r3-r7,pc}
                  |L17.160|
0000a0  6da0              LDR      r0,[r4,#0x58]         ;534
0000a2  f4207080          BIC      r0,r0,#0x100          ;534
0000a6  f0400002          ORR      r0,r0,#2              ;534
0000aa  65a0              STR      r0,[r4,#0x58]         ;534
0000ac  6820              LDR      r0,[r4,#0]            ;543
0000ae  f7fffffe          BL       LL_ADC_IsEnabled
0000b2  b9a8              CBNZ     r0,|L17.224|
0000b4  4843              LDR      r0,|L17.452|
0000b6  6880              LDR      r0,[r0,#8]            ;543
0000b8  f3c00000          UBFX     r0,r0,#0,#1           ;543
0000bc  4942              LDR      r1,|L17.456|
0000be  6889              LDR      r1,[r1,#8]            ;543
0000c0  f3c10100          UBFX     r1,r1,#0,#1           ;543
0000c4  4308              ORRS     r0,r0,r1              ;545
0000c6  4941              LDR      r1,|L17.460|
0000c8  6889              LDR      r1,[r1,#8]            ;545
0000ca  f3c10100          UBFX     r1,r1,#0,#1           ;545
0000ce  4308              ORRS     r0,r0,r1              ;545
0000d0  d106              BNE      |L17.224|
0000d2  6860              LDR      r0,[r4,#4]            ;564
0000d4  493e              LDR      r1,|L17.464|
0000d6  688a              LDR      r2,[r1,#8]            ;564
0000d8  f422127c          BIC      r2,r2,#0x3f0000       ;564
0000dc  4302              ORRS     r2,r2,r0              ;564
0000de  608a              STR      r2,[r1,#8]            ;564
                  |L17.224|
0000e0  68e1              LDR      r1,[r4,#0xc]          ;577
0000e2  6b60              LDR      r0,[r4,#0x34]         ;577
0000e4  7e62              LDRB     r2,[r4,#0x19]         ;577
0000e6  4308              ORRS     r0,r0,r1              ;577
0000e8  68a1              LDR      r1,[r4,#8]            ;577
0000ea  ea413142          ORR      r1,r1,r2,LSL #13      ;577
0000ee  4308              ORRS     r0,r0,r1              ;577
0000f0  f8941020          LDRB     r1,[r4,#0x20]         ;577
0000f4  ea404001          ORR      r0,r0,r1,LSL #16      ;577
0000f8  2901              CMP      r1,#1                 ;583
0000fa  d103              BNE      |L17.260|
0000fc  8ca1              LDRH     r1,[r4,#0x24]         ;585
0000fe  1e49              SUBS     r1,r1,#1              ;585
000100  ea404041          ORR      r0,r0,r1,LSL #17      ;585
                  |L17.260|
000104  6aa1              LDR      r1,[r4,#0x28]         ;593
000106  b129              CBZ      r1,|L17.276|
000108  f4017170          AND      r1,r1,#0x3c0          ;595
00010c  6ae2              LDR      r2,[r4,#0x2c]         ;595
00010e  4301              ORRS     r1,r1,r0              ;595
000110  ea420001          ORR      r0,r2,r1              ;595
                  |L17.276|
000114  6821              LDR      r1,[r4,#0]            ;601
000116  68ca              LDR      r2,[r1,#0xc]          ;601
000118  4b2e              LDR      r3,|L17.468|
00011a  401a              ANDS     r2,r2,r3              ;601
00011c  4302              ORRS     r2,r2,r0              ;601
00011e  60ca              STR      r2,[r1,#0xc]          ;601
000120  6820              LDR      r0,[r4,#0]            ;609
000122  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000126  4606              MOV      r6,r0                 ;609
000128  6820              LDR      r0,[r4,#0]            ;610
00012a  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
00012e  4306              ORRS     r6,r6,r0              ;611
000130  d117              BNE      |L17.354|
000132  7e20              LDRB     r0,[r4,#0x18]         ;615
000134  f8941030          LDRB     r1,[r4,#0x30]         ;615
000138  0380              LSLS     r0,r0,#14             ;615
00013a  ea400141          ORR      r1,r0,r1,LSL #1       ;615
00013e  6ce0              LDR      r0,[r4,#0x4c]         ;615
000140  4301              ORRS     r1,r1,r0              ;615
000142  6820              LDR      r0,[r4,#0]            ;619
000144  68c2              LDR      r2,[r0,#0xc]          ;619
000146  f2440306          MOV      r3,#0x4006            ;619
00014a  439a              BICS     r2,r2,r3              ;619
00014c  430a              ORRS     r2,r2,r1              ;619
00014e  60c2              STR      r2,[r0,#0xc]          ;619
000150  f8940038          LDRB     r0,[r4,#0x38]         ;621
000154  2801              CMP      r0,#1                 ;621
000156  d013              BEQ      |L17.384|
000158  6820              LDR      r0,[r4,#0]            ;648
00015a  6901              LDR      r1,[r0,#0x10]         ;648
00015c  f0210101          BIC      r1,r1,#1              ;648
000160  6101              STR      r1,[r0,#0x10]         ;648
                  |L17.354|
000162  6920              LDR      r0,[r4,#0x10]         ;662
000164  2801              CMP      r0,#1                 ;662
000166  d01c              BEQ      |L17.418|
000168  6820              LDR      r0,[r4,#0]            ;669
00016a  6b01              LDR      r1,[r0,#0x30]         ;669
00016c  f021010f          BIC      r1,r1,#0xf            ;669
000170  6301              STR      r1,[r0,#0x30]         ;669
                  |L17.370|
000172  6da0              LDR      r0,[r4,#0x58]         ;674
000174  f0200002          BIC      r0,r0,#2              ;674
000178  f0400001          ORR      r0,r0,#1              ;674
00017c  65a0              STR      r0,[r4,#0x58]         ;674
00017e  e78d              B        |L17.156|
                  |L17.384|
000180  e9d4100f          LDRD     r1,r0,[r4,#0x3c]      ;633
000184  4301              ORRS     r1,r1,r0              ;633
000186  e9d40211          LDRD     r0,r2,[r4,#0x44]      ;633
00018a  4310              ORRS     r0,r0,r2              ;633
00018c  4301              ORRS     r1,r1,r0              ;633
00018e  6820              LDR      r0,[r4,#0]            ;633
000190  6902              LDR      r2,[r0,#0x10]         ;633
000192  f24073fc          MOV      r3,#0x7fc             ;633
000196  439a              BICS     r2,r2,r3              ;633
000198  4311              ORRS     r1,r1,r2              ;633
00019a  f0410101          ORR      r1,r1,#1              ;633
00019e  6101              STR      r1,[r0,#0x10]         ;633
0001a0  e7df              B        |L17.354|
                  |L17.418|
0001a2  6820              LDR      r0,[r4,#0]            ;665
0001a4  6b01              LDR      r1,[r0,#0x30]         ;665
0001a6  69e2              LDR      r2,[r4,#0x1c]         ;665
0001a8  f021010f          BIC      r1,r1,#0xf            ;665
0001ac  1e52              SUBS     r2,r2,#1              ;665
0001ae  4311              ORRS     r1,r1,r2              ;665
0001b0  6301              STR      r1,[r0,#0x30]         ;665
0001b2  e7de              B        |L17.370|
;;;687    
                          ENDP

                  |L17.436|
                          DCD      0x5fffffc0
                  |L17.440|
                          DCD      0x7fffffc0
                  |L17.444|
                          DCD      SystemCoreClock
                  |L17.448|
                          DCD      0x00030d40
                  |L17.452|
                          DCD      0x50040000
                  |L17.456|
                          DCD      0x50040100
                  |L17.460|
                          DCD      0x50040200
                  |L17.464|
                          DCD      0x50040300
                  |L17.468|
                          DCD      0xfff0c007

                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;2637     */
;;;2638   __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;2639   {
;;;2640     /* Prevent unused argument(s) compilation warning */
;;;2641     UNUSED(hadc);
;;;2642   
;;;2643     /* NOTE : This function should not be modified. When the callback is needed,
;;;2644               function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
;;;2645     */
;;;2646   }
;;;2647   
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;921      */
;;;922    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;923    {
;;;924      /* Prevent unused argument(s) compilation warning */
;;;925      UNUSED(hadc);
;;;926    
;;;927      /* NOTE : This function should not be modified. When the callback is needed,
;;;928                function HAL_ADC_MspDeInit must be implemented in the user file.
;;;929       */
;;;930    }
;;;931    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;904      */
;;;905    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;906    {
;;;907      /* Prevent unused argument(s) compilation warning */
;;;908      UNUSED(hadc);
;;;909    
;;;910      /* NOTE : This function should not be modified. When the callback is needed,
;;;911                function HAL_ADC_MspInit must be implemented in the user file.
;;;912       */
;;;913    }
;;;914    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=2

                  HAL_ADC_PollForConversion PROC
;;;1400     */
;;;1401   HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1402   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  483e              LDR      r0,|L21.260|
00000a  6881              LDR      r1,[r0,#8]
00000c  f001061f          AND      r6,r1,#0x1f
;;;1403     uint32_t tickstart;
;;;1404     uint32_t tmp_Flag_End;
;;;1405     uint32_t tmp_cfgr;
;;;1406   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1407     const ADC_TypeDef *tmpADC_Master;
;;;1408     uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;1409   #endif
;;;1410   
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1413   
;;;1414     /* If end of conversion selected to end of sequence conversions */
;;;1415     if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
000010  6961              LDR      r1,[r4,#0x14]
000012  2908              CMP      r1,#8
000014  d00f              BEQ      |L21.54|
;;;1416     {
;;;1417       tmp_Flag_End = ADC_FLAG_EOS;
;;;1418     }
;;;1419     /* If end of conversion selected to end of unitary conversion */
;;;1420     else /* ADC_EOC_SINGLE_CONV */
;;;1421     {
;;;1422       /* Verification that ADC configuration is compliant with polling for      */
;;;1423       /* each conversion:                                                       */
;;;1424       /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
;;;1425       /* several ranks and polling for end of each conversion.                  */
;;;1426       /* For code simplicity sake, this particular case is generalized to       */
;;;1427       /* ADC configured in DMA mode and and polling for end of each conversion. */
;;;1428   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1429       if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
000016  b186              CBZ      r6,|L21.58|
;;;1430           || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
000018  2e05              CMP      r6,#5
00001a  d00e              BEQ      |L21.58|
;;;1431           || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
00001c  2e09              CMP      r6,#9
00001e  d00c              BEQ      |L21.58|
000020  6880              LDR      r0,[r0,#8]
000022  f4004060          AND      r0,r0,#0xe000
;;;1432          )
;;;1433       {
;;;1434         /* Check ADC DMA mode in independent mode on ADC group regular */
;;;1435         if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN) != 0UL)
;;;1436         {
;;;1437           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1438           return HAL_ERROR;
;;;1439         }
;;;1440         else
;;;1441         {
;;;1442           tmp_Flag_End = (ADC_FLAG_EOC);
;;;1443         }
;;;1444       }
;;;1445       else
;;;1446       {
;;;1447         /* Check ADC DMA mode in multimode on ADC group regular */
;;;1448         if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
000026  b1a0              CBZ      r0,|L21.82|
;;;1449         {
;;;1450           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
000028  6da0              LDR      r0,[r4,#0x58]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  65a0              STR      r0,[r4,#0x58]
;;;1451           return HAL_ERROR;
000030  2001              MOVS     r0,#1
                  |L21.50|
;;;1452         }
;;;1453         else
;;;1454         {
;;;1455           tmp_Flag_End = (ADC_FLAG_EOC);
;;;1456         }
;;;1457       }
;;;1458   #else
;;;1459       /* Check ADC DMA mode */
;;;1460       if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN) != 0UL)
;;;1461       {
;;;1462         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1463         return HAL_ERROR;
;;;1464       }
;;;1465       else
;;;1466       {
;;;1467         tmp_Flag_End = (ADC_FLAG_EOC);
;;;1468       }
;;;1469   #endif
;;;1470     }
;;;1471   
;;;1472     /* Get tick count */
;;;1473     tickstart = HAL_GetTick();
;;;1474   
;;;1475     /* Wait until End of unitary conversion or sequence conversions flag is raised */
;;;1476     while ((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
;;;1477     {
;;;1478       /* Check if timeout is disabled (set to infinite wait) */
;;;1479       if (Timeout != HAL_MAX_DELAY)
;;;1480       {
;;;1481         if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
;;;1482         {
;;;1483           /* New check to avoid false timeout detection in case of preemption */
;;;1484           if ((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
;;;1485           {
;;;1486             /* Update ADC state machine to timeout */
;;;1487             SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;1488   
;;;1489             /* Process unlocked */
;;;1490             __HAL_UNLOCK(hadc);
;;;1491   
;;;1492             return HAL_TIMEOUT;
;;;1493           }
;;;1494         }
;;;1495       }
;;;1496     }
;;;1497   
;;;1498     /* Update ADC state machine */
;;;1499     SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;1500   
;;;1501     /* Determine whether any further conversion upcoming on group regular       */
;;;1502     /* by external trigger, continuous mode or scan sequence on going.          */
;;;1503     if ((LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
;;;1504         && (hadc->Init.ContinuousConvMode == DISABLE)
;;;1505        )
;;;1506     {
;;;1507       /* Check whether end of sequence is reached */
;;;1508       if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
;;;1509       {
;;;1510         /* Set ADC state */
;;;1511         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;1512   
;;;1513         if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
;;;1514         {
;;;1515           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;1516         }
;;;1517       }
;;;1518     }
;;;1519   
;;;1520     /* Get relevant register CFGR in ADC instance of ADC master or slave        */
;;;1521     /* in function of multimode state (for devices with multimode               */
;;;1522     /* available).                                                              */
;;;1523   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1524     if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;1525         || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;1526         || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
;;;1527         || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
;;;1528        )
;;;1529     {
;;;1530       /* Retrieve handle ADC CFGR register */
;;;1531       tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;1532     }
;;;1533     else
;;;1534     {
;;;1535       /* Retrieve Master ADC CFGR register */
;;;1536       tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
;;;1537       tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
;;;1538     }
;;;1539   #else
;;;1540     /* Retrieve handle ADC CFGR register */
;;;1541     tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;1542   #endif
;;;1543   
;;;1544     /* Clear polled flag */
;;;1545     if (tmp_Flag_End == ADC_FLAG_EOS)
;;;1546     {
;;;1547       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOS);
;;;1548     }
;;;1549     else
;;;1550     {
;;;1551       /* Clear end of conversion EOC flag of regular group if low power feature */
;;;1552       /* "LowPowerAutoWait " is disabled, to not interfere with this feature    */
;;;1553       /* until data register is read using function HAL_ADC_GetValue().         */
;;;1554       if (READ_BIT(tmp_cfgr, ADC_CFGR_AUTDLY) == 0UL)
;;;1555       {
;;;1556         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
;;;1557       }
;;;1558     }
;;;1559   
;;;1560     /* Return function status */
;;;1561     return HAL_OK;
;;;1562   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L21.54|
000036  2508              MOVS     r5,#8                 ;1417
000038  e00c              B        |L21.84|
                  |L21.58|
00003a  6820              LDR      r0,[r4,#0]            ;1435
00003c  68c0              LDR      r0,[r0,#0xc]          ;1435
00003e  07c0              LSLS     r0,r0,#31             ;1435
000040  d005              BEQ      |L21.78|
000042  6da0              LDR      r0,[r4,#0x58]         ;1437
000044  f0400020          ORR      r0,r0,#0x20           ;1437
000048  65a0              STR      r0,[r4,#0x58]         ;1437
00004a  2001              MOVS     r0,#1                 ;1438
00004c  e7f1              B        |L21.50|
                  |L21.78|
00004e  2504              MOVS     r5,#4                 ;1442
000050  e000              B        |L21.84|
                  |L21.82|
000052  2504              MOVS     r5,#4                 ;1455
                  |L21.84|
000054  f7fffffe          BL       HAL_GetTick
000058  4680              MOV      r8,r0                 ;1473
00005a  e015              B        |L21.136|
                  |L21.92|
00005c  1c78              ADDS     r0,r7,#1              ;1479
00005e  d013              BEQ      |L21.136|
000060  f7fffffe          BL       HAL_GetTick
000064  eba00008          SUB      r0,r0,r8              ;1481
000068  42b8              CMP      r0,r7                 ;1481
00006a  d800              BHI      |L21.110|
00006c  b967              CBNZ     r7,|L21.136|
                  |L21.110|
00006e  6820              LDR      r0,[r4,#0]            ;1484
000070  6800              LDR      r0,[r0,#0]            ;1484
000072  4228              TST      r0,r5                 ;1484
000074  d108              BNE      |L21.136|
000076  6da0              LDR      r0,[r4,#0x58]         ;1487
000078  f0400004          ORR      r0,r0,#4              ;1487
00007c  65a0              STR      r0,[r4,#0x58]         ;1487
00007e  2000              MOVS     r0,#0                 ;1490
000080  f8840054          STRB     r0,[r4,#0x54]         ;1490
000084  2003              MOVS     r0,#3                 ;1492
000086  e7d4              B        |L21.50|
                  |L21.136|
000088  6820              LDR      r0,[r4,#0]            ;1476
00008a  6800              LDR      r0,[r0,#0]            ;1476
00008c  4228              TST      r0,r5                 ;1476
00008e  d0e5              BEQ      |L21.92|
000090  6da0              LDR      r0,[r4,#0x58]         ;1499
000092  f4407000          ORR      r0,r0,#0x200          ;1499
000096  65a0              STR      r0,[r4,#0x58]         ;1499
000098  6820              LDR      r0,[r4,#0]            ;1503
00009a  f7fffffe          BL       LL_ADC_REG_IsTriggerSourceSWStart
00009e  b180              CBZ      r0,|L21.194|
0000a0  7e60              LDRB     r0,[r4,#0x19]         ;1504
0000a2  b970              CBNZ     r0,|L21.194|
0000a4  6820              LDR      r0,[r4,#0]            ;1508
0000a6  6800              LDR      r0,[r0,#0]            ;1508
0000a8  0700              LSLS     r0,r0,#28             ;1508
0000aa  d50a              BPL      |L21.194|
0000ac  6da0              LDR      r0,[r4,#0x58]         ;1511
0000ae  f4207080          BIC      r0,r0,#0x100          ;1511
0000b2  65a0              STR      r0,[r4,#0x58]         ;1511
0000b4  6da0              LDR      r0,[r4,#0x58]         ;1513
0000b6  04c0              LSLS     r0,r0,#19             ;1513
0000b8  d403              BMI      |L21.194|
0000ba  6da0              LDR      r0,[r4,#0x58]         ;1515
0000bc  f0400001          ORR      r0,r0,#1              ;1515
0000c0  65a0              STR      r0,[r4,#0x58]         ;1515
                  |L21.194|
0000c2  4b11              LDR      r3,|L21.264|
0000c4  6820              LDR      r0,[r4,#0]            ;1524
0000c6  4911              LDR      r1,|L21.268|
0000c8  4298              CMP      r0,r3                 ;1524
0000ca  d101              BNE      |L21.208|
0000cc  460a              MOV      r2,r1                 ;1524
0000ce  e000              B        |L21.210|
                  |L21.208|
0000d0  4602              MOV      r2,r0                 ;1524
                  |L21.210|
0000d2  4282              CMP      r2,r0                 ;1524
0000d4  d010              BEQ      |L21.248|
0000d6  b17e              CBZ      r6,|L21.248|
0000d8  2e05              CMP      r6,#5                 ;1526
0000da  d00d              BEQ      |L21.248|
0000dc  2e09              CMP      r6,#9                 ;1527
0000de  d00b              BEQ      |L21.248|
0000e0  4298              CMP      r0,r3                 ;1536
0000e2  d000              BEQ      |L21.230|
0000e4  4601              MOV      r1,r0                 ;1536
                  |L21.230|
0000e6  68c9              LDR      r1,[r1,#0xc]          ;1537
                  |L21.232|
0000e8  2d08              CMP      r5,#8                 ;1545
0000ea  d007              BEQ      |L21.252|
0000ec  0449              LSLS     r1,r1,#17             ;1554
0000ee  d401              BMI      |L21.244|
0000f0  210c              MOVS     r1,#0xc               ;1556
0000f2  6001              STR      r1,[r0,#0]            ;1556
                  |L21.244|
0000f4  2000              MOVS     r0,#0                 ;1561
0000f6  e79c              B        |L21.50|
                  |L21.248|
0000f8  68c1              LDR      r1,[r0,#0xc]          ;1531
0000fa  e7f5              B        |L21.232|
                  |L21.252|
0000fc  2108              MOVS     r1,#8                 ;1547
0000fe  6001              STR      r1,[r0,#0]            ;1547
000100  e7f8              B        |L21.244|
;;;1563   
                          ENDP

000102  0000              DCW      0x0000
                  |L21.260|
                          DCD      0x50040300
                  |L21.264|
                          DCD      0x50040100
                  |L21.268|
                          DCD      0x50040000

                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;1583     */
;;;1584   HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef *hadc, uint32_t EventType, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1585   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1586     uint32_t tickstart;
;;;1587   
;;;1588     /* Check the parameters */
;;;1589     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1590     assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;1591   
;;;1592     /* Get tick count */
;;;1593     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4607              MOV      r7,r0
;;;1594   
;;;1595     /* Check selected event flag */
;;;1596     while (__HAL_ADC_GET_FLAG(hadc, EventType) == 0UL)
000010  e016              B        |L22.64|
                  |L22.18|
;;;1597     {
;;;1598       /* Check if timeout is disabled (set to infinite wait) */
;;;1599       if (Timeout != HAL_MAX_DELAY)
000012  1c68              ADDS     r0,r5,#1
000014  d014              BEQ      |L22.64|
;;;1600       {
;;;1601         if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
000016  f7fffffe          BL       HAL_GetTick
00001a  1bc0              SUBS     r0,r0,r7
00001c  42a8              CMP      r0,r5
00001e  d800              BHI      |L22.34|
000020  b975              CBNZ     r5,|L22.64|
                  |L22.34|
;;;1602         {
;;;1603           /* New check to avoid false timeout detection in case of preemption */
;;;1604           if (__HAL_ADC_GET_FLAG(hadc, EventType) == 0UL)
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  ea360000          BICS     r0,r6,r0
00002a  d009              BEQ      |L22.64|
;;;1605           {
;;;1606             /* Update ADC state machine to timeout */
;;;1607             SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
00002c  6da0              LDR      r0,[r4,#0x58]
00002e  f0400004          ORR      r0,r0,#4
000032  65a0              STR      r0,[r4,#0x58]
;;;1608   
;;;1609             /* Process unlocked */
;;;1610             __HAL_UNLOCK(hadc);
000034  2000              MOVS     r0,#0
000036  f8840054          STRB     r0,[r4,#0x54]
;;;1611   
;;;1612             return HAL_TIMEOUT;
00003a  2003              MOVS     r0,#3
                  |L22.60|
;;;1613           }
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   
;;;1618     switch (EventType)
;;;1619     {
;;;1620       /* End Of Sampling event */
;;;1621       case ADC_EOSMP_EVENT:
;;;1622         /* Set ADC state */
;;;1623         SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
;;;1624   
;;;1625         /* Clear the End Of Sampling flag */
;;;1626         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
;;;1627   
;;;1628         break;
;;;1629   
;;;1630       /* Analog watchdog (level out of window) event */
;;;1631       /* Note: In case of several analog watchdog enabled, if needed to know      */
;;;1632       /* which one triggered and on which ADCx, test ADC state of analog watchdog */
;;;1633       /* flags HAL_ADC_STATE_AWD1/2/3 using function "HAL_ADC_GetState()".        */
;;;1634       /* For example:                                                             */
;;;1635       /*  " if ((HAL_ADC_GetState(hadc1) & HAL_ADC_STATE_AWD1) != 0UL) "          */
;;;1636       /*  " if ((HAL_ADC_GetState(hadc1) & HAL_ADC_STATE_AWD2) != 0UL) "          */
;;;1637       /*  " if ((HAL_ADC_GetState(hadc1) & HAL_ADC_STATE_AWD3) != 0UL) "          */
;;;1638   
;;;1639       /* Check analog watchdog 1 flag */
;;;1640       case ADC_AWD_EVENT:
;;;1641         /* Set ADC state */
;;;1642         SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;1643   
;;;1644         /* Clear ADC analog watchdog flag */
;;;1645         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
;;;1646   
;;;1647         break;
;;;1648   
;;;1649       /* Check analog watchdog 2 flag */
;;;1650       case ADC_AWD2_EVENT:
;;;1651         /* Set ADC state */
;;;1652         SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
;;;1653   
;;;1654         /* Clear ADC analog watchdog flag */
;;;1655         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
;;;1656   
;;;1657         break;
;;;1658   
;;;1659       /* Check analog watchdog 3 flag */
;;;1660       case ADC_AWD3_EVENT:
;;;1661         /* Set ADC state */
;;;1662         SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
;;;1663   
;;;1664         /* Clear ADC analog watchdog flag */
;;;1665         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
;;;1666   
;;;1667         break;
;;;1668   
;;;1669       /* Injected context queue overflow event */
;;;1670       case ADC_JQOVF_EVENT:
;;;1671         /* Set ADC state */
;;;1672         SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
;;;1673   
;;;1674         /* Set ADC error code to Injected context queue overflow */
;;;1675         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
;;;1676   
;;;1677         /* Clear ADC Injected context queue overflow flag */
;;;1678         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
;;;1679   
;;;1680         break;
;;;1681   
;;;1682       /* Overrun event */
;;;1683       default: /* Case ADC_OVR_EVENT */
;;;1684         /* If overrun is set to overwrite previous data, overrun event is not     */
;;;1685         /* considered as an error.                                                */
;;;1686         /* (cf ref manual "Managing conversions without using the DMA and without */
;;;1687         /* overrun ")                                                             */
;;;1688         if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
;;;1689         {
;;;1690           /* Set ADC state */
;;;1691           SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
;;;1692   
;;;1693           /* Set ADC error code to overrun */
;;;1694           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
;;;1695         }
;;;1696         else
;;;1697         {
;;;1698           /* Clear ADC Overrun flag only if Overrun is set to ADC_OVR_DATA_OVERWRITTEN
;;;1699              otherwise, data register is potentially overwritten by new converted data as soon
;;;1700              as OVR is cleared. */
;;;1701           __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
;;;1702         }
;;;1703         break;
;;;1704     }
;;;1705   
;;;1706     /* Return function status */
;;;1707     return HAL_OK;
;;;1708   }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L22.64|
000040  6820              LDR      r0,[r4,#0]            ;1596
000042  6800              LDR      r0,[r0,#0]            ;1596
000044  ea360000          BICS     r0,r6,r0              ;1596
000048  d1e3              BNE      |L22.18|
00004a  f44f7080          MOV      r0,#0x100             ;1618
00004e  4286              CMP      r6,r0                 ;1618
000050  d027              BEQ      |L22.162|
000052  dc04              BGT      |L22.94|
000054  2e02              CMP      r6,#2                 ;1618
000056  d014              BEQ      |L22.130|
000058  2e80              CMP      r6,#0x80              ;1618
00005a  d130              BNE      |L22.190|
00005c  e019              B        |L22.146|
                  |L22.94|
00005e  f44f7000          MOV      r0,#0x200             ;1618
000062  4286              CMP      r6,r0                 ;1618
000064  d024              BEQ      |L22.176|
000066  0040              LSLS     r0,r0,#1              ;1618
000068  4286              CMP      r6,r0                 ;1618
00006a  d128              BNE      |L22.190|
00006c  6da1              LDR      r1,[r4,#0x58]         ;1672
00006e  f4414180          ORR      r1,r1,#0x4000         ;1672
000072  65a1              STR      r1,[r4,#0x58]         ;1672
000074  6de1              LDR      r1,[r4,#0x5c]         ;1675
000076  f0410108          ORR      r1,r1,#8              ;1675
00007a  65e1              STR      r1,[r4,#0x5c]         ;1675
00007c  6821              LDR      r1,[r4,#0]            ;1678
00007e  6008              STR      r0,[r1,#0]            ;1678
000080  e022              B        |L22.200|
                  |L22.130|
000082  6da0              LDR      r0,[r4,#0x58]         ;1623
000084  f4406000          ORR      r0,r0,#0x800          ;1623
000088  65a0              STR      r0,[r4,#0x58]         ;1623
00008a  6821              LDR      r1,[r4,#0]            ;1626
00008c  2002              MOVS     r0,#2                 ;1626
00008e  6008              STR      r0,[r1,#0]            ;1626
000090  e01a              B        |L22.200|
                  |L22.146|
000092  6da0              LDR      r0,[r4,#0x58]         ;1642
000094  f4403080          ORR      r0,r0,#0x10000        ;1642
000098  65a0              STR      r0,[r4,#0x58]         ;1642
00009a  6821              LDR      r1,[r4,#0]            ;1645
00009c  2080              MOVS     r0,#0x80              ;1645
00009e  6008              STR      r0,[r1,#0]            ;1645
0000a0  e012              B        |L22.200|
                  |L22.162|
0000a2  6da1              LDR      r1,[r4,#0x58]         ;1652
0000a4  f4413100          ORR      r1,r1,#0x20000        ;1652
0000a8  65a1              STR      r1,[r4,#0x58]         ;1652
0000aa  6821              LDR      r1,[r4,#0]            ;1655
0000ac  6008              STR      r0,[r1,#0]            ;1655
0000ae  e00b              B        |L22.200|
                  |L22.176|
0000b0  6da1              LDR      r1,[r4,#0x58]         ;1662
0000b2  f4412180          ORR      r1,r1,#0x40000        ;1662
0000b6  65a1              STR      r1,[r4,#0x58]         ;1662
0000b8  6821              LDR      r1,[r4,#0]            ;1665
0000ba  6008              STR      r0,[r1,#0]            ;1665
0000bc  e004              B        |L22.200|
                  |L22.190|
0000be  6b60              LDR      r0,[r4,#0x34]         ;1688
0000c0  b120              CBZ      r0,|L22.204|
0000c2  6821              LDR      r1,[r4,#0]            ;1701
0000c4  2010              MOVS     r0,#0x10              ;1701
0000c6  6008              STR      r0,[r1,#0]            ;1701
                  |L22.200|
0000c8  2000              MOVS     r0,#0                 ;1707
0000ca  e7b7              B        |L22.60|
                  |L22.204|
0000cc  6da0              LDR      r0,[r4,#0x58]         ;1691
0000ce  f4406080          ORR      r0,r0,#0x400          ;1691
0000d2  65a0              STR      r0,[r4,#0x58]         ;1691
0000d4  6de0              LDR      r0,[r4,#0x5c]         ;1694
0000d6  f0400002          ORR      r0,r0,#2              ;1694
0000da  65e0              STR      r0,[r4,#0x5c]         ;1694
0000dc  e7f4              B        |L22.200|
;;;1709   
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;1211     */
;;;1212   HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef *hadc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1213   {
000004  4604              MOV      r4,r0
000006  4837              LDR      r0,|L23.228|
000008  6880              LDR      r0,[r0,#8]
00000a  f000051f          AND      r5,r0,#0x1f
;;;1214     HAL_StatusTypeDef tmp_hal_status;
;;;1215   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1216     const ADC_TypeDef *tmpADC_Master;
;;;1217     uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;1218   #endif
;;;1219   
;;;1220     /* Check the parameters */
;;;1221     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1222   
;;;1223     /* Perform ADC enable and conversion start if no conversion is on going */
;;;1224     if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000014  b118              CBZ      r0,|L23.30|
;;;1225     {
;;;1226       /* Process locked */
;;;1227       __HAL_LOCK(hadc);
;;;1228   
;;;1229       /* Enable the ADC peripheral */
;;;1230       tmp_hal_status = ADC_Enable(hadc);
;;;1231   
;;;1232       /* Start conversion if ADC is effectively enabled */
;;;1233       if (tmp_hal_status == HAL_OK)
;;;1234       {
;;;1235         /* Set ADC state                                                        */
;;;1236         /* - Clear state bitfield related to regular group conversion results   */
;;;1237         /* - Set state bitfield related to regular operation                    */
;;;1238         ADC_STATE_CLR_SET(hadc->State,
;;;1239                           HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1240                           HAL_ADC_STATE_REG_BUSY);
;;;1241   
;;;1242   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1243         /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
;;;1244           - if ADC instance is master or if multimode feature is not available
;;;1245           - if multimode setting is disabled (ADC instance slave in independent mode) */
;;;1246         if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;1247             || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;1248            )
;;;1249         {
;;;1250           CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1251         }
;;;1252   #endif
;;;1253   
;;;1254         /* Set ADC error code */
;;;1255         /* Check if a conversion is on going on ADC group injected */
;;;1256         if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1257         {
;;;1258           /* Reset ADC error code fields related to regular conversions only */
;;;1259           CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
;;;1260         }
;;;1261         else
;;;1262         {
;;;1263           /* Reset all ADC error code fields */
;;;1264           ADC_CLEAR_ERRORCODE(hadc);
;;;1265         }
;;;1266   
;;;1267         /* Clear ADC group regular conversion flag and overrun flag               */
;;;1268         /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1269         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
;;;1270   
;;;1271         /* Process unlocked */
;;;1272         /* Unlock before starting ADC conversions: in case of potential         */
;;;1273         /* interruption, to let the process to ADC IRQ Handler.                 */
;;;1274         __HAL_UNLOCK(hadc);
;;;1275   
;;;1276         /* Enable conversion of regular group.                                  */
;;;1277         /* If software start has been selected, conversion starts immediately.  */
;;;1278         /* If external trigger has been selected, conversion will start at next */
;;;1279         /* trigger event.                                                       */
;;;1280         /* Case of multimode enabled (when multimode feature is available):     */
;;;1281         /*  - if ADC is slave and dual regular conversions are enabled, ADC is  */
;;;1282         /*    enabled only (conversion is not started),                         */
;;;1283         /*  - if ADC is master, ADC is enabled and conversion is started.       */
;;;1284   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1285         if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;1286             || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;1287             || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
;;;1288             || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
;;;1289            )
;;;1290         {
;;;1291           /* ADC instance is not a multimode slave instance with multimode regular conversions enabled */
;;;1292           if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != 0UL)
;;;1293           {
;;;1294             ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1295           }
;;;1296   
;;;1297           /* Start ADC group regular conversion */
;;;1298           LL_ADC_REG_StartConversion(hadc->Instance);
;;;1299         }
;;;1300         else
;;;1301         {
;;;1302           /* ADC instance is a multimode slave instance with multimode regular conversions enabled */
;;;1303           SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1304           /* if Master ADC JAUTO bit is set, update Slave State in setting
;;;1305              HAL_ADC_STATE_INJ_BUSY bit and in resetting HAL_ADC_STATE_INJ_EOC bit */
;;;1306           tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
;;;1307           if (READ_BIT(tmpADC_Master->CFGR, ADC_CFGR_JAUTO) != 0UL)
;;;1308           {
;;;1309             ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1310           }
;;;1311   
;;;1312         }
;;;1313   #else
;;;1314         if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != 0UL)
;;;1315         {
;;;1316           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1317         }
;;;1318   
;;;1319         /* Start ADC group regular conversion */
;;;1320         LL_ADC_REG_StartConversion(hadc->Instance);
;;;1321   #endif
;;;1322       }
;;;1323       else
;;;1324       {
;;;1325         /* Process unlocked */
;;;1326         __HAL_UNLOCK(hadc);
;;;1327       }
;;;1328     }
;;;1329     else
;;;1330     {
;;;1331       tmp_hal_status = HAL_BUSY;
000016  2102              MOVS     r1,#2
                  |L23.24|
;;;1332     }
;;;1333   
;;;1334     /* Return function status */
;;;1335     return tmp_hal_status;
000018  4608              MOV      r0,r1
                  |L23.26|
;;;1336   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L23.30|
00001e  f8940054          LDRB     r0,[r4,#0x54]         ;1227
000022  2801              CMP      r0,#1                 ;1227
000024  d00b              BEQ      |L23.62|
000026  2001              MOVS     r0,#1                 ;1227
000028  f8840054          STRB     r0,[r4,#0x54]         ;1227
00002c  4620              MOV      r0,r4                 ;1230
00002e  f7fffffe          BL       ADC_Enable
000032  4601              MOV      r1,r0                 ;1230
000034  2300              MOVS     r3,#0                 ;1233
000036  b121              CBZ      r1,|L23.66|
000038  f8843054          STRB     r3,[r4,#0x54]         ;1326
00003c  e7ec              B        |L23.24|
                  |L23.62|
00003e  2002              MOVS     r0,#2                 ;1227
000040  e7eb              B        |L23.26|
                  |L23.66|
000042  6da0              LDR      r0,[r4,#0x58]         ;1238
000044  f6406201          MOV      r2,#0xe01             ;1238
000048  4390              BICS     r0,r0,r2              ;1238
00004a  f4407080          ORR      r0,r0,#0x100          ;1238
00004e  65a0              STR      r0,[r4,#0x58]         ;1238
000050  4f25              LDR      r7,|L23.232|
000052  6820              LDR      r0,[r4,#0]            ;1246
000054  4e25              LDR      r6,|L23.236|
000056  42b8              CMP      r0,r7                 ;1246
000058  d101              BNE      |L23.94|
00005a  4632              MOV      r2,r6                 ;1246
00005c  e000              B        |L23.96|
                  |L23.94|
00005e  4602              MOV      r2,r0                 ;1246
                  |L23.96|
000060  4282              CMP      r2,r0                 ;1246
000062  d000              BEQ      |L23.102|
000064  b91d              CBNZ     r5,|L23.110|
                  |L23.102|
000066  6da2              LDR      r2,[r4,#0x58]         ;1250
000068  f4221280          BIC      r2,r2,#0x100000       ;1250
00006c  65a2              STR      r2,[r4,#0x58]         ;1250
                  |L23.110|
00006e  6da2              LDR      r2,[r4,#0x58]         ;1256
000070  04d2              LSLS     r2,r2,#19             ;1256
000072  d504              BPL      |L23.126|
000074  6de2              LDR      r2,[r4,#0x5c]         ;1259
000076  f0220206          BIC      r2,r2,#6              ;1259
00007a  65e2              STR      r2,[r4,#0x5c]         ;1259
00007c  e000              B        |L23.128|
                  |L23.126|
00007e  65e3              STR      r3,[r4,#0x5c]         ;1264
                  |L23.128|
000080  221c              MOVS     r2,#0x1c              ;1269
000082  6002              STR      r2,[r0,#0]            ;1269
000084  f8843054          STRB     r3,[r4,#0x54]         ;1274
000088  6820              LDR      r0,[r4,#0]            ;1285
00008a  42b8              CMP      r0,r7                 ;1285
00008c  d101              BNE      |L23.146|
00008e  4632              MOV      r2,r6                 ;1285
000090  e000              B        |L23.148|
                  |L23.146|
000092  4602              MOV      r2,r0                 ;1285
                  |L23.148|
000094  4282              CMP      r2,r0                 ;1285
000096  d015              BEQ      |L23.196|
000098  b1a5              CBZ      r5,|L23.196|
00009a  2d05              CMP      r5,#5                 ;1287
00009c  d012              BEQ      |L23.196|
00009e  2d09              CMP      r5,#9                 ;1288
0000a0  d010              BEQ      |L23.196|
0000a2  6da2              LDR      r2,[r4,#0x58]         ;1303
0000a4  f4421280          ORR      r2,r2,#0x100000       ;1303
0000a8  65a2              STR      r2,[r4,#0x58]         ;1303
0000aa  42b8              CMP      r0,r7                 ;1306
0000ac  d100              BNE      |L23.176|
0000ae  4630              MOV      r0,r6                 ;1306
                  |L23.176|
0000b0  68c0              LDR      r0,[r0,#0xc]          ;1307
0000b2  0180              LSLS     r0,r0,#6              ;1307
0000b4  d5b0              BPL      |L23.24|
0000b6  6da0              LDR      r0,[r4,#0x58]         ;1309
0000b8  f4205000          BIC      r0,r0,#0x2000         ;1309
0000bc  f4405080          ORR      r0,r0,#0x1000         ;1309
0000c0  65a0              STR      r0,[r4,#0x58]         ;1309
0000c2  e7a9              B        |L23.24|
                  |L23.196|
0000c4  68c2              LDR      r2,[r0,#0xc]          ;1292
0000c6  0192              LSLS     r2,r2,#6              ;1292
0000c8  d505              BPL      |L23.214|
0000ca  6da2              LDR      r2,[r4,#0x58]         ;1294
0000cc  f4225200          BIC      r2,r2,#0x2000         ;1294
0000d0  f4425280          ORR      r2,r2,#0x1000         ;1294
0000d4  65a2              STR      r2,[r4,#0x58]         ;1294
                  |L23.214|
0000d6  6882              LDR      r2,[r0,#8]            ;1294
0000d8  4b05              LDR      r3,|L23.240|
0000da  401a              ANDS     r2,r2,r3              ;1294
0000dc  1d12              ADDS     r2,r2,#4              ;1294
0000de  6082              STR      r2,[r0,#8]            ;1294
0000e0  e79a              B        |L23.24|
;;;1337   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L23.228|
                          DCD      0x50040300
                  |L23.232|
                          DCD      0x50040100
                  |L23.236|
                          DCD      0x50040000
                  |L23.240|
                          DCD      0x7fffffc0

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;1992     */
;;;1993   HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1994   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4835              LDR      r0,|L24.224|
00000c  6880              LDR      r0,[r0,#8]
00000e  f000051f          AND      r5,r0,#0x1f
;;;1995     HAL_StatusTypeDef tmp_hal_status;
;;;1996   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1997     uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;1998   #endif
;;;1999   
;;;2000     /* Check the parameters */
;;;2001     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2002   
;;;2003     /* Perform ADC enable and conversion start if no conversion is on going */
;;;2004     if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000018  b110              CBZ      r0,|L24.32|
;;;2005     {
;;;2006       /* Process locked */
;;;2007       __HAL_LOCK(hadc);
;;;2008   
;;;2009   #if defined(ADC_MULTIMODE_SUPPORT)
;;;2010       /* Ensure that multimode regular conversions are not enabled.   */
;;;2011       /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
;;;2012       if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;2013           || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
;;;2014           || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
;;;2015          )
;;;2016   #endif
;;;2017       {
;;;2018         /* Enable the ADC peripheral */
;;;2019         tmp_hal_status = ADC_Enable(hadc);
;;;2020   
;;;2021         /* Start conversion if ADC is effectively enabled */
;;;2022         if (tmp_hal_status == HAL_OK)
;;;2023         {
;;;2024           /* Set ADC state                                                        */
;;;2025           /* - Clear state bitfield related to regular group conversion results   */
;;;2026           /* - Set state bitfield related to regular operation                    */
;;;2027           ADC_STATE_CLR_SET(hadc->State,
;;;2028                             HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;2029                             HAL_ADC_STATE_REG_BUSY);
;;;2030   
;;;2031   #if defined(ADC_MULTIMODE_SUPPORT)
;;;2032           /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
;;;2033             - if ADC instance is master or if multimode feature is not available
;;;2034             - if multimode setting is disabled (ADC instance slave in independent mode) */
;;;2035           if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;2036               || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;2037              )
;;;2038           {
;;;2039             CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;2040           }
;;;2041   #endif
;;;2042   
;;;2043           /* Check if a conversion is on going on ADC group injected */
;;;2044           if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
;;;2045           {
;;;2046             /* Reset ADC error code fields related to regular conversions only */
;;;2047             CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
;;;2048           }
;;;2049           else
;;;2050           {
;;;2051             /* Reset all ADC error code fields */
;;;2052             ADC_CLEAR_ERRORCODE(hadc);
;;;2053           }
;;;2054   
;;;2055           /* Set the DMA transfer complete callback */
;;;2056           hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;2057   
;;;2058           /* Set the DMA half transfer complete callback */
;;;2059           hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;2060   
;;;2061           /* Set the DMA error callback */
;;;2062           hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;2063   
;;;2064   
;;;2065           /* Manage ADC and DMA start: ADC overrun interruption, DMA start,     */
;;;2066           /* ADC start (in case of SW start):                                   */
;;;2067   
;;;2068           /* Clear regular group conversion flag and overrun flag               */
;;;2069           /* (To ensure of no unknown state from potential previous ADC         */
;;;2070           /* operations)                                                        */
;;;2071           __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
;;;2072   
;;;2073           /* Process unlocked */
;;;2074           /* Unlock before starting ADC conversions: in case of potential         */
;;;2075           /* interruption, to let the process to ADC IRQ Handler.                 */
;;;2076           __HAL_UNLOCK(hadc);
;;;2077   
;;;2078           /* With DMA, overrun event is always considered as an error even if
;;;2079              hadc->Init.Overrun is set to ADC_OVR_DATA_OVERWRITTEN. Therefore,
;;;2080              ADC_IT_OVR is enabled. */
;;;2081           __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;2082   
;;;2083           /* Enable ADC DMA mode */
;;;2084           SET_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN);
;;;2085   
;;;2086           /* Start the DMA channel */
;;;2087           tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;2088   
;;;2089           /* Enable conversion of regular group.                                  */
;;;2090           /* If software start has been selected, conversion starts immediately.  */
;;;2091           /* If external trigger has been selected, conversion will start at next */
;;;2092           /* trigger event.                                                       */
;;;2093           /* Start ADC group regular conversion */
;;;2094           LL_ADC_REG_StartConversion(hadc->Instance);
;;;2095         }
;;;2096         else
;;;2097         {
;;;2098           /* Process unlocked */
;;;2099           __HAL_UNLOCK(hadc);
;;;2100         }
;;;2101   
;;;2102       }
;;;2103   #if defined(ADC_MULTIMODE_SUPPORT)
;;;2104       else
;;;2105       {
;;;2106         tmp_hal_status = HAL_ERROR;
;;;2107         /* Process unlocked */
;;;2108         __HAL_UNLOCK(hadc);
;;;2109       }
;;;2110   #endif
;;;2111     }
;;;2112     else
;;;2113     {
;;;2114       tmp_hal_status = HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L24.28|
;;;2115     }
;;;2116   
;;;2117     /* Return function status */
;;;2118     return tmp_hal_status;
;;;2119   }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L24.32|
000020  f8940054          LDRB     r0,[r4,#0x54]         ;2007
000024  2801              CMP      r0,#1                 ;2007
000026  d00c              BEQ      |L24.66|
000028  2001              MOVS     r0,#1                 ;2007
00002a  f8840054          STRB     r0,[r4,#0x54]         ;2007
00002e  f04f0800          MOV      r8,#0                 ;2012
000032  b145              CBZ      r5,|L24.70|
000034  2d05              CMP      r5,#5                 ;2013
000036  d006              BEQ      |L24.70|
000038  2d09              CMP      r5,#9                 ;2014
00003a  d004              BEQ      |L24.70|
00003c  f8848054          STRB     r8,[r4,#0x54]         ;2108
000040  e7ec              B        |L24.28|
                  |L24.66|
000042  2002              MOVS     r0,#2                 ;2007
000044  e7ea              B        |L24.28|
                  |L24.70|
000046  4620              MOV      r0,r4                 ;2019
000048  f7fffffe          BL       ADC_Enable
00004c  b110              CBZ      r0,|L24.84|
00004e  f8848054          STRB     r8,[r4,#0x54]         ;2099
000052  e7e3              B        |L24.28|
                  |L24.84|
000054  6da0              LDR      r0,[r4,#0x58]         ;2027
000056  f6406101          MOV      r1,#0xe01             ;2027
00005a  4388              BICS     r0,r0,r1              ;2027
00005c  f4407080          ORR      r0,r0,#0x100          ;2027
000060  65a0              STR      r0,[r4,#0x58]         ;2027
000062  4920              LDR      r1,|L24.228|
000064  6820              LDR      r0,[r4,#0]            ;2035
000066  4288              CMP      r0,r1                 ;2035
000068  d101              BNE      |L24.110|
00006a  4a1f              LDR      r2,|L24.232|
00006c  e000              B        |L24.112|
                  |L24.110|
00006e  4602              MOV      r2,r0                 ;2035
                  |L24.112|
000070  4282              CMP      r2,r0                 ;2035
000072  d000              BEQ      |L24.118|
000074  b91d              CBNZ     r5,|L24.126|
                  |L24.118|
000076  6da0              LDR      r0,[r4,#0x58]         ;2039
000078  f4201080          BIC      r0,r0,#0x100000       ;2039
00007c  65a0              STR      r0,[r4,#0x58]         ;2039
                  |L24.126|
00007e  6da0              LDR      r0,[r4,#0x58]         ;2044
000080  04c0              LSLS     r0,r0,#19             ;2044
000082  d504              BPL      |L24.142|
000084  6de0              LDR      r0,[r4,#0x5c]         ;2047
000086  f0200006          BIC      r0,r0,#6              ;2047
00008a  65e0              STR      r0,[r4,#0x5c]         ;2047
00008c  e001              B        |L24.146|
                  |L24.142|
00008e  f8c4805c          STR      r8,[r4,#0x5c]         ;2052
                  |L24.146|
000092  6d21              LDR      r1,[r4,#0x50]         ;2056
000094  4815              LDR      r0,|L24.236|
000096  62c8              STR      r0,[r1,#0x2c]         ;2056
000098  6d21              LDR      r1,[r4,#0x50]         ;2059
00009a  4815              LDR      r0,|L24.240|
00009c  6308              STR      r0,[r1,#0x30]         ;2059
00009e  6d21              LDR      r1,[r4,#0x50]         ;2062
0000a0  4814              LDR      r0,|L24.244|
0000a2  6348              STR      r0,[r1,#0x34]         ;2062
0000a4  6821              LDR      r1,[r4,#0]            ;2071
0000a6  201c              MOVS     r0,#0x1c              ;2071
0000a8  6008              STR      r0,[r1,#0]            ;2071
0000aa  f8848054          STRB     r8,[r4,#0x54]         ;2076
0000ae  6820              LDR      r0,[r4,#0]            ;2081
0000b0  6841              LDR      r1,[r0,#4]            ;2081
0000b2  f0410110          ORR      r1,r1,#0x10           ;2081
0000b6  6041              STR      r1,[r0,#4]            ;2081
0000b8  6820              LDR      r0,[r4,#0]            ;2084
0000ba  68c1              LDR      r1,[r0,#0xc]          ;2084
0000bc  f0410101          ORR      r1,r1,#1              ;2084
0000c0  60c1              STR      r1,[r0,#0xc]          ;2084
0000c2  6821              LDR      r1,[r4,#0]            ;2087
0000c4  463b              MOV      r3,r7                 ;2087
0000c6  3140              ADDS     r1,r1,#0x40           ;2087
0000c8  4632              MOV      r2,r6                 ;2087
0000ca  6d20              LDR      r0,[r4,#0x50]         ;2087
0000cc  f7fffffe          BL       HAL_DMA_Start_IT
0000d0  6821              LDR      r1,[r4,#0]            ;2094
0000d2  688a              LDR      r2,[r1,#8]            ;2094
0000d4  4b08              LDR      r3,|L24.248|
0000d6  401a              ANDS     r2,r2,r3              ;2094
0000d8  1d12              ADDS     r2,r2,#4              ;2094
0000da  608a              STR      r2,[r1,#8]            ;2094
0000dc  e79e              B        |L24.28|
;;;2120   
                          ENDP

0000de  0000              DCW      0x0000
                  |L24.224|
                          DCD      0x50040300
                  |L24.228|
                          DCD      0x50040100
                  |L24.232|
                          DCD      0x50040000
                  |L24.236|
                          DCD      ADC_DMAConvCplt
                  |L24.240|
                          DCD      ADC_DMAHalfConvCplt
                  |L24.244|
                          DCD      ADC_DMAError
                  |L24.248|
                          DCD      0x7fffffc0

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;1732     */
;;;1733   HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef *hadc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1734   {
000004  4604              MOV      r4,r0
000006  485c              LDR      r0,|L25.376|
000008  6880              LDR      r0,[r0,#8]
00000a  f000051f          AND      r5,r0,#0x1f
;;;1735     HAL_StatusTypeDef tmp_hal_status;
;;;1736   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1737     const ADC_TypeDef *tmpADC_Master;
;;;1738     uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;1739   #endif
;;;1740   
;;;1741     /* Check the parameters */
;;;1742     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1743   
;;;1744     /* Perform ADC enable and conversion start if no conversion is on going */
;;;1745     if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000014  b118              CBZ      r0,|L25.30|
;;;1746     {
;;;1747       /* Process locked */
;;;1748       __HAL_LOCK(hadc);
;;;1749   
;;;1750       /* Enable the ADC peripheral */
;;;1751       tmp_hal_status = ADC_Enable(hadc);
;;;1752   
;;;1753       /* Start conversion if ADC is effectively enabled */
;;;1754       if (tmp_hal_status == HAL_OK)
;;;1755       {
;;;1756         /* Set ADC state                                                        */
;;;1757         /* - Clear state bitfield related to regular group conversion results   */
;;;1758         /* - Set state bitfield related to regular operation                    */
;;;1759         ADC_STATE_CLR_SET(hadc->State,
;;;1760                           HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1761                           HAL_ADC_STATE_REG_BUSY);
;;;1762   
;;;1763   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1764         /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
;;;1765           - if ADC instance is master or if multimode feature is not available
;;;1766           - if multimode setting is disabled (ADC instance slave in independent mode) */
;;;1767         if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;1768             || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;1769            )
;;;1770         {
;;;1771           CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1772         }
;;;1773   #endif
;;;1774   
;;;1775         /* Set ADC error code */
;;;1776         /* Check if a conversion is on going on ADC group injected */
;;;1777         if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
;;;1778         {
;;;1779           /* Reset ADC error code fields related to regular conversions only */
;;;1780           CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
;;;1781         }
;;;1782         else
;;;1783         {
;;;1784           /* Reset all ADC error code fields */
;;;1785           ADC_CLEAR_ERRORCODE(hadc);
;;;1786         }
;;;1787   
;;;1788         /* Clear ADC group regular conversion flag and overrun flag               */
;;;1789         /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1790         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
;;;1791   
;;;1792         /* Process unlocked */
;;;1793         /* Unlock before starting ADC conversions: in case of potential         */
;;;1794         /* interruption, to let the process to ADC IRQ Handler.                 */
;;;1795         __HAL_UNLOCK(hadc);
;;;1796   
;;;1797         /* Disable all interruptions before enabling the desired ones */
;;;1798         __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
;;;1799   
;;;1800         /* Enable ADC end of conversion interrupt */
;;;1801         switch (hadc->Init.EOCSelection)
;;;1802         {
;;;1803           case ADC_EOC_SEQ_CONV:
;;;1804             __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOS);
;;;1805             break;
;;;1806           /* case ADC_EOC_SINGLE_CONV */
;;;1807           default:
;;;1808             __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
;;;1809             break;
;;;1810         }
;;;1811   
;;;1812         /* Enable ADC overrun interrupt */
;;;1813         /* If hadc->Init.Overrun is set to ADC_OVR_DATA_PRESERVED, only then is
;;;1814            ADC_IT_OVR enabled; otherwise data overwrite is considered as normal
;;;1815            behavior and no CPU time is lost for a non-processed interruption */
;;;1816         if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
;;;1817         {
;;;1818           __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;1819         }
;;;1820   
;;;1821         /* Enable conversion of regular group.                                  */
;;;1822         /* If software start has been selected, conversion starts immediately.  */
;;;1823         /* If external trigger has been selected, conversion will start at next */
;;;1824         /* trigger event.                                                       */
;;;1825         /* Case of multimode enabled (when multimode feature is available):     */
;;;1826         /*  - if ADC is slave and dual regular conversions are enabled, ADC is  */
;;;1827         /*    enabled only (conversion is not started),                         */
;;;1828         /*  - if ADC is master, ADC is enabled and conversion is started.       */
;;;1829   #if defined(ADC_MULTIMODE_SUPPORT)
;;;1830         if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;1831             || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;1832             || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
;;;1833             || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
;;;1834            )
;;;1835         {
;;;1836           /* ADC instance is not a multimode slave instance with multimode regular conversions enabled */
;;;1837           if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != 0UL)
;;;1838           {
;;;1839             ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1840   
;;;1841             /* Enable as well injected interruptions in case
;;;1842              HAL_ADCEx_InjectedStart_IT() has not been called beforehand. This
;;;1843              allows to start regular and injected conversions when JAUTO is
;;;1844              set with a single call to HAL_ADC_Start_IT() */
;;;1845             switch (hadc->Init.EOCSelection)
;;;1846             {
;;;1847               case ADC_EOC_SEQ_CONV:
;;;1848                 __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
;;;1849                 __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
;;;1850                 break;
;;;1851               /* case ADC_EOC_SINGLE_CONV */
;;;1852               default:
;;;1853                 __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
;;;1854                 __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
;;;1855                 break;
;;;1856             }
;;;1857           }
;;;1858   
;;;1859           /* Start ADC group regular conversion */
;;;1860           LL_ADC_REG_StartConversion(hadc->Instance);
;;;1861         }
;;;1862         else
;;;1863         {
;;;1864           /* ADC instance is a multimode slave instance with multimode regular conversions enabled */
;;;1865           SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1866           /* if Master ADC JAUTO bit is set, Slave injected interruptions
;;;1867              are enabled nevertheless (for same reason as above) */
;;;1868           tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
;;;1869           if (READ_BIT(tmpADC_Master->CFGR, ADC_CFGR_JAUTO) != 0UL)
;;;1870           {
;;;1871             /* First, update Slave State in setting HAL_ADC_STATE_INJ_BUSY bit
;;;1872                and in resetting HAL_ADC_STATE_INJ_EOC bit */
;;;1873             ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1874             /* Next, set Slave injected interruptions */
;;;1875             switch (hadc->Init.EOCSelection)
;;;1876             {
;;;1877               case ADC_EOC_SEQ_CONV:
;;;1878                 __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
;;;1879                 __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
;;;1880                 break;
;;;1881               /* case ADC_EOC_SINGLE_CONV */
;;;1882               default:
;;;1883                 __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
;;;1884                 __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
;;;1885                 break;
;;;1886             }
;;;1887           }
;;;1888         }
;;;1889   #else
;;;1890         /* ADC instance is not a multimode slave instance with multimode regular conversions enabled */
;;;1891         if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != 0UL)
;;;1892         {
;;;1893           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1894   
;;;1895           /* Enable as well injected interruptions in case
;;;1896            HAL_ADCEx_InjectedStart_IT() has not been called beforehand. This
;;;1897            allows to start regular and injected conversions when JAUTO is
;;;1898            set with a single call to HAL_ADC_Start_IT() */
;;;1899           switch (hadc->Init.EOCSelection)
;;;1900           {
;;;1901             case ADC_EOC_SEQ_CONV:
;;;1902               __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
;;;1903               __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
;;;1904               break;
;;;1905             /* case ADC_EOC_SINGLE_CONV */
;;;1906             default:
;;;1907               __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
;;;1908               __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
;;;1909               break;
;;;1910           }
;;;1911         }
;;;1912   
;;;1913         /* Start ADC group regular conversion */
;;;1914         LL_ADC_REG_StartConversion(hadc->Instance);
;;;1915   #endif
;;;1916       }
;;;1917       else
;;;1918       {
;;;1919         /* Process unlocked */
;;;1920         __HAL_UNLOCK(hadc);
;;;1921       }
;;;1922   
;;;1923     }
;;;1924     else
;;;1925     {
;;;1926       tmp_hal_status = HAL_BUSY;
000016  2102              MOVS     r1,#2
                  |L25.24|
;;;1927     }
;;;1928   
;;;1929     /* Return function status */
;;;1930     return tmp_hal_status;
000018  4608              MOV      r0,r1
                  |L25.26|
;;;1931   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L25.30|
00001e  f8940054          LDRB     r0,[r4,#0x54]         ;1748
000022  2801              CMP      r0,#1                 ;1748
000024  d00b              BEQ      |L25.62|
000026  2001              MOVS     r0,#1                 ;1748
000028  f8840054          STRB     r0,[r4,#0x54]         ;1748
00002c  4620              MOV      r0,r4                 ;1751
00002e  f7fffffe          BL       ADC_Enable
000032  4601              MOV      r1,r0                 ;1751
000034  2700              MOVS     r7,#0                 ;1754
000036  b121              CBZ      r1,|L25.66|
000038  f8847054          STRB     r7,[r4,#0x54]         ;1920
00003c  e7ec              B        |L25.24|
                  |L25.62|
00003e  2002              MOVS     r0,#2                 ;1748
000040  e7eb              B        |L25.26|
                  |L25.66|
000042  6da0              LDR      r0,[r4,#0x58]         ;1759
000044  f6406201          MOV      r2,#0xe01             ;1759
000048  4390              BICS     r0,r0,r2              ;1759
00004a  f4407080          ORR      r0,r0,#0x100          ;1759
00004e  65a0              STR      r0,[r4,#0x58]         ;1759
000050  4e4a              LDR      r6,|L25.380|
000052  6820              LDR      r0,[r4,#0]            ;1767
000054  4b4a              LDR      r3,|L25.384|
000056  42b0              CMP      r0,r6                 ;1767
000058  d101              BNE      |L25.94|
00005a  461a              MOV      r2,r3                 ;1767
00005c  e000              B        |L25.96|
                  |L25.94|
00005e  4602              MOV      r2,r0                 ;1767
                  |L25.96|
000060  4282              CMP      r2,r0                 ;1767
000062  d000              BEQ      |L25.102|
000064  b91d              CBNZ     r5,|L25.110|
                  |L25.102|
000066  6da2              LDR      r2,[r4,#0x58]         ;1771
000068  f4221280          BIC      r2,r2,#0x100000       ;1771
00006c  65a2              STR      r2,[r4,#0x58]         ;1771
                  |L25.110|
00006e  6da2              LDR      r2,[r4,#0x58]         ;1777
000070  04d2              LSLS     r2,r2,#19             ;1777
000072  d504              BPL      |L25.126|
000074  6de2              LDR      r2,[r4,#0x5c]         ;1780
000076  f0220206          BIC      r2,r2,#6              ;1780
00007a  65e2              STR      r2,[r4,#0x5c]         ;1780
00007c  e000              B        |L25.128|
                  |L25.126|
00007e  65e7              STR      r7,[r4,#0x5c]         ;1785
                  |L25.128|
000080  221c              MOVS     r2,#0x1c              ;1790
000082  6002              STR      r2,[r0,#0]            ;1790
000084  f8847054          STRB     r7,[r4,#0x54]         ;1795
000088  6820              LDR      r0,[r4,#0]            ;1798
00008a  6842              LDR      r2,[r0,#4]            ;1798
00008c  f022021c          BIC      r2,r2,#0x1c           ;1798
000090  6042              STR      r2,[r0,#4]            ;1798
000092  6960              LDR      r0,[r4,#0x14]         ;1801
000094  2808              CMP      r0,#8                 ;1801
000096  d007              BEQ      |L25.168|
000098  6820              LDR      r0,[r4,#0]            ;1808
00009a  6842              LDR      r2,[r0,#4]            ;1808
00009c  f0420204          ORR      r2,r2,#4              ;1808
0000a0  6042              STR      r2,[r0,#4]            ;1808
                  |L25.162|
0000a2  6b60              LDR      r0,[r4,#0x34]         ;1816
0000a4  b130              CBZ      r0,|L25.180|
0000a6  e00a              B        |L25.190|
                  |L25.168|
0000a8  6820              LDR      r0,[r4,#0]            ;1804
0000aa  6842              LDR      r2,[r0,#4]            ;1804
0000ac  f0420208          ORR      r2,r2,#8              ;1804
0000b0  6042              STR      r2,[r0,#4]            ;1804
0000b2  e7f6              B        |L25.162|
                  |L25.180|
0000b4  6820              LDR      r0,[r4,#0]            ;1818
0000b6  6842              LDR      r2,[r0,#4]            ;1818
0000b8  f0420210          ORR      r2,r2,#0x10           ;1818
0000bc  6042              STR      r2,[r0,#4]            ;1818
                  |L25.190|
0000be  6820              LDR      r0,[r4,#0]            ;1830
0000c0  42b0              CMP      r0,r6                 ;1830
0000c2  d101              BNE      |L25.200|
0000c4  461a              MOV      r2,r3                 ;1830
0000c6  e000              B        |L25.202|
                  |L25.200|
0000c8  4602              MOV      r2,r0                 ;1830
                  |L25.202|
0000ca  4282              CMP      r2,r0                 ;1830
0000cc  d00c              BEQ      |L25.232|
0000ce  b15d              CBZ      r5,|L25.232|
0000d0  2d05              CMP      r5,#5                 ;1832
0000d2  d009              BEQ      |L25.232|
0000d4  2d09              CMP      r5,#9                 ;1833
0000d6  d007              BEQ      |L25.232|
0000d8  6da2              LDR      r2,[r4,#0x58]         ;1865
0000da  f4421280          ORR      r2,r2,#0x100000       ;1865
0000de  65a2              STR      r2,[r4,#0x58]         ;1865
0000e0  42b0              CMP      r0,r6                 ;1868
0000e2  d127              BNE      |L25.308|
0000e4  461a              MOV      r2,r3                 ;1868
0000e6  e026              B        |L25.310|
                  |L25.232|
0000e8  68c2              LDR      r2,[r0,#0xc]          ;1837
0000ea  0192              LSLS     r2,r2,#6              ;1837
0000ec  d511              BPL      |L25.274|
0000ee  6da2              LDR      r2,[r4,#0x58]         ;1839
0000f0  f4225200          BIC      r2,r2,#0x2000         ;1839
0000f4  f4425280          ORR      r2,r2,#0x1000         ;1839
0000f8  65a2              STR      r2,[r4,#0x58]         ;1839
0000fa  6962              LDR      r2,[r4,#0x14]         ;1845
0000fc  2a08              CMP      r2,#8                 ;1845
0000fe  d00f              BEQ      |L25.288|
000100  6842              LDR      r2,[r0,#4]            ;1853
000102  f0220240          BIC      r2,r2,#0x40           ;1853
000106  6042              STR      r2,[r0,#4]            ;1853
000108  6820              LDR      r0,[r4,#0]            ;1854
00010a  6842              LDR      r2,[r0,#4]            ;1854
00010c  f0420220          ORR      r2,r2,#0x20           ;1854
000110  6042              STR      r2,[r0,#4]            ;1854
                  |L25.274|
000112  6820              LDR      r0,[r4,#0]            ;1860
000114  6882              LDR      r2,[r0,#8]            ;1860
000116  4b1b              LDR      r3,|L25.388|
000118  401a              ANDS     r2,r2,r3              ;1860
00011a  1d12              ADDS     r2,r2,#4              ;1860
00011c  6082              STR      r2,[r0,#8]            ;1860
                  |L25.286|
00011e  e77b              B        |L25.24|
                  |L25.288|
000120  6842              LDR      r2,[r0,#4]            ;1848
000122  f0220220          BIC      r2,r2,#0x20           ;1848
000126  6042              STR      r2,[r0,#4]            ;1848
000128  6820              LDR      r0,[r4,#0]            ;1849
00012a  6842              LDR      r2,[r0,#4]            ;1849
00012c  f0420240          ORR      r2,r2,#0x40           ;1849
000130  6042              STR      r2,[r0,#4]            ;1849
000132  e7ee              B        |L25.274|
                  |L25.308|
000134  4602              MOV      r2,r0                 ;1868
                  |L25.310|
000136  68d2              LDR      r2,[r2,#0xc]          ;1869
000138  0192              LSLS     r2,r2,#6              ;1869
00013a  d5f0              BPL      |L25.286|
00013c  6da2              LDR      r2,[r4,#0x58]         ;1873
00013e  f4225200          BIC      r2,r2,#0x2000         ;1873
000142  f4425280          ORR      r2,r2,#0x1000         ;1873
000146  65a2              STR      r2,[r4,#0x58]         ;1873
000148  6962              LDR      r2,[r4,#0x14]         ;1875
00014a  2a08              CMP      r2,#8                 ;1875
00014c  d009              BEQ      |L25.354|
00014e  6842              LDR      r2,[r0,#4]            ;1883
000150  f0220240          BIC      r2,r2,#0x40           ;1883
000154  6042              STR      r2,[r0,#4]            ;1883
000156  6820              LDR      r0,[r4,#0]            ;1884
000158  6842              LDR      r2,[r0,#4]            ;1884
00015a  f0420220          ORR      r2,r2,#0x20           ;1884
00015e  6042              STR      r2,[r0,#4]            ;1884
000160  e75a              B        |L25.24|
                  |L25.354|
000162  6842              LDR      r2,[r0,#4]            ;1878
000164  f0220220          BIC      r2,r2,#0x20           ;1878
000168  6042              STR      r2,[r0,#4]            ;1878
00016a  6820              LDR      r0,[r4,#0]            ;1879
00016c  6842              LDR      r2,[r0,#4]            ;1879
00016e  f0420240          ORR      r2,r2,#0x40           ;1879
000172  6042              STR      r2,[r0,#4]            ;1879
000174  e750              B        |L25.24|
;;;1932   
                          ENDP

000176  0000              DCW      0x0000
                  |L25.376|
                          DCD      0x50040300
                  |L25.380|
                          DCD      0x50040100
                  |L25.384|
                          DCD      0x50040000
                  |L25.388|
                          DCD      0x7fffffc0

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;1346     */
;;;1347   HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;1348   {
000002  4604              MOV      r4,r0
;;;1349     HAL_StatusTypeDef tmp_hal_status;
;;;1350   
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1353   
;;;1354     /* Process locked */
;;;1355     __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L26.30|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;1356   
;;;1357     /* 1. Stop potential conversion on going, on ADC groups regular and injected */
;;;1358     tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
000012  2103              MOVS     r1,#3
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  b110              CBZ      r0,|L26.34|
00001c  e00b              B        |L26.54|
                  |L26.30|
00001e  2002              MOVS     r0,#2                 ;1355
;;;1359   
;;;1360     /* Disable ADC peripheral if conversions are effectively stopped */
;;;1361     if (tmp_hal_status == HAL_OK)
;;;1362     {
;;;1363       /* 2. Disable the ADC peripheral */
;;;1364       tmp_hal_status = ADC_Disable(hadc);
;;;1365   
;;;1366       /* Check if ADC is effectively disabled */
;;;1367       if (tmp_hal_status == HAL_OK)
;;;1368       {
;;;1369         /* Set ADC state */
;;;1370         ADC_STATE_CLR_SET(hadc->State,
;;;1371                           HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1372                           HAL_ADC_STATE_READY);
;;;1373       }
;;;1374     }
;;;1375   
;;;1376     /* Process unlocked */
;;;1377     __HAL_UNLOCK(hadc);
;;;1378   
;;;1379     /* Return function status */
;;;1380     return tmp_hal_status;
;;;1381   }
000020  bd10              POP      {r4,pc}
                  |L26.34|
000022  4620              MOV      r0,r4                 ;1364
000024  f7fffffe          BL       ADC_Disable
000028  b928              CBNZ     r0,|L26.54|
00002a  6da1              LDR      r1,[r4,#0x58]         ;1370
00002c  f4215188          BIC      r1,r1,#0x1100         ;1370
000030  f0410101          ORR      r1,r1,#1              ;1370
000034  65a1              STR      r1,[r4,#0x58]         ;1370
                  |L26.54|
000036  2100              MOVS     r1,#0                 ;1377
000038  f8841054          STRB     r1,[r4,#0x54]         ;1377
00003c  bd10              POP      {r4,pc}
;;;1382   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;2133     */
;;;2134   HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;2135   {
000002  4604              MOV      r4,r0
;;;2136     HAL_StatusTypeDef tmp_hal_status;
;;;2137   
;;;2138     /* Check the parameters */
;;;2139     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2140   
;;;2141     /* Process locked */
;;;2142     __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L27.32|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;2143   
;;;2144     /* 1. Stop potential ADC group regular conversion on going */
;;;2145     tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
000012  2103              MOVS     r1,#3
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  4605              MOV      r5,r0
00001c  b115              CBZ      r5,|L27.36|
00001e  e029              B        |L27.116|
                  |L27.32|
000020  2002              MOVS     r0,#2                 ;2142
;;;2146   
;;;2147     /* Disable ADC peripheral if conversions are effectively stopped */
;;;2148     if (tmp_hal_status == HAL_OK)
;;;2149     {
;;;2150       /* Disable ADC DMA (ADC DMA configuration of continuous requests is kept) */
;;;2151       CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN);
;;;2152   
;;;2153       /* Disable the DMA channel (in case of DMA in circular mode or stop       */
;;;2154       /* while DMA transfer is on going)                                        */
;;;2155       if (hadc->DMA_Handle->State == HAL_DMA_STATE_BUSY)
;;;2156       {
;;;2157         tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;2158   
;;;2159         /* Check if DMA channel effectively disabled */
;;;2160         if (tmp_hal_status != HAL_OK)
;;;2161         {
;;;2162           /* Update ADC state machine to error */
;;;2163           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;2164         }
;;;2165       }
;;;2166   
;;;2167       /* Disable ADC overrun interrupt */
;;;2168       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;2169   
;;;2170       /* 2. Disable the ADC peripheral */
;;;2171       /* Update "tmp_hal_status" only if DMA channel disabling passed,          */
;;;2172       /* to keep in memory a potential failing status.                          */
;;;2173       if (tmp_hal_status == HAL_OK)
;;;2174       {
;;;2175         tmp_hal_status = ADC_Disable(hadc);
;;;2176       }
;;;2177       else
;;;2178       {
;;;2179         (void)ADC_Disable(hadc);
;;;2180       }
;;;2181   
;;;2182       /* Check if ADC is effectively disabled */
;;;2183       if (tmp_hal_status == HAL_OK)
;;;2184       {
;;;2185         /* Set ADC state */
;;;2186         ADC_STATE_CLR_SET(hadc->State,
;;;2187                           HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;2188                           HAL_ADC_STATE_READY);
;;;2189       }
;;;2190   
;;;2191     }
;;;2192   
;;;2193     /* Process unlocked */
;;;2194     __HAL_UNLOCK(hadc);
;;;2195   
;;;2196     /* Return function status */
;;;2197     return tmp_hal_status;
;;;2198   }
000022  bd70              POP      {r4-r6,pc}
                  |L27.36|
000024  6820              LDR      r0,[r4,#0]            ;2151
000026  68c1              LDR      r1,[r0,#0xc]          ;2151
000028  f0210101          BIC      r1,r1,#1              ;2151
00002c  60c1              STR      r1,[r0,#0xc]          ;2151
00002e  6d20              LDR      r0,[r4,#0x50]         ;2155
000030  f8901025          LDRB     r1,[r0,#0x25]         ;2155
000034  2902              CMP      r1,#2                 ;2155
000036  d107              BNE      |L27.72|
000038  f7fffffe          BL       HAL_DMA_Abort
00003c  4605              MOV      r5,r0                 ;2157
00003e  b11d              CBZ      r5,|L27.72|
000040  6da0              LDR      r0,[r4,#0x58]         ;2163
000042  f0400040          ORR      r0,r0,#0x40           ;2163
000046  65a0              STR      r0,[r4,#0x58]         ;2163
                  |L27.72|
000048  6820              LDR      r0,[r4,#0]            ;2168
00004a  6841              LDR      r1,[r0,#4]            ;2168
00004c  f0210110          BIC      r1,r1,#0x10           ;2168
000050  6041              STR      r1,[r0,#4]            ;2168
000052  b125              CBZ      r5,|L27.94|
000054  4620              MOV      r0,r4                 ;2179
000056  f7fffffe          BL       ADC_Disable
                  |L27.90|
00005a  b12d              CBZ      r5,|L27.104|
00005c  e00a              B        |L27.116|
                  |L27.94|
00005e  4620              MOV      r0,r4                 ;2175
000060  f7fffffe          BL       ADC_Disable
000064  4605              MOV      r5,r0                 ;2175
000066  e7f8              B        |L27.90|
                  |L27.104|
000068  6da0              LDR      r0,[r4,#0x58]         ;2186
00006a  f4205088          BIC      r0,r0,#0x1100         ;2186
00006e  f0400001          ORR      r0,r0,#1              ;2186
000072  65a0              STR      r0,[r4,#0x58]         ;2186
                  |L27.116|
000074  2000              MOVS     r0,#0                 ;2194
000076  f8840054          STRB     r0,[r4,#0x54]         ;2194
00007a  4628              MOV      r0,r5                 ;2197
00007c  bd70              POP      {r4-r6,pc}
;;;2199   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_IT PROC
;;;1939     */
;;;1940   HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;1941   {
000002  4604              MOV      r4,r0
;;;1942     HAL_StatusTypeDef tmp_hal_status;
;;;1943   
;;;1944     /* Check the parameters */
;;;1945     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1946   
;;;1947     /* Process locked */
;;;1948     __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L28.30|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;1949   
;;;1950     /* 1. Stop potential conversion on going, on ADC groups regular and injected */
;;;1951     tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
000012  2103              MOVS     r1,#3
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  b110              CBZ      r0,|L28.34|
00001c  e010              B        |L28.64|
                  |L28.30|
00001e  2002              MOVS     r0,#2                 ;1948
;;;1952   
;;;1953     /* Disable ADC peripheral if conversions are effectively stopped */
;;;1954     if (tmp_hal_status == HAL_OK)
;;;1955     {
;;;1956       /* Disable ADC end of conversion interrupt for regular group */
;;;1957       /* Disable ADC overrun interrupt */
;;;1958       __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
;;;1959   
;;;1960       /* 2. Disable the ADC peripheral */
;;;1961       tmp_hal_status = ADC_Disable(hadc);
;;;1962   
;;;1963       /* Check if ADC is effectively disabled */
;;;1964       if (tmp_hal_status == HAL_OK)
;;;1965       {
;;;1966         /* Set ADC state */
;;;1967         ADC_STATE_CLR_SET(hadc->State,
;;;1968                           HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1969                           HAL_ADC_STATE_READY);
;;;1970       }
;;;1971     }
;;;1972   
;;;1973     /* Process unlocked */
;;;1974     __HAL_UNLOCK(hadc);
;;;1975   
;;;1976     /* Return function status */
;;;1977     return tmp_hal_status;
;;;1978   }
000020  bd10              POP      {r4,pc}
                  |L28.34|
000022  6820              LDR      r0,[r4,#0]            ;1958
000024  6841              LDR      r1,[r0,#4]            ;1958
000026  f021011c          BIC      r1,r1,#0x1c           ;1958
00002a  6041              STR      r1,[r0,#4]            ;1958
00002c  4620              MOV      r0,r4                 ;1961
00002e  f7fffffe          BL       ADC_Disable
000032  b928              CBNZ     r0,|L28.64|
000034  6da1              LDR      r1,[r4,#0x58]         ;1967
000036  f4215188          BIC      r1,r1,#0x1100         ;1967
00003a  f0410101          ORR      r1,r1,#1              ;1967
00003e  65a1              STR      r1,[r4,#0x58]         ;1967
                  |L28.64|
000040  2100              MOVS     r1,#0                 ;1974
000042  f8841054          STRB     r1,[r4,#0x54]         ;1974
000046  bd10              POP      {r4,pc}
;;;1979   
                          ENDP


                          AREA ||i.LL_ADC_ConfigAnalogWDThresholds||, CODE, READONLY, ALIGN=1

                  LL_ADC_ConfigAnalogWDThresholds PROC
;;;5318     */
;;;5319   __STATIC_INLINE void LL_ADC_ConfigAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdHighValue,
000000  f4011140          AND      r1,r1,#0x300000
;;;5320                                                        uint32_t AWDThresholdLowValue)
;;;5321   {
;;;5322     /* Set bits with content of parameter "AWDThresholdxxxValue" with bits      */
;;;5323     /* position in register and register position depending on parameter        */
;;;5324     /* "AWDy".                                                                  */
;;;5325     /* Parameters "AWDy" and "AWDThresholdxxxValue" are used with masks because */
;;;5326     /* containing other bits reserved for other purpose.                        */
;;;5327     __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1, ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));
000004  eb004091          ADD      r0,r0,r1,LSR #18
;;;5328   
;;;5329     MODIFY_REG(*preg,
000008  6a01              LDR      r1,[r0,#0x20]
00000a  ea434202          ORR      r2,r3,r2,LSL #16
00000e  f00121f0          AND      r1,r1,#0xf000f000
000012  4311              ORRS     r1,r1,r2
000014  6201              STR      r1,[r0,#0x20]
;;;5330                ADC_TR1_HT1 | ADC_TR1_LT1,
;;;5331                (AWDThresholdHighValue << ADC_TR1_HT1_BITOFFSET_POS) | AWDThresholdLowValue);
;;;5332   }
000016  4770              BX       lr
;;;5333   
                          ENDP


                          AREA ||i.LL_ADC_GetOffsetChannel||, CODE, READONLY, ALIGN=1

                  LL_ADC_GetOffsetChannel PROC
;;;3005     */
;;;3006   __STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;3007   {
;;;3008     const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
;;;3009   
;;;3010     return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
000004  6e00              LDR      r0,[r0,#0x60]
000006  f00040f8          AND      r0,r0,#0x7c000000
;;;3011   }
00000a  4770              BX       lr
;;;3012   
                          ENDP


                          AREA ||i.LL_ADC_INJ_IsConversionOngoing||, CODE, READONLY, ALIGN=1

                  LL_ADC_INJ_IsConversionOngoing PROC
;;;6350     */
;;;6351   __STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
000000  6880              LDR      r0,[r0,#8]
;;;6352   {
;;;6353     return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
000002  f3c000c0          UBFX     r0,r0,#3,#1
;;;6354   }
000006  4770              BX       lr
;;;6355   
                          ENDP


                          AREA ||i.LL_ADC_IsEnabled||, CODE, READONLY, ALIGN=1

                  LL_ADC_IsEnabled PROC
;;;6045     */
;;;6046   __STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
000000  6880              LDR      r0,[r0,#8]
;;;6047   {
;;;6048     return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
000002  f3c00000          UBFX     r0,r0,#0,#1
;;;6049   }
000006  4770              BX       lr
;;;6050   
                          ENDP


                          AREA ||i.LL_ADC_REG_IsConversionOngoing||, CODE, READONLY, ALIGN=1

                  LL_ADC_REG_IsConversionOngoing PROC
;;;6167     */
;;;6168   __STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
000000  6880              LDR      r0,[r0,#8]
;;;6169   {
;;;6170     return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
000002  f3c00080          UBFX     r0,r0,#2,#1
;;;6171   }
000006  4770              BX       lr
;;;6172   
                          ENDP


                          AREA ||i.LL_ADC_REG_IsTriggerSourceSWStart||, CODE, READONLY, ALIGN=1

                  LL_ADC_REG_IsTriggerSourceSWStart PROC
;;;3245     */
;;;3246   __STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart(ADC_TypeDef *ADCx)
000000  68c0              LDR      r0,[r0,#0xc]
;;;3247   {
;;;3248     return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
000002  f4106f40          TST      r0,#0xc00
000006  d001              BEQ      |L34.12|
000008  2000              MOVS     r0,#0
;;;3249   }
00000a  4770              BX       lr
                  |L34.12|
00000c  2001              MOVS     r0,#1                 ;3248
00000e  4770              BX       lr
;;;3250   
                          ENDP


                          AREA ||i.LL_ADC_SetAnalogWDMonitChannels||, CODE, READONLY, ALIGN=2

                  LL_ADC_SetAnalogWDMonitChannels PROC
;;;5074     */
;;;5075   __STATIC_INLINE void LL_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDChannelGroup)
000000  b510              PUSH     {r4,lr}
;;;5076   {
;;;5077     /* Set bits with content of parameter "AWDChannelGroup" with bits position  */
;;;5078     /* in register and register position depending on parameter "AWDy".         */
;;;5079     /* Parameters "AWDChannelGroup" and "AWDy" are used with masks because      */
;;;5080     /* containing other bits reserved for other purpose.                        */
;;;5081     __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR, ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
000002  f0010301          AND      r3,r1,#1
000006  eb0303c3          ADD      r3,r3,r3,LSL #3
00000a  f3c15401          UBFX     r4,r1,#20,#2
00000e  eb040383          ADD      r3,r4,r3,LSL #2
000012  eb000083          ADD      r0,r0,r3,LSL #2
;;;5082                                                + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK) * ADC_AWD_CR12_REGOFFSETGAP_VAL));
;;;5083   
;;;5084     MODIFY_REG(*preg,
000016  68c3              LDR      r3,[r0,#0xc]
000018  4c03              LDR      r4,|L35.40|
00001a  400a              ANDS     r2,r2,r1
00001c  400c              ANDS     r4,r4,r1
00001e  43a3              BICS     r3,r3,r4
000020  4313              ORRS     r3,r3,r2
000022  60c3              STR      r3,[r0,#0xc]
;;;5085                (AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK),
;;;5086                AWDChannelGroup & AWDy);
;;;5087   }
000024  bd10              POP      {r4,pc}
;;;5088   
                          ENDP

000026  0000              DCW      0x0000
                  |L35.40|
                          DCD      0x7dc7ffff

                          AREA ||i.LL_ADC_SetChannelSamplingTime||, CODE, READONLY, ALIGN=1

                  LL_ADC_SetChannelSamplingTime PROC
;;;4713     */
;;;4714   __STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
000000  b510              PUSH     {r4,lr}
;;;4715   {
;;;4716     /* Set bits with content of parameter "SamplingTime" with bits position     */
;;;4717     /* in register and register position depending on parameter "Channel".      */
;;;4718     /* Parameter "Channel" is used with masks because containing                */
;;;4719     /* other bits reserved for other purpose.                                   */
;;;4720     __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
000002  f0017300          AND      r3,r1,#0x2000000
000006  eb0050d3          ADD      r0,r0,r3,LSR #23
;;;4721   
;;;4722     MODIFY_REG(*preg,
00000a  6943              LDR      r3,[r0,#0x14]
00000c  f3c15104          UBFX     r1,r1,#20,#5
000010  2407              MOVS     r4,#7
000012  408c              LSLS     r4,r4,r1
000014  43a3              BICS     r3,r3,r4
000016  408a              LSLS     r2,r2,r1
000018  4313              ORRS     r3,r3,r2
00001a  6143              STR      r3,[r0,#0x14]
;;;4723                ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
;;;4724                SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
;;;4725   }
00001c  bd10              POP      {r4,pc}
;;;4726   
                          ENDP


                          AREA ||i.LL_ADC_SetOffsetState||, CODE, READONLY, ALIGN=1

                  LL_ADC_SetOffsetState PROC
;;;3064     */
;;;3065   __STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;3066   {
;;;3067     __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
;;;3068   
;;;3069     MODIFY_REG(*preg,
000004  6e01              LDR      r1,[r0,#0x60]
000006  f0214100          BIC      r1,r1,#0x80000000
00000a  4311              ORRS     r1,r1,r2
00000c  6601              STR      r1,[r0,#0x60]
;;;3070                ADC_OFR1_OFFSET1_EN,
;;;3071                OffsetState);
;;;3072   }
00000e  4770              BX       lr
;;;3073   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_adc_c_52ef8f50____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_adc_c_52ef8f50____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_adc_c_52ef8f50____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_adc_c_52ef8f50____RRX|
#line 694
|__asm___19_stm32l4xx_hal_adc_c_52ef8f50____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
