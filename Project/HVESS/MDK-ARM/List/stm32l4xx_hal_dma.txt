; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_dma.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_dma.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1067     */
;;;1068   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1069   {
;;;1070   #if defined(DMAMUX1)
;;;1071     /* Clear the DMAMUX synchro overrun flag */
;;;1072     hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;1073   
;;;1074     if(hdma->DMAmuxRequestGen != 0U)
;;;1075     {
;;;1076       /* Clear the DMAMUX request generator overrun flag */
;;;1077       hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;1078     }
;;;1079   #endif
;;;1080   
;;;1081     /* Clear all flags */
;;;1082     hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
000002  f8904044          LDRB     r4,[r0,#0x44]
000006  f004051c          AND      r5,r4,#0x1c
00000a  2401              MOVS     r4,#1
00000c  40ac              LSLS     r4,r4,r5
00000e  6c05              LDR      r5,[r0,#0x40]
000010  606c              STR      r4,[r5,#4]
;;;1083   
;;;1084     /* Configure DMA Channel data length */
;;;1085     hdma->Instance->CNDTR = DataLength;
000012  6804              LDR      r4,[r0,#0]
000014  6063              STR      r3,[r4,#4]
;;;1086   
;;;1087     /* Memory to Peripheral */
;;;1088     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000016  6883              LDR      r3,[r0,#8]
000018  2b10              CMP      r3,#0x10
00001a  d004              BEQ      |L1.38|
;;;1089     {
;;;1090       /* Configure DMA Channel destination address */
;;;1091       hdma->Instance->CPAR = DstAddress;
;;;1092   
;;;1093       /* Configure DMA Channel source address */
;;;1094       hdma->Instance->CMAR = SrcAddress;
;;;1095     }
;;;1096     /* Peripheral to Memory */
;;;1097     else
;;;1098     {
;;;1099       /* Configure DMA Channel source address */
;;;1100       hdma->Instance->CPAR = SrcAddress;
00001c  6803              LDR      r3,[r0,#0]
00001e  6099              STR      r1,[r3,#8]
;;;1101   
;;;1102       /* Configure DMA Channel destination address */
;;;1103       hdma->Instance->CMAR = DstAddress;
000020  6800              LDR      r0,[r0,#0]
000022  60c2              STR      r2,[r0,#0xc]
;;;1104     }
;;;1105   }
000024  bd30              POP      {r4,r5,pc}
                  |L1.38|
000026  6803              LDR      r3,[r0,#0]            ;1091
000028  609a              STR      r2,[r3,#8]            ;1091
00002a  6800              LDR      r0,[r0,#0]            ;1094
00002c  60c1              STR      r1,[r0,#0xc]          ;1094
00002e  bd30              POP      {r4,r5,pc}
;;;1106   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;545      */
;;;546    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;547    {
;;;548      HAL_StatusTypeDef status = HAL_OK;
;;;549    
;;;550      /* Check the DMA peripheral state */
;;;551      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  f8901025          LDRB     r1,[r0,#0x25]
000006  2300              MOVS     r3,#0
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L2.24|
;;;552      {
;;;553        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000c  2104              MOVS     r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;554    
;;;555        /* Process Unlocked */
;;;556        __HAL_UNLOCK(hdma);
000010  f8803024          STRB     r3,[r0,#0x24]
;;;557    
;;;558        return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;559      }
;;;560      else
;;;561      {
;;;562        /* Disable DMA IT */
;;;563        __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
;;;564    
;;;565    #if defined(DMAMUX1)
;;;566        /* disable the DMAMUX sync overrun IT*/
;;;567        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
;;;568    #endif /* DMAMUX1 */
;;;569    
;;;570        /* Disable the channel */
;;;571        __HAL_DMA_DISABLE(hdma);
;;;572    
;;;573        /* Clear all flags */
;;;574        hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
;;;575    
;;;576    #if defined(DMAMUX1)
;;;577        /* Clear the DMAMUX synchro overrun flag */
;;;578        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;579    
;;;580        if(hdma->DMAmuxRequestGen != 0U)
;;;581        {
;;;582          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
;;;583          /* disable the request gen overrun IT*/
;;;584          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
;;;585    
;;;586          /* Clear the DMAMUX request generator overrun flag */
;;;587          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;588        }
;;;589    
;;;590    #endif /* DMAMUX1 */
;;;591    
;;;592        /* Change the DMA state */
;;;593        hdma->State = HAL_DMA_STATE_READY;
;;;594    
;;;595        /* Process Unlocked */
;;;596        __HAL_UNLOCK(hdma);
;;;597    
;;;598        return status;
;;;599      }
;;;600    }
000016  bd10              POP      {r4,pc}
                  |L2.24|
000018  6801              LDR      r1,[r0,#0]            ;563
00001a  680a              LDR      r2,[r1,#0]            ;563
00001c  f022020e          BIC      r2,r2,#0xe            ;563
000020  600a              STR      r2,[r1,#0]            ;563
000022  6801              LDR      r1,[r0,#0]            ;571
000024  680a              LDR      r2,[r1,#0]            ;571
000026  f0220201          BIC      r2,r2,#1              ;571
00002a  600a              STR      r2,[r1,#0]            ;571
00002c  f8901044          LDRB     r1,[r0,#0x44]         ;574
000030  2201              MOVS     r2,#1                 ;574
000032  f001041c          AND      r4,r1,#0x1c           ;574
000036  fa02f104          LSL      r1,r2,r4              ;574
00003a  6c04              LDR      r4,[r0,#0x40]         ;574
00003c  6061              STR      r1,[r4,#4]            ;574
00003e  f8802025          STRB     r2,[r0,#0x25]         ;593
000042  f8803024          STRB     r3,[r0,#0x24]         ;596
000046  4618              MOV      r0,r3                 ;598
000048  bd10              POP      {r4,pc}
;;;601    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;607      */
;;;608    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;609    {
;;;610      HAL_StatusTypeDef status = HAL_OK;
000002  2400              MOVS     r4,#0
;;;611    
;;;612      if(HAL_DMA_STATE_BUSY != hdma->State)
000004  f8901025          LDRB     r1,[r0,#0x25]
000008  2902              CMP      r1,#2
00000a  d003              BEQ      |L3.20|
;;;613      {
;;;614        /* no transfer ongoing */
;;;615        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000c  2104              MOVS     r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;616    
;;;617        status = HAL_ERROR;
000010  2401              MOVS     r4,#1
000012  e01a              B        |L3.74|
                  |L3.20|
;;;618      }
;;;619      else
;;;620      {
;;;621        /* Disable DMA IT */
;;;622        __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  f022020e          BIC      r2,r2,#0xe
00001c  600a              STR      r2,[r1,#0]
;;;623    
;;;624        /* Disable the channel */
;;;625        __HAL_DMA_DISABLE(hdma);
00001e  6801              LDR      r1,[r0,#0]
000020  680a              LDR      r2,[r1,#0]
000022  f0220201          BIC      r2,r2,#1
000026  600a              STR      r2,[r1,#0]
;;;626    
;;;627    #if defined(DMAMUX1)
;;;628        /* disable the DMAMUX sync overrun IT*/
;;;629        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
;;;630    
;;;631        /* Clear all flags */
;;;632        hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
;;;633    
;;;634        /* Clear the DMAMUX synchro overrun flag */
;;;635        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;636    
;;;637        if(hdma->DMAmuxRequestGen != 0U)
;;;638        {
;;;639          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
;;;640          /* disable the request gen overrun IT*/
;;;641          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
;;;642    
;;;643          /* Clear the DMAMUX request generator overrun flag */
;;;644          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;645        }
;;;646    
;;;647    #else
;;;648        /* Clear all flags */
;;;649        hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
000028  f8901044          LDRB     r1,[r0,#0x44]
00002c  2301              MOVS     r3,#1
00002e  f001021c          AND      r2,r1,#0x1c
000032  fa03f102          LSL      r1,r3,r2
000036  6c02              LDR      r2,[r0,#0x40]
000038  6051              STR      r1,[r2,#4]
;;;650    #endif /* DMAMUX1 */
;;;651    
;;;652        /* Change the DMA state */
;;;653        hdma->State = HAL_DMA_STATE_READY;
00003a  f8803025          STRB     r3,[r0,#0x25]
;;;654    
;;;655        /* Process Unlocked */
;;;656        __HAL_UNLOCK(hdma);
00003e  2100              MOVS     r1,#0
000040  f8801024          STRB     r1,[r0,#0x24]
;;;657    
;;;658        /* Call User Abort callback */
;;;659        if(hdma->XferAbortCallback != NULL)
000044  6b81              LDR      r1,[r0,#0x38]
000046  b101              CBZ      r1,|L3.74|
;;;660        {
;;;661          hdma->XferAbortCallback(hdma);
000048  4788              BLX      r1
                  |L3.74|
;;;662        }
;;;663      }
;;;664      return status;
00004a  4620              MOV      r0,r4
;;;665    }
00004c  bd10              POP      {r4,pc}
;;;666    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DMA_DeInit PROC
;;;293      */
;;;294    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b530              PUSH     {r4,r5,lr}
;;;295    {
;;;296    
;;;297      /* Check the DMA handle allocation */
;;;298      if (NULL == hdma )
000002  2800              CMP      r0,#0
000004  d012              BEQ      |L4.44|
;;;299      {
;;;300        return HAL_ERROR;
;;;301      }
;;;302    
;;;303      /* Check the parameters */
;;;304      assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
;;;305    
;;;306      /* Disable the selected DMA Channelx */
;;;307      __HAL_DMA_DISABLE(hdma);
000006  6801              LDR      r1,[r0,#0]
000008  680a              LDR      r2,[r1,#0]
00000a  f0220201          BIC      r2,r2,#1
00000e  600a              STR      r2,[r1,#0]
;;;308    
;;;309      /* Compute the channel index */
;;;310      if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
000010  4c22              LDR      r4,|L4.156|
000012  6802              LDR      r2,[r0,#0]
;;;311      {
;;;312        /* DMA1 */
;;;313        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
000014  2114              MOVS     r1,#0x14
;;;314        hdma->DmaBaseAddress = DMA1;
000016  4b22              LDR      r3,|L4.160|
000018  42a2              CMP      r2,r4                 ;310
00001a  d209              BCS      |L4.48|
00001c  4c21              LDR      r4,|L4.164|
00001e  4414              ADD      r4,r4,r2              ;313
000020  fbb4f1f1          UDIV     r1,r4,r1              ;313
000024  0089              LSLS     r1,r1,#2              ;313
000026  6441              STR      r1,[r0,#0x44]         ;313
000028  6403              STR      r3,[r0,#0x40]
00002a  e00b              B        |L4.68|
                  |L4.44|
00002c  2001              MOVS     r0,#1                 ;300
;;;315      }
;;;316      else
;;;317      {
;;;318        /* DMA2 */
;;;319        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
;;;320        hdma->DmaBaseAddress = DMA2;
;;;321      }
;;;322    
;;;323      /* Reset DMA Channel control register */
;;;324      hdma->Instance->CCR = 0U;
;;;325    
;;;326      /* Clear all flags */
;;;327      hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
;;;328    
;;;329    #if !defined (DMAMUX1)
;;;330    
;;;331      /* Reset DMA channel selection register */
;;;332      if (DMA1 == hdma->DmaBaseAddress)
;;;333      {
;;;334        /* DMA1 */
;;;335        DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;336      }
;;;337      else
;;;338      {
;;;339        /* DMA2 */
;;;340        DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;341      }
;;;342    #endif /* STM32L431xx || STM32L432xx || STM32L433xx || STM32L442xx || STM32L443xx */
;;;343           /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L442xx || STM32L486xx */
;;;344           /* STM32L496xx || STM32L4A6xx                                              */
;;;345    
;;;346    #if defined(DMAMUX1)
;;;347    
;;;348      /* Initialize parameters for DMAMUX channel :
;;;349         DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
;;;350    
;;;351      DMA_CalcDMAMUXChannelBaseAndMask(hdma);
;;;352    
;;;353      /* Reset the DMAMUX channel that corresponds to the DMA channel */
;;;354      hdma->DMAmuxChannel->CCR = 0U;
;;;355    
;;;356      /* Clear the DMAMUX synchro overrun flag */
;;;357      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;358    
;;;359      /* Reset Request generator parameters if any */
;;;360      if(((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
;;;361      {
;;;362        /* Initialize parameters for DMAMUX request generator :
;;;363           DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
;;;364        */
;;;365        DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
;;;366    
;;;367        /* Reset the DMAMUX request generator register*/
;;;368        hdma->DMAmuxRequestGen->RGCR = 0U;
;;;369    
;;;370        /* Clear the DMAMUX request generator overrun flag */
;;;371        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;372      }
;;;373    
;;;374      hdma->DMAmuxRequestGen = 0U;
;;;375      hdma->DMAmuxRequestGenStatus = 0U;
;;;376      hdma->DMAmuxRequestGenStatusMask = 0U;
;;;377    
;;;378    #endif /* DMAMUX1 */
;;;379    
;;;380      /* Clean callbacks */
;;;381      hdma->XferCpltCallback = NULL;
;;;382      hdma->XferHalfCpltCallback = NULL;
;;;383      hdma->XferErrorCallback = NULL;
;;;384      hdma->XferAbortCallback = NULL;
;;;385    
;;;386      /* Initialise the error code */
;;;387      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;388    
;;;389      /* Initialize the DMA state */
;;;390      hdma->State = HAL_DMA_STATE_RESET;
;;;391    
;;;392      /* Release Lock */
;;;393      __HAL_UNLOCK(hdma);
;;;394    
;;;395      return HAL_OK;
;;;396    }
00002e  bd30              POP      {r4,r5,pc}
                  |L4.48|
000030  4c1a              LDR      r4,|L4.156|
000032  4264              RSBS     r4,r4,#0              ;319
000034  4414              ADD      r4,r4,r2              ;319
000036  fbb4f1f1          UDIV     r1,r4,r1              ;319
00003a  0089              LSLS     r1,r1,#2              ;319
00003c  6441              STR      r1,[r0,#0x44]         ;319
00003e  4917              LDR      r1,|L4.156|
000040  3908              SUBS     r1,r1,#8              ;320
000042  6401              STR      r1,[r0,#0x40]         ;320
                  |L4.68|
000044  2100              MOVS     r1,#0                 ;324
000046  6011              STR      r1,[r2,#0]            ;324
000048  f8902044          LDRB     r2,[r0,#0x44]         ;327
00004c  f002041c          AND      r4,r2,#0x1c           ;327
000050  2201              MOVS     r2,#1                 ;327
000052  40a2              LSLS     r2,r2,r4              ;327
000054  6c04              LDR      r4,[r0,#0x40]         ;327
000056  6062              STR      r2,[r4,#4]            ;327
000058  6c04              LDR      r4,[r0,#0x40]         ;332
00005a  220f              MOVS     r2,#0xf               ;335
00005c  429c              CMP      r4,r3                 ;332
00005e  d109              BNE      |L4.116|
000060  f8534fa8          LDR      r4,[r3,#0xa8]!        ;335
000064  f8905044          LDRB     r5,[r0,#0x44]         ;335
000068  f005051c          AND      r5,r5,#0x1c           ;335
00006c  40aa              LSLS     r2,r2,r5              ;335
00006e  4394              BICS     r4,r4,r2              ;335
000070  601c              STR      r4,[r3,#0]            ;335
000072  e009              B        |L4.136|
                  |L4.116|
000074  4b09              LDR      r3,|L4.156|
000076  33a0              ADDS     r3,r3,#0xa0           ;340
000078  681c              LDR      r4,[r3,#0]            ;340
00007a  f8905044          LDRB     r5,[r0,#0x44]         ;340
00007e  f005051c          AND      r5,r5,#0x1c           ;340
000082  40aa              LSLS     r2,r2,r5              ;340
000084  4394              BICS     r4,r4,r2              ;340
000086  601c              STR      r4,[r3,#0]            ;340
                  |L4.136|
000088  3024              ADDS     r0,r0,#0x24           ;381
00008a  6081              STR      r1,[r0,#8]            ;381
00008c  60c1              STR      r1,[r0,#0xc]          ;382
00008e  6101              STR      r1,[r0,#0x10]         ;383
000090  6141              STR      r1,[r0,#0x14]         ;384
000092  6181              STR      r1,[r0,#0x18]         ;387
000094  7041              STRB     r1,[r0,#1]            ;390
000096  7001              STRB     r1,[r0,#0]            ;393
000098  2000              MOVS     r0,#0                 ;395
00009a  bd30              POP      {r4,r5,pc}
;;;397    
                          ENDP

                  |L4.156|
                          DCD      0x40020408
                  |L4.160|
                          DCD      0x40020000
                  |L4.164|
                          DCD      0xbffdfff8

                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1041     */
;;;1042   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;1043   {
;;;1044     return hdma->ErrorCode;
;;;1045   }
000002  4770              BX       lr
;;;1046   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1029     */
;;;1030   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  f8900025          LDRB     r0,[r0,#0x25]
;;;1031   {
;;;1032     /* Return DMA handle state */
;;;1033     return hdma->State;
;;;1034   }
000004  4770              BX       lr
;;;1035   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_DMA_IRQHandler PROC
;;;804      */
;;;805    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b4f0              PUSH     {r4-r7}
;;;806    {
;;;807      uint32_t flag_it = hdma->DmaBaseAddress->ISR;
000002  6c01              LDR      r1,[r0,#0x40]
000004  680a              LDR      r2,[r1,#0]
;;;808      uint32_t source_it = hdma->Instance->CCR;
000006  6801              LDR      r1,[r0,#0]
000008  680b              LDR      r3,[r1,#0]
;;;809    
;;;810      /* Half Transfer Complete Interrupt management ******************************/
;;;811      if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
00000a  f8904044          LDRB     r4,[r0,#0x44]
00000e  2604              MOVS     r6,#4
000010  f004041c          AND      r4,r4,#0x1c
000014  fa06f504          LSL      r5,r6,r4
000018  4215              TST      r5,r2
00001a  d015              BEQ      |L7.72|
00001c  075d              LSLS     r5,r3,#29
00001e  d513              BPL      |L7.72|
;;;812      {
;;;813          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;814          if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000020  680a              LDR      r2,[r1,#0]
000022  0692              LSLS     r2,r2,#26
000024  d403              BMI      |L7.46|
;;;815          {
;;;816            /* Disable the half transfer interrupt */
;;;817            __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
000026  680a              LDR      r2,[r1,#0]
000028  f0220204          BIC      r2,r2,#4
00002c  600a              STR      r2,[r1,#0]
                  |L7.46|
;;;818          }
;;;819          /* Clear the half transfer complete flag */
;;;820          hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
00002e  f8901044          LDRB     r1,[r0,#0x44]
000032  f001011c          AND      r1,r1,#0x1c
000036  fa06f501          LSL      r5,r6,r1
00003a  6c01              LDR      r1,[r0,#0x40]
00003c  604d              STR      r5,[r1,#4]
;;;821    
;;;822          /* DMA peripheral state is not updated in Half Transfer */
;;;823          /* but in Transfer Complete case */
;;;824    
;;;825          if(hdma->XferHalfCpltCallback != NULL)
00003e  6b01              LDR      r1,[r0,#0x30]
000040  2900              CMP      r1,#0
000042  d041              BEQ      |L7.200|
;;;826          {
;;;827            /* Half transfer callback */
;;;828            hdma->XferHalfCpltCallback(hdma);
000044  bcf0              POP      {r4-r7}
000046  4708              BX       r1
                  |L7.72|
;;;829          }
;;;830      }
;;;831    
;;;832      /* Transfer Complete Interrupt management ***********************************/
;;;833      else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
000048  f04f0c02          MOV      r12,#2
00004c  fa0cf604          LSL      r6,r12,r4
000050  4216              TST      r6,r2
000052  f04f0700          MOV      r7,#0
;;;834      {
;;;835        if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
;;;836        {
;;;837          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;838          /* Disable the transfer complete and error interrupt */
;;;839          /* if the DMA mode is not CIRCULAR  */
;;;840          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
;;;841    
;;;842          /* Change the DMA state */
;;;843          hdma->State = HAL_DMA_STATE_READY;
000056  f04f0501          MOV      r5,#1
00005a  d019              BEQ      |L7.144|
00005c  079e              LSLS     r6,r3,#30             ;833
00005e  d517              BPL      |L7.144|
000060  680a              LDR      r2,[r1,#0]            ;835
000062  0692              LSLS     r2,r2,#26             ;835
000064  d405              BMI      |L7.114|
000066  680a              LDR      r2,[r1,#0]            ;840
000068  f022020a          BIC      r2,r2,#0xa            ;840
00006c  600a              STR      r2,[r1,#0]            ;840
00006e  f8805025          STRB     r5,[r0,#0x25]
                  |L7.114|
;;;844        }
;;;845        /* Clear the transfer complete flag */
;;;846        hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1CU));
000072  f8901044          LDRB     r1,[r0,#0x44]
000076  f001011c          AND      r1,r1,#0x1c
00007a  fa0cf601          LSL      r6,r12,r1
00007e  6c01              LDR      r1,[r0,#0x40]
000080  604e              STR      r6,[r1,#4]
;;;847    
;;;848        /* Process Unlocked */
;;;849        __HAL_UNLOCK(hdma);
000082  f8807024          STRB     r7,[r0,#0x24]
;;;850    
;;;851        if(hdma->XferCpltCallback != NULL)
000086  6ac1              LDR      r1,[r0,#0x2c]
000088  2900              CMP      r1,#0
00008a  d01d              BEQ      |L7.200|
;;;852        {
;;;853          /* Transfer complete callback */
;;;854          hdma->XferCpltCallback(hdma);
00008c  bcf0              POP      {r4-r7}
00008e  4708              BX       r1
                  |L7.144|
;;;855        }
;;;856      }
;;;857    
;;;858      /* Transfer Error Interrupt management **************************************/
;;;859      else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) !=  0U))
000090  2608              MOVS     r6,#8
000092  40a6              LSLS     r6,r6,r4
000094  4216              TST      r6,r2
000096  d017              BEQ      |L7.200|
000098  071a              LSLS     r2,r3,#28
00009a  d515              BPL      |L7.200|
;;;860      {
;;;861        /* When a DMA transfer error occurs */
;;;862        /* A hardware clear of its EN bits is performed */
;;;863        /* Disable ALL DMA IT */
;;;864        __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
00009c  680a              LDR      r2,[r1,#0]
00009e  f022020e          BIC      r2,r2,#0xe
0000a2  600a              STR      r2,[r1,#0]
;;;865    
;;;866        /* Clear all flags */
;;;867        hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
0000a4  f8901044          LDRB     r1,[r0,#0x44]
0000a8  6c02              LDR      r2,[r0,#0x40]
0000aa  f001011c          AND      r1,r1,#0x1c
0000ae  fa05f101          LSL      r1,r5,r1
0000b2  6051              STR      r1,[r2,#4]
;;;868    
;;;869        /* Update error code */
;;;870        hdma->ErrorCode = HAL_DMA_ERROR_TE;
0000b4  63c5              STR      r5,[r0,#0x3c]
;;;871    
;;;872        /* Change the DMA state */
;;;873        hdma->State = HAL_DMA_STATE_READY;
0000b6  f8805025          STRB     r5,[r0,#0x25]
;;;874    
;;;875        /* Process Unlocked */
;;;876        __HAL_UNLOCK(hdma);
0000ba  f8807024          STRB     r7,[r0,#0x24]
;;;877    
;;;878        if (hdma->XferErrorCallback != NULL)
0000be  6b41              LDR      r1,[r0,#0x34]
0000c0  2900              CMP      r1,#0
0000c2  d001              BEQ      |L7.200|
;;;879        {
;;;880          /* Transfer error callback */
;;;881          hdma->XferErrorCallback(hdma);
0000c4  bcf0              POP      {r4-r7}
0000c6  4708              BX       r1
                  |L7.200|
;;;882        }
;;;883      }
;;;884      else
;;;885      {
;;;886        /* Nothing To Do */
;;;887      }
;;;888      return;
;;;889    }
0000c8  bcf0              POP      {r4-r7}
0000ca  4770              BX       lr
;;;890    
                          ENDP


                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;152      */
;;;153    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;154    {
;;;155      uint32_t tmp;
;;;156    
;;;157      /* Check the DMA handle allocation */
;;;158      if(hdma == NULL)
000002  2800              CMP      r0,#0
000004  d00d              BEQ      |L8.34|
;;;159      {
;;;160        return HAL_ERROR;
;;;161      }
;;;162    
;;;163      /* Check the parameters */
;;;164      assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
;;;165      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;166      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;167      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;168      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;169      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;170      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;171      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;172    
;;;173      assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));
;;;174    
;;;175      /* Compute the channel index */
;;;176      if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
000006  4c33              LDR      r4,|L8.212|
000008  6801              LDR      r1,[r0,#0]
;;;177      {
;;;178        /* DMA1 */
;;;179        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
00000a  2314              MOVS     r3,#0x14
;;;180        hdma->DmaBaseAddress = DMA1;
00000c  4a32              LDR      r2,|L8.216|
00000e  42a1              CMP      r1,r4                 ;176
000010  d209              BCS      |L8.38|
000012  4c32              LDR      r4,|L8.220|
000014  440c              ADD      r4,r4,r1              ;179
000016  fbb4f3f3          UDIV     r3,r4,r3              ;179
00001a  009b              LSLS     r3,r3,#2              ;179
00001c  6443              STR      r3,[r0,#0x44]         ;179
00001e  6402              STR      r2,[r0,#0x40]
000020  e00b              B        |L8.58|
                  |L8.34|
000022  2001              MOVS     r0,#1                 ;160
;;;181      }
;;;182      else
;;;183      {
;;;184        /* DMA2 */
;;;185        hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
;;;186        hdma->DmaBaseAddress = DMA2;
;;;187      }
;;;188    
;;;189      /* Change DMA peripheral state */
;;;190      hdma->State = HAL_DMA_STATE_BUSY;
;;;191    
;;;192      /* Get the CR register value */
;;;193      tmp = hdma->Instance->CCR;
;;;194    
;;;195      /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
;;;196      tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
;;;197                          DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
;;;198                          DMA_CCR_DIR   | DMA_CCR_MEM2MEM));
;;;199    
;;;200      /* Prepare the DMA Channel configuration */
;;;201      tmp |=  hdma->Init.Direction        |
;;;202              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;203              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;204              hdma->Init.Mode                | hdma->Init.Priority;
;;;205    
;;;206      /* Write to DMA Channel CR register */
;;;207      hdma->Instance->CCR = tmp;
;;;208    
;;;209    #if defined(DMAMUX1)
;;;210      /* Initialize parameters for DMAMUX channel :
;;;211         DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
;;;212      */
;;;213      DMA_CalcDMAMUXChannelBaseAndMask(hdma);
;;;214    
;;;215      if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
;;;216      {
;;;217        /* if memory to memory force the request to 0*/
;;;218        hdma->Init.Request = DMA_REQUEST_MEM2MEM;
;;;219      }
;;;220    
;;;221      /* Set peripheral request  to DMAMUX channel */
;;;222      hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
;;;223    
;;;224      /* Clear the DMAMUX synchro overrun flag */
;;;225      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;226    
;;;227      if(((hdma->Init.Request > 0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
;;;228      {
;;;229        /* Initialize parameters for DMAMUX request generator :
;;;230           DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
;;;231        */
;;;232        DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
;;;233    
;;;234        /* Reset the DMAMUX request generator register*/
;;;235        hdma->DMAmuxRequestGen->RGCR = 0U;
;;;236    
;;;237        /* Clear the DMAMUX request generator overrun flag */
;;;238        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;239      }
;;;240      else
;;;241      {
;;;242        hdma->DMAmuxRequestGen = 0U;
;;;243        hdma->DMAmuxRequestGenStatus = 0U;
;;;244        hdma->DMAmuxRequestGenStatusMask = 0U;
;;;245      }
;;;246    #endif /* DMAMUX1 */
;;;247    
;;;248    #if !defined (DMAMUX1)
;;;249    
;;;250      /* Set request selection */
;;;251      if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
;;;252      {
;;;253        /* Write to DMA channel selection register */
;;;254        if (DMA1 == hdma->DmaBaseAddress)
;;;255        {
;;;256          /* Reset request selection for DMA1 Channelx */
;;;257          DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;258    
;;;259          /* Configure request selection for DMA1 Channelx */
;;;260          DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
;;;261        }
;;;262        else /* DMA2 */
;;;263        {
;;;264          /* Reset request selection for DMA2 Channelx */
;;;265          DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
;;;266    
;;;267          /* Configure request selection for DMA2 Channelx */
;;;268          DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
;;;269        }
;;;270      }
;;;271    
;;;272    #endif /* STM32L431xx || STM32L432xx || STM32L433xx || STM32L442xx || STM32L443xx */
;;;273           /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L442xx || STM32L486xx */
;;;274           /* STM32L496xx || STM32L4A6xx                                              */
;;;275    
;;;276      /* Initialise the error code */
;;;277      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;278    
;;;279      /* Initialize the DMA state*/
;;;280      hdma->State = HAL_DMA_STATE_READY;
;;;281    
;;;282      /* Allocate lock resource and initialize it */
;;;283      hdma->Lock = HAL_UNLOCKED;
;;;284    
;;;285      return HAL_OK;
;;;286    }
000024  bd70              POP      {r4-r6,pc}
                  |L8.38|
000026  4c2b              LDR      r4,|L8.212|
000028  4264              RSBS     r4,r4,#0              ;185
00002a  440c              ADD      r4,r4,r1              ;185
00002c  fbb4f3f3          UDIV     r3,r4,r3              ;185
000030  009b              LSLS     r3,r3,#2              ;185
000032  6443              STR      r3,[r0,#0x44]         ;185
000034  4b27              LDR      r3,|L8.212|
000036  3b08              SUBS     r3,r3,#8              ;186
000038  6403              STR      r3,[r0,#0x40]         ;186
                  |L8.58|
00003a  2302              MOVS     r3,#2                 ;190
00003c  f8803025          STRB     r3,[r0,#0x25]         ;190
000040  680b              LDR      r3,[r1,#0]            ;193
000042  f64774f0          MOV      r4,#0x7ff0            ;196
000046  43a3              BICS     r3,r3,r4              ;196
000048  e9d04502          LDRD     r4,r5,[r0,#8]         ;201
00004c  432c              ORRS     r4,r4,r5              ;201
00004e  e9d05604          LDRD     r5,r6,[r0,#0x10]      ;201
000052  4335              ORRS     r5,r5,r6              ;201
000054  432c              ORRS     r4,r4,r5              ;201
000056  6985              LDR      r5,[r0,#0x18]         ;201
000058  432c              ORRS     r4,r4,r5              ;201
00005a  69c5              LDR      r5,[r0,#0x1c]         ;201
00005c  432c              ORRS     r4,r4,r5              ;201
00005e  6a05              LDR      r5,[r0,#0x20]         ;201
000060  432c              ORRS     r4,r4,r5              ;201
000062  431c              ORRS     r4,r4,r3              ;201
000064  600c              STR      r4,[r1,#0]            ;207
000066  6881              LDR      r1,[r0,#8]            ;251
000068  f5b14f80          CMP      r1,#0x4000            ;251
00006c  d029              BEQ      |L8.194|
00006e  6c01              LDR      r1,[r0,#0x40]         ;254
000070  230f              MOVS     r3,#0xf               ;257
000072  4291              CMP      r1,r2                 ;254
000074  d112              BNE      |L8.156|
000076  f8521fa8          LDR      r1,[r2,#0xa8]!        ;257
00007a  f8904044          LDRB     r4,[r0,#0x44]         ;257
00007e  f004041c          AND      r4,r4,#0x1c           ;257
000082  40a3              LSLS     r3,r3,r4              ;257
000084  4399              BICS     r1,r1,r3              ;257
000086  6011              STR      r1,[r2,#0]            ;257
000088  f8903044          LDRB     r3,[r0,#0x44]         ;260
00008c  6841              LDR      r1,[r0,#4]            ;260
00008e  f003031c          AND      r3,r3,#0x1c           ;260
000092  4099              LSLS     r1,r1,r3              ;260
000094  6813              LDR      r3,[r2,#0]            ;260
000096  4319              ORRS     r1,r1,r3              ;260
000098  6011              STR      r1,[r2,#0]            ;260
00009a  e012              B        |L8.194|
                  |L8.156|
00009c  490d              LDR      r1,|L8.212|
00009e  31a0              ADDS     r1,r1,#0xa0           ;265
0000a0  680a              LDR      r2,[r1,#0]            ;265
0000a2  f8904044          LDRB     r4,[r0,#0x44]         ;265
0000a6  f004041c          AND      r4,r4,#0x1c           ;265
0000aa  40a3              LSLS     r3,r3,r4              ;265
0000ac  439a              BICS     r2,r2,r3              ;265
0000ae  600a              STR      r2,[r1,#0]            ;265
0000b0  f8903044          LDRB     r3,[r0,#0x44]         ;268
0000b4  6842              LDR      r2,[r0,#4]            ;268
0000b6  f003031c          AND      r3,r3,#0x1c           ;268
0000ba  409a              LSLS     r2,r2,r3              ;268
0000bc  680b              LDR      r3,[r1,#0]            ;268
0000be  431a              ORRS     r2,r2,r3              ;268
0000c0  600a              STR      r2,[r1,#0]            ;268
                  |L8.194|
0000c2  2100              MOVS     r1,#0                 ;277
0000c4  3024              ADDS     r0,r0,#0x24           ;277
0000c6  6181              STR      r1,[r0,#0x18]         ;277
0000c8  2201              MOVS     r2,#1                 ;280
0000ca  7042              STRB     r2,[r0,#1]            ;280
0000cc  7001              STRB     r1,[r0,#0]            ;283
0000ce  2000              MOVS     r0,#0                 ;285
0000d0  bd70              POP      {r4-r6,pc}
;;;287    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L8.212|
                          DCD      0x40020408
                  |L8.216|
                          DCD      0x40020000
                  |L8.220|
                          DCD      0xbffdfff8

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA_PollForTransfer PROC
;;;674      */
;;;675    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;676    {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
;;;677      uint32_t temp;
;;;678      uint32_t tickstart;
;;;679    
;;;680      if(HAL_DMA_STATE_BUSY != hdma->State)
00000a  f8940025          LDRB     r0,[r4,#0x25]
00000e  f04f0800          MOV      r8,#0
;;;681      {
;;;682        /* no transfer ongoing */
;;;683        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000012  f04f0a04          MOV      r10,#4
000016  2802              CMP      r0,#2                 ;680
000018  d006              BEQ      |L9.40|
00001a  f8c4a03c          STR      r10,[r4,#0x3c]
;;;684        __HAL_UNLOCK(hdma);
00001e  f8848024          STRB     r8,[r4,#0x24]
;;;685        return HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L9.36|
;;;686      }
;;;687    
;;;688      /* Polling mode not supported in circular mode */
;;;689      if ((hdma->Instance->CCR & DMA_CCR_CIRC) != 0U)
;;;690      {
;;;691        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;692        return HAL_ERROR;
;;;693      }
;;;694    
;;;695      /* Get the level transfer complete flag */
;;;696      if (HAL_DMA_FULL_TRANSFER == CompleteLevel)
;;;697      {
;;;698        /* Transfer Complete flag */
;;;699        temp = DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU);
;;;700      }
;;;701      else
;;;702      {
;;;703        /* Half Transfer Complete flag */
;;;704        temp = DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU);
;;;705      }
;;;706    
;;;707      /* Get tick */
;;;708      tickstart = HAL_GetTick();
;;;709    
;;;710      while((hdma->DmaBaseAddress->ISR & temp) == 0U)
;;;711      {
;;;712        if((hdma->DmaBaseAddress->ISR & (DMA_FLAG_TE1 << (hdma->ChannelIndex& 0x1CU))) != 0U)
;;;713        {
;;;714          /* When a DMA transfer error occurs */
;;;715          /* A hardware clear of its EN bits is performed */
;;;716          /* Clear all flags */
;;;717          hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
;;;718    
;;;719          /* Update error code */
;;;720          hdma->ErrorCode = HAL_DMA_ERROR_TE;
;;;721    
;;;722          /* Change the DMA state */
;;;723          hdma->State= HAL_DMA_STATE_READY;
;;;724    
;;;725          /* Process Unlocked */
;;;726          __HAL_UNLOCK(hdma);
;;;727    
;;;728          return HAL_ERROR;
;;;729        }
;;;730        /* Check for the Timeout */
;;;731        if(Timeout != HAL_MAX_DELAY)
;;;732        {
;;;733          if(((HAL_GetTick() - tickstart) > Timeout) ||  (Timeout == 0U))
;;;734          {
;;;735            /* Update error code */
;;;736            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;737    
;;;738            /* Change the DMA state */
;;;739            hdma->State = HAL_DMA_STATE_READY;
;;;740    
;;;741            /* Process Unlocked */
;;;742            __HAL_UNLOCK(hdma);
;;;743    
;;;744            return HAL_ERROR;
;;;745          }
;;;746        }
;;;747      }
;;;748    
;;;749    #if defined(DMAMUX1)
;;;750      /*Check for DMAMUX Request generator (if used) overrun status */
;;;751      if(hdma->DMAmuxRequestGen != 0U)
;;;752      {
;;;753        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
;;;754        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
;;;755        {
;;;756          /* Disable the request gen overrun interrupt */
;;;757          hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
;;;758    
;;;759          /* Clear the DMAMUX request generator overrun flag */
;;;760          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
;;;761    
;;;762          /* Update error code */
;;;763          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
;;;764        }
;;;765      }
;;;766    
;;;767      /* Check for DMAMUX Synchronization overrun */
;;;768      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
;;;769      {
;;;770        /* Clear the DMAMUX synchro overrun flag */
;;;771        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
;;;772    
;;;773        /* Update error code */
;;;774        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
;;;775      }
;;;776    #endif /* DMAMUX1 */
;;;777    
;;;778      if(HAL_DMA_FULL_TRANSFER == CompleteLevel)
;;;779      {
;;;780        /* Clear the transfer complete flag */
;;;781        hdma->DmaBaseAddress->IFCR = (DMA_FLAG_TC1 << (hdma->ChannelIndex& 0x1CU));
;;;782    
;;;783        /* Process unlocked */
;;;784        __HAL_UNLOCK(hdma);
;;;785    
;;;786        /* The selected Channelx EN bit is cleared (DMA is disabled and
;;;787        all transfers are complete) */
;;;788        hdma->State = HAL_DMA_STATE_READY;
;;;789      }
;;;790      else
;;;791      {
;;;792        /* Clear the half transfer complete flag */
;;;793        hdma->DmaBaseAddress->IFCR = (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU));
;;;794      }
;;;795    
;;;796      return HAL_OK;
;;;797    }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L9.40|
000028  6820              LDR      r0,[r4,#0]            ;689
00002a  6800              LDR      r0,[r0,#0]            ;689
00002c  0680              LSLS     r0,r0,#26             ;689
00002e  d504              BPL      |L9.58|
000030  f44f7080          MOV      r0,#0x100             ;691
000034  63e0              STR      r0,[r4,#0x3c]         ;691
000036  2001              MOVS     r0,#1                 ;692
000038  e7f4              B        |L9.36|
                  |L9.58|
00003a  f1bb0f00          CMP      r11,#0                ;696
00003e  d00b              BEQ      |L9.88|
000040  f8940044          LDRB     r0,[r4,#0x44]         ;704
000044  f000001c          AND      r0,r0,#0x1c           ;704
000048  fa0af600          LSL      r6,r10,r0             ;704
                  |L9.76|
00004c  f7fffffe          BL       HAL_GetTick
000050  4607              MOV      r7,r0                 ;708
000052  f04f0901          MOV      r9,#1                 ;685
000056  e027              B        |L9.168|
                  |L9.88|
000058  f8940044          LDRB     r0,[r4,#0x44]         ;699
00005c  2602              MOVS     r6,#2                 ;699
00005e  f000001c          AND      r0,r0,#0x1c           ;699
000062  4086              LSLS     r6,r6,r0              ;699
000064  e7f2              B        |L9.76|
                  |L9.102|
000066  6801              LDR      r1,[r0,#0]            ;712
000068  f8940044          LDRB     r0,[r4,#0x44]         ;712
00006c  f000021c          AND      r2,r0,#0x1c           ;712
000070  2008              MOVS     r0,#8                 ;712
000072  4090              LSLS     r0,r0,r2              ;712
000074  4201              TST      r1,r0                 ;712
000076  d00f              BEQ      |L9.152|
000078  f8940044          LDRB     r0,[r4,#0x44]         ;717
00007c  6c21              LDR      r1,[r4,#0x40]         ;717
00007e  f000001c          AND      r0,r0,#0x1c           ;717
000082  fa09f000          LSL      r0,r9,r0              ;717
000086  6048              STR      r0,[r1,#4]            ;717
000088  f8c4903c          STR      r9,[r4,#0x3c]         ;720
00008c  f8849025          STRB     r9,[r4,#0x25]         ;723
000090  f8848024          STRB     r8,[r4,#0x24]         ;726
000094  2001              MOVS     r0,#1                 ;728
000096  e7c5              B        |L9.36|
                  |L9.152|
000098  1c68              ADDS     r0,r5,#1              ;731
00009a  d005              BEQ      |L9.168|
00009c  f7fffffe          BL       HAL_GetTick
0000a0  1bc0              SUBS     r0,r0,r7              ;733
0000a2  42a8              CMP      r0,r5                 ;733
0000a4  d812              BHI      |L9.204|
0000a6  b18d              CBZ      r5,|L9.204|
                  |L9.168|
0000a8  6c20              LDR      r0,[r4,#0x40]         ;710
0000aa  6801              LDR      r1,[r0,#0]            ;710
0000ac  4231              TST      r1,r6                 ;710
0000ae  d0da              BEQ      |L9.102|
0000b0  f1bb0f00          CMP      r11,#0                ;778
0000b4  d012              BEQ      |L9.220|
0000b6  f8940044          LDRB     r0,[r4,#0x44]         ;793
0000ba  f000001c          AND      r0,r0,#0x1c           ;793
0000be  fa0afa00          LSL      r10,r10,r0            ;793
0000c2  6c20              LDR      r0,[r4,#0x40]         ;793
0000c4  f8c0a004          STR      r10,[r0,#4]           ;793
                  |L9.200|
0000c8  2000              MOVS     r0,#0                 ;796
0000ca  e7ab              B        |L9.36|
                  |L9.204|
0000cc  2020              MOVS     r0,#0x20              ;736
0000ce  63e0              STR      r0,[r4,#0x3c]         ;736
0000d0  f8849025          STRB     r9,[r4,#0x25]         ;739
0000d4  f8848024          STRB     r8,[r4,#0x24]         ;742
0000d8  2001              MOVS     r0,#1                 ;744
0000da  e7a3              B        |L9.36|
                  |L9.220|
0000dc  f8940044          LDRB     r0,[r4,#0x44]         ;781
0000e0  f000011c          AND      r1,r0,#0x1c           ;781
0000e4  2002              MOVS     r0,#2                 ;781
0000e6  4088              LSLS     r0,r0,r1              ;781
0000e8  6c21              LDR      r1,[r4,#0x40]         ;781
0000ea  6048              STR      r0,[r1,#4]            ;781
0000ec  f8848024          STRB     r8,[r4,#0x24]         ;784
0000f0  f8849025          STRB     r9,[r4,#0x25]         ;788
0000f4  e7e8              B        |L9.200|
;;;798    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;900      */
;;;901    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma))
000000  b510              PUSH     {r4,lr}
;;;902    {
;;;903      HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;904    
;;;905      /* Process locked */
;;;906      __HAL_LOCK(hdma);
000004  f8904024          LDRB     r4,[r0,#0x24]
000008  2c01              CMP      r4,#1
00000a  d00c              BEQ      |L10.38|
00000c  2401              MOVS     r4,#1
00000e  f8804024          STRB     r4,[r0,#0x24]
;;;907    
;;;908      if(HAL_DMA_STATE_READY == hdma->State)
000012  f8904025          LDRB     r4,[r0,#0x25]
000016  2c01              CMP      r4,#1
000018  d007              BEQ      |L10.42|
;;;909      {
;;;910        switch (CallbackID)
;;;911        {
;;;912         case  HAL_DMA_XFER_CPLT_CB_ID:
;;;913               hdma->XferCpltCallback = pCallback;
;;;914               break;
;;;915    
;;;916         case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;917               hdma->XferHalfCpltCallback = pCallback;
;;;918               break;
;;;919    
;;;920         case  HAL_DMA_XFER_ERROR_CB_ID:
;;;921               hdma->XferErrorCallback = pCallback;
;;;922               break;
;;;923    
;;;924         case  HAL_DMA_XFER_ABORT_CB_ID:
;;;925               hdma->XferAbortCallback = pCallback;
;;;926               break;
;;;927    
;;;928         default:
;;;929               status = HAL_ERROR;
;;;930               break;
;;;931        }
;;;932      }
;;;933      else
;;;934      {
;;;935        status = HAL_ERROR;
00001a  2301              MOVS     r3,#1
                  |L10.28|
;;;936      }
;;;937    
;;;938      /* Release Lock */
;;;939      __HAL_UNLOCK(hdma);
00001c  2100              MOVS     r1,#0
00001e  f8801024          STRB     r1,[r0,#0x24]
;;;940    
;;;941      return status;
000022  4618              MOV      r0,r3
;;;942    }
000024  bd10              POP      {r4,pc}
                  |L10.38|
000026  2002              MOVS     r0,#2                 ;906
000028  bd10              POP      {r4,pc}
                  |L10.42|
00002a  b139              CBZ      r1,|L10.60|
00002c  2901              CMP      r1,#1                 ;910
00002e  d007              BEQ      |L10.64|
000030  2902              CMP      r1,#2                 ;910
000032  d007              BEQ      |L10.68|
000034  2903              CMP      r1,#3                 ;910
000036  d007              BEQ      |L10.72|
000038  2301              MOVS     r3,#1                 ;929
00003a  e7ef              B        |L10.28|
                  |L10.60|
00003c  62c2              STR      r2,[r0,#0x2c]         ;913
00003e  e7ed              B        |L10.28|
                  |L10.64|
000040  6302              STR      r2,[r0,#0x30]         ;917
000042  e7eb              B        |L10.28|
                  |L10.68|
000044  6342              STR      r2,[r0,#0x34]         ;921
000046  e7e9              B        |L10.28|
                  |L10.72|
000048  6382              STR      r2,[r0,#0x38]         ;925
00004a  e7e7              B        |L10.28|
;;;943    
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;429      */
;;;430    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b570              PUSH     {r4-r6,lr}
;;;431    {
000002  4604              MOV      r4,r0
;;;432      HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;433    
;;;434      /* Check the parameters */
;;;435      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;436    
;;;437      /* Process locked */
;;;438      __HAL_LOCK(hdma);
000006  f8940024          LDRB     r0,[r4,#0x24]
00000a  2801              CMP      r0,#1
00000c  d00c              BEQ      |L11.40|
00000e  2001              MOVS     r0,#1
000010  f8840024          STRB     r0,[r4,#0x24]
;;;439    
;;;440      if(HAL_DMA_STATE_READY == hdma->State)
000014  f8946025          LDRB     r6,[r4,#0x25]
000018  2000              MOVS     r0,#0
00001a  2e01              CMP      r6,#1
00001c  d006              BEQ      |L11.44|
;;;441      {
;;;442        /* Change DMA peripheral state */
;;;443        hdma->State = HAL_DMA_STATE_BUSY;
;;;444        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;445    
;;;446        /* Disable the peripheral */
;;;447        __HAL_DMA_DISABLE(hdma);
;;;448    
;;;449        /* Configure the source, destination address and the data length & clear flags*/
;;;450        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;451    
;;;452        /* Enable the Peripheral */
;;;453        __HAL_DMA_ENABLE(hdma);
;;;454      }
;;;455      else
;;;456      {
;;;457        /* Process Unlocked */
;;;458        __HAL_UNLOCK(hdma);
00001e  f8840024          STRB     r0,[r4,#0x24]
;;;459        status = HAL_BUSY;
000022  2502              MOVS     r5,#2
                  |L11.36|
;;;460      }
;;;461      return status;
000024  4628              MOV      r0,r5
;;;462    }
000026  bd70              POP      {r4-r6,pc}
                  |L11.40|
000028  2002              MOVS     r0,#2                 ;438
00002a  bd70              POP      {r4-r6,pc}
                  |L11.44|
00002c  2602              MOVS     r6,#2                 ;443
00002e  f8846025          STRB     r6,[r4,#0x25]         ;443
000032  63e0              STR      r0,[r4,#0x3c]         ;444
000034  6820              LDR      r0,[r4,#0]            ;447
000036  6806              LDR      r6,[r0,#0]            ;447
000038  f0260601          BIC      r6,r6,#1              ;447
00003c  6006              STR      r6,[r0,#0]            ;447
00003e  4620              MOV      r0,r4                 ;450
000040  f7fffffe          BL       DMA_SetConfig
000044  6820              LDR      r0,[r4,#0]            ;453
000046  6801              LDR      r1,[r0,#0]            ;453
000048  f0410101          ORR      r1,r1,#1              ;453
00004c  6001              STR      r1,[r0,#0]            ;453
00004e  e7e9              B        |L11.36|
;;;463    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;472      */
;;;473    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b570              PUSH     {r4-r6,lr}
;;;474    {
000002  4604              MOV      r4,r0
;;;475      HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;476    
;;;477      /* Check the parameters */
;;;478      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;479    
;;;480      /* Process locked */
;;;481      __HAL_LOCK(hdma);
000006  f8940024          LDRB     r0,[r4,#0x24]
00000a  2801              CMP      r0,#1
00000c  d00c              BEQ      |L12.40|
00000e  2001              MOVS     r0,#1
000010  f8840024          STRB     r0,[r4,#0x24]
;;;482    
;;;483      if(HAL_DMA_STATE_READY == hdma->State)
000014  f8946025          LDRB     r6,[r4,#0x25]
000018  2000              MOVS     r0,#0
00001a  2e01              CMP      r6,#1
00001c  d006              BEQ      |L12.44|
;;;484      {
;;;485        /* Change DMA peripheral state */
;;;486        hdma->State = HAL_DMA_STATE_BUSY;
;;;487        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;488    
;;;489        /* Disable the peripheral */
;;;490        __HAL_DMA_DISABLE(hdma);
;;;491    
;;;492        /* Configure the source, destination address and the data length & clear flags*/
;;;493        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;494    
;;;495        /* Enable the transfer complete interrupt */
;;;496        /* Enable the transfer Error interrupt */
;;;497        if(NULL != hdma->XferHalfCpltCallback )
;;;498        {
;;;499          /* Enable the Half transfer complete interrupt as well */
;;;500          __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
;;;501        }
;;;502        else
;;;503        {
;;;504          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
;;;505          __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
;;;506        }
;;;507    
;;;508    #ifdef DMAMUX1
;;;509    
;;;510        /* Check if DMAMUX Synchronization is enabled*/
;;;511        if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
;;;512        {
;;;513          /* Enable DMAMUX sync overrun IT*/
;;;514          hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
;;;515        }
;;;516    
;;;517        if(hdma->DMAmuxRequestGen != 0U)
;;;518        {
;;;519          /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
;;;520          /* enable the request gen overrun IT*/
;;;521          hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
;;;522        }
;;;523    
;;;524    #endif /* DMAMUX1 */
;;;525    
;;;526        /* Enable the Peripheral */
;;;527        __HAL_DMA_ENABLE(hdma);
;;;528      }
;;;529      else
;;;530      {
;;;531        /* Process Unlocked */
;;;532        __HAL_UNLOCK(hdma);
00001e  f8840024          STRB     r0,[r4,#0x24]
;;;533    
;;;534        /* Remain BUSY */
;;;535        status = HAL_BUSY;
000022  2502              MOVS     r5,#2
                  |L12.36|
;;;536      }
;;;537      return status;
000024  4628              MOV      r0,r5
;;;538    }
000026  bd70              POP      {r4-r6,pc}
                  |L12.40|
000028  2002              MOVS     r0,#2                 ;481
00002a  bd70              POP      {r4-r6,pc}
                  |L12.44|
00002c  2602              MOVS     r6,#2                 ;486
00002e  f8846025          STRB     r6,[r4,#0x25]         ;486
000032  63e0              STR      r0,[r4,#0x3c]         ;487
000034  6820              LDR      r0,[r4,#0]            ;490
000036  6806              LDR      r6,[r0,#0]            ;490
000038  f0260601          BIC      r6,r6,#1              ;490
00003c  6006              STR      r6,[r0,#0]            ;490
00003e  4620              MOV      r0,r4                 ;493
000040  f7fffffe          BL       DMA_SetConfig
000044  6b20              LDR      r0,[r4,#0x30]         ;497
000046  b128              CBZ      r0,|L12.84|
000048  6820              LDR      r0,[r4,#0]            ;500
00004a  6801              LDR      r1,[r0,#0]            ;500
00004c  f041010e          ORR      r1,r1,#0xe            ;500
000050  6001              STR      r1,[r0,#0]            ;500
000052  e009              B        |L12.104|
                  |L12.84|
000054  6820              LDR      r0,[r4,#0]            ;504
000056  6801              LDR      r1,[r0,#0]            ;504
000058  f0210104          BIC      r1,r1,#4              ;504
00005c  6001              STR      r1,[r0,#0]            ;504
00005e  6820              LDR      r0,[r4,#0]            ;505
000060  6801              LDR      r1,[r0,#0]            ;505
000062  f041010a          ORR      r1,r1,#0xa            ;505
000066  6001              STR      r1,[r0,#0]            ;505
                  |L12.104|
000068  6820              LDR      r0,[r4,#0]            ;527
00006a  6801              LDR      r1,[r0,#0]            ;527
00006c  f0410101          ORR      r1,r1,#1              ;527
000070  6001              STR      r1,[r0,#0]            ;527
000072  e7d7              B        |L12.36|
;;;539    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;951      */
;;;952    HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  b510              PUSH     {r4,lr}
;;;953    {
;;;954      HAL_StatusTypeDef status = HAL_OK;
000002  2200              MOVS     r2,#0
;;;955    
;;;956        /* Process locked */
;;;957      __HAL_LOCK(hdma);
000004  f8903024          LDRB     r3,[r0,#0x24]
000008  2b01              CMP      r3,#1
00000a  d00c              BEQ      |L13.38|
00000c  2301              MOVS     r3,#1
00000e  f8803024          STRB     r3,[r0,#0x24]
;;;958    
;;;959      if(HAL_DMA_STATE_READY == hdma->State)
000012  f8904025          LDRB     r4,[r0,#0x25]
000016  2300              MOVS     r3,#0
000018  2c01              CMP      r4,#1
00001a  d006              BEQ      |L13.42|
;;;960      {
;;;961        switch (CallbackID)
;;;962        {
;;;963         case  HAL_DMA_XFER_CPLT_CB_ID:
;;;964               hdma->XferCpltCallback = NULL;
;;;965               break;
;;;966    
;;;967         case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;968               hdma->XferHalfCpltCallback = NULL;
;;;969               break;
;;;970    
;;;971         case  HAL_DMA_XFER_ERROR_CB_ID:
;;;972               hdma->XferErrorCallback = NULL;
;;;973               break;
;;;974    
;;;975         case  HAL_DMA_XFER_ABORT_CB_ID:
;;;976               hdma->XferAbortCallback = NULL;
;;;977               break;
;;;978    
;;;979        case   HAL_DMA_XFER_ALL_CB_ID:
;;;980               hdma->XferCpltCallback = NULL;
;;;981               hdma->XferHalfCpltCallback = NULL;
;;;982               hdma->XferErrorCallback = NULL;
;;;983               hdma->XferAbortCallback = NULL;
;;;984               break;
;;;985    
;;;986        default:
;;;987               status = HAL_ERROR;
;;;988               break;
;;;989        }
;;;990      }
;;;991      else
;;;992      {
;;;993        status = HAL_ERROR;
00001c  2201              MOVS     r2,#1
                  |L13.30|
;;;994      }
;;;995    
;;;996      /* Release Lock */
;;;997      __HAL_UNLOCK(hdma);
00001e  f8803024          STRB     r3,[r0,#0x24]
;;;998    
;;;999      return status;
000022  4610              MOV      r0,r2
;;;1000   }
000024  bd10              POP      {r4,pc}
                  |L13.38|
000026  2002              MOVS     r0,#2                 ;957
000028  bd10              POP      {r4,pc}
                  |L13.42|
00002a  2905              CMP      r1,#5                 ;961
00002c  d211              BCS      |L13.82|
00002e  e8dff001          TBB      [pc,r1]               ;961
000032  0305              DCB      0x03,0x05
000034  07090b00          DCB      0x07,0x09,0x0b,0x00
000038  62c3              STR      r3,[r0,#0x2c]         ;964
00003a  e7f0              B        |L13.30|
00003c  6303              STR      r3,[r0,#0x30]         ;968
00003e  e7ee              B        |L13.30|
000040  6343              STR      r3,[r0,#0x34]         ;972
000042  e7ec              B        |L13.30|
000044  6383              STR      r3,[r0,#0x38]         ;976
000046  e7ea              B        |L13.30|
000048  62c3              STR      r3,[r0,#0x2c]         ;980
00004a  6303              STR      r3,[r0,#0x30]         ;981
00004c  6343              STR      r3,[r0,#0x34]         ;982
00004e  6383              STR      r3,[r0,#0x38]         ;983
000050  e7e5              B        |L13.30|
                  |L13.82|
000052  2201              MOVS     r2,#1                 ;987
000054  e7e3              B        |L13.30|
;;;1001   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_dma_c_c25f65ec____RRX|
#line 694
|__asm___19_stm32l4xx_hal_dma_c_c25f65ec____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
