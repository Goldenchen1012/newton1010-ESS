; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_adc_ex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_adc_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_adc_ex.c]
                          THUMB

                          AREA ||i.HAL_ADCEx_Calibration_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_Calibration_GetValue PROC
;;;201      */
;;;202    uint32_t HAL_ADCEx_Calibration_GetValue(ADC_HandleTypeDef *hadc, uint32_t SingleDiff)
000000  6800              LDR      r0,[r0,#0]
000002  f8d000b4          LDR      r0,[r0,#0xb4]
000006  f001127f          AND      r2,r1,#0x7f007f
00000a  f4013180          AND      r1,r1,#0x10000
00000e  4010              ANDS     r0,r0,r2
000010  0b09              LSRS     r1,r1,#12
000012  40c8              LSRS     r0,r0,r1
;;;203    {
;;;204      /* Check the parameters */
;;;205      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;206      assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
;;;207    
;;;208      /* Return the selected ADC calibration value */
;;;209      return LL_ADC_GetCalibrationFactor(hadc->Instance, SingleDiff);
;;;210    }
000014  4770              BX       lr
;;;211    
                          ENDP


                          AREA ||i.HAL_ADCEx_Calibration_SetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_Calibration_SetValue PROC
;;;221      */
;;;222    HAL_StatusTypeDef HAL_ADCEx_Calibration_SetValue(ADC_HandleTypeDef *hadc, uint32_t SingleDiff,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;223                                                     uint32_t CalibrationFactor)
;;;224    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;225      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;226      uint32_t tmp_adc_is_conversion_on_going_regular;
;;;227      uint32_t tmp_adc_is_conversion_on_going_injected;
;;;228    
;;;229      /* Check the parameters */
;;;230      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;231      assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
;;;232      assert_param(IS_ADC_CALFACT(CalibrationFactor));
;;;233    
;;;234      /* Process locked */
;;;235      __HAL_LOCK(hadc);
00000c  f8940054          LDRB     r0,[r4,#0x54]
000010  2801              CMP      r0,#1
000012  d012              BEQ      |L2.58|
000014  2001              MOVS     r0,#1
000016  f8840054          STRB     r0,[r4,#0x54]
;;;236    
;;;237      /* Verification of hardware constraints before modifying the calibration    */
;;;238      /* factors register: ADC must be enabled, no conversion on going.           */
;;;239      tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000020  4680              MOV      r8,r0
;;;240      tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
000028  4681              MOV      r9,r0
;;;241    
;;;242      if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       LL_ADC_IsEnabled
000030  b148              CBZ      r0,|L2.70|
;;;243          && (tmp_adc_is_conversion_on_going_regular == 0UL)
000032  f1b80f00          CMP      r8,#0
000036  d003              BEQ      |L2.64|
000038  e005              B        |L2.70|
                  |L2.58|
00003a  2002              MOVS     r0,#2                 ;235
                  |L2.60|
;;;244          && (tmp_adc_is_conversion_on_going_injected == 0UL)
;;;245         )
;;;246      {
;;;247        /* Set the selected ADC calibration value */
;;;248        LL_ADC_SetCalibrationFactor(hadc->Instance, SingleDiff, CalibrationFactor);
;;;249      }
;;;250      else
;;;251      {
;;;252        /* Update ADC state machine */
;;;253        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;254        /* Update ADC error code */
;;;255        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;256    
;;;257        /* Update ADC state machine to error */
;;;258        tmp_hal_status = HAL_ERROR;
;;;259      }
;;;260    
;;;261      /* Process unlocked */
;;;262      __HAL_UNLOCK(hadc);
;;;263    
;;;264      /* Return function status */
;;;265      return tmp_hal_status;
;;;266    }
00003c  e8bd87f0          POP      {r4-r10,pc}
                  |L2.64|
000040  f1b90f00          CMP      r9,#0                 ;244
000044  d00d              BEQ      |L2.98|
                  |L2.70|
000046  6da0              LDR      r0,[r4,#0x58]         ;253
000048  f0400020          ORR      r0,r0,#0x20           ;253
00004c  65a0              STR      r0,[r4,#0x58]         ;253
00004e  6de0              LDR      r0,[r4,#0x5c]         ;255
000050  f0400001          ORR      r0,r0,#1              ;255
000054  65e0              STR      r0,[r4,#0x5c]         ;255
000056  2701              MOVS     r7,#1                 ;258
                  |L2.88|
000058  2000              MOVS     r0,#0                 ;262
00005a  f8840054          STRB     r0,[r4,#0x54]         ;262
00005e  4638              MOV      r0,r7                 ;265
000060  e7ec              B        |L2.60|
                  |L2.98|
000062  6820              LDR      r0,[r4,#0]            ;248
000064  f8501fb4          LDR      r1,[r0,#0xb4]!        ;248
000068  f005127f          AND      r2,r5,#0x7f007f       ;248
00006c  4391              BICS     r1,r1,r2              ;248
00006e  f4053280          AND      r2,r5,#0x10000        ;248
000072  0b12              LSRS     r2,r2,#12             ;248
000074  43aa              BICS     r2,r2,r5              ;248
000076  4096              LSLS     r6,r6,r2              ;248
000078  4331              ORRS     r1,r1,r6              ;248
00007a  6001              STR      r1,[r0,#0]            ;248
00007c  e7ec              B        |L2.88|
;;;267    
                          ENDP


                          AREA ||i.HAL_ADCEx_Calibration_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_Calibration_Start PROC
;;;127      */
;;;128    HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t SingleDiff)
000000  b5f8              PUSH     {r3-r7,lr}
;;;129    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;130      HAL_StatusTypeDef tmp_hal_status;
;;;131      __IO uint32_t wait_loop_index = 0UL;
000006  2500              MOVS     r5,#0
000008  9500              STR      r5,[sp,#0]
;;;132    
;;;133      /* Check the parameters */
;;;134      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;135      assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
;;;136    
;;;137      /* Process locked */
;;;138      __HAL_LOCK(hadc);
00000a  f8940054          LDRB     r0,[r4,#0x54]
00000e  2801              CMP      r0,#1
000010  d010              BEQ      |L3.52|
000012  2001              MOVS     r0,#1
000014  f8840054          STRB     r0,[r4,#0x54]
;;;139    
;;;140      /* Calibration prerequisite: ADC must be disabled. */
;;;141    
;;;142      /* Disable the ADC (if not already disabled) */
;;;143      tmp_hal_status = ADC_Disable(hadc);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       ADC_Disable
00001e  4602              MOV      r2,r0
;;;144    
;;;145      /* Check if ADC is effectively disabled */
;;;146      if (tmp_hal_status == HAL_OK)
000020  0010              MOVS     r0,r2
000022  d009              BEQ      |L3.56|
;;;147      {
;;;148        /* Set ADC state */
;;;149        ADC_STATE_CLR_SET(hadc->State,
;;;150                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;151                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;152    
;;;153        /* Start ADC calibration in mode single-ended or differential */
;;;154        LL_ADC_StartCalibration(hadc->Instance, SingleDiff);
;;;155    
;;;156        /* Wait for calibration completion */
;;;157        while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
;;;158        {
;;;159          wait_loop_index++;
;;;160          if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
;;;161          {
;;;162            /* Update ADC state machine to error */
;;;163            ADC_STATE_CLR_SET(hadc->State,
;;;164                              HAL_ADC_STATE_BUSY_INTERNAL,
;;;165                              HAL_ADC_STATE_ERROR_INTERNAL);
;;;166    
;;;167            /* Process unlocked */
;;;168            __HAL_UNLOCK(hadc);
;;;169    
;;;170            return HAL_ERROR;
;;;171          }
;;;172        }
;;;173    
;;;174        /* Set ADC state */
;;;175        ADC_STATE_CLR_SET(hadc->State,
;;;176                          HAL_ADC_STATE_BUSY_INTERNAL,
;;;177                          HAL_ADC_STATE_READY);
;;;178      }
;;;179      else
;;;180      {
;;;181        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000024  6da0              LDR      r0,[r4,#0x58]
000026  f0400010          ORR      r0,r0,#0x10
00002a  65a0              STR      r0,[r4,#0x58]
                  |L3.44|
;;;182    
;;;183        /* Note: No need to update variable "tmp_hal_status" here: already set    */
;;;184        /*       to state "HAL_ERROR" by function disabling the ADC.              */
;;;185      }
;;;186    
;;;187      /* Process unlocked */
;;;188      __HAL_UNLOCK(hadc);
00002c  f8845054          STRB     r5,[r4,#0x54]
;;;189    
;;;190      /* Return function status */
;;;191      return tmp_hal_status;
000030  4610              MOV      r0,r2
;;;192    }
000032  bdf8              POP      {r3-r7,pc}
                  |L3.52|
000034  2002              MOVS     r0,#2                 ;138
000036  bdf8              POP      {r3-r7,pc}
                  |L3.56|
000038  6da0              LDR      r0,[r4,#0x58]         ;149
00003a  f4205088          BIC      r0,r0,#0x1100         ;149
00003e  f0400002          ORR      r0,r0,#2              ;149
000042  65a0              STR      r0,[r4,#0x58]         ;149
000044  6820              LDR      r0,[r4,#0]            ;154
000046  6881              LDR      r1,[r0,#8]            ;154
000048  4b13              LDR      r3,|L3.152|
00004a  4019              ANDS     r1,r1,r3              ;154
00004c  f0064380          AND      r3,r6,#0x40000000     ;154
000050  4319              ORRS     r1,r1,r3              ;154
000052  f0414100          ORR      r1,r1,#0x80000000     ;154
000056  6081              STR      r1,[r0,#8]            ;154
000058  f44f2391          MOV      r3,#0x48800           ;160
00005c  6820              LDR      r0,[r4,#0]            ;157
00005e  e00f              B        |L3.128|
                  |L3.96|
000060  9900              LDR      r1,[sp,#0]            ;159
000062  1c49              ADDS     r1,r1,#1              ;159
000064  9100              STR      r1,[sp,#0]            ;159
000066  9900              LDR      r1,[sp,#0]            ;160
000068  4299              CMP      r1,r3                 ;160
00006a  d309              BCC      |L3.128|
00006c  6da0              LDR      r0,[r4,#0x58]         ;163
00006e  f0200002          BIC      r0,r0,#2              ;163
000072  f0400010          ORR      r0,r0,#0x10           ;163
000076  65a0              STR      r0,[r4,#0x58]         ;163
000078  f8845054          STRB     r5,[r4,#0x54]         ;168
00007c  2001              MOVS     r0,#1                 ;170
00007e  bdf8              POP      {r3-r7,pc}
                  |L3.128|
000080  6881              LDR      r1,[r0,#8]
000082  0fc9              LSRS     r1,r1,#31
000084  2900              CMP      r1,#0                 ;157
000086  d1eb              BNE      |L3.96|
000088  6da0              LDR      r0,[r4,#0x58]         ;175
00008a  f0200002          BIC      r0,r0,#2              ;175
00008e  f0400001          ORR      r0,r0,#1              ;175
000092  65a0              STR      r0,[r4,#0x58]         ;175
000094  e7ca              B        |L3.44|
;;;193    
                          ENDP

000096  0000              DCW      0x0000
                  |L3.152|
                          DCD      0x3fffffc0

                          AREA ||i.HAL_ADCEx_DisableInjectedQueue||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_DisableInjectedQueue PROC
;;;2263     */
;;;2264   HAL_StatusTypeDef HAL_ADCEx_DisableInjectedQueue(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;2265   {
000002  4604              MOV      r4,r0
;;;2266     HAL_StatusTypeDef tmp_hal_status;
;;;2267     uint32_t tmp_adc_is_conversion_on_going_regular;
;;;2268     uint32_t tmp_adc_is_conversion_on_going_injected;
;;;2269   
;;;2270     /* Check the parameters */
;;;2271     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2272   
;;;2273     tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00000a  4605              MOV      r5,r0
;;;2274     tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
;;;2275   
;;;2276     /* Parameter can be set only if no conversion is on-going */
;;;2277     if ((tmp_adc_is_conversion_on_going_regular == 0UL)
000012  4305              ORRS     r5,r5,r0
000014  d001              BEQ      |L4.26|
;;;2278         && (tmp_adc_is_conversion_on_going_injected == 0UL)
;;;2279        )
;;;2280     {
;;;2281       LL_ADC_INJ_SetQueueMode(hadc->Instance, LL_ADC_INJ_QUEUE_DISABLE);
;;;2282       tmp_hal_status = HAL_OK;
;;;2283     }
;;;2284     else
;;;2285     {
;;;2286       tmp_hal_status = HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;2287     }
;;;2288   
;;;2289     return tmp_hal_status;
;;;2290   }
000018  bd70              POP      {r4-r6,pc}
                  |L4.26|
00001a  6820              LDR      r0,[r4,#0]            ;2281
00001c  68c1              LDR      r1,[r0,#0xc]          ;2281
00001e  4a03              LDR      r2,|L4.44|
000020  4011              ANDS     r1,r1,r2              ;2281
000022  f0414100          ORR      r1,r1,#0x80000000     ;2281
000026  60c1              STR      r1,[r0,#0xc]          ;2281
000028  2000              MOVS     r0,#0                 ;2282
00002a  bd70              POP      {r4-r6,pc}
;;;2291   
                          ENDP

                  |L4.44|
                          DCD      0x7fdfffff

                          AREA ||i.HAL_ADCEx_DisableVoltageRegulator||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_DisableVoltageRegulator PROC
;;;2300     */
;;;2301   HAL_StatusTypeDef HAL_ADCEx_DisableVoltageRegulator(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;2302   {
000002  4604              MOV      r4,r0
;;;2303     HAL_StatusTypeDef tmp_hal_status;
;;;2304   
;;;2305     /* Check the parameters */
;;;2306     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2307   
;;;2308     /* Setting of this feature is conditioned to ADC state: ADC must be ADC disabled */
;;;2309     if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       LL_ADC_IsEnabled
00000a  b108              CBZ      r0,|L5.16|
;;;2310     {
;;;2311       LL_ADC_DisableInternalRegulator(hadc->Instance);
;;;2312       tmp_hal_status = HAL_OK;
;;;2313     }
;;;2314     else
;;;2315     {
;;;2316       tmp_hal_status = HAL_ERROR;
00000c  2001              MOVS     r0,#1
;;;2317     }
;;;2318   
;;;2319     return tmp_hal_status;
;;;2320   }
00000e  bd10              POP      {r4,pc}
                  |L5.16|
000010  6820              LDR      r0,[r4,#0]            ;2311
000012  6881              LDR      r1,[r0,#8]            ;2311
000014  4a02              LDR      r2,|L5.32|
000016  4011              ANDS     r1,r1,r2              ;2311
000018  6081              STR      r1,[r0,#8]            ;2311
00001a  2000              MOVS     r0,#0                 ;2312
00001c  bd10              POP      {r4,pc}
;;;2321   
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      0x6fffffc0

                          AREA ||i.HAL_ADCEx_EnableInjectedQueue||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_EnableInjectedQueue PROC
;;;2222     */
;;;2223   HAL_StatusTypeDef HAL_ADCEx_EnableInjectedQueue(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;2224   {
000002  4604              MOV      r4,r0
;;;2225     HAL_StatusTypeDef tmp_hal_status;
;;;2226     uint32_t tmp_adc_is_conversion_on_going_regular;
;;;2227     uint32_t tmp_adc_is_conversion_on_going_injected;
;;;2228   
;;;2229     /* Check the parameters */
;;;2230     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2231   
;;;2232     tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00000a  4605              MOV      r5,r0
;;;2233     tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
;;;2234   
;;;2235     /* Parameter can be set only if no conversion is on-going */
;;;2236     if ((tmp_adc_is_conversion_on_going_regular == 0UL)
000012  4305              ORRS     r5,r5,r0
000014  d001              BEQ      |L6.26|
;;;2237         && (tmp_adc_is_conversion_on_going_injected == 0UL)
;;;2238        )
;;;2239     {
;;;2240       CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);
;;;2241   
;;;2242       /* Update state, clear previous result related to injected queue overflow */
;;;2243       CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
;;;2244   
;;;2245       tmp_hal_status = HAL_OK;
;;;2246     }
;;;2247     else
;;;2248     {
;;;2249       tmp_hal_status = HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;2250     }
;;;2251   
;;;2252     return tmp_hal_status;
;;;2253   }
000018  bd70              POP      {r4-r6,pc}
                  |L6.26|
00001a  6820              LDR      r0,[r4,#0]            ;2240
00001c  68c1              LDR      r1,[r0,#0xc]          ;2240
00001e  f0214100          BIC      r1,r1,#0x80000000     ;2240
000022  60c1              STR      r1,[r0,#0xc]          ;2240
000024  6da0              LDR      r0,[r4,#0x58]         ;2243
000026  f4204080          BIC      r0,r0,#0x4000         ;2243
00002a  65a0              STR      r0,[r4,#0x58]         ;2243
00002c  2000              MOVS     r0,#0                 ;2245
00002e  bd70              POP      {r4-r6,pc}
;;;2254   
                          ENDP


                          AREA ||i.HAL_ADCEx_EndOfSamplingCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_EndOfSamplingCallback PROC
;;;1253     */
;;;1254   __weak void HAL_ADCEx_EndOfSamplingCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1255   {
;;;1256     /* Prevent unused argument(s) compilation warning */
;;;1257     UNUSED(hadc);
;;;1258   
;;;1259     /* NOTE : This function should not be modified. When the callback is needed,
;;;1260               function HAL_ADCEx_EndOfSamplingCallback must be implemented in the user file.
;;;1261     */
;;;1262   }
;;;1263   
                          ENDP


                          AREA ||i.HAL_ADCEx_EnterADCDeepPowerDownMode||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_EnterADCDeepPowerDownMode PROC
;;;2337     */
;;;2338   HAL_StatusTypeDef HAL_ADCEx_EnterADCDeepPowerDownMode(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;2339   {
000002  4604              MOV      r4,r0
;;;2340     HAL_StatusTypeDef tmp_hal_status;
;;;2341   
;;;2342     /* Check the parameters */
;;;2343     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2344   
;;;2345     /* Setting of this feature is conditioned to ADC state: ADC must be ADC disabled */
;;;2346     if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       LL_ADC_IsEnabled
00000a  b108              CBZ      r0,|L8.16|
;;;2347     {
;;;2348       LL_ADC_EnableDeepPowerDown(hadc->Instance);
;;;2349       tmp_hal_status = HAL_OK;
;;;2350     }
;;;2351     else
;;;2352     {
;;;2353       tmp_hal_status = HAL_ERROR;
00000c  2001              MOVS     r0,#1
;;;2354     }
;;;2355   
;;;2356     return tmp_hal_status;
;;;2357   }
00000e  bd10              POP      {r4,pc}
                  |L8.16|
000010  6820              LDR      r0,[r4,#0]            ;2348
000012  6881              LDR      r1,[r0,#8]            ;2348
000014  4a03              LDR      r2,|L8.36|
000016  4011              ANDS     r1,r1,r2              ;2348
000018  f0415100          ORR      r1,r1,#0x20000000     ;2348
00001c  6081              STR      r1,[r0,#8]            ;2348
00001e  2000              MOVS     r0,#0                 ;2349
000020  bd10              POP      {r4,pc}
;;;2358   
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x7fffffc0

                          AREA ||i.HAL_ADCEx_InjectedConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedConfigChannel PROC
;;;1660     */
;;;1661   HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc, ADC_InjectionConfTypeDef *sConfigInjected)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1662   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1663     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000008  2700              MOVS     r7,#0
;;;1664     uint32_t tmpOffsetShifted;
;;;1665     uint32_t tmp_config_internal_channel;
;;;1666     uint32_t tmp_adc_is_conversion_on_going_regular;
;;;1667     uint32_t tmp_adc_is_conversion_on_going_injected;
;;;1668     __IO uint32_t wait_loop_index = 0;
00000a  2600              MOVS     r6,#0
00000c  9600              STR      r6,[sp,#0]
;;;1669   
;;;1670     uint32_t tmp_JSQR_ContextQueueBeingBuilt = 0U;
00000e  2000              MOVS     r0,#0
;;;1671   
;;;1672     /* Check the parameters */
;;;1673     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1674     assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
;;;1675     assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfigInjected->InjectedSingleDiff));
;;;1676     assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
;;;1677     assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->QueueInjectedContext));
;;;1678     assert_param(IS_ADC_EXTTRIGINJEC_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
;;;1679     assert_param(IS_ADC_EXTTRIGINJEC(hadc, sConfigInjected->ExternalTrigInjecConv));
;;;1680     assert_param(IS_ADC_OFFSET_NUMBER(sConfigInjected->InjectedOffsetNumber));
;;;1681     assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfigInjected->InjectedOffset));
;;;1682     assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjecOversamplingMode));
;;;1683   
;;;1684     if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
000010  6921              LDR      r1,[r4,#0x10]
;;;1685     {
;;;1686       assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
;;;1687       assert_param(IS_ADC_INJECTED_NB_CONV(sConfigInjected->InjectedNbrOfConversion));
;;;1688       assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
;;;1689     }
;;;1690   
;;;1691   
;;;1692     /* if JOVSE is set, the value of the OFFSETy_EN bit in ADCx_OFRy register is
;;;1693        ignored (considered as reset) */
;;;1694     assert_param(!((sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE) && (sConfigInjected->InjecOversamplingMode == ENABLE)));
;;;1695   
;;;1696     /* JDISCEN and JAUTO bits can't be set at the same time  */
;;;1697     assert_param(!((sConfigInjected->InjectedDiscontinuousConvMode == ENABLE) && (sConfigInjected->AutoInjectedConv == ENABLE)));
;;;1698   
;;;1699     /*  DISCEN and JAUTO bits can't be set at the same time */
;;;1700     assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (sConfigInjected->AutoInjectedConv == ENABLE)));
;;;1701   
;;;1702     /* Verification of channel number */
;;;1703     if (sConfigInjected->InjectedSingleDiff != ADC_DIFFERENTIAL_ENDED)
000012  f8df9408          LDR      r9,|L9.1052|
;;;1704     {
;;;1705       assert_param(IS_ADC_CHANNEL(hadc, sConfigInjected->InjectedChannel));
;;;1706     }
;;;1707     else
;;;1708     {
;;;1709       assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfigInjected->InjectedChannel));
;;;1710     }
;;;1711   
;;;1712     /* Process locked */
;;;1713     __HAL_LOCK(hadc);
000016  f8942054          LDRB     r2,[r4,#0x54]
00001a  2a01              CMP      r2,#1
00001c  d00b              BEQ      |L9.54|
00001e  f04f0801          MOV      r8,#1
000022  f8848054          STRB     r8,[r4,#0x54]
;;;1714   
;;;1715     /* Configuration of injected group sequencer:                               */
;;;1716     /* Hardware constraint: Must fully define injected context register JSQR    */
;;;1717     /* before make it entering into injected sequencer queue.                   */
;;;1718     /*                                                                          */
;;;1719     /* - if scan mode is disabled:                                              */
;;;1720     /*    * Injected channels sequence length is set to 0x00: 1 channel         */
;;;1721     /*      converted (channel on injected rank 1)                              */
;;;1722     /*      Parameter "InjectedNbrOfConversion" is discarded.                   */
;;;1723     /*    * Injected context register JSQR setting is simple: register is fully */
;;;1724     /*      defined on one call of this function (for injected rank 1) and can  */
;;;1725     /*      be entered into queue directly.                                     */
;;;1726     /* - if scan mode is enabled:                                               */
;;;1727     /*    * Injected channels sequence length is set to parameter               */
;;;1728     /*      "InjectedNbrOfConversion".                                          */
;;;1729     /*    * Injected context register JSQR setting more complex: register is    */
;;;1730     /*      fully defined over successive calls of this function, for each      */
;;;1731     /*      injected channel rank. It is entered into queue only when all       */
;;;1732     /*      injected ranks have been set.                                       */
;;;1733     /*   Note: Scan mode is not present by hardware on this device, but used    */
;;;1734     /*   by software for alignment over all STM32 devices.                      */
;;;1735   
;;;1736     if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
;;;1737         (sConfigInjected->InjectedNbrOfConversion == 1U))
;;;1738     {
;;;1739       /* Configuration of context register JSQR:                                */
;;;1740       /*  - number of ranks in injected group sequencer: fixed to 1st rank      */
;;;1741       /*    (scan mode disabled, only rank 1 used)                              */
;;;1742       /*  - external trigger to start conversion                                */
;;;1743       /*  - external trigger polarity                                           */
;;;1744       /*  - channel set to rank 1 (scan mode disabled, only rank 1 can be used) */
;;;1745   
;;;1746       if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
;;;1747       {
;;;1748         /* Enable external trigger if trigger selection is different of         */
;;;1749         /* software start.                                                      */
;;;1750         /* Note: This configuration keeps the hardware feature of parameter     */
;;;1751         /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
;;;1752         /*       software start.                                                */
;;;1753         if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
;;;1754         {
;;;1755           tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
;;;1756                                              | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
;;;1757                                              | sConfigInjected->ExternalTrigInjecConvEdge
;;;1758                                             );
;;;1759         }
;;;1760         else
;;;1761         {
;;;1762           tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1));
;;;1763         }
;;;1764   
;;;1765         MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_JSQR_ContextQueueBeingBuilt);
000026  4afe              LDR      r2,|L9.1056|
000028  b141              CBZ      r1,|L9.60|
00002a  69a9              LDR      r1,[r5,#0x18]         ;1737
00002c  2901              CMP      r1,#1                 ;1737
00002e  d005              BEQ      |L9.60|
;;;1766         /* For debug and informative reasons, hadc handle saves JSQR setting */
;;;1767         hadc->InjectionConfig.ContextQueue = tmp_JSQR_ContextQueueBeingBuilt;
;;;1768   
;;;1769       }
;;;1770     }
;;;1771     else
;;;1772     {
;;;1773       /* Case of scan mode enabled, several channels to set into injected group */
;;;1774       /* sequencer.                                                             */
;;;1775       /*                                                                        */
;;;1776       /* Procedure to define injected context register JSQR over successive     */
;;;1777       /* calls of this function, for each injected channel rank:                */
;;;1778       /* 1. Start new context and set parameters related to all injected        */
;;;1779       /*    channels: injected sequence length and trigger.                     */
;;;1780   
;;;1781       /* if hadc->InjectionConfig.ChannelCount is equal to 0, this is the first */
;;;1782       /*   call of the context under setting                                    */
;;;1783       if (hadc->InjectionConfig.ChannelCount == 0U)
000030  6e63              LDR      r3,[r4,#0x64]
000032  b1eb              CBZ      r3,|L9.112|
000034  e02a              B        |L9.140|
                  |L9.54|
000036  2002              MOVS     r0,#2                 ;1713
                  |L9.56|
;;;1784       {
;;;1785         /* Initialize number of channels that will be configured on the context */
;;;1786         /*  being built                                                         */
;;;1787         hadc->InjectionConfig.ChannelCount = sConfigInjected->InjectedNbrOfConversion;
;;;1788         /* Handle hadc saves the context under build up over each HAL_ADCEx_InjectedConfigChannel()
;;;1789            call, this context will be written in JSQR register at the last call.
;;;1790            At this point, the context is merely reset  */
;;;1791         hadc->InjectionConfig.ContextQueue = 0x00000000U;
;;;1792   
;;;1793         /* Configuration of context register JSQR:                              */
;;;1794         /*  - number of ranks in injected group sequencer                       */
;;;1795         /*  - external trigger to start conversion                              */
;;;1796         /*  - external trigger polarity                                         */
;;;1797   
;;;1798         /* Enable external trigger if trigger selection is different of         */
;;;1799         /* software start.                                                      */
;;;1800         /* Note: This configuration keeps the hardware feature of parameter     */
;;;1801         /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
;;;1802         /*       software start.                                                */
;;;1803         if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
;;;1804         {
;;;1805           tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
;;;1806                                              | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
;;;1807                                              | sConfigInjected->ExternalTrigInjecConvEdge
;;;1808                                             );
;;;1809         }
;;;1810         else
;;;1811         {
;;;1812           tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U));
;;;1813         }
;;;1814   
;;;1815       }
;;;1816   
;;;1817       /* 2. Continue setting of context under definition with parameter       */
;;;1818       /*    related to each channel: channel rank sequence                    */
;;;1819       /* Clear the old JSQx bits for the selected rank */
;;;1820       tmp_JSQR_ContextQueueBeingBuilt &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, sConfigInjected->InjectedRank);
;;;1821   
;;;1822       /* Set the JSQx bits for the selected rank */
;;;1823       tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
;;;1824   
;;;1825       /* Decrease channel count  */
;;;1826       hadc->InjectionConfig.ChannelCount--;
;;;1827   
;;;1828       /* 3. tmp_JSQR_ContextQueueBeingBuilt is fully built for this HAL_ADCEx_InjectedConfigChannel()
;;;1829             call, aggregate the setting to those already built during the previous
;;;1830             HAL_ADCEx_InjectedConfigChannel() calls (for the same context of course)  */
;;;1831       hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
;;;1832   
;;;1833       /* 4. End of context setting: if this is the last channel set, then write context
;;;1834           into register JSQR and make it enter into queue                   */
;;;1835       if (hadc->InjectionConfig.ChannelCount == 0U)
;;;1836       {
;;;1837         MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
;;;1838       }
;;;1839     }
;;;1840   
;;;1841     /* Parameters update conditioned to ADC state:                              */
;;;1842     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;1843     /* conversion on going on injected group:                                   */
;;;1844     /*  - Injected context queue: Queue disable (active context is kept) or     */
;;;1845     /*    enable (context decremented, up to 2 contexts queued)                 */
;;;1846     /*  - Injected discontinuous mode: can be enabled only if auto-injected     */
;;;1847     /*    mode is disabled.                                                     */
;;;1848     if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
;;;1849     {
;;;1850       /* If auto-injected mode is disabled: no constraint                       */
;;;1851       if (sConfigInjected->AutoInjectedConv == DISABLE)
;;;1852       {
;;;1853         MODIFY_REG(hadc->Instance->CFGR,
;;;1854                    ADC_CFGR_JQM | ADC_CFGR_JDISCEN,
;;;1855                    ADC_CFGR_INJECT_CONTEXT_QUEUE((uint32_t)sConfigInjected->QueueInjectedContext)           |
;;;1856                    ADC_CFGR_INJECT_DISCCONTINUOUS((uint32_t)sConfigInjected->InjectedDiscontinuousConvMode));
;;;1857       }
;;;1858       /* If auto-injected mode is enabled: Injected discontinuous setting is    */
;;;1859       /* discarded.                                                             */
;;;1860       else
;;;1861       {
;;;1862         MODIFY_REG(hadc->Instance->CFGR,
;;;1863                    ADC_CFGR_JQM | ADC_CFGR_JDISCEN,
;;;1864                    ADC_CFGR_INJECT_CONTEXT_QUEUE((uint32_t)sConfigInjected->QueueInjectedContext));
;;;1865       }
;;;1866   
;;;1867     }
;;;1868   
;;;1869     /* Parameters update conditioned to ADC state:                              */
;;;1870     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;1871     /* conversion on going on regular and injected groups:                      */
;;;1872     /*  - Automatic injected conversion: can be enabled if injected group       */
;;;1873     /*    external triggers are disabled.                                       */
;;;1874     /*  - Channel sampling time                                                 */
;;;1875     /*  - Channel offset                                                        */
;;;1876     tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
;;;1877     tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
;;;1878   
;;;1879     if ((tmp_adc_is_conversion_on_going_regular == 0UL)
;;;1880         && (tmp_adc_is_conversion_on_going_injected == 0UL)
;;;1881        )
;;;1882     {
;;;1883       /* If injected group external triggers are disabled (set to injected      */
;;;1884       /* software start): no constraint                                         */
;;;1885       if ((sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
;;;1886           || (sConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
;;;1887       {
;;;1888         if (sConfigInjected->AutoInjectedConv == ENABLE)
;;;1889         {
;;;1890           SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
;;;1891         }
;;;1892         else
;;;1893         {
;;;1894           CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
;;;1895         }
;;;1896       }
;;;1897       /* If Automatic injected conversion was intended to be set and could not  */
;;;1898       /* due to injected group external triggers enabled, error is reported.    */
;;;1899       else
;;;1900       {
;;;1901         if (sConfigInjected->AutoInjectedConv == ENABLE)
;;;1902         {
;;;1903           /* Update ADC state machine to error */
;;;1904           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1905   
;;;1906           tmp_hal_status = HAL_ERROR;
;;;1907         }
;;;1908         else
;;;1909         {
;;;1910           CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
;;;1911         }
;;;1912       }
;;;1913   
;;;1914       if (sConfigInjected->InjecOversamplingMode == ENABLE)
;;;1915       {
;;;1916         assert_param(IS_ADC_OVERSAMPLING_RATIO(sConfigInjected->InjecOversampling.Ratio));
;;;1917         assert_param(IS_ADC_RIGHT_BIT_SHIFT(sConfigInjected->InjecOversampling.RightBitShift));
;;;1918   
;;;1919         /*  JOVSE must be reset in case of triggered regular mode  */
;;;1920         assert_param(!(READ_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE | ADC_CFGR2_TROVS) == (ADC_CFGR2_ROVSE | ADC_CFGR2_TROVS)));
;;;1921   
;;;1922         /* Configuration of Injected Oversampler:                                 */
;;;1923         /*  - Oversampling Ratio                                                  */
;;;1924         /*  - Right bit shift                                                     */
;;;1925   
;;;1926         /* Enable OverSampling mode */
;;;1927         MODIFY_REG(hadc->Instance->CFGR2,
;;;1928                    ADC_CFGR2_JOVSE |
;;;1929                    ADC_CFGR2_OVSR  |
;;;1930                    ADC_CFGR2_OVSS,
;;;1931                    ADC_CFGR2_JOVSE                                  |
;;;1932                    sConfigInjected->InjecOversampling.Ratio         |
;;;1933                    sConfigInjected->InjecOversampling.RightBitShift
;;;1934                   );
;;;1935       }
;;;1936       else
;;;1937       {
;;;1938         /* Disable Regular OverSampling */
;;;1939         CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
;;;1940       }
;;;1941   
;;;1942   #if defined(ADC_SMPR1_SMPPLUS)
;;;1943       /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
;;;1944       if (sConfigInjected->InjectedSamplingTime == ADC_SAMPLETIME_3CYCLES_5)
;;;1945       {
;;;1946         /* Set sampling time of the selected ADC channel */
;;;1947         LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfigInjected->InjectedChannel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
;;;1948   
;;;1949         /* Set ADC sampling time common configuration */
;;;1950         LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
;;;1951       }
;;;1952       else
;;;1953       {
;;;1954         /* Set sampling time of the selected ADC channel */
;;;1955         LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSamplingTime);
;;;1956   
;;;1957         /* Set ADC sampling time common configuration */
;;;1958         LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
;;;1959       }
;;;1960   #else
;;;1961       /* Set sampling time of the selected ADC channel */
;;;1962       LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSamplingTime);
;;;1963   #endif
;;;1964   
;;;1965       /* Configure the offset: offset enable/disable, channel, offset value */
;;;1966   
;;;1967       /* Shift the offset with respect to the selected ADC resolution. */
;;;1968       /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
;;;1969       tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
;;;1970   
;;;1971       if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
;;;1972       {
;;;1973         /* Set ADC selected offset number */
;;;1974         LL_ADC_SetOffset(hadc->Instance, sConfigInjected->InjectedOffsetNumber, sConfigInjected->InjectedChannel,
;;;1975                          tmpOffsetShifted);
;;;1976   
;;;1977       }
;;;1978       else
;;;1979       {
;;;1980         /* Scan each offset register to check if the selected channel is targeted. */
;;;1981         /* If this is the case, the corresponding offset number is disabled.       */
;;;1982         if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
;;;1983             == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
;;;1984         {
;;;1985           LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
;;;1986         }
;;;1987         if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
;;;1988             == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
;;;1989         {
;;;1990           LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
;;;1991         }
;;;1992         if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
;;;1993             == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
;;;1994         {
;;;1995           LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
;;;1996         }
;;;1997         if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
;;;1998             == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
;;;1999         {
;;;2000           LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
;;;2001         }
;;;2002       }
;;;2003   
;;;2004     }
;;;2005   
;;;2006     /* Parameters update conditioned to ADC state:                              */
;;;2007     /* Parameters that can be updated only when ADC is disabled:                */
;;;2008     /*  - Single or differential mode                                           */
;;;2009     if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
;;;2010     {
;;;2011       /* Set mode single-ended or differential input of the selected ADC channel */
;;;2012       LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
;;;2013   
;;;2014       /* Configuration of differential mode */
;;;2015       /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
;;;2016       if (sConfigInjected->InjectedSingleDiff == ADC_DIFFERENTIAL_ENDED)
;;;2017       {
;;;2018         /* Set sampling time of the selected ADC channel */
;;;2019         LL_ADC_SetChannelSamplingTime(hadc->Instance,
;;;2020                                       (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
;;;2021                                                                                  + 1UL) & 0x1FUL)), sConfigInjected->InjectedSamplingTime);
;;;2022       }
;;;2023   
;;;2024     }
;;;2025   
;;;2026     /* Management of internal measurement channels: Vbat/VrefInt/TempSensor   */
;;;2027     /* internal measurement paths enable: If internal channel selected,       */
;;;2028     /* enable dedicated internal buffers and path.                            */
;;;2029     /* Note: these internal measurement paths can be disabled using           */
;;;2030     /* HAL_ADC_DeInit().                                                      */
;;;2031   
;;;2032     if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
;;;2033     {
;;;2034       tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;2035   
;;;2036       /* If the requested internal measurement path has already been enabled,   */
;;;2037       /* bypass the configuration processing.                                   */
;;;2038       if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR)
;;;2039           && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
;;;2040       {
;;;2041         if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
;;;2042         {
;;;2043           LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
;;;2044                                          LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
;;;2045   
;;;2046           /* Delay for temperature sensor stabilization time */
;;;2047           /* Wait loop initialization and execution */
;;;2048           /* Note: Variable divided by 2 to compensate partially              */
;;;2049           /*       CPU processing cycles, scaling in us split to not          */
;;;2050           /*       exceed 32 bits register capacity and handle low frequency. */
;;;2051           wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (((SystemCoreClock / (100000UL * 2UL)) + 1UL) + 1UL));
;;;2052           while (wait_loop_index != 0UL)
;;;2053           {
;;;2054             wait_loop_index--;
;;;2055           }
;;;2056         }
;;;2057       }
;;;2058       else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT)
;;;2059                && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
;;;2060       {
;;;2061         if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
;;;2062         {
;;;2063           LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
;;;2064                                          LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
;;;2065         }
;;;2066       }
;;;2067       else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)
;;;2068                && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
;;;2069       {
;;;2070         if (ADC_VREFINT_INSTANCE(hadc))
;;;2071         {
;;;2072           LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
;;;2073                                          LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
;;;2074         }
;;;2075       }
;;;2076       else
;;;2077       {
;;;2078         /* nothing to do */
;;;2079       }
;;;2080     }
;;;2081   
;;;2082     /* Process unlocked */
;;;2083     __HAL_UNLOCK(hadc);
;;;2084   
;;;2085     /* Return function status */
;;;2086     return tmp_hal_status;
;;;2087   }
000038  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.60|
00003c  6868              LDR      r0,[r5,#4]            ;1746
00003e  2808              CMP      r0,#8                 ;1746
000040  d138              BNE      |L9.180|
000042  6a28              LDR      r0,[r5,#0x20]         ;1753
000044  b148              CBZ      r0,|L9.90|
000046  6829              LDR      r1,[r5,#0]            ;1755
000048  f000003c          AND      r0,r0,#0x3c           ;1755
00004c  f00141f8          AND      r1,r1,#0x7c000000     ;1755
000050  ea404091          ORR      r0,r0,r1,LSR #18      ;1755
000054  6a69              LDR      r1,[r5,#0x24]         ;1755
000056  4308              ORRS     r0,r0,r1              ;1755
000058  e003              B        |L9.98|
                  |L9.90|
00005a  6828              LDR      r0,[r5,#0]            ;1762
00005c  f00040f8          AND      r0,r0,#0x7c000000     ;1762
000060  0c80              LSRS     r0,r0,#18             ;1762
                  |L9.98|
000062  6821              LDR      r1,[r4,#0]            ;1765
000064  6ccb              LDR      r3,[r1,#0x4c]         ;1765
000066  4013              ANDS     r3,r3,r2              ;1765
000068  4303              ORRS     r3,r3,r0              ;1765
00006a  64cb              STR      r3,[r1,#0x4c]         ;1765
00006c  6620              STR      r0,[r4,#0x60]         ;1767
00006e  e021              B        |L9.180|
                  |L9.112|
000070  6661              STR      r1,[r4,#0x64]         ;1787
000072  6626              STR      r6,[r4,#0x60]         ;1791
000074  6a29              LDR      r1,[r5,#0x20]         ;1803
000076  b139              CBZ      r1,|L9.136|
000078  69a8              LDR      r0,[r5,#0x18]         ;1805
00007a  f001013c          AND      r1,r1,#0x3c           ;1805
00007e  1e40              SUBS     r0,r0,#1              ;1805
000080  4308              ORRS     r0,r0,r1              ;1805
000082  6a69              LDR      r1,[r5,#0x24]         ;1805
000084  4308              ORRS     r0,r0,r1              ;1805
000086  e001              B        |L9.140|
                  |L9.136|
000088  69a8              LDR      r0,[r5,#0x18]         ;1812
00008a  1e40              SUBS     r0,r0,#1              ;1812
                  |L9.140|
00008c  6829              LDR      r1,[r5,#0]            ;1823
00008e  f3c16384          UBFX     r3,r1,#26,#5          ;1823
000092  7929              LDRB     r1,[r5,#4]            ;1823
000094  f001011f          AND      r1,r1,#0x1f           ;1823
000098  408b              LSLS     r3,r3,r1              ;1823
00009a  4303              ORRS     r3,r3,r0              ;1823
00009c  6e60              LDR      r0,[r4,#0x64]         ;1826
00009e  1e40              SUBS     r0,r0,#1              ;1826
0000a0  6660              STR      r0,[r4,#0x64]         ;1826
0000a2  6e21              LDR      r1,[r4,#0x60]         ;1831
0000a4  4319              ORRS     r1,r1,r3              ;1831
0000a6  6621              STR      r1,[r4,#0x60]         ;1831
0000a8  b920              CBNZ     r0,|L9.180|
0000aa  6820              LDR      r0,[r4,#0]            ;1837
0000ac  6cc3              LDR      r3,[r0,#0x4c]         ;1837
0000ae  4013              ANDS     r3,r3,r2              ;1837
0000b0  430b              ORRS     r3,r3,r1              ;1837
0000b2  64c3              STR      r3,[r0,#0x4c]         ;1837
                  |L9.180|
0000b4  6820              LDR      r0,[r4,#0]            ;1848
0000b6  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
0000ba  b948              CBNZ     r0,|L9.208|
0000bc  7f68              LDRB     r0,[r5,#0x1d]         ;1851
0000be  b190              CBZ      r0,|L9.230|
0000c0  6820              LDR      r0,[r4,#0]            ;1862
0000c2  68c1              LDR      r1,[r0,#0xc]          ;1862
0000c4  7faa              LDRB     r2,[r5,#0x1e]         ;1862
0000c6  f4211140          BIC      r1,r1,#0x300000       ;1862
0000ca  ea415142          ORR      r1,r1,r2,LSL #21      ;1862
0000ce  60c1              STR      r1,[r0,#0xc]          ;1862
                  |L9.208|
0000d0  6820              LDR      r0,[r4,#0]            ;1876
0000d2  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
0000d6  4682              MOV      r10,r0                ;1876
0000d8  6820              LDR      r0,[r4,#0]            ;1877
0000da  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
0000de  ea5a0a00          ORRS     r10,r10,r0            ;1879
0000e2  d00c              BEQ      |L9.254|
0000e4  e0e3              B        |L9.686|
                  |L9.230|
0000e6  7fa8              LDRB     r0,[r5,#0x1e]         ;1853
0000e8  7f29              LDRB     r1,[r5,#0x1c]         ;1853
0000ea  0540              LSLS     r0,r0,#21             ;1853
0000ec  ea405101          ORR      r1,r0,r1,LSL #20      ;1853
0000f0  6820              LDR      r0,[r4,#0]            ;1853
0000f2  68c2              LDR      r2,[r0,#0xc]          ;1853
0000f4  f4221240          BIC      r2,r2,#0x300000       ;1853
0000f8  4311              ORRS     r1,r1,r2              ;1853
0000fa  60c1              STR      r1,[r0,#0xc]          ;1853
0000fc  e7e8              B        |L9.208|
                  |L9.254|
0000fe  6a28              LDR      r0,[r5,#0x20]         ;1885
000100  b3c8              CBZ      r0,|L9.374|
000102  6a68              LDR      r0,[r5,#0x24]         ;1886
000104  b3b8              CBZ      r0,|L9.374|
000106  7f68              LDRB     r0,[r5,#0x1d]         ;1901
000108  2801              CMP      r0,#1                 ;1901
00010a  d04f              BEQ      |L9.428|
00010c  6820              LDR      r0,[r4,#0]            ;1910
00010e  68c1              LDR      r1,[r0,#0xc]          ;1910
000110  f0217100          BIC      r1,r1,#0x2000000      ;1910
000114  60c1              STR      r1,[r0,#0xc]          ;1910
                  |L9.278|
000116  f8950028          LDRB     r0,[r5,#0x28]         ;1914
00011a  2801              CMP      r0,#1                 ;1914
00011c  d04c              BEQ      |L9.440|
00011e  6820              LDR      r0,[r4,#0]            ;1939
000120  6901              LDR      r1,[r0,#0x10]         ;1939
000122  f0210102          BIC      r1,r1,#2              ;1939
000126  6101              STR      r1,[r0,#0x10]         ;1939
                  |L9.296|
000128  68aa              LDR      r2,[r5,#8]            ;1944
00012a  f1b24f00          CMP      r2,#0x80000000        ;1944
00012e  d023              BEQ      |L9.376|
000130  6829              LDR      r1,[r5,#0]            ;1955
000132  6820              LDR      r0,[r4,#0]            ;1955
000134  f7fffffe          BL       LL_ADC_SetChannelSamplingTime
000138  6820              LDR      r0,[r4,#0]            ;1958
00013a  6941              LDR      r1,[r0,#0x14]         ;1958
00013c  f0214100          BIC      r1,r1,#0x80000000     ;1958
000140  6141              STR      r1,[r0,#0x14]         ;1958
                  |L9.322|
000142  6820              LDR      r0,[r4,#0]            ;1969
000144  696a              LDR      r2,[r5,#0x14]         ;1969
000146  68c1              LDR      r1,[r0,#0xc]          ;1969
000148  f3c101c1          UBFX     r1,r1,#3,#2           ;1969
00014c  0049              LSLS     r1,r1,#1              ;1969
00014e  408a              LSLS     r2,r2,r1              ;1969
000150  6929              LDR      r1,[r5,#0x10]         ;1971
000152  2904              CMP      r1,#4                 ;1971
000154  d03c              BEQ      |L9.464|
000156  682b              LDR      r3,[r5,#0]            ;1974
000158  eb000081          ADD      r0,r0,r1,LSL #2       ;1974
00015c  6e01              LDR      r1,[r0,#0x60]         ;1974
00015e  f8dfc2c4          LDR      r12,|L9.1060|
000162  f00343f8          AND      r3,r3,#0x7c000000     ;1974
000166  ea01010c          AND      r1,r1,r12             ;1974
00016a  4313              ORRS     r3,r3,r2              ;1974
00016c  4319              ORRS     r1,r1,r3              ;1974
00016e  f0414100          ORR      r1,r1,#0x80000000     ;1974
000172  6601              STR      r1,[r0,#0x60]         ;1974
000174  e09b              B        |L9.686|
                  |L9.374|
000176  e00a              B        |L9.398|
                  |L9.376|
000178  6829              LDR      r1,[r5,#0]            ;1947
00017a  2200              MOVS     r2,#0                 ;1947
00017c  6820              LDR      r0,[r4,#0]            ;1947
00017e  f7fffffe          BL       LL_ADC_SetChannelSamplingTime
000182  6820              LDR      r0,[r4,#0]            ;1950
000184  6941              LDR      r1,[r0,#0x14]         ;1950
000186  f0414100          ORR      r1,r1,#0x80000000     ;1950
00018a  6141              STR      r1,[r0,#0x14]         ;1950
00018c  e7d9              B        |L9.322|
                  |L9.398|
00018e  7f68              LDRB     r0,[r5,#0x1d]         ;1888
000190  2801              CMP      r0,#1                 ;1888
000192  d005              BEQ      |L9.416|
000194  6820              LDR      r0,[r4,#0]            ;1894
000196  68c1              LDR      r1,[r0,#0xc]          ;1894
000198  f0217100          BIC      r1,r1,#0x2000000      ;1894
00019c  60c1              STR      r1,[r0,#0xc]          ;1894
00019e  e7ba              B        |L9.278|
                  |L9.416|
0001a0  6820              LDR      r0,[r4,#0]            ;1890
0001a2  68c1              LDR      r1,[r0,#0xc]          ;1890
0001a4  f0417100          ORR      r1,r1,#0x2000000      ;1890
0001a8  60c1              STR      r1,[r0,#0xc]          ;1890
0001aa  e7b4              B        |L9.278|
                  |L9.428|
0001ac  6da0              LDR      r0,[r4,#0x58]         ;1904
0001ae  f0400020          ORR      r0,r0,#0x20           ;1904
0001b2  65a0              STR      r0,[r4,#0x58]         ;1904
0001b4  2701              MOVS     r7,#1                 ;1906
0001b6  e7ae              B        |L9.278|
                  |L9.440|
0001b8  e9d5100b          LDRD     r1,r0,[r5,#0x2c]      ;1927
0001bc  4301              ORRS     r1,r1,r0              ;1927
0001be  6820              LDR      r0,[r4,#0]            ;1927
0001c0  6902              LDR      r2,[r0,#0x10]         ;1927
0001c2  f42272ff          BIC      r2,r2,#0x1fe          ;1927
0001c6  f0420202          ORR      r2,r2,#2              ;1927
0001ca  4311              ORRS     r1,r1,r2              ;1927
0001cc  6101              STR      r1,[r0,#0x10]         ;1927
0001ce  e7ab              B        |L9.296|
                  |L9.464|
0001d0  2100              MOVS     r1,#0                 ;1982
0001d2  f7fffffe          BL       LL_ADC_GetOffsetChannel
0001d6  0340              LSLS     r0,r0,#13             ;1982
0001d8  d06e              BEQ      |L9.696|
0001da  2100              MOVS     r1,#0                 ;1982
0001dc  6820              LDR      r0,[r4,#0]            ;1982
0001de  f7fffffe          BL       LL_ADC_GetOffsetChannel
0001e2  fa90f0a0          RBIT     r0,r0                 ;1982
0001e6  fab0f180          CLZ      r1,r0                 ;1982
                  |L9.490|
0001ea  6828              LDR      r0,[r5,#0]            ;1982
0001ec  0342              LSLS     r2,r0,#13             ;1982
0001ee  d06a              BEQ      |L9.710|
0001f0  fa90f0a0          RBIT     r0,r0                 ;1983
0001f4  fab0f080          CLZ      r0,r0                 ;1983
                  |L9.504|
0001f8  4281              CMP      r1,r0                 ;1983
0001fa  d104              BNE      |L9.518|
0001fc  2200              MOVS     r2,#0                 ;1985
0001fe  4611              MOV      r1,r2                 ;1985
000200  6820              LDR      r0,[r4,#0]            ;1985
000202  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L9.518|
000206  2101              MOVS     r1,#1                 ;1987
000208  6820              LDR      r0,[r4,#0]            ;1987
00020a  f7fffffe          BL       LL_ADC_GetOffsetChannel
00020e  0340              LSLS     r0,r0,#13             ;1987
000210  d05c              BEQ      |L9.716|
000212  2101              MOVS     r1,#1                 ;1987
000214  6820              LDR      r0,[r4,#0]            ;1987
000216  f7fffffe          BL       LL_ADC_GetOffsetChannel
00021a  fa90f0a0          RBIT     r0,r0                 ;1987
00021e  fab0f180          CLZ      r1,r0                 ;1987
                  |L9.546|
000222  6828              LDR      r0,[r5,#0]            ;1987
000224  0342              LSLS     r2,r0,#13             ;1987
000226  d058              BEQ      |L9.730|
000228  fa90f0a0          RBIT     r0,r0                 ;1988
00022c  fab0f080          CLZ      r0,r0                 ;1988
                  |L9.560|
000230  4281              CMP      r1,r0                 ;1988
000232  d104              BNE      |L9.574|
000234  2200              MOVS     r2,#0                 ;1990
000236  2101              MOVS     r1,#1                 ;1990
000238  6820              LDR      r0,[r4,#0]            ;1990
00023a  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L9.574|
00023e  2102              MOVS     r1,#2                 ;1992
000240  6820              LDR      r0,[r4,#0]            ;1992
000242  f7fffffe          BL       LL_ADC_GetOffsetChannel
000246  0340              LSLS     r0,r0,#13             ;1992
000248  d04a              BEQ      |L9.736|
00024a  2102              MOVS     r1,#2                 ;1992
00024c  6820              LDR      r0,[r4,#0]            ;1992
00024e  f7fffffe          BL       LL_ADC_GetOffsetChannel
000252  fa90f0a0          RBIT     r0,r0                 ;1992
000256  fab0f180          CLZ      r1,r0                 ;1992
                  |L9.602|
00025a  6828              LDR      r0,[r5,#0]            ;1992
00025c  0342              LSLS     r2,r0,#13             ;1992
00025e  d046              BEQ      |L9.750|
000260  fa90f0a0          RBIT     r0,r0                 ;1993
000264  fab0f080          CLZ      r0,r0                 ;1993
                  |L9.616|
000268  4281              CMP      r1,r0                 ;1993
00026a  d104              BNE      |L9.630|
00026c  2200              MOVS     r2,#0                 ;1995
00026e  2102              MOVS     r1,#2                 ;1995
000270  6820              LDR      r0,[r4,#0]            ;1995
000272  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L9.630|
000276  2103              MOVS     r1,#3                 ;1997
000278  6820              LDR      r0,[r4,#0]            ;1997
00027a  f7fffffe          BL       LL_ADC_GetOffsetChannel
00027e  0340              LSLS     r0,r0,#13             ;1997
000280  d038              BEQ      |L9.756|
000282  2103              MOVS     r1,#3                 ;1997
000284  6820              LDR      r0,[r4,#0]            ;1997
000286  f7fffffe          BL       LL_ADC_GetOffsetChannel
00028a  fa90f0a0          RBIT     r0,r0                 ;1997
00028e  fab0f180          CLZ      r1,r0                 ;1997
                  |L9.658|
000292  6828              LDR      r0,[r5,#0]            ;1997
000294  0342              LSLS     r2,r0,#13             ;1997
000296  d034              BEQ      |L9.770|
000298  fa90f0a0          RBIT     r0,r0                 ;1998
00029c  fab0f080          CLZ      r0,r0                 ;1998
                  |L9.672|
0002a0  4281              CMP      r1,r0                 ;1998
0002a2  d104              BNE      |L9.686|
0002a4  2200              MOVS     r2,#0                 ;2000
0002a6  2103              MOVS     r1,#3                 ;2000
0002a8  6820              LDR      r0,[r4,#0]            ;2000
0002aa  f7fffffe          BL       LL_ADC_SetOffsetState
                  |L9.686|
0002ae  6820              LDR      r0,[r4,#0]            ;2009
0002b0  f7fffffe          BL       LL_ADC_IsEnabled
0002b4  b340              CBZ      r0,|L9.776|
0002b6  e0b0              B        |L9.1050|
                  |L9.696|
0002b8  2100              MOVS     r1,#0                 ;1982
0002ba  6820              LDR      r0,[r4,#0]            ;1982
0002bc  f7fffffe          BL       LL_ADC_GetOffsetChannel
0002c0  f3c06184          UBFX     r1,r0,#26,#5          ;1982
0002c4  e791              B        |L9.490|
                  |L9.710|
0002c6  f3c06084          UBFX     r0,r0,#26,#5          ;1983
0002ca  e795              B        |L9.504|
                  |L9.716|
0002cc  2101              MOVS     r1,#1                 ;1987
0002ce  6820              LDR      r0,[r4,#0]            ;1987
0002d0  f7fffffe          BL       LL_ADC_GetOffsetChannel
0002d4  f3c06184          UBFX     r1,r0,#26,#5          ;1987
0002d8  e7a3              B        |L9.546|
                  |L9.730|
0002da  f3c06084          UBFX     r0,r0,#26,#5          ;1988
0002de  e7a7              B        |L9.560|
                  |L9.736|
0002e0  2102              MOVS     r1,#2                 ;1992
0002e2  6820              LDR      r0,[r4,#0]            ;1992
0002e4  f7fffffe          BL       LL_ADC_GetOffsetChannel
0002e8  f3c06184          UBFX     r1,r0,#26,#5          ;1992
0002ec  e7b5              B        |L9.602|
                  |L9.750|
0002ee  f3c06084          UBFX     r0,r0,#26,#5          ;1993
0002f2  e7b9              B        |L9.616|
                  |L9.756|
0002f4  2103              MOVS     r1,#3                 ;1997
0002f6  6820              LDR      r0,[r4,#0]            ;1997
0002f8  f7fffffe          BL       LL_ADC_GetOffsetChannel
0002fc  f3c06184          UBFX     r1,r0,#26,#5          ;1997
000300  e7c7              B        |L9.658|
                  |L9.770|
000302  f3c06084          UBFX     r0,r0,#26,#5          ;1998
000306  e7cb              B        |L9.672|
                  |L9.776|
000308  6820              LDR      r0,[r4,#0]            ;2012
00030a  7b2a              LDRB     r2,[r5,#0xc]          ;2012
00030c  6829              LDR      r1,[r5,#0]            ;2012
00030e  f8503fb0          LDR      r3,[r0,#0xb0]!        ;2012
000312  f3c10c12          UBFX     r12,r1,#0,#19         ;2012
000316  ea23030c          BIC      r3,r3,r12             ;2012
00031a  f0020c18          AND      r12,r2,#0x18          ;2012
00031e  4a42              LDR      r2,|L9.1064|
000320  fa22f20c          LSR      r2,r2,r12             ;2012
000324  400a              ANDS     r2,r2,r1              ;2012
000326  4313              ORRS     r3,r3,r2              ;2012
000328  6003              STR      r3,[r0,#0]            ;2012
00032a  68e8              LDR      r0,[r5,#0xc]          ;2016
00032c  4548              CMP      r0,r9                 ;2016
00032e  d174              BNE      |L9.1050|
000330  6828              LDR      r0,[r5,#0]            ;2019
000332  0341              LSLS     r1,r0,#13             ;2019
000334  d019              BEQ      |L9.874|
000336  fa90f1a0          RBIT     r1,r0                 ;2020
00033a  fab1f181          CLZ      r1,r1                 ;2020
                  |L9.830|
00033e  1c49              ADDS     r1,r1,#1              ;2020
000340  f001011f          AND      r1,r1,#0x1f           ;2020
000344  2909              CMP      r1,#9                 ;2020
000346  d831              BHI      |L9.940|
000348  0341              LSLS     r1,r0,#13             ;2020
00034a  2900              CMP      r1,#0                 ;2020
00034c  d010              BEQ      |L9.880|
00034e  fa90f1a0          RBIT     r1,r0                 ;2020
000352  fab1f181          CLZ      r1,r1                 ;2020
                  |L9.854|
000356  f1010101          ADD      r1,r1,#1              ;2020
00035a  f001011f          AND      r1,r1,#0x1f           ;2020
00035e  fa08f801          LSL      r8,r8,r1              ;2020
000362  d108              BNE      |L9.886|
000364  f3c06184          UBFX     r1,r0,#26,#5          ;2020
000368  e009              B        |L9.894|
                  |L9.874|
00036a  f3c06184          UBFX     r1,r0,#26,#5          ;2020
00036e  e7e6              B        |L9.830|
                  |L9.880|
000370  f3c06184          UBFX     r1,r0,#26,#5          ;2020
000374  e7ef              B        |L9.854|
                  |L9.886|
000376  fa90f1a0          RBIT     r1,r0                 ;2020
00037a  fab1f181          CLZ      r1,r1                 ;2020
                  |L9.894|
00037e  f1010101          ADD      r1,r1,#1              ;2020
000382  f001011f          AND      r1,r1,#0x1f           ;2020
000386  ea486181          ORR      r1,r8,r1,LSL #26      ;2020
00038a  d102              BNE      |L9.914|
00038c  f3c06084          UBFX     r0,r0,#26,#5          ;2020
000390  e003              B        |L9.922|
                  |L9.914|
000392  fa90f0a0          RBIT     r0,r0                 ;2020
000396  fab0f080          CLZ      r0,r0                 ;2020
                  |L9.922|
00039a  f1000001          ADD      r0,r0,#1              ;2020
00039e  f000001f          AND      r0,r0,#0x1f           ;2020
0003a2  eb000040          ADD      r0,r0,r0,LSL #1       ;2020
0003a6  ea415100          ORR      r1,r1,r0,LSL #20      ;2020
0003aa  e032              B        |L9.1042|
                  |L9.940|
0003ac  ea4f3140          LSL      r1,r0,#13             ;2020
0003b0  2900              CMP      r1,#0                 ;2020
0003b2  d00d              BEQ      |L9.976|
0003b4  fa90f1a0          RBIT     r1,r0                 ;2020
0003b8  fab1f181          CLZ      r1,r1                 ;2020
                  |L9.956|
0003bc  f1010101          ADD      r1,r1,#1              ;2020
0003c0  f001011f          AND      r1,r1,#0x1f           ;2020
0003c4  fa08f801          LSL      r8,r8,r1              ;2020
0003c8  d105              BNE      |L9.982|
0003ca  f3c06184          UBFX     r1,r0,#26,#5          ;2020
0003ce  e006              B        |L9.990|
                  |L9.976|
0003d0  f3c06184          UBFX     r1,r0,#26,#5          ;2020
0003d4  e7f2              B        |L9.956|
                  |L9.982|
0003d6  fa90f1a0          RBIT     r1,r0                 ;2020
0003da  fab1f181          CLZ      r1,r1                 ;2020
                  |L9.990|
0003de  f1010101          ADD      r1,r1,#1              ;2020
0003e2  f001011f          AND      r1,r1,#0x1f           ;2020
0003e6  ea486181          ORR      r1,r8,r1,LSL #26      ;2020
0003ea  d102              BNE      |L9.1010|
0003ec  f3c06084          UBFX     r0,r0,#26,#5          ;2020
0003f0  e003              B        |L9.1018|
                  |L9.1010|
0003f2  fa90f0a0          RBIT     r0,r0                 ;2020
0003f6  fab0f080          CLZ      r0,r0                 ;2020
                  |L9.1018|
0003fa  f1000001          ADD      r0,r0,#1              ;2020
0003fe  f000001f          AND      r0,r0,#0x1f           ;2020
000402  f1a0000a          SUB      r0,r0,#0xa            ;2020
000406  eb000040          ADD      r0,r0,r0,LSL #1       ;2020
00040a  ea415000          ORR      r0,r1,r0,LSL #20      ;2020
00040e  f0407100          ORR      r1,r0,#0x2000000      ;2020
                  |L9.1042|
000412  68aa              LDR      r2,[r5,#8]            ;2020
000414  6820              LDR      r0,[r4,#0]            ;2020
000416  f7fffffe          BL       LL_ADC_SetChannelSamplingTime
                  |L9.1050|
00041a  e007              B        |L9.1068|
                  |L9.1052|
                          DCD      0x407f0000
                  |L9.1056|
                          DCD      0x82082000
                  |L9.1060|
                          DCD      0x03fff000
                  |L9.1064|
                          DCD      0x0007ffff
                  |L9.1068|
00042c  482b              LDR      r0,|L9.1244|
00042e  6829              LDR      r1,[r5,#0]            ;2032
000430  4201              TST      r1,r0                 ;2032
000432  d04e              BEQ      |L9.1234|
000434  4a2a              LDR      r2,|L9.1248|
000436  6890              LDR      r0,[r2,#8]            ;2032
000438  f00070e0          AND      r0,r0,#0x1c00000      ;2032
00043c  f8dfc0a4          LDR      r12,|L9.1252|
000440  4b29              LDR      r3,|L9.1256|
000442  4d2a              LDR      r5,|L9.1260|
000444  4561              CMP      r1,r12                ;2038
000446  d120              BNE      |L9.1162|
000448  ea5f2c00          LSLS     r12,r0,#8             ;2039
00044c  d41d              BMI      |L9.1162|
00044e  6821              LDR      r1,[r4,#0]            ;2041
000450  4299              CMP      r1,r3                 ;2041
000452  d001              BEQ      |L9.1112|
000454  42a9              CMP      r1,r5                 ;2041
000456  d13c              BNE      |L9.1234|
                  |L9.1112|
000458  f4400000          ORR      r0,r0,#0x800000       ;2043
00045c  6891              LDR      r1,[r2,#8]            ;2043
00045e  f02171e0          BIC      r1,r1,#0x1c00000      ;2043
000462  4301              ORRS     r1,r1,r0              ;2043
000464  6091              STR      r1,[r2,#8]            ;2043
000466  4822              LDR      r0,|L9.1264|
000468  4922              LDR      r1,|L9.1268|
00046a  6800              LDR      r0,[r0,#0]            ;2051  ; SystemCoreClock
00046c  fbb0f0f1          UDIV     r0,r0,r1              ;2051
000470  1c80              ADDS     r0,r0,#2              ;2051
000472  eb000040          ADD      r0,r0,r0,LSL #1       ;2051
000476  0080              LSLS     r0,r0,#2              ;2051
000478  9000              STR      r0,[sp,#0]            ;2051
00047a  e002              B        |L9.1154|
                  |L9.1148|
00047c  9800              LDR      r0,[sp,#0]            ;2054
00047e  1e40              SUBS     r0,r0,#1              ;2054
000480  9000              STR      r0,[sp,#0]            ;2054
                  |L9.1154|
000482  9800              LDR      r0,[sp,#0]            ;2052
000484  2800              CMP      r0,#0                 ;2052
000486  d1f9              BNE      |L9.1148|
000488  e023              B        |L9.1234|
                  |L9.1162|
00048a  f8dfc06c          LDR      r12,|L9.1272|
00048e  4561              CMP      r1,r12                ;2058
000490  d10f              BNE      |L9.1202|
000492  ea5f1cc0          LSLS     r12,r0,#7             ;2059
000496  d40c              BMI      |L9.1202|
000498  6821              LDR      r1,[r4,#0]            ;2061
00049a  4299              CMP      r1,r3                 ;2061
00049c  d001              BEQ      |L9.1186|
00049e  42a9              CMP      r1,r5                 ;2061
0004a0  d117              BNE      |L9.1234|
                  |L9.1186|
0004a2  f0407080          ORR      r0,r0,#0x1000000      ;2063
0004a6  6891              LDR      r1,[r2,#8]            ;2063
0004a8  f02171e0          BIC      r1,r1,#0x1c00000      ;2063
0004ac  4301              ORRS     r1,r1,r0              ;2063
0004ae  6091              STR      r1,[r2,#8]            ;2063
0004b0  e00f              B        |L9.1234|
                  |L9.1202|
0004b2  f06f4500          MVN      r5,#0x80000000        ;2067
0004b6  42e9              CMN      r1,r5                 ;2067
0004b8  d10b              BNE      |L9.1234|
0004ba  0241              LSLS     r1,r0,#9              ;2068
0004bc  d409              BMI      |L9.1234|
0004be  6821              LDR      r1,[r4,#0]            ;2070
0004c0  4299              CMP      r1,r3                 ;2070
0004c2  d106              BNE      |L9.1234|
0004c4  f4400080          ORR      r0,r0,#0x400000       ;2072
0004c8  6891              LDR      r1,[r2,#8]            ;2072
0004ca  f02171e0          BIC      r1,r1,#0x1c00000      ;2072
0004ce  4301              ORRS     r1,r1,r0              ;2072
0004d0  6091              STR      r1,[r2,#8]            ;2072
                  |L9.1234|
0004d2  f8846054          STRB     r6,[r4,#0x54]         ;2083
0004d6  4638              MOV      r0,r7                 ;2086
0004d8  e5ae              B        |L9.56|
;;;2088   
                          ENDP

0004da  0000              DCW      0x0000
                  |L9.1244|
                          DCD      0x80080000
                  |L9.1248|
                          DCD      0x50040300
                  |L9.1252|
                          DCD      0xc7520000
                  |L9.1256|
                          DCD      0x50040000
                  |L9.1260|
                          DCD      0x50040200
                  |L9.1264|
                          DCD      SystemCoreClock
                  |L9.1268|
                          DCD      0x00030d40
                  |L9.1272|
                          DCD      0xcb840000

                          AREA ||i.HAL_ADCEx_InjectedConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedConvCpltCallback PROC
;;;1188     */
;;;1189   __weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1190   {
;;;1191     /* Prevent unused argument(s) compilation warning */
;;;1192     UNUSED(hadc);
;;;1193   
;;;1194     /* NOTE : This function should not be modified. When the callback is needed,
;;;1195               function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
;;;1196     */
;;;1197   }
;;;1198   
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedGetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedGetValue PROC
;;;1153     */
;;;1154   uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef *hadc, uint32_t InjectedRank)
000000  6800              LDR      r0,[r0,#0]
;;;1155   {
;;;1156     uint32_t tmp_jdr;
;;;1157   
;;;1158     /* Check the parameters */
;;;1159     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1160     assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
;;;1161   
;;;1162     /* Get ADC converted value */
;;;1163     switch (InjectedRank)
000002  f5b17f87          CMP      r1,#0x10e
000006  d00f              BEQ      |L11.40|
000008  f5b17f05          CMP      r1,#0x214
00000c  d009              BEQ      |L11.34|
00000e  f5a17140          SUB      r1,r1,#0x300
000012  391a              SUBS     r1,r1,#0x1a
000014  d002              BEQ      |L11.28|
;;;1164     {
;;;1165       case ADC_INJECTED_RANK_4:
;;;1166         tmp_jdr = hadc->Instance->JDR4;
;;;1167         break;
;;;1168       case ADC_INJECTED_RANK_3:
;;;1169         tmp_jdr = hadc->Instance->JDR3;
;;;1170         break;
;;;1171       case ADC_INJECTED_RANK_2:
;;;1172         tmp_jdr = hadc->Instance->JDR2;
;;;1173         break;
;;;1174       case ADC_INJECTED_RANK_1:
;;;1175       default:
;;;1176         tmp_jdr = hadc->Instance->JDR1;
000016  f8d00080          LDR      r0,[r0,#0x80]
;;;1177         break;
;;;1178     }
;;;1179   
;;;1180     /* Return ADC converted value */
;;;1181     return tmp_jdr;
;;;1182   }
00001a  4770              BX       lr
                  |L11.28|
00001c  f8d0008c          LDR      r0,[r0,#0x8c]         ;1166
000020  4770              BX       lr
                  |L11.34|
000022  f8d00088          LDR      r0,[r0,#0x88]         ;1169
000026  4770              BX       lr
                  |L11.40|
000028  f8d00084          LDR      r0,[r0,#0x84]         ;1172
00002c  4770              BX       lr
;;;1183   
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedPollForConversion||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedPollForConversion PROC
;;;482      */
;;;483    HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;484    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4839              LDR      r0,|L12.240|
00000a  6880              LDR      r0,[r0,#8]
00000c  f000071f          AND      r7,r0,#0x1f
;;;485      uint32_t tickstart;
;;;486      uint32_t tmp_Flag_End;
;;;487      uint32_t tmp_adc_inj_is_trigger_source_sw_start;
;;;488      uint32_t tmp_adc_reg_is_trigger_source_sw_start;
;;;489      uint32_t tmp_cfgr;
;;;490    #if defined(ADC_MULTIMODE_SUPPORT)
;;;491      const ADC_TypeDef *tmpADC_Master;
;;;492      uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;493    #endif
;;;494    
;;;495      /* Check the parameters */
;;;496      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;497    
;;;498      /* If end of sequence selected */
;;;499      if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
000010  6960              LDR      r0,[r4,#0x14]
000012  2808              CMP      r0,#8
000014  d004              BEQ      |L12.32|
;;;500      {
;;;501        tmp_Flag_End = ADC_FLAG_JEOS;
;;;502      }
;;;503      else /* end of conversion selected */
;;;504      {
;;;505        tmp_Flag_End = ADC_FLAG_JEOC;
000016  2520              MOVS     r5,#0x20
                  |L12.24|
;;;506      }
;;;507    
;;;508      /* Get timeout */
;;;509      tickstart = HAL_GetTick();
000018  f7fffffe          BL       HAL_GetTick
00001c  4680              MOV      r8,r0
;;;510    
;;;511      /* Wait until End of Conversion or Sequence flag is raised */
;;;512      while ((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
00001e  e018              B        |L12.82|
                  |L12.32|
000020  2540              MOVS     r5,#0x40              ;501
000022  e7f9              B        |L12.24|
                  |L12.36|
;;;513      {
;;;514        /* Check if timeout is disabled (set to infinite wait) */
;;;515        if (Timeout != HAL_MAX_DELAY)
000024  1c70              ADDS     r0,r6,#1
000026  d014              BEQ      |L12.82|
;;;516        {
;;;517          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
000028  f7fffffe          BL       HAL_GetTick
00002c  eba00008          SUB      r0,r0,r8
000030  42b0              CMP      r0,r6
000032  d800              BHI      |L12.54|
000034  b96e              CBNZ     r6,|L12.82|
                  |L12.54|
;;;518          {
;;;519            /* New check to avoid false timeout detection in case of preemption */
;;;520            if ((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
000036  6820              LDR      r0,[r4,#0]
000038  6800              LDR      r0,[r0,#0]
00003a  4228              TST      r0,r5
00003c  d109              BNE      |L12.82|
;;;521            {
;;;522              /* Update ADC state machine to timeout */
;;;523              SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
00003e  6da0              LDR      r0,[r4,#0x58]
000040  f0400004          ORR      r0,r0,#4
000044  65a0              STR      r0,[r4,#0x58]
;;;524    
;;;525              /* Process unlocked */
;;;526              __HAL_UNLOCK(hadc);
000046  2000              MOVS     r0,#0
000048  f8840054          STRB     r0,[r4,#0x54]
;;;527    
;;;528              return HAL_TIMEOUT;
00004c  2003              MOVS     r0,#3
                  |L12.78|
;;;529            }
;;;530          }
;;;531        }
;;;532      }
;;;533    
;;;534      /* Retrieve ADC configuration */
;;;535      tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
;;;536      tmp_adc_reg_is_trigger_source_sw_start = LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance);
;;;537      /* Get relevant register CFGR in ADC instance of ADC master or slave  */
;;;538      /* in function of multimode state (for devices with multimode         */
;;;539      /* available).                                                        */
;;;540    #if defined(ADC_MULTIMODE_SUPPORT)
;;;541      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;542          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;543          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
;;;544          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
;;;545         )
;;;546      {
;;;547        tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;548      }
;;;549      else
;;;550      {
;;;551        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
;;;552        tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
;;;553      }
;;;554    #else
;;;555      tmp_cfgr = READ_REG(hadc->Instance->CFGR);
;;;556    #endif
;;;557    
;;;558      /* Update ADC state machine */
;;;559      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
;;;560    
;;;561      /* Determine whether any further conversion upcoming on group injected      */
;;;562      /* by external trigger or by automatic injected conversion                  */
;;;563      /* from group regular.                                                      */
;;;564      if ((tmp_adc_inj_is_trigger_source_sw_start != 0UL)            ||
;;;565          ((READ_BIT(tmp_cfgr, ADC_CFGR_JAUTO) == 0UL)      &&
;;;566           ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
;;;567            (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) == 0UL))))
;;;568      {
;;;569        /* Check whether end of sequence is reached */
;;;570        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
;;;571        {
;;;572          /* Particular case if injected contexts queue is enabled:             */
;;;573          /* when the last context has been fully processed, JSQR is reset      */
;;;574          /* by the hardware. Even if no injected conversion is planned to come */
;;;575          /* (queue empty, triggers are ignored), it can start again            */
;;;576          /* immediately after setting a new context (JADSTART is still set).   */
;;;577          /* Therefore, state of HAL ADC injected group is kept to busy.        */
;;;578          if (READ_BIT(tmp_cfgr, ADC_CFGR_JQM) == 0UL)
;;;579          {
;;;580            /* Set ADC state */
;;;581            CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
;;;582    
;;;583            if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
;;;584            {
;;;585              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;586            }
;;;587          }
;;;588        }
;;;589      }
;;;590    
;;;591      /* Clear polled flag */
;;;592      if (tmp_Flag_End == ADC_FLAG_JEOS)
;;;593      {
;;;594        /* Clear end of sequence JEOS flag of injected group if low power feature */
;;;595        /* "LowPowerAutoWait " is disabled, to not interfere with this feature.   */
;;;596        /* For injected groups, no new conversion will start before JEOS is       */
;;;597        /* cleared.                                                               */
;;;598        if (READ_BIT(tmp_cfgr, ADC_CFGR_AUTDLY) == 0UL)
;;;599        {
;;;600          __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
;;;601        }
;;;602      }
;;;603      else
;;;604      {
;;;605        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
;;;606      }
;;;607    
;;;608      /* Return API HAL status */
;;;609      return HAL_OK;
;;;610    }
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L12.82|
000052  6820              LDR      r0,[r4,#0]            ;512
000054  6800              LDR      r0,[r0,#0]            ;512
000056  4228              TST      r0,r5                 ;512
000058  d0e4              BEQ      |L12.36|
00005a  6820              LDR      r0,[r4,#0]            ;535
00005c  6cc1              LDR      r1,[r0,#0x4c]         ;535
00005e  f0110fc0          TST      r1,#0xc0              ;535
000062  d00c              BEQ      |L12.126|
000064  2600              MOVS     r6,#0                 ;535
                  |L12.102|
000066  68c1              LDR      r1,[r0,#0xc]          ;535
000068  f4116f40          TST      r1,#0xc00             ;535
00006c  d009              BEQ      |L12.130|
00006e  2300              MOVS     r3,#0                 ;535
                  |L12.112|
000070  f8dfc080          LDR      r12,|L12.244|
000074  4920              LDR      r1,|L12.248|
000076  4560              CMP      r0,r12                ;541
000078  d105              BNE      |L12.134|
00007a  460a              MOV      r2,r1                 ;541
00007c  e004              B        |L12.136|
                  |L12.126|
00007e  2601              MOVS     r6,#1                 ;541
000080  e7f1              B        |L12.102|
                  |L12.130|
000082  2301              MOVS     r3,#1                 ;541
000084  e7f4              B        |L12.112|
                  |L12.134|
000086  4602              MOV      r2,r0                 ;541
                  |L12.136|
000088  4282              CMP      r2,r0                 ;541
00008a  d00e              BEQ      |L12.170|
00008c  b16f              CBZ      r7,|L12.170|
00008e  2f06              CMP      r7,#6                 ;543
000090  d00b              BEQ      |L12.170|
000092  2f07              CMP      r7,#7                 ;544
000094  d009              BEQ      |L12.170|
000096  4560              CMP      r0,r12                ;551
000098  d000              BEQ      |L12.156|
00009a  4601              MOV      r1,r0                 ;551
                  |L12.156|
00009c  68c9              LDR      r1,[r1,#0xc]          ;552
                  |L12.158|
00009e  6da2              LDR      r2,[r4,#0x58]         ;559
0000a0  f4425200          ORR      r2,r2,#0x2000         ;559
0000a4  65a2              STR      r2,[r4,#0x58]         ;559
0000a6  b93e              CBNZ     r6,|L12.184|
0000a8  e001              B        |L12.174|
                  |L12.170|
0000aa  68c1              LDR      r1,[r0,#0xc]          ;547
0000ac  e7f7              B        |L12.158|
                  |L12.174|
0000ae  018a              LSLS     r2,r1,#6              ;565
0000b0  d412              BMI      |L12.216|
0000b2  b18b              CBZ      r3,|L12.216|
0000b4  048a              LSLS     r2,r1,#18             ;567
0000b6  d40f              BMI      |L12.216|
                  |L12.184|
0000b8  6802              LDR      r2,[r0,#0]            ;570
0000ba  0652              LSLS     r2,r2,#25             ;570
0000bc  d50c              BPL      |L12.216|
0000be  028a              LSLS     r2,r1,#10             ;578
0000c0  d40a              BMI      |L12.216|
0000c2  6da2              LDR      r2,[r4,#0x58]         ;581
0000c4  f4225280          BIC      r2,r2,#0x1000         ;581
0000c8  65a2              STR      r2,[r4,#0x58]         ;581
0000ca  6da2              LDR      r2,[r4,#0x58]         ;583
0000cc  05d2              LSLS     r2,r2,#23             ;583
0000ce  d403              BMI      |L12.216|
0000d0  6da2              LDR      r2,[r4,#0x58]         ;585
0000d2  f0420201          ORR      r2,r2,#1              ;585
0000d6  65a2              STR      r2,[r4,#0x58]         ;585
                  |L12.216|
0000d8  2d40              CMP      r5,#0x40              ;592
0000da  d003              BEQ      |L12.228|
0000dc  2120              MOVS     r1,#0x20              ;605
0000de  6001              STR      r1,[r0,#0]            ;605
                  |L12.224|
0000e0  2000              MOVS     r0,#0                 ;609
0000e2  e7b4              B        |L12.78|
                  |L12.228|
0000e4  0449              LSLS     r1,r1,#17             ;598
0000e6  d4fb              BMI      |L12.224|
0000e8  2160              MOVS     r1,#0x60              ;600
0000ea  6001              STR      r1,[r0,#0]            ;600
0000ec  e7f8              B        |L12.224|
;;;611    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L12.240|
                          DCD      0x50040300
                  |L12.244|
                          DCD      0x50040100
                  |L12.248|
                          DCD      0x50040000

                          AREA ||i.HAL_ADCEx_InjectedQueueOverflowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedQueueOverflowCallback PROC
;;;1207     */
;;;1208   __weak void HAL_ADCEx_InjectedQueueOverflowCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1209   {
;;;1210     /* Prevent unused argument(s) compilation warning */
;;;1211     UNUSED(hadc);
;;;1212   
;;;1213     /* NOTE : This function should not be modified. When the callback is needed,
;;;1214               function HAL_ADCEx_InjectedQueueOverflowCallback must be implemented in the user file.
;;;1215     */
;;;1216   }
;;;1217   
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedStart||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart PROC
;;;278      */
;;;279    HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef *hadc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;280    {
000004  4604              MOV      r4,r0
000006  4836              LDR      r0,|L14.224|
000008  6880              LDR      r0,[r0,#8]
00000a  f000051f          AND      r5,r0,#0x1f
;;;281      HAL_StatusTypeDef tmp_hal_status;
;;;282      uint32_t tmp_config_injected_queue;
;;;283    #if defined(ADC_MULTIMODE_SUPPORT)
;;;284      uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;285    #endif
;;;286    
;;;287      /* Check the parameters */
;;;288      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;289    
;;;290      if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
000014  b110              CBZ      r0,|L14.28|
;;;291      {
;;;292        return HAL_BUSY;
000016  2002              MOVS     r0,#2
                  |L14.24|
;;;293      }
;;;294      else
;;;295      {
;;;296        /* In case of software trigger detection enabled, JQDIS must be set
;;;297          (which can be done only if ADSTART and JADSTART are both cleared).
;;;298           If JQDIS is not set at that point, returns an error
;;;299           - since software trigger detection is disabled. User needs to
;;;300           resort to HAL_ADCEx_DisableInjectedQueue() API to set JQDIS.
;;;301           - or (if JQDIS is intentionally reset) since JEXTEN = 0 which means
;;;302             the queue is empty */
;;;303        tmp_config_injected_queue = READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);
;;;304    
;;;305        if ((READ_BIT(hadc->Instance->JSQR, ADC_JSQR_JEXTEN) == 0UL)
;;;306            && (tmp_config_injected_queue == 0UL)
;;;307           )
;;;308        {
;;;309          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;310          return HAL_ERROR;
;;;311        }
;;;312    
;;;313        /* Process locked */
;;;314        __HAL_LOCK(hadc);
;;;315    
;;;316        /* Enable the ADC peripheral */
;;;317        tmp_hal_status = ADC_Enable(hadc);
;;;318    
;;;319        /* Start conversion if ADC is effectively enabled */
;;;320        if (tmp_hal_status == HAL_OK)
;;;321        {
;;;322          /* Check if a regular conversion is ongoing */
;;;323          if ((hadc->State & HAL_ADC_STATE_REG_BUSY) != 0UL)
;;;324          {
;;;325            /* Reset ADC error code field related to injected conversions only */
;;;326            CLEAR_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
;;;327          }
;;;328          else
;;;329          {
;;;330            /* Set ADC error code to none */
;;;331            ADC_CLEAR_ERRORCODE(hadc);
;;;332          }
;;;333    
;;;334          /* Set ADC state                                                        */
;;;335          /* - Clear state bitfield related to injected group conversion results  */
;;;336          /* - Set state bitfield related to injected operation                   */
;;;337          ADC_STATE_CLR_SET(hadc->State,
;;;338                            HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
;;;339                            HAL_ADC_STATE_INJ_BUSY);
;;;340    
;;;341    #if defined(ADC_MULTIMODE_SUPPORT)
;;;342          /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
;;;343            - if ADC instance is master or if multimode feature is not available
;;;344            - if multimode setting is disabled (ADC instance slave in independent mode) */
;;;345          if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;346              || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;347             )
;;;348          {
;;;349            CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;350          }
;;;351    #endif
;;;352    
;;;353          /* Clear ADC group injected group conversion flag */
;;;354          /* (To ensure of no unknown state from potential previous ADC operations) */
;;;355          __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
;;;356    
;;;357          /* Process unlocked */
;;;358          /* Unlock before starting ADC conversions: in case of potential         */
;;;359          /* interruption, to let the process to ADC IRQ Handler.                 */
;;;360          __HAL_UNLOCK(hadc);
;;;361    
;;;362          /* Enable conversion of injected group, if automatic injected conversion  */
;;;363          /* is disabled.                                                           */
;;;364          /* If software start has been selected, conversion starts immediately.    */
;;;365          /* If external trigger has been selected, conversion will start at next   */
;;;366          /* trigger event.                                                         */
;;;367          /* Case of multimode enabled (when multimode feature is available):       */
;;;368          /* if ADC is slave,                                                       */
;;;369          /*    - ADC is enabled only (conversion is not started),                  */
;;;370          /*    - if multimode only concerns regular conversion, ADC is enabled     */
;;;371          /*     and conversion is started.                                         */
;;;372          /* If ADC is master or independent,                                       */
;;;373          /*    - ADC is enabled and conversion is started.                         */
;;;374    #if defined(ADC_MULTIMODE_SUPPORT)
;;;375          if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;376              || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;377              || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
;;;378              || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
;;;379             )
;;;380          {
;;;381            /* ADC instance is not a multimode slave instance with multimode injected conversions enabled */
;;;382            if (LL_ADC_INJ_GetTrigAuto(hadc->Instance) == LL_ADC_INJ_TRIG_INDEPENDENT)
;;;383            {
;;;384              LL_ADC_INJ_StartConversion(hadc->Instance);
;;;385            }
;;;386          }
;;;387          else
;;;388          {
;;;389            /* ADC instance is not a multimode slave instance with multimode injected conversions enabled */
;;;390            SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;391          }
;;;392    #else
;;;393          if (LL_ADC_INJ_GetTrigAuto(hadc->Instance) == LL_ADC_INJ_TRIG_INDEPENDENT)
;;;394          {
;;;395            /* Start ADC group injected conversion */
;;;396            LL_ADC_INJ_StartConversion(hadc->Instance);
;;;397          }
;;;398    #endif
;;;399    
;;;400        }
;;;401        else
;;;402        {
;;;403          /* Process unlocked */
;;;404          __HAL_UNLOCK(hadc);
;;;405        }
;;;406    
;;;407        /* Return function status */
;;;408        return tmp_hal_status;
;;;409      }
;;;410    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L14.28|
00001c  6820              LDR      r0,[r4,#0]            ;303
00001e  68c1              LDR      r1,[r0,#0xc]          ;303
000020  f0014100          AND      r1,r1,#0x80000000     ;303
000024  6cc0              LDR      r0,[r0,#0x4c]         ;305
000026  f0100fc0          TST      r0,#0xc0              ;305
00002a  d100              BNE      |L14.46|
00002c  b181              CBZ      r1,|L14.80|
                  |L14.46|
00002e  f8940054          LDRB     r0,[r4,#0x54]         ;314
000032  2801              CMP      r0,#1                 ;314
000034  d012              BEQ      |L14.92|
000036  2001              MOVS     r0,#1                 ;314
000038  f8840054          STRB     r0,[r4,#0x54]         ;314
00003c  4620              MOV      r0,r4                 ;317
00003e  f7fffffe          BL       ADC_Enable
000042  4602              MOV      r2,r0                 ;317
000044  2600              MOVS     r6,#0                 ;320
000046  b15a              CBZ      r2,|L14.96|
000048  f8846054          STRB     r6,[r4,#0x54]         ;404
                  |L14.76|
00004c  4610              MOV      r0,r2                 ;408
00004e  e7e3              B        |L14.24|
                  |L14.80|
000050  6da0              LDR      r0,[r4,#0x58]         ;309
000052  f0400020          ORR      r0,r0,#0x20           ;309
000056  65a0              STR      r0,[r4,#0x58]         ;309
000058  2001              MOVS     r0,#1                 ;310
00005a  e7dd              B        |L14.24|
                  |L14.92|
00005c  2002              MOVS     r0,#2                 ;314
00005e  e7db              B        |L14.24|
                  |L14.96|
000060  6da0              LDR      r0,[r4,#0x58]         ;323
000062  05c0              LSLS     r0,r0,#23             ;323
000064  d504              BPL      |L14.112|
000066  6de0              LDR      r0,[r4,#0x5c]         ;326
000068  f0200008          BIC      r0,r0,#8              ;326
00006c  65e0              STR      r0,[r4,#0x5c]         ;326
00006e  e000              B        |L14.114|
                  |L14.112|
000070  65e6              STR      r6,[r4,#0x5c]         ;331
                  |L14.114|
000072  6da0              LDR      r0,[r4,#0x58]         ;337
000074  f2420101          MOV      r1,#0x2001            ;337
000078  4388              BICS     r0,r0,r1              ;337
00007a  f4405080          ORR      r0,r0,#0x1000         ;337
00007e  65a0              STR      r0,[r4,#0x58]         ;337
000080  4f18              LDR      r7,|L14.228|
000082  6821              LDR      r1,[r4,#0]            ;345
000084  4b18              LDR      r3,|L14.232|
000086  42b9              CMP      r1,r7                 ;345
000088  d101              BNE      |L14.142|
00008a  4618              MOV      r0,r3                 ;345
00008c  e000              B        |L14.144|
                  |L14.142|
00008e  4608              MOV      r0,r1                 ;345
                  |L14.144|
000090  4288              CMP      r0,r1                 ;345
000092  d000              BEQ      |L14.150|
000094  b91d              CBNZ     r5,|L14.158|
                  |L14.150|
000096  6da0              LDR      r0,[r4,#0x58]         ;349
000098  f4201080          BIC      r0,r0,#0x100000       ;349
00009c  65a0              STR      r0,[r4,#0x58]         ;349
                  |L14.158|
00009e  2060              MOVS     r0,#0x60              ;355
0000a0  6008              STR      r0,[r1,#0]            ;355
0000a2  f8846054          STRB     r6,[r4,#0x54]         ;360
0000a6  6820              LDR      r0,[r4,#0]            ;375
0000a8  42b8              CMP      r0,r7                 ;375
0000aa  d000              BEQ      |L14.174|
0000ac  4603              MOV      r3,r0                 ;375
                  |L14.174|
0000ae  4283              CMP      r3,r0                 ;375
0000b0  d009              BEQ      |L14.198|
0000b2  b145              CBZ      r5,|L14.198|
0000b4  2d06              CMP      r5,#6                 ;377
0000b6  d006              BEQ      |L14.198|
0000b8  2d07              CMP      r5,#7                 ;378
0000ba  d004              BEQ      |L14.198|
0000bc  6da0              LDR      r0,[r4,#0x58]         ;390
0000be  f4401080          ORR      r0,r0,#0x100000       ;390
0000c2  65a0              STR      r0,[r4,#0x58]         ;390
0000c4  e7c2              B        |L14.76|
                  |L14.198|
0000c6  68c1              LDR      r1,[r0,#0xc]          ;390
0000c8  f0017100          AND      r1,r1,#0x2000000      ;390
0000cc  2900              CMP      r1,#0                 ;382
0000ce  d1bd              BNE      |L14.76|
0000d0  6881              LDR      r1,[r0,#8]            ;382
0000d2  4b06              LDR      r3,|L14.236|
0000d4  4019              ANDS     r1,r1,r3              ;382
0000d6  f0410108          ORR      r1,r1,#8              ;382
0000da  6081              STR      r1,[r0,#8]            ;382
0000dc  e7b6              B        |L14.76|
;;;411    
                          ENDP

0000de  0000              DCW      0x0000
                  |L14.224|
                          DCD      0x50040300
                  |L14.228|
                          DCD      0x50040100
                  |L14.232|
                          DCD      0x50040000
                  |L14.236|
                          DCD      0x7fffffc0

                          AREA ||i.HAL_ADCEx_InjectedStart_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart_IT PROC
;;;623      */
;;;624    HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef *hadc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;625    {
000004  4604              MOV      r4,r0
000006  4847              LDR      r0,|L15.292|
000008  6880              LDR      r0,[r0,#8]
00000a  f000051f          AND      r5,r0,#0x1f
;;;626      HAL_StatusTypeDef tmp_hal_status;
;;;627      uint32_t tmp_config_injected_queue;
;;;628    #if defined(ADC_MULTIMODE_SUPPORT)
;;;629      uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
;;;630    #endif
;;;631    
;;;632      /* Check the parameters */
;;;633      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;634    
;;;635      if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
000014  b110              CBZ      r0,|L15.28|
;;;636      {
;;;637        return HAL_BUSY;
000016  2002              MOVS     r0,#2
                  |L15.24|
;;;638      }
;;;639      else
;;;640      {
;;;641        /* In case of software trigger detection enabled, JQDIS must be set
;;;642          (which can be done only if ADSTART and JADSTART are both cleared).
;;;643           If JQDIS is not set at that point, returns an error
;;;644           - since software trigger detection is disabled. User needs to
;;;645           resort to HAL_ADCEx_DisableInjectedQueue() API to set JQDIS.
;;;646           - or (if JQDIS is intentionally reset) since JEXTEN = 0 which means
;;;647             the queue is empty */
;;;648        tmp_config_injected_queue = READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);
;;;649    
;;;650        if ((READ_BIT(hadc->Instance->JSQR, ADC_JSQR_JEXTEN) == 0UL)
;;;651            && (tmp_config_injected_queue == 0UL)
;;;652           )
;;;653        {
;;;654          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;655          return HAL_ERROR;
;;;656        }
;;;657    
;;;658        /* Process locked */
;;;659        __HAL_LOCK(hadc);
;;;660    
;;;661        /* Enable the ADC peripheral */
;;;662        tmp_hal_status = ADC_Enable(hadc);
;;;663    
;;;664        /* Start conversion if ADC is effectively enabled */
;;;665        if (tmp_hal_status == HAL_OK)
;;;666        {
;;;667          /* Check if a regular conversion is ongoing */
;;;668          if ((hadc->State & HAL_ADC_STATE_REG_BUSY) != 0UL)
;;;669          {
;;;670            /* Reset ADC error code field related to injected conversions only */
;;;671            CLEAR_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
;;;672          }
;;;673          else
;;;674          {
;;;675            /* Set ADC error code to none */
;;;676            ADC_CLEAR_ERRORCODE(hadc);
;;;677          }
;;;678    
;;;679          /* Set ADC state                                                        */
;;;680          /* - Clear state bitfield related to injected group conversion results  */
;;;681          /* - Set state bitfield related to injected operation                   */
;;;682          ADC_STATE_CLR_SET(hadc->State,
;;;683                            HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
;;;684                            HAL_ADC_STATE_INJ_BUSY);
;;;685    
;;;686    #if defined(ADC_MULTIMODE_SUPPORT)
;;;687          /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
;;;688            - if ADC instance is master or if multimode feature is not available
;;;689            - if multimode setting is disabled (ADC instance slave in independent mode) */
;;;690          if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;691              || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;692             )
;;;693          {
;;;694            CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;695          }
;;;696    #endif
;;;697    
;;;698          /* Clear ADC group injected group conversion flag */
;;;699          /* (To ensure of no unknown state from potential previous ADC operations) */
;;;700          __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
;;;701    
;;;702          /* Process unlocked */
;;;703          /* Unlock before starting ADC conversions: in case of potential         */
;;;704          /* interruption, to let the process to ADC IRQ Handler.                 */
;;;705          __HAL_UNLOCK(hadc);
;;;706    
;;;707          /* Enable ADC Injected context queue overflow interrupt if this feature   */
;;;708          /* is enabled.                                                            */
;;;709          if ((hadc->Instance->CFGR & ADC_CFGR_JQM) != 0UL)
;;;710          {
;;;711            __HAL_ADC_ENABLE_IT(hadc, ADC_FLAG_JQOVF);
;;;712          }
;;;713    
;;;714          /* Enable ADC end of conversion interrupt */
;;;715          switch (hadc->Init.EOCSelection)
;;;716          {
;;;717            case ADC_EOC_SEQ_CONV:
;;;718              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
;;;719              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
;;;720              break;
;;;721            /* case ADC_EOC_SINGLE_CONV */
;;;722            default:
;;;723              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
;;;724              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
;;;725              break;
;;;726          }
;;;727    
;;;728          /* Enable conversion of injected group, if automatic injected conversion  */
;;;729          /* is disabled.                                                           */
;;;730          /* If software start has been selected, conversion starts immediately.    */
;;;731          /* If external trigger has been selected, conversion will start at next   */
;;;732          /* trigger event.                                                         */
;;;733          /* Case of multimode enabled (when multimode feature is available):       */
;;;734          /* if ADC is slave,                                                       */
;;;735          /*    - ADC is enabled only (conversion is not started),                  */
;;;736          /*    - if multimode only concerns regular conversion, ADC is enabled     */
;;;737          /*     and conversion is started.                                         */
;;;738          /* If ADC is master or independent,                                       */
;;;739          /*    - ADC is enabled and conversion is started.                         */
;;;740    #if defined(ADC_MULTIMODE_SUPPORT)
;;;741          if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
;;;742              || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
;;;743              || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
;;;744              || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
;;;745             )
;;;746          {
;;;747            /* ADC instance is not a multimode slave instance with multimode injected conversions enabled */
;;;748            if (LL_ADC_INJ_GetTrigAuto(hadc->Instance) == LL_ADC_INJ_TRIG_INDEPENDENT)
;;;749            {
;;;750              LL_ADC_INJ_StartConversion(hadc->Instance);
;;;751            }
;;;752          }
;;;753          else
;;;754          {
;;;755            /* ADC instance is not a multimode slave instance with multimode injected conversions enabled */
;;;756            SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;757          }
;;;758    #else
;;;759          if (LL_ADC_INJ_GetTrigAuto(hadc->Instance) == LL_ADC_INJ_TRIG_INDEPENDENT)
;;;760          {
;;;761            /* Start ADC group injected conversion */
;;;762            LL_ADC_INJ_StartConversion(hadc->Instance);
;;;763          }
;;;764    #endif
;;;765    
;;;766        }
;;;767        else
;;;768        {
;;;769          /* Process unlocked */
;;;770          __HAL_UNLOCK(hadc);
;;;771        }
;;;772    
;;;773        /* Return function status */
;;;774        return tmp_hal_status;
;;;775      }
;;;776    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L15.28|
00001c  6820              LDR      r0,[r4,#0]            ;648
00001e  68c1              LDR      r1,[r0,#0xc]          ;648
000020  f0014100          AND      r1,r1,#0x80000000     ;648
000024  6cc0              LDR      r0,[r0,#0x4c]         ;650
000026  f0100fc0          TST      r0,#0xc0              ;650
00002a  d100              BNE      |L15.46|
00002c  b181              CBZ      r1,|L15.80|
                  |L15.46|
00002e  f8940054          LDRB     r0,[r4,#0x54]         ;659
000032  2801              CMP      r0,#1                 ;659
000034  d012              BEQ      |L15.92|
000036  2001              MOVS     r0,#1                 ;659
000038  f8840054          STRB     r0,[r4,#0x54]         ;659
00003c  4620              MOV      r0,r4                 ;662
00003e  f7fffffe          BL       ADC_Enable
000042  4601              MOV      r1,r0                 ;662
000044  2700              MOVS     r7,#0                 ;665
000046  b159              CBZ      r1,|L15.96|
000048  f8847054          STRB     r7,[r4,#0x54]         ;770
                  |L15.76|
00004c  4608              MOV      r0,r1                 ;774
00004e  e7e3              B        |L15.24|
                  |L15.80|
000050  6da0              LDR      r0,[r4,#0x58]         ;654
000052  f0400020          ORR      r0,r0,#0x20           ;654
000056  65a0              STR      r0,[r4,#0x58]         ;654
000058  2001              MOVS     r0,#1                 ;655
00005a  e7dd              B        |L15.24|
                  |L15.92|
00005c  2002              MOVS     r0,#2                 ;659
00005e  e7db              B        |L15.24|
                  |L15.96|
000060  6da0              LDR      r0,[r4,#0x58]         ;668
000062  05c0              LSLS     r0,r0,#23             ;668
000064  d504              BPL      |L15.112|
000066  6de0              LDR      r0,[r4,#0x5c]         ;671
000068  f0200008          BIC      r0,r0,#8              ;671
00006c  65e0              STR      r0,[r4,#0x5c]         ;671
00006e  e000              B        |L15.114|
                  |L15.112|
000070  65e7              STR      r7,[r4,#0x5c]         ;676
                  |L15.114|
000072  6da0              LDR      r0,[r4,#0x58]         ;682
000074  f2420201          MOV      r2,#0x2001            ;682
000078  4390              BICS     r0,r0,r2              ;682
00007a  f4405080          ORR      r0,r0,#0x1000         ;682
00007e  65a0              STR      r0,[r4,#0x58]         ;682
000080  4b29              LDR      r3,|L15.296|
000082  6820              LDR      r0,[r4,#0]            ;690
000084  4e29              LDR      r6,|L15.300|
000086  4298              CMP      r0,r3                 ;690
000088  d101              BNE      |L15.142|
00008a  4632              MOV      r2,r6                 ;690
00008c  e000              B        |L15.144|
                  |L15.142|
00008e  4602              MOV      r2,r0                 ;690
                  |L15.144|
000090  4282              CMP      r2,r0                 ;690
000092  d000              BEQ      |L15.150|
000094  b91d              CBNZ     r5,|L15.158|
                  |L15.150|
000096  6da2              LDR      r2,[r4,#0x58]         ;694
000098  f4221280          BIC      r2,r2,#0x100000       ;694
00009c  65a2              STR      r2,[r4,#0x58]         ;694
                  |L15.158|
00009e  2260              MOVS     r2,#0x60              ;700
0000a0  6002              STR      r2,[r0,#0]            ;700
0000a2  f8847054          STRB     r7,[r4,#0x54]         ;705
0000a6  6820              LDR      r0,[r4,#0]            ;709
0000a8  68c2              LDR      r2,[r0,#0xc]          ;709
0000aa  0292              LSLS     r2,r2,#10             ;709
0000ac  d503              BPL      |L15.182|
0000ae  6842              LDR      r2,[r0,#4]            ;711
0000b0  f4426280          ORR      r2,r2,#0x400          ;711
0000b4  6042              STR      r2,[r0,#4]            ;711
                  |L15.182|
0000b6  6960              LDR      r0,[r4,#0x14]         ;715
0000b8  2808              CMP      r0,#8                 ;715
0000ba  d00e              BEQ      |L15.218|
0000bc  6820              LDR      r0,[r4,#0]            ;723
0000be  6842              LDR      r2,[r0,#4]            ;723
0000c0  f0220240          BIC      r2,r2,#0x40           ;723
0000c4  6042              STR      r2,[r0,#4]            ;723
0000c6  6820              LDR      r0,[r4,#0]            ;724
0000c8  6842              LDR      r2,[r0,#4]            ;724
0000ca  f0420220          ORR      r2,r2,#0x20           ;724
0000ce  6042              STR      r2,[r0,#4]            ;724
                  |L15.208|
0000d0  6820              LDR      r0,[r4,#0]            ;741
0000d2  4298              CMP      r0,r3                 ;741
0000d4  d10c              BNE      |L15.240|
0000d6  4632              MOV      r2,r6                 ;741
0000d8  e00b              B        |L15.242|
                  |L15.218|
0000da  6820              LDR      r0,[r4,#0]            ;718
0000dc  6842              LDR      r2,[r0,#4]            ;718
0000de  f0220220          BIC      r2,r2,#0x20           ;718
0000e2  6042              STR      r2,[r0,#4]            ;718
0000e4  6820              LDR      r0,[r4,#0]            ;719
0000e6  6842              LDR      r2,[r0,#4]            ;719
0000e8  f0420240          ORR      r2,r2,#0x40           ;719
0000ec  6042              STR      r2,[r0,#4]            ;719
0000ee  e7ef              B        |L15.208|
                  |L15.240|
0000f0  4602              MOV      r2,r0                 ;741
                  |L15.242|
0000f2  4282              CMP      r2,r0                 ;741
0000f4  d009              BEQ      |L15.266|
0000f6  b145              CBZ      r5,|L15.266|
0000f8  2d06              CMP      r5,#6                 ;743
0000fa  d006              BEQ      |L15.266|
0000fc  2d07              CMP      r5,#7                 ;744
0000fe  d004              BEQ      |L15.266|
000100  6da0              LDR      r0,[r4,#0x58]         ;756
000102  f4401080          ORR      r0,r0,#0x100000       ;756
000106  65a0              STR      r0,[r4,#0x58]         ;756
000108  e7a0              B        |L15.76|
                  |L15.266|
00010a  68c2              LDR      r2,[r0,#0xc]          ;756
00010c  f0027200          AND      r2,r2,#0x2000000      ;756
000110  2a00              CMP      r2,#0                 ;748
000112  d19b              BNE      |L15.76|
000114  6882              LDR      r2,[r0,#8]            ;748
000116  4b06              LDR      r3,|L15.304|
000118  401a              ANDS     r2,r2,r3              ;748
00011a  f0420208          ORR      r2,r2,#8              ;748
00011e  6082              STR      r2,[r0,#8]            ;748
000120  e794              B        |L15.76|
;;;777    
                          ENDP

000122  0000              DCW      0x0000
                  |L15.292|
                          DCD      0x50040300
                  |L15.296|
                          DCD      0x50040100
                  |L15.300|
                          DCD      0x50040000
                  |L15.304|
                          DCD      0x7fffffc0

                          AREA ||i.HAL_ADCEx_InjectedStop||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop PROC
;;;427      */
;;;428    HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;429    {
000002  4604              MOV      r4,r0
;;;430      HAL_StatusTypeDef tmp_hal_status;
;;;431    
;;;432      /* Check the parameters */
;;;433      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;434    
;;;435      /* Process locked */
;;;436      __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L16.32|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;437    
;;;438      /* 1. Stop potential conversion on going on injected group only. */
;;;439      tmp_hal_status = ADC_ConversionStop(hadc, ADC_INJECTED_GROUP);
000012  2102              MOVS     r1,#2
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  4605              MOV      r5,r0
00001c  b115              CBZ      r5,|L16.36|
00001e  e009              B        |L16.52|
                  |L16.32|
000020  2002              MOVS     r0,#2                 ;436
;;;440    
;;;441      /* Disable ADC peripheral if injected conversions are effectively stopped   */
;;;442      /* and if no conversion on regular group is on-going                       */
;;;443      if (tmp_hal_status == HAL_OK)
;;;444      {
;;;445        if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
;;;446        {
;;;447          /* 2. Disable the ADC peripheral */
;;;448          tmp_hal_status = ADC_Disable(hadc);
;;;449    
;;;450          /* Check if ADC is effectively disabled */
;;;451          if (tmp_hal_status == HAL_OK)
;;;452          {
;;;453            /* Set ADC state */
;;;454            ADC_STATE_CLR_SET(hadc->State,
;;;455                              HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;456                              HAL_ADC_STATE_READY);
;;;457          }
;;;458        }
;;;459        /* Conversion on injected group is stopped, but ADC not disabled since    */
;;;460        /* conversion on regular group is still running.                          */
;;;461        else
;;;462        {
;;;463          /* Set ADC state */
;;;464          CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
;;;465        }
;;;466      }
;;;467    
;;;468      /* Process unlocked */
;;;469      __HAL_UNLOCK(hadc);
;;;470    
;;;471      /* Return function status */
;;;472      return tmp_hal_status;
;;;473    }
000022  bd70              POP      {r4-r6,pc}
                  |L16.36|
000024  6820              LDR      r0,[r4,#0]            ;445
000026  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00002a  b140              CBZ      r0,|L16.62|
00002c  6da0              LDR      r0,[r4,#0x58]         ;464
00002e  f4205080          BIC      r0,r0,#0x1000         ;464
000032  65a0              STR      r0,[r4,#0x58]         ;464
                  |L16.52|
000034  2000              MOVS     r0,#0                 ;469
000036  f8840054          STRB     r0,[r4,#0x54]         ;469
00003a  4628              MOV      r0,r5                 ;472
00003c  bd70              POP      {r4-r6,pc}
                  |L16.62|
00003e  4620              MOV      r0,r4                 ;448
000040  f7fffffe          BL       ADC_Disable
000044  4605              MOV      r5,r0                 ;448
000046  2d00              CMP      r5,#0                 ;451
000048  d1f4              BNE      |L16.52|
00004a  6da0              LDR      r0,[r4,#0x58]         ;454
00004c  f4205088          BIC      r0,r0,#0x1100         ;454
000050  f0400001          ORR      r0,r0,#1              ;454
000054  65a0              STR      r0,[r4,#0x58]         ;454
000056  e7ed              B        |L16.52|
;;;474    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedStop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop_IT PROC
;;;796      */
;;;797    HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;798    {
000002  4604              MOV      r4,r0
;;;799      HAL_StatusTypeDef tmp_hal_status;
;;;800    
;;;801      /* Check the parameters */
;;;802      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;803    
;;;804      /* Process locked */
;;;805      __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L17.32|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;806    
;;;807      /* 1. Stop potential conversion on going on injected group only. */
;;;808      tmp_hal_status = ADC_ConversionStop(hadc, ADC_INJECTED_GROUP);
000012  2102              MOVS     r1,#2
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  4605              MOV      r5,r0
00001c  b115              CBZ      r5,|L17.36|
00001e  e00e              B        |L17.62|
                  |L17.32|
000020  2002              MOVS     r0,#2                 ;805
;;;809    
;;;810      /* Disable ADC peripheral if injected conversions are effectively stopped   */
;;;811      /* and if no conversion on the other group (regular group) is intended to   */
;;;812      /* continue.                                                                */
;;;813      if (tmp_hal_status == HAL_OK)
;;;814      {
;;;815        /* Disable ADC end of conversion interrupt for injected channels */
;;;816        __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_JEOC | ADC_IT_JEOS | ADC_FLAG_JQOVF));
;;;817    
;;;818        if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
;;;819        {
;;;820          /* 2. Disable the ADC peripheral */
;;;821          tmp_hal_status = ADC_Disable(hadc);
;;;822    
;;;823          /* Check if ADC is effectively disabled */
;;;824          if (tmp_hal_status == HAL_OK)
;;;825          {
;;;826            /* Set ADC state */
;;;827            ADC_STATE_CLR_SET(hadc->State,
;;;828                              HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;829                              HAL_ADC_STATE_READY);
;;;830          }
;;;831        }
;;;832        /* Conversion on injected group is stopped, but ADC not disabled since    */
;;;833        /* conversion on regular group is still running.                          */
;;;834        else
;;;835        {
;;;836          /* Set ADC state */
;;;837          CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
;;;838        }
;;;839      }
;;;840    
;;;841      /* Process unlocked */
;;;842      __HAL_UNLOCK(hadc);
;;;843    
;;;844      /* Return function status */
;;;845      return tmp_hal_status;
;;;846    }
000022  bd70              POP      {r4-r6,pc}
                  |L17.36|
000024  6820              LDR      r0,[r4,#0]            ;816
000026  6841              LDR      r1,[r0,#4]            ;816
000028  f421618c          BIC      r1,r1,#0x460          ;816
00002c  6041              STR      r1,[r0,#4]            ;816
00002e  6820              LDR      r0,[r4,#0]            ;818
000030  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000034  b140              CBZ      r0,|L17.72|
000036  6da0              LDR      r0,[r4,#0x58]         ;837
000038  f4205080          BIC      r0,r0,#0x1000         ;837
00003c  65a0              STR      r0,[r4,#0x58]         ;837
                  |L17.62|
00003e  2000              MOVS     r0,#0                 ;842
000040  f8840054          STRB     r0,[r4,#0x54]         ;842
000044  4628              MOV      r0,r5                 ;845
000046  bd70              POP      {r4-r6,pc}
                  |L17.72|
000048  4620              MOV      r0,r4                 ;821
00004a  f7fffffe          BL       ADC_Disable
00004e  4605              MOV      r5,r0                 ;821
000050  2d00              CMP      r5,#0                 ;824
000052  d1f4              BNE      |L17.62|
000054  6da0              LDR      r0,[r4,#0x58]         ;827
000056  f4205088          BIC      r0,r0,#0x1100         ;827
00005a  f0400001          ORR      r0,r0,#1              ;827
00005e  65a0              STR      r0,[r4,#0x58]         ;827
000060  e7ed              B        |L17.62|
;;;847    
                          ENDP


                          AREA ||i.HAL_ADCEx_LevelOutOfWindow2Callback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_LevelOutOfWindow2Callback PROC
;;;1222     */
;;;1223   __weak void HAL_ADCEx_LevelOutOfWindow2Callback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1224   {
;;;1225     /* Prevent unused argument(s) compilation warning */
;;;1226     UNUSED(hadc);
;;;1227   
;;;1228     /* NOTE : This function should not be modified. When the callback is needed,
;;;1229               function HAL_ADCEx_LevelOutOfWindow2Callback must be implemented in the user file.
;;;1230     */
;;;1231   }
;;;1232   
                          ENDP


                          AREA ||i.HAL_ADCEx_LevelOutOfWindow3Callback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_LevelOutOfWindow3Callback PROC
;;;1237     */
;;;1238   __weak void HAL_ADCEx_LevelOutOfWindow3Callback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1239   {
;;;1240     /* Prevent unused argument(s) compilation warning */
;;;1241     UNUSED(hadc);
;;;1242   
;;;1243     /* NOTE : This function should not be modified. When the callback is needed,
;;;1244               function HAL_ADCEx_LevelOutOfWindow3Callback must be implemented in the user file.
;;;1245     */
;;;1246   }
;;;1247   
                          ENDP


                          AREA ||i.HAL_ADCEx_MultiModeConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeConfigChannel PROC
;;;2105     */
;;;2106   HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2107   {
000004  b09a              SUB      sp,sp,#0x68
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;2108     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
00000a  f04f0900          MOV      r9,#0
;;;2109     ADC_Common_TypeDef *tmpADC_Common;
;;;2110     ADC_HandleTypeDef tmphadcSlave;
;;;2111     uint32_t tmphadcSlave_conversion_on_going;
;;;2112   
;;;2113     /* Check the parameters */
;;;2114     assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;2115     assert_param(IS_ADC_MULTIMODE(multimode->Mode));
;;;2116     if (multimode->Mode != ADC_MODE_INDEPENDENT)
;;;2117     {
;;;2118       assert_param(IS_ADC_DMA_ACCESS_MULTIMODE(multimode->DMAAccessMode));
;;;2119       assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
;;;2120     }
;;;2121   
;;;2122     /* Process locked */
;;;2123     __HAL_LOCK(hadc);
00000e  f8940054          LDRB     r0,[r4,#0x54]
000012  2801              CMP      r0,#1
000014  d00e              BEQ      |L20.52|
000016  2001              MOVS     r0,#1
000018  f8840054          STRB     r0,[r4,#0x54]
;;;2124   
;;;2125     /* Temporary handle minimum initialization */
;;;2126     __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
00001c  2600              MOVS     r6,#0
00001e  9616              STR      r6,[sp,#0x58]
;;;2127     ADC_CLEAR_ERRORCODE(&tmphadcSlave);
000020  9617              STR      r6,[sp,#0x5c]
;;;2128   
;;;2129     ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
000022  4f35              LDR      r7,|L20.248|
000024  6820              LDR      r0,[r4,#0]
000026  f8df80d4          LDR      r8,|L20.252|
00002a  42b8              CMP      r0,r7
00002c  d106              BNE      |L20.60|
00002e  f8cd8000          STR      r8,[sp,#0]
000032  e004              B        |L20.62|
                  |L20.52|
000034  2002              MOVS     r0,#2                 ;2123
                  |L20.54|
;;;2130   
;;;2131     if (tmphadcSlave.Instance == NULL)
;;;2132     {
;;;2133       /* Update ADC state machine to error */
;;;2134       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;2135   
;;;2136       /* Process unlocked */
;;;2137       __HAL_UNLOCK(hadc);
;;;2138   
;;;2139       return HAL_ERROR;
;;;2140     }
;;;2141   
;;;2142     /* Parameters update conditioned to ADC state:                              */
;;;2143     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;2144     /* conversion on going on regular group:                                    */
;;;2145     /*  - Multimode DMA configuration                                           */
;;;2146     /*  - Multimode DMA mode                                                    */
;;;2147     tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
;;;2148     if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
;;;2149         && (tmphadcSlave_conversion_on_going == 0UL))
;;;2150     {
;;;2151       /* Pointer to the common control register */
;;;2152       tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
;;;2153   
;;;2154       /* If multimode is selected, configure all multimode parameters.          */
;;;2155       /* Otherwise, reset multimode parameters (can be used in case of          */
;;;2156       /* transition from multimode to independent mode).                        */
;;;2157       if (multimode->Mode != ADC_MODE_INDEPENDENT)
;;;2158       {
;;;2159         MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
;;;2160                    multimode->DMAAccessMode |
;;;2161                    ADC_CCR_MULTI_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
;;;2162   
;;;2163         /* Parameters that can be updated only when ADC is disabled:                */
;;;2164         /*  - Multimode mode selection                                              */
;;;2165         /*  - Multimode delay                                                       */
;;;2166         /*    Note: Delay range depends on selected resolution:                     */
;;;2167         /*      from 1 to 12 clock cycles for 12 bits                               */
;;;2168         /*      from 1 to 10 clock cycles for 10 bits,                              */
;;;2169         /*      from 1 to 8 clock cycles for 8 bits                                 */
;;;2170         /*      from 1 to 6 clock cycles for 6 bits                                 */
;;;2171         /*    If a higher delay is selected, it will be clipped to maximum delay    */
;;;2172         /*    range                                                                 */
;;;2173         if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
;;;2174         {
;;;2175           MODIFY_REG(tmpADC_Common->CCR,
;;;2176                      ADC_CCR_DUAL |
;;;2177                      ADC_CCR_DELAY,
;;;2178                      multimode->Mode |
;;;2179                      multimode->TwoSamplingDelay
;;;2180                     );
;;;2181         }
;;;2182       }
;;;2183       else /* ADC_MODE_INDEPENDENT */
;;;2184       {
;;;2185         CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
;;;2186   
;;;2187         /* Parameters that can be updated only when ADC is disabled:                */
;;;2188         /*  - Multimode mode selection                                              */
;;;2189         /*  - Multimode delay                                                       */
;;;2190         if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
;;;2191         {
;;;2192           CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
;;;2193         }
;;;2194       }
;;;2195     }
;;;2196     /* If one of the ADC sharing the same common group is enabled, no update    */
;;;2197     /* could be done on neither of the multimode structure parameters.          */
;;;2198     else
;;;2199     {
;;;2200       /* Update ADC state machine to error */
;;;2201       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;2202   
;;;2203       tmp_hal_status = HAL_ERROR;
;;;2204     }
;;;2205   
;;;2206     /* Process unlocked */
;;;2207     __HAL_UNLOCK(hadc);
;;;2208   
;;;2209     /* Return function status */
;;;2210     return tmp_hal_status;
;;;2211   }
000036  b01a              ADD      sp,sp,#0x68
000038  e8bd87f0          POP      {r4-r10,pc}
                  |L20.60|
00003c  9600              STR      r6,[sp,#0]            ;2129
                  |L20.62|
00003e  9800              LDR      r0,[sp,#0]            ;2131
000040  b140              CBZ      r0,|L20.84|
000042  9800              LDR      r0,[sp,#0]            ;2147
000044  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000048  4682              MOV      r10,r0                ;2147
00004a  6820              LDR      r0,[r4,#0]            ;2148
00004c  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000050  b140              CBZ      r0,|L20.100|
000052  e00a              B        |L20.106|
                  |L20.84|
000054  6da0              LDR      r0,[r4,#0x58]         ;2134
000056  f0400020          ORR      r0,r0,#0x20           ;2134
00005a  65a0              STR      r0,[r4,#0x58]         ;2134
00005c  f8846054          STRB     r6,[r4,#0x54]         ;2137
000060  2001              MOVS     r0,#1                 ;2139
000062  e7e8              B        |L20.54|
                  |L20.100|
000064  f1ba0f00          CMP      r10,#0                ;2149
000068  d009              BEQ      |L20.126|
                  |L20.106|
00006a  6da0              LDR      r0,[r4,#0x58]         ;2201
00006c  f0400020          ORR      r0,r0,#0x20           ;2201
000070  65a0              STR      r0,[r4,#0x58]         ;2201
000072  f04f0901          MOV      r9,#1                 ;2203
                  |L20.118|
000076  f8846054          STRB     r6,[r4,#0x54]         ;2207
00007a  4648              MOV      r0,r9                 ;2210
00007c  e7db              B        |L20.54|
                  |L20.126|
00007e  4820              LDR      r0,|L20.256|
000080  4b20              LDR      r3,|L20.260|
000082  6829              LDR      r1,[r5,#0]            ;2157
000084  f640721f          MOV      r2,#0xf1f             ;2175
000088  b301              CBZ      r1,|L20.204|
00008a  6881              LDR      r1,[r0,#8]            ;2159
00008c  f894c030          LDRB     r12,[r4,#0x30]        ;2159
000090  f4214160          BIC      r1,r1,#0xe000         ;2159
000094  ea41314c          ORR      r1,r1,r12,LSL #13     ;2159
000098  f8d5c004          LDR      r12,[r5,#4]           ;2159
00009c  ea41010c          ORR      r1,r1,r12             ;2159
0000a0  6081              STR      r1,[r0,#8]            ;2159
0000a2  68b9              LDR      r1,[r7,#8]            ;2159
0000a4  f3c10100          UBFX     r1,r1,#0,#1           ;2159
0000a8  f8d87008          LDR      r7,[r8,#8]            ;2159
0000ac  f3c70700          UBFX     r7,r7,#0,#1           ;2159
0000b0  4339              ORRS     r1,r1,r7              ;2173
0000b2  689b              LDR      r3,[r3,#8]            ;2173
0000b4  f3c30300          UBFX     r3,r3,#0,#1           ;2173
0000b8  4319              ORRS     r1,r1,r3              ;2173
0000ba  d1dc              BNE      |L20.118|
0000bc  68ab              LDR      r3,[r5,#8]            ;2175
0000be  6829              LDR      r1,[r5,#0]            ;2175
0000c0  4319              ORRS     r1,r1,r3              ;2175
0000c2  6883              LDR      r3,[r0,#8]            ;2175
0000c4  4393              BICS     r3,r3,r2              ;2175
0000c6  4319              ORRS     r1,r1,r3              ;2175
0000c8  6081              STR      r1,[r0,#8]            ;2175
0000ca  e7d4              B        |L20.118|
                  |L20.204|
0000cc  6881              LDR      r1,[r0,#8]            ;2185
0000ce  f4214160          BIC      r1,r1,#0xe000         ;2185
0000d2  6081              STR      r1,[r0,#8]            ;2185
0000d4  68b9              LDR      r1,[r7,#8]            ;2185
0000d6  f3c10100          UBFX     r1,r1,#0,#1           ;2185
0000da  f8d85008          LDR      r5,[r8,#8]            ;2185
0000de  f3c50500          UBFX     r5,r5,#0,#1           ;2185
0000e2  4329              ORRS     r1,r1,r5              ;2190
0000e4  689b              LDR      r3,[r3,#8]            ;2190
0000e6  f3c30300          UBFX     r3,r3,#0,#1           ;2190
0000ea  4319              ORRS     r1,r1,r3              ;2190
0000ec  d1c3              BNE      |L20.118|
0000ee  6881              LDR      r1,[r0,#8]            ;2192
0000f0  4391              BICS     r1,r1,r2              ;2192
0000f2  6081              STR      r1,[r0,#8]            ;2192
0000f4  e7bf              B        |L20.118|
;;;2212   #endif /* ADC_MULTIMODE_SUPPORT */
                          ENDP

0000f6  0000              DCW      0x0000
                  |L20.248|
                          DCD      0x50040000
                  |L20.252|
                          DCD      0x50040100
                  |L20.256|
                          DCD      0x50040300
                  |L20.260|
                          DCD      0x50040200

                          AREA ||i.HAL_ADCEx_MultiModeGetValue||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeGetValue PROC
;;;1106     */
;;;1107   uint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef *hadc)
000000  4801              LDR      r0,|L21.8|
;;;1108   {
;;;1109     const ADC_Common_TypeDef *tmpADC_Common;
;;;1110   
;;;1111     /* Check the parameters */
;;;1112     assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;1113   
;;;1114     /* Prevent unused argument(s) compilation warning if no assert_param check */
;;;1115     /* and possible no usage in __LL_ADC_COMMON_INSTANCE() below               */
;;;1116     UNUSED(hadc);
;;;1117   
;;;1118     /* Pointer to the common control register  */
;;;1119     tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
;;;1120   
;;;1121     /* Return the multi mode conversion value */
;;;1122     return tmpADC_Common->CDR;
000002  68c0              LDR      r0,[r0,#0xc]
;;;1123   }
000004  4770              BX       lr
;;;1124   #endif /* ADC_MULTIMODE_SUPPORT */
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x50040300

                          AREA ||i.HAL_ADCEx_MultiModeStart_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStart_DMA PROC
;;;863      */
;;;864    HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;865    {
000002  b09b              SUB      sp,sp,#0x6c
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;866      HAL_StatusTypeDef tmp_hal_status;
;;;867      ADC_HandleTypeDef tmphadcSlave;
;;;868      ADC_Common_TypeDef *tmpADC_Common;
;;;869    
;;;870      /* Check the parameters */
;;;871      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;872      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;873      assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;874      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;875    
;;;876      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000010  b110              CBZ      r0,|L22.24|
;;;877      {
;;;878        return HAL_BUSY;
000012  2002              MOVS     r0,#2
                  |L22.20|
;;;879      }
;;;880      else
;;;881      {
;;;882        /* Process locked */
;;;883        __HAL_LOCK(hadc);
;;;884    
;;;885        /* Temporary handle minimum initialization */
;;;886        __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
;;;887        ADC_CLEAR_ERRORCODE(&tmphadcSlave);
;;;888    
;;;889        /* Set a temporary handle of the ADC slave associated to the ADC master   */
;;;890        ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
;;;891    
;;;892        if (tmphadcSlave.Instance == NULL)
;;;893        {
;;;894          /* Set ADC state */
;;;895          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;896    
;;;897          /* Process unlocked */
;;;898          __HAL_UNLOCK(hadc);
;;;899    
;;;900          return HAL_ERROR;
;;;901        }
;;;902    
;;;903        /* Enable the ADC peripherals: master and slave (in case if not already   */
;;;904        /* enabled previously)                                                    */
;;;905        tmp_hal_status = ADC_Enable(hadc);
;;;906        if (tmp_hal_status == HAL_OK)
;;;907        {
;;;908          tmp_hal_status = ADC_Enable(&tmphadcSlave);
;;;909        }
;;;910    
;;;911        /* Start multimode conversion of ADCs pair */
;;;912        if (tmp_hal_status == HAL_OK)
;;;913        {
;;;914          /* Set ADC state */
;;;915          ADC_STATE_CLR_SET(hadc->State,
;;;916                            (HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP),
;;;917                            HAL_ADC_STATE_REG_BUSY);
;;;918    
;;;919          /* Set ADC error code to none */
;;;920          ADC_CLEAR_ERRORCODE(hadc);
;;;921    
;;;922          /* Set the DMA transfer complete callback */
;;;923          hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;924    
;;;925          /* Set the DMA half transfer complete callback */
;;;926          hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;927    
;;;928          /* Set the DMA error callback */
;;;929          hadc->DMA_Handle->XferErrorCallback = ADC_DMAError ;
;;;930    
;;;931          /* Pointer to the common control register  */
;;;932          tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
;;;933    
;;;934          /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
;;;935          /* start (in case of SW start):                                           */
;;;936    
;;;937          /* Clear regular group conversion flag and overrun flag */
;;;938          /* (To ensure of no unknown state from potential previous ADC operations) */
;;;939          __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
;;;940    
;;;941          /* Process unlocked */
;;;942          /* Unlock before starting ADC conversions: in case of potential         */
;;;943          /* interruption, to let the process to ADC IRQ Handler.                 */
;;;944          __HAL_UNLOCK(hadc);
;;;945    
;;;946          /* Enable ADC overrun interrupt */
;;;947          __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;948    
;;;949          /* Start the DMA channel */
;;;950          tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&tmpADC_Common->CDR, (uint32_t)pData, Length);
;;;951    
;;;952          /* Enable conversion of regular group.                                    */
;;;953          /* If software start has been selected, conversion starts immediately.    */
;;;954          /* If external trigger has been selected, conversion will start at next   */
;;;955          /* trigger event.                                                         */
;;;956          /* Start ADC group regular conversion */
;;;957          LL_ADC_REG_StartConversion(hadc->Instance);
;;;958        }
;;;959        else
;;;960        {
;;;961          /* Process unlocked */
;;;962          __HAL_UNLOCK(hadc);
;;;963        }
;;;964    
;;;965        /* Return function status */
;;;966        return tmp_hal_status;
;;;967      }
;;;968    }
000014  b01b              ADD      sp,sp,#0x6c
000016  bdf0              POP      {r4-r7,pc}
                  |L22.24|
000018  f8940054          LDRB     r0,[r4,#0x54]         ;883
00001c  2801              CMP      r0,#1                 ;883
00001e  d00c              BEQ      |L22.58|
000020  2001              MOVS     r0,#1                 ;883
000022  f8840054          STRB     r0,[r4,#0x54]         ;883
000026  2500              MOVS     r5,#0                 ;886
000028  9517              STR      r5,[sp,#0x5c]         ;886
00002a  9518              STR      r5,[sp,#0x60]         ;887
00002c  4923              LDR      r1,|L22.188|
00002e  6820              LDR      r0,[r4,#0]            ;890
000030  4288              CMP      r0,r1                 ;890
000032  d104              BNE      |L22.62|
000034  4822              LDR      r0,|L22.192|
000036  9001              STR      r0,[sp,#4]            ;890
000038  e002              B        |L22.64|
                  |L22.58|
00003a  2002              MOVS     r0,#2                 ;883
00003c  e7ea              B        |L22.20|
                  |L22.62|
00003e  9501              STR      r5,[sp,#4]            ;890
                  |L22.64|
000040  9801              LDR      r0,[sp,#4]            ;892
000042  b120              CBZ      r0,|L22.78|
000044  4620              MOV      r0,r4                 ;905
000046  f7fffffe          BL       ADC_Enable
00004a  b140              CBZ      r0,|L22.94|
00004c  e00a              B        |L22.100|
                  |L22.78|
00004e  6da0              LDR      r0,[r4,#0x58]         ;895
000050  f0400020          ORR      r0,r0,#0x20           ;895
000054  65a0              STR      r0,[r4,#0x58]         ;895
000056  f8845054          STRB     r5,[r4,#0x54]         ;898
00005a  2001              MOVS     r0,#1                 ;900
00005c  e7da              B        |L22.20|
                  |L22.94|
00005e  a801              ADD      r0,sp,#4              ;908
000060  f7fffffe          BL       ADC_Enable
                  |L22.100|
000064  b110              CBZ      r0,|L22.108|
000066  f8845054          STRB     r5,[r4,#0x54]         ;962
00006a  e7d3              B        |L22.20|
                  |L22.108|
00006c  6da0              LDR      r0,[r4,#0x58]         ;915
00006e  f6406101          MOV      r1,#0xe01             ;915
000072  4388              BICS     r0,r0,r1              ;915
000074  f4407080          ORR      r0,r0,#0x100          ;915
000078  65a0              STR      r0,[r4,#0x58]         ;915
00007a  65e5              STR      r5,[r4,#0x5c]         ;920
00007c  6d21              LDR      r1,[r4,#0x50]         ;923
00007e  4811              LDR      r0,|L22.196|
000080  62c8              STR      r0,[r1,#0x2c]         ;923
000082  6d21              LDR      r1,[r4,#0x50]         ;926
000084  4810              LDR      r0,|L22.200|
000086  6308              STR      r0,[r1,#0x30]         ;926
000088  6d21              LDR      r1,[r4,#0x50]         ;929
00008a  4810              LDR      r0,|L22.204|
00008c  6348              STR      r0,[r1,#0x34]         ;929
00008e  6821              LDR      r1,[r4,#0]            ;939
000090  201c              MOVS     r0,#0x1c              ;939
000092  6008              STR      r0,[r1,#0]            ;939
000094  f8845054          STRB     r5,[r4,#0x54]         ;944
000098  6820              LDR      r0,[r4,#0]            ;947
00009a  6841              LDR      r1,[r0,#4]            ;947
00009c  f0410110          ORR      r1,r1,#0x10           ;947
0000a0  6041              STR      r1,[r0,#4]            ;947
0000a2  463b              MOV      r3,r7                 ;950
0000a4  4632              MOV      r2,r6                 ;950
0000a6  490a              LDR      r1,|L22.208|
0000a8  6d20              LDR      r0,[r4,#0x50]         ;950
0000aa  f7fffffe          BL       HAL_DMA_Start_IT
0000ae  6821              LDR      r1,[r4,#0]            ;957
0000b0  688a              LDR      r2,[r1,#8]            ;957
0000b2  4b08              LDR      r3,|L22.212|
0000b4  401a              ANDS     r2,r2,r3              ;957
0000b6  1d12              ADDS     r2,r2,#4              ;957
0000b8  608a              STR      r2,[r1,#8]            ;957
0000ba  e7ab              B        |L22.20|
;;;969    
                          ENDP

                  |L22.188|
                          DCD      0x50040000
                  |L22.192|
                          DCD      0x50040100
                  |L22.196|
                          DCD      ADC_DMAConvCplt
                  |L22.200|
                          DCD      ADC_DMAHalfConvCplt
                  |L22.204|
                          DCD      ADC_DMAError
                  |L22.208|
                          DCD      0x5004030c
                  |L22.212|
                          DCD      0x7fffffc0

                          AREA ||i.HAL_ADCEx_MultiModeStop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStop_DMA PROC
;;;982      */
;;;983    HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef *hadc)
000000  b5f0              PUSH     {r4-r7,lr}
;;;984    {
000002  b09b              SUB      sp,sp,#0x6c
000004  4604              MOV      r4,r0
;;;985      HAL_StatusTypeDef tmp_hal_status;
;;;986      uint32_t tickstart;
;;;987      ADC_HandleTypeDef tmphadcSlave;
;;;988      uint32_t tmphadcSlave_conversion_on_going;
;;;989      HAL_StatusTypeDef tmphadcSlave_disable_status;
;;;990    
;;;991      /* Check the parameters */
;;;992      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;993    
;;;994      /* Process locked */
;;;995      __HAL_LOCK(hadc);
000006  f8940054          LDRB     r0,[r4,#0x54]
00000a  2801              CMP      r0,#1
00000c  d00a              BEQ      |L23.36|
00000e  2001              MOVS     r0,#1
000010  f8840054          STRB     r0,[r4,#0x54]
;;;996    
;;;997    
;;;998      /* 1. Stop potential multimode conversion on going, on regular and injected groups */
;;;999      tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
000014  2103              MOVS     r1,#3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       ADC_ConversionStop
00001c  4605              MOV      r5,r0
;;;1000   
;;;1001     /* Disable ADC peripheral if conversions are effectively stopped */
;;;1002     if (tmp_hal_status == HAL_OK)
00001e  2600              MOVS     r6,#0
000020  b11d              CBZ      r5,|L23.42|
000022  e05e              B        |L23.226|
                  |L23.36|
000024  2002              MOVS     r0,#2                 ;995
                  |L23.38|
;;;1003     {
;;;1004       /* Temporary handle minimum initialization */
;;;1005       __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
;;;1006       ADC_CLEAR_ERRORCODE(&tmphadcSlave);
;;;1007   
;;;1008       /* Set a temporary handle of the ADC slave associated to the ADC master   */
;;;1009       ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
;;;1010   
;;;1011       if (tmphadcSlave.Instance == NULL)
;;;1012       {
;;;1013         /* Update ADC state machine to error */
;;;1014         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1015   
;;;1016         /* Process unlocked */
;;;1017         __HAL_UNLOCK(hadc);
;;;1018   
;;;1019         return HAL_ERROR;
;;;1020       }
;;;1021   
;;;1022       /* Procedure to disable the ADC peripheral: wait for conversions          */
;;;1023       /* effectively stopped (ADC master and ADC slave), then disable ADC       */
;;;1024   
;;;1025       /* 1. Wait for ADC conversion completion for ADC master and ADC slave */
;;;1026       tickstart = HAL_GetTick();
;;;1027   
;;;1028       tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
;;;1029       while ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 1UL)
;;;1030              || (tmphadcSlave_conversion_on_going == 1UL)
;;;1031             )
;;;1032       {
;;;1033         if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
;;;1034         {
;;;1035           /* New check to avoid false timeout detection in case of preemption */
;;;1036           tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
;;;1037           if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 1UL)
;;;1038               || (tmphadcSlave_conversion_on_going == 1UL)
;;;1039              )
;;;1040           {
;;;1041             /* Update ADC state machine to error */
;;;1042             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;1043   
;;;1044             /* Process unlocked */
;;;1045             __HAL_UNLOCK(hadc);
;;;1046   
;;;1047             return HAL_ERROR;
;;;1048           }
;;;1049         }
;;;1050   
;;;1051         tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
;;;1052       }
;;;1053   
;;;1054       /* Disable the DMA channel (in case of DMA in circular mode or stop       */
;;;1055       /* while DMA transfer is on going)                                        */
;;;1056       /* Note: DMA channel of ADC slave should be stopped after this function   */
;;;1057       /*       with HAL_ADC_Stop_DMA() API.                                     */
;;;1058       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1059   
;;;1060       /* Check if DMA channel effectively disabled */
;;;1061       if (tmp_hal_status == HAL_ERROR)
;;;1062       {
;;;1063         /* Update ADC state machine to error */
;;;1064         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;1065       }
;;;1066   
;;;1067       /* Disable ADC overrun interrupt */
;;;1068       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;1069   
;;;1070       /* 2. Disable the ADC peripherals: master and slave */
;;;1071       /* Update "tmp_hal_status" only if DMA channel disabling passed, to keep in */
;;;1072       /* memory a potential failing status.                                     */
;;;1073       if (tmp_hal_status == HAL_OK)
;;;1074       {
;;;1075         tmphadcSlave_disable_status = ADC_Disable(&tmphadcSlave);
;;;1076         if ((ADC_Disable(hadc) == HAL_OK)           &&
;;;1077             (tmphadcSlave_disable_status == HAL_OK))
;;;1078         {
;;;1079           tmp_hal_status = HAL_OK;
;;;1080         }
;;;1081       }
;;;1082       else
;;;1083       {
;;;1084         /* In case of error, attempt to disable ADC master and slave without status assert */
;;;1085         (void) ADC_Disable(hadc);
;;;1086         (void) ADC_Disable(&tmphadcSlave);
;;;1087       }
;;;1088   
;;;1089       /* Set ADC state (ADC master) */
;;;1090       ADC_STATE_CLR_SET(hadc->State,
;;;1091                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1092                         HAL_ADC_STATE_READY);
;;;1093     }
;;;1094   
;;;1095     /* Process unlocked */
;;;1096     __HAL_UNLOCK(hadc);
;;;1097   
;;;1098     /* Return function status */
;;;1099     return tmp_hal_status;
;;;1100   }
000026  b01b              ADD      sp,sp,#0x6c
000028  bdf0              POP      {r4-r7,pc}
                  |L23.42|
00002a  9617              STR      r6,[sp,#0x5c]         ;1005
00002c  9618              STR      r6,[sp,#0x60]         ;1006
00002e  4932              LDR      r1,|L23.248|
000030  6820              LDR      r0,[r4,#0]            ;1009
000032  4288              CMP      r0,r1                 ;1009
000034  d102              BNE      |L23.60|
000036  4831              LDR      r0,|L23.252|
000038  9001              STR      r0,[sp,#4]            ;1009
00003a  e000              B        |L23.62|
                  |L23.60|
00003c  9601              STR      r6,[sp,#4]            ;1009
                  |L23.62|
00003e  9801              LDR      r0,[sp,#4]            ;1011
000040  b138              CBZ      r0,|L23.82|
000042  f7fffffe          BL       HAL_GetTick
000046  4607              MOV      r7,r0                 ;1026
000048  9801              LDR      r0,[sp,#4]            ;1028
00004a  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00004e  4605              MOV      r5,r0                 ;1028
000050  e01b              B        |L23.138|
                  |L23.82|
000052  6da0              LDR      r0,[r4,#0x58]         ;1014
000054  f0400020          ORR      r0,r0,#0x20           ;1014
000058  65a0              STR      r0,[r4,#0x58]         ;1014
00005a  f8846054          STRB     r6,[r4,#0x54]         ;1017
00005e  2001              MOVS     r0,#1                 ;1019
000060  e7e1              B        |L23.38|
                  |L23.98|
000062  f7fffffe          BL       HAL_GetTick
000066  1bc0              SUBS     r0,r0,r7              ;1033
000068  2805              CMP      r0,#5                 ;1033
00006a  d90a              BLS      |L23.130|
00006c  9801              LDR      r0,[sp,#4]            ;1036
00006e  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000072  4605              MOV      r5,r0                 ;1036
000074  6820              LDR      r0,[r4,#0]            ;1037
000076  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00007a  2801              CMP      r0,#1                 ;1037
00007c  d013              BEQ      |L23.166|
00007e  2d01              CMP      r5,#1                 ;1038
000080  d011              BEQ      |L23.166|
                  |L23.130|
000082  9801              LDR      r0,[sp,#4]            ;1051
000084  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000088  4605              MOV      r5,r0                 ;1051
                  |L23.138|
00008a  6820              LDR      r0,[r4,#0]            ;1029
00008c  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000090  2801              CMP      r0,#1                 ;1029
000092  d0e6              BEQ      |L23.98|
000094  2d01              CMP      r5,#1                 ;1030
000096  d0e4              BEQ      |L23.98|
000098  6d20              LDR      r0,[r4,#0x50]         ;1058
00009a  f7fffffe          BL       HAL_DMA_Abort
00009e  4605              MOV      r5,r0                 ;1058
0000a0  2d01              CMP      r5,#1                 ;1061
0000a2  d008              BEQ      |L23.182|
0000a4  e00b              B        |L23.190|
                  |L23.166|
0000a6  6da0              LDR      r0,[r4,#0x58]         ;1042
0000a8  f0400010          ORR      r0,r0,#0x10           ;1042
0000ac  65a0              STR      r0,[r4,#0x58]         ;1042
0000ae  f8846054          STRB     r6,[r4,#0x54]         ;1045
0000b2  2001              MOVS     r0,#1                 ;1047
0000b4  e7b7              B        |L23.38|
                  |L23.182|
0000b6  6da0              LDR      r0,[r4,#0x58]         ;1064
0000b8  f0400040          ORR      r0,r0,#0x40           ;1064
0000bc  65a0              STR      r0,[r4,#0x58]         ;1064
                  |L23.190|
0000be  6820              LDR      r0,[r4,#0]            ;1068
0000c0  6841              LDR      r1,[r0,#4]            ;1068
0000c2  f0210110          BIC      r1,r1,#0x10           ;1068
0000c6  6041              STR      r1,[r0,#4]            ;1068
0000c8  b17d              CBZ      r5,|L23.234|
0000ca  4620              MOV      r0,r4                 ;1085
0000cc  f7fffffe          BL       ADC_Disable
0000d0  a801              ADD      r0,sp,#4              ;1086
0000d2  f7fffffe          BL       ADC_Disable
                  |L23.214|
0000d6  6da0              LDR      r0,[r4,#0x58]         ;1090
0000d8  f4205088          BIC      r0,r0,#0x1100         ;1090
0000dc  f0400001          ORR      r0,r0,#1              ;1090
0000e0  65a0              STR      r0,[r4,#0x58]         ;1090
                  |L23.226|
0000e2  f8846054          STRB     r6,[r4,#0x54]         ;1096
0000e6  4628              MOV      r0,r5                 ;1099
0000e8  e79d              B        |L23.38|
                  |L23.234|
0000ea  a801              ADD      r0,sp,#4              ;1075
0000ec  f7fffffe          BL       ADC_Disable
0000f0  4620              MOV      r0,r4                 ;1076
0000f2  f7fffffe          BL       ADC_Disable
0000f6  e7ee              B        |L23.214|
;;;1101   
                          ENDP

                  |L23.248|
                          DCD      0x50040000
                  |L23.252|
                          DCD      0x50040100

                          AREA ||i.HAL_ADCEx_RegularMultiModeStop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_RegularMultiModeStop_DMA PROC
;;;1475     */
;;;1476   HAL_StatusTypeDef HAL_ADCEx_RegularMultiModeStop_DMA(ADC_HandleTypeDef *hadc)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1477   {
000002  b09b              SUB      sp,sp,#0x6c
000004  4604              MOV      r4,r0
;;;1478     HAL_StatusTypeDef tmp_hal_status;
;;;1479     uint32_t tickstart;
;;;1480     ADC_HandleTypeDef tmphadcSlave;
;;;1481     uint32_t tmphadcSlave_conversion_on_going;
;;;1482   
;;;1483     /* Check the parameters */
;;;1484     assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;1485   
;;;1486     /* Process locked */
;;;1487     __HAL_LOCK(hadc);
000006  f8940054          LDRB     r0,[r4,#0x54]
00000a  2801              CMP      r0,#1
00000c  d00a              BEQ      |L24.36|
00000e  2001              MOVS     r0,#1
000010  f8840054          STRB     r0,[r4,#0x54]
;;;1488   
;;;1489   
;;;1490     /* 1. Stop potential multimode conversion on going, on regular groups */
;;;1491     tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_GROUP);
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       ADC_ConversionStop
00001c  4605              MOV      r5,r0
;;;1492   
;;;1493     /* Disable ADC peripheral if conversions are effectively stopped */
;;;1494     if (tmp_hal_status == HAL_OK)
00001e  2600              MOVS     r6,#0
000020  b11d              CBZ      r5,|L24.42|
000022  e06e              B        |L24.258|
                  |L24.36|
000024  2002              MOVS     r0,#2                 ;1487
                  |L24.38|
;;;1495     {
;;;1496       /* Clear HAL_ADC_STATE_REG_BUSY bit */
;;;1497       CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;1498   
;;;1499       /* Temporary handle minimum initialization */
;;;1500       __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
;;;1501       ADC_CLEAR_ERRORCODE(&tmphadcSlave);
;;;1502   
;;;1503       /* Set a temporary handle of the ADC slave associated to the ADC master   */
;;;1504       ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
;;;1505   
;;;1506       if (tmphadcSlave.Instance == NULL)
;;;1507       {
;;;1508         /* Update ADC state machine to error */
;;;1509         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1510   
;;;1511         /* Process unlocked */
;;;1512         __HAL_UNLOCK(hadc);
;;;1513   
;;;1514         return HAL_ERROR;
;;;1515       }
;;;1516   
;;;1517       /* Procedure to disable the ADC peripheral: wait for conversions          */
;;;1518       /* effectively stopped (ADC master and ADC slave), then disable ADC       */
;;;1519   
;;;1520       /* 1. Wait for ADC conversion completion for ADC master and ADC slave */
;;;1521       tickstart = HAL_GetTick();
;;;1522   
;;;1523       tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
;;;1524       while ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 1UL)
;;;1525              || (tmphadcSlave_conversion_on_going == 1UL)
;;;1526             )
;;;1527       {
;;;1528         if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
;;;1529         {
;;;1530           /* New check to avoid false timeout detection in case of preemption */
;;;1531           tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
;;;1532           if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 1UL)
;;;1533               || (tmphadcSlave_conversion_on_going == 1UL)
;;;1534              )
;;;1535           {
;;;1536             /* Update ADC state machine to error */
;;;1537             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;1538   
;;;1539             /* Process unlocked */
;;;1540             __HAL_UNLOCK(hadc);
;;;1541   
;;;1542             return HAL_ERROR;
;;;1543           }
;;;1544         }
;;;1545   
;;;1546         tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
;;;1547       }
;;;1548   
;;;1549       /* Disable the DMA channel (in case of DMA in circular mode or stop       */
;;;1550       /* while DMA transfer is on going)                                        */
;;;1551       /* Note: DMA channel of ADC slave should be stopped after this function   */
;;;1552       /* with HAL_ADCEx_RegularStop_DMA() API.                                  */
;;;1553       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1554   
;;;1555       /* Check if DMA channel effectively disabled */
;;;1556       if (tmp_hal_status != HAL_OK)
;;;1557       {
;;;1558         /* Update ADC state machine to error */
;;;1559         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;1560       }
;;;1561   
;;;1562       /* Disable ADC overrun interrupt */
;;;1563       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;1564   
;;;1565       /* 2. Disable the ADC peripherals: master and slave if no injected        */
;;;1566       /*   conversion is on-going.                                              */
;;;1567       /* Update "tmp_hal_status" only if DMA channel disabling passed, to keep in */
;;;1568       /* memory a potential failing status.                                     */
;;;1569       if (tmp_hal_status == HAL_OK)
;;;1570       {
;;;1571         if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
;;;1572         {
;;;1573           tmp_hal_status =  ADC_Disable(hadc);
;;;1574           if (tmp_hal_status == HAL_OK)
;;;1575           {
;;;1576             if (LL_ADC_INJ_IsConversionOngoing((&tmphadcSlave)->Instance) == 0UL)
;;;1577             {
;;;1578               tmp_hal_status =  ADC_Disable(&tmphadcSlave);
;;;1579             }
;;;1580           }
;;;1581         }
;;;1582   
;;;1583         if (tmp_hal_status == HAL_OK)
;;;1584         {
;;;1585           /* Both Master and Slave ADC's could be disabled. Update Master State */
;;;1586           /* Clear HAL_ADC_STATE_INJ_BUSY bit, set HAL_ADC_STATE_READY bit */
;;;1587           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY, HAL_ADC_STATE_READY);
;;;1588         }
;;;1589         else
;;;1590         {
;;;1591           /* injected (Master or Slave) conversions are still on-going,
;;;1592              no Master State change */
;;;1593         }
;;;1594       }
;;;1595     }
;;;1596   
;;;1597     /* Process unlocked */
;;;1598     __HAL_UNLOCK(hadc);
;;;1599   
;;;1600     /* Return function status */
;;;1601     return tmp_hal_status;
;;;1602   }
000026  b01b              ADD      sp,sp,#0x6c
000028  bdf0              POP      {r4-r7,pc}
                  |L24.42|
00002a  6da0              LDR      r0,[r4,#0x58]         ;1497
00002c  f4207080          BIC      r0,r0,#0x100          ;1497
000030  65a0              STR      r0,[r4,#0x58]         ;1497
000032  9617              STR      r6,[sp,#0x5c]         ;1500
000034  9618              STR      r6,[sp,#0x60]         ;1501
000036  4935              LDR      r1,|L24.268|
000038  6820              LDR      r0,[r4,#0]            ;1504
00003a  4288              CMP      r0,r1                 ;1504
00003c  d102              BNE      |L24.68|
00003e  4834              LDR      r0,|L24.272|
000040  9001              STR      r0,[sp,#4]            ;1504
000042  e000              B        |L24.70|
                  |L24.68|
000044  9601              STR      r6,[sp,#4]            ;1504
                  |L24.70|
000046  9801              LDR      r0,[sp,#4]            ;1506
000048  b138              CBZ      r0,|L24.90|
00004a  f7fffffe          BL       HAL_GetTick
00004e  4607              MOV      r7,r0                 ;1521
000050  9801              LDR      r0,[sp,#4]            ;1523
000052  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000056  4605              MOV      r5,r0                 ;1523
000058  e01b              B        |L24.146|
                  |L24.90|
00005a  6da0              LDR      r0,[r4,#0x58]         ;1509
00005c  f0400020          ORR      r0,r0,#0x20           ;1509
000060  65a0              STR      r0,[r4,#0x58]         ;1509
000062  f8846054          STRB     r6,[r4,#0x54]         ;1512
000066  2001              MOVS     r0,#1                 ;1514
000068  e7dd              B        |L24.38|
                  |L24.106|
00006a  f7fffffe          BL       HAL_GetTick
00006e  1bc0              SUBS     r0,r0,r7              ;1528
000070  2805              CMP      r0,#5                 ;1528
000072  d90a              BLS      |L24.138|
000074  9801              LDR      r0,[sp,#4]            ;1531
000076  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
00007a  4605              MOV      r5,r0                 ;1531
00007c  6820              LDR      r0,[r4,#0]            ;1532
00007e  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000082  2801              CMP      r0,#1                 ;1532
000084  d021              BEQ      |L24.202|
000086  2d01              CMP      r5,#1                 ;1533
000088  d01f              BEQ      |L24.202|
                  |L24.138|
00008a  9801              LDR      r0,[sp,#4]            ;1546
00008c  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000090  4605              MOV      r5,r0                 ;1546
                  |L24.146|
000092  6820              LDR      r0,[r4,#0]            ;1524
000094  f7fffffe          BL       LL_ADC_REG_IsConversionOngoing
000098  2801              CMP      r0,#1                 ;1524
00009a  d0e6              BEQ      |L24.106|
00009c  2d01              CMP      r5,#1                 ;1525
00009e  d0e4              BEQ      |L24.106|
0000a0  6d20              LDR      r0,[r4,#0x50]         ;1553
0000a2  f7fffffe          BL       HAL_DMA_Abort
0000a6  4605              MOV      r5,r0                 ;1553
0000a8  2d00              CMP      r5,#0                 ;1556
0000aa  d003              BEQ      |L24.180|
0000ac  6da0              LDR      r0,[r4,#0x58]         ;1559
0000ae  f0400040          ORR      r0,r0,#0x40           ;1559
0000b2  65a0              STR      r0,[r4,#0x58]         ;1559
                  |L24.180|
0000b4  6820              LDR      r0,[r4,#0]            ;1563
0000b6  6841              LDR      r1,[r0,#4]            ;1563
0000b8  f0210110          BIC      r1,r1,#0x10           ;1563
0000bc  6041              STR      r1,[r0,#4]            ;1563
0000be  d120              BNE      |L24.258|
0000c0  6820              LDR      r0,[r4,#0]            ;1571
0000c2  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
0000c6  b140              CBZ      r0,|L24.218|
0000c8  e014              B        |L24.244|
                  |L24.202|
0000ca  6da0              LDR      r0,[r4,#0x58]         ;1537
0000cc  f0400010          ORR      r0,r0,#0x10           ;1537
0000d0  65a0              STR      r0,[r4,#0x58]         ;1537
0000d2  f8846054          STRB     r6,[r4,#0x54]         ;1540
0000d6  2001              MOVS     r0,#1                 ;1542
0000d8  e7a5              B        |L24.38|
                  |L24.218|
0000da  4620              MOV      r0,r4                 ;1573
0000dc  f7fffffe          BL       ADC_Disable
0000e0  4605              MOV      r5,r0                 ;1573
0000e2  b93d              CBNZ     r5,|L24.244|
0000e4  9801              LDR      r0,[sp,#4]            ;1576
0000e6  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
0000ea  b918              CBNZ     r0,|L24.244|
0000ec  a801              ADD      r0,sp,#4              ;1578
0000ee  f7fffffe          BL       ADC_Disable
0000f2  4605              MOV      r5,r0                 ;1578
                  |L24.244|
0000f4  b92d              CBNZ     r5,|L24.258|
0000f6  6da0              LDR      r0,[r4,#0x58]         ;1587
0000f8  f4205080          BIC      r0,r0,#0x1000         ;1587
0000fc  f0400001          ORR      r0,r0,#1              ;1587
000100  65a0              STR      r0,[r4,#0x58]         ;1587
                  |L24.258|
000102  f8846054          STRB     r6,[r4,#0x54]         ;1598
000106  4628              MOV      r0,r5                 ;1601
000108  e78d              B        |L24.38|
;;;1603   #endif /* ADC_MULTIMODE_SUPPORT */
                          ENDP

00010a  0000              DCW      0x0000
                  |L24.268|
                          DCD      0x50040000
                  |L24.272|
                          DCD      0x50040100

                          AREA ||i.HAL_ADCEx_RegularStop||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_RegularStop PROC
;;;1270     */
;;;1271   HAL_StatusTypeDef HAL_ADCEx_RegularStop(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1272   {
000002  4604              MOV      r4,r0
;;;1273     HAL_StatusTypeDef tmp_hal_status;
;;;1274   
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1277   
;;;1278     /* Process locked */
;;;1279     __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L25.32|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;1280   
;;;1281     /* 1. Stop potential regular conversion on going */
;;;1282     tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_GROUP);
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  4605              MOV      r5,r0
00001c  b115              CBZ      r5,|L25.36|
00001e  e00d              B        |L25.60|
                  |L25.32|
000020  2002              MOVS     r0,#2                 ;1279
;;;1283   
;;;1284     /* Disable ADC peripheral if regular conversions are effectively stopped
;;;1285        and if no injected conversions are on-going */
;;;1286     if (tmp_hal_status == HAL_OK)
;;;1287     {
;;;1288       /* Clear HAL_ADC_STATE_REG_BUSY bit */
;;;1289       CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;1290   
;;;1291       if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
;;;1292       {
;;;1293         /* 2. Disable the ADC peripheral */
;;;1294         tmp_hal_status = ADC_Disable(hadc);
;;;1295   
;;;1296         /* Check if ADC is effectively disabled */
;;;1297         if (tmp_hal_status == HAL_OK)
;;;1298         {
;;;1299           /* Set ADC state */
;;;1300           ADC_STATE_CLR_SET(hadc->State,
;;;1301                             HAL_ADC_STATE_INJ_BUSY,
;;;1302                             HAL_ADC_STATE_READY);
;;;1303         }
;;;1304       }
;;;1305       /* Conversion on injected group is stopped, but ADC not disabled since    */
;;;1306       /* conversion on regular group is still running.                          */
;;;1307       else
;;;1308       {
;;;1309         SET_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
;;;1310       }
;;;1311     }
;;;1312   
;;;1313     /* Process unlocked */
;;;1314     __HAL_UNLOCK(hadc);
;;;1315   
;;;1316     /* Return function status */
;;;1317     return tmp_hal_status;
;;;1318   }
000022  bd70              POP      {r4-r6,pc}
                  |L25.36|
000024  6da0              LDR      r0,[r4,#0x58]         ;1289
000026  f4207080          BIC      r0,r0,#0x100          ;1289
00002a  65a0              STR      r0,[r4,#0x58]         ;1289
00002c  6820              LDR      r0,[r4,#0]            ;1291
00002e  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
000032  b140              CBZ      r0,|L25.70|
000034  6da0              LDR      r0,[r4,#0x58]         ;1309
000036  f4405080          ORR      r0,r0,#0x1000         ;1309
00003a  65a0              STR      r0,[r4,#0x58]         ;1309
                  |L25.60|
00003c  2000              MOVS     r0,#0                 ;1314
00003e  f8840054          STRB     r0,[r4,#0x54]         ;1314
000042  4628              MOV      r0,r5                 ;1317
000044  bd70              POP      {r4-r6,pc}
                  |L25.70|
000046  4620              MOV      r0,r4                 ;1294
000048  f7fffffe          BL       ADC_Disable
00004c  4605              MOV      r5,r0                 ;1294
00004e  2d00              CMP      r5,#0                 ;1297
000050  d1f4              BNE      |L25.60|
000052  6da0              LDR      r0,[r4,#0x58]         ;1300
000054  f4205080          BIC      r0,r0,#0x1000         ;1300
000058  f0400001          ORR      r0,r0,#1              ;1300
00005c  65a0              STR      r0,[r4,#0x58]         ;1300
00005e  e7ed              B        |L25.60|
;;;1319   
                          ENDP


                          AREA ||i.HAL_ADCEx_RegularStop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_RegularStop_DMA PROC
;;;1388     */
;;;1389   HAL_StatusTypeDef HAL_ADCEx_RegularStop_DMA(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1390   {
000002  4604              MOV      r4,r0
;;;1391     HAL_StatusTypeDef tmp_hal_status;
;;;1392   
;;;1393     /* Check the parameters */
;;;1394     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1395   
;;;1396     /* Process locked */
;;;1397     __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L26.32|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;1398   
;;;1399     /* 1. Stop potential regular conversion on going */
;;;1400     tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_GROUP);
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  4605              MOV      r5,r0
00001c  b115              CBZ      r5,|L26.36|
00001e  e020              B        |L26.98|
                  |L26.32|
000020  2002              MOVS     r0,#2                 ;1397
;;;1401   
;;;1402     /* Disable ADC peripheral if conversions are effectively stopped
;;;1403        and if no injected conversion is on-going */
;;;1404     if (tmp_hal_status == HAL_OK)
;;;1405     {
;;;1406       /* Clear HAL_ADC_STATE_REG_BUSY bit */
;;;1407       CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;1408   
;;;1409       /* Disable ADC DMA (ADC DMA configuration ADC_CFGR_DMACFG is kept) */
;;;1410       CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN);
;;;1411   
;;;1412       /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;1413       /* while DMA transfer is on going)                                        */
;;;1414       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1415   
;;;1416       /* Check if DMA channel effectively disabled */
;;;1417       if (tmp_hal_status != HAL_OK)
;;;1418       {
;;;1419         /* Update ADC state machine to error */
;;;1420         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;1421       }
;;;1422   
;;;1423       /* Disable ADC overrun interrupt */
;;;1424       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;1425   
;;;1426       /* 2. Disable the ADC peripheral */
;;;1427       /* Update "tmp_hal_status" only if DMA channel disabling passed,          */
;;;1428       /* to keep in memory a potential failing status.                          */
;;;1429       if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
;;;1430       {
;;;1431         if (tmp_hal_status == HAL_OK)
;;;1432         {
;;;1433           tmp_hal_status = ADC_Disable(hadc);
;;;1434         }
;;;1435         else
;;;1436         {
;;;1437           (void)ADC_Disable(hadc);
;;;1438         }
;;;1439   
;;;1440         /* Check if ADC is effectively disabled */
;;;1441         if (tmp_hal_status == HAL_OK)
;;;1442         {
;;;1443           /* Set ADC state */
;;;1444           ADC_STATE_CLR_SET(hadc->State,
;;;1445                             HAL_ADC_STATE_INJ_BUSY,
;;;1446                             HAL_ADC_STATE_READY);
;;;1447         }
;;;1448       }
;;;1449       else
;;;1450       {
;;;1451         SET_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
;;;1452       }
;;;1453     }
;;;1454   
;;;1455     /* Process unlocked */
;;;1456     __HAL_UNLOCK(hadc);
;;;1457   
;;;1458     /* Return function status */
;;;1459     return tmp_hal_status;
;;;1460   }
000022  bd70              POP      {r4-r6,pc}
                  |L26.36|
000024  6da0              LDR      r0,[r4,#0x58]         ;1407
000026  f4207080          BIC      r0,r0,#0x100          ;1407
00002a  65a0              STR      r0,[r4,#0x58]         ;1407
00002c  6820              LDR      r0,[r4,#0]            ;1410
00002e  68c1              LDR      r1,[r0,#0xc]          ;1410
000030  f0210101          BIC      r1,r1,#1              ;1410
000034  60c1              STR      r1,[r0,#0xc]          ;1410
000036  6d20              LDR      r0,[r4,#0x50]         ;1414
000038  f7fffffe          BL       HAL_DMA_Abort
00003c  4605              MOV      r5,r0                 ;1414
00003e  b11d              CBZ      r5,|L26.72|
000040  6da0              LDR      r0,[r4,#0x58]         ;1420
000042  f0400040          ORR      r0,r0,#0x40           ;1420
000046  65a0              STR      r0,[r4,#0x58]         ;1420
                  |L26.72|
000048  6820              LDR      r0,[r4,#0]            ;1424
00004a  6841              LDR      r1,[r0,#4]            ;1424
00004c  f0210110          BIC      r1,r1,#0x10           ;1424
000050  6041              STR      r1,[r0,#4]            ;1424
000052  6820              LDR      r0,[r4,#0]            ;1429
000054  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
000058  b140              CBZ      r0,|L26.108|
00005a  6da0              LDR      r0,[r4,#0x58]         ;1451
00005c  f4405080          ORR      r0,r0,#0x1000         ;1451
000060  65a0              STR      r0,[r4,#0x58]         ;1451
                  |L26.98|
000062  2000              MOVS     r0,#0                 ;1456
000064  f8840054          STRB     r0,[r4,#0x54]         ;1456
000068  4628              MOV      r0,r5                 ;1459
00006a  bd70              POP      {r4-r6,pc}
                  |L26.108|
00006c  b15d              CBZ      r5,|L26.134|
00006e  4620              MOV      r0,r4                 ;1437
000070  f7fffffe          BL       ADC_Disable
                  |L26.116|
000074  2d00              CMP      r5,#0                 ;1441
000076  d1f4              BNE      |L26.98|
000078  6da0              LDR      r0,[r4,#0x58]         ;1444
00007a  f4205080          BIC      r0,r0,#0x1000         ;1444
00007e  f0400001          ORR      r0,r0,#1              ;1444
000082  65a0              STR      r0,[r4,#0x58]         ;1444
000084  e7ed              B        |L26.98|
                  |L26.134|
000086  4620              MOV      r0,r4                 ;1433
000088  f7fffffe          BL       ADC_Disable
00008c  4605              MOV      r5,r0                 ;1433
00008e  e7f1              B        |L26.116|
;;;1461   
                          ENDP


                          AREA ||i.HAL_ADCEx_RegularStop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_RegularStop_IT PROC
;;;1328     */
;;;1329   HAL_StatusTypeDef HAL_ADCEx_RegularStop_IT(ADC_HandleTypeDef *hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1330   {
000002  4604              MOV      r4,r0
;;;1331     HAL_StatusTypeDef tmp_hal_status;
;;;1332   
;;;1333     /* Check the parameters */
;;;1334     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1335   
;;;1336     /* Process locked */
;;;1337     __HAL_LOCK(hadc);
000004  f8940054          LDRB     r0,[r4,#0x54]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L27.32|
00000c  2001              MOVS     r0,#1
00000e  f8840054          STRB     r0,[r4,#0x54]
;;;1338   
;;;1339     /* 1. Stop potential regular conversion on going */
;;;1340     tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_GROUP);
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop
00001a  4605              MOV      r5,r0
00001c  b115              CBZ      r5,|L27.36|
00001e  e012              B        |L27.70|
                  |L27.32|
000020  2002              MOVS     r0,#2                 ;1337
;;;1341   
;;;1342     /* Disable ADC peripheral if conversions are effectively stopped
;;;1343       and if no injected conversion is on-going */
;;;1344     if (tmp_hal_status == HAL_OK)
;;;1345     {
;;;1346       /* Clear HAL_ADC_STATE_REG_BUSY bit */
;;;1347       CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
;;;1348   
;;;1349       /* Disable all regular-related interrupts */
;;;1350       __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
;;;1351   
;;;1352       /* 2. Disable ADC peripheral if no injected conversions are on-going */
;;;1353       if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
;;;1354       {
;;;1355         tmp_hal_status = ADC_Disable(hadc);
;;;1356         /* if no issue reported */
;;;1357         if (tmp_hal_status == HAL_OK)
;;;1358         {
;;;1359           /* Set ADC state */
;;;1360           ADC_STATE_CLR_SET(hadc->State,
;;;1361                             HAL_ADC_STATE_INJ_BUSY,
;;;1362                             HAL_ADC_STATE_READY);
;;;1363         }
;;;1364       }
;;;1365       else
;;;1366       {
;;;1367         SET_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
;;;1368       }
;;;1369     }
;;;1370   
;;;1371     /* Process unlocked */
;;;1372     __HAL_UNLOCK(hadc);
;;;1373   
;;;1374     /* Return function status */
;;;1375     return tmp_hal_status;
;;;1376   }
000022  bd70              POP      {r4-r6,pc}
                  |L27.36|
000024  6da0              LDR      r0,[r4,#0x58]         ;1347
000026  f4207080          BIC      r0,r0,#0x100          ;1347
00002a  65a0              STR      r0,[r4,#0x58]         ;1347
00002c  6820              LDR      r0,[r4,#0]            ;1350
00002e  6841              LDR      r1,[r0,#4]            ;1350
000030  f021011c          BIC      r1,r1,#0x1c           ;1350
000034  6041              STR      r1,[r0,#4]            ;1350
000036  6820              LDR      r0,[r4,#0]            ;1353
000038  f7fffffe          BL       LL_ADC_INJ_IsConversionOngoing
00003c  b140              CBZ      r0,|L27.80|
00003e  6da0              LDR      r0,[r4,#0x58]         ;1367
000040  f4405080          ORR      r0,r0,#0x1000         ;1367
000044  65a0              STR      r0,[r4,#0x58]         ;1367
                  |L27.70|
000046  2000              MOVS     r0,#0                 ;1372
000048  f8840054          STRB     r0,[r4,#0x54]         ;1372
00004c  4628              MOV      r0,r5                 ;1375
00004e  bd70              POP      {r4-r6,pc}
                  |L27.80|
000050  4620              MOV      r0,r4                 ;1355
000052  f7fffffe          BL       ADC_Disable
000056  4605              MOV      r5,r0                 ;1355
000058  2d00              CMP      r5,#0                 ;1357
00005a  d1f4              BNE      |L27.70|
00005c  6da0              LDR      r0,[r4,#0x58]         ;1360
00005e  f4205080          BIC      r0,r0,#0x1000         ;1360
000062  f0400001          ORR      r0,r0,#1              ;1360
000066  65a0              STR      r0,[r4,#0x58]         ;1360
000068  e7ed              B        |L27.70|
;;;1377   
                          ENDP


                          AREA ||i.LL_ADC_GetOffsetChannel||, CODE, READONLY, ALIGN=1

                  LL_ADC_GetOffsetChannel PROC
;;;3005     */
;;;3006   __STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;3007   {
;;;3008     const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
;;;3009   
;;;3010     return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
000004  6e00              LDR      r0,[r0,#0x60]
000006  f00040f8          AND      r0,r0,#0x7c000000
;;;3011   }
00000a  4770              BX       lr
;;;3012   
                          ENDP


                          AREA ||i.LL_ADC_INJ_IsConversionOngoing||, CODE, READONLY, ALIGN=1

                  LL_ADC_INJ_IsConversionOngoing PROC
;;;6350     */
;;;6351   __STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
000000  6880              LDR      r0,[r0,#8]
;;;6352   {
;;;6353     return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
000002  f3c000c0          UBFX     r0,r0,#3,#1
;;;6354   }
000006  4770              BX       lr
;;;6355   
                          ENDP


                          AREA ||i.LL_ADC_IsEnabled||, CODE, READONLY, ALIGN=1

                  LL_ADC_IsEnabled PROC
;;;6045     */
;;;6046   __STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
000000  6880              LDR      r0,[r0,#8]
;;;6047   {
;;;6048     return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
000002  f3c00000          UBFX     r0,r0,#0,#1
;;;6049   }
000006  4770              BX       lr
;;;6050   
                          ENDP


                          AREA ||i.LL_ADC_REG_IsConversionOngoing||, CODE, READONLY, ALIGN=1

                  LL_ADC_REG_IsConversionOngoing PROC
;;;6167     */
;;;6168   __STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
000000  6880              LDR      r0,[r0,#8]
;;;6169   {
;;;6170     return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
000002  f3c00080          UBFX     r0,r0,#2,#1
;;;6171   }
000006  4770              BX       lr
;;;6172   
                          ENDP


                          AREA ||i.LL_ADC_SetChannelSamplingTime||, CODE, READONLY, ALIGN=1

                  LL_ADC_SetChannelSamplingTime PROC
;;;4713     */
;;;4714   __STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
000000  b510              PUSH     {r4,lr}
;;;4715   {
;;;4716     /* Set bits with content of parameter "SamplingTime" with bits position     */
;;;4717     /* in register and register position depending on parameter "Channel".      */
;;;4718     /* Parameter "Channel" is used with masks because containing                */
;;;4719     /* other bits reserved for other purpose.                                   */
;;;4720     __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
000002  f0017300          AND      r3,r1,#0x2000000
000006  eb0050d3          ADD      r0,r0,r3,LSR #23
;;;4721   
;;;4722     MODIFY_REG(*preg,
00000a  6943              LDR      r3,[r0,#0x14]
00000c  f3c15104          UBFX     r1,r1,#20,#5
000010  2407              MOVS     r4,#7
000012  408c              LSLS     r4,r4,r1
000014  43a3              BICS     r3,r3,r4
000016  408a              LSLS     r2,r2,r1
000018  4313              ORRS     r3,r3,r2
00001a  6143              STR      r3,[r0,#0x14]
;;;4723                ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
;;;4724                SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
;;;4725   }
00001c  bd10              POP      {r4,pc}
;;;4726   
                          ENDP


                          AREA ||i.LL_ADC_SetOffsetState||, CODE, READONLY, ALIGN=1

                  LL_ADC_SetOffsetState PROC
;;;3064     */
;;;3065   __STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;3066   {
;;;3067     __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
;;;3068   
;;;3069     MODIFY_REG(*preg,
000004  6e01              LDR      r1,[r0,#0x60]
000006  f0214100          BIC      r1,r1,#0x80000000
00000a  4311              ORRS     r1,r1,r2
00000c  6601              STR      r1,[r0,#0x60]
;;;3070                ADC_OFR1_OFFSET1_EN,
;;;3071                OffsetState);
;;;3072   }
00000e  4770              BX       lr
;;;3073   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_adc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_adc_ex_c_3613cd7f____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_adc_ex_c_3613cd7f____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_adc_ex_c_3613cd7f____REVSH|
#line 507
|__asm___22_stm32l4xx_hal_adc_ex_c_3613cd7f____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_adc_ex_c_3613cd7f____RRX|
#line 694
|__asm___22_stm32l4xx_hal_adc_ex_c_3613cd7f____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
