; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;536      */
;;;537    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4802              LDR      r0,|L1.12|
;;;538    {
;;;539      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210101          BIC      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;540    }
00000a  4770              BX       lr
;;;541    
                          ENDP

                  |L1.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;572      */
;;;573    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4802              LDR      r0,|L2.12|
;;;574    {
;;;575      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0210104          BIC      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;576    }
00000a  4770              BX       lr
;;;577    
                          ENDP

                  |L2.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;554      */
;;;555    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4802              LDR      r0,|L3.12|
;;;556    {
;;;557      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210102          BIC      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;558    }
00000a  4770              BX       lr
;;;559    
                          ENDP

                  |L3.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;527      */
;;;528    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4802              LDR      r0,|L4.12|
;;;529    {
;;;530      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410101          ORR      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;531    }
00000a  4770              BX       lr
;;;532    
                          ENDP

                  |L4.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;563      */
;;;564    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4802              LDR      r0,|L5.12|
;;;565    {
;;;566      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0410104          ORR      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;567    }
00000a  4770              BX       lr
;;;568    
                          ENDP

                  |L5.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;545      */
;;;546    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4802              LDR      r0,|L6.12|
;;;547    {
;;;548      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410102          ORR      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;549    }
00000a  4770              BX       lr
;;;550    
                          ENDP

                  |L6.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;195      */
;;;196    HAL_StatusTypeDef HAL_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198      /* Reset of all peripherals */
;;;199      __HAL_RCC_APB1_FORCE_RESET();
000002  480a              LDR      r0,|L7.44|
000004  f04f31ff          MOV      r1,#0xffffffff
000008  6381              STR      r1,[r0,#0x38]
00000a  63c1              STR      r1,[r0,#0x3c]
;;;200      __HAL_RCC_APB1_RELEASE_RESET();
00000c  2200              MOVS     r2,#0
00000e  6382              STR      r2,[r0,#0x38]
000010  63c2              STR      r2,[r0,#0x3c]
;;;201    
;;;202      __HAL_RCC_APB2_FORCE_RESET();
000012  6401              STR      r1,[r0,#0x40]
;;;203      __HAL_RCC_APB2_RELEASE_RESET();
000014  6402              STR      r2,[r0,#0x40]
;;;204    
;;;205      __HAL_RCC_AHB1_FORCE_RESET();
000016  6281              STR      r1,[r0,#0x28]
;;;206      __HAL_RCC_AHB1_RELEASE_RESET();
000018  6282              STR      r2,[r0,#0x28]
;;;207    
;;;208      __HAL_RCC_AHB2_FORCE_RESET();
00001a  62c1              STR      r1,[r0,#0x2c]
;;;209      __HAL_RCC_AHB2_RELEASE_RESET();
00001c  62c2              STR      r2,[r0,#0x2c]
;;;210    
;;;211      __HAL_RCC_AHB3_FORCE_RESET();
00001e  6301              STR      r1,[r0,#0x30]
;;;212      __HAL_RCC_AHB3_RELEASE_RESET();
000020  6302              STR      r2,[r0,#0x30]
;;;213    
;;;214      /* De-Init the low level hardware */
;;;215      HAL_MspDeInit();
000022  f7fffffe          BL       HAL_MspDeInit
;;;216    
;;;217      /* Return function status */
;;;218      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;219    }
000028  bd10              POP      {r4,pc}
;;;220    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40021000

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=2

                  HAL_Delay PROC
;;;401      */
;;;402    __weak void HAL_Delay(uint32_t Delay)
000000  b570              PUSH     {r4-r6,lr}
;;;403    {
000002  4604              MOV      r4,r0
;;;404      uint32_t tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4605              MOV      r5,r0
;;;405      uint32_t wait = Delay;
;;;406    
;;;407      /* Add a period to guaranty minimum wait */
;;;408      if (wait < HAL_MAX_DELAY)
00000a  1c60              ADDS     r0,r4,#1
00000c  d002              BEQ      |L8.20|
;;;409      {
;;;410        wait += (uint32_t)uwTickFreq;
00000e  4804              LDR      r0,|L8.32|
000010  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
000012  4404              ADD      r4,r4,r0
                  |L8.20|
;;;411      }
;;;412    
;;;413      while ((HAL_GetTick() - tickstart) < wait)
000014  f7fffffe          BL       HAL_GetTick
000018  1b40              SUBS     r0,r0,r5
00001a  42a0              CMP      r0,r4
00001c  d3fa              BCC      |L8.20|
;;;414      {
;;;415      }
;;;416    }
00001e  bd70              POP      {r4-r6,pc}
;;;417    
                          ENDP

                  |L8.32|
                          DCD      ||.data||

                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;471      */
;;;472    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L9.12|
;;;473    {
;;;474      return(DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;475    }
000008  4770              BX       lr
;;;476    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;453      */
;;;454    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L10.4|
;;;455    {
;;;456      return STM32L4XX_HAL_VERSION;
;;;457    }
000002  4770              BX       lr
;;;458    
                          ENDP

                  |L10.4|
                          DCD      0x010d0000

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;462      */
;;;463    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L11.8|
;;;464    {
;;;465      return((DBGMCU->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;466    }
000006  4770              BX       lr
;;;467    
                          ENDP

                  |L11.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;337      */
;;;338    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L12.8|
;;;339    {
;;;340      return uwTick;
000002  6880              LDR      r0,[r0,#8]  ; uwTick
;;;341    }
000004  4770              BX       lr
;;;342    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_GetTickFreq PROC
;;;385      */
;;;386    HAL_TickFreqTypeDef HAL_GetTickFreq(void)
000000  4801              LDR      r0,|L13.8|
;;;387    {
;;;388      return uwTickFreq;
000002  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
;;;389    }
000004  4770              BX       lr
;;;390    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickPrio||, CODE, READONLY, ALIGN=2

                  HAL_GetTickPrio PROC
;;;346      */
;;;347    uint32_t HAL_GetTickPrio(void)
000000  4801              LDR      r0,|L14.8|
;;;348    {
;;;349      return uwTickPrio;
000002  6840              LDR      r0,[r0,#4]  ; uwTickPrio
;;;350    }
000004  4770              BX       lr
;;;351    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetUIDw0||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw0 PROC
;;;480      */
;;;481    uint32_t HAL_GetUIDw0(void)
000000  4801              LDR      r0,|L15.8|
;;;482    {
;;;483      return(READ_REG(*((uint32_t *)UID_BASE)));
000002  6800              LDR      r0,[r0,#0]
;;;484    }
000004  4770              BX       lr
;;;485    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x1fff7590

                          AREA ||i.HAL_GetUIDw1||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw1 PROC
;;;489      */
;;;490    uint32_t HAL_GetUIDw1(void)
000000  4801              LDR      r0,|L16.8|
;;;491    {
;;;492      return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000002  6800              LDR      r0,[r0,#0]
;;;493    }
000004  4770              BX       lr
;;;494    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x1fff7594

                          AREA ||i.HAL_GetUIDw2||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw2 PROC
;;;498      */
;;;499    uint32_t HAL_GetUIDw2(void)
000000  4801              LDR      r0,|L17.8|
;;;500    {
;;;501      return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
000002  6800              LDR      r0,[r0,#0]
;;;502    }
000004  4770              BX       lr
;;;503    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x1fff7598

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;326      */
;;;327    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L18.12|
;;;328    {
;;;329      uwTick += (uint32_t)uwTickFreq;
000002  6881              LDR      r1,[r0,#8]  ; uwTick
000004  7802              LDRB     r2,[r0,#0]  ; uwTickFreq
000006  4411              ADD      r1,r1,r2
000008  6081              STR      r1,[r0,#8]  ; uwTick
;;;330    }
00000a  4770              BX       lr
;;;331    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=1

                  HAL_Init PROC
;;;151      */
;;;152    HAL_StatusTypeDef HAL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154      HAL_StatusTypeDef  status = HAL_OK;
000002  2400              MOVS     r4,#0
;;;155    
;;;156      /* Configure Flash prefetch, Instruction cache, Data cache */
;;;157      /* Default configuration at reset is:                      */
;;;158      /* - Prefetch disabled                                     */
;;;159      /* - Instruction cache enabled                             */
;;;160      /* - Data cache enabled                                    */
;;;161    #if (INSTRUCTION_CACHE_ENABLE == 0)
;;;162       __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
;;;163    #endif /* INSTRUCTION_CACHE_ENABLE */
;;;164    
;;;165    #if (DATA_CACHE_ENABLE == 0)
;;;166       __HAL_FLASH_DATA_CACHE_DISABLE();
;;;167    #endif /* DATA_CACHE_ENABLE */
;;;168    
;;;169    #if (PREFETCH_ENABLE != 0)
;;;170      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
;;;171    #endif /* PREFETCH_ENABLE */
;;;172    
;;;173      /* Set Interrupt Group Priority */
;;;174      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000004  2003              MOVS     r0,#3
000006  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;175    
;;;176      /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
;;;177      if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
00000a  200f              MOVS     r0,#0xf
00000c  f7fffffe          BL       HAL_InitTick
000010  b108              CBZ      r0,|L19.22|
;;;178      {
;;;179        status = HAL_ERROR;
000012  2401              MOVS     r4,#1
000014  e001              B        |L19.26|
                  |L19.22|
;;;180      }
;;;181      else
;;;182      {
;;;183        /* Init the low level hardware */
;;;184        HAL_MspInit();
000016  f7fffffe          BL       HAL_MspInit
                  |L19.26|
;;;185      }
;;;186    
;;;187      /* Return function status */
;;;188      return status;
00001a  4620              MOV      r0,r4
;;;189    }
00001c  bd10              POP      {r4,pc}
;;;190    
                          ENDP


                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;258      */
;;;259    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;260    {
000002  4605              MOV      r5,r0
;;;261      HAL_StatusTypeDef  status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;262    
;;;263      /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
;;;264      if ((uint32_t)uwTickFreq != 0U)
000006  4e0f              LDR      r6,|L20.68|
000008  7830              LDRB     r0,[r6,#0]  ; uwTickFreq
00000a  2800              CMP      r0,#0
00000c  d017              BEQ      |L20.62|
;;;265      {
;;;266        /*Configure the SysTick to have interrupt in 1ms time basis*/
;;;267        if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
00000e  f44f717a          MOV      r1,#0x3e8
000012  fbb1f0f0          UDIV     r0,r1,r0
000016  490c              LDR      r1,|L20.72|
000018  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00001a  fbb1f0f0          UDIV     r0,r1,r0
00001e  f7fffffe          BL       HAL_SYSTICK_Config
000022  b108              CBZ      r0,|L20.40|
;;;268        {
;;;269          /* Configure the SysTick IRQ priority */
;;;270          if (TickPriority < (1UL << __NVIC_PRIO_BITS))
;;;271          {
;;;272            HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
;;;273            uwTickPrio = TickPriority;
;;;274          }
;;;275          else
;;;276          {
;;;277            status = HAL_ERROR;
;;;278          }
;;;279        }
;;;280        else
;;;281        {
;;;282          status = HAL_ERROR;
000024  2401              MOVS     r4,#1
000026  e00b              B        |L20.64|
                  |L20.40|
000028  2d10              CMP      r5,#0x10              ;270
00002a  d206              BCS      |L20.58|
00002c  2200              MOVS     r2,#0                 ;272
00002e  4629              MOV      r1,r5                 ;272
000030  1e50              SUBS     r0,r2,#1              ;272
000032  f7fffffe          BL       HAL_NVIC_SetPriority
000036  6075              STR      r5,[r6,#4]            ;273  ; uwTickPrio
000038  e002              B        |L20.64|
                  |L20.58|
00003a  2401              MOVS     r4,#1                 ;277
00003c  e000              B        |L20.64|
                  |L20.62|
;;;283        }
;;;284      }
;;;285      else
;;;286      {
;;;287        status = HAL_ERROR;
00003e  2401              MOVS     r4,#1
                  |L20.64|
;;;288      }
;;;289    
;;;290      /* Return function status */
;;;291      return status;
000040  4620              MOV      r0,r4
;;;292    }
000042  bd70              POP      {r4-r6,pc}
;;;293    
                          ENDP

                  |L20.68|
                          DCD      ||.data||
                  |L20.72|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;235      */
;;;236    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;237    {
;;;238      /* NOTE : This function should not be modified, when the callback is needed,
;;;239                the HAL_MspDeInit could be implemented in the user file
;;;240       */
;;;241    }
;;;242    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;224      */
;;;225    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;226    {
;;;227      /* NOTE : This function should not be modified, when the callback is needed,
;;;228                the HAL_MspInit could be implemented in the user file
;;;229       */
;;;230    }
;;;231    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;443      */
;;;444    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;445    {
;;;446      /* Enable SysTick Interrupt */
;;;447      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0410102          ORR      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;448    }
00000c  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.HAL_SYSCFG_DisableIOAnalogSwitchBooster||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_DisableIOAnalogSwitchBooster PROC
;;;743      */
;;;744    void HAL_SYSCFG_DisableIOAnalogSwitchBooster(void)
000000  4802              LDR      r0,|L24.12|
;;;745    {
;;;746      CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
000002  6841              LDR      r1,[r0,#4]
000004  f4217180          BIC      r1,r1,#0x100
000008  6041              STR      r1,[r0,#4]
;;;747    }
00000a  4770              BX       lr
;;;748    
                          ENDP

                  |L24.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_DisableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_DisableMemorySwappingBank PROC
;;;639      */
;;;640    void HAL_SYSCFG_DisableMemorySwappingBank(void)
000000  4901              LDR      r1,|L25.8|
;;;641    {
;;;642    
;;;643      *(__IO uint32_t *)FB_MODE_BB = 0x00000000UL;
000002  2000              MOVS     r0,#0
000004  6208              STR      r0,[r1,#0x20]
;;;644    }
000006  4770              BX       lr
;;;645    
                          ENDP

                  |L25.8|
                          DCD      0x42200000

                          AREA ||i.HAL_SYSCFG_DisableVREFBUF||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_DisableVREFBUF PROC
;;;722      */
;;;723    void HAL_SYSCFG_DisableVREFBUF(void)
000000  4802              LDR      r0,|L26.12|
;;;724    {
;;;725      CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
000002  6b01              LDR      r1,[r0,#0x30]
000004  f0210101          BIC      r1,r1,#1
000008  6301              STR      r1,[r0,#0x30]
;;;726    }
00000a  4770              BX       lr
;;;727    #endif /* VREFBUF */
                          ENDP

                  |L26.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_EnableIOAnalogSwitchBooster||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_EnableIOAnalogSwitchBooster PROC
;;;733      */
;;;734    void HAL_SYSCFG_EnableIOAnalogSwitchBooster(void)
000000  4802              LDR      r0,|L27.12|
;;;735    {
;;;736      SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
000002  6841              LDR      r1,[r0,#4]
000004  f4417180          ORR      r1,r1,#0x100
000008  6041              STR      r1,[r0,#4]
;;;737    }
00000a  4770              BX       lr
;;;738    
                          ENDP

                  |L27.12|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_EnableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_EnableMemorySwappingBank PROC
;;;624      */
;;;625    void HAL_SYSCFG_EnableMemorySwappingBank(void)
000000  4901              LDR      r1,|L28.8|
;;;626    {
;;;627      *(__IO uint32_t *)FB_MODE_BB = 0x00000001UL;
000002  2001              MOVS     r0,#1
000004  6208              STR      r0,[r1,#0x20]
;;;628    }
000006  4770              BX       lr
;;;629    
                          ENDP

                  |L28.8|
                          DCD      0x42200000

                          AREA ||i.HAL_SYSCFG_EnableVREFBUF||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_EnableVREFBUF PROC
;;;696      */
;;;697    HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
000000  b570              PUSH     {r4-r6,lr}
;;;698    {
;;;699      uint32_t  tickstart;
;;;700    
;;;701      SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
000002  4c0a              LDR      r4,|L29.44|
000004  6b20              LDR      r0,[r4,#0x30]
000006  f0400001          ORR      r0,r0,#1
00000a  6320              STR      r0,[r4,#0x30]
;;;702    
;;;703      /* Get Start Tick*/
;;;704      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;705    
;;;706      /* Wait for VRR bit  */
;;;707      while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0U)
000012  e006              B        |L29.34|
                  |L29.20|
;;;708      {
;;;709        if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
000014  f7fffffe          BL       HAL_GetTick
000018  1b40              SUBS     r0,r0,r5
00001a  280a              CMP      r0,#0xa
00001c  d901              BLS      |L29.34|
;;;710        {
;;;711          return HAL_TIMEOUT;
00001e  2003              MOVS     r0,#3
;;;712        }
;;;713      }
;;;714    
;;;715      return HAL_OK;
;;;716    }
000020  bd70              POP      {r4-r6,pc}
                  |L29.34|
000022  6b20              LDR      r0,[r4,#0x30]         ;707
000024  0700              LSLS     r0,r0,#28             ;707
000026  d5f5              BPL      |L29.20|
000028  2000              MOVS     r0,#0                 ;715
00002a  bd70              POP      {r4-r6,pc}
;;;717    
                          ENDP

                  |L29.44|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_SRAM2Erase||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_SRAM2Erase PROC
;;;605      */
;;;606    void HAL_SYSCFG_SRAM2Erase(void)
000000  4804              LDR      r0,|L30.20|
;;;607    {
;;;608      /* unlock the write protection of the SRAM2ER bit */
;;;609      SYSCFG->SKR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6241              STR      r1,[r0,#0x24]
;;;610      SYSCFG->SKR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6241              STR      r1,[r0,#0x24]
;;;611      /* Starts a hardware SRAM2 erase operation*/
;;;612      *(__IO uint32_t *) SCSR_SRAM2ER_BB = 0x00000001UL;
00000a  4903              LDR      r1,|L30.24|
00000c  2001              MOVS     r0,#1
00000e  6008              STR      r0,[r1,#0]
;;;613    }
000010  4770              BX       lr
;;;614    
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x40010000
                  |L30.24|
                          DCD      0x42200300

                          AREA ||i.HAL_SYSCFG_VREFBUF_HighImpedanceConfig||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_VREFBUF_HighImpedanceConfig PROC
;;;672      */
;;;673    void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
000000  4903              LDR      r1,|L31.16|
;;;674    {
;;;675      /* Check the parameters */
;;;676      assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));
;;;677    
;;;678      MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
000002  6b0a              LDR      r2,[r1,#0x30]
000004  f0220202          BIC      r2,r2,#2
000008  4302              ORRS     r2,r2,r0
00000a  630a              STR      r2,[r1,#0x30]
;;;679    }
00000c  4770              BX       lr
;;;680    
                          ENDP

00000e  0000              DCW      0x0000
                  |L31.16|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_VREFBUF_TrimmingConfig||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_VREFBUF_TrimmingConfig PROC
;;;684      */
;;;685    void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
000000  4903              LDR      r1,|L32.16|
;;;686    {
;;;687      /* Check the parameters */
;;;688      assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));
;;;689    
;;;690      MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
000002  6b4a              LDR      r2,[r1,#0x34]
000004  f022023f          BIC      r2,r2,#0x3f
000008  4302              ORRS     r2,r2,r0
00000a  634a              STR      r2,[r1,#0x34]
;;;691    }
00000c  4770              BX       lr
;;;692    
                          ENDP

00000e  0000              DCW      0x0000
                  |L32.16|
                          DCD      0x40010000

                          AREA ||i.HAL_SYSCFG_VREFBUF_VoltageScalingConfig||, CODE, READONLY, ALIGN=2

                  HAL_SYSCFG_VREFBUF_VoltageScalingConfig PROC
;;;656      */
;;;657    void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
000000  4903              LDR      r1,|L33.16|
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
;;;661    
;;;662      MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
000002  6b0a              LDR      r2,[r1,#0x30]
000004  f0220204          BIC      r2,r2,#4
000008  4302              ORRS     r2,r2,r0
00000a  630a              STR      r2,[r1,#0x30]
;;;663    }
00000c  4770              BX       lr
;;;664    
                          ENDP

00000e  0000              DCW      0x0000
                  |L33.16|
                          DCD      0x40010000

                          AREA ||i.HAL_SetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_SetTickFreq PROC
;;;356      */
;;;357    HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
000000  b570              PUSH     {r4-r6,lr}
;;;358    {
000002  4601              MOV      r1,r0
;;;359      HAL_StatusTypeDef status  = HAL_OK;
000004  2000              MOVS     r0,#0
;;;360      HAL_TickFreqTypeDef prevTickFreq;
;;;361    
;;;362      if (uwTickFreq != Freq)
000006  4d06              LDR      r5,|L34.32|
000008  782c              LDRB     r4,[r5,#0]  ; uwTickFreq
00000a  428c              CMP      r4,r1
00000c  d006              BEQ      |L34.28|
;;;363      {
;;;364        /* Back up uwTickFreq frequency */
;;;365        prevTickFreq = uwTickFreq;
;;;366    
;;;367        /* Update uwTickFreq global variable used by HAL_InitTick() */
;;;368        uwTickFreq = Freq;
00000e  7029              STRB     r1,[r5,#0]
;;;369    
;;;370        /* Apply the new tick Freq  */
;;;371        status = HAL_InitTick(uwTickPrio);
000010  6868              LDR      r0,[r5,#4]  ; uwTickPrio
000012  f7fffffe          BL       HAL_InitTick
;;;372        if (status != HAL_OK)
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L34.28|
;;;373        {
;;;374          /* Restore previous tick frequency */
;;;375          uwTickFreq = prevTickFreq;
00001a  702c              STRB     r4,[r5,#0]
                  |L34.28|
;;;376        }
;;;377      }
;;;378    
;;;379      return status;
;;;380    }
00001c  bd70              POP      {r4-r6,pc}
;;;381    
                          ENDP

00001e  0000              DCW      0x0000
                  |L34.32|
                          DCD      ||.data||

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;427      */
;;;428    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;429    {
;;;430      /* Disable SysTick Interrupt */
;;;431      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210102          BIC      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;432    }
00000c  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTickFreq
000000  01000000          DCB      0x01,0x00,0x00,0x00
                  uwTickPrio
                          DCD      0x00000010
                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l4xx_hal_c_3da258af____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___15_stm32l4xx_hal_c_3da258af____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l4xx_hal_c_3da258af____REVSH|
#line 507
|__asm___15_stm32l4xx_hal_c_3da258af____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l4xx_hal_c_3da258af____RRX|
#line 694
|__asm___15_stm32l4xx_hal_c_3da258af____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
