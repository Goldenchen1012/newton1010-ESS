L 1 "..\..\..\HAL\HalAfe.c"
N/**
N  ******************************************************************************
N  * @file        HalAfe.c
N  * @author      Johnny
N  * @version     v0.0
N  * @date        2021/10/12
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 19 "..\..\..\HAL\HalAfe.c" 2
N#include "halafe.h"
L 1 "..\..\..\HAL\halafe.h" 1
N/**
N  ******************************************************************************
N  * @file        HalAfe.h
N  * @author      Johnny
N  * @version     v0.0
N  * @date        2021/9/7
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef HAL_AFE_H_
N#define HAL_AFE_H_
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include "LibRegister.h"
L 1 "..\..\..\Lib\LibRegister.h" 1
N
N#ifndef _LIB_REGISTER_H
N#define _LIB_REGISTER_H
N
N#include "sdk_config.h"
L 1 "..\..\..\Config_Common\sdk_config.h" 1
N/**
N  ******************************************************************************
N  * @file        sdk_config.h
N  * @author      Johnny
N  * @version     v1.0
N  * @date        2021/9/4
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef SDK_CONFIG_H_
N#define SDK_CONFIG_H_
N
N#define __far
N//
N//#include "project_config.h"
N
N// <h> Application 
N
N//==========================================================
N// <q> APP PROJECT 
N#define APP_PROJECT_LED_SHOW_CAPACITY_TIME 5000 //ms
N#define APP_PROJECT_VPACK_THRES 36000  //mv
N#define APP_PROJECT_VPACK_DROP_DELTA 20  //%
N#define APP_PROJECT_VPACK_NOMINAL_VOL 36500  //mV
N
N#ifndef APP_PROJECT_LED_POWER_OFF_TIMES
N#define APP_PROJECT_LED_POWER_OFF_TIMES 2
N#endif
N
N#ifndef APP_PROJECT_LED_POWER_ON_ENABLE
N#define APP_PROJECT_LED_POWER_ON_ENABLE 0
N#endif
N
N#define APP_PROJECT_STATE_ALARM_SUPPOER 1
N
N#ifndef APP_PROJECT_SHUTDOWN_TIMER_DEF
N#define APP_PROJECT_SHUTDOWN_TIMER_DEF 86400
N#endif
N
N#ifndef APP_PROJECT_LED_COMM_ENABLE
N#define APP_PROJECT_LED_COMM_ENABLE 0
N#endif
N
N//==========================================================
N// <q> APP CAPACITY
N#ifndef APP_CAPACITY_SELF_CURRENT
N#define APP_CAPACITY_SELF_CURRENT  4   //mA
N#endif
N//==========================================================
N// <q> APP SERIAL
N
N#define APP_SERIAL_KEEGLO_HAL &mHalSerialUart1
N#define APP_SERIAL_KEEGLO_APP_DATA_COMM &mAppSerialDat
N#define APP_SERIAL_KEEGLO_BMU 0
N
N#define APP_SERIAL_CUSTOM_HAL &mHalSerialUart0
N#define APP_SERIAL_CUSTOM_APP_DATA_COMM &mAppSerialDat
N#define APP_SERIAL_CUSTOM_BMU 0
N
N
N#define APP_SERIAL_CAN_KEEGLO_HAL &mHalSerialCan1
N#define APP_SERIAL_CAN_KEEGLO_APP_DATA_COMM &mAppSerialDat
N#define APP_SERIAL_CAN_KEEGLO_BMU 0
N
N//UART
N#ifndef APP_SERIAL_CUSTOM_ENABLE
N#define APP_SERIAL_CUSTOM_ENABLE 0
N#endif
N
N
N//CAN
N#ifndef APP_SERIAL_CAN1_ENABLE
N#define APP_SERIAL_CAN1_ENABLE 1
N#endif
N
N#ifndef APP_SERIAL_CAN_CUSTOM_ENABLE
N#define APP_SERIAL_CAN_CUSTOM_ENABLE  1
N#endif
N
N#if (APP_SERIAL_CAN_CUSTOM_ENABLE == 1)
X#if (1 == 1)
N#define APP_SERIAL_CAN_CUSTOM_HAL &mHalSerialCan1
N#define APP_SERIAL_CAN_CUSTOM_APP_DATA_COMM &mAppSerialDat
N#define APP_SERIAL_CAN_CUSTOM_BMU 0
N
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> AFE 
N
N//==========================================================
N// <q> AFE Parameter 
N
N#ifndef AFE_MAX
N#define AFE_MAX 1
N#endif
N
N#define AFE_ADC_DATA_LEN_16 16
N#define AFE_ADC_DATA_LEN_32 32
N
N#ifndef AFE_ADC_DATA_LEN
N#define AFE_ADC_DATA_LEN AFE_ADC_DATA_LEN_16
N#endif
N
N#ifndef AFE_ADC_GAIN_CELL_VOL
N#define AFE_ADC_GAIN_CELL_VOL 305
N#endif
N
N#ifndef AFE_ADC_GAIN_PACK_VOL
N#define AFE_ADC_GAIN_PACK_VOL 6104
N#endif
N
N#ifndef AFE_ADC_GAIN_CURR
N#define AFE_ADC_GAIN_CURR 5493
N#endif
N
N#define AFE_AVG_WINDOW_CELL_VOL 2
N#define AFE_AVG_WINDOW_NTC 2
N#define AFE_AVG_WINDOW_CURRENT 1
N#define AFE_AVG_WINDOW_VB 0
N#define AFE_AVG_WINDOW_VP 0
N
N#define AFE_CALIB_VB   0
N#define AFE_CALIB_VP   1
N#define AFE_CALIB_CURRENT   0
N
N#define AFE_ADC_BALANCE_RELEASE_TIME 80
N//==========================================================
N// <q> LIB MOS
N
N#ifndef LIB_MOS_PRE_DSG_TIME_DEF   //ms
N#define LIB_MOS_PRE_DSG_TIME_DEF 2000
N#endif
N
N#ifndef LIB_MOS_PRE_DSG_RETRY_TIME   //ms
N#define LIB_MOS_PRE_DSG_RETRY_TIME 1000
N#endif
N
N#ifndef LIB_MOS_PRE_DSG_RETRY_COUNT   
N#define LIB_MOS_PRE_DSG_RETRY_COUNT 10
N#endif
N
N#ifndef LIB_MOS_PRE_DSG_VP_THRESHOLD   //uV
N#define LIB_MOS_PRE_DSG_VP_THRESHOLD 10000000
N#endif
N
N//==========================================================
N// <q> LIB PROTECT
N
N#ifndef LIB_PROTECT_OV_ENABLE   
N#define LIB_PROTECT_OV_ENABLE 1
N#endif
N
N// OVP
N#define LIB_OVP_LEVEL_MAX 3
N
N#define LIB_OVP_THRESHOLD_L1   (3500000/AFE_ADC_GAIN_CELL_VOL)  //LSB
N#define LIB_OVP_THRESHOLD_L2   (3600000/AFE_ADC_GAIN_CELL_VOL)  //LSB
N#define LIB_OVP_THRESHOLD_L3   (3650000/AFE_ADC_GAIN_CELL_VOL)  //LSB
N#define LIB_OVP_THRESHOLD_RELEASE   (3450000/AFE_ADC_GAIN_CELL_VOL)  //LSB
N#define LIB_OVP_TIME 50  //unit 100ms
N#define LIB_OVP_TIME_RELEASE 50  //unit 100ms
N
N//==========================================================
N// <q> LIB Register
N
N#ifndef LIB_REGISTER_RECORD_DYNAMIC_ENABLE
N#define LIB_REGISTER_RECORD_DYNAMIC_ENABLE 0
N#endif
N
N#ifndef LIB_REGISTER_RECORD_MAX
N#define LIB_REGISTER_RECORD_MAX 	50
N#endif
N
N//==========================================================
N// <q> LIB Button
N
N#ifndef LIB_BUTTON_LONG_PRESS_TIME
N#define LIB_BUTTON_LONG_PRESS_TIME 3000  //ms
N#endif
N
N
N#ifndef LIB_BUTTON_USE_ADC
N#define LIB_BUTTON_USE_ADC 0  
N#endif
N
N
N//==========================================================
N// <q> NTC
N#ifndef HAL_NTC_CHECK_TABLE
N#define HAL_NTC_CHECK_TABLE {1,0,0,0,0,0,0}
N#endif
N
N//==========================================================
N// <q> BMU
N
N#ifndef APP_BMU_SELF_TEST_TIME    //Unit:100ms 
N#define APP_BMU_SELF_TEST_TIME (LIB_BUTTON_LONG_PRESS_TIME / 100)
N#endif
N
N#ifndef APP_BMU_PROTECT_DUTP_ENABLE
N#define	APP_BMU_PROTECT_DUTP_ENABLE	0
N#endif 
N
N#ifndef APP_BMU_PRE_DISCHARGE_ENABLE
N#define	APP_BMU_PRE_DISCHARGE_ENABLE	0
N#endif
N
N//==========================================================
N// <q> BMS
N#ifndef BMS_MODE_SLAVE_ENABLE
N#define BMS_MODE_SLAVE_ENABLE false
N#endif
N
N#endif
N
L 6 "..\..\..\Lib\LibRegister.h" 2
N#include "LibDebug.h"
L 1 "..\..\..\Lib\LibDebug.h" 1
N#ifndef _LIB_DEBUG_H
N#define	_LIB_DEBUG_H
N
N#include <stdint.h>
N//#include "sdk_config.h"
N
N//#define __USE_FULL_ASSERT
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  __USE_FULL_ASSERT
S
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function which reports 
S  *         the name of the source file and the source line number of the call 
S  *         that failed. If expr is true, it returns no value.
S  * @retval None
S  */
S#ifndef assert_param
S#define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S#endif
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0U)
N#endif /* USE_FULL_ASSERT */
N
N#define tErrCode int8_t
N#define RES_ERROR_BASE_NUM (tErrCode)(0x00)
N
N/** @} */
N
N#define RES_SUCCESS                           (RES_ERROR_BASE_NUM - 0)  ///< Successful command
N#define RES_ERROR_NOT_FOUND                   (RES_ERROR_BASE_NUM - 1)  ///< Not found or unknown error 
N#define RES_ERROR_NOT_SUPPORTED               (RES_ERROR_BASE_NUM - 2)  ///< Not supported
N#define RES_ERROR_INVALID_PARAM               (RES_ERROR_BASE_NUM - 3)  ///< Invalid Parameter
N#define RES_ERROR_INVALID_STATE               (RES_ERROR_BASE_NUM - 4)  ///< Invalid state, operation disallowed in this state
N#define RES_ERROR_INVALID_LENGTH              (RES_ERROR_BASE_NUM - 5)  ///< Invalid Length
N#define RES_ERROR_INVALID_FLAGS               (RES_ERROR_BASE_NUM - 6) ///< Invalid Flags
N#define RES_ERROR_INVALID_DATA                (RES_ERROR_BASE_NUM - 7) ///< Invalid Data
N#define RES_ERROR_INVALID_ADDR                (RES_ERROR_BASE_NUM - 8) ///< Bad Memory Address
N#define RES_ERROR_DATA_SIZE                   (RES_ERROR_BASE_NUM - 9) ///< Invalid Data size
N#define RES_ERROR_TIMEOUT                     (RES_ERROR_BASE_NUM - 10) ///< Operation timed out
N#define RES_ERROR_NULL                        (RES_ERROR_BASE_NUM - 11) ///< Null Pointer
N#define RES_ERROR_FORBIDDEN                   (RES_ERROR_BASE_NUM - 12) ///< Forbidden Operation
N#define RES_ERROR_BUSY                        (RES_ERROR_BASE_NUM - 13) ///< Busy
N#define RES_ERROR_RESOURCES                   (RES_ERROR_BASE_NUM - 14) ///< Not enough resources for operation
N#define RES_ERROR_NOT_OPEN                    (RES_ERROR_BASE_NUM - 15) ///< Some software equipment was not open.
N#define RES_ERROR_ACCESS                      (RES_ERROR_BASE_NUM - 16) ///< Accress path error.
N#define RES_ERROR_MALLOC                      (RES_ERROR_BASE_NUM - 17) ///< Memory allocate error.
N#define RES_ERROR_UNINIT                      (RES_ERROR_BASE_NUM - 18) ///< UNINIT error.
N#define RES_ERROR_FULL                           (RES_ERROR_BASE_NUM - 19) ///< Buffer full error.
N#define RES_ERROR_REINIT                       (RES_ERROR_BASE_NUM - 20) ///< 
N#define RES_ERROR_INIT                             (RES_ERROR_BASE_NUM - 21) ///< 
N#define RES_ERROR_EMPTY                             (RES_ERROR_BASE_NUM - 22) ///< Buffer empty error
N#define RES_ERROR_FAIL				(RES_ERROR_BASE_NUM - 23)
N#endif
L 7 "..\..\..\Lib\LibRegister.h" 2
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 10 "..\..\..\Lib\LibRegister.h" 2
N//---------------------SysLockCB Debug Definition -----------------------------
N#define LibRegisterAdd(head, handler, dest) _LibRegisterAdd((__far tLibRegister *)head, handler, (__far void *)dest)
N#define LibRegisterRm(head, handler, dest) _LibRegisterRm((__far tLibRegister *)head, handler, (__far void *)dest)
N#define LibRegisterTypeHandlerExe(head, evt, data) _LibRegisterTypeHandlerExe((__far tLibRegister *)head, evt, (__far void *)data)
N#define LibRegisterGetMemberAddr(head, number) _LibRegisterGetMemberAddr((__far tLibRegister *)head, number)
N#define LibRegisterIsMemberNull(head) _LibRegisterIsMemberNull((__far tLibRegister *)head)
N//---------------------SysLockCB Global Variables -----------------------------
N//---------------------SysLockCB Prototype Declaration  -----------------------    
Ntypedef void (* tLibRegisterEvtHandler)(__far void *dest, uint16_t evt, __far void *data);
Xtypedef void (* tLibRegisterEvtHandler)( void *dest, uint16_t evt,  void *data);
N
Ntypedef struct 
N{
N	__far void *dest;
X	 void *dest;
N    tLibRegisterEvtHandler handler;
N    __far void *next;
X     void *next;
N}tLibRegisterMember;
N
Ntypedef struct 
N{
N    __far tLibRegisterMember *next;
X     tLibRegisterMember *next;
N	__far tLibRegisterMember *executing;
X	 tLibRegisterMember *executing;
N	bool removeExecutingHandlerFlag;
X	_Bool removeExecutingHandlerFlag;
N}tLibRegister;
N
N//---------------------SysLockCB Public API  ----------------------------------
NtErrCode _LibRegisterAdd(__far tLibRegister *head, tLibRegisterEvtHandler handler, __far void *dest); //Store member to heap.
Xint8_t _LibRegisterAdd( tLibRegister *head, tLibRegisterEvtHandler handler,  void *dest); 
NtErrCode _LibRegisterRm(__far tLibRegister *head,tLibRegisterEvtHandler handler, __far void *dest); //When "head" is 0,this API will remove all member.
Xint8_t _LibRegisterRm( tLibRegister *head,tLibRegisterEvtHandler handler,  void *dest); 
NtErrCode _LibRegisterTypeHandlerExe(__far tLibRegister *head, uint16_t evt, __far void * data);
Xint8_t _LibRegisterTypeHandlerExe( tLibRegister *head, uint16_t evt,  void * data);
N__far tLibRegisterMember *_LibRegisterGetMemberAddr(__far tLibRegister *head, uint16_t number);
X tLibRegisterMember *_LibRegisterGetMemberAddr( tLibRegister *head, uint16_t number);
Nbool _LibRegisterIsMemberNull(__far tLibRegister *head);
X_Bool _LibRegisterIsMemberNull( tLibRegister *head);
N#endif /* _LIB_REGISTER_H */
N
L 22 "..\..\..\HAL\halafe.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Nenum{
N	AFE_STATE_NORMAL = 0,
N	AFE_STATE_INI,
N};
N	
Nenum{
N	AFE_EVT_COMM_L1_SET = 1,
N	AFE_EVT_COMM_L1_RELEASE,
N	AFE_EVT_COMM_L2_SET,
N	AFE_EVT_COMM_L2_RELEASE,
N	AFE_EVT_END
N};
N
N#define	MAX_CELL_NUMBER		400
N#define	MAX_NTC_NUMBER		400
N
N/* Public define ------------------------------------------------------------*/
N#define tAfeEvtHandler tLibRegisterEvtHandler
N
N#define	tCellVoltage		uint16_t
N#define	tNtcAdcData			uint16_t
N#define	tBatteryVoltage		uint32_t
N#define	tPackVoltage		uint32_t
N#define	tCurrent			int32_t
N
N
Nint32_t	halAfeGetCurrentAdcValue(uint8_t CurrentIndex);
Nvoid halAfeSetCurrentAdcValue(uint8_t CurrentIndex,int32_t adcvalue);
Nint32_t	halAfeGetVBatAdcValue(uint8_t VbIndex);
Nvoid halAfeSetVBatAdcValue(uint8_t VbIndex,int32_t adcvalue);
N
NtCellVoltage halAfeGetCellVoltage(uint16_t CellIndex);
Xuint16_t halAfeGetCellVoltage(uint16_t CellIndex);
NtCurrent halAfeGetCurrentValue(uint8_t index);
Xint32_t halAfeGetCurrentValue(uint8_t index);
NtNtcAdcData HalAfeGetNtcAdc(uint16_t NtcIndex);
Xuint16_t HalAfeGetNtcAdc(uint16_t NtcIndex);
Nvoid halAfeSetCellVoltage(uint16_t cell, tCellVoltage voltage);
Xvoid halAfeSetCellVoltage(uint16_t cell, uint16_t voltage);
Nvoid halAfeSetNtcAdcData(uint16_t ntcs, tNtcAdcData adcdata);
Xvoid halAfeSetNtcAdcData(uint16_t ntcs, uint16_t adcdata);
Nvoid HalAfeSetCurrentValue(uint8_t index, int32_t current);
Nuint32_t halAfeGetVBatVoltage(uint8_t index);
Nvoid halAfeSetVBatVoltage(uint8_t index, uint32_t voltage);
N
NtCellVoltage halAfeGetMaxCellVoltage(void);
Xuint16_t halAfeGetMaxCellVoltage(void);
NtCellVoltage halAfeGetMinCellVoltage(void);
Xuint16_t halAfeGetMinCellVoltage(void);
NtNtcAdcData HalAfeGetMinNtcTempAdc(void);
Xuint16_t HalAfeGetMinNtcTempAdc(void);
NtNtcAdcData HalAfeGetMaxNtcTempAdc(void);
Xuint16_t HalAfeGetMaxNtcTempAdc(void);
N
Nvoid halAfeUpdateMinMaxCellVoltage(void);
Nvoid halAfeUpdateMinMaxNtcTempVoltage(void);
N
Nvoid halafeOpen(tAfeEvtHandler evtHandler);
Xvoid halafeOpen(tLibRegisterEvtHandler evtHandler);
Nvoid halAfeSetPhysicalBalancePosition(uint8_t bmuindex, uint16_t position);
Nvoid halAfeSetBalanceOnFlag(uint8_t onflag);
Nuint8_t halAfeGetState(void);
Nuint8_t halAfeIsL1Protect(void);
Nuint8_t halAfeIsL2Protect(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N	
N
N#endif /* HAL_AFE_H_ */
N
N/************************ (C) COPYRIGHT Johnny Wang *****END OF FILE****/    
L 20 "..\..\..\HAL\HalAfe.c" 2
N#include "LibSwTimer.h"
L 1 "..\..\..\Lib\LibSwTimer.h" 1
N/**
N  ******************************************************************************
N  * @file        LibSwTimer.h
N  * @author      Johnny
N  * @version     v0.0
N  * @date        2021/10/14
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef _LIB_SW_TIMER_H
N#define _LIB_SW_TIMER_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include "LibDebug.h"
N#include "LibRegister.h"
N
N/* Public define ------------------------------------------------------------*/
N#define tLibSwTimerEvtHandler tLibRegisterEvtHandler
N/* Public typedef -----------------------------------------------------------*/
Ntypedef enum {
N  LIB_SW_TIMER_EVT_SW_10MS_0 = 0,
N  LIB_SW_TIMER_EVT_SW_10MS_1,  
N  LIB_SW_TIMER_EVT_SW_10MS_2,  
N  LIB_SW_TIMER_EVT_SW_10MS_3,  
N  LIB_SW_TIMER_EVT_SW_10MS_4,  
N  LIB_SW_TIMER_EVT_SW_10MS_5,  
N  LIB_SW_TIMER_EVT_SW_10MS_6,  
N  LIB_SW_TIMER_EVT_SW_10MS_7,  
N  LIB_SW_TIMER_EVT_SW_10MS_8,  
N  LIB_SW_TIMER_EVT_SW_10MS_9,  
N  LIB_SW_TIMER_EVT_SW_1MS,  
N  LIB_SW_TIMER_EVT_SW_100MS,
N  LIB_SW_TIMER_EVT_SW_500MS,
N  LIB_SW_TIMER_EVT_SW_1S,
N  
N  LIB_SW_TIMER_EVT_SW_TASK,
N  
N  LIB_SW_TIMER_EVT_HW_1MS,
N  LIB_SW_TIMER_EVT_HW_5MS,
N
N} tLibSwTimerEvt;
N
N/* Public macro -------------------------------------------------------------*/
N/* Public variables ---------------------------------------------------------*/
N/* Public function prototypes -----------------------------------------------*/
Nuint16_t LibGetSwTimer(void);
Nvoid LibSwTimerClearCount(void);
NtErrCode LibSwTimerOpen(tLibSwTimerEvtHandler handler, __far void *dest);
Xint8_t LibSwTimerOpen(tLibRegisterEvtHandler handler,  void *dest);
NtErrCode LibSwTimerClose(tLibSwTimerEvtHandler handler, __far void *dest);
Xint8_t LibSwTimerClose(tLibRegisterEvtHandler handler,  void *dest);
Nvoid LibSwTimerHwHandler(tLibSwTimerEvt evt, __far void *data);
Xvoid LibSwTimerHwHandler(tLibSwTimerEvt evt,  void *data);
Nvoid LibSwTimerHandle(void);
Nvoid LibSwTimerHwDelay(uint16_t ms);
N
NtErrCode LibSwTimerTaskOpen(tLibSwTimerEvtHandler handler, __far void *dest);
Xint8_t LibSwTimerTaskOpen(tLibRegisterEvtHandler handler,  void *dest);
NtErrCode LibSwTimerTaskClose(tLibSwTimerEvtHandler handler, __far void *dest);
Xint8_t LibSwTimerTaskClose(tLibRegisterEvtHandler handler,  void *dest);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _LIB_SW_TIMER_H */
L 21 "..\..\..\HAL\HalAfe.c" 2
N#include "LibNtc.h"
L 1 "..\..\..\Lib\LibNtc.h" 1
N/**
N  ******************************************************************************
N  * @file        LibNtc.h
N  * @author      Johnny
N  * @version     v1.0
N  * @date        2021/10/25
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef _LIB_NTC_H_
N#define _LIB_NTC_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N	
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N
N	
N/* Public define ------------------------------------------------------------*/
N	
N/* Public typedef -----------------------------------------------------------*/
N
N/* Public macro -------------------------------------------------------------*/
N
N/* Public variables ---------------------------------------------------------*/
N/* Public function prototypes -----------------------------------------------*/
Nuint16_t LibTemperatureToVoltage(int16_t temp);
Nuint16_t LibNtcRToTemperature(double NtcR);
Nuint16_t LibNtcVoltageToTemperature(uint16_t NtcVoltage);
Nuint16_t LibSetRealTemperatureToInternalValue(int16_t temp);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _LIB_NTC_H_ */
L 22 "..\..\..\HAL\HalAfe.c" 2
N#include "HalAfeBq796xx.h"
L 1 "..\..\..\HAL\HalAfeBq796xx.h" 1
N/**
N  ******************************************************************************
N  * @file        HalAfeBq796xx.h
N  * @author      Johnny
N  * @version     v0.0
N  * @date        2021/10/19
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef HAL_AFE_BQ796XX_H_
N#define HAL_AFE_BQ796XX_H_
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* Public define ------------------------------------------------------------*/
N/* Public typedef -----------------------------------------------------------*/
N	
N/* Public macro -------------------------------------------------------------*/
N
N
N/* Public variables ---------------------------------------------------------*/
N/* Public function prototypes -----------------------------------------------*/
NtErrCode HalAfeBq796xx_Init(void);
Xint8_t HalAfeBq796xx_Init(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* HAL_AFE_BQ796XX_H_ */
N
N/************************ (C) COPYRIGHT Johnny Wang *****END OF FILE****/    
L 23 "..\..\..\HAL\HalAfe.c" 2
N#include "ApiSysPar.h"
L 1 "..\..\..\API\ApiSysPar.h" 1
N/**
N  ******************************************************************************
N  * @file        ApiSysPar.h
N  * @author      Johnny
N  * @version     v0.0.1
N  * @date        2021/11/29
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef _API_SYS_PAR_H_
N#define _API_SYS_PAR_H_
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include "define.h"
L 1 "..\..\..\User\define.h" 1
N/**
N  ******************************************************************************
N  * @file        define.h
N  * @author      Johnny
N  * @version     v0.0
N  * @date        2021/9/8
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef _DEFINE_H_
N#define _DEFINE_H_
N
N#define	DEBUG_MODE				//don't check HW Protect 
N
N//-------------------------------------------------
Ntypedef unsigned char			BYTE;
Ntypedef	char					CHAR;
Ntypedef	unsigned short int		WORD;
Ntypedef short int				INT;
Ntypedef unsigned long int		DWORD;
Ntypedef long int				LONG;
Ntypedef unsigned char			BOOL;
Ntypedef unsigned long long int 	DDWORD;
Ntypedef long long int			DLONG;
N
Ntypedef union{
N	BYTE	b[2];
N	WORD	i;
N	INT		si;
N}tIbyte;
N	
Ntypedef union{
N	BYTE	b[4];
N	WORD	i[2];
N	DWORD	l;
N	LONG	sl;
N}tLbyte;
N
Ntypedef union{
N	BYTE	b[8];
N	WORD	i[4];
N	DWORD	l[2];
N	DDWORD  ll;
N	DLONG	sll;
N}tLLbyte;
N
N#define	GET_BYTE(addr)		((BYTE)(*(BYTE *)addr))	
N//#define	GET_WORD(addr)		((WORD)(*(WORD *)addr))	
N//#define	GET_DWORD(addr)		((DWORD)(*(DWORD *)addr))
N
N#define	GET_WORD(addr)		((((WORD)(*(BYTE *)(addr+1)))<<8) + (((WORD)(*(BYTE *)(addr+0)))))
N#define	GET_DWORD(addr)		((((DWORD)(*(BYTE *)(addr+3)))<<24) + (((DWORD)(*(BYTE *)(addr+2)))<<16) + (((DWORD)(*(BYTE *)(addr+1)))<<8) + (((DWORD)(*(BYTE *)(addr+0)))))
N
N
N#endif
N
L 22 "..\..\..\API\ApiSysPar.h" 2
N#include "LibCalibration.h"
L 1 "..\..\..\Lib\LibCalibration.h" 1
N/**
N  ******************************************************************************
N  * @file        LibCalibration.h
N  * @author      Johnny
N  * @version     v0.0
N  * @date        2021/10/14
N  * @brief       
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2021 Johnny</center></h2>
N  *
N  *
N  ******************************************************************************
N  */
N
N#ifndef _LIB_CALIBRATION_H_
N#define _LIB_CALIBRATION_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include <stdbool.h>
N
N/* Public define ------------------------------------------------------------*/
Ntypedef struct {  
N    int32_t A1;    
N    int32_t A2;  
N    int32_t B;
N} tCalibCoef;
N/* Public typedef -----------------------------------------------------------*/
N/* Public define ------------------------------------------------------------*/
N/* Public typedef -----------------------------------------------------------*/
N/* Public macro -------------------------------------------------------------*/
N/* Public variables ---------------------------------------------------------*/
N/* Public function prototypes -----------------------------------------------*/
Nint32_t doCalibration(tCalibCoef *par, int32_t dataX);
NtCalibCoef calCoef(int32_t valL, int32_t adcL, int32_t valH, int32_t adcH);
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _LIB_CALIBRATION_H_ */
L 23 "..\..\..\API\ApiSysPar.h" 2
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#define	APP_SYS_PAR_MAX_OCV_TABLE_NUM	25
N#define	APP_SYS_PAR_MAX_RA_TABLE_NUM	25
N
N
N#define	CALI_P1_INDEX	0
N#define	CALI_P2_INDEX	1
N
Ntypedef struct{
N    int32_t 	valL;
N    int32_t 	valH;
N    int32_t 	adcL;
N    int32_t 	adcH;
N}tCaliPar;
N
N
Ntypedef struct{
N	tLbyte			SetValue;
N	tLbyte			STime;
N	tLbyte			RelValue;
N	tLbyte			RTime;
N}tScuProtectPar;
N
N
Ntypedef struct{
N		uint8_t		Level;
N		uint16_t	Value;
N}tOcvRaTable;
N
Ntypedef struct{
N	uint8_t			HeadInfo[8];
N	uint16_t		ParLeng;
N	uint16_t		DateCode;
N	uint32_t		Checksum;
N	tCaliPar		Currentt[2];
N	tCaliPar		VBat[2];
N	uint32_t	Reserved;
N}tCalRomPar;
N
Ntypedef struct{
N	tCalRomPar			RomPar;
N	struct{	
N		tCalibCoef		Current[2];
N		tCalibCoef		VBat[2];
N	}RamPar;
N}tSysCalPar;
N
Nextern tSysCalPar	SysCalPar;
N
N/* Public define ------------------------------------------------------------*/
N#define	MAX_NOTE_MESSAGE_STRING_ITEM	100
N
N/* Public macro -------------------------------------------------------------*/
N/* Public function prototypes -----------------------------------------------*/
N//	Battery Info
Nuint8_t apiSysParIsOvpPfSet(void);
Nuint8_t apiSysParIsUvpPfSet(void);
Nvoid apiSysParOvpPfClean(void);
Nvoid apiSysParOvpPfSet(void);
Nvoid apiSysParUvpPfClean(void);
Nvoid apiSysParUvpPfSet(void);
N
N//	Cali
Nvoid apiCaliParSetCurrentValue(uint8_t CurrentNum, uint8_t PointIndex,int32_t Value, int32_t Adc);
Nvoid apiCaliParGetCurrentValue(uint8_t CurrentNum, uint8_t PointIndex,int32_t *Value, int32_t *Adc);
Nvoid apiCaliParSetVbatValue(uint8_t CurrentIndex, uint8_t PointIndex,int32_t Value, int32_t Adc);
Nvoid apiCaliParGetVbatValue(uint8_t CurrentNum, uint8_t PointIndex,int32_t *Value, int32_t *Adc);
Nuint32_t apiCaliParGetChecksum(void);
N
N
N
N
N
N// system par
Nuint32_t apiSysParGetHwVersion(void);
Nvoid apiSysParSetHwVersion(uint32_t version);
Nuint32_t apiSysParGetFwVersion(void);
Nvoid appSysParSetFwVersion(uint32_t version);
N
N
Nuint8_t apiSysParGetBmuNumber(void);
Nvoid apiSysParSetBmuNumber(uint8_t BmuNumber);
Nuint32_t apiSysParGetCellFlag(uint8_t BmuIndex);
Nvoid apiSysParSetCellFlag(uint8_t BmuIndex,uint32_t CellFlag);
Nuint32_t apiSysParGetNtcFlag(uint8_t BmuIndex);
Nvoid apiSysParSetNtcFlag(uint8_t BmuIndex,uint32_t NtcFlag);
N
Nuint16_t apiSysParGetZeroCurrentValue(void);
Nvoid apiSysParSetZeroCurrentValue(uint16_t current);
Nuint16_t apiSysParGetMinChargeCurrentValue(void);
Nvoid apiSysParSetMinChargeCurrentValue(uint16_t current);
N
Nuint32_t apiSysParGetDesignedCapacity(void);
Nvoid apiSysParSetDesignedCapacity(uint32_t dc);
N
Nvoid apiSysParGetFullChargeCondition(tScuProtectPar *pPar);
Nvoid apiSysParSetFullChargeCondition(tScuProtectPar *pPar);
N
N
Nuint16_t apiSysParGetMinFlatVoltage(void);
Nuint16_t apiSysParGetMaxFlatVoltage(void);
N
Nvoid apiSysParGetFlatVoltage(tScuProtectPar *pPar);
Nvoid apiSysParSetFlatVoltage(tScuProtectPar *pPar);
N
N
N
Nuint16_t apiSysParGetCellNumber(void);
Nuint16_t apiSysParGetNtcNumber(void);
N
Nvoid apiSysParGetOcvTable(uint8_t index ,tOcvRaTable *pOcvTable);
Nvoid apiSysParGetRaTable(uint8_t index ,tOcvRaTable *pOcvTable);
Nvoid apiSysParSetOcvTable(uint8_t index ,tOcvRaTable *pOcvTable);
Nvoid apiSysParSetRaTable(uint8_t index ,tOcvRaTable *pOcvTable);
N
Nvoid apiSysParGetAfeCommTime(tScuProtectPar *pPar);
Nvoid apiSysParSetAfeCommTime(tScuProtectPar *pPar);
Nvoid apiSysParGetInsulationResistance(tScuProtectPar *pPar);
Nvoid apiSysParSetInsulationResistance(tScuProtectPar *pPar);
N
Nuint16_t apiSysParGetTerminateVoltage(void);
Nvoid apiSysParSetTerminateVoltage(uint16_t voltage);
Nuint16_t apiSysParGetPreDischargeTime(void);
Nvoid apiSysParSetPreDischargeTime(uint16_t time);
Nuint16_t apiSysParGetRelayOnDiffVoltage(void);
Nvoid apiSysParSetRelayOnDiffVoltage(uint16_t voltage);
N
Nuint8_t apiSysParGetScuId(void);
Nvoid saveScuIdPar(uint8_t scuid);
N
N//protect
N//uint16_t appSysParGetOvpSetValue(uint8_t level);
Nuint16_t appSysParGetOvpSetTime(uint8_t level);
Nuint16_t appSysParGetOvpReleaseValue(uint8_t level);
Nuint16_t appSysParGetOvpReleaseTime(uint8_t level);
N
Nvoid apiSysParGetOvpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetOvpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetUvpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetUvpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGet2ndOtProtectPar(tScuProtectPar *pPar);
Nvoid apiSysParSet2ndOtProtectPar(tScuProtectPar *pPar);
Nvoid apiSysParGet2ndUtProtectPar(tScuProtectPar *pPar);
Nvoid apiSysParSet2ndUtProtectPar(tScuProtectPar *pPar);
N
Nvoid apiSysParGetCotpProtectPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParGetCotpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetCotpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetCutpProtectPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParGetCutpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetCutpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetDotpProtectPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParGetDotpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetDotpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetDutpProtectPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParGetDutpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetDutpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetDtpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetDtpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetCocpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetCocpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetDocpPar(uint8_t level, tScuProtectPar *pPar);
Nvoid apiSysParSetDocpPar(uint8_t level, tScuProtectPar *pPar);
N
Nvoid apiSysParGetOvpPfPar(tScuProtectPar *pPar);
Nvoid apiSysParSetOvpPfPar(tScuProtectPar *pPar);
N
Nvoid apiSysParGetUvpPfPar(tScuProtectPar *pPar);
Nvoid apiSysParSetUvpPfPar(tScuProtectPar *pPar);
N
Nvoid apiSysParGetBalanceDuty(tScuProtectPar *pPar);
Nvoid apiSysParSetBalanceDuty(tScuProtectPar *pPar);
Nvoid apiSysParGetBalanceChg(tScuProtectPar *pPar);
Nvoid apiSysParSetBalanceChg(tScuProtectPar *pPar);
Nvoid apiSysParGetBalanceDhg(tScuProtectPar *pPar);
Nvoid apiSysParSetBalanceDhg(tScuProtectPar *pPar);
Nvoid apiSysParGetBalanceRlx(tScuProtectPar *pPar);
Nvoid apiSysParSetBalanceRlx(tScuProtectPar *pPar);
N
Nvoid apiSysParGetNotwMessageString(uint8_t *pMsg);
Nvoid apiSysParSetNotwMessageString(uint8_t *pMsg);
N
Nuint32_t apiSysParGetQmax(void);
Nvoid apiSysParSetQmax(uint32_t Qmax);
Nuint16_t apiSysParGetQmaxUpdateTimes(void);
Nvoid apiSysParSetQmaxUpdateTimes(uint16_t times);
Nuint16_t apiSysParGetCycleCount(void);
Nvoid apiSysParSetCycleCount(uint16_t count);
Nuint16_t apiSysParGetPfFlag(void);
Nvoid apiSysParSetPfFlag(uint16_t flag);
Nuint32_t apiSysParGetChecksum(void);
N
Nuint16_t apiSysParOpen(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N	
N
N#endif /* _API_SYS_PAR_H_ */
N
N/************************ (C) COPYRIGHT Johnny Wang *****END OF FILE****/    
N
N
L 24 "..\..\..\HAL\HalAfe.c" 2
N
N/* Private define ------------------------------------------------------------*/
N#define		afeCellNumber()		apiSysParGetCellNumber()
N#define		afeNtcNumber()		apiSysParGetNtcNumber()
N/* Private macro -------------------------------------------------------------*/
N
N/* Private typedef -----------------------------------------------------------*/
N
Ntypedef struct{
N	tCellVoltage	CellVoltage[MAX_CELL_NUMBER + 4];
X	uint16_t	CellVoltage[400 + 4];
N	tNtcAdcData		NtcAdcData[MAX_NTC_NUMBER + 4];
X	uint16_t		NtcAdcData[400 + 4];
N	tCurrent		CurrentValue[2];
X	int32_t		CurrentValue[2];
N	int32_t			CurrentAdcValue[2];
N	uint32_t		VBat[2];
N	int32_t			VbatAdcValue[2];
N	uint16_t		CellNumber;
N	uint16_t		MaxCellVoltage;
N	uint16_t		MinCellVoltage;
N	uint16_t		MaxTempNtcVoltage;
N	uint16_t		MinTempNtcVoltage;
N}tAfeBuffer;
N
NtAfeBuffer	AfeBuffer;
N/* Public variables ---------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
N/* Public function prototypes -----------------------------------------------*/
Nint32_t	halAfeGetCurrentAdcValue(uint8_t CurrentIndex)
N{
N	if(CurrentIndex >= 2)
N		return 0;
N	return AfeBuffer.CurrentAdcValue[CurrentIndex];
N}
N
Nvoid halAfeSetCurrentAdcValue(uint8_t CurrentIndex,int32_t adcvalue)
N{
N	if(CurrentIndex >= 2)
N		return;
N	AfeBuffer.CurrentAdcValue[CurrentIndex] = adcvalue;
N}
Nint32_t	halAfeGetVBatAdcValue(uint8_t VbIndex)
N{
N	if(VbIndex >= 2)
N		return 0;
N	return AfeBuffer.VbatAdcValue[VbIndex];
N}
Nvoid halAfeSetVBatAdcValue(uint8_t VbIndex, int32_t adcvalue)
N{
N	if(VbIndex >= 2)
N		return;
N	AfeBuffer.VbatAdcValue[VbIndex] = adcvalue;
N}
N
Nvoid halAfeSetCellVoltage(uint16_t cell, tCellVoltage voltage)
Xvoid halAfeSetCellVoltage(uint16_t cell, uint16_t voltage)
N{
N	AfeBuffer.CellVoltage[cell] = voltage;
N}
Nvoid halAfeSetNtcAdcData(uint16_t ntcs, tNtcAdcData adcdata)
Xvoid halAfeSetNtcAdcData(uint16_t ntcs, uint16_t adcdata)
N{
N	AfeBuffer.NtcAdcData[ntcs] = adcdata;
N}
N
NtBatteryVoltage HalAfeGetBatteryVoltage(void)
Xuint32_t HalAfeGetBatteryVoltage(void)
N{
N	tBatteryVoltage	vbat = 0;
X	uint32_t	vbat = 0;
N	uint16_t		cell;
N		 
N	for(cell=0; cell<AfeBuffer.CellNumber; cell++)
N	{
N		vbat += AfeBuffer.CellVoltage[cell];
N	}
N	return vbat;
N}
N
NtCellVoltage halAfeGetCellVoltage(uint16_t CellIndex)
Xuint16_t halAfeGetCellVoltage(uint16_t CellIndex)
N{
N	return AfeBuffer.CellVoltage[CellIndex];	
N}
N
NtNtcAdcData HalAfeGetNtcAdc(uint16_t NtcIndex)
Xuint16_t HalAfeGetNtcAdc(uint16_t NtcIndex)
N{
N	return AfeBuffer.NtcAdcData[NtcIndex];	
N}
N
NtCurrent halAfeGetCurrentValue(uint8_t index)
Xint32_t halAfeGetCurrentValue(uint8_t index)
N{
N	return AfeBuffer.CurrentValue[index];
N}
Nvoid HalAfeSetCurrentValue(uint8_t index, int32_t current)
N{
N	AfeBuffer.CurrentValue[index] = current;
N}
N
Nuint32_t halAfeGetVBatVoltage(uint8_t index)
N{
N	return AfeBuffer.VBat[index];
N}
Nvoid halAfeSetVBatVoltage(uint8_t index, uint32_t voltage)
N{
N	AfeBuffer.VBat[index] = voltage;
N}
N
N
NtCellVoltage halAfeGetMaxCellVoltage(void)
Xuint16_t halAfeGetMaxCellVoltage(void)
N{
N	return AfeBuffer.MaxCellVoltage;
N}
N
NtCellVoltage halAfeGetMinCellVoltage(void)
Xuint16_t halAfeGetMinCellVoltage(void)
N{
N	return AfeBuffer.MinCellVoltage;
N}
N
NtNtcAdcData HalAfeGetMinNtcTempAdc(void)
Xuint16_t HalAfeGetMinNtcTempAdc(void)
N{
N	return AfeBuffer.MinTempNtcVoltage;
N}
NtNtcAdcData HalAfeGetMaxNtcTempAdc(void)
Xuint16_t HalAfeGetMaxNtcTempAdc(void)
N{
N	return AfeBuffer.MaxTempNtcVoltage;
N}
N
N
Nvoid halAfeUpdateMinMaxCellVoltage(void)
N{
N	uint16_t	cell;
N	tCellVoltage	cv;
X	uint16_t	cv;
N	
N	AfeBuffer.MaxCellVoltage = 0;
N	AfeBuffer.MinCellVoltage = 0xffff;
N	
N	for(cell=0; cell<afeCellNumber(); cell++)
X	for(cell=0; cell<apiSysParGetCellNumber(); cell++)
N	{
N		cv  = halAfeGetCellVoltage(cell);
N		if(cv > AfeBuffer.MaxCellVoltage)
N		{		
N			AfeBuffer.MaxCellVoltage = cv;
N		}
N		if(cv < AfeBuffer.MinCellVoltage)
N		{		
N			AfeBuffer.MinCellVoltage = cv;
N		}
N	}
N}
Nvoid halAfeUpdateMinMaxNtcTempVoltage(void)
N{
N	uint16_t	ntc;
N	uint16_t	cv;
N	
N	AfeBuffer.MinTempNtcVoltage = 0;
N	AfeBuffer.MaxTempNtcVoltage = 0xffff;
N	
N	for(ntc=0; ntc<afeNtcNumber(); ntc++)
X	for(ntc=0; ntc<apiSysParGetNtcNumber(); ntc++)
N	{
N		cv = HalAfeGetNtcAdc(ntc);
N		if(cv < AfeBuffer.MaxTempNtcVoltage)
N		{		
N			AfeBuffer.MaxTempNtcVoltage = cv;
N		}
N		if(cv > AfeBuffer.MinTempNtcVoltage)
N		{		
N			AfeBuffer.MinTempNtcVoltage = cv;
N		}
N	}
N}
N
N//tNtcAdcData HalAfeGetNtcAdc(uint16_t NtcIndex)
N
N/************************ (C) COPYRIGHT Johnny Wang *****END OF FILE****/    
N
N
