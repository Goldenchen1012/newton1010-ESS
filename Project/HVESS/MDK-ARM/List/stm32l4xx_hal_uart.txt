; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_uart.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2994     */
;;;2995   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;2996   {
;;;2997     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d015              BEQ      |L1.52|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;2998     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  6781              STR      r1,[r0,#0x78]
;;;2999   
;;;3000     /* Clear TE and RE bits */
;;;3001     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
000012  6801              LDR      r1,[r0,#0]
000014  680a              LDR      r2,[r1,#0]
000016  f022020c          BIC      r2,r2,#0xc
00001a  600a              STR      r2,[r1,#0]
;;;3002   
;;;3003     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;3004     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
00001c  6801              LDR      r1,[r0,#0]
00001e  680a              LDR      r2,[r1,#0]
000020  f0420204          ORR      r2,r2,#4
000024  600a              STR      r2,[r1,#0]
;;;3005   
;;;3006     huart->gState = HAL_UART_STATE_READY;
000026  2120              MOVS     r1,#0x20
000028  6781              STR      r1,[r0,#0x78]
;;;3007   
;;;3008     __HAL_UNLOCK(huart);
00002a  2100              MOVS     r1,#0
00002c  f8801074          STRB     r1,[r0,#0x74]
;;;3009   
;;;3010     return HAL_OK;
000030  2000              MOVS     r0,#0
;;;3011   }
000032  4770              BX       lr
                  |L1.52|
000034  2002              MOVS     r0,#2                 ;2997
000036  4770              BX       lr
;;;3012   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2971     */
;;;2972   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;2973   {
;;;2974     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d015              BEQ      |L2.52|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;2975     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  6781              STR      r1,[r0,#0x78]
;;;2976   
;;;2977     /* Clear TE and RE bits */
;;;2978     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
000012  6801              LDR      r1,[r0,#0]
000014  680a              LDR      r2,[r1,#0]
000016  f022020c          BIC      r2,r2,#0xc
00001a  600a              STR      r2,[r1,#0]
;;;2979   
;;;2980     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2981     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
00001c  6801              LDR      r1,[r0,#0]
00001e  680a              LDR      r2,[r1,#0]
000020  f0420208          ORR      r2,r2,#8
000024  600a              STR      r2,[r1,#0]
;;;2982   
;;;2983     huart->gState = HAL_UART_STATE_READY;
000026  2120              MOVS     r1,#0x20
000028  6781              STR      r1,[r0,#0x78]
;;;2984   
;;;2985     __HAL_UNLOCK(huart);
00002a  2100              MOVS     r1,#0
00002c  f8801074          STRB     r1,[r0,#0x74]
;;;2986   
;;;2987     return HAL_OK;
000030  2000              MOVS     r0,#0
;;;2988   }
000032  4770              BX       lr
                  |L2.52|
000034  2002              MOVS     r0,#2                 ;2974
000036  4770              BX       lr
;;;2989   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;393      */
;;;394    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;395    {
000002  4604              MOV      r4,r0
;;;396      /* Check the UART handle allocation */
;;;397      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d002              BEQ      |L3.14|
;;;398      {
;;;399        return HAL_ERROR;
;;;400      }
;;;401    
;;;402      /* Check UART instance */
;;;403      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;404    
;;;405      if (huart->gState == HAL_UART_STATE_RESET)
000008  6fa0              LDR      r0,[r4,#0x78]
00000a  b110              CBZ      r0,|L3.18|
00000c  e007              B        |L3.30|
                  |L3.14|
00000e  2001              MOVS     r0,#1                 ;399
;;;406      {
;;;407        /* Allocate lock resource and initialize it */
;;;408        huart->Lock = HAL_UNLOCKED;
;;;409    
;;;410    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;411        UART_InitCallbacksToDefault(huart);
;;;412    
;;;413        if (huart->MspInitCallback == NULL)
;;;414        {
;;;415          huart->MspInitCallback = HAL_UART_MspInit;
;;;416        }
;;;417    
;;;418        /* Init the low level hardware */
;;;419        huart->MspInitCallback(huart);
;;;420    #else
;;;421        /* Init the low level hardware : GPIO, CLOCK */
;;;422        HAL_UART_MspInit(huart);
;;;423    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;424      }
;;;425    
;;;426      huart->gState = HAL_UART_STATE_BUSY;
;;;427    
;;;428      __HAL_UART_DISABLE(huart);
;;;429    
;;;430      /* Set the UART Communication parameters */
;;;431      if (UART_SetConfig(huart) == HAL_ERROR)
;;;432      {
;;;433        return HAL_ERROR;
;;;434      }
;;;435    
;;;436      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;437      {
;;;438        UART_AdvFeatureConfig(huart);
;;;439      }
;;;440    
;;;441      /* In half-duplex mode, the following bits must be kept cleared:
;;;442      - LINEN and CLKEN bits in the USART_CR2 register,
;;;443      - SCEN and IREN bits in the USART_CR3 register.*/
;;;444      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;445      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;446    
;;;447      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;448      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;449    
;;;450      __HAL_UART_ENABLE(huart);
;;;451    
;;;452      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;453      return (UART_CheckIdleState(huart));
;;;454    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2000              MOVS     r0,#0                 ;408
000014  f8840074          STRB     r0,[r4,#0x74]         ;408
000018  4620              MOV      r0,r4                 ;422
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L3.30|
00001e  2024              MOVS     r0,#0x24              ;426
000020  67a0              STR      r0,[r4,#0x78]         ;426
000022  6820              LDR      r0,[r4,#0]            ;428
000024  6801              LDR      r1,[r0,#0]            ;428
000026  f0210101          BIC      r1,r1,#1              ;428
00002a  6001              STR      r1,[r0,#0]            ;428
00002c  4620              MOV      r0,r4                 ;431
00002e  f7fffffe          BL       UART_SetConfig
000032  2801              CMP      r0,#1                 ;431
000034  d01d              BEQ      |L3.114|
000036  6a60              LDR      r0,[r4,#0x24]         ;436
000038  b110              CBZ      r0,|L3.64|
00003a  4620              MOV      r0,r4                 ;438
00003c  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.64|
000040  6820              LDR      r0,[r4,#0]            ;444
000042  6841              LDR      r1,[r0,#4]            ;444
000044  f4214190          BIC      r1,r1,#0x4800         ;444
000048  6041              STR      r1,[r0,#4]            ;444
00004a  6820              LDR      r0,[r4,#0]            ;445
00004c  6881              LDR      r1,[r0,#8]            ;445
00004e  f0210122          BIC      r1,r1,#0x22           ;445
000052  6081              STR      r1,[r0,#8]            ;445
000054  6820              LDR      r0,[r4,#0]            ;448
000056  6881              LDR      r1,[r0,#8]            ;448
000058  f0410108          ORR      r1,r1,#8              ;448
00005c  6081              STR      r1,[r0,#8]            ;448
00005e  6820              LDR      r0,[r4,#0]            ;450
000060  6801              LDR      r1,[r0,#0]            ;450
000062  f0410101          ORR      r1,r1,#1              ;450
000066  6001              STR      r1,[r0,#0]            ;450
000068  4620              MOV      r0,r4                 ;453
00006a  e8bd4010          POP      {r4,lr}               ;453
00006e  f7ffbffe          B.W      UART_CheckIdleState
                  |L3.114|
000072  2001              MOVS     r0,#1                 ;433
000074  bd10              POP      {r4,pc}
;;;455    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;466      */
;;;467    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;468    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;469      /* Check the UART handle allocation */
;;;470      if (huart == NULL)
000006  2c00              CMP      r4,#0
000008  d007              BEQ      |L4.26|
;;;471      {
;;;472        return HAL_ERROR;
;;;473      }
;;;474    
;;;475      /* Check the LIN UART instance */
;;;476      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;477      /* Check the Break detection length parameter */
;;;478      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;479    
;;;480      /* LIN mode limited to 16-bit oversampling only */
;;;481      if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
00000a  69e0              LDR      r0,[r4,#0x1c]
00000c  f5b04f00          CMP      r0,#0x8000
000010  d005              BEQ      |L4.30|
;;;482      {
;;;483        return HAL_ERROR;
;;;484      }
;;;485      /* LIN mode limited to 8-bit data length */
;;;486      if (huart->Init.WordLength != UART_WORDLENGTH_8B)
000012  68a0              LDR      r0,[r4,#8]
000014  b128              CBZ      r0,|L4.34|
;;;487      {
;;;488        return HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;489      }
;;;490    
;;;491      if (huart->gState == HAL_UART_STATE_RESET)
;;;492      {
;;;493        /* Allocate lock resource and initialize it */
;;;494        huart->Lock = HAL_UNLOCKED;
;;;495    
;;;496    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;497        UART_InitCallbacksToDefault(huart);
;;;498    
;;;499        if (huart->MspInitCallback == NULL)
;;;500        {
;;;501          huart->MspInitCallback = HAL_UART_MspInit;
;;;502        }
;;;503    
;;;504        /* Init the low level hardware */
;;;505        huart->MspInitCallback(huart);
;;;506    #else
;;;507        /* Init the low level hardware : GPIO, CLOCK */
;;;508        HAL_UART_MspInit(huart);
;;;509    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;510      }
;;;511    
;;;512      huart->gState = HAL_UART_STATE_BUSY;
;;;513    
;;;514      __HAL_UART_DISABLE(huart);
;;;515    
;;;516      /* Set the UART Communication parameters */
;;;517      if (UART_SetConfig(huart) == HAL_ERROR)
;;;518      {
;;;519        return HAL_ERROR;
;;;520      }
;;;521    
;;;522      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;523      {
;;;524        UART_AdvFeatureConfig(huart);
;;;525      }
;;;526    
;;;527      /* In LIN mode, the following bits must be kept cleared:
;;;528      - LINEN and CLKEN bits in the USART_CR2 register,
;;;529      - SCEN and IREN bits in the USART_CR3 register.*/
;;;530      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;531      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;532    
;;;533      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;534      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;535    
;;;536      /* Set the USART LIN Break detection length. */
;;;537      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;538    
;;;539      __HAL_UART_ENABLE(huart);
;;;540    
;;;541      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;542      return (UART_CheckIdleState(huart));
;;;543    }
000018  bd70              POP      {r4-r6,pc}
                  |L4.26|
00001a  2001              MOVS     r0,#1                 ;472
00001c  bd70              POP      {r4-r6,pc}
                  |L4.30|
00001e  2001              MOVS     r0,#1                 ;483
000020  bd70              POP      {r4-r6,pc}
                  |L4.34|
000022  6fa0              LDR      r0,[r4,#0x78]         ;491
000024  b928              CBNZ     r0,|L4.50|
000026  2000              MOVS     r0,#0                 ;494
000028  f8840074          STRB     r0,[r4,#0x74]         ;494
00002c  4620              MOV      r0,r4                 ;508
00002e  f7fffffe          BL       HAL_UART_MspInit
                  |L4.50|
000032  2024              MOVS     r0,#0x24              ;512
000034  67a0              STR      r0,[r4,#0x78]         ;512
000036  6820              LDR      r0,[r4,#0]            ;514
000038  6801              LDR      r1,[r0,#0]            ;514
00003a  f0210101          BIC      r1,r1,#1              ;514
00003e  6001              STR      r1,[r0,#0]            ;514
000040  4620              MOV      r0,r4                 ;517
000042  f7fffffe          BL       UART_SetConfig
000046  2801              CMP      r0,#1                 ;517
000048  d023              BEQ      |L4.146|
00004a  6a60              LDR      r0,[r4,#0x24]         ;522
00004c  b110              CBZ      r0,|L4.84|
00004e  4620              MOV      r0,r4                 ;524
000050  f7fffffe          BL       UART_AdvFeatureConfig
                  |L4.84|
000054  6820              LDR      r0,[r4,#0]            ;530
000056  6841              LDR      r1,[r0,#4]            ;530
000058  f4216100          BIC      r1,r1,#0x800          ;530
00005c  6041              STR      r1,[r0,#4]            ;530
00005e  6820              LDR      r0,[r4,#0]            ;531
000060  6881              LDR      r1,[r0,#8]            ;531
000062  f021012a          BIC      r1,r1,#0x2a           ;531
000066  6081              STR      r1,[r0,#8]            ;531
000068  6820              LDR      r0,[r4,#0]            ;534
00006a  6841              LDR      r1,[r0,#4]            ;534
00006c  f4414180          ORR      r1,r1,#0x4000         ;534
000070  6041              STR      r1,[r0,#4]            ;534
000072  6820              LDR      r0,[r4,#0]            ;537
000074  6841              LDR      r1,[r0,#4]            ;537
000076  f0210120          BIC      r1,r1,#0x20           ;537
00007a  4329              ORRS     r1,r1,r5              ;537
00007c  6041              STR      r1,[r0,#4]            ;537
00007e  6820              LDR      r0,[r4,#0]            ;539
000080  6801              LDR      r1,[r0,#0]            ;539
000082  f0410101          ORR      r1,r1,#1              ;539
000086  6001              STR      r1,[r0,#0]            ;539
000088  4620              MOV      r0,r4                 ;542
00008a  e8bd4070          POP      {r4-r6,lr}            ;542
00008e  f7ffbffe          B.W      UART_CheckIdleState
                  |L4.146|
000092  2001              MOVS     r0,#1                 ;519
000094  bd70              POP      {r4-r6,pc}
;;;544    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;3018     */
;;;3019   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;3020   {
;;;3021     /* Check the parameters */
;;;3022     assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;3023   
;;;3024     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L5.42|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;3025   
;;;3026     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  6781              STR      r1,[r0,#0x78]
;;;3027   
;;;3028     /* Send break characters */
;;;3029     __HAL_UART_SEND_REQ(huart, UART_SENDBREAK_REQUEST);
000012  6801              LDR      r1,[r0,#0]
000014  8b0a              LDRH     r2,[r1,#0x18]
000016  f0420202          ORR      r2,r2,#2
00001a  830a              STRH     r2,[r1,#0x18]
;;;3030   
;;;3031     huart->gState = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  6781              STR      r1,[r0,#0x78]
;;;3032   
;;;3033     __HAL_UNLOCK(huart);
000020  2100              MOVS     r1,#0
000022  f8801074          STRB     r1,[r0,#0x74]
;;;3034   
;;;3035     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;3036   }
000028  4770              BX       lr
                  |L5.42|
00002a  2002              MOVS     r0,#2                 ;3024
00002c  4770              BX       lr
;;;3037   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;2941     */
;;;2942   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;2943   {
;;;2944     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00d              BEQ      |L6.36|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;2945   
;;;2946     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  6781              STR      r1,[r0,#0x78]
;;;2947   
;;;2948     /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;2949     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
000012  6801              LDR      r1,[r0,#0]
000014  680a              LDR      r2,[r1,#0]
000016  f4225200          BIC      r2,r2,#0x2000
00001a  600a              STR      r2,[r1,#0]
;;;2950   
;;;2951     huart->gState = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  6781              STR      r1,[r0,#0x78]
;;;2952   
;;;2953     return (UART_CheckIdleState(huart));
000020  f7ffbffe          B.W      UART_CheckIdleState
                  |L6.36|
000024  2002              MOVS     r0,#2                 ;2944
;;;2954   }
000026  4770              BX       lr
;;;2955   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;2921     */
;;;2922   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;2923   {
;;;2924     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00d              BEQ      |L7.36|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;2925   
;;;2926     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  6781              STR      r1,[r0,#0x78]
;;;2927   
;;;2928     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;2929     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
000012  6801              LDR      r1,[r0,#0]
000014  680a              LDR      r2,[r1,#0]
000016  f4425200          ORR      r2,r2,#0x2000
00001a  600a              STR      r2,[r1,#0]
;;;2930   
;;;2931     huart->gState = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  6781              STR      r1,[r0,#0x78]
;;;2932   
;;;2933     return (UART_CheckIdleState(huart));
000020  f7ffbffe          B.W      UART_CheckIdleState
                  |L7.36|
000024  2002              MOVS     r0,#2                 ;2924
;;;2934   }
000026  4770              BX       lr
;;;2935   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2961     */
;;;2962   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6800              LDR      r0,[r0,#0]
;;;2963   {
;;;2964     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  8b01              LDRH     r1,[r0,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  8301              STRH     r1,[r0,#0x18]
;;;2965   }
00000a  4770              BX       lr
;;;2966   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;563      */
;;;564    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;565    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;566      /* Check the UART handle allocation */
;;;567      if (huart == NULL)
000008  2c00              CMP      r4,#0
00000a  d002              BEQ      |L9.18|
;;;568      {
;;;569        return HAL_ERROR;
;;;570      }
;;;571    
;;;572      /* Check the wake up method parameter */
;;;573      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;574    
;;;575      if (huart->gState == HAL_UART_STATE_RESET)
00000c  6fa0              LDR      r0,[r4,#0x78]
00000e  b110              CBZ      r0,|L9.22|
000010  e007              B        |L9.34|
                  |L9.18|
000012  2001              MOVS     r0,#1                 ;569
;;;576      {
;;;577        /* Allocate lock resource and initialize it */
;;;578        huart->Lock = HAL_UNLOCKED;
;;;579    
;;;580    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;581        UART_InitCallbacksToDefault(huart);
;;;582    
;;;583        if (huart->MspInitCallback == NULL)
;;;584        {
;;;585          huart->MspInitCallback = HAL_UART_MspInit;
;;;586        }
;;;587    
;;;588        /* Init the low level hardware */
;;;589        huart->MspInitCallback(huart);
;;;590    #else
;;;591        /* Init the low level hardware : GPIO, CLOCK */
;;;592        HAL_UART_MspInit(huart);
;;;593    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;594      }
;;;595    
;;;596      huart->gState = HAL_UART_STATE_BUSY;
;;;597    
;;;598      __HAL_UART_DISABLE(huart);
;;;599    
;;;600      /* Set the UART Communication parameters */
;;;601      if (UART_SetConfig(huart) == HAL_ERROR)
;;;602      {
;;;603        return HAL_ERROR;
;;;604      }
;;;605    
;;;606      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;607      {
;;;608        UART_AdvFeatureConfig(huart);
;;;609      }
;;;610    
;;;611      /* In multiprocessor mode, the following bits must be kept cleared:
;;;612      - LINEN and CLKEN bits in the USART_CR2 register,
;;;613      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;614      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;615      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;616    
;;;617      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;618      {
;;;619        /* If address mark wake up method is chosen, set the USART address node */
;;;620        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;621      }
;;;622    
;;;623      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;624      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;625    
;;;626      __HAL_UART_ENABLE(huart);
;;;627    
;;;628      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;629      return (UART_CheckIdleState(huart));
;;;630    }
000014  bd70              POP      {r4-r6,pc}
                  |L9.22|
000016  2000              MOVS     r0,#0                 ;578
000018  f8840074          STRB     r0,[r4,#0x74]         ;578
00001c  4620              MOV      r0,r4                 ;592
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L9.34|
000022  2024              MOVS     r0,#0x24              ;596
000024  67a0              STR      r0,[r4,#0x78]         ;596
000026  6820              LDR      r0,[r4,#0]            ;598
000028  6801              LDR      r1,[r0,#0]            ;598
00002a  f0210101          BIC      r1,r1,#1              ;598
00002e  6001              STR      r1,[r0,#0]            ;598
000030  4620              MOV      r0,r4                 ;601
000032  f7fffffe          BL       UART_SetConfig
000036  2801              CMP      r0,#1                 ;601
000038  d012              BEQ      |L9.96|
00003a  6a60              LDR      r0,[r4,#0x24]         ;606
00003c  b110              CBZ      r0,|L9.68|
00003e  4620              MOV      r0,r4                 ;608
000040  f7fffffe          BL       UART_AdvFeatureConfig
                  |L9.68|
000044  6820              LDR      r0,[r4,#0]            ;614
000046  6841              LDR      r1,[r0,#4]            ;614
000048  f4214190          BIC      r1,r1,#0x4800         ;614
00004c  6041              STR      r1,[r0,#4]            ;614
00004e  6820              LDR      r0,[r4,#0]            ;615
000050  6881              LDR      r1,[r0,#8]            ;615
000052  f021012a          BIC      r1,r1,#0x2a           ;615
000056  6081              STR      r1,[r0,#8]            ;615
000058  f5b56f00          CMP      r5,#0x800             ;617
00005c  d002              BEQ      |L9.100|
00005e  e006              B        |L9.110|
                  |L9.96|
000060  2001              MOVS     r0,#1                 ;603
000062  bd70              POP      {r4-r6,pc}
                  |L9.100|
000064  6820              LDR      r0,[r4,#0]            ;620
000066  6841              LDR      r1,[r0,#4]            ;620
000068  f366611f          BFI      r1,r6,#24,#8          ;620
00006c  6041              STR      r1,[r0,#4]            ;620
                  |L9.110|
00006e  6820              LDR      r0,[r4,#0]            ;624
000070  6801              LDR      r1,[r0,#0]            ;624
000072  f4216100          BIC      r1,r1,#0x800          ;624
000076  4329              ORRS     r1,r1,r5              ;624
000078  6001              STR      r1,[r0,#0]            ;624
00007a  6820              LDR      r0,[r4,#0]            ;626
00007c  6801              LDR      r1,[r0,#0]            ;626
00007e  f0410101          ORR      r1,r1,#1              ;626
000082  6001              STR      r1,[r0,#0]            ;626
000084  4620              MOV      r0,r4                 ;629
000086  e8bd4070          POP      {r4-r6,lr}            ;629
00008a  f7ffbffe          B.W      UART_CheckIdleState
;;;631    
                          ENDP


                          AREA ||i.HAL_UARTEx_RxEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_RxEventCallback PROC
;;;2782     */
;;;2783   __weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
000000  4770              BX       lr
;;;2784   {
;;;2785     /* Prevent unused argument(s) compilation warning */
;;;2786     UNUSED(huart);
;;;2787     UNUSED(Size);
;;;2788   
;;;2789     /* NOTE : This function should not be modified, when the callback is needed,
;;;2790               the HAL_UARTEx_RxEventCallback can be implemented in the user file.
;;;2791      */
;;;2792   }
;;;2793   
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1705     */
;;;1706   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1707   {
000002  4604              MOV      r4,r0
;;;1708   #if defined(USART_CR1_FIFOEN)
;;;1709     /* Disable TXE, TC, RXNE, PE, RXFT, TXFT and ERR (Frame error, noise error, overrun error) interrupts */
;;;1710     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
;;;1711                                      USART_CR1_TCIE));
;;;1712     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE);
;;;1713   #else
;;;1714     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1715     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  6001              STR      r1,[r0,#0]
;;;1716     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210101          BIC      r1,r1,#1
000016  6081              STR      r1,[r0,#8]
;;;1717   #endif /* USART_CR1_FIFOEN */
;;;1718   
;;;1719     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;1720     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000018  6e20              LDR      r0,[r4,#0x60]
00001a  2801              CMP      r0,#1
00001c  d104              BNE      |L11.40|
;;;1721     {
;;;1722       CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
00001e  6820              LDR      r0,[r4,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0210110          BIC      r1,r1,#0x10
000026  6001              STR      r1,[r0,#0]
                  |L11.40|
;;;1723     }
;;;1724   
;;;1725     /* Disable the UART DMA Tx request if enabled */
;;;1726     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000028  6820              LDR      r0,[r4,#0]
00002a  6881              LDR      r1,[r0,#8]
;;;1727     {
;;;1728       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1729   
;;;1730       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1731       if (huart->hdmatx != NULL)
;;;1732       {
;;;1733         /* Set the UART DMA Abort callback to Null.
;;;1734            No call back execution at end of DMA abort procedure */
;;;1735         huart->hdmatx->XferAbortCallback = NULL;
;;;1736   
;;;1737         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
;;;1738         {
;;;1739           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
;;;1740           {
;;;1741             /* Set error code to DMA */
;;;1742             huart->ErrorCode = HAL_UART_ERROR_DMA;
00002c  f04f0610          MOV      r6,#0x10
000030  0609              LSLS     r1,r1,#24             ;1726
000032  f04f0500          MOV      r5,#0
000036  d50f              BPL      |L11.88|
000038  6881              LDR      r1,[r0,#8]            ;1728
00003a  f0210180          BIC      r1,r1,#0x80           ;1728
00003e  6081              STR      r1,[r0,#8]            ;1728
000040  6ee0              LDR      r0,[r4,#0x6c]         ;1731
000042  b148              CBZ      r0,|L11.88|
000044  6385              STR      r5,[r0,#0x38]         ;1735
000046  6ee0              LDR      r0,[r4,#0x6c]         ;1737
000048  f7fffffe          BL       HAL_DMA_Abort
00004c  b120              CBZ      r0,|L11.88|
00004e  6ee0              LDR      r0,[r4,#0x6c]         ;1739
000050  f7fffffe          BL       HAL_DMA_GetError
000054  2820              CMP      r0,#0x20              ;1739
000056  d027              BEQ      |L11.168|
                  |L11.88|
;;;1743   
;;;1744             return HAL_TIMEOUT;
;;;1745           }
;;;1746         }
;;;1747       }
;;;1748     }
;;;1749   
;;;1750     /* Disable the UART DMA Rx request if enabled */
;;;1751     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000058  6820              LDR      r0,[r4,#0]
00005a  6881              LDR      r1,[r0,#8]
00005c  0649              LSLS     r1,r1,#25
00005e  d50f              BPL      |L11.128|
;;;1752     {
;;;1753       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000060  6881              LDR      r1,[r0,#8]
000062  f0210140          BIC      r1,r1,#0x40
000066  6081              STR      r1,[r0,#8]
;;;1754   
;;;1755       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1756       if (huart->hdmarx != NULL)
000068  6f20              LDR      r0,[r4,#0x70]
00006a  b148              CBZ      r0,|L11.128|
;;;1757       {
;;;1758         /* Set the UART DMA Abort callback to Null.
;;;1759            No call back execution at end of DMA abort procedure */
;;;1760         huart->hdmarx->XferAbortCallback = NULL;
00006c  6385              STR      r5,[r0,#0x38]
;;;1761   
;;;1762         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
00006e  6f20              LDR      r0,[r4,#0x70]
000070  f7fffffe          BL       HAL_DMA_Abort
000074  b120              CBZ      r0,|L11.128|
;;;1763         {
;;;1764           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
000076  6f20              LDR      r0,[r4,#0x70]
000078  f7fffffe          BL       HAL_DMA_GetError
00007c  2820              CMP      r0,#0x20
00007e  d017              BEQ      |L11.176|
                  |L11.128|
;;;1765           {
;;;1766             /* Set error code to DMA */
;;;1767             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1768   
;;;1769             return HAL_TIMEOUT;
;;;1770           }
;;;1771         }
;;;1772       }
;;;1773     }
;;;1774   
;;;1775     /* Reset Tx and Rx transfer counters */
;;;1776     huart->TxXferCount = 0U;
000080  f8a45052          STRH     r5,[r4,#0x52]
;;;1777     huart->RxXferCount = 0U;
000084  f8a4505a          STRH     r5,[r4,#0x5a]
;;;1778   
;;;1779     /* Clear the Error flags in the ICR register */
;;;1780     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000088  6821              LDR      r1,[r4,#0]
00008a  200f              MOVS     r0,#0xf
00008c  6208              STR      r0,[r1,#0x20]
;;;1781   
;;;1782   #if defined(USART_CR1_FIFOEN)
;;;1783     /* Flush the whole TX FIFO (if needed) */
;;;1784     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;1785     {
;;;1786       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;1787     }
;;;1788   #endif /* USART_CR1_FIFOEN */
;;;1789   
;;;1790     /* Discard the received data */
;;;1791     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
00008e  6820              LDR      r0,[r4,#0]
000090  8b01              LDRH     r1,[r0,#0x18]
000092  f0410108          ORR      r1,r1,#8
000096  8301              STRH     r1,[r0,#0x18]
;;;1792   
;;;1793     /* Restore huart->gState and huart->RxState to Ready */
;;;1794     huart->gState  = HAL_UART_STATE_READY;
000098  2020              MOVS     r0,#0x20
00009a  67a0              STR      r0,[r4,#0x78]
;;;1795     huart->RxState = HAL_UART_STATE_READY;
00009c  67e0              STR      r0,[r4,#0x7c]
;;;1796     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00009e  6625              STR      r5,[r4,#0x60]
;;;1797   
;;;1798     huart->ErrorCode = HAL_UART_ERROR_NONE;
0000a0  f8c45080          STR      r5,[r4,#0x80]
;;;1799   
;;;1800     return HAL_OK;
0000a4  2000              MOVS     r0,#0
;;;1801   }
0000a6  bd70              POP      {r4-r6,pc}
                  |L11.168|
0000a8  f8c46080          STR      r6,[r4,#0x80]         ;1742
0000ac  2003              MOVS     r0,#3                 ;1744
0000ae  bd70              POP      {r4-r6,pc}
                  |L11.176|
0000b0  f8c46080          STR      r6,[r4,#0x80]         ;1767
0000b4  2003              MOVS     r0,#3                 ;1769
0000b6  bd70              POP      {r4-r6,pc}
;;;1802   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2735     */
;;;2736   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2737   {
;;;2738     /* Prevent unused argument(s) compilation warning */
;;;2739     UNUSED(huart);
;;;2740   
;;;2741     /* NOTE : This function should not be modified, when the callback is needed,
;;;2742               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2743      */
;;;2744   }
;;;2745   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1879     */
;;;1880   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1881   {
000002  4604              MOV      r4,r0
;;;1882   #if defined(USART_CR1_FIFOEN)
;;;1883     /* Disable PEIE, EIE, RXNEIE and RXFTIE interrupts */
;;;1884     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
;;;1885     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE);
;;;1886   #else
;;;1887     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1888     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f4217190          BIC      r1,r1,#0x120
00000c  6001              STR      r1,[r0,#0]
;;;1889     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210101          BIC      r1,r1,#1
000016  6081              STR      r1,[r0,#8]
;;;1890   #endif /* USART_CR1_FIFOEN */
;;;1891   
;;;1892     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;1893     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000018  6e20              LDR      r0,[r4,#0x60]
00001a  2801              CMP      r0,#1
00001c  d104              BNE      |L13.40|
;;;1894     {
;;;1895       CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
00001e  6820              LDR      r0,[r4,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0210110          BIC      r1,r1,#0x10
000026  6001              STR      r1,[r0,#0]
                  |L13.40|
;;;1896     }
;;;1897   
;;;1898     /* Disable the UART DMA Rx request if enabled */
;;;1899     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000028  6820              LDR      r0,[r4,#0]
00002a  6881              LDR      r1,[r0,#8]
00002c  f04f0500          MOV      r5,#0
000030  0649              LSLS     r1,r1,#25
000032  d50f              BPL      |L13.84|
;;;1900     {
;;;1901       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000034  6881              LDR      r1,[r0,#8]
000036  f0210140          BIC      r1,r1,#0x40
00003a  6081              STR      r1,[r0,#8]
;;;1902   
;;;1903       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1904       if (huart->hdmarx != NULL)
00003c  6f20              LDR      r0,[r4,#0x70]
00003e  b148              CBZ      r0,|L13.84|
;;;1905       {
;;;1906         /* Set the UART DMA Abort callback to Null.
;;;1907            No call back execution at end of DMA abort procedure */
;;;1908         huart->hdmarx->XferAbortCallback = NULL;
000040  6385              STR      r5,[r0,#0x38]
;;;1909   
;;;1910         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
000042  6f20              LDR      r0,[r4,#0x70]
000044  f7fffffe          BL       HAL_DMA_Abort
000048  b120              CBZ      r0,|L13.84|
;;;1911         {
;;;1912           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
00004a  6f20              LDR      r0,[r4,#0x70]
00004c  f7fffffe          BL       HAL_DMA_GetError
000050  2820              CMP      r0,#0x20
000052  d00e              BEQ      |L13.114|
                  |L13.84|
;;;1913           {
;;;1914             /* Set error code to DMA */
;;;1915             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1916   
;;;1917             return HAL_TIMEOUT;
;;;1918           }
;;;1919         }
;;;1920       }
;;;1921     }
;;;1922   
;;;1923     /* Reset Rx transfer counter */
;;;1924     huart->RxXferCount = 0U;
000054  f8a4505a          STRH     r5,[r4,#0x5a]
;;;1925   
;;;1926     /* Clear the Error flags in the ICR register */
;;;1927     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000058  6821              LDR      r1,[r4,#0]
00005a  200f              MOVS     r0,#0xf
00005c  6208              STR      r0,[r1,#0x20]
;;;1928   
;;;1929     /* Discard the received data */
;;;1930     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
00005e  6820              LDR      r0,[r4,#0]
000060  8b01              LDRH     r1,[r0,#0x18]
000062  f0410108          ORR      r1,r1,#8
000066  8301              STRH     r1,[r0,#0x18]
;;;1931   
;;;1932     /* Restore huart->RxState to Ready */
;;;1933     huart->RxState = HAL_UART_STATE_READY;
000068  2020              MOVS     r0,#0x20
00006a  67e0              STR      r0,[r4,#0x7c]
;;;1934     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00006c  6625              STR      r5,[r4,#0x60]
;;;1935   
;;;1936     return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;1937   }
000070  bd70              POP      {r4-r6,pc}
                  |L13.114|
000072  2010              MOVS     r0,#0x10              ;1915
000074  f8c40080          STR      r0,[r4,#0x80]         ;1915
000078  2003              MOVS     r0,#3                 ;1917
00007a  bd70              POP      {r4-r6,pc}
;;;1938   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2765     */
;;;2766   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2767   {
;;;2768     /* Prevent unused argument(s) compilation warning */
;;;2769     UNUSED(huart);
;;;2770   
;;;2771     /* NOTE : This function should not be modified, when the callback is needed,
;;;2772               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2773      */
;;;2774   }
;;;2775   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;2207     */
;;;2208   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2209   {
000002  4604              MOV      r4,r0
;;;2210     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2211   #if defined(USART_CR1_FIFOEN)
;;;2212     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
;;;2213     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
;;;2214   #else
;;;2215     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f4217190          BIC      r1,r1,#0x120
00000c  6001              STR      r1,[r0,#0]
;;;2216     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f0210101          BIC      r1,r1,#1
000016  6081              STR      r1,[r0,#8]
;;;2217   #endif /* USART_CR1_FIFOEN */
;;;2218   
;;;2219     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2220     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000018  6e20              LDR      r0,[r4,#0x60]
00001a  2801              CMP      r0,#1
00001c  d104              BNE      |L15.40|
;;;2221     {
;;;2222       CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
00001e  6820              LDR      r0,[r4,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0210110          BIC      r1,r1,#0x10
000026  6001              STR      r1,[r0,#0]
                  |L15.40|
;;;2223     }
;;;2224   
;;;2225     /* Disable the UART DMA Rx request if enabled */
;;;2226     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000028  6820              LDR      r0,[r4,#0]
00002a  6881              LDR      r1,[r0,#8]
;;;2227     {
;;;2228       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2229   
;;;2230       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;2231       if (huart->hdmarx != NULL)
;;;2232       {
;;;2233         /* Set the UART DMA Abort callback :
;;;2234            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2235         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;2236   
;;;2237         /* Abort DMA RX */
;;;2238         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;2239         {
;;;2240           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;2241           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;2242         }
;;;2243       }
;;;2244       else
;;;2245       {
;;;2246         /* Reset Rx transfer counter */
;;;2247         huart->RxXferCount = 0U;
;;;2248   
;;;2249         /* Clear RxISR function pointer */
;;;2250         huart->pRxBuffPtr = NULL;
;;;2251   
;;;2252         /* Clear the Error flags in the ICR register */
;;;2253         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00002c  f04f030f          MOV      r3,#0xf
000030  064d              LSLS     r5,r1,#25             ;2226
000032  f04f0100          MOV      r1,#0                 ;2226
;;;2254   
;;;2255         /* Discard the received data */
;;;2256         __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
;;;2257   
;;;2258         /* Restore huart->RxState to Ready */
;;;2259         huart->RxState = HAL_UART_STATE_READY;
000036  f04f0220          MOV      r2,#0x20
00003a  d51f              BPL      |L15.124|
00003c  6885              LDR      r5,[r0,#8]            ;2228
00003e  f0250540          BIC      r5,r5,#0x40           ;2228
000042  6085              STR      r5,[r0,#8]            ;2228
000044  6f20              LDR      r0,[r4,#0x70]         ;2231
000046  b148              CBZ      r0,|L15.92|
000048  4912              LDR      r1,|L15.148|
00004a  6381              STR      r1,[r0,#0x38]         ;2235
00004c  6f20              LDR      r0,[r4,#0x70]         ;2238
00004e  f7fffffe          BL       HAL_DMA_Abort_IT
000052  b1e0              CBZ      r0,|L15.142|
000054  6f20              LDR      r0,[r4,#0x70]         ;2241
000056  6b81              LDR      r1,[r0,#0x38]         ;2241
000058  4788              BLX      r1                    ;2241
00005a  e018              B        |L15.142|
                  |L15.92|
00005c  f8a4105a          STRH     r1,[r4,#0x5a]         ;2247
000060  6561              STR      r1,[r4,#0x54]         ;2250
000062  6820              LDR      r0,[r4,#0]            ;2253
000064  6203              STR      r3,[r0,#0x20]         ;2253
000066  6820              LDR      r0,[r4,#0]            ;2256
000068  8b03              LDRH     r3,[r0,#0x18]         ;2256
00006a  f0430308          ORR      r3,r3,#8              ;2256
00006e  8303              STRH     r3,[r0,#0x18]         ;2256
000070  67e2              STR      r2,[r4,#0x7c]
;;;2260         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000072  6621              STR      r1,[r4,#0x60]
;;;2261   
;;;2262         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2263   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2264         /* Call registered Abort Receive Complete Callback */
;;;2265         huart->AbortReceiveCpltCallback(huart);
;;;2266   #else
;;;2267         /* Call legacy weak Abort Receive Complete Callback */
;;;2268         HAL_UART_AbortReceiveCpltCallback(huart);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
00007a  e008              B        |L15.142|
                  |L15.124|
;;;2269   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2270       }
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Reset Rx transfer counter */
;;;2275       huart->RxXferCount = 0U;
00007c  f8a4105a          STRH     r1,[r4,#0x5a]
;;;2276   
;;;2277       /* Clear RxISR function pointer */
;;;2278       huart->pRxBuffPtr = NULL;
000080  6561              STR      r1,[r4,#0x54]
;;;2279   
;;;2280       /* Clear the Error flags in the ICR register */
;;;2281       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000082  6203              STR      r3,[r0,#0x20]
;;;2282   
;;;2283       /* Restore huart->RxState to Ready */
;;;2284       huart->RxState = HAL_UART_STATE_READY;
000084  67e2              STR      r2,[r4,#0x7c]
;;;2285       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000086  6621              STR      r1,[r4,#0x60]
;;;2286   
;;;2287       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2288   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2289       /* Call registered Abort Receive Complete Callback */
;;;2290       huart->AbortReceiveCpltCallback(huart);
;;;2291   #else
;;;2292       /* Call legacy weak Abort Receive Complete Callback */
;;;2293       HAL_UART_AbortReceiveCpltCallback(huart);
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L15.142|
;;;2294   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2295     }
;;;2296   
;;;2297     return HAL_OK;
00008e  2000              MOVS     r0,#0
;;;2298   }
000090  bd70              POP      {r4-r6,pc}
;;;2299   
                          ENDP

000092  0000              DCW      0x0000
                  |L15.148|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1814     */
;;;1815   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1816   {
000002  4604              MOV      r4,r0
;;;1817   #if defined(USART_CR1_FIFOEN)
;;;1818     /* Disable TCIE, TXEIE and TXFTIE interrupts */
;;;1819     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
;;;1820     CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
;;;1821   #else
;;;1822     /* Disable TXEIE and TCIE interrupts */
;;;1823     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  6001              STR      r1,[r0,#0]
;;;1824   #endif /* USART_CR1_FIFOEN */
;;;1825   
;;;1826     /* Disable the UART DMA Tx request if enabled */
;;;1827     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
000012  f04f0500          MOV      r5,#0
000016  0609              LSLS     r1,r1,#24
000018  d50f              BPL      |L16.58|
;;;1828     {
;;;1829       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6881              LDR      r1,[r0,#8]
00001c  f0210180          BIC      r1,r1,#0x80
000020  6081              STR      r1,[r0,#8]
;;;1830   
;;;1831       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1832       if (huart->hdmatx != NULL)
000022  6ee0              LDR      r0,[r4,#0x6c]
000024  b148              CBZ      r0,|L16.58|
;;;1833       {
;;;1834         /* Set the UART DMA Abort callback to Null.
;;;1835            No call back execution at end of DMA abort procedure */
;;;1836         huart->hdmatx->XferAbortCallback = NULL;
000026  6385              STR      r5,[r0,#0x38]
;;;1837   
;;;1838         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000028  6ee0              LDR      r0,[r4,#0x6c]
00002a  f7fffffe          BL       HAL_DMA_Abort
00002e  b120              CBZ      r0,|L16.58|
;;;1839         {
;;;1840           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
000030  6ee0              LDR      r0,[r4,#0x6c]
000032  f7fffffe          BL       HAL_DMA_GetError
000036  2820              CMP      r0,#0x20
000038  d005              BEQ      |L16.70|
                  |L16.58|
;;;1841           {
;;;1842             /* Set error code to DMA */
;;;1843             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1844   
;;;1845             return HAL_TIMEOUT;
;;;1846           }
;;;1847         }
;;;1848       }
;;;1849     }
;;;1850   
;;;1851     /* Reset Tx transfer counter */
;;;1852     huart->TxXferCount = 0U;
00003a  f8a45052          STRH     r5,[r4,#0x52]
;;;1853   
;;;1854   #if defined(USART_CR1_FIFOEN)
;;;1855     /* Flush the whole TX FIFO (if needed) */
;;;1856     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;1857     {
;;;1858       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;1859     }
;;;1860   #endif /* USART_CR1_FIFOEN */
;;;1861   
;;;1862     /* Restore huart->gState to Ready */
;;;1863     huart->gState = HAL_UART_STATE_READY;
00003e  2020              MOVS     r0,#0x20
000040  67a0              STR      r0,[r4,#0x78]
;;;1864   
;;;1865     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;1866   }
000044  bd70              POP      {r4-r6,pc}
                  |L16.70|
000046  2010              MOVS     r0,#0x10              ;1843
000048  f8c40080          STR      r0,[r4,#0x80]         ;1843
00004c  2003              MOVS     r0,#3                 ;1845
00004e  bd70              POP      {r4-r6,pc}
;;;1867   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2750     */
;;;2751   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2752   {
;;;2753     /* Prevent unused argument(s) compilation warning */
;;;2754     UNUSED(huart);
;;;2755   
;;;2756     /* NOTE : This function should not be modified, when the callback is needed,
;;;2757               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2758      */
;;;2759   }
;;;2760   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;2111     */
;;;2112   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2113   {
000002  4604              MOV      r4,r0
;;;2114     /* Disable interrupts */
;;;2115   #if defined(USART_CR1_FIFOEN)
;;;2116     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
;;;2117     CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
;;;2118   #else
;;;2119     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  6001              STR      r1,[r0,#0]
;;;2120   #endif /* USART_CR1_FIFOEN */
;;;2121   
;;;2122     /* Disable the UART DMA Tx request if enabled */
;;;2123     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6881              LDR      r1,[r0,#8]
;;;2124     {
;;;2125       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;2126   
;;;2127       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;2128       if (huart->hdmatx != NULL)
;;;2129       {
;;;2130         /* Set the UART DMA Abort callback :
;;;2131            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2132         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;2133   
;;;2134         /* Abort DMA TX */
;;;2135         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;2136         {
;;;2137           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;2138           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;2139         }
;;;2140       }
;;;2141       else
;;;2142       {
;;;2143         /* Reset Tx transfer counter */
;;;2144         huart->TxXferCount = 0U;
;;;2145   
;;;2146         /* Clear TxISR function pointers */
;;;2147         huart->TxISR = NULL;
;;;2148   
;;;2149         /* Restore huart->gState to Ready */
;;;2150         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  060b              LSLS     r3,r1,#24             ;2123
000018  f04f0100          MOV      r1,#0                 ;2123
00001c  d517              BPL      |L18.78|
00001e  6883              LDR      r3,[r0,#8]            ;2125
000020  f0230380          BIC      r3,r3,#0x80           ;2125
000024  6083              STR      r3,[r0,#8]            ;2125
000026  6ee0              LDR      r0,[r4,#0x6c]         ;2128
000028  b148              CBZ      r0,|L18.62|
00002a  490d              LDR      r1,|L18.96|
00002c  6381              STR      r1,[r0,#0x38]         ;2132
00002e  6ee0              LDR      r0,[r4,#0x6c]         ;2135
000030  f7fffffe          BL       HAL_DMA_Abort_IT
000034  b190              CBZ      r0,|L18.92|
000036  6ee0              LDR      r0,[r4,#0x6c]         ;2138
000038  6b81              LDR      r1,[r0,#0x38]         ;2138
00003a  4788              BLX      r1                    ;2138
00003c  e00e              B        |L18.92|
                  |L18.62|
00003e  f8a41052          STRH     r1,[r4,#0x52]         ;2144
000042  66a1              STR      r1,[r4,#0x68]         ;2147
000044  67a2              STR      r2,[r4,#0x78]
;;;2151   
;;;2152         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2153   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2154         /* Call registered Abort Transmit Complete Callback */
;;;2155         huart->AbortTransmitCpltCallback(huart);
;;;2156   #else
;;;2157         /* Call legacy weak Abort Transmit Complete Callback */
;;;2158         HAL_UART_AbortTransmitCpltCallback(huart);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
00004c  e006              B        |L18.92|
                  |L18.78|
;;;2159   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2160       }
;;;2161     }
;;;2162     else
;;;2163     {
;;;2164       /* Reset Tx transfer counter */
;;;2165       huart->TxXferCount = 0U;
00004e  f8a41052          STRH     r1,[r4,#0x52]
;;;2166   
;;;2167       /* Clear TxISR function pointers */
;;;2168       huart->TxISR = NULL;
000052  66a1              STR      r1,[r4,#0x68]
;;;2169   
;;;2170   #if defined(USART_CR1_FIFOEN)
;;;2171       /* Flush the whole TX FIFO (if needed) */
;;;2172       if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;2173       {
;;;2174         __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;2175       }
;;;2176   #endif /* USART_CR1_FIFOEN */
;;;2177   
;;;2178       /* Restore huart->gState to Ready */
;;;2179       huart->gState = HAL_UART_STATE_READY;
000054  67a2              STR      r2,[r4,#0x78]
;;;2180   
;;;2181       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2182   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2183       /* Call registered Abort Transmit Complete Callback */
;;;2184       huart->AbortTransmitCpltCallback(huart);
;;;2185   #else
;;;2186       /* Call legacy weak Abort Transmit Complete Callback */
;;;2187       HAL_UART_AbortTransmitCpltCallback(huart);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L18.92|
;;;2188   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2189     }
;;;2190   
;;;2191     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;2192   }
00005e  bd10              POP      {r4,pc}
;;;2193   
                          ENDP

                  |L18.96|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1952     */
;;;1953   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1954   {
000002  4604              MOV      r4,r0
;;;1955     uint32_t abortcplt = 1U;
000004  2501              MOVS     r5,#1
;;;1956   
;;;1957     /* Disable interrupts */
;;;1958   #if defined(USART_CR1_FIFOEN)
;;;1959     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_TCIE | USART_CR1_RXNEIE_RXFNEIE |
;;;1960                                      USART_CR1_TXEIE_TXFNFIE));
;;;1961     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
;;;1962   #else
;;;1963     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  6801              LDR      r1,[r0,#0]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  6001              STR      r1,[r0,#0]
;;;1964     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6881              LDR      r1,[r0,#8]
000014  f0210101          BIC      r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1965   #endif /* USART_CR1_FIFOEN */
;;;1966   
;;;1967     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;1968     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
00001a  6e20              LDR      r0,[r4,#0x60]
00001c  2801              CMP      r0,#1
00001e  d104              BNE      |L19.42|
;;;1969     {
;;;1970       CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  f0210110          BIC      r1,r1,#0x10
000028  6001              STR      r1,[r0,#0]
                  |L19.42|
;;;1971     }
;;;1972   
;;;1973     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1974        before any call to DMA Abort functions */
;;;1975     /* DMA Tx Handle is valid */
;;;1976     if (huart->hdmatx != NULL)
00002a  6ee0              LDR      r0,[r4,#0x6c]
00002c  2600              MOVS     r6,#0
00002e  b138              CBZ      r0,|L19.64|
;;;1977     {
;;;1978       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1979          Otherwise, set it to NULL */
;;;1980       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000030  6821              LDR      r1,[r4,#0]
000032  6889              LDR      r1,[r1,#8]
000034  0609              LSLS     r1,r1,#24
000036  d502              BPL      |L19.62|
;;;1981       {
;;;1982         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
000038  4925              LDR      r1,|L19.208|
00003a  6381              STR      r1,[r0,#0x38]
00003c  e000              B        |L19.64|
                  |L19.62|
;;;1983       }
;;;1984       else
;;;1985       {
;;;1986         huart->hdmatx->XferAbortCallback = NULL;
00003e  6386              STR      r6,[r0,#0x38]
                  |L19.64|
;;;1987       }
;;;1988     }
;;;1989     /* DMA Rx Handle is valid */
;;;1990     if (huart->hdmarx != NULL)
000040  6f20              LDR      r0,[r4,#0x70]
000042  b138              CBZ      r0,|L19.84|
;;;1991     {
;;;1992       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1993          Otherwise, set it to NULL */
;;;1994       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000044  6821              LDR      r1,[r4,#0]
000046  6889              LDR      r1,[r1,#8]
000048  0649              LSLS     r1,r1,#25
00004a  d502              BPL      |L19.82|
;;;1995       {
;;;1996         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00004c  4921              LDR      r1,|L19.212|
00004e  6381              STR      r1,[r0,#0x38]
000050  e000              B        |L19.84|
                  |L19.82|
;;;1997       }
;;;1998       else
;;;1999       {
;;;2000         huart->hdmarx->XferAbortCallback = NULL;
000052  6386              STR      r6,[r0,#0x38]
                  |L19.84|
;;;2001       }
;;;2002     }
;;;2003   
;;;2004     /* Disable the UART DMA Tx request if enabled */
;;;2005     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000054  6820              LDR      r0,[r4,#0]
000056  6881              LDR      r1,[r0,#8]
000058  0609              LSLS     r1,r1,#24
00005a  d50c              BPL      |L19.118|
;;;2006     {
;;;2007       /* Disable DMA Tx at UART level */
;;;2008       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00005c  6881              LDR      r1,[r0,#8]
00005e  f0210180          BIC      r1,r1,#0x80
000062  6081              STR      r1,[r0,#8]
;;;2009   
;;;2010       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;2011       if (huart->hdmatx != NULL)
000064  6ee0              LDR      r0,[r4,#0x6c]
000066  b130              CBZ      r0,|L19.118|
;;;2012       {
;;;2013         /* UART Tx DMA Abort callback has already been initialised :
;;;2014            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2015   
;;;2016         /* Abort DMA TX */
;;;2017         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000068  f7fffffe          BL       HAL_DMA_Abort_IT
00006c  b110              CBZ      r0,|L19.116|
;;;2018         {
;;;2019           huart->hdmatx->XferAbortCallback = NULL;
00006e  6ee0              LDR      r0,[r4,#0x6c]
000070  6386              STR      r6,[r0,#0x38]
000072  e000              B        |L19.118|
                  |L19.116|
;;;2020         }
;;;2021         else
;;;2022         {
;;;2023           abortcplt = 0U;
000074  2500              MOVS     r5,#0
                  |L19.118|
;;;2024         }
;;;2025       }
;;;2026     }
;;;2027   
;;;2028     /* Disable the UART DMA Rx request if enabled */
;;;2029     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000076  6820              LDR      r0,[r4,#0]
000078  6881              LDR      r1,[r0,#8]
00007a  0649              LSLS     r1,r1,#25
00007c  d50d              BPL      |L19.154|
;;;2030     {
;;;2031       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00007e  6881              LDR      r1,[r0,#8]
000080  f0210140          BIC      r1,r1,#0x40
000084  6081              STR      r1,[r0,#8]
;;;2032   
;;;2033       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;2034       if (huart->hdmarx != NULL)
000086  6f20              LDR      r0,[r4,#0x70]
000088  b138              CBZ      r0,|L19.154|
;;;2035       {
;;;2036         /* UART Rx DMA Abort callback has already been initialised :
;;;2037            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2038   
;;;2039         /* Abort DMA RX */
;;;2040         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00008a  f7fffffe          BL       HAL_DMA_Abort_IT
00008e  b118              CBZ      r0,|L19.152|
;;;2041         {
;;;2042           huart->hdmarx->XferAbortCallback = NULL;
000090  6f20              LDR      r0,[r4,#0x70]
000092  6386              STR      r6,[r0,#0x38]
;;;2043           abortcplt = 1U;
000094  2501              MOVS     r5,#1
000096  e000              B        |L19.154|
                  |L19.152|
;;;2044         }
;;;2045         else
;;;2046         {
;;;2047           abortcplt = 0U;
000098  2500              MOVS     r5,#0
                  |L19.154|
;;;2048         }
;;;2049       }
;;;2050     }
;;;2051   
;;;2052     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;2053     if (abortcplt == 1U)
00009a  2d01              CMP      r5,#1
00009c  d116              BNE      |L19.204|
;;;2054     {
;;;2055       /* Reset Tx and Rx transfer counters */
;;;2056       huart->TxXferCount = 0U;
00009e  f8a46052          STRH     r6,[r4,#0x52]
;;;2057       huart->RxXferCount = 0U;
0000a2  f8a4605a          STRH     r6,[r4,#0x5a]
;;;2058   
;;;2059       /* Clear ISR function pointers */
;;;2060       huart->RxISR = NULL;
0000a6  6666              STR      r6,[r4,#0x64]
;;;2061       huart->TxISR = NULL;
0000a8  66a6              STR      r6,[r4,#0x68]
;;;2062   
;;;2063       /* Reset errorCode */
;;;2064       huart->ErrorCode = HAL_UART_ERROR_NONE;
0000aa  f8c46080          STR      r6,[r4,#0x80]
;;;2065   
;;;2066       /* Clear the Error flags in the ICR register */
;;;2067       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
0000ae  6821              LDR      r1,[r4,#0]
0000b0  200f              MOVS     r0,#0xf
0000b2  6208              STR      r0,[r1,#0x20]
;;;2068   
;;;2069   #if defined(USART_CR1_FIFOEN)
;;;2070       /* Flush the whole TX FIFO (if needed) */
;;;2071       if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;2072       {
;;;2073         __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;2074       }
;;;2075   #endif /* USART_CR1_FIFOEN */
;;;2076   
;;;2077       /* Discard the received data */
;;;2078       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
0000b4  6820              LDR      r0,[r4,#0]
0000b6  8b01              LDRH     r1,[r0,#0x18]
0000b8  f0410108          ORR      r1,r1,#8
0000bc  8301              STRH     r1,[r0,#0x18]
;;;2079   
;;;2080       /* Restore huart->gState and huart->RxState to Ready */
;;;2081       huart->gState  = HAL_UART_STATE_READY;
0000be  2020              MOVS     r0,#0x20
0000c0  67a0              STR      r0,[r4,#0x78]
;;;2082       huart->RxState = HAL_UART_STATE_READY;
0000c2  67e0              STR      r0,[r4,#0x7c]
;;;2083       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
0000c4  6626              STR      r6,[r4,#0x60]
;;;2084   
;;;2085       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2086   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2087       /* Call registered Abort complete callback */
;;;2088       huart->AbortCpltCallback(huart);
;;;2089   #else
;;;2090       /* Call legacy weak Abort complete callback */
;;;2091       HAL_UART_AbortCpltCallback(huart);
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L19.204|
;;;2092   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2093     }
;;;2094   
;;;2095     return HAL_OK;
0000cc  2000              MOVS     r0,#0
;;;2096   }
0000ce  bd70              POP      {r4-r6,pc}
;;;2097   
                          ENDP

                  |L19.208|
                          DCD      UART_DMATxAbortCallback
                  |L19.212|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1564     */
;;;1565   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1566   {
;;;1567     const HAL_UART_StateTypeDef gstate = huart->gState;
000002  6f83              LDR      r3,[r0,#0x78]
;;;1568     const HAL_UART_StateTypeDef rxstate = huart->RxState;
000004  6fc2              LDR      r2,[r0,#0x7c]
;;;1569   
;;;1570     __HAL_LOCK(huart);
000006  f8901074          LDRB     r1,[r0,#0x74]
00000a  2901              CMP      r1,#1
00000c  d009              BEQ      |L20.34|
00000e  2101              MOVS     r1,#1
000010  f8801074          STRB     r1,[r0,#0x74]
;;;1571   
;;;1572     if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
000014  6801              LDR      r1,[r0,#0]
000016  688c              LDR      r4,[r1,#8]
000018  0624              LSLS     r4,r4,#24
00001a  d508              BPL      |L20.46|
;;;1573         (gstate == HAL_UART_STATE_BUSY_TX))
00001c  2b21              CMP      r3,#0x21
00001e  d002              BEQ      |L20.38|
000020  e005              B        |L20.46|
                  |L20.34|
000022  2002              MOVS     r0,#2                 ;1570
;;;1574     {
;;;1575       /* Disable the UART DMA Tx request */
;;;1576       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1577     }
;;;1578     if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
;;;1579         (rxstate == HAL_UART_STATE_BUSY_RX))
;;;1580     {
;;;1581       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1582       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1583       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1584   
;;;1585       /* Disable the UART DMA Rx request */
;;;1586       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1587     }
;;;1588   
;;;1589     __HAL_UNLOCK(huart);
;;;1590   
;;;1591     return HAL_OK;
;;;1592   }
000024  bd10              POP      {r4,pc}
                  |L20.38|
000026  688b              LDR      r3,[r1,#8]            ;1576
000028  f0230380          BIC      r3,r3,#0x80           ;1576
00002c  608b              STR      r3,[r1,#8]            ;1576
                  |L20.46|
00002e  6801              LDR      r1,[r0,#0]            ;1578
000030  688b              LDR      r3,[r1,#8]            ;1578
000032  065b              LSLS     r3,r3,#25             ;1578
000034  d50f              BPL      |L20.86|
000036  2a22              CMP      r2,#0x22              ;1579
000038  d10d              BNE      |L20.86|
00003a  680a              LDR      r2,[r1,#0]            ;1582
00003c  f4227280          BIC      r2,r2,#0x100          ;1582
000040  600a              STR      r2,[r1,#0]            ;1582
000042  6801              LDR      r1,[r0,#0]            ;1583
000044  688a              LDR      r2,[r1,#8]            ;1583
000046  f0220201          BIC      r2,r2,#1              ;1583
00004a  608a              STR      r2,[r1,#8]            ;1583
00004c  6801              LDR      r1,[r0,#0]            ;1586
00004e  688a              LDR      r2,[r1,#8]            ;1586
000050  f0220240          BIC      r2,r2,#0x40           ;1586
000054  608a              STR      r2,[r1,#8]            ;1586
                  |L20.86|
000056  2100              MOVS     r1,#0                 ;1589
000058  f8801074          STRB     r1,[r0,#0x74]         ;1589
00005c  2000              MOVS     r0,#0                 ;1591
00005e  bd10              POP      {r4,pc}
;;;1593   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1598     */
;;;1599   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;1600   {
;;;1601     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d006              BEQ      |L21.22|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;1602   
;;;1603     if (huart->gState == HAL_UART_STATE_BUSY_TX)
00000e  6f81              LDR      r1,[r0,#0x78]
000010  2921              CMP      r1,#0x21
000012  d002              BEQ      |L21.26|
000014  e006              B        |L21.36|
                  |L21.22|
000016  2002              MOVS     r0,#2                 ;1601
;;;1604     {
;;;1605       /* Enable the UART DMA Tx request */
;;;1606       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1607     }
;;;1608     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1609     {
;;;1610       /* Clear the Overrun flag before resuming the Rx transfer */
;;;1611       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
;;;1612   
;;;1613       /* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1614       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1615       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1616   
;;;1617       /* Enable the UART DMA Rx request */
;;;1618       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1619     }
;;;1620   
;;;1621     __HAL_UNLOCK(huart);
;;;1622   
;;;1623     return HAL_OK;
;;;1624   }
000018  4770              BX       lr
                  |L21.26|
00001a  6801              LDR      r1,[r0,#0]            ;1606
00001c  688a              LDR      r2,[r1,#8]            ;1606
00001e  f0420280          ORR      r2,r2,#0x80           ;1606
000022  608a              STR      r2,[r1,#8]            ;1606
                  |L21.36|
000024  6fc1              LDR      r1,[r0,#0x7c]         ;1608
000026  2922              CMP      r1,#0x22              ;1608
000028  d111              BNE      |L21.78|
00002a  6802              LDR      r2,[r0,#0]            ;1611
00002c  2108              MOVS     r1,#8                 ;1611
00002e  6211              STR      r1,[r2,#0x20]         ;1611
000030  6801              LDR      r1,[r0,#0]            ;1614
000032  680a              LDR      r2,[r1,#0]            ;1614
000034  f4427280          ORR      r2,r2,#0x100          ;1614
000038  600a              STR      r2,[r1,#0]            ;1614
00003a  6801              LDR      r1,[r0,#0]            ;1615
00003c  688a              LDR      r2,[r1,#8]            ;1615
00003e  f0420201          ORR      r2,r2,#1              ;1615
000042  608a              STR      r2,[r1,#8]            ;1615
000044  6801              LDR      r1,[r0,#0]            ;1618
000046  688a              LDR      r2,[r1,#8]            ;1618
000048  f0420240          ORR      r2,r2,#0x40           ;1618
00004c  608a              STR      r2,[r1,#8]            ;1618
                  |L21.78|
00004e  2100              MOVS     r1,#0                 ;1621
000050  f8801074          STRB     r1,[r0,#0x74]         ;1621
000054  2000              MOVS     r0,#0                 ;1623
000056  4770              BX       lr
;;;1625   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1630     */
;;;1631   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1632   {
000002  4604              MOV      r4,r0
;;;1633     /* The Lock is not implemented on this API to allow the user application
;;;1634        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1635        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
;;;1636        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1637        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1638        the stream and the corresponding call back is executed. */
;;;1639   
;;;1640     const HAL_UART_StateTypeDef gstate = huart->gState;
000004  6fa1              LDR      r1,[r4,#0x78]
;;;1641     const HAL_UART_StateTypeDef rxstate = huart->RxState;
000006  6fe5              LDR      r5,[r4,#0x7c]
;;;1642   
;;;1643     /* Stop UART DMA Tx request if ongoing */
;;;1644     if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
000008  6820              LDR      r0,[r4,#0]
00000a  6882              LDR      r2,[r0,#8]
;;;1645         (gstate == HAL_UART_STATE_BUSY_TX))
;;;1646     {
;;;1647       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1648   
;;;1649       /* Abort the UART DMA Tx channel */
;;;1650       if (huart->hdmatx != NULL)
;;;1651       {
;;;1652         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
;;;1653         {
;;;1654           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
;;;1655           {
;;;1656             /* Set error code to DMA */
;;;1657             huart->ErrorCode = HAL_UART_ERROR_DMA;
00000c  f04f0610          MOV      r6,#0x10
000010  0612              LSLS     r2,r2,#24             ;1644
000012  d512              BPL      |L22.58|
000014  2921              CMP      r1,#0x21              ;1645
000016  d110              BNE      |L22.58|
000018  6881              LDR      r1,[r0,#8]            ;1647
00001a  f0210180          BIC      r1,r1,#0x80           ;1647
00001e  6081              STR      r1,[r0,#8]            ;1647
000020  6ee0              LDR      r0,[r4,#0x6c]         ;1650
000022  b138              CBZ      r0,|L22.52|
000024  f7fffffe          BL       HAL_DMA_Abort
000028  b120              CBZ      r0,|L22.52|
00002a  6ee0              LDR      r0,[r4,#0x6c]         ;1654
00002c  f7fffffe          BL       HAL_DMA_GetError
000030  2820              CMP      r0,#0x20              ;1654
000032  d009              BEQ      |L22.72|
                  |L22.52|
;;;1658   
;;;1659             return HAL_TIMEOUT;
;;;1660           }
;;;1661         }
;;;1662       }
;;;1663   
;;;1664       UART_EndTxTransfer(huart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       UART_EndTxTransfer
                  |L22.58|
;;;1665     }
;;;1666   
;;;1667     /* Stop UART DMA Rx request if ongoing */
;;;1668     if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
00003a  6820              LDR      r0,[r4,#0]
00003c  6881              LDR      r1,[r0,#8]
00003e  0649              LSLS     r1,r1,#25
000040  d517              BPL      |L22.114|
;;;1669         (rxstate == HAL_UART_STATE_BUSY_RX))
000042  2d22              CMP      r5,#0x22
000044  d004              BEQ      |L22.80|
000046  e014              B        |L22.114|
                  |L22.72|
000048  f8c46080          STR      r6,[r4,#0x80]         ;1657
00004c  2003              MOVS     r0,#3                 ;1659
;;;1670     {
;;;1671       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1672   
;;;1673       /* Abort the UART DMA Rx channel */
;;;1674       if (huart->hdmarx != NULL)
;;;1675       {
;;;1676         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
;;;1677         {
;;;1678           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
;;;1679           {
;;;1680             /* Set error code to DMA */
;;;1681             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1682   
;;;1683             return HAL_TIMEOUT;
;;;1684           }
;;;1685         }
;;;1686       }
;;;1687   
;;;1688       UART_EndRxTransfer(huart);
;;;1689     }
;;;1690   
;;;1691     return HAL_OK;
;;;1692   }
00004e  bd70              POP      {r4-r6,pc}
                  |L22.80|
000050  6881              LDR      r1,[r0,#8]            ;1671
000052  f0210140          BIC      r1,r1,#0x40           ;1671
000056  6081              STR      r1,[r0,#8]            ;1671
000058  6f20              LDR      r0,[r4,#0x70]         ;1674
00005a  b138              CBZ      r0,|L22.108|
00005c  f7fffffe          BL       HAL_DMA_Abort
000060  b120              CBZ      r0,|L22.108|
000062  6f20              LDR      r0,[r4,#0x70]         ;1678
000064  f7fffffe          BL       HAL_DMA_GetError
000068  2820              CMP      r0,#0x20              ;1678
00006a  d004              BEQ      |L22.118|
                  |L22.108|
00006c  4620              MOV      r0,r4                 ;1688
00006e  f7fffffe          BL       UART_EndRxTransfer
                  |L22.114|
000072  2000              MOVS     r0,#0                 ;1691
000074  bd70              POP      {r4-r6,pc}
                  |L22.118|
000076  f8c46080          STR      r6,[r4,#0x80]         ;1681
00007a  2003              MOVS     r0,#3                 ;1683
00007c  bd70              POP      {r4-r6,pc}
;;;1693   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;637      */
;;;638    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;639    {
000002  4604              MOV      r4,r0
;;;640      /* Check the UART handle allocation */
;;;641      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d018              BEQ      |L23.58|
;;;642      {
;;;643        return HAL_ERROR;
;;;644      }
;;;645    
;;;646      /* Check the parameters */
;;;647      assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
;;;648    
;;;649      huart->gState = HAL_UART_STATE_BUSY;
000008  2024              MOVS     r0,#0x24
00000a  67a0              STR      r0,[r4,#0x78]
;;;650    
;;;651      __HAL_UART_DISABLE(huart);
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0210101          BIC      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;652    
;;;653      huart->Instance->CR1 = 0x0U;
000016  6820              LDR      r0,[r4,#0]
000018  2500              MOVS     r5,#0
00001a  6005              STR      r5,[r0,#0]
;;;654      huart->Instance->CR2 = 0x0U;
00001c  6820              LDR      r0,[r4,#0]
00001e  6045              STR      r5,[r0,#4]
;;;655      huart->Instance->CR3 = 0x0U;
000020  6820              LDR      r0,[r4,#0]
000022  6085              STR      r5,[r0,#8]
;;;656    
;;;657    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;658      if (huart->MspDeInitCallback == NULL)
;;;659      {
;;;660        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;661      }
;;;662      /* DeInit the low level hardware */
;;;663      huart->MspDeInitCallback(huart);
;;;664    #else
;;;665      /* DeInit the low level hardware */
;;;666      HAL_UART_MspDeInit(huart);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_UART_MspDeInit
;;;667    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;668    
;;;669      huart->ErrorCode = HAL_UART_ERROR_NONE;
00002a  3460              ADDS     r4,r4,#0x60
00002c  6225              STR      r5,[r4,#0x20]
;;;670      huart->gState = HAL_UART_STATE_RESET;
00002e  61a5              STR      r5,[r4,#0x18]
;;;671      huart->RxState = HAL_UART_STATE_RESET;
000030  61e5              STR      r5,[r4,#0x1c]
;;;672      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000032  6025              STR      r5,[r4,#0]
;;;673    
;;;674      __HAL_UNLOCK(huart);
000034  7525              STRB     r5,[r4,#0x14]
;;;675    
;;;676      return HAL_OK;
000036  2000              MOVS     r0,#0
;;;677    }
000038  bd70              POP      {r4-r6,pc}
                  |L23.58|
00003a  2001              MOVS     r0,#1                 ;643
00003c  bd70              POP      {r4-r6,pc}
;;;678    
                          ENDP


                          AREA ||i.HAL_UART_DisableReceiverTimeout||, CODE, READONLY, ALIGN=2

                  HAL_UART_DisableReceiverTimeout PROC
;;;2883     */
;;;2884   HAL_StatusTypeDef HAL_UART_DisableReceiverTimeout(UART_HandleTypeDef *huart)
000000  4a0f              LDR      r2,|L24.64|
;;;2885   {
;;;2886     if (!(IS_LPUART_INSTANCE(huart->Instance)))
000002  6801              LDR      r1,[r0,#0]
000004  4291              CMP      r1,r2
000006  d019              BEQ      |L24.60|
;;;2887     {
;;;2888       if (huart->gState == HAL_UART_STATE_READY)
000008  6f82              LDR      r2,[r0,#0x78]
00000a  2a20              CMP      r2,#0x20
00000c  d001              BEQ      |L24.18|
;;;2889       {
;;;2890         /* Process Locked */
;;;2891         __HAL_LOCK(huart);
;;;2892   
;;;2893         huart->gState = HAL_UART_STATE_BUSY;
;;;2894   
;;;2895         /* Clear the USART RTOEN bit */
;;;2896         CLEAR_BIT(huart->Instance->CR2, USART_CR2_RTOEN);
;;;2897   
;;;2898         huart->gState = HAL_UART_STATE_READY;
;;;2899   
;;;2900         /* Process Unlocked */
;;;2901         __HAL_UNLOCK(huart);
;;;2902   
;;;2903         return HAL_OK;
;;;2904       }
;;;2905       else
;;;2906       {
;;;2907         return HAL_BUSY;
00000e  2002              MOVS     r0,#2
;;;2908       }
;;;2909     }
;;;2910     else
;;;2911     {
;;;2912       return HAL_ERROR;
;;;2913     }
;;;2914   }
000010  4770              BX       lr
                  |L24.18|
000012  f8902074          LDRB     r2,[r0,#0x74]         ;2891
000016  2a01              CMP      r2,#1                 ;2891
000018  d00e              BEQ      |L24.56|
00001a  2201              MOVS     r2,#1                 ;2891
00001c  f8002f74          STRB     r2,[r0,#0x74]!        ;2891
000020  2224              MOVS     r2,#0x24              ;2893
000022  6042              STR      r2,[r0,#4]            ;2893
000024  684a              LDR      r2,[r1,#4]            ;2896
000026  f4220200          BIC      r2,r2,#0x800000       ;2896
00002a  604a              STR      r2,[r1,#4]            ;2896
00002c  2120              MOVS     r1,#0x20              ;2898
00002e  6041              STR      r1,[r0,#4]            ;2898
000030  2100              MOVS     r1,#0                 ;2901
000032  7001              STRB     r1,[r0,#0]            ;2901
000034  2000              MOVS     r0,#0                 ;2903
000036  4770              BX       lr
                  |L24.56|
000038  2002              MOVS     r0,#2                 ;2891
00003a  4770              BX       lr
                  |L24.60|
00003c  2001              MOVS     r0,#1                 ;2912
00003e  4770              BX       lr
;;;2915   
                          ENDP

                  |L24.64|
                          DCD      0x40008000

                          AREA ||i.HAL_UART_EnableReceiverTimeout||, CODE, READONLY, ALIGN=2

                  HAL_UART_EnableReceiverTimeout PROC
;;;2845     */
;;;2846   HAL_StatusTypeDef HAL_UART_EnableReceiverTimeout(UART_HandleTypeDef *huart)
000000  4a0f              LDR      r2,|L25.64|
;;;2847   {
;;;2848     if (!(IS_LPUART_INSTANCE(huart->Instance)))
000002  6801              LDR      r1,[r0,#0]
000004  4291              CMP      r1,r2
000006  d019              BEQ      |L25.60|
;;;2849     {
;;;2850       if (huart->gState == HAL_UART_STATE_READY)
000008  6f82              LDR      r2,[r0,#0x78]
00000a  2a20              CMP      r2,#0x20
00000c  d001              BEQ      |L25.18|
;;;2851       {
;;;2852         /* Process Locked */
;;;2853         __HAL_LOCK(huart);
;;;2854   
;;;2855         huart->gState = HAL_UART_STATE_BUSY;
;;;2856   
;;;2857         /* Set the USART RTOEN bit */
;;;2858         SET_BIT(huart->Instance->CR2, USART_CR2_RTOEN);
;;;2859   
;;;2860         huart->gState = HAL_UART_STATE_READY;
;;;2861   
;;;2862         /* Process Unlocked */
;;;2863         __HAL_UNLOCK(huart);
;;;2864   
;;;2865         return HAL_OK;
;;;2866       }
;;;2867       else
;;;2868       {
;;;2869         return HAL_BUSY;
00000e  2002              MOVS     r0,#2
;;;2870       }
;;;2871     }
;;;2872     else
;;;2873     {
;;;2874       return HAL_ERROR;
;;;2875     }
;;;2876   }
000010  4770              BX       lr
                  |L25.18|
000012  f8902074          LDRB     r2,[r0,#0x74]         ;2853
000016  2a01              CMP      r2,#1                 ;2853
000018  d00e              BEQ      |L25.56|
00001a  2201              MOVS     r2,#1                 ;2853
00001c  f8002f74          STRB     r2,[r0,#0x74]!        ;2853
000020  2224              MOVS     r2,#0x24              ;2855
000022  6042              STR      r2,[r0,#4]            ;2855
000024  684a              LDR      r2,[r1,#4]            ;2858
000026  f4420200          ORR      r2,r2,#0x800000       ;2858
00002a  604a              STR      r2,[r1,#4]            ;2858
00002c  2120              MOVS     r1,#0x20              ;2860
00002e  6041              STR      r1,[r0,#4]            ;2860
000030  2100              MOVS     r1,#0                 ;2863
000032  7001              STRB     r1,[r0,#0]            ;2863
000034  2000              MOVS     r0,#0                 ;2865
000036  4770              BX       lr
                  |L25.56|
000038  2002              MOVS     r0,#2                 ;2853
00003a  4770              BX       lr
                  |L25.60|
00003c  2001              MOVS     r0,#1                 ;2874
00003e  4770              BX       lr
;;;2877   
                          ENDP

                  |L25.64|
                          DCD      0x40008000

                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2720     */
;;;2721   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2722   {
;;;2723     /* Prevent unused argument(s) compilation warning */
;;;2724     UNUSED(huart);
;;;2725   
;;;2726     /* NOTE : This function should not be modified, when the callback is needed,
;;;2727               the HAL_UART_ErrorCallback can be implemented in the user file.
;;;2728      */
;;;2729   }
;;;2730   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;3079     */
;;;3080   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  f8d00080          LDR      r0,[r0,#0x80]
;;;3081   {
;;;3082     return huart->ErrorCode;
;;;3083   }
000004  4770              BX       lr
;;;3084   /**
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;3063     */
;;;3064   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;3065   {
;;;3066     uint32_t temp1;
;;;3067     uint32_t temp2;
;;;3068     temp1 = huart->gState;
000002  6f88              LDR      r0,[r1,#0x78]
;;;3069     temp2 = huart->RxState;
000004  6fc9              LDR      r1,[r1,#0x7c]
;;;3070   
;;;3071     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000006  4308              ORRS     r0,r0,r1
;;;3072   }
000008  4770              BX       lr
;;;3073   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2304     */
;;;2305   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2306   {
000004  4604              MOV      r4,r0
;;;2307     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000006  6822              LDR      r2,[r4,#0]
000008  69d0              LDR      r0,[r2,#0x1c]
;;;2308     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6811              LDR      r1,[r2,#0]
;;;2309     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000c  6893              LDR      r3,[r2,#8]
;;;2310   
;;;2311     uint32_t errorflags;
;;;2312     uint32_t errorcode;
;;;2313   
;;;2314     /* If no error occurs */
;;;2315     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
00000e  f640050f          MOV      r5,#0x80f
000012  ea000605          AND      r6,r0,r5
;;;2316     if (errorflags == 0U)
000016  2e00              CMP      r6,#0
000018  d10a              BNE      |L29.48|
;;;2317     {
;;;2318       /* UART in mode Receiver ---------------------------------------------------*/
;;;2319   #if defined(USART_CR1_FIFOEN)
;;;2320       if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
;;;2321           && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
;;;2322               || ((cr3its & USART_CR3_RXFTIE) != 0U)))
;;;2323   #else
;;;2324       if (((isrflags & USART_ISR_RXNE) != 0U)
00001a  0685              LSLS     r5,r0,#26
00001c  d508              BPL      |L29.48|
;;;2325           && ((cr1its & USART_CR1_RXNEIE) != 0U))
00001e  068d              LSLS     r5,r1,#26
000020  d506              BPL      |L29.48|
;;;2326   #endif /* USART_CR1_FIFOEN */
;;;2327       {
;;;2328         if (huart->RxISR != NULL)
000022  6e61              LDR      r1,[r4,#0x64]
000024  2900              CMP      r1,#0
000026  d07d              BEQ      |L29.292|
;;;2329         {
;;;2330           huart->RxISR(huart);
000028  4620              MOV      r0,r4
00002a  e8bd41f0          POP      {r4-r8,lr}
00002e  4708              BX       r1
                  |L29.48|
;;;2331         }
;;;2332         return;
;;;2333       }
;;;2334     }
;;;2335   
;;;2336     /* If some errors occur */
;;;2337   #if defined(USART_CR1_FIFOEN)
;;;2338     if ((errorflags != 0U)
;;;2339         && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
;;;2340              || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
;;;2341   #else
;;;2342     if ((errorflags != 0U)
000030  2500              MOVS     r5,#0
000032  2e00              CMP      r6,#0
000034  d077              BEQ      |L29.294|
;;;2343         && (((cr3its & USART_CR3_EIE) != 0U)
000036  4f84              LDR      r7,|L29.584|
000038  f0030601          AND      r6,r3,#1
00003c  400f              ANDS     r7,r7,r1
00003e  4337              ORRS     r7,r7,r6
000040  d071              BEQ      |L29.294|
;;;2344             || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
;;;2345   #endif /* USART_CR1_FIFOEN */
;;;2346     {
;;;2347       /* UART parity error interrupt occurred -------------------------------------*/
;;;2348       if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
000042  07c7              LSLS     r7,r0,#31
000044  d009              BEQ      |L29.90|
000046  05cf              LSLS     r7,r1,#23
000048  d507              BPL      |L29.90|
;;;2349       {
;;;2350         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
00004a  2701              MOVS     r7,#1
00004c  6217              STR      r7,[r2,#0x20]
;;;2351   
;;;2352         huart->ErrorCode |= HAL_UART_ERROR_PE;
00004e  f8d42080          LDR      r2,[r4,#0x80]
000052  f0420201          ORR      r2,r2,#1
000056  f8c42080          STR      r2,[r4,#0x80]
                  |L29.90|
;;;2353       }
;;;2354   
;;;2355       /* UART frame error interrupt occurred --------------------------------------*/
;;;2356       if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
00005a  0782              LSLS     r2,r0,#30
00005c  d50a              BPL      |L29.116|
00005e  07da              LSLS     r2,r3,#31
000060  d008              BEQ      |L29.116|
;;;2357       {
;;;2358         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
000062  6827              LDR      r7,[r4,#0]
000064  2202              MOVS     r2,#2
000066  623a              STR      r2,[r7,#0x20]
;;;2359   
;;;2360         huart->ErrorCode |= HAL_UART_ERROR_FE;
000068  f8d42080          LDR      r2,[r4,#0x80]
00006c  f0420204          ORR      r2,r2,#4
000070  f8c42080          STR      r2,[r4,#0x80]
                  |L29.116|
;;;2361       }
;;;2362   
;;;2363       /* UART noise error interrupt occurred --------------------------------------*/
;;;2364       if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
000074  0742              LSLS     r2,r0,#29
000076  d50a              BPL      |L29.142|
000078  07da              LSLS     r2,r3,#31
00007a  d008              BEQ      |L29.142|
;;;2365       {
;;;2366         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
00007c  6823              LDR      r3,[r4,#0]
00007e  2204              MOVS     r2,#4
000080  621a              STR      r2,[r3,#0x20]
;;;2367   
;;;2368         huart->ErrorCode |= HAL_UART_ERROR_NE;
000082  f8d42080          LDR      r2,[r4,#0x80]
000086  f0420202          ORR      r2,r2,#2
00008a  f8c42080          STR      r2,[r4,#0x80]
                  |L29.142|
;;;2369       }
;;;2370   
;;;2371       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;2372   #if defined(USART_CR1_FIFOEN)
;;;2373       if (((isrflags & USART_ISR_ORE) != 0U)
;;;2374           && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
;;;2375               ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)))
;;;2376   #else
;;;2377       if (((isrflags & USART_ISR_ORE) != 0U)
00008e  0702              LSLS     r2,r0,#28
000090  d50c              BPL      |L29.172|
;;;2378           && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
000092  f0010220          AND      r2,r1,#0x20
000096  4332              ORRS     r2,r2,r6
000098  d008              BEQ      |L29.172|
;;;2379               ((cr3its & USART_CR3_EIE) != 0U)))
;;;2380   #endif /* USART_CR1_FIFOEN */
;;;2381       {
;;;2382         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
00009a  6823              LDR      r3,[r4,#0]
00009c  2208              MOVS     r2,#8
00009e  621a              STR      r2,[r3,#0x20]
;;;2383   
;;;2384         huart->ErrorCode |= HAL_UART_ERROR_ORE;
0000a0  f8d42080          LDR      r2,[r4,#0x80]
0000a4  f0420208          ORR      r2,r2,#8
0000a8  f8c42080          STR      r2,[r4,#0x80]
                  |L29.172|
;;;2385       }
;;;2386   
;;;2387       /* UART Receiver Timeout interrupt occurred ---------------------------------*/
;;;2388       if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
0000ac  0502              LSLS     r2,r0,#20
0000ae  d50b              BPL      |L29.200|
0000b0  014a              LSLS     r2,r1,#5
0000b2  d509              BPL      |L29.200|
;;;2389       {
;;;2390         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
0000b4  6823              LDR      r3,[r4,#0]
0000b6  f44f6200          MOV      r2,#0x800
0000ba  621a              STR      r2,[r3,#0x20]
;;;2391   
;;;2392         huart->ErrorCode |= HAL_UART_ERROR_RTO;
0000bc  f8d42080          LDR      r2,[r4,#0x80]
0000c0  f0420220          ORR      r2,r2,#0x20
0000c4  f8c42080          STR      r2,[r4,#0x80]
                  |L29.200|
;;;2393       }
;;;2394   
;;;2395       /* Call UART Error Call back function if need be ----------------------------*/
;;;2396       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
0000c8  f8d42080          LDR      r2,[r4,#0x80]
0000cc  2a00              CMP      r2,#0
0000ce  d02e              BEQ      |L29.302|
;;;2397       {
;;;2398         /* UART in mode Receiver --------------------------------------------------*/
;;;2399   #if defined(USART_CR1_FIFOEN)
;;;2400         if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
;;;2401             && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
;;;2402                 || ((cr3its & USART_CR3_RXFTIE) != 0U)))
;;;2403   #else
;;;2404         if (((isrflags & USART_ISR_RXNE) != 0U)
0000d0  0680              LSLS     r0,r0,#26
0000d2  d505              BPL      |L29.224|
;;;2405             && ((cr1its & USART_CR1_RXNEIE) != 0U))
0000d4  0688              LSLS     r0,r1,#26
0000d6  d503              BPL      |L29.224|
;;;2406   #endif /* USART_CR1_FIFOEN */
;;;2407         {
;;;2408           if (huart->RxISR != NULL)
0000d8  6e61              LDR      r1,[r4,#0x64]
0000da  b109              CBZ      r1,|L29.224|
;;;2409           {
;;;2410             huart->RxISR(huart);
0000dc  4620              MOV      r0,r4
0000de  4788              BLX      r1
                  |L29.224|
;;;2411           }
;;;2412         }
;;;2413   
;;;2414         /* If Error is to be considered as blocking :
;;;2415             - Receiver Timeout error in Reception
;;;2416             - Overrun error in Reception
;;;2417             - any error occurs in DMA mode reception
;;;2418         */
;;;2419         errorcode = huart->ErrorCode;
0000e0  f8d40080          LDR      r0,[r4,#0x80]
;;;2420         if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
0000e4  6821              LDR      r1,[r4,#0]
0000e6  6889              LDR      r1,[r1,#8]
0000e8  0649              LSLS     r1,r1,#25
0000ea  d402              BMI      |L29.242|
;;;2421             ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
0000ec  f0100f28          TST      r0,#0x28
0000f0  d023              BEQ      |L29.314|
                  |L29.242|
;;;2422         {
;;;2423           /* Blocking error : transfer is aborted
;;;2424              Set the UART state ready to be able to start again the process,
;;;2425              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2426           UART_EndRxTransfer(huart);
0000f2  4620              MOV      r0,r4
0000f4  f7fffffe          BL       UART_EndRxTransfer
;;;2427   
;;;2428           /* Disable the UART DMA Rx request if enabled */
;;;2429           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000f8  6820              LDR      r0,[r4,#0]
0000fa  6881              LDR      r1,[r0,#8]
0000fc  0649              LSLS     r1,r1,#25
0000fe  d518              BPL      |L29.306|
;;;2430           {
;;;2431             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000100  6881              LDR      r1,[r0,#8]
000102  f0210140          BIC      r1,r1,#0x40
000106  6081              STR      r1,[r0,#8]
;;;2432   
;;;2433             /* Abort the UART DMA Rx channel */
;;;2434             if (huart->hdmarx != NULL)
000108  6f20              LDR      r0,[r4,#0x70]
00010a  b168              CBZ      r0,|L29.296|
;;;2435             {
;;;2436               /* Set the UART DMA Abort callback :
;;;2437                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2438               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
00010c  494f              LDR      r1,|L29.588|
00010e  6381              STR      r1,[r0,#0x38]
;;;2439   
;;;2440               /* Abort DMA RX */
;;;2441               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000110  6f20              LDR      r0,[r4,#0x70]
000112  f7fffffe          BL       HAL_DMA_Abort_IT
000116  2800              CMP      r0,#0
000118  d009              BEQ      |L29.302|
;;;2442               {
;;;2443                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;2444                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
00011a  6f20              LDR      r0,[r4,#0x70]
00011c  6b81              LDR      r1,[r0,#0x38]
00011e  e8bd41f0          POP      {r4-r8,lr}
000122  4708              BX       r1
                  |L29.292|
000124  e003              B        |L29.302|
                  |L29.294|
000126  e00e              B        |L29.326|
                  |L29.296|
;;;2445               }
;;;2446             }
;;;2447             else
;;;2448             {
;;;2449               /* Call user error callback */
;;;2450   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2451               /*Call registered error callback*/
;;;2452               huart->ErrorCallback(huart);
;;;2453   #else
;;;2454               /*Call legacy weak error callback*/
;;;2455               HAL_UART_ErrorCallback(huart);
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L29.302|
;;;2456   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2457   
;;;2458             }
;;;2459           }
;;;2460           else
;;;2461           {
;;;2462             /* Call user error callback */
;;;2463   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2464             /*Call registered error callback*/
;;;2465             huart->ErrorCallback(huart);
;;;2466   #else
;;;2467             /*Call legacy weak error callback*/
;;;2468             HAL_UART_ErrorCallback(huart);
;;;2469   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2470           }
;;;2471         }
;;;2472         else
;;;2473         {
;;;2474           /* Non Blocking error : transfer could go on.
;;;2475              Error is notified to user through user error callback */
;;;2476   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2477           /*Call registered error callback*/
;;;2478           huart->ErrorCallback(huart);
;;;2479   #else
;;;2480           /*Call legacy weak error callback*/
;;;2481           HAL_UART_ErrorCallback(huart);
;;;2482   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2483           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2484         }
;;;2485       }
;;;2486       return;
;;;2487   
;;;2488     } /* End if some error occurs */
;;;2489   
;;;2490     /* Check current reception Mode :
;;;2491        If Reception till IDLE event has been selected : */
;;;2492     if (  (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;2493         &&((isrflags & USART_ISR_IDLE) != 0U)
;;;2494         &&((cr1its & USART_ISR_IDLE) != 0U))
;;;2495     {
;;;2496       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
;;;2497   
;;;2498       /* Check if DMA mode is enabled in UART */
;;;2499       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2500       {
;;;2501         /* DMA mode enabled */
;;;2502         /* Check received length : If all expected data are received, do nothing,
;;;2503            (DMA cplt callback will be called).
;;;2504            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2505         uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
;;;2506         if (  (nb_remaining_rx_data > 0U)
;;;2507             &&(nb_remaining_rx_data < huart->RxXferSize))
;;;2508         {
;;;2509           /* Reception is not complete */
;;;2510           huart->RxXferCount = nb_remaining_rx_data;
;;;2511   
;;;2512           /* In Normal mode, end DMA xfer and HAL UART Rx process*/
;;;2513           if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
;;;2514           {
;;;2515             /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2516             CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;2517             CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2518   
;;;2519             /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;2520                in the UART CR3 register */
;;;2521             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2522   
;;;2523             /* At end of Rx process, restore huart->RxState to Ready */
;;;2524             huart->RxState = HAL_UART_STATE_READY;
;;;2525             huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2526   
;;;2527             CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2528   
;;;2529             /* Last bytes received, so no need as the abort is immediate */
;;;2530             (void)HAL_DMA_Abort(huart->hdmarx);
;;;2531           }
;;;2532   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2533           /*Call registered Rx Event callback*/
;;;2534           huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2535   #else
;;;2536           /*Call legacy weak Rx Event callback*/
;;;2537           HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2538   #endif
;;;2539         }
;;;2540         return;
;;;2541       }
;;;2542       else
;;;2543       {
;;;2544         /* DMA mode not enabled */
;;;2545         /* Check received length : If all expected data are received, do nothing.
;;;2546            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2547         uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
;;;2548         if (  (huart->RxXferCount > 0U)
;;;2549             &&(nb_rx_data > 0U) )
;;;2550         {
;;;2551   #if defined(USART_CR1_FIFOEN)
;;;2552           /* Disable the UART Parity Error Interrupt and RXNE interrupts */
;;;2553           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;2554   
;;;2555           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
;;;2556           CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
;;;2557   #else
;;;2558           /* Disable the UART Parity Error Interrupt and RXNE interrupts */
;;;2559           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;2560   
;;;2561           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2562           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2563   #endif
;;;2564   
;;;2565           /* Rx process is completed, restore huart->RxState to Ready */
;;;2566           huart->RxState = HAL_UART_STATE_READY;
;;;2567           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2568   
;;;2569           /* Clear RxISR function pointer */
;;;2570           huart->RxISR = NULL;
;;;2571   
;;;2572           CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2573   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2574           /*Call registered Rx complete callback*/
;;;2575           huart->RxEventCallback(huart, nb_rx_data);
;;;2576   #else
;;;2577           /*Call legacy weak Rx Event callback*/
;;;2578           HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
;;;2579   #endif
;;;2580         }
;;;2581         return;
;;;2582       }
;;;2583     }
;;;2584   
;;;2585     /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
;;;2586     if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
;;;2587     {
;;;2588       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
;;;2589   
;;;2590       /* UART Rx state is not reset as a reception process might be ongoing.
;;;2591          If UART handle state fields need to be reset to READY, this could be done in Wakeup callback */
;;;2592   
;;;2593   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2594       /* Call registered Wakeup Callback */
;;;2595       huart->WakeupCallback(huart);
;;;2596   #else
;;;2597       /* Call legacy weak Wakeup Callback */
;;;2598       HAL_UARTEx_WakeupCallback(huart);
;;;2599   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2600       return;
;;;2601     }
;;;2602   
;;;2603     /* UART in mode Transmitter ------------------------------------------------*/
;;;2604   #if defined(USART_CR1_FIFOEN)
;;;2605     if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
;;;2606         && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
;;;2607             || ((cr3its & USART_CR3_TXFTIE) != 0U)))
;;;2608   #else
;;;2609     if (((isrflags & USART_ISR_TXE) != 0U)
;;;2610         && ((cr1its & USART_CR1_TXEIE) != 0U))
;;;2611   #endif /* USART_CR1_FIFOEN */
;;;2612     {
;;;2613       if (huart->TxISR != NULL)
;;;2614       {
;;;2615         huart->TxISR(huart);
;;;2616       }
;;;2617       return;
;;;2618     }
;;;2619   
;;;2620     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;2621     if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
;;;2622     {
;;;2623       UART_EndTransmit_IT(huart);
;;;2624       return;
;;;2625     }
;;;2626   
;;;2627   #if defined(USART_CR1_FIFOEN)
;;;2628     /* UART TX Fifo Empty occurred ----------------------------------------------*/
;;;2629     if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
;;;2630     {
;;;2631   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2632       /* Call registered Tx Fifo Empty Callback */
;;;2633       huart->TxFifoEmptyCallback(huart);
;;;2634   #else
;;;2635       /* Call legacy weak Tx Fifo Empty Callback */
;;;2636       HAL_UARTEx_TxFifoEmptyCallback(huart);
;;;2637   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2638       return;
;;;2639     }
;;;2640   
;;;2641     /* UART RX Fifo Full occurred ----------------------------------------------*/
;;;2642     if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
;;;2643     {
;;;2644   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2645       /* Call registered Rx Fifo Full Callback */
;;;2646       huart->RxFifoFullCallback(huart);
;;;2647   #else
;;;2648       /* Call legacy weak Rx Fifo Full Callback */
;;;2649       HAL_UARTEx_RxFifoFullCallback(huart);
;;;2650   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2651       return;
;;;2652     }
;;;2653   #endif /* USART_CR1_FIFOEN */
;;;2654   }
00012e  e8bd81f0          POP      {r4-r8,pc}
                  |L29.306|
000132  4620              MOV      r0,r4                 ;2468
000134  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L29.312|
000138  e7f9              B        |L29.302|
                  |L29.314|
00013a  4620              MOV      r0,r4                 ;2481
00013c  f7fffffe          BL       HAL_UART_ErrorCallback
000140  f8c45080          STR      r5,[r4,#0x80]         ;2483
                  |L29.324|
000144  e7f3              B        |L29.302|
                  |L29.326|
000146  6e26              LDR      r6,[r4,#0x60]         ;2492
000148  2e01              CMP      r6,#1                 ;2492
00014a  d15d              BNE      |L29.520|
00014c  06c6              LSLS     r6,r0,#27             ;2493
00014e  d55b              BPL      |L29.520|
000150  06ce              LSLS     r6,r1,#27             ;2494
000152  d559              BPL      |L29.520|
000154  2010              MOVS     r0,#0x10              ;2496
000156  6210              STR      r0,[r2,#0x20]         ;2496
000158  6820              LDR      r0,[r4,#0]            ;2499
00015a  6881              LDR      r1,[r0,#8]            ;2499
00015c  f04f0320          MOV      r3,#0x20              ;2524
000160  0649              LSLS     r1,r1,#25             ;2499
000162  d531              BPL      |L29.456|
000164  6f22              LDR      r2,[r4,#0x70]         ;2505
000166  6811              LDR      r1,[r2,#0]            ;2505
000168  6849              LDR      r1,[r1,#4]            ;2505
00016a  b289              UXTH     r1,r1                 ;2505
00016c  2900              CMP      r1,#0                 ;2506
00016e  d0de              BEQ      |L29.302|
000170  f8b46058          LDRH     r6,[r4,#0x58]         ;2507
000174  428e              CMP      r6,r1                 ;2507
000176  d9da              BLS      |L29.302|
000178  f8a4105a          STRH     r1,[r4,#0x5a]         ;2510
00017c  6811              LDR      r1,[r2,#0]            ;2513
00017e  6809              LDR      r1,[r1,#0]            ;2513
000180  0689              LSLS     r1,r1,#26             ;2513
000182  d417              BMI      |L29.436|
000184  6801              LDR      r1,[r0,#0]            ;2516
000186  f4217180          BIC      r1,r1,#0x100          ;2516
00018a  6001              STR      r1,[r0,#0]            ;2516
00018c  6820              LDR      r0,[r4,#0]            ;2517
00018e  6881              LDR      r1,[r0,#8]            ;2517
000190  f0210101          BIC      r1,r1,#1              ;2517
000194  6081              STR      r1,[r0,#8]            ;2517
000196  6820              LDR      r0,[r4,#0]            ;2521
000198  6881              LDR      r1,[r0,#8]            ;2521
00019a  f0210140          BIC      r1,r1,#0x40           ;2521
00019e  6081              STR      r1,[r0,#8]            ;2521
0001a0  67e3              STR      r3,[r4,#0x7c]         ;2524
0001a2  6625              STR      r5,[r4,#0x60]         ;2525
0001a4  6820              LDR      r0,[r4,#0]            ;2527
0001a6  6801              LDR      r1,[r0,#0]            ;2527
0001a8  f0210110          BIC      r1,r1,#0x10           ;2527
0001ac  6001              STR      r1,[r0,#0]            ;2527
0001ae  6f20              LDR      r0,[r4,#0x70]         ;2530
0001b0  f7fffffe          BL       HAL_DMA_Abort
                  |L29.436|
0001b4  f8b40058          LDRH     r0,[r4,#0x58]         ;2537
0001b8  f8b4105a          LDRH     r1,[r4,#0x5a]         ;2537
0001bc  1a40              SUBS     r0,r0,r1              ;2537
0001be  b281              UXTH     r1,r0                 ;2537
0001c0  4620              MOV      r0,r4                 ;2537
0001c2  f7fffffe          BL       HAL_UARTEx_RxEventCallback
                  |L29.454|
0001c6  e7b2              B        |L29.302|
                  |L29.456|
0001c8  f8341f58          LDRH     r1,[r4,#0x58]!        ;2547
0001cc  8862              LDRH     r2,[r4,#2]            ;2547
0001ce  1a89              SUBS     r1,r1,r2              ;2547
0001d0  b289              UXTH     r1,r1                 ;2547
0001d2  8862              LDRH     r2,[r4,#2]            ;2548
0001d4  3c58              SUBS     r4,r4,#0x58           ;2548
0001d6  2a00              CMP      r2,#0                 ;2548
0001d8  d0a9              BEQ      |L29.302|
0001da  2900              CMP      r1,#0                 ;2549
0001dc  d0a7              BEQ      |L29.302|
0001de  6802              LDR      r2,[r0,#0]            ;2559
0001e0  f4227290          BIC      r2,r2,#0x120          ;2559
0001e4  6002              STR      r2,[r0,#0]            ;2559
0001e6  6820              LDR      r0,[r4,#0]            ;2562
0001e8  6882              LDR      r2,[r0,#8]            ;2562
0001ea  f0220201          BIC      r2,r2,#1              ;2562
0001ee  6082              STR      r2,[r0,#8]            ;2562
0001f0  67e3              STR      r3,[r4,#0x7c]         ;2566
0001f2  6625              STR      r5,[r4,#0x60]         ;2567
0001f4  6665              STR      r5,[r4,#0x64]         ;2570
0001f6  6820              LDR      r0,[r4,#0]            ;2572
0001f8  6802              LDR      r2,[r0,#0]            ;2572
0001fa  f0220210          BIC      r2,r2,#0x10           ;2572
0001fe  6002              STR      r2,[r0,#0]            ;2572
000200  4620              MOV      r0,r4                 ;2578
000202  f7fffffe          BL       HAL_UARTEx_RxEventCallback
000206  e792              B        |L29.302|
                  |L29.520|
000208  02c5              LSLS     r5,r0,#11             ;2586
00020a  d509              BPL      |L29.544|
00020c  025b              LSLS     r3,r3,#9              ;2586
00020e  d507              BPL      |L29.544|
000210  f44f1080          MOV      r0,#0x100000          ;2588
000214  6210              STR      r0,[r2,#0x20]         ;2588
000216  4620              MOV      r0,r4                 ;2598
000218  e8bd41f0          POP      {r4-r8,lr}            ;2598
00021c  f7ffbffe          B.W      HAL_UARTEx_WakeupCallback
                  |L29.544|
000220  0602              LSLS     r2,r0,#24             ;2609
000222  d508              BPL      |L29.566|
000224  060a              LSLS     r2,r1,#24             ;2610
000226  d506              BPL      |L29.566|
000228  6ea1              LDR      r1,[r4,#0x68]         ;2613
00022a  2900              CMP      r1,#0                 ;2613
00022c  d084              BEQ      |L29.312|
00022e  4620              MOV      r0,r4                 ;2615
000230  e8bd41f0          POP      {r4-r8,lr}            ;2615
000234  4708              BX       r1                    ;2615
                  |L29.566|
000236  0640              LSLS     r0,r0,#25             ;2621
000238  d584              BPL      |L29.324|
00023a  0648              LSLS     r0,r1,#25             ;2621
00023c  d5c3              BPL      |L29.454|
00023e  4620              MOV      r0,r4                 ;2623
000240  e8bd41f0          POP      {r4-r8,lr}            ;2623
000244  f7ffbffe          B.W      UART_EndTransmit_IT
;;;2655   
                          ENDP

                  |L29.584|
                          DCD      0x04000120
                  |L29.588|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;320      */
;;;321    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;322    {
000002  4604              MOV      r4,r0
;;;323      /* Check the UART handle allocation */
;;;324      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d002              BEQ      |L30.14|
;;;325      {
;;;326        return HAL_ERROR;
;;;327      }
;;;328    
;;;329      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;330      {
;;;331        /* Check the parameters */
;;;332        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;333      }
;;;334      else
;;;335      {
;;;336        /* Check the parameters */
;;;337        assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
;;;338      }
;;;339    
;;;340      if (huart->gState == HAL_UART_STATE_RESET)
000008  6fa0              LDR      r0,[r4,#0x78]
00000a  b110              CBZ      r0,|L30.18|
00000c  e007              B        |L30.30|
                  |L30.14|
00000e  2001              MOVS     r0,#1                 ;326
;;;341      {
;;;342        /* Allocate lock resource and initialize it */
;;;343        huart->Lock = HAL_UNLOCKED;
;;;344    
;;;345    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;346        UART_InitCallbacksToDefault(huart);
;;;347    
;;;348        if (huart->MspInitCallback == NULL)
;;;349        {
;;;350          huart->MspInitCallback = HAL_UART_MspInit;
;;;351        }
;;;352    
;;;353        /* Init the low level hardware */
;;;354        huart->MspInitCallback(huart);
;;;355    #else
;;;356        /* Init the low level hardware : GPIO, CLOCK */
;;;357        HAL_UART_MspInit(huart);
;;;358    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;359      }
;;;360    
;;;361      huart->gState = HAL_UART_STATE_BUSY;
;;;362    
;;;363      __HAL_UART_DISABLE(huart);
;;;364    
;;;365      /* Set the UART Communication parameters */
;;;366      if (UART_SetConfig(huart) == HAL_ERROR)
;;;367      {
;;;368        return HAL_ERROR;
;;;369      }
;;;370    
;;;371      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;372      {
;;;373        UART_AdvFeatureConfig(huart);
;;;374      }
;;;375    
;;;376      /* In asynchronous mode, the following bits must be kept cleared:
;;;377      - LINEN and CLKEN bits in the USART_CR2 register,
;;;378      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;379      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;380      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;381    
;;;382      __HAL_UART_ENABLE(huart);
;;;383    
;;;384      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;385      return (UART_CheckIdleState(huart));
;;;386    }
000010  bd10              POP      {r4,pc}
                  |L30.18|
000012  2000              MOVS     r0,#0                 ;343
000014  f8840074          STRB     r0,[r4,#0x74]         ;343
000018  4620              MOV      r0,r4                 ;357
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L30.30|
00001e  2024              MOVS     r0,#0x24              ;361
000020  67a0              STR      r0,[r4,#0x78]         ;361
000022  6820              LDR      r0,[r4,#0]            ;363
000024  6801              LDR      r1,[r0,#0]            ;363
000026  f0210101          BIC      r1,r1,#1              ;363
00002a  6001              STR      r1,[r0,#0]            ;363
00002c  4620              MOV      r0,r4                 ;366
00002e  f7fffffe          BL       UART_SetConfig
000032  2801              CMP      r0,#1                 ;366
000034  d018              BEQ      |L30.104|
000036  6a60              LDR      r0,[r4,#0x24]         ;371
000038  b110              CBZ      r0,|L30.64|
00003a  4620              MOV      r0,r4                 ;373
00003c  f7fffffe          BL       UART_AdvFeatureConfig
                  |L30.64|
000040  6820              LDR      r0,[r4,#0]            ;379
000042  6841              LDR      r1,[r0,#4]            ;379
000044  f4214190          BIC      r1,r1,#0x4800         ;379
000048  6041              STR      r1,[r0,#4]            ;379
00004a  6820              LDR      r0,[r4,#0]            ;380
00004c  6881              LDR      r1,[r0,#8]            ;380
00004e  f021012a          BIC      r1,r1,#0x2a           ;380
000052  6081              STR      r1,[r0,#8]            ;380
000054  6820              LDR      r0,[r4,#0]            ;382
000056  6801              LDR      r1,[r0,#0]            ;382
000058  f0410101          ORR      r1,r1,#1              ;382
00005c  6001              STR      r1,[r0,#0]            ;382
00005e  4620              MOV      r0,r4                 ;385
000060  e8bd4010          POP      {r4,lr}               ;385
000064  f7ffbffe          B.W      UART_CheckIdleState
                  |L30.104|
000068  2001              MOVS     r0,#1                 ;368
00006a  bd10              POP      {r4,pc}
;;;387    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;698      */
;;;699    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;700    {
;;;701      /* Prevent unused argument(s) compilation warning */
;;;702      UNUSED(huart);
;;;703    
;;;704      /* NOTE : This function should not be modified, when the callback is needed,
;;;705                the HAL_UART_MspDeInit can be implemented in the user file
;;;706       */
;;;707    }
;;;708    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;683      */
;;;684    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;685    {
;;;686      /* Prevent unused argument(s) compilation warning */
;;;687      UNUSED(huart);
;;;688    
;;;689      /* NOTE : This function should not be modified, when the callback is needed,
;;;690                the HAL_UART_MspInit can be implemented in the user file
;;;691       */
;;;692    }
;;;693    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1230     */
;;;1231   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1232   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;1233     uint8_t  *pdata8bits;
;;;1234     uint16_t *pdata16bits;
;;;1235     uint16_t uhMask;
;;;1236     uint32_t tickstart;
;;;1237   
;;;1238     /* Check that a Rx process is not already ongoing */
;;;1239     if (huart->RxState == HAL_UART_STATE_READY)
00000c  6fe0              LDR      r0,[r4,#0x7c]
00000e  2820              CMP      r0,#0x20
000010  d002              BEQ      |L33.24|
;;;1240     {
;;;1241       if ((pData == NULL) || (Size == 0U))
;;;1242       {
;;;1243         return  HAL_ERROR;
;;;1244       }
;;;1245   
;;;1246       __HAL_LOCK(huart);
;;;1247   
;;;1248       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1249       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1250       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1251   
;;;1252       /* Init tickstart for timeout management */
;;;1253       tickstart = HAL_GetTick();
;;;1254   
;;;1255       huart->RxXferSize  = Size;
;;;1256       huart->RxXferCount = Size;
;;;1257   
;;;1258       /* Computation of UART mask to apply to RDR register */
;;;1259       UART_MASK_COMPUTATION(huart);
;;;1260       uhMask = huart->Mask;
;;;1261   
;;;1262       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1263       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1264       {
;;;1265         pdata8bits  = NULL;
;;;1266         pdata16bits = (uint16_t *) pData;
;;;1267       }
;;;1268       else
;;;1269       {
;;;1270         pdata8bits  = pData;
;;;1271         pdata16bits = NULL;
;;;1272       }
;;;1273   
;;;1274       __HAL_UNLOCK(huart);
;;;1275   
;;;1276       /* as long as data have to be received */
;;;1277       while (huart->RxXferCount > 0U)
;;;1278       {
;;;1279         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1280         {
;;;1281           return HAL_TIMEOUT;
;;;1282         }
;;;1283         if (pdata8bits == NULL)
;;;1284         {
;;;1285           *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
;;;1286           pdata16bits++;
;;;1287         }
;;;1288         else
;;;1289         {
;;;1290           *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;1291           pdata8bits++;
;;;1292         }
;;;1293         huart->RxXferCount--;
;;;1294       }
;;;1295   
;;;1296       /* At end of Rx process, restore huart->RxState to Ready */
;;;1297       huart->RxState = HAL_UART_STATE_READY;
;;;1298   
;;;1299       return HAL_OK;
;;;1300     }
;;;1301     else
;;;1302     {
;;;1303       return HAL_BUSY;
000012  2002              MOVS     r0,#2
                  |L33.20|
;;;1304     }
;;;1305   }
000014  e8bd8ff8          POP      {r3-r11,pc}
                  |L33.24|
000018  b30e              CBZ      r6,|L33.94|
00001a  b305              CBZ      r5,|L33.94|
00001c  f8940074          LDRB     r0,[r4,#0x74]         ;1246
000020  2801              CMP      r0,#1                 ;1246
000022  d01e              BEQ      |L33.98|
000024  2001              MOVS     r0,#1                 ;1246
000026  f8840074          STRB     r0,[r4,#0x74]         ;1246
00002a  f04f0a00          MOV      r10,#0                ;1248
00002e  f8c4a080          STR      r10,[r4,#0x80]        ;1248
000032  2022              MOVS     r0,#0x22              ;1249
000034  67e0              STR      r0,[r4,#0x7c]         ;1249
000036  f8c4a060          STR      r10,[r4,#0x60]        ;1250
00003a  f7fffffe          BL       HAL_GetTick
00003e  4681              MOV      r9,r0                 ;1253
000040  f8a45058          STRH     r5,[r4,#0x58]         ;1255
000044  f8a4505a          STRH     r5,[r4,#0x5a]         ;1256
000048  68a0              LDR      r0,[r4,#8]            ;1259
00004a  f44f5380          MOV      r3,#0x1000            ;1259
00004e  21ff              MOVS     r1,#0xff              ;1259
000050  4298              CMP      r0,r3                 ;1259
000052  d10d              BNE      |L33.112|
000054  6922              LDR      r2,[r4,#0x10]         ;1259
000056  b132              CBZ      r2,|L33.102|
000058  f8a4105c          STRH     r1,[r4,#0x5c]         ;1259
00005c  e00f              B        |L33.126|
                  |L33.94|
00005e  2001              MOVS     r0,#1                 ;1243
000060  e7d8              B        |L33.20|
                  |L33.98|
000062  2002              MOVS     r0,#2                 ;1246
000064  e7d6              B        |L33.20|
                  |L33.102|
000066  f24011ff          MOV      r1,#0x1ff             ;1259
00006a  f8a4105c          STRH     r1,[r4,#0x5c]         ;1259
00006e  e006              B        |L33.126|
                  |L33.112|
000070  227f              MOVS     r2,#0x7f              ;1259
000072  b178              CBZ      r0,|L33.148|
000074  f1b05f80          CMP      r0,#0x10000000        ;1259
000078  d014              BEQ      |L33.164|
00007a  f8a4a05c          STRH     r10,[r4,#0x5c]        ;1259
                  |L33.126|
00007e  f8b4705c          LDRH     r7,[r4,#0x5c]         ;1260
000082  4298              CMP      r0,r3                 ;1263
000084  d101              BNE      |L33.138|
000086  6920              LDR      r0,[r4,#0x10]         ;1263
000088  b1a8              CBZ      r0,|L33.182|
                  |L33.138|
00008a  4635              MOV      r5,r6                 ;1270
00008c  2600              MOVS     r6,#0                 ;1271
                  |L33.142|
00008e  f884a074          STRB     r10,[r4,#0x74]        ;1274
000092  e028              B        |L33.230|
                  |L33.148|
000094  6925              LDR      r5,[r4,#0x10]         ;1259
000096  b115              CBZ      r5,|L33.158|
000098  f8a4205c          STRH     r2,[r4,#0x5c]         ;1259
00009c  e7ef              B        |L33.126|
                  |L33.158|
00009e  f8a4105c          STRH     r1,[r4,#0x5c]         ;1259
0000a2  e7ec              B        |L33.126|
                  |L33.164|
0000a4  6921              LDR      r1,[r4,#0x10]         ;1259
0000a6  b119              CBZ      r1,|L33.176|
0000a8  213f              MOVS     r1,#0x3f              ;1259
0000aa  f8a4105c          STRH     r1,[r4,#0x5c]         ;1259
0000ae  e7e6              B        |L33.126|
                  |L33.176|
0000b0  f8a4205c          STRH     r2,[r4,#0x5c]         ;1259
0000b4  e7e3              B        |L33.126|
                  |L33.182|
0000b6  2500              MOVS     r5,#0                 ;1265
0000b8  e7e9              B        |L33.142|
                  |L33.186|
0000ba  464b              MOV      r3,r9                 ;1279
0000bc  2200              MOVS     r2,#0                 ;1279
0000be  2120              MOVS     r1,#0x20              ;1279
0000c0  4620              MOV      r0,r4                 ;1279
0000c2  f8cd8000          STR      r8,[sp,#0]            ;1279
0000c6  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000ca  b108              CBZ      r0,|L33.208|
0000cc  2003              MOVS     r0,#3                 ;1281
0000ce  e7a1              B        |L33.20|
                  |L33.208|
0000d0  b18d              CBZ      r5,|L33.246|
0000d2  6820              LDR      r0,[r4,#0]            ;1290
0000d4  8c80              LDRH     r0,[r0,#0x24]         ;1290
0000d6  4038              ANDS     r0,r0,r7              ;1290
0000d8  f8050b01          STRB     r0,[r5],#1            ;1290
                  |L33.220|
0000dc  f8b4005a          LDRH     r0,[r4,#0x5a]         ;1293
0000e0  1e40              SUBS     r0,r0,#1              ;1293
0000e2  f8a4005a          STRH     r0,[r4,#0x5a]         ;1293
                  |L33.230|
0000e6  f8b4005a          LDRH     r0,[r4,#0x5a]         ;1277
0000ea  2800              CMP      r0,#0                 ;1277
0000ec  d1e5              BNE      |L33.186|
0000ee  2020              MOVS     r0,#0x20              ;1297
0000f0  67e0              STR      r0,[r4,#0x7c]         ;1297
0000f2  2000              MOVS     r0,#0                 ;1299
0000f4  e78e              B        |L33.20|
                  |L33.246|
0000f6  6820              LDR      r0,[r4,#0]            ;1285
0000f8  8c80              LDRH     r0,[r0,#0x24]         ;1285
0000fa  4038              ANDS     r0,r0,r7              ;1285
0000fc  f8260b02          STRH     r0,[r6],#2            ;1285
000100  e7ec              B        |L33.220|
;;;1306   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1526     */
;;;1527   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b430              PUSH     {r4,r5}
;;;1528   {
;;;1529     /* Check that a Rx process is not already ongoing */
;;;1530     if (huart->RxState == HAL_UART_STATE_READY)
000002  6fc3              LDR      r3,[r0,#0x7c]
000004  2b20              CMP      r3,#0x20
000006  d002              BEQ      |L34.14|
;;;1531     {
;;;1532       if ((pData == NULL) || (Size == 0U))
;;;1533       {
;;;1534         return HAL_ERROR;
;;;1535       }
;;;1536   
;;;1537       __HAL_LOCK(huart);
;;;1538   
;;;1539       /* Set Reception type to Standard reception */
;;;1540       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1541   
;;;1542       if (!(IS_LPUART_INSTANCE(huart->Instance)))
;;;1543       {
;;;1544         /* Check that USART RTOEN bit is set */
;;;1545         if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
;;;1546         {
;;;1547           /* Enable the UART Receiver Timeout Interrupt */
;;;1548           SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
;;;1549         }
;;;1550       }
;;;1551   
;;;1552       return(UART_Start_Receive_DMA(huart, pData, Size));
;;;1553     }
;;;1554     else
;;;1555     {
;;;1556       return HAL_BUSY;
000008  2002              MOVS     r0,#2
                  |L34.10|
;;;1557     }
;;;1558   }
00000a  bc30              POP      {r4,r5}
00000c  4770              BX       lr
                  |L34.14|
00000e  b1b9              CBZ      r1,|L34.64|
000010  b1b2              CBZ      r2,|L34.64|
000012  f8903074          LDRB     r3,[r0,#0x74]         ;1537
000016  2b01              CMP      r3,#1                 ;1537
000018  d014              BEQ      |L34.68|
00001a  2301              MOVS     r3,#1                 ;1537
00001c  f8803074          STRB     r3,[r0,#0x74]         ;1537
000020  2300              MOVS     r3,#0                 ;1540
000022  6603              STR      r3,[r0,#0x60]         ;1540
000024  4c08              LDR      r4,|L34.72|
000026  6803              LDR      r3,[r0,#0]            ;1542
000028  42a3              CMP      r3,r4                 ;1542
00002a  d006              BEQ      |L34.58|
00002c  685c              LDR      r4,[r3,#4]            ;1545
00002e  0224              LSLS     r4,r4,#8              ;1545
000030  d503              BPL      |L34.58|
000032  681c              LDR      r4,[r3,#0]            ;1548
000034  f0446480          ORR      r4,r4,#0x4000000      ;1548
000038  601c              STR      r4,[r3,#0]            ;1548
                  |L34.58|
00003a  bc30              POP      {r4,r5}               ;1552
00003c  f7ffbffe          B.W      UART_Start_Receive_DMA
                  |L34.64|
000040  2001              MOVS     r0,#1                 ;1534
000042  e7e2              B        |L34.10|
                  |L34.68|
000044  2002              MOVS     r0,#2                 ;1537
000046  e7e0              B        |L34.10|
;;;1559   
                          ENDP

                  |L34.72|
                          DCD      0x40008000

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_IT PROC
;;;1407     */
;;;1408   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b410              PUSH     {r4}
;;;1409   {
;;;1410     /* Check that a Rx process is not already ongoing */
;;;1411     if (huart->RxState == HAL_UART_STATE_READY)
000002  6fc3              LDR      r3,[r0,#0x7c]
000004  2b20              CMP      r3,#0x20
000006  d002              BEQ      |L35.14|
;;;1412     {
;;;1413       if ((pData == NULL) || (Size == 0U))
;;;1414       {
;;;1415         return HAL_ERROR;
;;;1416       }
;;;1417   
;;;1418       __HAL_LOCK(huart);
;;;1419   
;;;1420       /* Set Reception type to Standard reception */
;;;1421       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1422   
;;;1423       if (!(IS_LPUART_INSTANCE(huart->Instance)))
;;;1424       {
;;;1425         /* Check that USART RTOEN bit is set */
;;;1426         if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
;;;1427         {
;;;1428           /* Enable the UART Receiver Timeout Interrupt */
;;;1429           SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
;;;1430         }
;;;1431       }
;;;1432   
;;;1433       return(UART_Start_Receive_IT(huart, pData, Size));
;;;1434     }
;;;1435     else
;;;1436     {
;;;1437       return HAL_BUSY;
000008  2002              MOVS     r0,#2
                  |L35.10|
;;;1438     }
;;;1439   }
00000a  bc10              POP      {r4}
00000c  4770              BX       lr
                  |L35.14|
00000e  b1b9              CBZ      r1,|L35.64|
000010  b1b2              CBZ      r2,|L35.64|
000012  f8903074          LDRB     r3,[r0,#0x74]         ;1418
000016  2b01              CMP      r3,#1                 ;1418
000018  d014              BEQ      |L35.68|
00001a  2301              MOVS     r3,#1                 ;1418
00001c  f8803074          STRB     r3,[r0,#0x74]         ;1418
000020  2300              MOVS     r3,#0                 ;1421
000022  6603              STR      r3,[r0,#0x60]         ;1421
000024  4c08              LDR      r4,|L35.72|
000026  6803              LDR      r3,[r0,#0]            ;1423
000028  42a3              CMP      r3,r4                 ;1423
00002a  d006              BEQ      |L35.58|
00002c  685c              LDR      r4,[r3,#4]            ;1426
00002e  0224              LSLS     r4,r4,#8              ;1426
000030  d503              BPL      |L35.58|
000032  681c              LDR      r4,[r3,#0]            ;1429
000034  f0446480          ORR      r4,r4,#0x4000000      ;1429
000038  601c              STR      r4,[r3,#0]            ;1429
                  |L35.58|
00003a  bc10              POP      {r4}                  ;1433
00003c  f7ffbffe          B.W      UART_Start_Receive_IT
                  |L35.64|
000040  2001              MOVS     r0,#1                 ;1415
000042  e7e2              B        |L35.10|
                  |L35.68|
000044  2002              MOVS     r0,#2                 ;1418
000046  e7e0              B        |L35.10|
;;;1440   
                          ENDP

                  |L35.72|
                          DCD      0x40008000

                          AREA ||i.HAL_UART_ReceiverTimeout_Config||, CODE, READONLY, ALIGN=2

                  HAL_UART_ReceiverTimeout_Config PROC
;;;2830     */
;;;2831   void HAL_UART_ReceiverTimeout_Config(UART_HandleTypeDef *huart, uint32_t TimeoutValue)
000000  6800              LDR      r0,[r0,#0]
;;;2832   {
;;;2833     if (!(IS_LPUART_INSTANCE(huart->Instance)))
000002  4a04              LDR      r2,|L36.20|
000004  4290              CMP      r0,r2
000006  d004              BEQ      |L36.18|
;;;2834     {
;;;2835       assert_param(IS_UART_RECEIVER_TIMEOUT_VALUE(TimeoutValue));
;;;2836       MODIFY_REG(huart->Instance->RTOR, USART_RTOR_RTO, TimeoutValue);
000008  6942              LDR      r2,[r0,#0x14]
00000a  f002427f          AND      r2,r2,#0xff000000
00000e  430a              ORRS     r2,r2,r1
000010  6142              STR      r2,[r0,#0x14]
                  |L36.18|
;;;2837     }
;;;2838   }
000012  4770              BX       lr
;;;2839   
                          ENDP

                  |L36.20|
                          DCD      0x40008000

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2690     */
;;;2691   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2692   {
;;;2693     /* Prevent unused argument(s) compilation warning */
;;;2694     UNUSED(huart);
;;;2695   
;;;2696     /* NOTE : This function should not be modified, when the callback is needed,
;;;2697               the HAL_UART_RxCpltCallback can be implemented in the user file.
;;;2698      */
;;;2699   }
;;;2700   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2705     */
;;;2706   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2707   {
;;;2708     /* Prevent unused argument(s) compilation warning */
;;;2709     UNUSED(huart);
;;;2710   
;;;2711     /* NOTE: This function should not be modified, when the callback is needed,
;;;2712              the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
;;;2713      */
;;;2714   }
;;;2715   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1141     */
;;;1142   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1143   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1144     uint8_t  *pdata8bits;
;;;1145     uint16_t *pdata16bits;
;;;1146     uint32_t tickstart;
;;;1147   
;;;1148     /* Check that a Tx process is not already ongoing */
;;;1149     if (huart->gState == HAL_UART_STATE_READY)
00000c  6fa0              LDR      r0,[r4,#0x78]
00000e  2820              CMP      r0,#0x20
000010  d002              BEQ      |L39.24|
;;;1150     {
;;;1151       if ((pData == NULL) || (Size == 0U))
;;;1152       {
;;;1153         return  HAL_ERROR;
;;;1154       }
;;;1155   
;;;1156       __HAL_LOCK(huart);
;;;1157   
;;;1158       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1159       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1160   
;;;1161       /* Init tickstart for timeout management */
;;;1162       tickstart = HAL_GetTick();
;;;1163   
;;;1164       huart->TxXferSize  = Size;
;;;1165       huart->TxXferCount = Size;
;;;1166   
;;;1167       /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
;;;1168       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1169       {
;;;1170         pdata8bits  = NULL;
;;;1171         pdata16bits = (uint16_t *) pData;
;;;1172       }
;;;1173       else
;;;1174       {
;;;1175         pdata8bits  = pData;
;;;1176         pdata16bits = NULL;
;;;1177       }
;;;1178   
;;;1179       __HAL_UNLOCK(huart);
;;;1180   
;;;1181       while (huart->TxXferCount > 0U)
;;;1182       {
;;;1183         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1184         {
;;;1185           return HAL_TIMEOUT;
;;;1186         }
;;;1187         if (pdata8bits == NULL)
;;;1188         {
;;;1189           huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
;;;1190           pdata16bits++;
;;;1191         }
;;;1192         else
;;;1193         {
;;;1194           huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
;;;1195           pdata8bits++;
;;;1196         }
;;;1197         huart->TxXferCount--;
;;;1198       }
;;;1199   
;;;1200       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1201       {
;;;1202         return HAL_TIMEOUT;
;;;1203       }
;;;1204   
;;;1205       /* At end of Tx process, restore huart->gState to Ready */
;;;1206       huart->gState = HAL_UART_STATE_READY;
;;;1207   
;;;1208       return HAL_OK;
;;;1209     }
;;;1210     else
;;;1211     {
;;;1212       return HAL_BUSY;
000012  2002              MOVS     r0,#2
                  |L39.20|
;;;1213     }
;;;1214   }
000014  e8bd83f8          POP      {r3-r9,pc}
                  |L39.24|
000018  b1ce              CBZ      r6,|L39.78|
00001a  b1c5              CBZ      r5,|L39.78|
00001c  f8940074          LDRB     r0,[r4,#0x74]         ;1156
000020  2801              CMP      r0,#1                 ;1156
000022  d016              BEQ      |L39.82|
000024  2001              MOVS     r0,#1                 ;1156
000026  f8840074          STRB     r0,[r4,#0x74]         ;1156
00002a  f04f0900          MOV      r9,#0                 ;1158
00002e  f8c49080          STR      r9,[r4,#0x80]         ;1158
000032  2021              MOVS     r0,#0x21              ;1159
000034  67a0              STR      r0,[r4,#0x78]         ;1159
000036  f7fffffe          BL       HAL_GetTick
00003a  4680              MOV      r8,r0                 ;1162
00003c  f8a45050          STRH     r5,[r4,#0x50]         ;1164
000040  f8a45052          STRH     r5,[r4,#0x52]         ;1165
000044  68a0              LDR      r0,[r4,#8]            ;1168
000046  f5b05f80          CMP      r0,#0x1000            ;1168
00004a  d004              BEQ      |L39.86|
00004c  e005              B        |L39.90|
                  |L39.78|
00004e  2001              MOVS     r0,#1                 ;1153
000050  e7e0              B        |L39.20|
                  |L39.82|
000052  2002              MOVS     r0,#2                 ;1156
000054  e7de              B        |L39.20|
                  |L39.86|
000056  6920              LDR      r0,[r4,#0x10]         ;1168
000058  b120              CBZ      r0,|L39.100|
                  |L39.90|
00005a  4635              MOV      r5,r6                 ;1175
00005c  2600              MOVS     r6,#0                 ;1176
                  |L39.94|
00005e  f8849074          STRB     r9,[r4,#0x74]         ;1179
000062  e015              B        |L39.144|
                  |L39.100|
000064  2500              MOVS     r5,#0                 ;1170
000066  e7fa              B        |L39.94|
                  |L39.104|
000068  4643              MOV      r3,r8                 ;1183
00006a  2200              MOVS     r2,#0                 ;1183
00006c  2180              MOVS     r1,#0x80              ;1183
00006e  4620              MOV      r0,r4                 ;1183
000070  9700              STR      r7,[sp,#0]            ;1183
000072  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000076  b108              CBZ      r0,|L39.124|
000078  2003              MOVS     r0,#3                 ;1185
00007a  e7cb              B        |L39.20|
                  |L39.124|
00007c  b1b5              CBZ      r5,|L39.172|
00007e  6821              LDR      r1,[r4,#0]            ;1194
000080  f8150b01          LDRB     r0,[r5],#1            ;1194
000084  8508              STRH     r0,[r1,#0x28]         ;1194
                  |L39.134|
000086  f8b40052          LDRH     r0,[r4,#0x52]         ;1197
00008a  1e40              SUBS     r0,r0,#1              ;1197
00008c  f8a40052          STRH     r0,[r4,#0x52]         ;1197
                  |L39.144|
000090  f8b40052          LDRH     r0,[r4,#0x52]         ;1181
000094  2800              CMP      r0,#0                 ;1181
000096  d1e7              BNE      |L39.104|
000098  4643              MOV      r3,r8                 ;1200
00009a  2200              MOVS     r2,#0                 ;1200
00009c  2140              MOVS     r1,#0x40              ;1200
00009e  4620              MOV      r0,r4                 ;1200
0000a0  9700              STR      r7,[sp,#0]            ;1200
0000a2  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a6  b140              CBZ      r0,|L39.186|
0000a8  2003              MOVS     r0,#3                 ;1202
0000aa  e7b3              B        |L39.20|
                  |L39.172|
0000ac  f8360b02          LDRH     r0,[r6],#2            ;1189
0000b0  6821              LDR      r1,[r4,#0]            ;1189
0000b2  f3c00008          UBFX     r0,r0,#0,#9           ;1189
0000b6  8508              STRH     r0,[r1,#0x28]         ;1189
0000b8  e7e5              B        |L39.134|
                  |L39.186|
0000ba  2020              MOVS     r0,#0x20              ;1206
0000bc  67a0              STR      r0,[r4,#0x78]         ;1206
0000be  2000              MOVS     r0,#0                 ;1208
0000c0  e7a8              B        |L39.20|
;;;1215   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1450     */
;;;1451   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1452   {
000002  4604              MOV      r4,r0
;;;1453     /* Check that a Tx process is not already ongoing */
;;;1454     if (huart->gState == HAL_UART_STATE_READY)
000004  6fa0              LDR      r0,[r4,#0x78]
000006  2820              CMP      r0,#0x20
000008  d001              BEQ      |L40.14|
;;;1455     {
;;;1456       if ((pData == NULL) || (Size == 0U))
;;;1457       {
;;;1458         return HAL_ERROR;
;;;1459       }
;;;1460   
;;;1461       __HAL_LOCK(huart);
;;;1462   
;;;1463       huart->pTxBuffPtr  = pData;
;;;1464       huart->TxXferSize  = Size;
;;;1465       huart->TxXferCount = Size;
;;;1466   
;;;1467       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1468       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1469   
;;;1470       if (huart->hdmatx != NULL)
;;;1471       {
;;;1472         /* Set the UART DMA transfer complete callback */
;;;1473         huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1474   
;;;1475         /* Set the UART DMA Half transfer complete callback */
;;;1476         huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1477   
;;;1478         /* Set the DMA error callback */
;;;1479         huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1480   
;;;1481         /* Set the DMA abort callback */
;;;1482         huart->hdmatx->XferAbortCallback = NULL;
;;;1483   
;;;1484         /* Enable the UART transmit DMA channel */
;;;1485         if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
;;;1486         {
;;;1487           /* Set error code to DMA */
;;;1488           huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1489   
;;;1490           __HAL_UNLOCK(huart);
;;;1491   
;;;1492           /* Restore huart->gState to ready */
;;;1493           huart->gState = HAL_UART_STATE_READY;
;;;1494   
;;;1495           return HAL_ERROR;
;;;1496         }
;;;1497       }
;;;1498       /* Clear the TC flag in the ICR register */
;;;1499       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
;;;1500   
;;;1501       __HAL_UNLOCK(huart);
;;;1502   
;;;1503       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1504       in the UART CR3 register */
;;;1505       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1506   
;;;1507       return HAL_OK;
;;;1508     }
;;;1509     else
;;;1510     {
;;;1511       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;1512     }
;;;1513   }
00000c  bd70              POP      {r4-r6,pc}
                  |L40.14|
00000e  b371              CBZ      r1,|L40.110|
000010  b36a              CBZ      r2,|L40.110|
000012  f8940074          LDRB     r0,[r4,#0x74]         ;1461
000016  2801              CMP      r0,#1                 ;1461
000018  d02c              BEQ      |L40.116|
00001a  2001              MOVS     r0,#1                 ;1461
00001c  344c              ADDS     r4,r4,#0x4c           ;1461
00001e  f8840028          STRB     r0,[r4,#0x28]         ;1461
000022  6021              STR      r1,[r4,#0]            ;1463
000024  80a2              STRH     r2,[r4,#4]            ;1464
000026  80e2              STRH     r2,[r4,#6]            ;1465
000028  2500              MOVS     r5,#0                 ;1467
00002a  6365              STR      r5,[r4,#0x34]         ;1467
00002c  2021              MOVS     r0,#0x21              ;1468
00002e  62e0              STR      r0,[r4,#0x2c]         ;1468
000030  6a20              LDR      r0,[r4,#0x20]         ;1470
000032  3c4c              SUBS     r4,r4,#0x4c           ;1470
000034  b300              CBZ      r0,|L40.120|
000036  4916              LDR      r1,|L40.144|
000038  62c1              STR      r1,[r0,#0x2c]         ;1473
00003a  6ee1              LDR      r1,[r4,#0x6c]         ;1476
00003c  4815              LDR      r0,|L40.148|
00003e  6308              STR      r0,[r1,#0x30]         ;1476
000040  6ee1              LDR      r1,[r4,#0x6c]         ;1479
000042  4815              LDR      r0,|L40.152|
000044  6348              STR      r0,[r1,#0x34]         ;1479
000046  6ee0              LDR      r0,[r4,#0x6c]         ;1482
000048  6385              STR      r5,[r0,#0x38]         ;1482
00004a  6820              LDR      r0,[r4,#0]            ;1485
00004c  4613              MOV      r3,r2                 ;1485
00004e  3028              ADDS     r0,r0,#0x28           ;1485
000050  6ee6              LDR      r6,[r4,#0x6c]         ;1485
000052  4602              MOV      r2,r0                 ;1485
000054  4630              MOV      r0,r6                 ;1485
000056  6ce1              LDR      r1,[r4,#0x4c]         ;1485
000058  f7fffffe          BL       HAL_DMA_Start_IT
00005c  b160              CBZ      r0,|L40.120|
00005e  2010              MOVS     r0,#0x10              ;1488
000060  3474              ADDS     r4,r4,#0x74           ;1488
000062  60e0              STR      r0,[r4,#0xc]          ;1488
000064  7025              STRB     r5,[r4,#0]            ;1490
000066  2020              MOVS     r0,#0x20              ;1493
000068  6060              STR      r0,[r4,#4]            ;1493
00006a  2001              MOVS     r0,#1                 ;1495
                  |L40.108|
00006c  bd70              POP      {r4-r6,pc}
                  |L40.110|
00006e  e7ff              B        |L40.112|
                  |L40.112|
000070  2001              MOVS     r0,#1                 ;1458
000072  e7fb              B        |L40.108|
                  |L40.116|
000074  2002              MOVS     r0,#2                 ;1461
000076  e7f9              B        |L40.108|
                  |L40.120|
000078  6821              LDR      r1,[r4,#0]            ;1499
00007a  2040              MOVS     r0,#0x40              ;1499
00007c  6208              STR      r0,[r1,#0x20]         ;1499
00007e  f8845074          STRB     r5,[r4,#0x74]         ;1501
000082  6820              LDR      r0,[r4,#0]            ;1505
000084  6881              LDR      r1,[r0,#8]            ;1505
000086  f0410180          ORR      r1,r1,#0x80           ;1505
00008a  6081              STR      r1,[r0,#8]            ;1505
00008c  2000              MOVS     r0,#0                 ;1507
00008e  e7ed              B        |L40.108|
;;;1514   
                          ENDP

                  |L40.144|
                          DCD      UART_DMATransmitCplt
                  |L40.148|
                          DCD      UART_DMATxHalfCplt
                  |L40.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_IT PROC
;;;1316     */
;;;1317   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6f83              LDR      r3,[r0,#0x78]
;;;1318   {
;;;1319     /* Check that a Tx process is not already ongoing */
;;;1320     if (huart->gState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d001              BEQ      |L41.10|
;;;1321     {
;;;1322       if ((pData == NULL) || (Size == 0U))
;;;1323       {
;;;1324         return HAL_ERROR;
;;;1325       }
;;;1326   
;;;1327       __HAL_LOCK(huart);
;;;1328   
;;;1329       huart->pTxBuffPtr  = pData;
;;;1330       huart->TxXferSize  = Size;
;;;1331       huart->TxXferCount = Size;
;;;1332       huart->TxISR       = NULL;
;;;1333   
;;;1334       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1335       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1336   
;;;1337   #if defined(USART_CR1_FIFOEN)
;;;1338       /* Configure Tx interrupt processing */
;;;1339       if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;1340       {
;;;1341         /* Set the Tx ISR function pointer according to the data word length */
;;;1342         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1343         {
;;;1344           huart->TxISR = UART_TxISR_16BIT_FIFOEN;
;;;1345         }
;;;1346         else
;;;1347         {
;;;1348           huart->TxISR = UART_TxISR_8BIT_FIFOEN;
;;;1349         }
;;;1350   
;;;1351         __HAL_UNLOCK(huart);
;;;1352   
;;;1353         /* Enable the TX FIFO threshold interrupt */
;;;1354         SET_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
;;;1355       }
;;;1356       else
;;;1357       {
;;;1358         /* Set the Tx ISR function pointer according to the data word length */
;;;1359         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1360         {
;;;1361           huart->TxISR = UART_TxISR_16BIT;
;;;1362         }
;;;1363         else
;;;1364         {
;;;1365           huart->TxISR = UART_TxISR_8BIT;
;;;1366         }
;;;1367   
;;;1368         __HAL_UNLOCK(huart);
;;;1369   
;;;1370         /* Enable the Transmit Data Register Empty interrupt */
;;;1371         SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
;;;1372       }
;;;1373   #else
;;;1374       /* Set the Tx ISR function pointer according to the data word length */
;;;1375       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1376       {
;;;1377         huart->TxISR = UART_TxISR_16BIT;
;;;1378       }
;;;1379       else
;;;1380       {
;;;1381         huart->TxISR = UART_TxISR_8BIT;
;;;1382       }
;;;1383   
;;;1384       __HAL_UNLOCK(huart);
;;;1385   
;;;1386       /* Enable the Transmit Data Register Empty interrupt */
;;;1387       SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;1388   #endif /* USART_CR1_FIFOEN */
;;;1389   
;;;1390       return HAL_OK;
;;;1391     }
;;;1392     else
;;;1393     {
;;;1394       return HAL_BUSY;
000006  2002              MOVS     r0,#2
;;;1395     }
;;;1396   }
000008  4770              BX       lr
                  |L41.10|
00000a  b1b9              CBZ      r1,|L41.60|
00000c  b1b2              CBZ      r2,|L41.60|
00000e  f8903074          LDRB     r3,[r0,#0x74]         ;1327
000012  2b01              CMP      r3,#1                 ;1327
000014  d014              BEQ      |L41.64|
000016  2301              MOVS     r3,#1                 ;1327
000018  f8803074          STRB     r3,[r0,#0x74]         ;1327
00001c  64c1              STR      r1,[r0,#0x4c]         ;1329
00001e  f8a02050          STRH     r2,[r0,#0x50]         ;1330
000022  f8a02052          STRH     r2,[r0,#0x52]         ;1331
000026  2100              MOVS     r1,#0                 ;1332
000028  6681              STR      r1,[r0,#0x68]         ;1332
00002a  f8c01080          STR      r1,[r0,#0x80]         ;1334
00002e  2221              MOVS     r2,#0x21              ;1335
000030  6782              STR      r2,[r0,#0x78]         ;1335
000032  6882              LDR      r2,[r0,#8]            ;1375
000034  f5b25f80          CMP      r2,#0x1000            ;1375
000038  d004              BEQ      |L41.68|
00003a  e005              B        |L41.72|
                  |L41.60|
00003c  2001              MOVS     r0,#1                 ;1324
00003e  4770              BX       lr
                  |L41.64|
000040  2002              MOVS     r0,#2                 ;1327
000042  4770              BX       lr
                  |L41.68|
000044  6902              LDR      r2,[r0,#0x10]         ;1375
000046  b152              CBZ      r2,|L41.94|
                  |L41.72|
000048  4a06              LDR      r2,|L41.100|
00004a  6682              STR      r2,[r0,#0x68]         ;1381
                  |L41.76|
00004c  f8801074          STRB     r1,[r0,#0x74]         ;1384
000050  6800              LDR      r0,[r0,#0]            ;1387
000052  6801              LDR      r1,[r0,#0]            ;1387
000054  f0410180          ORR      r1,r1,#0x80           ;1387
000058  6001              STR      r1,[r0,#0]            ;1387
00005a  2000              MOVS     r0,#0                 ;1390
00005c  4770              BX       lr
                  |L41.94|
00005e  4a02              LDR      r2,|L41.104|
000060  6682              STR      r2,[r0,#0x68]         ;1377
000062  e7f3              B        |L41.76|
;;;1397   
                          ENDP

                  |L41.100|
                          DCD      UART_TxISR_8BIT
                  |L41.104|
                          DCD      UART_TxISR_16BIT

                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2660     */
;;;2661   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2662   {
;;;2663     /* Prevent unused argument(s) compilation warning */
;;;2664     UNUSED(huart);
;;;2665   
;;;2666     /* NOTE : This function should not be modified, when the callback is needed,
;;;2667               the HAL_UART_TxCpltCallback can be implemented in the user file.
;;;2668      */
;;;2669   }
;;;2670   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2675     */
;;;2676   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2677   {
;;;2678     /* Prevent unused argument(s) compilation warning */
;;;2679     UNUSED(huart);
;;;2680   
;;;2681     /* NOTE: This function should not be modified, when the callback is needed,
;;;2682              the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
;;;2683      */
;;;2684   }
;;;2685   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;3382     */
;;;3383   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  f8901024          LDRB     r1,[r0,#0x24]
;;;3384   {
;;;3385     /* Check whether the set of advanced features to configure is properly set */
;;;3386     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;3387   
;;;3388     /* if required, configure TX pin active level inversion */
;;;3389     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000004  07c9              LSLS     r1,r1,#31
000006  d006              BEQ      |L44.22|
;;;3390     {
;;;3391       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;3392       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
000008  6801              LDR      r1,[r0,#0]
00000a  684a              LDR      r2,[r1,#4]
00000c  6a83              LDR      r3,[r0,#0x28]
00000e  f4223200          BIC      r2,r2,#0x20000
000012  431a              ORRS     r2,r2,r3
000014  604a              STR      r2,[r1,#4]
                  |L44.22|
;;;3393     }
;;;3394   
;;;3395     /* if required, configure RX pin active level inversion */
;;;3396     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
000016  f8901024          LDRB     r1,[r0,#0x24]
00001a  0789              LSLS     r1,r1,#30
00001c  d506              BPL      |L44.44|
;;;3397     {
;;;3398       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;3399       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
00001e  6801              LDR      r1,[r0,#0]
000020  684a              LDR      r2,[r1,#4]
000022  6ac3              LDR      r3,[r0,#0x2c]
000024  f4223280          BIC      r2,r2,#0x10000
000028  431a              ORRS     r2,r2,r3
00002a  604a              STR      r2,[r1,#4]
                  |L44.44|
;;;3400     }
;;;3401   
;;;3402     /* if required, configure data inversion */
;;;3403     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
00002c  f8901024          LDRB     r1,[r0,#0x24]
000030  0749              LSLS     r1,r1,#29
000032  d506              BPL      |L44.66|
;;;3404     {
;;;3405       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;3406       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
000034  6801              LDR      r1,[r0,#0]
000036  684a              LDR      r2,[r1,#4]
000038  6b03              LDR      r3,[r0,#0x30]
00003a  f4222280          BIC      r2,r2,#0x40000
00003e  431a              ORRS     r2,r2,r3
000040  604a              STR      r2,[r1,#4]
                  |L44.66|
;;;3407     }
;;;3408   
;;;3409     /* if required, configure RX/TX pins swap */
;;;3410     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000042  f8901024          LDRB     r1,[r0,#0x24]
000046  0709              LSLS     r1,r1,#28
000048  d506              BPL      |L44.88|
;;;3411     {
;;;3412       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;3413       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
00004a  6801              LDR      r1,[r0,#0]
00004c  684a              LDR      r2,[r1,#4]
00004e  6b43              LDR      r3,[r0,#0x34]
000050  f4224200          BIC      r2,r2,#0x8000
000054  431a              ORRS     r2,r2,r3
000056  604a              STR      r2,[r1,#4]
                  |L44.88|
;;;3414     }
;;;3415   
;;;3416     /* if required, configure RX overrun detection disabling */
;;;3417     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
000058  f8901024          LDRB     r1,[r0,#0x24]
00005c  06c9              LSLS     r1,r1,#27
00005e  d506              BPL      |L44.110|
;;;3418     {
;;;3419       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;3420       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000060  6801              LDR      r1,[r0,#0]
000062  688a              LDR      r2,[r1,#8]
000064  6b83              LDR      r3,[r0,#0x38]
000066  f4225280          BIC      r2,r2,#0x1000
00006a  431a              ORRS     r2,r2,r3
00006c  608a              STR      r2,[r1,#8]
                  |L44.110|
;;;3421     }
;;;3422   
;;;3423     /* if required, configure DMA disabling on reception error */
;;;3424     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
00006e  f8901024          LDRB     r1,[r0,#0x24]
000072  0689              LSLS     r1,r1,#26
000074  d506              BPL      |L44.132|
;;;3425     {
;;;3426       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;3427       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
000076  6801              LDR      r1,[r0,#0]
000078  688a              LDR      r2,[r1,#8]
00007a  6bc3              LDR      r3,[r0,#0x3c]
00007c  f4225200          BIC      r2,r2,#0x2000
000080  431a              ORRS     r2,r2,r3
000082  608a              STR      r2,[r1,#8]
                  |L44.132|
;;;3428     }
;;;3429   
;;;3430     /* if required, configure auto Baud rate detection scheme */
;;;3431     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
000084  f8901024          LDRB     r1,[r0,#0x24]
000088  0649              LSLS     r1,r1,#25
00008a  d511              BPL      |L44.176|
;;;3432     {
;;;3433       assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
;;;3434       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;3435       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
00008c  6801              LDR      r1,[r0,#0]
00008e  684a              LDR      r2,[r1,#4]
000090  6c03              LDR      r3,[r0,#0x40]
000092  f4221280          BIC      r2,r2,#0x100000
000096  431a              ORRS     r2,r2,r3
000098  604a              STR      r2,[r1,#4]
;;;3436       /* set auto Baudrate detection parameters if detection is enabled */
;;;3437       if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
00009a  6c01              LDR      r1,[r0,#0x40]
00009c  f5b11f80          CMP      r1,#0x100000
0000a0  d106              BNE      |L44.176|
;;;3438       {
;;;3439         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;3440         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000a2  6801              LDR      r1,[r0,#0]
0000a4  684a              LDR      r2,[r1,#4]
0000a6  6c43              LDR      r3,[r0,#0x44]
0000a8  f42202c0          BIC      r2,r2,#0x600000
0000ac  431a              ORRS     r2,r2,r3
0000ae  604a              STR      r2,[r1,#4]
                  |L44.176|
;;;3441       }
;;;3442     }
;;;3443   
;;;3444     /* if required, configure MSB first on communication line */
;;;3445     if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000b0  f8901024          LDRB     r1,[r0,#0x24]
0000b4  0609              LSLS     r1,r1,#24
0000b6  d506              BPL      |L44.198|
;;;3446     {
;;;3447       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;3448       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000b8  6801              LDR      r1,[r0,#0]
0000ba  684a              LDR      r2,[r1,#4]
0000bc  6c80              LDR      r0,[r0,#0x48]
0000be  f4222200          BIC      r2,r2,#0x80000
0000c2  4302              ORRS     r2,r2,r0
0000c4  604a              STR      r2,[r1,#4]
                  |L44.198|
;;;3449     }
;;;3450   }
0000c6  4770              BX       lr
;;;3451   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;3456     */
;;;3457   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3458   {
000002  4604              MOV      r4,r0
;;;3459     uint32_t tickstart;
;;;3460   
;;;3461     /* Initialize the UART ErrorCode */
;;;3462     huart->ErrorCode = HAL_UART_ERROR_NONE;
000004  2500              MOVS     r5,#0
000006  f8c45080          STR      r5,[r4,#0x80]
;;;3463   
;;;3464     /* Init tickstart for timeout management */
;;;3465     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4607              MOV      r7,r0
;;;3466   
;;;3467     /* Check if the Transmitter is enabled */
;;;3468     if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
;;;3469     {
;;;3470       /* Wait until TEACK flag is set */
;;;3471       if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000014  f06f467e          MVN      r6,#0xfe000000
000018  0700              LSLS     r0,r0,#28             ;3468
00001a  d50a              BPL      |L45.50|
00001c  463b              MOV      r3,r7
00001e  2200              MOVS     r2,#0
000020  f44f1100          MOV      r1,#0x200000
000024  4620              MOV      r0,r4
000026  9600              STR      r6,[sp,#0]
000028  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00002c  b108              CBZ      r0,|L45.50|
;;;3472       {
;;;3473         /* Timeout occurred */
;;;3474         return HAL_TIMEOUT;
00002e  2003              MOVS     r0,#3
;;;3475       }
;;;3476     }
;;;3477   
;;;3478     /* Check if the Receiver is enabled */
;;;3479     if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
;;;3480     {
;;;3481       /* Wait until REACK flag is set */
;;;3482       if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;3483       {
;;;3484         /* Timeout occurred */
;;;3485         return HAL_TIMEOUT;
;;;3486       }
;;;3487     }
;;;3488   
;;;3489     /* Initialize the UART State */
;;;3490     huart->gState = HAL_UART_STATE_READY;
;;;3491     huart->RxState = HAL_UART_STATE_READY;
;;;3492     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;3493   
;;;3494     __HAL_UNLOCK(huart);
;;;3495   
;;;3496     return HAL_OK;
;;;3497   }
000030  bdf8              POP      {r3-r7,pc}
                  |L45.50|
000032  6820              LDR      r0,[r4,#0]            ;3479
000034  6800              LDR      r0,[r0,#0]            ;3479
000036  0740              LSLS     r0,r0,#29             ;3479
000038  d50a              BPL      |L45.80|
00003a  463b              MOV      r3,r7                 ;3482
00003c  2200              MOVS     r2,#0                 ;3482
00003e  f44f0180          MOV      r1,#0x400000          ;3482
000042  4620              MOV      r0,r4                 ;3482
000044  9600              STR      r6,[sp,#0]            ;3482
000046  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00004a  b108              CBZ      r0,|L45.80|
00004c  2003              MOVS     r0,#3                 ;3485
00004e  bdf8              POP      {r3-r7,pc}
                  |L45.80|
000050  2020              MOVS     r0,#0x20              ;3490
000052  67a0              STR      r0,[r4,#0x78]         ;3490
000054  67e0              STR      r0,[r4,#0x7c]         ;3491
000056  6625              STR      r5,[r4,#0x60]         ;3492
000058  f8845074          STRB     r5,[r4,#0x74]         ;3494
00005c  2000              MOVS     r0,#0                 ;3496
00005e  bdf8              POP      {r3-r7,pc}
;;;3498   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;3952     */
;;;3953   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3954   {
;;;3955     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3956     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a0105a          STRH     r1,[r0,#0x5a]
;;;3957     huart->TxXferCount = 0U;
00000a  f8a01052          STRH     r1,[r0,#0x52]
;;;3958   
;;;3959   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3960     /*Call registered error callback*/
;;;3961     huart->ErrorCallback(huart);
;;;3962   #else
;;;3963     /*Call legacy weak error callback*/
;;;3964     HAL_UART_ErrorCallback(huart);
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3965   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3966   }
000012  bd10              POP      {r4,pc}
;;;3967   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;3912     */
;;;3913   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3914   {
;;;3915     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a84              LDR      r4,[r0,#0x28]
;;;3916   
;;;3917     const HAL_UART_StateTypeDef gstate = huart->gState;
000004  6fa0              LDR      r0,[r4,#0x78]
;;;3918     const HAL_UART_StateTypeDef rxstate = huart->RxState;
000006  6fe5              LDR      r5,[r4,#0x7c]
;;;3919   
;;;3920     /* Stop UART DMA Tx request if ongoing */
;;;3921     if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
000008  6821              LDR      r1,[r4,#0]
00000a  6889              LDR      r1,[r1,#8]
00000c  f04f0600          MOV      r6,#0
000010  0609              LSLS     r1,r1,#24
000012  d506              BPL      |L47.34|
;;;3922         (gstate == HAL_UART_STATE_BUSY_TX))
000014  2821              CMP      r0,#0x21
000016  d104              BNE      |L47.34|
;;;3923     {
;;;3924       huart->TxXferCount = 0U;
000018  f8a46052          STRH     r6,[r4,#0x52]
;;;3925       UART_EndTxTransfer(huart);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       UART_EndTxTransfer
                  |L47.34|
;;;3926     }
;;;3927   
;;;3928     /* Stop UART DMA Rx request if ongoing */
;;;3929     if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
000022  6820              LDR      r0,[r4,#0]
000024  6880              LDR      r0,[r0,#8]
000026  0640              LSLS     r0,r0,#25
000028  d506              BPL      |L47.56|
;;;3930         (rxstate == HAL_UART_STATE_BUSY_RX))
00002a  2d22              CMP      r5,#0x22
00002c  d104              BNE      |L47.56|
;;;3931     {
;;;3932       huart->RxXferCount = 0U;
00002e  f8a4605a          STRH     r6,[r4,#0x5a]
;;;3933       UART_EndRxTransfer(huart);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       UART_EndRxTransfer
                  |L47.56|
;;;3934     }
;;;3935   
;;;3936     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000038  f8d40080          LDR      r0,[r4,#0x80]
00003c  f0400010          ORR      r0,r0,#0x10
000040  f8c40080          STR      r0,[r4,#0x80]
;;;3937   
;;;3938   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3939     /*Call registered error callback*/
;;;3940     huart->ErrorCallback(huart);
;;;3941   #else
;;;3942     /*Call legacy weak error callback*/
;;;3943     HAL_UART_ErrorCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3944   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3945   }
00004a  bd70              POP      {r4-r6,pc}
;;;3946   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;3821     */
;;;3822   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3823   {
000002  4601              MOV      r1,r0
;;;3824     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000004  6a88              LDR      r0,[r1,#0x28]
;;;3825   
;;;3826     /* DMA Normal mode */
;;;3827     if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d41b              BMI      |L48.70|
;;;3828     {
;;;3829       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  f8a0105a          STRH     r1,[r0,#0x5a]
;;;3830   
;;;3831       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3832       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  f4227280          BIC      r2,r2,#0x100
00001c  600a              STR      r2,[r1,#0]
;;;3833       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001e  6801              LDR      r1,[r0,#0]
000020  688a              LDR      r2,[r1,#8]
000022  f0220201          BIC      r2,r2,#1
000026  608a              STR      r2,[r1,#8]
;;;3834   
;;;3835       /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;3836          in the UART CR3 register */
;;;3837       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6801              LDR      r1,[r0,#0]
00002a  688a              LDR      r2,[r1,#8]
00002c  f0220240          BIC      r2,r2,#0x40
000030  608a              STR      r2,[r1,#8]
;;;3838   
;;;3839       /* At end of Rx process, restore huart->RxState to Ready */
;;;3840       huart->RxState = HAL_UART_STATE_READY;
000032  2120              MOVS     r1,#0x20
000034  67c1              STR      r1,[r0,#0x7c]
;;;3841   
;;;3842       /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
;;;3843       if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000036  6e01              LDR      r1,[r0,#0x60]
000038  2901              CMP      r1,#1
00003a  d104              BNE      |L48.70|
;;;3844       {
;;;3845         CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00003c  6801              LDR      r1,[r0,#0]
00003e  680a              LDR      r2,[r1,#0]
000040  f0220210          BIC      r2,r2,#0x10
000044  600a              STR      r2,[r1,#0]
                  |L48.70|
;;;3846       }
;;;3847     }
;;;3848   
;;;3849     /* Check current reception Mode :
;;;3850        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3851     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000046  6e01              LDR      r1,[r0,#0x60]
000048  2901              CMP      r1,#1
00004a  d002              BEQ      |L48.82|
;;;3852     {
;;;3853   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3854       /*Call registered Rx Event callback*/
;;;3855       huart->RxEventCallback(huart, huart->RxXferSize);
;;;3856   #else
;;;3857       /*Call legacy weak Rx Event callback*/
;;;3858       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
;;;3859   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3860     }
;;;3861     else
;;;3862     {
;;;3863       /* In other cases : use Rx Complete callback */
;;;3864   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3865       /*Call registered Rx complete callback*/
;;;3866       huart->RxCpltCallback(huart);
;;;3867   #else
;;;3868       /*Call legacy weak Rx complete callback*/
;;;3869       HAL_UART_RxCpltCallback(huart);
00004c  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;3870   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3871     }
;;;3872   }
000050  bd10              POP      {r4,pc}
                  |L48.82|
000052  f8b01058          LDRH     r1,[r0,#0x58]         ;3858
000056  f7fffffe          BL       HAL_UARTEx_RxEventCallback
00005a  bd10              POP      {r4,pc}
;;;3873   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;4032     */
;;;4033   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4034   {
;;;4035     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;4036   
;;;4037     huart->hdmarx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6f01              LDR      r1,[r0,#0x70]
000008  638a              STR      r2,[r1,#0x38]
;;;4038   
;;;4039     /* Check if an Abort process is still ongoing */
;;;4040     if (huart->hdmatx != NULL)
00000a  6ec1              LDR      r1,[r0,#0x6c]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L49.22|
;;;4041     {
;;;4042       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6b89              LDR      r1,[r1,#0x38]
000012  2900              CMP      r1,#0
000014  d113              BNE      |L49.62|
                  |L49.22|
;;;4043       {
;;;4044         return;
;;;4045       }
;;;4046     }
;;;4047   
;;;4048     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;4049     huart->TxXferCount = 0U;
000016  f8a02052          STRH     r2,[r0,#0x52]
;;;4050     huart->RxXferCount = 0U;
00001a  f8a0205a          STRH     r2,[r0,#0x5a]
;;;4051   
;;;4052     /* Reset errorCode */
;;;4053     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  f8c02080          STR      r2,[r0,#0x80]
;;;4054   
;;;4055     /* Clear the Error flags in the ICR register */
;;;4056     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000022  6803              LDR      r3,[r0,#0]
000024  210f              MOVS     r1,#0xf
000026  6219              STR      r1,[r3,#0x20]
;;;4057   
;;;4058     /* Discard the received data */
;;;4059     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000028  6801              LDR      r1,[r0,#0]
00002a  8b0b              LDRH     r3,[r1,#0x18]
00002c  f0430308          ORR      r3,r3,#8
000030  830b              STRH     r3,[r1,#0x18]
;;;4060   
;;;4061     /* Restore huart->gState and huart->RxState to Ready */
;;;4062     huart->gState  = HAL_UART_STATE_READY;
000032  2120              MOVS     r1,#0x20
000034  6781              STR      r1,[r0,#0x78]
;;;4063     huart->RxState = HAL_UART_STATE_READY;
000036  67c1              STR      r1,[r0,#0x7c]
;;;4064     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000038  6602              STR      r2,[r0,#0x60]
;;;4065   
;;;4066     /* Call user Abort complete callback */
;;;4067   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4068     /* Call registered Abort complete callback */
;;;4069     huart->AbortCpltCallback(huart);
;;;4070   #else
;;;4071     /* Call legacy weak Abort complete callback */
;;;4072     HAL_UART_AbortCpltCallback(huart);
00003a  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L49.62|
;;;4073   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;4074   }
00003e  bd10              POP      {r4,pc}
;;;4075   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;3878     */
;;;3879   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3880   {
;;;3881     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3882   
;;;3883     /* Check current reception Mode :
;;;3884        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3885     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000004  6e01              LDR      r1,[r0,#0x60]
000006  2901              CMP      r1,#1
000008  d002              BEQ      |L50.16|
;;;3886     {
;;;3887   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3888       /*Call registered Rx Event callback*/
;;;3889       huart->RxEventCallback(huart, huart->RxXferSize/2U);
;;;3890   #else
;;;3891       /*Call legacy weak Rx Event callback*/
;;;3892       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize/2U);
;;;3893   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3894     }
;;;3895     else
;;;3896     {
;;;3897       /* In other cases : use Rx Half Complete callback */
;;;3898   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3899       /*Call registered Rx Half complete callback*/
;;;3900       huart->RxHalfCpltCallback(huart);
;;;3901   #else
;;;3902       /*Call legacy weak Rx Half complete callback*/
;;;3903       HAL_UART_RxHalfCpltCallback(huart);
00000a  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;3904   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3905     }
;;;3906   }
00000e  bd10              POP      {r4,pc}
                  |L50.16|
000010  f8b01058          LDRH     r1,[r0,#0x58]         ;3892
000014  0849              LSRS     r1,r1,#1              ;3892
000016  f7fffffe          BL       HAL_UARTEx_RxEventCallback
00001a  bd10              POP      {r4,pc}
;;;3907   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;4119     */
;;;4120   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4121   {
;;;4122     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;4123   
;;;4124     huart->RxXferCount = 0U;
000004  2200              MOVS     r2,#0
000006  f8a0205a          STRH     r2,[r0,#0x5a]
;;;4125   
;;;4126     /* Clear the Error flags in the ICR register */
;;;4127     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00000a  6803              LDR      r3,[r0,#0]
00000c  210f              MOVS     r1,#0xf
00000e  6219              STR      r1,[r3,#0x20]
;;;4128   
;;;4129     /* Discard the received data */
;;;4130     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000010  6801              LDR      r1,[r0,#0]
000012  8b0b              LDRH     r3,[r1,#0x18]
000014  f0430308          ORR      r3,r3,#8
000018  830b              STRH     r3,[r1,#0x18]
;;;4131   
;;;4132     /* Restore huart->RxState to Ready */
;;;4133     huart->RxState = HAL_UART_STATE_READY;
00001a  2120              MOVS     r1,#0x20
00001c  67c1              STR      r1,[r0,#0x7c]
;;;4134     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00001e  6602              STR      r2,[r0,#0x60]
;;;4135   
;;;4136     /* Call user Abort complete callback */
;;;4137   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4138     /* Call registered Abort Receive Complete Callback */
;;;4139     huart->AbortReceiveCpltCallback(huart);
;;;4140   #else
;;;4141     /* Call legacy weak Abort Receive Complete Callback */
;;;4142     HAL_UART_AbortReceiveCpltCallback(huart);
000020  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;4143   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;4144   }
000024  bd10              POP      {r4,pc}
;;;4145   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;3769     */
;;;3770   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3771   {
000002  4601              MOV      r1,r0
;;;3772     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000004  6a88              LDR      r0,[r1,#0x28]
;;;3773   
;;;3774     /* DMA Normal mode */
;;;3775     if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40d              BMI      |L52.42|
;;;3776     {
;;;3777       huart->TxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  f8a01052          STRH     r1,[r0,#0x52]
;;;3778   
;;;3779       /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;3780          in the UART CR3 register */
;;;3781       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6801              LDR      r1,[r0,#0]
000016  688a              LDR      r2,[r1,#8]
000018  f0220280          BIC      r2,r2,#0x80
00001c  608a              STR      r2,[r1,#8]
;;;3782   
;;;3783       /* Enable the UART Transmit Complete Interrupt */
;;;3784       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001e  6800              LDR      r0,[r0,#0]
000020  6801              LDR      r1,[r0,#0]
000022  f0410140          ORR      r1,r1,#0x40
000026  6001              STR      r1,[r0,#0]
;;;3785     }
;;;3786     /* DMA Circular mode */
;;;3787     else
;;;3788     {
;;;3789   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3790       /*Call registered Tx complete callback*/
;;;3791       huart->TxCpltCallback(huart);
;;;3792   #else
;;;3793       /*Call legacy weak Tx complete callback*/
;;;3794       HAL_UART_TxCpltCallback(huart);
;;;3795   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3796     }
;;;3797   }
000028  bd10              POP      {r4,pc}
                  |L52.42|
00002a  f7fffffe          BL       HAL_UART_TxCpltCallback
00002e  bd10              POP      {r4,pc}
;;;3798   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;3975     */
;;;3976   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3977   {
;;;3978     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3979   
;;;3980     huart->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6ec1              LDR      r1,[r0,#0x6c]
000008  638a              STR      r2,[r1,#0x38]
;;;3981   
;;;3982     /* Check if an Abort process is still ongoing */
;;;3983     if (huart->hdmarx != NULL)
00000a  6f01              LDR      r1,[r0,#0x70]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L53.22|
;;;3984     {
;;;3985       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6b89              LDR      r1,[r1,#0x38]
000012  2900              CMP      r1,#0
000014  d10e              BNE      |L53.52|
                  |L53.22|
;;;3986       {
;;;3987         return;
;;;3988       }
;;;3989     }
;;;3990   
;;;3991     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3992     huart->TxXferCount = 0U;
000016  f8a02052          STRH     r2,[r0,#0x52]
;;;3993     huart->RxXferCount = 0U;
00001a  f8a0205a          STRH     r2,[r0,#0x5a]
;;;3994   
;;;3995     /* Reset errorCode */
;;;3996     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  f8c02080          STR      r2,[r0,#0x80]
;;;3997   
;;;3998     /* Clear the Error flags in the ICR register */
;;;3999     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000022  6803              LDR      r3,[r0,#0]
000024  210f              MOVS     r1,#0xf
000026  6219              STR      r1,[r3,#0x20]
;;;4000   
;;;4001   #if defined(USART_CR1_FIFOEN)
;;;4002     /* Flush the whole TX FIFO (if needed) */
;;;4003     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;4004     {
;;;4005       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;4006     }
;;;4007   #endif /* USART_CR1_FIFOEN */
;;;4008   
;;;4009     /* Restore huart->gState and huart->RxState to Ready */
;;;4010     huart->gState  = HAL_UART_STATE_READY;
000028  2120              MOVS     r1,#0x20
00002a  6781              STR      r1,[r0,#0x78]
;;;4011     huart->RxState = HAL_UART_STATE_READY;
00002c  67c1              STR      r1,[r0,#0x7c]
;;;4012     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00002e  6602              STR      r2,[r0,#0x60]
;;;4013   
;;;4014     /* Call user Abort complete callback */
;;;4015   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4016     /* Call registered Abort complete callback */
;;;4017     huart->AbortCpltCallback(huart);
;;;4018   #else
;;;4019     /* Call legacy weak Abort complete callback */
;;;4020     HAL_UART_AbortCpltCallback(huart);
000030  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L53.52|
;;;4021   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;4022   }
000034  bd10              POP      {r4,pc}
;;;4023   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;3803     */
;;;3804   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3805   {
;;;3806     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;3807   
;;;3808   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3809     /*Call registered Tx Half complete callback*/
;;;3810     huart->TxHalfCpltCallback(huart);
;;;3811   #else
;;;3812     /*Call legacy weak Tx Half complete callback*/
;;;3813     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;3814   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3815   }
000008  bd10              POP      {r4,pc}
;;;3816   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;4084     */
;;;4085   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4086   {
;;;4087     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
000002  6a80              LDR      r0,[r0,#0x28]
;;;4088   
;;;4089     huart->TxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a01052          STRH     r1,[r0,#0x52]
;;;4090   
;;;4091   #if defined(USART_CR1_FIFOEN)
;;;4092     /* Flush the whole TX FIFO (if needed) */
;;;4093     if (huart->FifoMode == UART_FIFOMODE_ENABLE)
;;;4094     {
;;;4095       __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
;;;4096     }
;;;4097   #endif /* USART_CR1_FIFOEN */
;;;4098   
;;;4099     /* Restore huart->gState to Ready */
;;;4100     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  6781              STR      r1,[r0,#0x78]
;;;4101   
;;;4102     /* Call user Abort complete callback */
;;;4103   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4104     /* Call registered Abort Transmit Complete Callback */
;;;4105     huart->AbortTransmitCpltCallback(huart);
;;;4106   #else
;;;4107     /* Call legacy weak Abort Transmit Complete Callback */
;;;4108     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;4109   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;4110   }
000012  bd10              POP      {r4,pc}
;;;4111   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;3738     */
;;;3739   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;3740   {
;;;3741     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3742   #if defined(USART_CR1_FIFOEN)
;;;3743     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;3744     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
;;;3745   #else
;;;3746     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  680a              LDR      r2,[r1,#0]
000004  f4227290          BIC      r2,r2,#0x120
000008  600a              STR      r2,[r1,#0]
;;;3747     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  688a              LDR      r2,[r1,#8]
00000e  f0220201          BIC      r2,r2,#1
000012  608a              STR      r2,[r1,#8]
;;;3748   #endif /* USART_CR1_FIFOEN */
;;;3749   
;;;3750     /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
;;;3751     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000014  6e01              LDR      r1,[r0,#0x60]
000016  2901              CMP      r1,#1
000018  d104              BNE      |L56.36|
;;;3752     {
;;;3753       CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00001a  6801              LDR      r1,[r0,#0]
00001c  680a              LDR      r2,[r1,#0]
00001e  f0220210          BIC      r2,r2,#0x10
000022  600a              STR      r2,[r1,#0]
                  |L56.36|
;;;3754     }
;;;3755   
;;;3756     /* At end of Rx process, restore huart->RxState to Ready */
;;;3757     huart->RxState = HAL_UART_STATE_READY;
000024  2120              MOVS     r1,#0x20
000026  67c1              STR      r1,[r0,#0x7c]
;;;3758     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000028  2100              MOVS     r1,#0
00002a  6601              STR      r1,[r0,#0x60]
;;;3759   
;;;3760     /* Reset RxIsr function pointer */
;;;3761     huart->RxISR = NULL;
00002c  6641              STR      r1,[r0,#0x64]
;;;3762   }
00002e  4770              BX       lr
;;;3763   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;4304     */
;;;4305   static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;4306   {
;;;4307     /* Disable the UART Transmit Complete Interrupt */
;;;4308     CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000002  6801              LDR      r1,[r0,#0]
000004  680a              LDR      r2,[r1,#0]
000006  f0220240          BIC      r2,r2,#0x40
00000a  600a              STR      r2,[r1,#0]
;;;4309   
;;;4310     /* Tx process is ended, restore huart->gState to Ready */
;;;4311     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  6781              STR      r1,[r0,#0x78]
;;;4312   
;;;4313     /* Cleat TxISR function pointer */
;;;4314     huart->TxISR = NULL;
000010  2100              MOVS     r1,#0
000012  6681              STR      r1,[r0,#0x68]
;;;4315   
;;;4316   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4317     /*Call registered Tx complete callback*/
;;;4318     huart->TxCpltCallback(huart);
;;;4319   #else
;;;4320     /*Call legacy weak Tx complete callback*/
;;;4321     HAL_UART_TxCpltCallback(huart);
000014  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;4322   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;4323   }
000018  bd10              POP      {r4,pc}
;;;4324   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;3717     */
;;;3718   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;3719   {
;;;3720   #if defined(USART_CR1_FIFOEN)
;;;3721     /* Disable TXEIE, TCIE, TXFT interrupts */
;;;3722     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
;;;3723     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
;;;3724   #else
;;;3725     /* Disable TXEIE and TCIE interrupts */
;;;3726     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  680a              LDR      r2,[r1,#0]
000004  f02202c0          BIC      r2,r2,#0xc0
000008  600a              STR      r2,[r1,#0]
;;;3727   #endif /* USART_CR1_FIFOEN */
;;;3728   
;;;3729     /* At end of Tx process, restore huart->gState to Ready */
;;;3730     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  6781              STR      r1,[r0,#0x78]
;;;3731   }
00000e  4770              BX       lr
;;;3732   
                          ENDP


                          AREA ||i.UART_RxISR_16BIT||, CODE, READONLY, ALIGN=1

                  UART_RxISR_16BIT PROC
;;;4403     */
;;;4404   static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;4405   {
000002  4604              MOV      r4,r0
;;;4406     uint16_t *tmp;
;;;4407     uint16_t uhMask = huart->Mask;
000004  f8b4105c          LDRH     r1,[r4,#0x5c]
;;;4408     uint16_t  uhdata;
;;;4409   
;;;4410     /* Check that a Rx process is ongoing */
;;;4411     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000008  6fe2              LDR      r2,[r4,#0x7c]
00000a  6820              LDR      r0,[r4,#0]
00000c  2a22              CMP      r2,#0x22
00000e  d004              BEQ      |L59.26|
;;;4412     {
;;;4413       uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
;;;4414       tmp = (uint16_t *) huart->pRxBuffPtr ;
;;;4415       *tmp = (uint16_t)(uhdata & uhMask);
;;;4416       huart->pRxBuffPtr += 2U;
;;;4417       huart->RxXferCount--;
;;;4418   
;;;4419       if (huart->RxXferCount == 0U)
;;;4420       {
;;;4421         /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
;;;4422   #if defined(USART_CR1_FIFOEN)
;;;4423         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;4424   #else
;;;4425         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;4426   #endif /* USART_CR1_FIFOEN */
;;;4427   
;;;4428         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;4429         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;4430   
;;;4431         /* Rx process is completed, restore huart->RxState to Ready */
;;;4432         huart->RxState = HAL_UART_STATE_READY;
;;;4433   
;;;4434         /* Clear RxISR function pointer */
;;;4435         huart->RxISR = NULL;
;;;4436   
;;;4437         /* Check current reception Mode :
;;;4438            If Reception till IDLE event has been selected : */
;;;4439         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;4440         {
;;;4441           /* Disable IDLE interrupt */
;;;4442           CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;4443   
;;;4444   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4445           /*Call registered Rx Event callback*/
;;;4446           huart->RxEventCallback(huart, huart->RxXferSize);
;;;4447   #else
;;;4448           /*Call legacy weak Rx Event callback*/
;;;4449           HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
;;;4450   #endif
;;;4451         }
;;;4452         else
;;;4453         {
;;;4454           /* Standard reception API called */
;;;4455   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4456           /*Call registered Rx complete callback*/
;;;4457           huart->RxCpltCallback(huart);
;;;4458   #else
;;;4459           /*Call legacy weak Rx complete callback*/
;;;4460           HAL_UART_RxCpltCallback(huart);
;;;4461   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;4462         }
;;;4463         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;4464       }
;;;4465     }
;;;4466     else
;;;4467     {
;;;4468       /* Clear RXNE interrupt flag */
;;;4469       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000010  8b01              LDRH     r1,[r0,#0x18]
000012  f0410108          ORR      r1,r1,#8
000016  8301              STRH     r1,[r0,#0x18]
                  |L59.24|
;;;4470     }
;;;4471   }
000018  bd70              POP      {r4-r6,pc}
                  |L59.26|
00001a  8c80              LDRH     r0,[r0,#0x24]         ;4413
00001c  f8542f54          LDR      r2,[r4,#0x54]!        ;4414
000020  4008              ANDS     r0,r0,r1              ;4415
000022  8010              STRH     r0,[r2,#0]            ;4415
000024  6820              LDR      r0,[r4,#0]            ;4416
000026  1c80              ADDS     r0,r0,#2              ;4416
000028  6020              STR      r0,[r4,#0]            ;4416
00002a  88e0              LDRH     r0,[r4,#6]            ;4417
00002c  1e40              SUBS     r0,r0,#1              ;4417
00002e  80e0              STRH     r0,[r4,#6]            ;4417
000030  88e0              LDRH     r0,[r4,#6]            ;4419
000032  3c54              SUBS     r4,r4,#0x54           ;4419
000034  2800              CMP      r0,#0                 ;4419
000036  d1ef              BNE      |L59.24|
000038  6820              LDR      r0,[r4,#0]            ;4425
00003a  6801              LDR      r1,[r0,#0]            ;4425
00003c  f4217190          BIC      r1,r1,#0x120          ;4425
000040  6001              STR      r1,[r0,#0]            ;4425
000042  6820              LDR      r0,[r4,#0]            ;4429
000044  6881              LDR      r1,[r0,#8]            ;4429
000046  f0210101          BIC      r1,r1,#1              ;4429
00004a  6081              STR      r1,[r0,#8]            ;4429
00004c  2020              MOVS     r0,#0x20              ;4432
00004e  67e0              STR      r0,[r4,#0x7c]         ;4432
000050  2500              MOVS     r5,#0                 ;4435
000052  6665              STR      r5,[r4,#0x64]         ;4435
000054  6e20              LDR      r0,[r4,#0x60]         ;4439
000056  2801              CMP      r0,#1                 ;4439
000058  d004              BEQ      |L59.100|
00005a  4620              MOV      r0,r4                 ;4460
00005c  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L59.96|
000060  6625              STR      r5,[r4,#0x60]         ;4463
000062  bd70              POP      {r4-r6,pc}
                  |L59.100|
000064  6820              LDR      r0,[r4,#0]            ;4442
000066  6801              LDR      r1,[r0,#0]            ;4442
000068  f0210110          BIC      r1,r1,#0x10           ;4442
00006c  6001              STR      r1,[r0,#0]            ;4442
00006e  f8b41058          LDRH     r1,[r4,#0x58]         ;4449
000072  4620              MOV      r0,r4                 ;4449
000074  f7fffffe          BL       HAL_UARTEx_RxEventCallback
000078  e7f2              B        |L59.96|
;;;4472   
                          ENDP


                          AREA ||i.UART_RxISR_8BIT||, CODE, READONLY, ALIGN=1

                  UART_RxISR_8BIT PROC
;;;4329     */
;;;4330   static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;4331   {
000002  4604              MOV      r4,r0
;;;4332     uint16_t uhMask = huart->Mask;
000004  f8b4105c          LDRH     r1,[r4,#0x5c]
;;;4333     uint16_t  uhdata;
;;;4334   
;;;4335     /* Check that a Rx process is ongoing */
;;;4336     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000008  6fe2              LDR      r2,[r4,#0x7c]
00000a  6820              LDR      r0,[r4,#0]
00000c  2a22              CMP      r2,#0x22
00000e  d004              BEQ      |L60.26|
;;;4337     {
;;;4338       uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
;;;4339       *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
;;;4340       huart->pRxBuffPtr++;
;;;4341       huart->RxXferCount--;
;;;4342   
;;;4343       if (huart->RxXferCount == 0U)
;;;4344       {
;;;4345         /* Disable the UART Parity Error Interrupt and RXNE interrupts */
;;;4346   #if defined(USART_CR1_FIFOEN)
;;;4347         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
;;;4348   #else
;;;4349         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;4350   #endif /* USART_CR1_FIFOEN */
;;;4351   
;;;4352         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;4353         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;4354   
;;;4355         /* Rx process is completed, restore huart->RxState to Ready */
;;;4356         huart->RxState = HAL_UART_STATE_READY;
;;;4357   
;;;4358         /* Clear RxISR function pointer */
;;;4359         huart->RxISR = NULL;
;;;4360   
;;;4361         /* Check current reception Mode :
;;;4362            If Reception till IDLE event has been selected : */
;;;4363         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;4364         {
;;;4365           /* Disable IDLE interrupt */
;;;4366           CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;4367   
;;;4368   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4369           /*Call registered Rx Event callback*/
;;;4370           huart->RxEventCallback(huart, huart->RxXferSize);
;;;4371   #else
;;;4372           /*Call legacy weak Rx Event callback*/
;;;4373           HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
;;;4374   #endif
;;;4375         }
;;;4376         else
;;;4377         {
;;;4378           /* Standard reception API called */
;;;4379   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;4380           /*Call registered Rx complete callback*/
;;;4381           huart->RxCpltCallback(huart);
;;;4382   #else
;;;4383           /*Call legacy weak Rx complete callback*/
;;;4384           HAL_UART_RxCpltCallback(huart);
;;;4385   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;4386         }
;;;4387         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;4388       }
;;;4389     }
;;;4390     else
;;;4391     {
;;;4392       /* Clear RXNE interrupt flag */
;;;4393       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
000010  8b01              LDRH     r1,[r0,#0x18]
000012  f0410108          ORR      r1,r1,#8
000016  8301              STRH     r1,[r0,#0x18]
                  |L60.24|
;;;4394     }
;;;4395   }
000018  bd70              POP      {r4-r6,pc}
                  |L60.26|
00001a  8c80              LDRH     r0,[r0,#0x24]         ;4338
00001c  4008              ANDS     r0,r0,r1              ;4339
00001e  f8541f54          LDR      r1,[r4,#0x54]!        ;4339
000022  7008              STRB     r0,[r1,#0]            ;4339
000024  6820              LDR      r0,[r4,#0]            ;4340
000026  1c40              ADDS     r0,r0,#1              ;4340
000028  6020              STR      r0,[r4,#0]            ;4340
00002a  88e0              LDRH     r0,[r4,#6]            ;4341
00002c  1e40              SUBS     r0,r0,#1              ;4341
00002e  80e0              STRH     r0,[r4,#6]            ;4341
000030  88e0              LDRH     r0,[r4,#6]            ;4343
000032  3c54              SUBS     r4,r4,#0x54           ;4343
000034  2800              CMP      r0,#0                 ;4343
000036  d1ef              BNE      |L60.24|
000038  6820              LDR      r0,[r4,#0]            ;4349
00003a  6801              LDR      r1,[r0,#0]            ;4349
00003c  f4217190          BIC      r1,r1,#0x120          ;4349
000040  6001              STR      r1,[r0,#0]            ;4349
000042  6820              LDR      r0,[r4,#0]            ;4353
000044  6881              LDR      r1,[r0,#8]            ;4353
000046  f0210101          BIC      r1,r1,#1              ;4353
00004a  6081              STR      r1,[r0,#8]            ;4353
00004c  2020              MOVS     r0,#0x20              ;4356
00004e  67e0              STR      r0,[r4,#0x7c]         ;4356
000050  2500              MOVS     r5,#0                 ;4359
000052  6665              STR      r5,[r4,#0x64]         ;4359
000054  6e20              LDR      r0,[r4,#0x60]         ;4363
000056  2801              CMP      r0,#1                 ;4363
000058  d004              BEQ      |L60.100|
00005a  4620              MOV      r0,r4                 ;4384
00005c  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L60.96|
000060  6625              STR      r5,[r4,#0x60]         ;4387
000062  bd70              POP      {r4-r6,pc}
                  |L60.100|
000064  6820              LDR      r0,[r4,#0]            ;4366
000066  6801              LDR      r1,[r0,#0]            ;4366
000068  f0210110          BIC      r1,r1,#0x10           ;4366
00006c  6001              STR      r1,[r0,#0]            ;4366
00006e  f8b41058          LDRH     r1,[r4,#0x58]         ;4373
000072  4620              MOV      r0,r4                 ;4373
000074  f7fffffe          BL       HAL_UARTEx_RxEventCallback
000078  e7f2              B        |L60.96|
;;;4396   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3127     */
;;;3128   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3129   {
000004  4604              MOV      r4,r0
;;;3130     uint32_t tmpreg;
;;;3131     uint16_t brrtemp;
;;;3132     UART_ClockSourceTypeDef clocksource;
;;;3133     uint32_t usartdiv;
;;;3134     HAL_StatusTypeDef ret               = HAL_OK;
000006  2500              MOVS     r5,#0
;;;3135   #if defined(USART_PRESC_PRESCALER)
;;;3136     uint32_t lpuart_ker_ck_pres;
;;;3137   #endif /* USART_PRESC_PRESCALER */
;;;3138     uint32_t pclk;
;;;3139   
;;;3140     /* Check the parameters */
;;;3141     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3142     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;3143     if (UART_INSTANCE_LOWPOWER(huart))
000008  4ba3              LDR      r3,|L61.664|
00000a  6820              LDR      r0,[r4,#0]
;;;3144     {
;;;3145       assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
;;;3146     }
;;;3147     else
;;;3148     {
;;;3149       assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3150       assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;3151     }
;;;3152   
;;;3153     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3154     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3155     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;3156     assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;3157   #if defined(USART_PRESC_PRESCALER)
;;;3158     assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
;;;3159   #endif /* USART_PRESC_PRESCALER */
;;;3160   
;;;3161     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3162     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;3163     *  the UART Word Length, Parity, Mode and oversampling:
;;;3164     *  set the M bits according to huart->Init.WordLength value
;;;3165     *  set PCE and PS bits according to huart->Init.Parity value
;;;3166     *  set TE and RE bits according to huart->Init.Mode value
;;;3167     *  set OVER8 bit according to huart->Init.OverSampling value */
;;;3168     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
00000c  6922              LDR      r2,[r4,#0x10]
00000e  68a1              LDR      r1,[r4,#8]
000010  69e6              LDR      r6,[r4,#0x1c]
000012  4311              ORRS     r1,r1,r2
000014  6962              LDR      r2,[r4,#0x14]
000016  4332              ORRS     r2,r2,r6
000018  4311              ORRS     r1,r1,r2
;;;3169     MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
00001a  6802              LDR      r2,[r0,#0]
00001c  4e9f              LDR      r6,|L61.668|
00001e  4032              ANDS     r2,r2,r6
000020  430a              ORRS     r2,r2,r1
000022  6002              STR      r2,[r0,#0]
;;;3170   
;;;3171     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3172     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;3173     * to huart->Init.StopBits value */
;;;3174     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000024  6820              LDR      r0,[r4,#0]
000026  6841              LDR      r1,[r0,#4]
000028  68e2              LDR      r2,[r4,#0xc]
00002a  f4215140          BIC      r1,r1,#0x3000
00002e  4311              ORRS     r1,r1,r2
000030  6041              STR      r1,[r0,#4]
;;;3175   
;;;3176     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3177     /* Configure
;;;3178     * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;3179     *   to huart->Init.HwFlowCtl value
;;;3180     * - one-bit sampling method versus three samples' majority rule according
;;;3181     *   to huart->Init.OneBitSampling (not applicable to LPUART) */
;;;3182     tmpreg = (uint32_t)huart->Init.HwFlowCtl;
000032  69a0              LDR      r0,[r4,#0x18]
;;;3183   
;;;3184     if (!(UART_INSTANCE_LOWPOWER(huart)))
000034  6821              LDR      r1,[r4,#0]
000036  4299              CMP      r1,r3
000038  d001              BEQ      |L61.62|
;;;3185     {
;;;3186       tmpreg |= huart->Init.OneBitSampling;
00003a  6a22              LDR      r2,[r4,#0x20]
00003c  4310              ORRS     r0,r0,r2
                  |L61.62|
;;;3187     }
;;;3188     MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
00003e  688a              LDR      r2,[r1,#8]
000040  f4226230          BIC      r2,r2,#0xb00
000044  4302              ORRS     r2,r2,r0
000046  608a              STR      r2,[r1,#8]
;;;3189   
;;;3190   #if defined(USART_PRESC_PRESCALER)
;;;3191     /*-------------------------- USART PRESC Configuration -----------------------*/
;;;3192     /* Configure
;;;3193     * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
;;;3194     MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
;;;3195   #endif /* USART_PRESC_PRESCALER */
;;;3196   
;;;3197     /*-------------------------- USART BRR Configuration -----------------------*/
;;;3198     UART_GETCLOCKSOURCE(huart, clocksource);
000048  4995              LDR      r1,|L61.672|
00004a  6822              LDR      r2,[r4,#0]
00004c  4895              LDR      r0,|L61.676|
00004e  428a              CMP      r2,r1
000050  d114              BNE      |L61.124|
000052  f8d00088          LDR      r0,[r0,#0x88]
000056  f0100003          ANDS     r0,r0,#3
00005a  d007              BEQ      |L61.108|
00005c  2801              CMP      r0,#1
00005e  d009              BEQ      |L61.116|
000060  2802              CMP      r0,#2
000062  d005              BEQ      |L61.112|
000064  2803              CMP      r0,#3
000066  d007              BEQ      |L61.120|
000068  2110              MOVS     r1,#0x10
00006a  e085              B        |L61.376|
                  |L61.108|
00006c  2101              MOVS     r1,#1
00006e  e083              B        |L61.376|
                  |L61.112|
000070  2102              MOVS     r1,#2
000072  e081              B        |L61.376|
                  |L61.116|
000074  2104              MOVS     r1,#4
000076  e07f              B        |L61.376|
                  |L61.120|
000078  2108              MOVS     r1,#8
00007a  e07d              B        |L61.376|
                  |L61.124|
00007c  498a              LDR      r1,|L61.680|
00007e  428a              CMP      r2,r1
000080  d114              BNE      |L61.172|
000082  f8d00088          LDR      r0,[r0,#0x88]
000086  f010000c          ANDS     r0,r0,#0xc
00008a  d007              BEQ      |L61.156|
00008c  2804              CMP      r0,#4
00008e  d009              BEQ      |L61.164|
000090  2808              CMP      r0,#8
000092  d005              BEQ      |L61.160|
000094  280c              CMP      r0,#0xc
000096  d007              BEQ      |L61.168|
000098  2110              MOVS     r1,#0x10
00009a  e06d              B        |L61.376|
                  |L61.156|
00009c  2100              MOVS     r1,#0
00009e  e06b              B        |L61.376|
                  |L61.160|
0000a0  2102              MOVS     r1,#2
0000a2  e069              B        |L61.376|
                  |L61.164|
0000a4  2104              MOVS     r1,#4
0000a6  e067              B        |L61.376|
                  |L61.168|
0000a8  2108              MOVS     r1,#8
0000aa  e065              B        |L61.376|
                  |L61.172|
0000ac  497f              LDR      r1,|L61.684|
0000ae  428a              CMP      r2,r1
0000b0  d114              BNE      |L61.220|
0000b2  f8d00088          LDR      r0,[r0,#0x88]
0000b6  f0100030          ANDS     r0,r0,#0x30
0000ba  d007              BEQ      |L61.204|
0000bc  2810              CMP      r0,#0x10
0000be  d009              BEQ      |L61.212|
0000c0  2820              CMP      r0,#0x20
0000c2  d005              BEQ      |L61.208|
0000c4  2830              CMP      r0,#0x30
0000c6  d007              BEQ      |L61.216|
0000c8  2110              MOVS     r1,#0x10
0000ca  e055              B        |L61.376|
                  |L61.204|
0000cc  2100              MOVS     r1,#0
0000ce  e053              B        |L61.376|
                  |L61.208|
0000d0  2102              MOVS     r1,#2
0000d2  e051              B        |L61.376|
                  |L61.212|
0000d4  2104              MOVS     r1,#4
0000d6  e04f              B        |L61.376|
                  |L61.216|
0000d8  2108              MOVS     r1,#8
0000da  e04d              B        |L61.376|
                  |L61.220|
0000dc  4974              LDR      r1,|L61.688|
0000de  428a              CMP      r2,r1
0000e0  d114              BNE      |L61.268|
0000e2  f8d00088          LDR      r0,[r0,#0x88]
0000e6  f01000c0          ANDS     r0,r0,#0xc0
0000ea  d007              BEQ      |L61.252|
0000ec  2840              CMP      r0,#0x40
0000ee  d009              BEQ      |L61.260|
0000f0  2880              CMP      r0,#0x80
0000f2  d005              BEQ      |L61.256|
0000f4  28c0              CMP      r0,#0xc0
0000f6  d007              BEQ      |L61.264|
0000f8  2110              MOVS     r1,#0x10
0000fa  e03d              B        |L61.376|
                  |L61.252|
0000fc  2100              MOVS     r1,#0
0000fe  e03b              B        |L61.376|
                  |L61.256|
000100  2102              MOVS     r1,#2
000102  e039              B        |L61.376|
                  |L61.260|
000104  2104              MOVS     r1,#4
000106  e037              B        |L61.376|
                  |L61.264|
000108  2108              MOVS     r1,#8
00010a  e035              B        |L61.376|
                  |L61.268|
00010c  4969              LDR      r1,|L61.692|
00010e  428a              CMP      r2,r1
000110  d117              BNE      |L61.322|
000112  f8d00088          LDR      r0,[r0,#0x88]
000116  f4107040          ANDS     r0,r0,#0x300
00011a  d00a              BEQ      |L61.306|
00011c  f5b07f80          CMP      r0,#0x100
000120  d00b              BEQ      |L61.314|
000122  f5b07f00          CMP      r0,#0x200
000126  d006              BEQ      |L61.310|
000128  f5b07f40          CMP      r0,#0x300
00012c  d007              BEQ      |L61.318|
00012e  2110              MOVS     r1,#0x10
000130  e022              B        |L61.376|
                  |L61.306|
000132  2100              MOVS     r1,#0
000134  e020              B        |L61.376|
                  |L61.310|
000136  2102              MOVS     r1,#2
000138  e01e              B        |L61.376|
                  |L61.314|
00013a  2104              MOVS     r1,#4
00013c  e01c              B        |L61.376|
                  |L61.318|
00013e  2108              MOVS     r1,#8
000140  e01a              B        |L61.376|
                  |L61.322|
000142  429a              CMP      r2,r3
000144  d117              BNE      |L61.374|
000146  f8d00088          LDR      r0,[r0,#0x88]
00014a  f4106040          ANDS     r0,r0,#0xc00
00014e  d00a              BEQ      |L61.358|
000150  f5b06f80          CMP      r0,#0x400
000154  d00b              BEQ      |L61.366|
000156  f5b06f00          CMP      r0,#0x800
00015a  d006              BEQ      |L61.362|
00015c  f5b06f40          CMP      r0,#0xc00
000160  d007              BEQ      |L61.370|
000162  2110              MOVS     r1,#0x10
000164  e008              B        |L61.376|
                  |L61.358|
000166  2100              MOVS     r1,#0
000168  e006              B        |L61.376|
                  |L61.362|
00016a  2102              MOVS     r1,#2
00016c  e004              B        |L61.376|
                  |L61.366|
00016e  2104              MOVS     r1,#4
000170  e002              B        |L61.376|
                  |L61.370|
000172  2108              MOVS     r1,#8
000174  e000              B        |L61.376|
                  |L61.374|
000176  2110              MOVS     r1,#0x10
                  |L61.376|
;;;3199   
;;;3200     /* Check LPUART instance */
;;;3201     if (UART_INSTANCE_LOWPOWER(huart))
;;;3202     {
;;;3203       /* Retrieve frequency clock */
;;;3204       switch (clocksource)
;;;3205       {
;;;3206         case UART_CLOCKSOURCE_PCLK1:
;;;3207           pclk = HAL_RCC_GetPCLK1Freq();
;;;3208           break;
;;;3209         case UART_CLOCKSOURCE_HSI:
;;;3210           pclk = (uint32_t) HSI_VALUE;
000178  484f              LDR      r0,|L61.696|
00017a  2600              MOVS     r6,#0
;;;3211           break;
;;;3212         case UART_CLOCKSOURCE_SYSCLK:
;;;3213           pclk = HAL_RCC_GetSysClockFreq();
;;;3214           break;
;;;3215         case UART_CLOCKSOURCE_LSE:
;;;3216           pclk = (uint32_t) LSE_VALUE;
00017c  f44f4c00          MOV      r12,#0x8000
000180  429a              CMP      r2,r3                 ;3201
000182  d12d              BNE      |L61.480|
000184  b191              CBZ      r1,|L61.428|
000186  2902              CMP      r1,#2                 ;3204
000188  d005              BEQ      |L61.406|
00018a  2904              CMP      r1,#4                 ;3204
00018c  d011              BEQ      |L61.434|
00018e  2908              CMP      r1,#8                 ;3204
000190  d012              BEQ      |L61.440|
;;;3217           break;
;;;3218         default:
;;;3219           pclk = 0U;
000192  2000              MOVS     r0,#0
;;;3220           ret = HAL_ERROR;
000194  2501              MOVS     r5,#1
                  |L61.406|
;;;3221           break;
;;;3222       }
;;;3223   
;;;3224       /* If proper clock source reported */
;;;3225       if (pclk != 0U)
000196  b300              CBZ      r0,|L61.474|
;;;3226       {
;;;3227   #if defined(USART_PRESC_PRESCALER)
;;;3228         /* Compute clock after Prescaler */
;;;3229         lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
;;;3230   
;;;3231         /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
;;;3232         if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
;;;3233             (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
;;;3234         {
;;;3235           ret = HAL_ERROR;
;;;3236         }
;;;3237         else
;;;3238         {
;;;3239           /* Check computed UsartDiv value is in allocated range
;;;3240              (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
;;;3241           usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3242           if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
;;;3243           {
;;;3244             huart->Instance->BRR = usartdiv;
;;;3245           }
;;;3246           else
;;;3247           {
;;;3248             ret = HAL_ERROR;
;;;3249           }
;;;3250         } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
;;;3251                   (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
;;;3252   #else
;;;3253         /* No Prescaler applicable */
;;;3254         /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
;;;3255         if ((pclk < (3U * huart->Init.BaudRate)) ||
000198  6862              LDR      r2,[r4,#4]
00019a  eb020142          ADD      r1,r2,r2,LSL #1
00019e  4281              CMP      r1,r0
0001a0  d802              BHI      |L61.424|
;;;3256             (pclk > (4096U * huart->Init.BaudRate)))
0001a2  ebb03f02          CMP      r0,r2,LSL #12
0001a6  d909              BLS      |L61.444|
                  |L61.424|
;;;3257         {
;;;3258           ret = HAL_ERROR;
0001a8  2501              MOVS     r5,#1
0001aa  e070              B        |L61.654|
                  |L61.428|
0001ac  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001b0  e7f1              B        |L61.406|
                  |L61.434|
0001b2  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0001b6  e7ee              B        |L61.406|
                  |L61.440|
0001b8  4660              MOV      r0,r12                ;3216
0001ba  e7ec              B        |L61.406|
                  |L61.444|
;;;3259         }
;;;3260         else
;;;3261         {
;;;3262           usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate));
0001bc  0e01              LSRS     r1,r0,#24
0001be  0203              LSLS     r3,r0,#8
0001c0  0850              LSRS     r0,r2,#1
0001c2  1818              ADDS     r0,r3,r0
0001c4  4171              ADCS     r1,r1,r6
0001c6  2300              MOVS     r3,#0
0001c8  f7fffffe          BL       __aeabi_uldivmod
;;;3263           if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
0001cc  4a3b              LDR      r2,|L61.700|
0001ce  f5a07140          SUB      r1,r0,#0x300
0001d2  4291              CMP      r1,r2
0001d4  d802              BHI      |L61.476|
;;;3264           {
;;;3265             huart->Instance->BRR = usartdiv;
0001d6  6821              LDR      r1,[r4,#0]
0001d8  60c8              STR      r0,[r1,#0xc]
                  |L61.474|
0001da  e058              B        |L61.654|
                  |L61.476|
;;;3266           }
;;;3267           else
;;;3268           {
;;;3269             ret = HAL_ERROR;
0001dc  2501              MOVS     r5,#1
0001de  e056              B        |L61.654|
                  |L61.480|
;;;3270           }
;;;3271         } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
;;;3272   #endif /* USART_PRESC_PRESCALER */
;;;3273       } /* if (pclk != 0) */
;;;3274     }
;;;3275     /* Check UART Over Sampling to set Baud Rate Register */
;;;3276     else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
0001e0  69e2              LDR      r2,[r4,#0x1c]
;;;3277     {
;;;3278       switch (clocksource)
;;;3279       {
;;;3280         case UART_CLOCKSOURCE_PCLK1:
;;;3281           pclk = HAL_RCC_GetPCLK1Freq();
;;;3282           break;
;;;3283         case UART_CLOCKSOURCE_PCLK2:
;;;3284           pclk = HAL_RCC_GetPCLK2Freq();
;;;3285           break;
;;;3286         case UART_CLOCKSOURCE_HSI:
;;;3287           pclk = (uint32_t) HSI_VALUE;
;;;3288           break;
;;;3289         case UART_CLOCKSOURCE_SYSCLK:
;;;3290           pclk = HAL_RCC_GetSysClockFreq();
;;;3291           break;
;;;3292         case UART_CLOCKSOURCE_LSE:
;;;3293           pclk = (uint32_t) LSE_VALUE;
;;;3294           break;
;;;3295         default:
;;;3296           pclk = 0U;
;;;3297           ret = HAL_ERROR;
;;;3298           break;
;;;3299       }
;;;3300   
;;;3301       /* USARTDIV must be greater than or equal to 0d16 */
;;;3302       if (pclk != 0U)
;;;3303       {
;;;3304   #if defined(USART_PRESC_PRESCALER)
;;;3305         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3306   #else
;;;3307         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
;;;3308   #endif /* USART_PRESC_PRESCALER */
;;;3309         if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
0001e2  f64f77ef          MOV      r7,#0xffef
0001e6  4562              CMP      r2,r12                ;3276
0001e8  d12c              BNE      |L61.580|
0001ea  2909              CMP      r1,#9                 ;3278
0001ec  d211              BCS      |L61.530|
0001ee  e8dff001          TBB      [pc,r1]               ;3278
0001f2  0508              DCB      0x05,0x08
0001f4  12100b10          DCB      0x12,0x10,0x0b,0x10
0001f8  10100e00          DCB      0x10,0x10,0x0e,0x00
0001fc  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000200  e009              B        |L61.534|
000202  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000206  e006              B        |L61.534|
000208  f7fffffe          BL       HAL_RCC_GetSysClockFreq
00020c  e003              B        |L61.534|
00020e  4660              MOV      r0,r12                ;3293
000210  e001              B        |L61.534|
                  |L61.530|
000212  2000              MOVS     r0,#0                 ;3296
000214  2501              MOVS     r5,#1                 ;3297
                  |L61.534|
000216  b3c0              CBZ      r0,|L61.650|
000218  0041              LSLS     r1,r0,#1              ;3307
00021a  6860              LDR      r0,[r4,#4]            ;3307
00021c  eb010150          ADD      r1,r1,r0,LSR #1       ;3307
000220  fbb1f0f0          UDIV     r0,r1,r0              ;3307
000224  b280              UXTH     r0,r0                 ;3307
000226  f1a00110          SUB      r1,r0,#0x10
00022a  42b9              CMP      r1,r7
00022c  d808              BHI      |L61.576|
;;;3310         {
;;;3311           brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
00022e  f64f71f0          MOV      r1,#0xfff0
000232  4001              ANDS     r1,r1,r0
;;;3312           brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
000234  f3c00042          UBFX     r0,r0,#1,#3
000238  4301              ORRS     r1,r1,r0
;;;3313           huart->Instance->BRR = brrtemp;
00023a  6820              LDR      r0,[r4,#0]
00023c  60c1              STR      r1,[r0,#0xc]
00023e  e026              B        |L61.654|
                  |L61.576|
;;;3314         }
;;;3315         else
;;;3316         {
;;;3317           ret = HAL_ERROR;
000240  2501              MOVS     r5,#1
000242  e024              B        |L61.654|
                  |L61.580|
;;;3318         }
;;;3319       }
;;;3320     }
;;;3321     else
;;;3322     {
;;;3323       switch (clocksource)
000244  2909              CMP      r1,#9
000246  d211              BCS      |L61.620|
000248  e8dff001          TBB      [pc,r1]
00024c  05081210          DCB      0x05,0x08,0x12,0x10
000250  0b101010          DCB      0x0b,0x10,0x10,0x10
000254  0e00              DCB      0x0e,0x00
;;;3324       {
;;;3325         case UART_CLOCKSOURCE_PCLK1:
;;;3326           pclk = HAL_RCC_GetPCLK1Freq();
000256  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
;;;3327           break;
00025a  e009              B        |L61.624|
;;;3328         case UART_CLOCKSOURCE_PCLK2:
;;;3329           pclk = HAL_RCC_GetPCLK2Freq();
00025c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
;;;3330           break;
000260  e006              B        |L61.624|
;;;3331         case UART_CLOCKSOURCE_HSI:
;;;3332           pclk = (uint32_t) HSI_VALUE;
;;;3333           break;
;;;3334         case UART_CLOCKSOURCE_SYSCLK:
;;;3335           pclk = HAL_RCC_GetSysClockFreq();
000262  f7fffffe          BL       HAL_RCC_GetSysClockFreq
;;;3336           break;
000266  e003              B        |L61.624|
;;;3337         case UART_CLOCKSOURCE_LSE:
;;;3338           pclk = (uint32_t) LSE_VALUE;
000268  4660              MOV      r0,r12
;;;3339           break;
00026a  e001              B        |L61.624|
                  |L61.620|
;;;3340         default:
;;;3341           pclk = 0U;
00026c  2000              MOVS     r0,#0
;;;3342           ret = HAL_ERROR;
00026e  2501              MOVS     r5,#1
                  |L61.624|
;;;3343           break;
;;;3344       }
;;;3345   
;;;3346       if (pclk != 0U)
000270  b158              CBZ      r0,|L61.650|
;;;3347       {
;;;3348         /* USARTDIV must be greater than or equal to 0d16 */
;;;3349   #if defined(USART_PRESC_PRESCALER)
;;;3350         usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
;;;3351   #else
;;;3352         usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
000272  6861              LDR      r1,[r4,#4]
000274  eb000051          ADD      r0,r0,r1,LSR #1
000278  fbb0f0f1          UDIV     r0,r0,r1
00027c  b280              UXTH     r0,r0
;;;3353   #endif /* USART_PRESC_PRESCALER */
;;;3354         if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
00027e  f1a00110          SUB      r1,r0,#0x10
000282  42b9              CMP      r1,r7
000284  d802              BHI      |L61.652|
;;;3355         {
;;;3356           huart->Instance->BRR = usartdiv;
000286  6821              LDR      r1,[r4,#0]
000288  60c8              STR      r0,[r1,#0xc]
                  |L61.650|
00028a  e000              B        |L61.654|
                  |L61.652|
;;;3357         }
;;;3358         else
;;;3359         {
;;;3360           ret = HAL_ERROR;
00028c  2501              MOVS     r5,#1
                  |L61.654|
;;;3361         }
;;;3362       }
;;;3363     }
;;;3364   
;;;3365   #if defined(USART_CR1_FIFOEN)
;;;3366     /* Initialize the number of data to process during RX/TX ISR execution */
;;;3367     huart->NbTxDataToProcess = 1;
;;;3368     huart->NbRxDataToProcess = 1;
;;;3369   #endif /* USART_CR1_FIFOEN */
;;;3370   
;;;3371     /* Clear ISR function pointers */
;;;3372     huart->RxISR = NULL;
00028e  6666              STR      r6,[r4,#0x64]
;;;3373     huart->TxISR = NULL;
000290  66a6              STR      r6,[r4,#0x68]
;;;3374   
;;;3375     return ret;
000292  4628              MOV      r0,r5
;;;3376   }
000294  e8bd81f0          POP      {r4-r8,pc}
;;;3377   
                          ENDP

                  |L61.664|
                          DCD      0x40008000
                  |L61.668|
                          DCD      0xefff69f3
                  |L61.672|
                          DCD      0x40013800
                  |L61.676|
                          DCD      0x40021000
                  |L61.680|
                          DCD      0x40004400
                  |L61.684|
                          DCD      0x40004800
                  |L61.688|
                          DCD      0x40004c00
                  |L61.692|
                          DCD      0x40005000
                  |L61.696|
                          DCD      0x00f42400
                  |L61.700|
                          DCD      0x000ffcff

                          AREA ||i.UART_Start_Receive_DMA||, CODE, READONLY, ALIGN=2

                  UART_Start_Receive_DMA PROC
;;;3660     */
;;;3661   HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;3662   {
000002  4604              MOV      r4,r0
;;;3663     huart->pRxBuffPtr = pData;
000004  6561              STR      r1,[r4,#0x54]
;;;3664     huart->RxXferSize = Size;
000006  f8a42058          STRH     r2,[r4,#0x58]
;;;3665   
;;;3666     huart->ErrorCode = HAL_UART_ERROR_NONE;
00000a  2500              MOVS     r5,#0
00000c  f8c45080          STR      r5,[r4,#0x80]
;;;3667     huart->RxState = HAL_UART_STATE_BUSY_RX;
000010  2022              MOVS     r0,#0x22
000012  67e0              STR      r0,[r4,#0x7c]
;;;3668   
;;;3669     if (huart->hdmarx != NULL)
000014  6f20              LDR      r0,[r4,#0x70]
000016  2800              CMP      r0,#0
000018  d01a              BEQ      |L62.80|
;;;3670     {
;;;3671       /* Set the UART DMA transfer complete callback */
;;;3672       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
00001a  4917              LDR      r1,|L62.120|
00001c  62c1              STR      r1,[r0,#0x2c]
;;;3673   
;;;3674       /* Set the UART DMA Half transfer complete callback */
;;;3675       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
00001e  6f21              LDR      r1,[r4,#0x70]
000020  4816              LDR      r0,|L62.124|
000022  6308              STR      r0,[r1,#0x30]
;;;3676   
;;;3677       /* Set the DMA error callback */
;;;3678       huart->hdmarx->XferErrorCallback = UART_DMAError;
000024  6f21              LDR      r1,[r4,#0x70]
000026  4816              LDR      r0,|L62.128|
000028  6348              STR      r0,[r1,#0x34]
;;;3679   
;;;3680       /* Set the DMA abort callback */
;;;3681       huart->hdmarx->XferAbortCallback = NULL;
00002a  6f20              LDR      r0,[r4,#0x70]
00002c  6385              STR      r5,[r0,#0x38]
;;;3682   
;;;3683       /* Enable the DMA channel */
;;;3684       if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
00002e  6821              LDR      r1,[r4,#0]
000030  6d66              LDR      r6,[r4,#0x54]
000032  4613              MOV      r3,r2
000034  3124              ADDS     r1,r1,#0x24
000036  4632              MOV      r2,r6
000038  6f20              LDR      r0,[r4,#0x70]
00003a  f7fffffe          BL       HAL_DMA_Start_IT
00003e  b138              CBZ      r0,|L62.80|
;;;3685       {
;;;3686         /* Set error code to DMA */
;;;3687         huart->ErrorCode = HAL_UART_ERROR_DMA;
000040  2010              MOVS     r0,#0x10
000042  3474              ADDS     r4,r4,#0x74
000044  60e0              STR      r0,[r4,#0xc]
;;;3688   
;;;3689         __HAL_UNLOCK(huart);
000046  7025              STRB     r5,[r4,#0]
;;;3690   
;;;3691         /* Restore huart->gState to ready */
;;;3692         huart->gState = HAL_UART_STATE_READY;
000048  2020              MOVS     r0,#0x20
00004a  6060              STR      r0,[r4,#4]
;;;3693   
;;;3694         return HAL_ERROR;
00004c  2001              MOVS     r0,#1
;;;3695       }
;;;3696     }
;;;3697     __HAL_UNLOCK(huart);
;;;3698   
;;;3699     /* Enable the UART Parity Error Interrupt */
;;;3700     SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;3701   
;;;3702     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3703     SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;3704   
;;;3705     /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;3706     in the UART CR3 register */
;;;3707     SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;3708   
;;;3709     return HAL_OK;
;;;3710   }
00004e  bd70              POP      {r4-r6,pc}
                  |L62.80|
000050  f8845074          STRB     r5,[r4,#0x74]         ;3697
000054  6820              LDR      r0,[r4,#0]            ;3700
000056  6801              LDR      r1,[r0,#0]            ;3700
000058  f4417180          ORR      r1,r1,#0x100          ;3700
00005c  6001              STR      r1,[r0,#0]            ;3700
00005e  6820              LDR      r0,[r4,#0]            ;3703
000060  6881              LDR      r1,[r0,#8]            ;3703
000062  f0410101          ORR      r1,r1,#1              ;3703
000066  6081              STR      r1,[r0,#8]            ;3703
000068  6820              LDR      r0,[r4,#0]            ;3707
00006a  6881              LDR      r1,[r0,#8]            ;3707
00006c  f0410140          ORR      r1,r1,#0x40           ;3707
000070  6081              STR      r1,[r0,#8]            ;3707
000072  2000              MOVS     r0,#0                 ;3709
000074  bd70              POP      {r4-r6,pc}
;;;3711   
                          ENDP

000076  0000              DCW      0x0000
                  |L62.120|
                          DCD      UART_DMAReceiveCplt
                  |L62.124|
                          DCD      UART_DMARxHalfCplt
                  |L62.128|
                          DCD      UART_DMAError

                          AREA ||i.UART_Start_Receive_IT||, CODE, READONLY, ALIGN=2

                  UART_Start_Receive_IT PROC
;;;3577     */
;;;3578   HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;3579   {
;;;3580     huart->pRxBuffPtr  = pData;
000002  6541              STR      r1,[r0,#0x54]
;;;3581     huart->RxXferSize  = Size;
000004  f8a02058          STRH     r2,[r0,#0x58]
;;;3582     huart->RxXferCount = Size;
000008  f8a0205a          STRH     r2,[r0,#0x5a]
;;;3583     huart->RxISR       = NULL;
00000c  2200              MOVS     r2,#0
00000e  6642              STR      r2,[r0,#0x64]
;;;3584   
;;;3585     /* Computation of UART mask to apply to RDR register */
;;;3586     UART_MASK_COMPUTATION(huart);
000010  6881              LDR      r1,[r0,#8]
000012  f44f5580          MOV      r5,#0x1000
000016  23ff              MOVS     r3,#0xff
000018  42a9              CMP      r1,r5
00001a  d109              BNE      |L63.48|
00001c  6901              LDR      r1,[r0,#0x10]
00001e  b111              CBZ      r1,|L63.38|
000020  f8a0305c          STRH     r3,[r0,#0x5c]
000024  e00b              B        |L63.62|
                  |L63.38|
000026  f24011ff          MOV      r1,#0x1ff
00002a  f8a0105c          STRH     r1,[r0,#0x5c]
00002e  e006              B        |L63.62|
                  |L63.48|
000030  247f              MOVS     r4,#0x7f
000032  b1e9              CBZ      r1,|L63.112|
000034  f1b15f80          CMP      r1,#0x10000000
000038  d022              BEQ      |L63.128|
00003a  f8a0205c          STRH     r2,[r0,#0x5c]
                  |L63.62|
;;;3587   
;;;3588     huart->ErrorCode = HAL_UART_ERROR_NONE;
00003e  f8c02080          STR      r2,[r0,#0x80]
;;;3589     huart->RxState = HAL_UART_STATE_BUSY_RX;
000042  2122              MOVS     r1,#0x22
000044  67c1              STR      r1,[r0,#0x7c]
;;;3590   
;;;3591     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3592     SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
000046  6801              LDR      r1,[r0,#0]
000048  688b              LDR      r3,[r1,#8]
00004a  f0430301          ORR      r3,r3,#1
00004e  608b              STR      r3,[r1,#8]
;;;3593   
;;;3594   #if defined(USART_CR1_FIFOEN)
;;;3595     /* Configure Rx interrupt processing */
;;;3596     if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
;;;3597     {
;;;3598       /* Set the Rx ISR function pointer according to the data word length */
;;;3599       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;3600       {
;;;3601         huart->RxISR = UART_RxISR_16BIT_FIFOEN;
;;;3602       }
;;;3603       else
;;;3604       {
;;;3605         huart->RxISR = UART_RxISR_8BIT_FIFOEN;
;;;3606       }
;;;3607   
;;;3608       __HAL_UNLOCK(huart);
;;;3609   
;;;3610       /* Enable the UART Parity Error interrupt and RX FIFO Threshold interrupt */
;;;3611       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;3612       SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
;;;3613     }
;;;3614     else
;;;3615     {
;;;3616       /* Set the Rx ISR function pointer according to the data word length */
;;;3617       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;3618       {
;;;3619         huart->RxISR = UART_RxISR_16BIT;
;;;3620       }
;;;3621       else
;;;3622       {
;;;3623         huart->RxISR = UART_RxISR_8BIT;
;;;3624       }
;;;3625   
;;;3626       __HAL_UNLOCK(huart);
;;;3627   
;;;3628       /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
;;;3629       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
;;;3630     }
;;;3631   #else
;;;3632     /* Set the Rx ISR function pointer according to the data word length */
;;;3633     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000050  6881              LDR      r1,[r0,#8]
000052  42a9              CMP      r1,r5
000054  d101              BNE      |L63.90|
000056  6901              LDR      r1,[r0,#0x10]
000058  b1d9              CBZ      r1,|L63.146|
                  |L63.90|
;;;3634     {
;;;3635       huart->RxISR = UART_RxISR_16BIT;
;;;3636     }
;;;3637     else
;;;3638     {
;;;3639       huart->RxISR = UART_RxISR_8BIT;
00005a  490f              LDR      r1,|L63.152|
00005c  6641              STR      r1,[r0,#0x64]
                  |L63.94|
;;;3640     }
;;;3641   
;;;3642     __HAL_UNLOCK(huart);
00005e  f8802074          STRB     r2,[r0,#0x74]
;;;3643   
;;;3644     /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
;;;3645     SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
000062  6800              LDR      r0,[r0,#0]
000064  6801              LDR      r1,[r0,#0]
000066  f4417190          ORR      r1,r1,#0x120
00006a  6001              STR      r1,[r0,#0]
;;;3646   #endif /* USART_CR1_FIFOEN */
;;;3647     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;3648   }
00006e  bd30              POP      {r4,r5,pc}
                  |L63.112|
000070  6901              LDR      r1,[r0,#0x10]         ;3586
000072  b111              CBZ      r1,|L63.122|
000074  f8a0405c          STRH     r4,[r0,#0x5c]         ;3586
000078  e7e1              B        |L63.62|
                  |L63.122|
00007a  f8a0305c          STRH     r3,[r0,#0x5c]         ;3586
00007e  e7de              B        |L63.62|
                  |L63.128|
000080  6901              LDR      r1,[r0,#0x10]         ;3586
000082  b119              CBZ      r1,|L63.140|
000084  213f              MOVS     r1,#0x3f              ;3586
000086  f8a0105c          STRH     r1,[r0,#0x5c]         ;3586
00008a  e7d8              B        |L63.62|
                  |L63.140|
00008c  f8a0405c          STRH     r4,[r0,#0x5c]         ;3586
000090  e7d5              B        |L63.62|
                  |L63.146|
000092  4902              LDR      r1,|L63.156|
000094  6641              STR      r1,[r0,#0x64]         ;3635
000096  e7e2              B        |L63.94|
;;;3649   
                          ENDP

                  |L63.152|
                          DCD      UART_RxISR_8BIT
                  |L63.156|
                          DCD      UART_RxISR_16BIT

                          AREA ||i.UART_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  UART_TxISR_16BIT PROC
;;;4185     */
;;;4186   static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
000000  6f81              LDR      r1,[r0,#0x78]
;;;4187   {
;;;4188     uint16_t *tmp;
;;;4189   
;;;4190     /* Check that a Tx process is ongoing */
;;;4191     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  2921              CMP      r1,#0x21
000004  d110              BNE      |L64.40|
;;;4192     {
;;;4193       if (huart->TxXferCount == 0U)
000006  f8b01052          LDRH     r1,[r0,#0x52]
00000a  b171              CBZ      r1,|L64.42|
;;;4194       {
;;;4195         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;4196   #if defined(USART_CR1_FIFOEN)
;;;4197         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
;;;4198   #else
;;;4199         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;4200   #endif /* USART_CR1_FIFOEN */
;;;4201   
;;;4202         /* Enable the UART Transmit Complete Interrupt */
;;;4203         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;4204       }
;;;4205       else
;;;4206       {
;;;4207         tmp = (uint16_t *) huart->pTxBuffPtr;
00000c  6cc1              LDR      r1,[r0,#0x4c]
;;;4208         huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
00000e  6802              LDR      r2,[r0,#0]
000010  8809              LDRH     r1,[r1,#0]
000012  f3c10108          UBFX     r1,r1,#0,#9
000016  8511              STRH     r1,[r2,#0x28]
;;;4209         huart->pTxBuffPtr += 2U;
000018  6cc1              LDR      r1,[r0,#0x4c]
00001a  1c89              ADDS     r1,r1,#2
00001c  64c1              STR      r1,[r0,#0x4c]
;;;4210         huart->TxXferCount--;
00001e  f8b01052          LDRH     r1,[r0,#0x52]
000022  1e49              SUBS     r1,r1,#1
000024  f8a01052          STRH     r1,[r0,#0x52]
                  |L64.40|
;;;4211       }
;;;4212     }
;;;4213   }
000028  4770              BX       lr
                  |L64.42|
00002a  6801              LDR      r1,[r0,#0]            ;4199
00002c  680a              LDR      r2,[r1,#0]            ;4199
00002e  f0220280          BIC      r2,r2,#0x80           ;4199
000032  600a              STR      r2,[r1,#0]            ;4199
000034  6800              LDR      r0,[r0,#0]            ;4203
000036  6801              LDR      r1,[r0,#0]            ;4203
000038  f0410140          ORR      r1,r1,#0x40           ;4203
00003c  6001              STR      r1,[r0,#0]            ;4203
00003e  4770              BX       lr
;;;4214   
                          ENDP


                          AREA ||i.UART_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  UART_TxISR_8BIT PROC
;;;4152     */
;;;4153   static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
000000  6f81              LDR      r1,[r0,#0x78]
;;;4154   {
;;;4155     /* Check that a Tx process is ongoing */
;;;4156     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  2921              CMP      r1,#0x21
000004  d10e              BNE      |L65.36|
;;;4157     {
;;;4158       if (huart->TxXferCount == 0U)
000006  f8b01052          LDRH     r1,[r0,#0x52]
00000a  b161              CBZ      r1,|L65.38|
;;;4159       {
;;;4160         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;4161   #if defined(USART_CR1_FIFOEN)
;;;4162         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
;;;4163   #else
;;;4164         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;4165   #endif /* USART_CR1_FIFOEN */
;;;4166   
;;;4167         /* Enable the UART Transmit Complete Interrupt */
;;;4168         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;4169       }
;;;4170       else
;;;4171       {
;;;4172         huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
00000c  6cc1              LDR      r1,[r0,#0x4c]
00000e  6802              LDR      r2,[r0,#0]
000010  7809              LDRB     r1,[r1,#0]
000012  8511              STRH     r1,[r2,#0x28]
;;;4173         huart->pTxBuffPtr++;
000014  6cc1              LDR      r1,[r0,#0x4c]
000016  1c49              ADDS     r1,r1,#1
000018  64c1              STR      r1,[r0,#0x4c]
;;;4174         huart->TxXferCount--;
00001a  f8b01052          LDRH     r1,[r0,#0x52]
00001e  1e49              SUBS     r1,r1,#1
000020  f8a01052          STRH     r1,[r0,#0x52]
                  |L65.36|
;;;4175       }
;;;4176     }
;;;4177   }
000024  4770              BX       lr
                  |L65.38|
000026  6801              LDR      r1,[r0,#0]            ;4164
000028  680a              LDR      r2,[r1,#0]            ;4164
00002a  f0220280          BIC      r2,r2,#0x80           ;4164
00002e  600a              STR      r2,[r1,#0]            ;4164
000030  6800              LDR      r0,[r0,#0]            ;4168
000032  6801              LDR      r1,[r0,#0]            ;4168
000034  f0410140          ORR      r1,r1,#0x40           ;4168
000038  6001              STR      r1,[r0,#0]            ;4168
00003a  4770              BX       lr
;;;4178   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;3507     */
;;;3508   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3509                                                 uint32_t Tickstart, uint32_t Timeout)
;;;3510   {
000004  4604              MOV      r4,r0
000006  9d08              LDR      r5,[sp,#0x20]
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
00000c  4698              MOV      r8,r3
;;;3511     /* Wait until flag is set */
;;;3512     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  f04f0a00          MOV      r10,#0
;;;3513     {
;;;3514       /* Check for the Timeout */
;;;3515       if (Timeout != HAL_MAX_DELAY)
;;;3516       {
;;;3517         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;3518         {
;;;3519           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
;;;3520              interrupts for the interrupt process */
;;;3521   #if defined(USART_CR1_FIFOEN)
;;;3522           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
;;;3523   #else
;;;3524           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;3525   #endif /* USART_CR1_FIFOEN */
;;;3526           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;3527   
;;;3528           huart->gState = HAL_UART_STATE_READY;
000012  f04f0920          MOV      r9,#0x20
000016  e03b              B        |L66.144|
                  |L66.24|
000018  1c68              ADDS     r0,r5,#1              ;3515
00001a  d039              BEQ      |L66.144|
00001c  f7fffffe          BL       HAL_GetTick
000020  eba00008          SUB      r0,r0,r8              ;3517
000024  42a8              CMP      r0,r5                 ;3517
000026  d821              BHI      |L66.108|
000028  b305              CBZ      r5,|L66.108|
;;;3529           huart->RxState = HAL_UART_STATE_READY;
;;;3530   
;;;3531           __HAL_UNLOCK(huart);
;;;3532   
;;;3533           return HAL_TIMEOUT;
;;;3534         }
;;;3535   
;;;3536         if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
00002a  6820              LDR      r0,[r4,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  0749              LSLS     r1,r1,#29
000030  d52e              BPL      |L66.144|
;;;3537         {
;;;3538           if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
000032  69c0              LDR      r0,[r0,#0x1c]
000034  43c0              MVNS     r0,r0
000036  0500              LSLS     r0,r0,#20
000038  d42a              BMI      |L66.144|
;;;3539           {
;;;3540             /* Clear Receiver Timeout flag*/
;;;3541             __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
00003a  6821              LDR      r1,[r4,#0]
00003c  f44f6000          MOV      r0,#0x800
000040  6208              STR      r0,[r1,#0x20]
;;;3542   
;;;3543             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
;;;3544                interrupts for the interrupt process */
;;;3545   #if defined(USART_CR1_FIFOEN)
;;;3546             CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
;;;3547   #else
;;;3548             CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f42171d0          BIC      r1,r1,#0x1a0
00004a  6001              STR      r1,[r0,#0]
;;;3549   #endif
;;;3550             CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00004c  6820              LDR      r0,[r4,#0]
00004e  6881              LDR      r1,[r0,#8]
000050  f0210101          BIC      r1,r1,#1
000054  6081              STR      r1,[r0,#8]
;;;3551   
;;;3552             huart->gState = HAL_UART_STATE_READY;
000056  f8c49078          STR      r9,[r4,#0x78]
;;;3553             huart->RxState = HAL_UART_STATE_READY;
00005a  f8c4907c          STR      r9,[r4,#0x7c]
;;;3554             huart->ErrorCode = HAL_UART_ERROR_RTO;
00005e  f8c49080          STR      r9,[r4,#0x80]
;;;3555   
;;;3556             /* Process Unlocked */
;;;3557             __HAL_UNLOCK(huart);
000062  f884a074          STRB     r10,[r4,#0x74]
;;;3558   
;;;3559             return HAL_TIMEOUT;
000066  2003              MOVS     r0,#3
                  |L66.104|
;;;3560           }
;;;3561         }
;;;3562       }
;;;3563     }
;;;3564     return HAL_OK;
;;;3565   }
000068  e8bd87f0          POP      {r4-r10,pc}
                  |L66.108|
00006c  6820              LDR      r0,[r4,#0]            ;3524
00006e  6801              LDR      r1,[r0,#0]            ;3524
000070  f42171d0          BIC      r1,r1,#0x1a0          ;3524
000074  6001              STR      r1,[r0,#0]            ;3524
000076  6820              LDR      r0,[r4,#0]            ;3526
000078  6881              LDR      r1,[r0,#8]            ;3526
00007a  f0210101          BIC      r1,r1,#1              ;3526
00007e  6081              STR      r1,[r0,#8]            ;3526
000080  f8c49078          STR      r9,[r4,#0x78]         ;3528
000084  f8c4907c          STR      r9,[r4,#0x7c]         ;3529
000088  f884a074          STRB     r10,[r4,#0x74]        ;3531
00008c  2003              MOVS     r0,#3                 ;3533
00008e  e7eb              B        |L66.104|
                  |L66.144|
000090  6820              LDR      r0,[r4,#0]            ;3512
000092  69c0              LDR      r0,[r0,#0x1c]         ;3512
000094  ea360000          BICS     r0,r6,r0              ;3512
000098  d004              BEQ      |L66.164|
00009a  2000              MOVS     r0,#0                 ;3512
                  |L66.156|
00009c  42b8              CMP      r0,r7                 ;3512
00009e  d0bb              BEQ      |L66.24|
0000a0  2000              MOVS     r0,#0                 ;3564
0000a2  e7e1              B        |L66.104|
                  |L66.164|
0000a4  2001              MOVS     r0,#1                 ;3512
0000a6  e7f9              B        |L66.156|
;;;3566   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_uart_c_d497114f____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32l4xx_hal_uart_c_d497114f____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_uart_c_d497114f____REVSH|
#line 507
|__asm___20_stm32l4xx_hal_uart_c_d497114f____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_hal_uart_c_d497114f____RRX|
#line 694
|__asm___20_stm32l4xx_hal_uart_c_d497114f____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
