L 1 "..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_ll_gpio.c"
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_gpio.c
N  * @author  MCD Application Team
N  * @brief   GPIO LL module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 0L
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32l4xx_ll_gpio.h"
S#include "stm32l4xx_ll_bus.h"
S#ifdef  USE_FULL_ASSERT
S#include "stm32_assert.h"
S#else
S#define assert_param(expr) ((void)0U)
S#endif
S
S/** @addtogroup STM32L4xx_LL_Driver
S  * @{
S  */
S
S#if defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI)
S
S/** @addtogroup GPIO_LL
S  * @{
S  */
S/** MISRA C:2012 deviation rule has been granted for following rules:
S  * Rule-12.2 - Medium: RHS argument is in interval [0,INF] which is out of
S  * range of the shift operator in following API :
S  * LL_GPIO_Init
S  */
S
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/* Private macros ------------------------------------------------------------*/
S/** @addtogroup GPIO_LL_Private_Macros
S  * @{
S  */
S#define IS_LL_GPIO_PIN(__VALUE__)          (((0x00u) < (__VALUE__)) && ((__VALUE__) <= (LL_GPIO_PIN_ALL)))
S
S#define IS_LL_GPIO_MODE(__VALUE__)         (((__VALUE__) == LL_GPIO_MODE_INPUT)     ||\
S                                            ((__VALUE__) == LL_GPIO_MODE_OUTPUT)    ||\
S                                            ((__VALUE__) == LL_GPIO_MODE_ALTERNATE) ||\
S                                            ((__VALUE__) == LL_GPIO_MODE_ANALOG))
X#define IS_LL_GPIO_MODE(__VALUE__)         (((__VALUE__) == LL_GPIO_MODE_INPUT)     ||                                            ((__VALUE__) == LL_GPIO_MODE_OUTPUT)    ||                                            ((__VALUE__) == LL_GPIO_MODE_ALTERNATE) ||                                            ((__VALUE__) == LL_GPIO_MODE_ANALOG))
S
S#define IS_LL_GPIO_OUTPUT_TYPE(__VALUE__)  (((__VALUE__) == LL_GPIO_OUTPUT_PUSHPULL)  ||\
S                                            ((__VALUE__) == LL_GPIO_OUTPUT_OPENDRAIN))
X#define IS_LL_GPIO_OUTPUT_TYPE(__VALUE__)  (((__VALUE__) == LL_GPIO_OUTPUT_PUSHPULL)  ||                                            ((__VALUE__) == LL_GPIO_OUTPUT_OPENDRAIN))
S
S#define IS_LL_GPIO_SPEED(__VALUE__)        (((__VALUE__) == LL_GPIO_SPEED_FREQ_LOW)       ||\
S                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_MEDIUM)    ||\
S                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_HIGH)      ||\
S                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_VERY_HIGH))
X#define IS_LL_GPIO_SPEED(__VALUE__)        (((__VALUE__) == LL_GPIO_SPEED_FREQ_LOW)       ||                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_MEDIUM)    ||                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_HIGH)      ||                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_VERY_HIGH))
S
S#define IS_LL_GPIO_PULL(__VALUE__)         (((__VALUE__) == LL_GPIO_PULL_NO)   ||\
S                                            ((__VALUE__) == LL_GPIO_PULL_UP)   ||\
S                                            ((__VALUE__) == LL_GPIO_PULL_DOWN))
X#define IS_LL_GPIO_PULL(__VALUE__)         (((__VALUE__) == LL_GPIO_PULL_NO)   ||                                            ((__VALUE__) == LL_GPIO_PULL_UP)   ||                                            ((__VALUE__) == LL_GPIO_PULL_DOWN))
S
S#define IS_LL_GPIO_ALTERNATE(__VALUE__)    (((__VALUE__) == LL_GPIO_AF_0  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_1  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_2  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_3  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_4  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_5  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_6  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_7  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_8  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_9  )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_10 )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_11 )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_12 )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_13 )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_14 )   ||\
S                                            ((__VALUE__) == LL_GPIO_AF_15 ))
X#define IS_LL_GPIO_ALTERNATE(__VALUE__)    (((__VALUE__) == LL_GPIO_AF_0  )   ||                                            ((__VALUE__) == LL_GPIO_AF_1  )   ||                                            ((__VALUE__) == LL_GPIO_AF_2  )   ||                                            ((__VALUE__) == LL_GPIO_AF_3  )   ||                                            ((__VALUE__) == LL_GPIO_AF_4  )   ||                                            ((__VALUE__) == LL_GPIO_AF_5  )   ||                                            ((__VALUE__) == LL_GPIO_AF_6  )   ||                                            ((__VALUE__) == LL_GPIO_AF_7  )   ||                                            ((__VALUE__) == LL_GPIO_AF_8  )   ||                                            ((__VALUE__) == LL_GPIO_AF_9  )   ||                                            ((__VALUE__) == LL_GPIO_AF_10 )   ||                                            ((__VALUE__) == LL_GPIO_AF_11 )   ||                                            ((__VALUE__) == LL_GPIO_AF_12 )   ||                                            ((__VALUE__) == LL_GPIO_AF_13 )   ||                                            ((__VALUE__) == LL_GPIO_AF_14 )   ||                                            ((__VALUE__) == LL_GPIO_AF_15 ))
S/**
S  * @}
S  */
S
S/* Private function prototypes -----------------------------------------------*/
S
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup GPIO_LL_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup GPIO_LL_EF_Init
S  * @{
S  */
S
S/**
S  * @brief  De-initialize GPIO registers (Registers restored to their default values).
S  * @param  GPIOx GPIO Port
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: GPIO registers are de-initialized
S  *          - ERROR:   Wrong GPIO Port
S  */
SErrorStatus LL_GPIO_DeInit(GPIO_TypeDef *GPIOx)
S{
S  ErrorStatus status = SUCCESS;
S
S  /* Check the parameters */
S  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
S
S  /* Force and Release reset on clock of GPIOx Port */
S  if (GPIOx == GPIOA)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOA);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOA);
S  }
S  else if (GPIOx == GPIOB)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOB);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOB);
S  }
S  else if (GPIOx == GPIOC)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOC);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOC);
S  }
S#if defined(GPIOD)
S  else if (GPIOx == GPIOD)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOD);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOD);
S  }
S#endif /* GPIOD */
S#if defined(GPIOE)
S  else if (GPIOx == GPIOE)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOE);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOE);
S  }
S#endif /* GPIOE */
S#if defined(GPIOF)
S  else if (GPIOx == GPIOF)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOF);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOF);
S  }
S#endif /* GPIOF */
S#if defined(GPIOG)
S  else if (GPIOx == GPIOG)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOG);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOG);
S  }
S#endif /* GPIOG */
S#if defined(GPIOH)
S  else if (GPIOx == GPIOH)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOH);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOH);
S  }
S#endif /* GPIOH */
S#if defined(GPIOI)
S  else if (GPIOx == GPIOI)
S  {
S    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOI);
S    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOI);
S  }
S#endif /* GPIOI */
S  else
S  {
S    status = ERROR;
S  }
S
S  return (status);
S}
S
S/**
S  * @brief  Initialize GPIO registers according to the specified parameters in GPIO_InitStruct.
S  * @param  GPIOx GPIO Port
S  * @param GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure
S  *         that contains the configuration information for the specified GPIO peripheral.
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
S  *          - ERROR:   Not applicable
S  */
SErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
S{
S  uint32_t pinpos;
S  uint32_t currentpin;
S
S  /* Check the parameters */
S  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
S  assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));
S  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
S  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));
S
S  /* ------------------------- Configure the port pins ---------------- */
S  /* Initialize  pinpos on first pin set */
S  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
S
S  /* Configure the port pins */
S  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00u)
S  {
S    /* Get current io position */
S    currentpin = (GPIO_InitStruct->Pin) & (0x00000001uL << pinpos);
S
S    if (currentpin != 0x00u)
S    {
S      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
S      {
S        /* Check Speed mode parameters */
S        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
S
S        /* Speed mode configuration */
S        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
S
S        /* Check Output mode parameters */
S        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
S
S        /* Output mode configuration*/
S        LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);
S      }
S
S      /* Pull-up Pull down resistor configuration*/
S      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
S
S      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
S      {
S        /* Check Alternate parameter */
S        assert_param(IS_LL_GPIO_ALTERNATE(GPIO_InitStruct->Alternate));
S
S        /* Speed mode configuration */
S        if (currentpin < LL_GPIO_PIN_8)
S        {
S          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
S        }
S        else
S        {
S          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
S        }
S      }
S
S      /* Pin Mode configuration */
S      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
S    }
S    pinpos++;
S  }
S
S  return (SUCCESS);
S}
S
S/**
S  * @brief Set each @ref LL_GPIO_InitTypeDef field to default value.
S  * @param GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure
S  *                          whose fields will be set to default values.
S  * @retval None
S  */
S
Svoid LL_GPIO_StructInit(LL_GPIO_InitTypeDef *GPIO_InitStruct)
S{
S  /* Reset GPIO init structure parameters values */
S  GPIO_InitStruct->Pin        = LL_GPIO_PIN_ALL;
S  GPIO_InitStruct->Mode       = LL_GPIO_MODE_ANALOG;
S  GPIO_InitStruct->Speed      = LL_GPIO_SPEED_FREQ_LOW;
S  GPIO_InitStruct->OutputType = LL_GPIO_OUTPUT_PUSHPULL;
S  GPIO_InitStruct->Pull       = LL_GPIO_PULL_NO;
S  GPIO_InitStruct->Alternate  = LL_GPIO_AF_0;
S}
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S#endif /* defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) */
S
S/**
S  * @}
S  */
S
N#endif /* USE_FULL_LL_DRIVER */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
