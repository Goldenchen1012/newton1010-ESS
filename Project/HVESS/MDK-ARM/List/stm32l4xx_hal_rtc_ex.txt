; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_rtc_ex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_rtc_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_rtc_ex.c]
                          THUMB

                          AREA ||i.HAL_RTCEx_AlarmBEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_AlarmBEventCallback PROC
;;;1671     */
;;;1672   __weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1673   {
;;;1674     /* Prevent unused argument(s) compilation warning */
;;;1675     UNUSED(hrtc);
;;;1676   
;;;1677     /* NOTE : This function should not be modified, when the callback is needed,
;;;1678               the HAL_RTCEx_AlarmBEventCallback could be implemented in the user file
;;;1679      */
;;;1680   }
;;;1681   
                          ENDP


                          AREA ||i.HAL_RTCEx_BKUPRead||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_BKUPRead PROC
;;;2372     */
;;;2373   uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
000000  6800              LDR      r0,[r0,#0]
;;;2374   {
;;;2375     uint32_t tmp;
;;;2376   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;2377     /* Process TAMP instance pointer */
;;;2378     TAMP_TypeDef *tamp = (TAMP_TypeDef *)((uint32_t)hrtc->Instance + hrtc->TampOffset);
;;;2379   
;;;2380     /* Check the parameters */
;;;2381     assert_param(IS_RTC_BKP(BackupRegister));
;;;2382   
;;;2383     tmp = (uint32_t) & (tamp->BKP0R);
;;;2384   #else /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2385     /* Check the parameters */
;;;2386     assert_param(IS_RTC_BKP(BackupRegister));
;;;2387   
;;;2388     tmp = (uint32_t) & (hrtc->Instance->BKP0R);
000002  3050              ADDS     r0,r0,#0x50
;;;2389   #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2390   
;;;2391     tmp += (BackupRegister * 4U);
000004  eb000081          ADD      r0,r0,r1,LSL #2
;;;2392   
;;;2393     /* Read the specified register */
;;;2394     return (*(__IO uint32_t *)tmp);
000008  6800              LDR      r0,[r0,#0]
;;;2395   }
00000a  4770              BX       lr
;;;2396   
                          ENDP


                          AREA ||i.HAL_RTCEx_BKUPWrite||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_BKUPWrite PROC
;;;2339     */
;;;2340   void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
000000  b508              PUSH     {r3,lr}
;;;2341   {
;;;2342     uint32_t __IO tmp;
;;;2343   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;2344     /* Process TAMP instance pointer */
;;;2345     TAMP_TypeDef *tamp = (TAMP_TypeDef *)((uint32_t)hrtc->Instance + hrtc->TampOffset);
;;;2346   
;;;2347     /* Check the parameters */
;;;2348     assert_param(IS_RTC_BKP(BackupRegister));
;;;2349   
;;;2350     tmp = (uint32_t) & (tamp->BKP0R);
;;;2351   #else /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2352     /* Check the parameters */
;;;2353     assert_param(IS_RTC_BKP(BackupRegister));
;;;2354   
;;;2355     tmp = (uint32_t) & (hrtc->Instance->BKP0R);
000002  6800              LDR      r0,[r0,#0]
000004  3050              ADDS     r0,r0,#0x50
000006  9000              STR      r0,[sp,#0]
;;;2356   #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;2357   
;;;2358     tmp += (BackupRegister * 4U);
000008  9800              LDR      r0,[sp,#0]
00000a  eb000081          ADD      r0,r0,r1,LSL #2
00000e  9000              STR      r0,[sp,#0]
;;;2359   
;;;2360     /* Write the specified register */
;;;2361     *(__IO uint32_t *)tmp = (uint32_t)Data;
000010  9800              LDR      r0,[sp,#0]
000012  6002              STR      r2,[r0,#0]
;;;2362   }
000014  bd08              POP      {r3,pc}
;;;2363   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateCalibrationOutPut||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateCalibrationOutPut PROC
;;;1373     */
;;;1374   HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef *hrtc)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;1375   {
;;;1376     /* Process Locked */
;;;1377     __HAL_LOCK(hrtc);
000004  2901              CMP      r1,#1
000006  d01a              BEQ      |L4.62|
000008  2201              MOVS     r2,#1
00000a  f8802020          STRB     r2,[r0,#0x20]
;;;1378   
;;;1379     hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f8801021          STRB     r1,[r0,#0x21]
;;;1380   
;;;1381     /* Disable the write protection for RTC registers */
;;;1382     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000014  6803              LDR      r3,[r0,#0]
000016  21ca              MOVS     r1,#0xca
000018  6259              STR      r1,[r3,#0x24]
00001a  6803              LDR      r3,[r0,#0]
00001c  2153              MOVS     r1,#0x53
00001e  6259              STR      r1,[r3,#0x24]
;;;1383   
;;;1384     __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);
000020  6801              LDR      r1,[r0,#0]
000022  688b              LDR      r3,[r1,#8]
000024  f4230300          BIC      r3,r3,#0x800000
000028  608b              STR      r3,[r1,#8]
;;;1385   
;;;1386     /* Enable the write protection for RTC registers */
;;;1387     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00002a  6803              LDR      r3,[r0,#0]
00002c  21ff              MOVS     r1,#0xff
00002e  6259              STR      r1,[r3,#0x24]
;;;1388   
;;;1389     /* Change RTC state */
;;;1390     hrtc->State = HAL_RTC_STATE_READY;
000030  f8802021          STRB     r2,[r0,#0x21]
;;;1391   
;;;1392     /* Process Unlocked */
;;;1393     __HAL_UNLOCK(hrtc);
000034  2100              MOVS     r1,#0
000036  f8801020          STRB     r1,[r0,#0x20]
;;;1394   
;;;1395     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;1396   }
00003c  4770              BX       lr
                  |L4.62|
00003e  2002              MOVS     r0,#2                 ;1377
000040  4770              BX       lr
;;;1397   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateInternalTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateInternalTimeStamp PROC
;;;347      */
;;;348    HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;349    {
;;;350      /* Process Locked */
;;;351      __HAL_LOCK(hrtc);
000004  2901              CMP      r1,#1
000006  d01a              BEQ      |L5.62|
000008  2201              MOVS     r2,#1
00000a  f8802020          STRB     r2,[r0,#0x20]
;;;352    
;;;353      hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f8801021          STRB     r1,[r0,#0x21]
;;;354    
;;;355      /* Disable the write protection for RTC registers */
;;;356      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000014  6803              LDR      r3,[r0,#0]
000016  21ca              MOVS     r1,#0xca
000018  6259              STR      r1,[r3,#0x24]
00001a  6803              LDR      r3,[r0,#0]
00001c  2153              MOVS     r1,#0x53
00001e  6259              STR      r1,[r3,#0x24]
;;;357    
;;;358      /* Configure the internal Time Stamp Enable bits */
;;;359      __HAL_RTC_INTERNAL_TIMESTAMP_DISABLE(hrtc);
000020  6801              LDR      r1,[r0,#0]
000022  688b              LDR      r3,[r1,#8]
000024  f0237380          BIC      r3,r3,#0x1000000
000028  608b              STR      r3,[r1,#8]
;;;360    
;;;361      /* Enable the write protection for RTC registers */
;;;362      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00002a  6803              LDR      r3,[r0,#0]
00002c  21ff              MOVS     r1,#0xff
00002e  6259              STR      r1,[r3,#0x24]
;;;363    
;;;364      hrtc->State = HAL_RTC_STATE_READY;
000030  f8802021          STRB     r2,[r0,#0x21]
;;;365    
;;;366      /* Process Unlocked */
;;;367      __HAL_UNLOCK(hrtc);
000034  2100              MOVS     r1,#0
000036  f8801020          STRB     r1,[r0,#0x20]
;;;368    
;;;369      return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;370    }
00003c  4770              BX       lr
                  |L5.62|
00003e  2002              MOVS     r0,#2                 ;351
000040  4770              BX       lr
;;;371    
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateRefClock||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateRefClock PROC
;;;1443     */
;;;1444   HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1445   {
000002  4604              MOV      r4,r0
;;;1446     HAL_StatusTypeDef status;
;;;1447   
;;;1448     /* Process Locked */
;;;1449     __HAL_LOCK(hrtc);
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2801              CMP      r0,#1
00000a  d010              BEQ      |L6.46|
00000c  2501              MOVS     r5,#1
00000e  f8845020          STRB     r5,[r4,#0x20]
;;;1450   
;;;1451     hrtc->State = HAL_RTC_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840021          STRB     r0,[r4,#0x21]
;;;1452   
;;;1453     /* Disable the write protection for RTC registers */
;;;1454     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000018  6821              LDR      r1,[r4,#0]
00001a  20ca              MOVS     r0,#0xca
00001c  6248              STR      r0,[r1,#0x24]
00001e  6821              LDR      r1,[r4,#0]
000020  2053              MOVS     r0,#0x53
000022  6248              STR      r0,[r1,#0x24]
;;;1455   
;;;1456     /* Enter Initialization mode */
;;;1457     status = RTC_EnterInitMode(hrtc);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RTC_EnterInitMode
00002a  b110              CBZ      r0,|L6.50|
00002c  e009              B        |L6.66|
                  |L6.46|
00002e  2002              MOVS     r0,#2                 ;1449
;;;1458     if (status == HAL_OK)
;;;1459     {
;;;1460       __HAL_RTC_CLOCKREF_DETECTION_DISABLE(hrtc);
;;;1461   
;;;1462       /* Exit Initialization mode */
;;;1463       status = RTC_ExitInitMode(hrtc);
;;;1464     }
;;;1465   
;;;1466     /* Enable the write protection for RTC registers */
;;;1467     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1468   
;;;1469     if (status == HAL_OK)
;;;1470     {
;;;1471       hrtc->State = HAL_RTC_STATE_READY;
;;;1472     }
;;;1473   
;;;1474     /* Process Unlocked */
;;;1475     __HAL_UNLOCK(hrtc);
;;;1476   
;;;1477     return status;
;;;1478   }
000030  bd70              POP      {r4-r6,pc}
                  |L6.50|
000032  6820              LDR      r0,[r4,#0]            ;1460
000034  6881              LDR      r1,[r0,#8]            ;1460
000036  f0210110          BIC      r1,r1,#0x10           ;1460
00003a  6081              STR      r1,[r0,#8]            ;1460
00003c  4620              MOV      r0,r4                 ;1463
00003e  f7fffffe          BL       RTC_ExitInitMode
                  |L6.66|
000042  6822              LDR      r2,[r4,#0]            ;1467
000044  21ff              MOVS     r1,#0xff              ;1467
000046  6251              STR      r1,[r2,#0x24]         ;1467
000048  b908              CBNZ     r0,|L6.78|
00004a  f8845021          STRB     r5,[r4,#0x21]         ;1471
                  |L6.78|
00004e  2100              MOVS     r1,#0                 ;1475
000050  f8841020          STRB     r1,[r4,#0x20]         ;1475
000054  bd70              POP      {r4-r6,pc}
;;;1479   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateTamper||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_DeactivateTamper PROC
;;;2112     */
;;;2113   HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
000000  b530              PUSH     {r4,r5,lr}
;;;2114   {
;;;2115     assert_param(IS_RTC_TAMPER(Tamper));
;;;2116   
;;;2117     /* Process Locked */
;;;2118     __HAL_LOCK(hrtc);
000002  f8902020          LDRB     r2,[r0,#0x20]
000006  2a01              CMP      r2,#1
000008  d024              BEQ      |L7.84|
00000a  2301              MOVS     r3,#1
00000c  f8803020          STRB     r3,[r0,#0x20]
;;;2119   
;;;2120     hrtc->State = HAL_RTC_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  f8802021          STRB     r2,[r0,#0x21]
;;;2121   
;;;2122     /* Disable the selected Tamper pin */
;;;2123     hrtc->Instance->TAMPCR &= ~Tamper;
000016  6802              LDR      r2,[r0,#0]
000018  6c14              LDR      r4,[r2,#0x40]
00001a  438c              BICS     r4,r4,r1
00001c  6414              STR      r4,[r2,#0x40]
;;;2124   
;;;2125   #if defined(RTC_TAMPER1_SUPPORT)
;;;2126     if ((Tamper & RTC_TAMPER_1) != 0U)
00001e  07ca              LSLS     r2,r1,#31
000020  d004              BEQ      |L7.44|
;;;2127     {
;;;2128       /* Disable the Tamper1 interrupt */
;;;2129       hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP1));
000022  6802              LDR      r2,[r0,#0]
000024  6c14              LDR      r4,[r2,#0x40]
000026  4d0c              LDR      r5,|L7.88|
000028  402c              ANDS     r4,r4,r5
00002a  6414              STR      r4,[r2,#0x40]
                  |L7.44|
;;;2130     }
;;;2131   #endif /* RTC_TAMPER1_SUPPORT */
;;;2132     if ((Tamper & RTC_TAMPER_2) != 0U)
00002c  070a              LSLS     r2,r1,#28
00002e  d504              BPL      |L7.58|
;;;2133     {
;;;2134       /* Disable the Tamper2 interrupt */
;;;2135       hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP2));
000030  6802              LDR      r2,[r0,#0]
000032  6c14              LDR      r4,[r2,#0x40]
000034  4d09              LDR      r5,|L7.92|
000036  402c              ANDS     r4,r4,r5
000038  6414              STR      r4,[r2,#0x40]
                  |L7.58|
;;;2136     }
;;;2137   #if defined(RTC_TAMPER3_SUPPORT)
;;;2138     if ((Tamper & RTC_TAMPER_3) != 0U)
00003a  0689              LSLS     r1,r1,#26
00003c  d504              BPL      |L7.72|
;;;2139     {
;;;2140       /* Disable the Tamper3 interrupt */
;;;2141       hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP3));
00003e  6801              LDR      r1,[r0,#0]
000040  6c0a              LDR      r2,[r1,#0x40]
000042  4c07              LDR      r4,|L7.96|
000044  4022              ANDS     r2,r2,r4
000046  640a              STR      r2,[r1,#0x40]
                  |L7.72|
;;;2142     }
;;;2143   #endif /* RTC_TAMPER3_SUPPORT */
;;;2144   
;;;2145     hrtc->State = HAL_RTC_STATE_READY;
000048  3020              ADDS     r0,r0,#0x20
00004a  7043              STRB     r3,[r0,#1]
;;;2146   
;;;2147     /* Process Unlocked */
;;;2148     __HAL_UNLOCK(hrtc);
00004c  2100              MOVS     r1,#0
00004e  7001              STRB     r1,[r0,#0]
;;;2149   
;;;2150     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;2151   }
000052  bd30              POP      {r4,r5,pc}
                  |L7.84|
000054  2002              MOVS     r0,#2                 ;2118
000056  bd30              POP      {r4,r5,pc}
;;;2152   #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
                          ENDP

                  |L7.88|
                          DCD      0xfffefffb
                  |L7.92|
                          DCD      0xfff7fffb
                  |L7.96|
                          DCD      0xffbffffb

                          AREA ||i.HAL_RTCEx_DeactivateTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateTimeStamp PROC
;;;279      */
;;;280    HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282      uint32_t tmpreg;
;;;283    
;;;284      /* Process Locked */
;;;285      __HAL_LOCK(hrtc);
000002  f8901020          LDRB     r1,[r0,#0x20]
000006  2901              CMP      r1,#1
000008  d020              BEQ      |L8.76|
00000a  2301              MOVS     r3,#1
00000c  f8803020          STRB     r3,[r0,#0x20]
;;;286    
;;;287      hrtc->State = HAL_RTC_STATE_BUSY;
000010  2102              MOVS     r1,#2
000012  f8801021          STRB     r1,[r0,#0x21]
;;;288    
;;;289      /* Disable the write protection for RTC registers */
;;;290      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000016  6802              LDR      r2,[r0,#0]
000018  21ca              MOVS     r1,#0xca
00001a  6251              STR      r1,[r2,#0x24]
00001c  6802              LDR      r2,[r0,#0]
00001e  2153              MOVS     r1,#0x53
000020  6251              STR      r1,[r2,#0x24]
;;;291    
;;;292      /* In case of interrupt mode is used, the interrupt source must disabled */
;;;293      __HAL_RTC_TIMESTAMP_DISABLE_IT(hrtc, RTC_IT_TS);
000022  6801              LDR      r1,[r0,#0]
000024  688a              LDR      r2,[r1,#8]
000026  f4224200          BIC      r2,r2,#0x8000
00002a  608a              STR      r2,[r1,#8]
;;;294    
;;;295      /* Get the RTC_CR register and clear the bits to be configured */
;;;296      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
00002c  6801              LDR      r1,[r0,#0]
00002e  688a              LDR      r2,[r1,#8]
000030  f6400408          MOV      r4,#0x808
000034  43a2              BICS     r2,r2,r4
;;;297    
;;;298      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;299      hrtc->Instance->CR = (uint32_t)tmpreg;
000036  608a              STR      r2,[r1,#8]
;;;300    
;;;301      /* Enable the write protection for RTC registers */
;;;302      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000038  6802              LDR      r2,[r0,#0]
00003a  21ff              MOVS     r1,#0xff
00003c  6251              STR      r1,[r2,#0x24]
;;;303    
;;;304      hrtc->State = HAL_RTC_STATE_READY;
00003e  f8803021          STRB     r3,[r0,#0x21]
;;;305    
;;;306      /* Process Unlocked */
;;;307      __HAL_UNLOCK(hrtc);
000042  2100              MOVS     r1,#0
000044  f8801020          STRB     r1,[r0,#0x20]
;;;308    
;;;309      return HAL_OK;
000048  2000              MOVS     r0,#0
;;;310    }
00004a  bd10              POP      {r4,pc}
                  |L8.76|
00004c  2002              MOVS     r0,#2                 ;285
00004e  bd10              POP      {r4,pc}
;;;311    
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateWakeUpTimer PROC
;;;929      */
;;;930    HAL_StatusTypeDef HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;931    {
000004  4604              MOV      r4,r0
;;;932      uint32_t tickstart;
;;;933    
;;;934      /* Process Locked */
;;;935      __HAL_LOCK(hrtc);
000006  f8940020          LDRB     r0,[r4,#0x20]
00000a  2801              CMP      r0,#1
00000c  d01e              BEQ      |L9.76|
00000e  2601              MOVS     r6,#1
000010  f8846020          STRB     r6,[r4,#0x20]
;;;936    
;;;937      hrtc->State = HAL_RTC_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f8840021          STRB     r0,[r4,#0x21]
;;;938    
;;;939      /* Disable the write protection for RTC registers */
;;;940      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00001a  6821              LDR      r1,[r4,#0]
00001c  20ca              MOVS     r0,#0xca
00001e  6248              STR      r0,[r1,#0x24]
000020  6821              LDR      r1,[r4,#0]
000022  2053              MOVS     r0,#0x53
000024  6248              STR      r0,[r1,#0x24]
;;;941    
;;;942      /* Disable the Wakeup Timer */
;;;943      __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
000026  6820              LDR      r0,[r4,#0]
000028  6881              LDR      r1,[r0,#8]
00002a  f4216180          BIC      r1,r1,#0x400
00002e  6081              STR      r1,[r0,#8]
;;;944    
;;;945      /* In case of interrupt mode is used, the interrupt source must disabled */
;;;946      __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc, RTC_IT_WUT);
000030  6820              LDR      r0,[r4,#0]
000032  6881              LDR      r1,[r0,#8]
000034  f4214180          BIC      r1,r1,#0x4000
000038  6081              STR      r1,[r0,#8]
;;;947    
;;;948      tickstart = HAL_GetTick();
00003a  f7fffffe          BL       HAL_GetTick
00003e  4605              MOV      r5,r0
;;;949      /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;950      while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)
000040  2700              MOVS     r7,#0
;;;951      {
;;;952        if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;953        {
;;;954          /* Enable the write protection for RTC registers */
;;;955          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000042  f04f08ff          MOV      r8,#0xff
000046  f44f797a          MOV      r9,#0x3e8             ;952
00004a  e010              B        |L9.110|
                  |L9.76|
00004c  2002              MOVS     r0,#2                 ;935
                  |L9.78|
;;;956    
;;;957          hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;958    
;;;959          /* Process Unlocked */
;;;960          __HAL_UNLOCK(hrtc);
;;;961    
;;;962          return HAL_TIMEOUT;
;;;963        }
;;;964      }
;;;965    
;;;966      /* Enable the write protection for RTC registers */
;;;967      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;968    
;;;969      hrtc->State = HAL_RTC_STATE_READY;
;;;970    
;;;971      /* Process Unlocked */
;;;972      __HAL_UNLOCK(hrtc);
;;;973    
;;;974      return HAL_OK;
;;;975    }
00004e  e8bd87f0          POP      {r4-r10,pc}
                  |L9.82|
000052  f7fffffe          BL       HAL_GetTick
000056  1b40              SUBS     r0,r0,r5              ;952
000058  4548              CMP      r0,r9                 ;952
00005a  d908              BLS      |L9.110|
00005c  6820              LDR      r0,[r4,#0]            ;955
00005e  f8c08024          STR      r8,[r0,#0x24]         ;955
000062  2003              MOVS     r0,#3                 ;957
000064  f8840021          STRB     r0,[r4,#0x21]         ;957
000068  f8847020          STRB     r7,[r4,#0x20]         ;960
00006c  e7ef              B        |L9.78|
                  |L9.110|
00006e  6820              LDR      r0,[r4,#0]            ;950
000070  68c0              LDR      r0,[r0,#0xc]          ;950
000072  0740              LSLS     r0,r0,#29             ;950
000074  d5ed              BPL      |L9.82|
000076  6820              LDR      r0,[r4,#0]            ;967
000078  f8c08024          STR      r8,[r0,#0x24]         ;967
00007c  f8846021          STRB     r6,[r4,#0x21]         ;969
000080  f8847020          STRB     r7,[r4,#0x20]         ;972
000084  2000              MOVS     r0,#0                 ;974
000086  e7e2              B        |L9.78|
;;;976    
                          ENDP


                          AREA ||i.HAL_RTCEx_DisableBypassShadow||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_DisableBypassShadow PROC
;;;1518     */
;;;1519   HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef *hrtc)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;1520   {
;;;1521     /* Process Locked */
;;;1522     __HAL_LOCK(hrtc);
000004  2901              CMP      r1,#1
000006  d01a              BEQ      |L10.62|
000008  2201              MOVS     r2,#1
00000a  f8802020          STRB     r2,[r0,#0x20]
;;;1523   
;;;1524     hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f8801021          STRB     r1,[r0,#0x21]
;;;1525   
;;;1526     /* Disable the write protection for RTC registers */
;;;1527     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000014  6803              LDR      r3,[r0,#0]
000016  21ca              MOVS     r1,#0xca
000018  6259              STR      r1,[r3,#0x24]
00001a  6803              LDR      r3,[r0,#0]
00001c  2153              MOVS     r1,#0x53
00001e  6259              STR      r1,[r3,#0x24]
;;;1528   
;;;1529     /* Clear the BYPSHAD bit */
;;;1530     CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
000020  4908              LDR      r1,|L10.68|
000022  680b              LDR      r3,[r1,#0]
000024  f0230320          BIC      r3,r3,#0x20
000028  600b              STR      r3,[r1,#0]
;;;1531   
;;;1532     /* Enable the write protection for RTC registers */
;;;1533     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00002a  6803              LDR      r3,[r0,#0]
00002c  21ff              MOVS     r1,#0xff
00002e  6259              STR      r1,[r3,#0x24]
;;;1534   
;;;1535     /* Change RTC state */
;;;1536     hrtc->State = HAL_RTC_STATE_READY;
000030  f8802021          STRB     r2,[r0,#0x21]
;;;1537   
;;;1538     /* Process Unlocked */
;;;1539     __HAL_UNLOCK(hrtc);
000034  2100              MOVS     r1,#0
000036  f8801020          STRB     r1,[r0,#0x20]
;;;1540   
;;;1541     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;1542   }
00003c  4770              BX       lr
                  |L10.62|
00003e  2002              MOVS     r0,#2                 ;1522
000040  4770              BX       lr
;;;1543   
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      0x40002808

                          AREA ||i.HAL_RTCEx_EnableBypassShadow||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_EnableBypassShadow PROC
;;;1486     */
;;;1487   HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;1488   {
;;;1489     /* Process Locked */
;;;1490     __HAL_LOCK(hrtc);
000004  2901              CMP      r1,#1
000006  d01a              BEQ      |L11.62|
000008  2201              MOVS     r2,#1
00000a  f8802020          STRB     r2,[r0,#0x20]
;;;1491   
;;;1492     hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f8801021          STRB     r1,[r0,#0x21]
;;;1493   
;;;1494     /* Disable the write protection for RTC registers */
;;;1495     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000014  6803              LDR      r3,[r0,#0]
000016  21ca              MOVS     r1,#0xca
000018  6259              STR      r1,[r3,#0x24]
00001a  6803              LDR      r3,[r0,#0]
00001c  2153              MOVS     r1,#0x53
00001e  6259              STR      r1,[r3,#0x24]
;;;1496   
;;;1497     /* Set the BYPSHAD bit */
;;;1498     SET_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD);
000020  6801              LDR      r1,[r0,#0]
000022  688b              LDR      r3,[r1,#8]
000024  f0430320          ORR      r3,r3,#0x20
000028  608b              STR      r3,[r1,#8]
;;;1499   
;;;1500     /* Enable the write protection for RTC registers */
;;;1501     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00002a  6803              LDR      r3,[r0,#0]
00002c  21ff              MOVS     r1,#0xff
00002e  6259              STR      r1,[r3,#0x24]
;;;1502   
;;;1503     /* Change RTC state */
;;;1504     hrtc->State = HAL_RTC_STATE_READY;
000030  f8802021          STRB     r2,[r0,#0x21]
;;;1505   
;;;1506     /* Process Unlocked */
;;;1507     __HAL_UNLOCK(hrtc);
000034  2100              MOVS     r1,#0
000036  f8801020          STRB     r1,[r0,#0x20]
;;;1508   
;;;1509     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;1510   }
00003c  4770              BX       lr
                  |L11.62|
00003e  2002              MOVS     r0,#2                 ;1490
000040  4770              BX       lr
;;;1511   
                          ENDP


                          AREA ||i.HAL_RTCEx_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_GetTimeStamp PROC
;;;447      */
;;;448    HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTimeStamp, RTC_DateTypeDef *sTimeStampDate, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;449    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;450      uint32_t tmptime, tmpdate;
;;;451    
;;;452      /* Check the parameters */
;;;453      assert_param(IS_RTC_FORMAT(Format));
;;;454    
;;;455      /* Get the TimeStamp time and date registers values */
;;;456      tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
000008  6830              LDR      r0,[r6,#0]
00000a  6b01              LDR      r1,[r0,#0x30]
00000c  4a24              LDR      r2,|L12.160|
00000e  4011              ANDS     r1,r1,r2
;;;457      tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);
000010  6b40              LDR      r0,[r0,#0x34]
000012  f64f723f          MOV      r2,#0xff3f
000016  4010              ANDS     r0,r0,r2
;;;458    
;;;459      /* Fill the Time structure fields with the read parameters */
;;;460      sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TSTR_HT | RTC_TSTR_HU)) >> RTC_TSTR_HU_Pos);
000018  f3c14205          UBFX     r2,r1,#16,#6
00001c  7022              STRB     r2,[r4,#0]
;;;461      sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TSTR_MNT | RTC_TSTR_MNU)) >> RTC_TSTR_MNU_Pos);
00001e  f3c12206          UBFX     r2,r1,#8,#7
000022  7062              STRB     r2,[r4,#1]
;;;462      sTimeStamp->Seconds = (uint8_t)((tmptime & (RTC_TSTR_ST | RTC_TSTR_SU)) >> RTC_TSTR_SU_Pos);
000024  f001027f          AND      r2,r1,#0x7f
000028  70a2              STRB     r2,[r4,#2]
;;;463      sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TSTR_PM)) >> RTC_TSTR_PM_Pos);
00002a  0d89              LSRS     r1,r1,#22
00002c  70e1              STRB     r1,[r4,#3]
;;;464      sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;
00002e  6831              LDR      r1,[r6,#0]
000030  6b89              LDR      r1,[r1,#0x38]
000032  6061              STR      r1,[r4,#4]
;;;465    
;;;466      /* Fill the Date structure fields with the read parameters */
;;;467      sTimeStampDate->Year = 0U;
000034  2100              MOVS     r1,#0
000036  70e9              STRB     r1,[r5,#3]
;;;468      sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_TSDR_MT | RTC_TSDR_MU)) >> RTC_TSDR_MU_Pos);
000038  f3c02104          UBFX     r1,r0,#8,#5
00003c  7069              STRB     r1,[r5,#1]
;;;469      sTimeStampDate->Date = (uint8_t)((tmpdate & (RTC_TSDR_DT | RTC_TSDR_DU)) >> RTC_TSDR_DU_Pos);
00003e  f000013f          AND      r1,r0,#0x3f
000042  70a9              STRB     r1,[r5,#2]
;;;470      sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_TSDR_WDU)) >> RTC_TSDR_WDU_Pos);
000044  f3c03042          UBFX     r0,r0,#13,#3
000048  7028              STRB     r0,[r5,#0]
;;;471    
;;;472      /* Check the input parameters format */
;;;473      if (Format == RTC_FORMAT_BIN)
00004a  2b00              CMP      r3,#0
00004c  d117              BNE      |L12.126|
;;;474      {
;;;475        /* Convert the TimeStamp structure parameters to Binary format */
;;;476        sTimeStamp->Hours = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Hours);
00004e  7820              LDRB     r0,[r4,#0]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  7020              STRB     r0,[r4,#0]
;;;477        sTimeStamp->Minutes = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Minutes);
000056  7860              LDRB     r0,[r4,#1]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7060              STRB     r0,[r4,#1]
;;;478        sTimeStamp->Seconds = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Seconds);
00005e  78a0              LDRB     r0,[r4,#2]
000060  f7fffffe          BL       RTC_Bcd2ToByte
000064  70a0              STRB     r0,[r4,#2]
;;;479    
;;;480        /* Convert the DateTimeStamp structure parameters to Binary format */
;;;481        sTimeStampDate->Month = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Month);
000066  7868              LDRB     r0,[r5,#1]
000068  f7fffffe          BL       RTC_Bcd2ToByte
00006c  7068              STRB     r0,[r5,#1]
;;;482        sTimeStampDate->Date = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Date);
00006e  78a8              LDRB     r0,[r5,#2]
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  70a8              STRB     r0,[r5,#2]
;;;483        sTimeStampDate->WeekDay = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->WeekDay);
000076  7828              LDRB     r0,[r5,#0]
000078  f7fffffe          BL       RTC_Bcd2ToByte
00007c  7028              STRB     r0,[r5,#0]
                  |L12.126|
;;;484      }
;;;485    
;;;486      /* Clear the TIMESTAMP Flags */
;;;487      __HAL_RTC_INTERNAL_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_ITSF);
00007e  6830              LDR      r0,[r6,#0]
000080  68c1              LDR      r1,[r0,#0xc]
000082  f0010180          AND      r1,r1,#0x80
000086  f5a13100          SUB      r1,r1,#0x20000
00008a  3981              SUBS     r1,r1,#0x81
00008c  60c1              STR      r1,[r0,#0xc]
;;;488      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
00008e  6830              LDR      r0,[r6,#0]
000090  68c1              LDR      r1,[r0,#0xc]
000092  f0010180          AND      r1,r1,#0x80
000096  f4616108          ORN      r1,r1,#0x880
00009a  60c1              STR      r1,[r0,#0xc]
;;;489    
;;;490      return HAL_OK;
00009c  2000              MOVS     r0,#0
;;;491    }
00009e  bd70              POP      {r4-r6,pc}
;;;492    #endif /* #if defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
                          ENDP

                  |L12.160|
                          DCD      0x007f7f7f

                          AREA ||i.HAL_RTCEx_GetWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_GetWakeUpTimer PROC
;;;981      */
;;;982    uint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)
000000  6800              LDR      r0,[r0,#0]
;;;983    {
;;;984      /* Get the counter value */
;;;985      return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT));
000002  6940              LDR      r0,[r0,#0x14]
000004  b280              UXTH     r0,r0
;;;986    }
000006  4770              BX       lr
;;;987    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForAlarmBEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForAlarmBEvent PROC
;;;1687     */
;;;1688   HAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1689   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1690     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;1691   
;;;1692     while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == 0U)
00000c  e007              B        |L14.30|
                  |L14.14|
;;;1693     {
;;;1694       if (Timeout != HAL_MAX_DELAY)
00000e  1c60              ADDS     r0,r4,#1
000010  d005              BEQ      |L14.30|
;;;1695       {
;;;1696         if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
000012  f7fffffe          BL       HAL_GetTick
000016  1b80              SUBS     r0,r0,r6
000018  42a0              CMP      r0,r4
00001a  d810              BHI      |L14.62|
00001c  b17c              CBZ      r4,|L14.62|
                  |L14.30|
00001e  6828              LDR      r0,[r5,#0]            ;1692
000020  68c0              LDR      r0,[r0,#0xc]          ;1692
000022  0580              LSLS     r0,r0,#22             ;1692
000024  d5f3              BPL      |L14.14|
;;;1697         {
;;;1698           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1699           return HAL_TIMEOUT;
;;;1700         }
;;;1701       }
;;;1702     }
;;;1703   
;;;1704     /* Clear the Alarm Flag */
;;;1705     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
000026  6828              LDR      r0,[r5,#0]
000028  68c1              LDR      r1,[r0,#0xc]
00002a  f0010180          AND      r1,r1,#0x80
00002e  f4617120          ORN      r1,r1,#0x280
000032  60c1              STR      r1,[r0,#0xc]
;;;1706   
;;;1707     /* Change RTC state */
;;;1708     hrtc->State = HAL_RTC_STATE_READY;
000034  2001              MOVS     r0,#1
000036  f8850021          STRB     r0,[r5,#0x21]
;;;1709   
;;;1710     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;1711   }
00003c  bd70              POP      {r4-r6,pc}
                  |L14.62|
00003e  2003              MOVS     r0,#3                 ;1698
000040  f8850021          STRB     r0,[r5,#0x21]         ;1698
000044  bd70              POP      {r4-r6,pc}
;;;1712   
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTamper1Event||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTamper1Event PROC
;;;2161     */
;;;2162   HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;2163   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2164     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2165   
;;;2166     /* Get the status of the Interrupt */
;;;2167     while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) == 0U)
00000c  e007              B        |L15.30|
                  |L15.14|
;;;2168     {
;;;2169       if (Timeout != HAL_MAX_DELAY)
00000e  1c60              ADDS     r0,r4,#1
000010  d005              BEQ      |L15.30|
;;;2170       {
;;;2171         if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
000012  f7fffffe          BL       HAL_GetTick
000016  1b80              SUBS     r0,r0,r6
000018  42a0              CMP      r0,r4
00001a  d810              BHI      |L15.62|
00001c  b17c              CBZ      r4,|L15.62|
                  |L15.30|
00001e  6828              LDR      r0,[r5,#0]            ;2167
000020  68c0              LDR      r0,[r0,#0xc]          ;2167
000022  0480              LSLS     r0,r0,#18             ;2167
000024  d5f3              BPL      |L15.14|
;;;2172         {
;;;2173           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;2174           return HAL_TIMEOUT;
;;;2175         }
;;;2176       }
;;;2177     }
;;;2178   
;;;2179     /* Clear the Tamper Flag */
;;;2180     __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
000026  6828              LDR      r0,[r5,#0]
000028  68c1              LDR      r1,[r0,#0xc]
00002a  f0010180          AND      r1,r1,#0x80
00002e  f4615102          ORN      r1,r1,#0x2080
000032  60c1              STR      r1,[r0,#0xc]
;;;2181   
;;;2182     /* Change RTC state */
;;;2183     hrtc->State = HAL_RTC_STATE_READY;
000034  2001              MOVS     r0,#1
000036  f8850021          STRB     r0,[r5,#0x21]
;;;2184   
;;;2185     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;2186   }
00003c  bd70              POP      {r4-r6,pc}
                  |L15.62|
00003e  2003              MOVS     r0,#3                 ;2173
000040  f8850021          STRB     r0,[r5,#0x21]         ;2173
000044  bd70              POP      {r4-r6,pc}
;;;2187   #endif /* RTC_TAMPER1_SUPPORT */
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTamper2Event||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTamper2Event PROC
;;;2194     */
;;;2195   HAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;2196   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2197     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2198   
;;;2199     /* Get the status of the Interrupt */
;;;2200     while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == 0U)
00000c  e007              B        |L16.30|
                  |L16.14|
;;;2201     {
;;;2202       if (Timeout != HAL_MAX_DELAY)
00000e  1c60              ADDS     r0,r4,#1
000010  d005              BEQ      |L16.30|
;;;2203       {
;;;2204         if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
000012  f7fffffe          BL       HAL_GetTick
000016  1b80              SUBS     r0,r0,r6
000018  42a0              CMP      r0,r4
00001a  d810              BHI      |L16.62|
00001c  b17c              CBZ      r4,|L16.62|
                  |L16.30|
00001e  6828              LDR      r0,[r5,#0]            ;2200
000020  68c0              LDR      r0,[r0,#0xc]          ;2200
000022  0440              LSLS     r0,r0,#17             ;2200
000024  d5f3              BPL      |L16.14|
;;;2205         {
;;;2206           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;2207           return HAL_TIMEOUT;
;;;2208         }
;;;2209       }
;;;2210     }
;;;2211   
;;;2212     /* Clear the Tamper Flag */
;;;2213     __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
000026  6828              LDR      r0,[r5,#0]
000028  68c1              LDR      r1,[r0,#0xc]
00002a  f0010180          AND      r1,r1,#0x80
00002e  f4614181          ORN      r1,r1,#0x4080
000032  60c1              STR      r1,[r0,#0xc]
;;;2214   
;;;2215     /* Change RTC state */
;;;2216     hrtc->State = HAL_RTC_STATE_READY;
000034  2001              MOVS     r0,#1
000036  f8850021          STRB     r0,[r5,#0x21]
;;;2217   
;;;2218     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;2219   }
00003c  bd70              POP      {r4-r6,pc}
                  |L16.62|
00003e  2003              MOVS     r0,#3                 ;2206
000040  f8850021          STRB     r0,[r5,#0x21]         ;2206
000044  bd70              POP      {r4-r6,pc}
;;;2220   
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTamper3Event||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTamper3Event PROC
;;;2227     */
;;;2228   HAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;2229   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2230     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2231   
;;;2232     /* Get the status of the Interrupt */
;;;2233     while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) == 0U)
00000c  e00b              B        |L17.38|
                  |L17.14|
;;;2234     {
;;;2235       if (Timeout != HAL_MAX_DELAY)
00000e  1c60              ADDS     r0,r4,#1
000010  d009              BEQ      |L17.38|
;;;2236       {
;;;2237         if ((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
000012  b124              CBZ      r4,|L17.30|
000014  f7fffffe          BL       HAL_GetTick
000018  1b80              SUBS     r0,r0,r6
00001a  42a0              CMP      r0,r4
00001c  d903              BLS      |L17.38|
                  |L17.30|
;;;2238         {
;;;2239           hrtc->State = HAL_RTC_STATE_TIMEOUT;
00001e  2003              MOVS     r0,#3
000020  f8850021          STRB     r0,[r5,#0x21]
;;;2240           return HAL_TIMEOUT;
;;;2241         }
;;;2242       }
;;;2243     }
;;;2244   
;;;2245     /* Clear the Tamper Flag */
;;;2246     __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
;;;2247   
;;;2248     /* Change RTC state */
;;;2249     hrtc->State = HAL_RTC_STATE_READY;
;;;2250   
;;;2251     return HAL_OK;
;;;2252   }
000024  bd70              POP      {r4-r6,pc}
                  |L17.38|
000026  6828              LDR      r0,[r5,#0]            ;2233
000028  68c0              LDR      r0,[r0,#0xc]          ;2233
00002a  0400              LSLS     r0,r0,#16             ;2233
00002c  d5ef              BPL      |L17.14|
00002e  6828              LDR      r0,[r5,#0]            ;2246
000030  68c1              LDR      r1,[r0,#0xc]          ;2246
000032  f0010180          AND      r1,r1,#0x80           ;2246
000036  f5a14100          SUB      r1,r1,#0x8000         ;2246
00003a  3981              SUBS     r1,r1,#0x81           ;2246
00003c  60c1              STR      r1,[r0,#0xc]          ;2246
00003e  2001              MOVS     r0,#1                 ;2249
000040  f8850021          STRB     r0,[r5,#0x21]         ;2249
000044  2000              MOVS     r0,#0                 ;2251
000046  bd70              POP      {r4-r6,pc}
;;;2253   #endif /* RTC_TAMPER3_SUPPORT */
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTimeStampEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTimeStampEvent PROC
;;;677      */
;;;678    HAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;679    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;680      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;681    
;;;682      while (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == 0U)
00000c  e016              B        |L18.60|
                  |L18.14|
;;;683      {
;;;684        if (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != 0U)
00000e  68c1              LDR      r1,[r0,#0xc]
000010  04c9              LSLS     r1,r1,#19
000012  d50b              BPL      |L18.44|
;;;685        {
;;;686          /* Clear the TIMESTAMP OverRun Flag */
;;;687          __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
000014  6821              LDR      r1,[r4,#0]
000016  68c9              LDR      r1,[r1,#0xc]
000018  f0010180          AND      r1,r1,#0x80
00001c  f4615184          ORN      r1,r1,#0x1080
000020  60c1              STR      r1,[r0,#0xc]
;;;688    
;;;689          /* Change TIMESTAMP state */
;;;690          hrtc->State = HAL_RTC_STATE_ERROR;
000022  2004              MOVS     r0,#4
000024  f8840021          STRB     r0,[r4,#0x21]
;;;691    
;;;692          return HAL_ERROR;
000028  2001              MOVS     r0,#1
;;;693        }
;;;694    
;;;695        if (Timeout != HAL_MAX_DELAY)
;;;696        {
;;;697          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;698          {
;;;699            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;700            return HAL_TIMEOUT;
;;;701          }
;;;702        }
;;;703      }
;;;704    
;;;705      /* Change RTC state */
;;;706      hrtc->State = HAL_RTC_STATE_READY;
;;;707    
;;;708      return HAL_OK;
;;;709    }
00002a  bd70              POP      {r4-r6,pc}
                  |L18.44|
00002c  1c68              ADDS     r0,r5,#1              ;695
00002e  d005              BEQ      |L18.60|
000030  f7fffffe          BL       HAL_GetTick
000034  1b80              SUBS     r0,r0,r6              ;697
000036  42a8              CMP      r0,r5                 ;697
000038  d809              BHI      |L18.78|
00003a  b145              CBZ      r5,|L18.78|
                  |L18.60|
00003c  6820              LDR      r0,[r4,#0]            ;682
00003e  68c1              LDR      r1,[r0,#0xc]          ;682
000040  0509              LSLS     r1,r1,#20             ;682
000042  d5e4              BPL      |L18.14|
000044  2001              MOVS     r0,#1                 ;706
000046  f8840021          STRB     r0,[r4,#0x21]         ;706
00004a  2000              MOVS     r0,#0                 ;708
00004c  bd70              POP      {r4-r6,pc}
                  |L18.78|
00004e  2003              MOVS     r0,#3                 ;699
000050  f8840021          STRB     r0,[r4,#0x21]         ;699
000054  bd70              POP      {r4-r6,pc}
;;;710    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForWakeUpTimerEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForWakeUpTimerEvent PROC
;;;1046     */
;;;1047   HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1048   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1049     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;1050   
;;;1051     while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == 0U)
00000c  e007              B        |L19.30|
                  |L19.14|
;;;1052     {
;;;1053       if (Timeout != HAL_MAX_DELAY)
00000e  1c60              ADDS     r0,r4,#1
000010  d005              BEQ      |L19.30|
;;;1054       {
;;;1055         if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
000012  f7fffffe          BL       HAL_GetTick
000016  1b80              SUBS     r0,r0,r6
000018  42a0              CMP      r0,r4
00001a  d810              BHI      |L19.62|
00001c  b17c              CBZ      r4,|L19.62|
                  |L19.30|
00001e  6828              LDR      r0,[r5,#0]            ;1051
000020  68c0              LDR      r0,[r0,#0xc]          ;1051
000022  0540              LSLS     r0,r0,#21             ;1051
000024  d5f3              BPL      |L19.14|
;;;1056         {
;;;1057           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1058           return HAL_TIMEOUT;
;;;1059         }
;;;1060       }
;;;1061     }
;;;1062   
;;;1063     /* Clear the WAKEUPTIMER Flag */
;;;1064     __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
000026  6828              LDR      r0,[r5,#0]
000028  68c1              LDR      r1,[r0,#0xc]
00002a  f0010180          AND      r1,r1,#0x80
00002e  f4616190          ORN      r1,r1,#0x480
000032  60c1              STR      r1,[r0,#0xc]
;;;1065   
;;;1066     /* Change RTC state */
;;;1067     hrtc->State = HAL_RTC_STATE_READY;
000034  2001              MOVS     r0,#1
000036  f8850021          STRB     r0,[r5,#0x21]
;;;1068   
;;;1069     return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;1070   }
00003c  bd70              POP      {r4-r6,pc}
                  |L19.62|
00003e  2003              MOVS     r0,#3                 ;1057
000040  f8850021          STRB     r0,[r5,#0x21]         ;1057
000044  bd70              POP      {r4-r6,pc}
;;;1071   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetCalibrationOutPut||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetCalibrationOutPut PROC
;;;1335     */
;;;1336   HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef *hrtc, uint32_t CalibOutput)
000000  b510              PUSH     {r4,lr}
;;;1337   {
;;;1338     /* Check the parameters */
;;;1339     assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));
;;;1340   
;;;1341     /* Process Locked */
;;;1342     __HAL_LOCK(hrtc);
000002  f8902020          LDRB     r2,[r0,#0x20]
000006  2a01              CMP      r2,#1
000008  d023              BEQ      |L20.82|
00000a  2401              MOVS     r4,#1
00000c  f8804020          STRB     r4,[r0,#0x20]
;;;1343   
;;;1344     hrtc->State = HAL_RTC_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  f8802021          STRB     r2,[r0,#0x21]
;;;1345   
;;;1346     /* Disable the write protection for RTC registers */
;;;1347     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000016  6803              LDR      r3,[r0,#0]
000018  22ca              MOVS     r2,#0xca
00001a  625a              STR      r2,[r3,#0x24]
00001c  6803              LDR      r3,[r0,#0]
00001e  2253              MOVS     r2,#0x53
000020  625a              STR      r2,[r3,#0x24]
;;;1348   
;;;1349     /* Clear flags before config */
;;;1350     hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;
000022  6802              LDR      r2,[r0,#0]
000024  6893              LDR      r3,[r2,#8]
000026  f4232300          BIC      r3,r3,#0x80000
00002a  6093              STR      r3,[r2,#8]
;;;1351   
;;;1352     /* Configure the RTC_CR register */
;;;1353     hrtc->Instance->CR |= (uint32_t)CalibOutput;
00002c  6802              LDR      r2,[r0,#0]
00002e  6893              LDR      r3,[r2,#8]
000030  430b              ORRS     r3,r3,r1
000032  6093              STR      r3,[r2,#8]
;;;1354   
;;;1355     __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);
000034  6801              LDR      r1,[r0,#0]
000036  688a              LDR      r2,[r1,#8]
000038  f4420200          ORR      r2,r2,#0x800000
00003c  608a              STR      r2,[r1,#8]
;;;1356   
;;;1357     /* Enable the write protection for RTC registers */
;;;1358     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00003e  6802              LDR      r2,[r0,#0]
000040  21ff              MOVS     r1,#0xff
000042  6251              STR      r1,[r2,#0x24]
;;;1359   
;;;1360     /* Change RTC state */
;;;1361     hrtc->State = HAL_RTC_STATE_READY;
000044  f8804021          STRB     r4,[r0,#0x21]
;;;1362   
;;;1363     /* Process Unlocked */
;;;1364     __HAL_UNLOCK(hrtc);
000048  2100              MOVS     r1,#0
00004a  f8801020          STRB     r1,[r0,#0x20]
;;;1365   
;;;1366     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;1367   }
000050  bd10              POP      {r4,pc}
                  |L20.82|
000052  2002              MOVS     r0,#2                 ;1342
000054  bd10              POP      {r4,pc}
;;;1368   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetInternalTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetInternalTimeStamp PROC
;;;317      */
;;;318    HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;319    {
;;;320      /* Process Locked */
;;;321      __HAL_LOCK(hrtc);
000004  2901              CMP      r1,#1
000006  d01a              BEQ      |L21.62|
000008  2201              MOVS     r2,#1
00000a  f8802020          STRB     r2,[r0,#0x20]
;;;322    
;;;323      hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f8801021          STRB     r1,[r0,#0x21]
;;;324    
;;;325      /* Disable the write protection for RTC registers */
;;;326      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000014  6803              LDR      r3,[r0,#0]
000016  21ca              MOVS     r1,#0xca
000018  6259              STR      r1,[r3,#0x24]
00001a  6803              LDR      r3,[r0,#0]
00001c  2153              MOVS     r1,#0x53
00001e  6259              STR      r1,[r3,#0x24]
;;;327    
;;;328      /* Configure the internal Time Stamp Enable bits */
;;;329      __HAL_RTC_INTERNAL_TIMESTAMP_ENABLE(hrtc);
000020  6801              LDR      r1,[r0,#0]
000022  688b              LDR      r3,[r1,#8]
000024  f0437380          ORR      r3,r3,#0x1000000
000028  608b              STR      r3,[r1,#8]
;;;330    
;;;331      /* Enable the write protection for RTC registers */
;;;332      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00002a  6803              LDR      r3,[r0,#0]
00002c  21ff              MOVS     r1,#0xff
00002e  6259              STR      r1,[r3,#0x24]
;;;333    
;;;334      /* Change RTC state */
;;;335      hrtc->State = HAL_RTC_STATE_READY;
000030  f8802021          STRB     r2,[r0,#0x21]
;;;336    
;;;337      /* Process Unlocked */
;;;338      __HAL_UNLOCK(hrtc);
000034  2100              MOVS     r1,#0
000036  f8801020          STRB     r1,[r0,#0x20]
;;;339    
;;;340      return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;341    }
00003c  4770              BX       lr
                  |L21.62|
00003e  2002              MOVS     r0,#2                 ;321
000040  4770              BX       lr
;;;342    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetRefClock||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetRefClock PROC
;;;1402     */
;;;1403   HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1404   {
000002  4604              MOV      r4,r0
;;;1405     HAL_StatusTypeDef status;
;;;1406   
;;;1407     /* Process Locked */
;;;1408     __HAL_LOCK(hrtc);
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2801              CMP      r0,#1
00000a  d010              BEQ      |L22.46|
00000c  2501              MOVS     r5,#1
00000e  f8845020          STRB     r5,[r4,#0x20]
;;;1409   
;;;1410     hrtc->State = HAL_RTC_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840021          STRB     r0,[r4,#0x21]
;;;1411   
;;;1412     /* Disable the write protection for RTC registers */
;;;1413     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000018  6821              LDR      r1,[r4,#0]
00001a  20ca              MOVS     r0,#0xca
00001c  6248              STR      r0,[r1,#0x24]
00001e  6821              LDR      r1,[r4,#0]
000020  2053              MOVS     r0,#0x53
000022  6248              STR      r0,[r1,#0x24]
;;;1414   
;;;1415     /* Enter Initialization mode */
;;;1416     status = RTC_EnterInitMode(hrtc);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RTC_EnterInitMode
00002a  b110              CBZ      r0,|L22.50|
00002c  e009              B        |L22.66|
                  |L22.46|
00002e  2002              MOVS     r0,#2                 ;1408
;;;1417     if (status == HAL_OK)
;;;1418     {
;;;1419       __HAL_RTC_CLOCKREF_DETECTION_ENABLE(hrtc);
;;;1420   
;;;1421       /* Exit Initialization mode */
;;;1422       status = RTC_ExitInitMode(hrtc);
;;;1423     }
;;;1424   
;;;1425     /* Enable the write protection for RTC registers */
;;;1426     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1427   
;;;1428     if (status == HAL_OK)
;;;1429     {
;;;1430       hrtc->State = HAL_RTC_STATE_READY;
;;;1431     }
;;;1432   
;;;1433     /* Process Unlocked */
;;;1434     __HAL_UNLOCK(hrtc);
;;;1435   
;;;1436     return status;
;;;1437   }
000030  bd70              POP      {r4-r6,pc}
                  |L22.50|
000032  6820              LDR      r0,[r4,#0]            ;1419
000034  6881              LDR      r1,[r0,#8]            ;1419
000036  f0410110          ORR      r1,r1,#0x10           ;1419
00003a  6081              STR      r1,[r0,#8]            ;1419
00003c  4620              MOV      r0,r4                 ;1422
00003e  f7fffffe          BL       RTC_ExitInitMode
                  |L22.66|
000042  6822              LDR      r2,[r4,#0]            ;1426
000044  21ff              MOVS     r1,#0xff              ;1426
000046  6251              STR      r1,[r2,#0x24]         ;1426
000048  b908              CBNZ     r0,|L22.78|
00004a  f8845021          STRB     r5,[r4,#0x21]         ;1430
                  |L22.78|
00004e  2100              MOVS     r1,#0                 ;1434
000050  f8841020          STRB     r1,[r4,#0x20]         ;1434
000054  bd70              POP      {r4-r6,pc}
;;;1438   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSmoothCalib||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetSmoothCalib PROC
;;;1123     */
;;;1124   HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1125   {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
;;;1126     uint32_t tickstart;
;;;1127   
;;;1128     /* Check the parameters */
;;;1129     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
;;;1130     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
;;;1131     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));
;;;1132   
;;;1133     /* Process Locked */
;;;1134     __HAL_LOCK(hrtc);
00000a  f8940020          LDRB     r0,[r4,#0x20]
00000e  2801              CMP      r0,#1
000010  d019              BEQ      |L23.70|
000012  2601              MOVS     r6,#1
000014  f8846020          STRB     r6,[r4,#0x20]
;;;1135   
;;;1136     hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f8840021          STRB     r0,[r4,#0x21]
;;;1137   
;;;1138     /* Disable the write protection for RTC registers */
;;;1139     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00001e  6821              LDR      r1,[r4,#0]
000020  20ca              MOVS     r0,#0xca
000022  6248              STR      r0,[r1,#0x24]
000024  6821              LDR      r1,[r4,#0]
000026  2053              MOVS     r0,#0x53
000028  6248              STR      r0,[r1,#0x24]
;;;1140   
;;;1141     /* check if a calibration is pending*/
;;;1142   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;1143     if ((hrtc->Instance->ICSR & RTC_ICSR_RECALPF) != 0U)
;;;1144   #else
;;;1145     if ((hrtc->Instance->ISR & RTC_ISR_RECALPF) != 0U)
00002a  6820              LDR      r0,[r4,#0]
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  f04f0700          MOV      r7,#0
000032  03c0              LSLS     r0,r0,#15
;;;1146   #endif
;;;1147     {
;;;1148       tickstart = HAL_GetTick();
;;;1149   
;;;1150       /* check if a calibration is pending*/
;;;1151   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;1152       while ((hrtc->Instance->ICSR & RTC_ICSR_RECALPF) != 0U)
;;;1153   #else
;;;1154       while ((hrtc->Instance->ISR & RTC_ISR_RECALPF) != 0U)
;;;1155   #endif
;;;1156       {
;;;1157         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1158         {
;;;1159           /* Enable the write protection for RTC registers */
;;;1160           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000034  f04f08ff          MOV      r8,#0xff
000038  d51b              BPL      |L23.114|
00003a  f7fffffe          BL       HAL_GetTick
00003e  4605              MOV      r5,r0                 ;1148
000040  f44f797a          MOV      r9,#0x3e8             ;1157
000044  e011              B        |L23.106|
                  |L23.70|
000046  2002              MOVS     r0,#2                 ;1134
                  |L23.72|
;;;1161   
;;;1162           /* Change RTC state */
;;;1163           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1164   
;;;1165           /* Process Unlocked */
;;;1166           __HAL_UNLOCK(hrtc);
;;;1167   
;;;1168           return HAL_TIMEOUT;
;;;1169         }
;;;1170       }
;;;1171     }
;;;1172   
;;;1173     /* Configure the Smooth calibration settings */
;;;1174     MODIFY_REG(hrtc->Instance->CALR, (RTC_CALR_CALP | RTC_CALR_CALW8 | RTC_CALR_CALW16 | RTC_CALR_CALM), (uint32_t)(SmoothCalibPeriod | SmoothCalibPlusPulses | SmoothCalibMinusPulsesValue));
;;;1175   
;;;1176     /* Enable the write protection for RTC registers */
;;;1177     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1178   
;;;1179     /* Change RTC state */
;;;1180     hrtc->State = HAL_RTC_STATE_READY;
;;;1181   
;;;1182     /* Process Unlocked */
;;;1183     __HAL_UNLOCK(hrtc);
;;;1184   
;;;1185     return HAL_OK;
;;;1186   }
000048  b004              ADD      sp,sp,#0x10
00004a  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.78|
00004e  f7fffffe          BL       HAL_GetTick
000052  1b40              SUBS     r0,r0,r5              ;1157
000054  4548              CMP      r0,r9                 ;1157
000056  d908              BLS      |L23.106|
000058  6820              LDR      r0,[r4,#0]            ;1160
00005a  f8c08024          STR      r8,[r0,#0x24]         ;1160
00005e  2003              MOVS     r0,#3                 ;1163
000060  f8840021          STRB     r0,[r4,#0x21]         ;1163
000064  f8847020          STRB     r7,[r4,#0x20]         ;1166
000068  e7ee              B        |L23.72|
                  |L23.106|
00006a  6820              LDR      r0,[r4,#0]            ;1154
00006c  68c0              LDR      r0,[r0,#0xc]          ;1154
00006e  03c0              LSLS     r0,r0,#15             ;1154
000070  d4ed              BMI      |L23.78|
                  |L23.114|
000072  6820              LDR      r0,[r4,#0]            ;1174
000074  6bc1              LDR      r1,[r0,#0x3c]         ;1174
000076  f24e12ff          MOV      r2,#0xe1ff            ;1174
00007a  4391              BICS     r1,r1,r2              ;1174
00007c  9a03              LDR      r2,[sp,#0xc]          ;1174
00007e  ea4a0a0b          ORR      r10,r10,r11           ;1174
000082  ea4a0a02          ORR      r10,r10,r2            ;1174
000086  ea41010a          ORR      r1,r1,r10             ;1174
00008a  63c1              STR      r1,[r0,#0x3c]         ;1174
00008c  6820              LDR      r0,[r4,#0]            ;1177
00008e  f8c08024          STR      r8,[r0,#0x24]         ;1177
000092  f8846021          STRB     r6,[r4,#0x21]         ;1180
000096  f8847020          STRB     r7,[r4,#0x20]         ;1183
00009a  2000              MOVS     r0,#0                 ;1185
00009c  e7d4              B        |L23.72|
;;;1187   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSynchroShift||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetSynchroShift PROC
;;;1238     */
;;;1239   HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef *hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1240   {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
000008  4692              MOV      r10,r2
;;;1241     uint32_t tickstart;
;;;1242   
;;;1243     /* Check the parameters */
;;;1244     assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
;;;1245     assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));
;;;1246   
;;;1247     /* Process Locked */
;;;1248     __HAL_LOCK(hrtc);
00000a  f8940020          LDRB     r0,[r4,#0x20]
00000e  2801              CMP      r0,#1
000010  d014              BEQ      |L24.60|
000012  f04f0801          MOV      r8,#1
000016  f8848020          STRB     r8,[r4,#0x20]
;;;1249   
;;;1250     hrtc->State = HAL_RTC_STATE_BUSY;
00001a  2002              MOVS     r0,#2
00001c  f8840021          STRB     r0,[r4,#0x21]
;;;1251   
;;;1252     /* Disable the write protection for RTC registers */
;;;1253     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000020  6821              LDR      r1,[r4,#0]
000022  20ca              MOVS     r0,#0xca
000024  6248              STR      r0,[r1,#0x24]
000026  6821              LDR      r1,[r4,#0]
000028  2053              MOVS     r0,#0x53
00002a  6248              STR      r0,[r1,#0x24]
;;;1254   
;;;1255     tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4605              MOV      r5,r0
;;;1256   
;;;1257     /* Wait until the shift is completed*/
;;;1258   #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;1259     while ((hrtc->Instance->ICSR & RTC_ICSR_SHPF) != 0U)
;;;1260   #else
;;;1261     while ((hrtc->Instance->ISR & RTC_ISR_SHPF) != 0U)
000032  2600              MOVS     r6,#0
;;;1262   #endif
;;;1263     {
;;;1264       if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1265       {
;;;1266         /* Enable the write protection for RTC registers */
;;;1267         __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000034  27ff              MOVS     r7,#0xff
000036  f44f797a          MOV      r9,#0x3e8             ;1264
00003a  e00f              B        |L24.92|
                  |L24.60|
00003c  2002              MOVS     r0,#2                 ;1248
                  |L24.62|
;;;1268   
;;;1269         hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1270   
;;;1271         /* Process Unlocked */
;;;1272         __HAL_UNLOCK(hrtc);
;;;1273   
;;;1274         return HAL_TIMEOUT;
;;;1275       }
;;;1276     }
;;;1277   
;;;1278     /* Check if the reference clock detection is disabled */
;;;1279     if ((hrtc->Instance->CR & RTC_CR_REFCKON) == 0U)
;;;1280     {
;;;1281       /* Configure the Shift settings */
;;;1282       hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);
;;;1283   
;;;1284       /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;1285       if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
;;;1286       {
;;;1287         if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;1288         {
;;;1289           /* Enable the write protection for RTC registers */
;;;1290           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1291   
;;;1292           hrtc->State = HAL_RTC_STATE_ERROR;
;;;1293   
;;;1294           /* Process Unlocked */
;;;1295           __HAL_UNLOCK(hrtc);
;;;1296   
;;;1297           return HAL_ERROR;
;;;1298         }
;;;1299       }
;;;1300     }
;;;1301     else
;;;1302     {
;;;1303       /* Enable the write protection for RTC registers */
;;;1304       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1305   
;;;1306       /* Change RTC state */
;;;1307       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1308   
;;;1309       /* Process Unlocked */
;;;1310       __HAL_UNLOCK(hrtc);
;;;1311   
;;;1312       return HAL_ERROR;
;;;1313     }
;;;1314   
;;;1315     /* Enable the write protection for RTC registers */
;;;1316     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1317   
;;;1318     /* Change RTC state */
;;;1319     hrtc->State = HAL_RTC_STATE_READY;
;;;1320   
;;;1321     /* Process Unlocked */
;;;1322     __HAL_UNLOCK(hrtc);
;;;1323   
;;;1324     return HAL_OK;
;;;1325   }
00003e  e8bd9ff0          POP      {r4-r12,pc}
                  |L24.66|
000042  f7fffffe          BL       HAL_GetTick
000046  1b40              SUBS     r0,r0,r5              ;1264
000048  4548              CMP      r0,r9                 ;1264
00004a  d907              BLS      |L24.92|
00004c  6820              LDR      r0,[r4,#0]            ;1267
00004e  6247              STR      r7,[r0,#0x24]         ;1267
000050  2003              MOVS     r0,#3                 ;1269
000052  f8840021          STRB     r0,[r4,#0x21]         ;1269
000056  f8846020          STRB     r6,[r4,#0x20]         ;1272
00005a  e7f0              B        |L24.62|
                  |L24.92|
00005c  6820              LDR      r0,[r4,#0]            ;1261
00005e  68c0              LDR      r0,[r0,#0xc]          ;1261
000060  0700              LSLS     r0,r0,#28             ;1261
000062  d4ee              BMI      |L24.66|
000064  6820              LDR      r0,[r4,#0]            ;1279
000066  6881              LDR      r1,[r0,#8]            ;1279
000068  f04f0504          MOV      r5,#4                 ;1292
00006c  06c9              LSLS     r1,r1,#27             ;1279
00006e  d413              BMI      |L24.152|
000070  ea4a0a0b          ORR      r10,r10,r11           ;1282
000074  f8c0a02c          STR      r10,[r0,#0x2c]        ;1282
000078  6820              LDR      r0,[r4,#0]            ;1285
00007a  6880              LDR      r0,[r0,#8]            ;1285
00007c  0680              LSLS     r0,r0,#26             ;1285
00007e  d411              BMI      |L24.164|
000080  4620              MOV      r0,r4                 ;1287
000082  f7fffffe          BL       HAL_RTC_WaitForSynchro
000086  b168              CBZ      r0,|L24.164|
000088  6820              LDR      r0,[r4,#0]            ;1290
00008a  6247              STR      r7,[r0,#0x24]         ;1290
00008c  f8845021          STRB     r5,[r4,#0x21]         ;1292
000090  f8846020          STRB     r6,[r4,#0x20]         ;1295
000094  2001              MOVS     r0,#1                 ;1297
000096  e7d2              B        |L24.62|
                  |L24.152|
000098  6247              STR      r7,[r0,#0x24]         ;1304
00009a  3420              ADDS     r4,r4,#0x20           ;1307
00009c  7065              STRB     r5,[r4,#1]            ;1307
00009e  7026              STRB     r6,[r4,#0]            ;1310
0000a0  2001              MOVS     r0,#1                 ;1312
0000a2  e7cc              B        |L24.62|
                  |L24.164|
0000a4  6820              LDR      r0,[r4,#0]            ;1316
0000a6  6247              STR      r7,[r0,#0x24]         ;1316
0000a8  f8848021          STRB     r8,[r4,#0x21]         ;1319
0000ac  f8846020          STRB     r6,[r4,#0x20]         ;1322
0000b0  2000              MOVS     r0,#0                 ;1324
0000b2  e7c4              B        |L24.62|
;;;1326   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTamper||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTamper PROC
;;;1819     */
;;;1820   HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef *sTamper)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1821   {
;;;1822     uint32_t tmpreg;
;;;1823   
;;;1824     /* Check the parameters */
;;;1825     assert_param(IS_RTC_TAMPER(sTamper->Tamper));
;;;1826     assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;1827     assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));
;;;1828     assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));
;;;1829     assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
;;;1830     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
;;;1831     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
;;;1832     assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
;;;1833     assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
;;;1834   
;;;1835     /* Process Locked */
;;;1836     __HAL_LOCK(hrtc);
000004  f8902020          LDRB     r2,[r0,#0x20]
000008  2a01              CMP      r2,#1
00000a  d032              BEQ      |L25.114|
00000c  f04f0c01          MOV      r12,#1
000010  f880c020          STRB     r12,[r0,#0x20]
;;;1837   
;;;1838     hrtc->State = HAL_RTC_STATE_BUSY;
000014  2202              MOVS     r2,#2
000016  f8802021          STRB     r2,[r0,#0x21]
;;;1839   
;;;1840     /* Read register */
;;;1841     tmpreg = hrtc->Instance->TAMPCR;
00001a  6805              LDR      r5,[r0,#0]
00001c  6c2a              LDR      r2,[r5,#0x40]
;;;1842   
;;;1843   #if defined(RTC_TAMPER1_SUPPORT)
;;;1844     if ((sTamper->Tamper & RTC_TAMPER_1) != 0)
00001e  680b              LDR      r3,[r1,#0]
;;;1845     {
;;;1846       MODIFY_REG(tmpreg,
000020  f44f2880          MOV      r8,#0x40000
000024  07dc              LSLS     r4,r3,#31             ;1844
000026  d013              BEQ      |L25.80|
000028  688c              LDR      r4,[r1,#8]
00002a  b32c              CBZ      r4,|L25.120|
00002c  2602              MOVS     r6,#2
                  |L25.46|
00002e  68cc              LDR      r4,[r1,#0xc]
000030  ea430706          ORR      r7,r3,r6
000034  b314              CBZ      r4,|L25.124|
000036  f44f3600          MOV      r6,#0x20000
                  |L25.58|
00003a  f8d19010          LDR      r9,[r1,#0x10]
00003e  4644              MOV      r4,r8
000040  45a1              CMP      r9,r4
000042  d000              BEQ      |L25.70|
000044  2400              MOVS     r4,#0
                  |L25.70|
000046  4326              ORRS     r6,r6,r4
000048  4337              ORRS     r7,r7,r6
00004a  f0221207          BIC      r2,r2,#0x70007
00004e  433a              ORRS     r2,r2,r7
                  |L25.80|
;;;1847                  (RTC_TAMPCR_TAMP1E | RTC_TAMPCR_TAMP1TRG | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP1IE | RTC_TAMPCR_TAMP1NOERASE | RTC_TAMPCR_TAMP1MF), \
;;;1848                  sTamper->Tamper | \
;;;1849                  (sTamper->Trigger == RTC_TAMPERTRIGGER_RISINGEDGE ?  0U : RTC_TAMPCR_TAMP1TRG) | \
;;;1850                  (sTamper->NoErase == RTC_TAMPER_ERASE_BACKUP_ENABLE ? 0U : RTC_TAMPCR_TAMP1NOERASE ) | \
;;;1851                  (sTamper->MaskFlag == RTC_TAMPERMASK_FLAG_ENABLE ? RTC_TAMPCR_TAMP1MF : 0U) \
;;;1852                 );
;;;1853     }
;;;1854   #endif /* RTC_TAMPER1_SUPPORT */
;;;1855   
;;;1856   #if defined(RTC_TAMPER2_SUPPORT)
;;;1857     if ((sTamper->Tamper & RTC_TAMPER_2) != 0)
000050  071c              LSLS     r4,r3,#28
000052  d51f              BPL      |L25.148|
;;;1858     {
;;;1859       MODIFY_REG(tmpreg,
000054  688c              LDR      r4,[r1,#8]
000056  b19c              CBZ      r4,|L25.128|
000058  2610              MOVS     r6,#0x10
                  |L25.90|
00005a  ea430406          ORR      r4,r3,r6
00005e  68ce              LDR      r6,[r1,#0xc]
000060  b186              CBZ      r6,|L25.132|
000062  f44f1680          MOV      r6,#0x100000
                  |L25.102|
000066  690f              LDR      r7,[r1,#0x10]
000068  4547              CMP      r7,r8
00006a  d10d              BNE      |L25.136|
00006c  f44f1700          MOV      r7,#0x200000
000070  e00b              B        |L25.138|
                  |L25.114|
000072  2002              MOVS     r0,#2                 ;1836
                  |L25.116|
;;;1860                  (RTC_TAMPCR_TAMP2E | RTC_TAMPCR_TAMP2TRG | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP2NOERASE | RTC_TAMPCR_TAMP2MF), \
;;;1861                  sTamper->Tamper | \
;;;1862                  (sTamper->Trigger == RTC_TAMPERTRIGGER_RISINGEDGE ?  0U : RTC_TAMPCR_TAMP2TRG) | \
;;;1863                  (sTamper->NoErase == RTC_TAMPER_ERASE_BACKUP_ENABLE ? 0U : RTC_TAMPCR_TAMP2NOERASE ) | \
;;;1864                  (sTamper->MaskFlag == RTC_TAMPERMASK_FLAG_ENABLE ? RTC_TAMPCR_TAMP2MF : 0U) \
;;;1865                 );
;;;1866     }
;;;1867   #endif /* RTC_TAMPER2_SUPPORT */
;;;1868   
;;;1869   #if defined(RTC_TAMPER3_SUPPORT)
;;;1870     if ((sTamper->Tamper & RTC_TAMPER_3) != 0)
;;;1871     {
;;;1872       MODIFY_REG(tmpreg,
;;;1873                  (RTC_TAMPCR_TAMP3E | RTC_TAMPCR_TAMP3TRG | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP3IE | RTC_TAMPCR_TAMP3NOERASE | RTC_TAMPCR_TAMP3MF), \
;;;1874                  sTamper->Tamper | \
;;;1875                  (sTamper->Trigger == RTC_TAMPERTRIGGER_RISINGEDGE ?  0U : RTC_TAMPCR_TAMP3TRG) | \
;;;1876                  (sTamper->NoErase == RTC_TAMPER_ERASE_BACKUP_ENABLE ? 0U : RTC_TAMPCR_TAMP3NOERASE ) | \
;;;1877                  (sTamper->MaskFlag == RTC_TAMPERMASK_FLAG_ENABLE ? RTC_TAMPCR_TAMP3MF : 0U) \
;;;1878                 );
;;;1879     }
;;;1880   #endif /* RTC_TAMPER3_SUPPORT */
;;;1881   
;;;1882     /* Update common parameters */
;;;1883     MODIFY_REG(tmpreg,
;;;1884                (RTC_TAMPCR_TAMPTS | RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH | RTC_TAMPCR_TAMPPUDIS), \
;;;1885                sTamper->Filter | sTamper->SamplingFrequency | sTamper->PrechargeDuration | sTamper->TamperPullUp | \
;;;1886                sTamper->TimeStampOnTamperDetection \
;;;1887                );
;;;1888   
;;;1889     /* Set register */
;;;1890     WRITE_REG (hrtc->Instance->TAMPCR, tmpreg);
;;;1891   
;;;1892     hrtc->State = HAL_RTC_STATE_READY;
;;;1893   
;;;1894     /* Process Unlocked */
;;;1895     __HAL_UNLOCK(hrtc);
;;;1896   
;;;1897     return HAL_OK;
;;;1898   }
000074  e8bd83f0          POP      {r4-r9,pc}
                  |L25.120|
000078  2600              MOVS     r6,#0                 ;1846
00007a  e7d8              B        |L25.46|
                  |L25.124|
00007c  2600              MOVS     r6,#0                 ;1846
00007e  e7dc              B        |L25.58|
                  |L25.128|
000080  2600              MOVS     r6,#0                 ;1859
000082  e7ea              B        |L25.90|
                  |L25.132|
000084  2600              MOVS     r6,#0                 ;1859
000086  e7ee              B        |L25.102|
                  |L25.136|
000088  2700              MOVS     r7,#0                 ;1859
                  |L25.138|
00008a  433e              ORRS     r6,r6,r7              ;1859
00008c  4334              ORRS     r4,r4,r6              ;1859
00008e  4e19              LDR      r6,|L25.244|
000090  4032              ANDS     r2,r2,r6              ;1859
000092  4322              ORRS     r2,r2,r4              ;1859
                  |L25.148|
000094  069c              LSLS     r4,r3,#26             ;1870
000096  d518              BPL      |L25.202|
000098  688c              LDR      r4,[r1,#8]            ;1872
00009a  b164              CBZ      r4,|L25.182|
00009c  2440              MOVS     r4,#0x40              ;1872
                  |L25.158|
00009e  ea430604          ORR      r6,r3,r4              ;1872
0000a2  68cb              LDR      r3,[r1,#0xc]          ;1872
0000a4  b14b              CBZ      r3,|L25.186|
0000a6  f44f0300          MOV      r3,#0x800000          ;1872
                  |L25.170|
0000aa  690c              LDR      r4,[r1,#0x10]         ;1872
0000ac  4544              CMP      r4,r8                 ;1872
0000ae  d106              BNE      |L25.190|
0000b0  f04f7480          MOV      r4,#0x1000000         ;1872
0000b4  e004              B        |L25.192|
                  |L25.182|
0000b6  2400              MOVS     r4,#0                 ;1872
0000b8  e7f1              B        |L25.158|
                  |L25.186|
0000ba  2300              MOVS     r3,#0                 ;1872
0000bc  e7f5              B        |L25.170|
                  |L25.190|
0000be  2400              MOVS     r4,#0                 ;1872
                  |L25.192|
0000c0  4323              ORRS     r3,r3,r4              ;1872
0000c2  431e              ORRS     r6,r6,r3              ;1872
0000c4  4b0c              LDR      r3,|L25.248|
0000c6  401a              ANDS     r2,r2,r3              ;1872
0000c8  4332              ORRS     r2,r2,r6              ;1872
                  |L25.202|
0000ca  e9d13405          LDRD     r3,r4,[r1,#0x14]      ;1883
0000ce  4323              ORRS     r3,r3,r4              ;1883
0000d0  e9d14607          LDRD     r4,r6,[r1,#0x1c]      ;1883
0000d4  4334              ORRS     r4,r4,r6              ;1883
0000d6  6a49              LDR      r1,[r1,#0x24]         ;1883
0000d8  4323              ORRS     r3,r3,r4              ;1883
0000da  430b              ORRS     r3,r3,r1              ;1883
0000dc  f64f7180          MOV      r1,#0xff80            ;1883
0000e0  438a              BICS     r2,r2,r1              ;1883
0000e2  4313              ORRS     r3,r3,r2              ;1883
0000e4  642b              STR      r3,[r5,#0x40]         ;1890
0000e6  f880c021          STRB     r12,[r0,#0x21]        ;1892
0000ea  2100              MOVS     r1,#0                 ;1895
0000ec  f8801020          STRB     r1,[r0,#0x20]         ;1895
0000f0  2000              MOVS     r0,#0                 ;1897
0000f2  e7bf              B        |L25.116|
;;;1899   #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
                          ENDP

                  |L25.244|
                          DCD      0xffc7ffe3
                  |L25.248|
                          DCD      0xfe3fff9b

                          AREA ||i.HAL_RTCEx_SetTamper_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTamper_IT PROC
;;;1983     */
;;;1984   HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef *sTamper)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1985   {
;;;1986     uint32_t tmpreg;
;;;1987   
;;;1988     /* Check the parameters */
;;;1989     assert_param(IS_RTC_TAMPER(sTamper->Tamper));
;;;1990     assert_param(IS_RTC_TAMPER_INTERRUPT(sTamper->Interrupt));
;;;1991     assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;1992     assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));
;;;1993     assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));
;;;1994     assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
;;;1995     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
;;;1996     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
;;;1997     assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
;;;1998     assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
;;;1999   
;;;2000     /* Process Locked */
;;;2001     __HAL_LOCK(hrtc);
000004  f8902020          LDRB     r2,[r0,#0x20]
000008  2a01              CMP      r2,#1
00000a  d034              BEQ      |L26.118|
00000c  f04f0c01          MOV      r12,#1
000010  f880c020          STRB     r12,[r0,#0x20]
;;;2002   
;;;2003     hrtc->State = HAL_RTC_STATE_BUSY;
000014  2202              MOVS     r2,#2
000016  f8802021          STRB     r2,[r0,#0x21]
;;;2004   
;;;2005     /* Read register */
;;;2006     tmpreg = hrtc->Instance->TAMPCR;
00001a  6806              LDR      r6,[r0,#0]
00001c  6c32              LDR      r2,[r6,#0x40]
;;;2007   
;;;2008   #if defined(RTC_TAMPER1_SUPPORT)
;;;2009     if ((sTamper->Tamper & RTC_TAMPER_1) != 0)
00001e  680b              LDR      r3,[r1,#0]
;;;2010     {
;;;2011       MODIFY_REG(tmpreg,
000020  f44f2880          MOV      r8,#0x40000
000024  07dc              LSLS     r4,r3,#31             ;2009
000026  d013              BEQ      |L26.80|
000028  684c              LDR      r4,[r1,#4]
00002a  688d              LDR      r5,[r1,#8]
00002c  431c              ORRS     r4,r4,r3
00002e  b32d              CBZ      r5,|L26.124|
000030  2502              MOVS     r5,#2
                  |L26.50|
000032  68cf              LDR      r7,[r1,#0xc]
000034  b327              CBZ      r7,|L26.128|
000036  f44f3700          MOV      r7,#0x20000
                  |L26.58|
00003a  433d              ORRS     r5,r5,r7
00003c  4325              ORRS     r5,r5,r4
00003e  690f              LDR      r7,[r1,#0x10]
000040  4644              MOV      r4,r8
000042  42a7              CMP      r7,r4
000044  d000              BEQ      |L26.72|
000046  2400              MOVS     r4,#0
                  |L26.72|
000048  4325              ORRS     r5,r5,r4
00004a  f0221207          BIC      r2,r2,#0x70007
00004e  432a              ORRS     r2,r2,r5
                  |L26.80|
;;;2012                  (RTC_TAMPCR_TAMP1E | RTC_TAMPCR_TAMP1TRG | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP1IE | RTC_TAMPCR_TAMP1NOERASE | RTC_TAMPCR_TAMP1MF), \
;;;2013                  sTamper->Tamper | sTamper->Interrupt | \
;;;2014                  (sTamper->Trigger == RTC_TAMPERTRIGGER_RISINGEDGE ?  0U : RTC_TAMPCR_TAMP1TRG) | \
;;;2015                  (sTamper->NoErase == RTC_TAMPER_ERASE_BACKUP_ENABLE ? 0U : RTC_TAMPCR_TAMP1NOERASE ) | \
;;;2016                  (sTamper->MaskFlag == RTC_TAMPERMASK_FLAG_ENABLE ? RTC_TAMPCR_TAMP1MF : 0U) \
;;;2017                 );
;;;2018     }
;;;2019   #endif /* RTC_TAMPER1_SUPPORT */
;;;2020   
;;;2021   #if defined(RTC_TAMPER2_SUPPORT)
;;;2022     if ((sTamper->Tamper & RTC_TAMPER_2) != 0)
000050  071c              LSLS     r4,r3,#28
000052  d520              BPL      |L26.150|
;;;2023     {
;;;2024       MODIFY_REG(tmpreg,
000054  684c              LDR      r4,[r1,#4]
000056  688d              LDR      r5,[r1,#8]
000058  431c              ORRS     r4,r4,r3
00005a  b19d              CBZ      r5,|L26.132|
00005c  2510              MOVS     r5,#0x10
                  |L26.94|
00005e  68cf              LDR      r7,[r1,#0xc]
000060  b197              CBZ      r7,|L26.136|
000062  f44f1780          MOV      r7,#0x100000
                  |L26.102|
000066  433d              ORRS     r5,r5,r7
000068  432c              ORRS     r4,r4,r5
00006a  690d              LDR      r5,[r1,#0x10]
00006c  4545              CMP      r5,r8
00006e  d10d              BNE      |L26.140|
000070  f44f1500          MOV      r5,#0x200000
000074  e00b              B        |L26.142|
                  |L26.118|
000076  2002              MOVS     r0,#2                 ;2001
                  |L26.120|
;;;2025                  (RTC_TAMPCR_TAMP2E | RTC_TAMPCR_TAMP2TRG | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP2NOERASE | RTC_TAMPCR_TAMP2MF), \
;;;2026                  sTamper->Tamper | sTamper->Interrupt | \
;;;2027                  (sTamper->Trigger == RTC_TAMPERTRIGGER_RISINGEDGE ?  0U : RTC_TAMPCR_TAMP2TRG) | \
;;;2028                  (sTamper->NoErase == RTC_TAMPER_ERASE_BACKUP_ENABLE ? 0U : RTC_TAMPCR_TAMP2NOERASE ) | \
;;;2029                  (sTamper->MaskFlag == RTC_TAMPERMASK_FLAG_ENABLE ? RTC_TAMPCR_TAMP2MF : 0U) \
;;;2030                 );
;;;2031     }
;;;2032   #endif /* RTC_TAMPER2_SUPPORT */
;;;2033   
;;;2034   #if defined(RTC_TAMPER3_SUPPORT)
;;;2035     if ((sTamper->Tamper & RTC_TAMPER_3) != 0)
;;;2036     {
;;;2037       MODIFY_REG(tmpreg,
;;;2038                  (RTC_TAMPCR_TAMP3E | RTC_TAMPCR_TAMP3TRG | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP3IE | RTC_TAMPCR_TAMP3NOERASE | RTC_TAMPCR_TAMP3MF), \
;;;2039                  sTamper->Tamper | sTamper->Interrupt | \
;;;2040                  (sTamper->Trigger == RTC_TAMPERTRIGGER_RISINGEDGE ?  0U : RTC_TAMPCR_TAMP3TRG) | \
;;;2041                  (sTamper->NoErase == RTC_TAMPER_ERASE_BACKUP_ENABLE ? 0U : RTC_TAMPCR_TAMP3NOERASE ) | \
;;;2042                  (sTamper->MaskFlag == RTC_TAMPERMASK_FLAG_ENABLE ? RTC_TAMPCR_TAMP3MF : 0U) \
;;;2043                 );
;;;2044     }
;;;2045   #endif /* RTC_TAMPER3_SUPPORT */
;;;2046   
;;;2047     /* Update common parameters */
;;;2048     MODIFY_REG(tmpreg,
;;;2049                (RTC_TAMPCR_TAMPTS | RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH | RTC_TAMPCR_TAMPPUDIS), \
;;;2050                sTamper->Filter | sTamper->SamplingFrequency | sTamper->PrechargeDuration | sTamper->TamperPullUp | \
;;;2051                sTamper->TimeStampOnTamperDetection \
;;;2052                );
;;;2053   
;;;2054     /* Set register */
;;;2055     WRITE_REG (hrtc->Instance->TAMPCR, tmpreg);
;;;2056   
;;;2057     /* RTC Tamper Interrupt Configuration: EXTI configuration */
;;;2058     __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
;;;2059     __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
;;;2060   
;;;2061     hrtc->State = HAL_RTC_STATE_READY;
;;;2062   
;;;2063     /* Process Unlocked */
;;;2064     __HAL_UNLOCK(hrtc);
;;;2065   
;;;2066     return HAL_OK;
;;;2067   }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L26.124|
00007c  2500              MOVS     r5,#0                 ;2011
00007e  e7d8              B        |L26.50|
                  |L26.128|
000080  2700              MOVS     r7,#0                 ;2011
000082  e7da              B        |L26.58|
                  |L26.132|
000084  2500              MOVS     r5,#0                 ;2024
000086  e7ea              B        |L26.94|
                  |L26.136|
000088  2700              MOVS     r7,#0                 ;2024
00008a  e7ec              B        |L26.102|
                  |L26.140|
00008c  2500              MOVS     r5,#0                 ;2024
                  |L26.142|
00008e  432c              ORRS     r4,r4,r5              ;2024
000090  4d1f              LDR      r5,|L26.272|
000092  402a              ANDS     r2,r2,r5              ;2024
000094  4322              ORRS     r2,r2,r4              ;2024
                  |L26.150|
000096  069c              LSLS     r4,r3,#26             ;2035
000098  d51a              BPL      |L26.208|
00009a  684c              LDR      r4,[r1,#4]            ;2037
00009c  ea430504          ORR      r5,r3,r4              ;2037
0000a0  688b              LDR      r3,[r1,#8]            ;2037
0000a2  b163              CBZ      r3,|L26.190|
0000a4  2340              MOVS     r3,#0x40              ;2037
                  |L26.166|
0000a6  68cc              LDR      r4,[r1,#0xc]          ;2037
0000a8  b15c              CBZ      r4,|L26.194|
0000aa  f44f0400          MOV      r4,#0x800000          ;2037
                  |L26.174|
0000ae  4323              ORRS     r3,r3,r4              ;2037
0000b0  431d              ORRS     r5,r5,r3              ;2037
0000b2  690b              LDR      r3,[r1,#0x10]         ;2037
0000b4  4543              CMP      r3,r8                 ;2037
0000b6  d106              BNE      |L26.198|
0000b8  f04f7380          MOV      r3,#0x1000000         ;2037
0000bc  e004              B        |L26.200|
                  |L26.190|
0000be  2300              MOVS     r3,#0                 ;2037
0000c0  e7f1              B        |L26.166|
                  |L26.194|
0000c2  2400              MOVS     r4,#0                 ;2037
0000c4  e7f3              B        |L26.174|
                  |L26.198|
0000c6  2300              MOVS     r3,#0                 ;2037
                  |L26.200|
0000c8  431d              ORRS     r5,r5,r3              ;2037
0000ca  4b12              LDR      r3,|L26.276|
0000cc  401a              ANDS     r2,r2,r3              ;2037
0000ce  432a              ORRS     r2,r2,r5              ;2037
                  |L26.208|
0000d0  e9d13405          LDRD     r3,r4,[r1,#0x14]      ;2048
0000d4  4323              ORRS     r3,r3,r4              ;2048
0000d6  e9d14507          LDRD     r4,r5,[r1,#0x1c]      ;2048
0000da  432c              ORRS     r4,r4,r5              ;2048
0000dc  6a49              LDR      r1,[r1,#0x24]         ;2048
0000de  4323              ORRS     r3,r3,r4              ;2048
0000e0  430b              ORRS     r3,r3,r1              ;2048
0000e2  f64f7180          MOV      r1,#0xff80            ;2048
0000e6  438a              BICS     r2,r2,r1              ;2048
0000e8  4313              ORRS     r3,r3,r2              ;2048
0000ea  6433              STR      r3,[r6,#0x40]         ;2055
0000ec  490a              LDR      r1,|L26.280|
0000ee  680a              LDR      r2,[r1,#0]            ;2058
0000f0  f4422200          ORR      r2,r2,#0x80000        ;2058
0000f4  600a              STR      r2,[r1,#0]            ;2058
0000f6  4908              LDR      r1,|L26.280|
0000f8  3108              ADDS     r1,r1,#8              ;2059
0000fa  680a              LDR      r2,[r1,#0]            ;2059
0000fc  f4422200          ORR      r2,r2,#0x80000        ;2059
000100  600a              STR      r2,[r1,#0]            ;2059
000102  f880c021          STRB     r12,[r0,#0x21]        ;2061
000106  2100              MOVS     r1,#0                 ;2064
000108  f8801020          STRB     r1,[r0,#0x20]         ;2064
00010c  2000              MOVS     r0,#0                 ;2066
00010e  e7b3              B        |L26.120|
;;;2068   #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
                          ENDP

                  |L26.272|
                          DCD      0xffc7ffe3
                  |L26.276|
                          DCD      0xfe3fff9b
                  |L26.280|
                          DCD      0x40010400

                          AREA ||i.HAL_RTCEx_SetTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetTimeStamp PROC
;;;168      */
;;;169    HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
000000  b530              PUSH     {r4,r5,lr}
;;;170    {
;;;171      uint32_t tmpreg;
;;;172    
;;;173      /* Check the parameters */
;;;174      assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
;;;175      assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;176    
;;;177      /* Prevent unused argument(s) compilation warning if no assert_param check */
;;;178      UNUSED(RTC_TimeStampPin);
;;;179    
;;;180      /* Process Locked */
;;;181      __HAL_LOCK(hrtc);
000002  f8902020          LDRB     r2,[r0,#0x20]
000006  2a01              CMP      r2,#1
000008  d021              BEQ      |L27.78|
00000a  2401              MOVS     r4,#1
00000c  f8804020          STRB     r4,[r0,#0x20]
;;;182    
;;;183      hrtc->State = HAL_RTC_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  f8802021          STRB     r2,[r0,#0x21]
;;;184    
;;;185      /* Get the RTC_CR register and clear the bits to be configured */
;;;186      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000016  6802              LDR      r2,[r0,#0]
000018  6893              LDR      r3,[r2,#8]
00001a  f6400508          MOV      r5,#0x808
00001e  43ab              BICS     r3,r3,r5
;;;187    
;;;188      tmpreg |= TimeStampEdge;
000020  430b              ORRS     r3,r3,r1
;;;189    
;;;190      /* Disable the write protection for RTC registers */
;;;191      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000022  21ca              MOVS     r1,#0xca
000024  6251              STR      r1,[r2,#0x24]
000026  6802              LDR      r2,[r0,#0]
000028  2153              MOVS     r1,#0x53
00002a  6251              STR      r1,[r2,#0x24]
;;;192    
;;;193      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;194      hrtc->Instance->CR = (uint32_t)tmpreg;
00002c  6801              LDR      r1,[r0,#0]
00002e  608b              STR      r3,[r1,#8]
;;;195    
;;;196      __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
000030  6801              LDR      r1,[r0,#0]
000032  688a              LDR      r2,[r1,#8]
000034  f4426200          ORR      r2,r2,#0x800
000038  608a              STR      r2,[r1,#8]
;;;197    
;;;198      /* Enable the write protection for RTC registers */
;;;199      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00003a  6802              LDR      r2,[r0,#0]
00003c  21ff              MOVS     r1,#0xff
00003e  6251              STR      r1,[r2,#0x24]
;;;200    
;;;201      /* Change RTC state */
;;;202      hrtc->State = HAL_RTC_STATE_READY;
000040  f8804021          STRB     r4,[r0,#0x21]
;;;203    
;;;204      /* Process Unlocked */
;;;205      __HAL_UNLOCK(hrtc);
000044  2100              MOVS     r1,#0
000046  f8801020          STRB     r1,[r0,#0x20]
;;;206    
;;;207      return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;208    }
00004c  bd30              POP      {r4,r5,pc}
                  |L27.78|
00004e  2002              MOVS     r0,#2                 ;181
000050  bd30              POP      {r4,r5,pc}
;;;209    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTimeStamp_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTimeStamp_IT PROC
;;;227      */
;;;228    HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
000000  b530              PUSH     {r4,r5,lr}
;;;229    {
;;;230      uint32_t tmpreg;
;;;231    
;;;232      /* Check the parameters */
;;;233      assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
;;;234      assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;235    
;;;236      /* Prevent unused argument(s) compilation warning if no assert_param check */
;;;237      UNUSED(RTC_TimeStampPin);
;;;238    
;;;239      /* Process Locked */
;;;240      __HAL_LOCK(hrtc);
000002  f8902020          LDRB     r2,[r0,#0x20]
000006  2a01              CMP      r2,#1
000008  d031              BEQ      |L28.110|
00000a  2401              MOVS     r4,#1
00000c  f8804020          STRB     r4,[r0,#0x20]
;;;241    
;;;242      hrtc->State = HAL_RTC_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  f8802021          STRB     r2,[r0,#0x21]
;;;243    
;;;244      /* Get the RTC_CR register and clear the bits to be configured */
;;;245      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000016  6802              LDR      r2,[r0,#0]
000018  6893              LDR      r3,[r2,#8]
00001a  f6400508          MOV      r5,#0x808
00001e  43ab              BICS     r3,r3,r5
;;;246    
;;;247      tmpreg |= TimeStampEdge;
000020  430b              ORRS     r3,r3,r1
;;;248    
;;;249      /* Disable the write protection for RTC registers */
;;;250      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000022  21ca              MOVS     r1,#0xca
000024  6251              STR      r1,[r2,#0x24]
000026  6802              LDR      r2,[r0,#0]
000028  2153              MOVS     r1,#0x53
00002a  6251              STR      r1,[r2,#0x24]
;;;251    
;;;252      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;253      hrtc->Instance->CR = (uint32_t)tmpreg;
00002c  6801              LDR      r1,[r0,#0]
00002e  608b              STR      r3,[r1,#8]
;;;254    
;;;255      __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
000030  6801              LDR      r1,[r0,#0]
000032  688a              LDR      r2,[r1,#8]
000034  f4426200          ORR      r2,r2,#0x800
000038  608a              STR      r2,[r1,#8]
;;;256    
;;;257      /* Enable IT timestamp */
;;;258      __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc, RTC_IT_TS);
00003a  6801              LDR      r1,[r0,#0]
00003c  688a              LDR      r2,[r1,#8]
00003e  f4424200          ORR      r2,r2,#0x8000
000042  608a              STR      r2,[r1,#8]
;;;259    
;;;260      /* RTC timestamp Interrupt Configuration: EXTI configuration */
;;;261      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
000044  490b              LDR      r1,|L28.116|
000046  680a              LDR      r2,[r1,#0]
000048  f4422200          ORR      r2,r2,#0x80000
00004c  600a              STR      r2,[r1,#0]
;;;262      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
00004e  4909              LDR      r1,|L28.116|
000050  3108              ADDS     r1,r1,#8
000052  680a              LDR      r2,[r1,#0]
000054  f4422200          ORR      r2,r2,#0x80000
000058  600a              STR      r2,[r1,#0]
;;;263    
;;;264      /* Enable the write protection for RTC registers */
;;;265      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00005a  6802              LDR      r2,[r0,#0]
00005c  21ff              MOVS     r1,#0xff
00005e  6251              STR      r1,[r2,#0x24]
;;;266    
;;;267      hrtc->State = HAL_RTC_STATE_READY;
000060  f8804021          STRB     r4,[r0,#0x21]
;;;268    
;;;269      /* Process Unlocked */
;;;270      __HAL_UNLOCK(hrtc);
000064  2100              MOVS     r1,#0
000066  f8801020          STRB     r1,[r0,#0x20]
;;;271    
;;;272      return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;273    }
00006c  bd30              POP      {r4,r5,pc}
                  |L28.110|
00006e  2002              MOVS     r0,#2                 ;240
000070  bd30              POP      {r4,r5,pc}
;;;274    
                          ENDP

000072  0000              DCW      0x0000
                  |L28.116|
                          DCD      0x40010400

                          AREA ||i.HAL_RTCEx_SetWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetWakeUpTimer PROC
;;;735      */
;;;736    HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;737    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
;;;738      uint32_t tickstart;
;;;739    
;;;740      /* Check the parameters */
;;;741      assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
;;;742      assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
;;;743    
;;;744      /* Process Locked */
;;;745      __HAL_LOCK(hrtc);
00000a  f8940020          LDRB     r0,[r4,#0x20]
00000e  2801              CMP      r0,#1
000010  d01e              BEQ      |L29.80|
000012  2601              MOVS     r6,#1
000014  f8846020          STRB     r6,[r4,#0x20]
;;;746    
;;;747      hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f8840021          STRB     r0,[r4,#0x21]
;;;748    
;;;749      /* Disable the write protection for RTC registers */
;;;750      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00001e  6821              LDR      r1,[r4,#0]
000020  20ca              MOVS     r0,#0xca
000022  6248              STR      r0,[r1,#0x24]
000024  6821              LDR      r1,[r4,#0]
000026  2053              MOVS     r0,#0x53
000028  6248              STR      r0,[r1,#0x24]
;;;751    
;;;752      /* Clear WUTE in RTC_CR to disable the wakeup timer */
;;;753      CLEAR_BIT(hrtc->Instance->CR, RTC_CR_WUTE);
00002a  6820              LDR      r0,[r4,#0]
00002c  6881              LDR      r1,[r0,#8]
00002e  f4216180          BIC      r1,r1,#0x400
000032  6081              STR      r1,[r0,#8]
;;;754    
;;;755      /* Poll WUTWF until it is set in RTC_ICSR to make sure the access to wakeup autoreload
;;;756         counter and to WUCKSEL[2:0] bits is allowed. This step must be skipped in
;;;757         calendar initialization mode. */
;;;758    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;759      if (READ_BIT(hrtc->Instance->ICSR, RTC_ICSR_INITF) == 0U)
;;;760    #else
;;;761      if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  f04f0700          MOV      r7,#0
00003c  0640              LSLS     r0,r0,#25
;;;762    #endif
;;;763      {
;;;764        tickstart = HAL_GetTick();
;;;765    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;766        while (READ_BIT(hrtc->Instance->ICSR, RTC_ICSR_WUTWF) == 0U)
;;;767    #else
;;;768        while (READ_BIT(hrtc->Instance->ISR, RTC_ISR_WUTWF) == 0U)
;;;769    #endif
;;;770        {
;;;771          if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;772          {
;;;773            /* Enable the write protection for RTC registers */
;;;774            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00003e  f04f08ff          MOV      r8,#0xff
000042  d41a              BMI      |L29.122|
000044  f7fffffe          BL       HAL_GetTick
000048  4605              MOV      r5,r0                 ;764
00004a  f44f797a          MOV      r9,#0x3e8             ;771
00004e  e010              B        |L29.114|
                  |L29.80|
000050  2002              MOVS     r0,#2                 ;745
                  |L29.82|
;;;775    
;;;776            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;777    
;;;778            /* Process Unlocked */
;;;779            __HAL_UNLOCK(hrtc);
;;;780    
;;;781            return HAL_TIMEOUT;
;;;782          }
;;;783        }
;;;784      }
;;;785    
;;;786      /* Configure the clock source */
;;;787      MODIFY_REG(hrtc->Instance->CR, RTC_CR_WUCKSEL, (uint32_t)WakeUpClock);
;;;788    
;;;789      /* Configure the Wakeup Timer counter */
;;;790      WRITE_REG(hrtc->Instance->WUTR, (uint32_t)WakeUpCounter);
;;;791    
;;;792      /* Enable the Wakeup Timer */
;;;793      SET_BIT(hrtc->Instance->CR, RTC_CR_WUTE);
;;;794    
;;;795      /* Enable the write protection for RTC registers */
;;;796      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;797    
;;;798      hrtc->State = HAL_RTC_STATE_READY;
;;;799    
;;;800      /* Process Unlocked */
;;;801      __HAL_UNLOCK(hrtc);
;;;802    
;;;803      return HAL_OK;
;;;804    }
000052  e8bd9ff0          POP      {r4-r12,pc}
                  |L29.86|
000056  f7fffffe          BL       HAL_GetTick
00005a  1b40              SUBS     r0,r0,r5              ;771
00005c  4548              CMP      r0,r9                 ;771
00005e  d908              BLS      |L29.114|
000060  6820              LDR      r0,[r4,#0]            ;774
000062  f8c08024          STR      r8,[r0,#0x24]         ;774
000066  2003              MOVS     r0,#3                 ;776
000068  f8840021          STRB     r0,[r4,#0x21]         ;776
00006c  f8847020          STRB     r7,[r4,#0x20]         ;779
000070  e7ef              B        |L29.82|
                  |L29.114|
000072  6820              LDR      r0,[r4,#0]            ;768
000074  68c0              LDR      r0,[r0,#0xc]          ;768
000076  0740              LSLS     r0,r0,#29             ;768
000078  d5ed              BPL      |L29.86|
                  |L29.122|
00007a  6820              LDR      r0,[r4,#0]            ;787
00007c  6881              LDR      r1,[r0,#8]            ;787
00007e  f0210107          BIC      r1,r1,#7              ;787
000082  ea41010b          ORR      r1,r1,r11             ;787
000086  6081              STR      r1,[r0,#8]            ;787
000088  6820              LDR      r0,[r4,#0]            ;790
00008a  f8c0a014          STR      r10,[r0,#0x14]        ;790
00008e  6820              LDR      r0,[r4,#0]            ;793
000090  6881              LDR      r1,[r0,#8]            ;793
000092  f4416180          ORR      r1,r1,#0x400          ;793
000096  6081              STR      r1,[r0,#8]            ;793
000098  6820              LDR      r0,[r4,#0]            ;796
00009a  f8c08024          STR      r8,[r0,#0x24]         ;796
00009e  f8846021          STRB     r6,[r4,#0x21]         ;798
0000a2  f8847020          STRB     r7,[r4,#0x20]         ;801
0000a6  2000              MOVS     r0,#0                 ;803
0000a8  e7d3              B        |L29.82|
;;;805    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetWakeUpTimer_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetWakeUpTimer_IT PROC
;;;820    #else
;;;821    HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;822    #endif
;;;823    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
;;;824      uint32_t tickstart;
;;;825    
;;;826      /* Check the parameters */
;;;827      assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
;;;828      assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
;;;829    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;830      /* (0x0000<=WUTOCLR<=WUT) */
;;;831      assert_param(WakeUpAutoClr <= WakeUpCounter);
;;;832    #endif
;;;833    
;;;834      /* Process Locked */
;;;835      __HAL_LOCK(hrtc);
00000a  f8940020          LDRB     r0,[r4,#0x20]
00000e  2801              CMP      r0,#1
000010  d025              BEQ      |L30.94|
000012  2601              MOVS     r6,#1
000014  f8846020          STRB     r6,[r4,#0x20]
;;;836    
;;;837      hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f8840021          STRB     r0,[r4,#0x21]
;;;838    
;;;839      /* Disable the write protection for RTC registers */
;;;840      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00001e  6821              LDR      r1,[r4,#0]
000020  20ca              MOVS     r0,#0xca
000022  6248              STR      r0,[r1,#0x24]
000024  6821              LDR      r1,[r4,#0]
000026  2053              MOVS     r0,#0x53
000028  6248              STR      r0,[r1,#0x24]
;;;841    
;;;842      /* Clear WUTE in RTC_CR to disable the wakeup timer */
;;;843      CLEAR_BIT(hrtc->Instance->CR, RTC_CR_WUTE);
00002a  6820              LDR      r0,[r4,#0]
00002c  6881              LDR      r1,[r0,#8]
00002e  f4216180          BIC      r1,r1,#0x400
000032  6081              STR      r1,[r0,#8]
;;;844    
;;;845      /* Clear flag Wake-Up */
;;;846      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
000034  6820              LDR      r0,[r4,#0]
000036  68c1              LDR      r1,[r0,#0xc]
000038  f0010180          AND      r1,r1,#0x80
00003c  f4616190          ORN      r1,r1,#0x480
000040  60c1              STR      r1,[r0,#0xc]
;;;847    
;;;848      /* Poll WUTWF until it is set in RTC_ICSR to make sure the access to wakeup autoreload
;;;849         counter and to WUCKSEL[2:0] bits is allowed. This step must be skipped in
;;;850         calendar initialization mode. */
;;;851    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;852      if (READ_BIT(hrtc->Instance->ICSR, RTC_ICSR_INITF) == 0U)
;;;853    #else
;;;854      if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  f04f0700          MOV      r7,#0
00004a  0640              LSLS     r0,r0,#25
;;;855    #endif
;;;856      {
;;;857        tickstart = HAL_GetTick();
;;;858    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;859        while (READ_BIT(hrtc->Instance->ICSR, RTC_ICSR_WUTWF) == 0U)
;;;860    #else
;;;861        while (READ_BIT(hrtc->Instance->ISR, RTC_ISR_WUTWF) == 0U)
;;;862    #endif
;;;863        {
;;;864          if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;865          {
;;;866            /* Enable the write protection for RTC registers */
;;;867            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00004c  f04f08ff          MOV      r8,#0xff
000050  d41a              BMI      |L30.136|
000052  f7fffffe          BL       HAL_GetTick
000056  4605              MOV      r5,r0                 ;857
000058  f44f797a          MOV      r9,#0x3e8             ;864
00005c  e010              B        |L30.128|
                  |L30.94|
00005e  2002              MOVS     r0,#2                 ;835
                  |L30.96|
;;;868    
;;;869            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;870    
;;;871            /* Process Unlocked */
;;;872            __HAL_UNLOCK(hrtc);
;;;873    
;;;874            return HAL_TIMEOUT;
;;;875          }
;;;876        }
;;;877      }
;;;878    
;;;879    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;880      /* Configure the Wakeup Timer counter and auto clear value */
;;;881      hrtc->Instance->WUTR = (uint32_t)(WakeUpCounter | (WakeUpAutoClr << RTC_WUTR_WUTOCLR_Pos));
;;;882    #else
;;;883      /* Configure the Wakeup Timer counter */
;;;884      hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
;;;885    #endif
;;;886    
;;;887      /* Configure the clock source */
;;;888      MODIFY_REG(hrtc->Instance->CR, RTC_CR_WUCKSEL, (uint32_t)WakeUpClock);
;;;889    
;;;890    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;891      /* In case of WUT autoclr, the IRQ handler should not be called */
;;;892      if (WakeUpAutoClr != 0u)
;;;893      {
;;;894        /* RTC WakeUpTimer EXTI Configuration: Event configuration */
;;;895        __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_EVENT();
;;;896      }
;;;897      else
;;;898      {
;;;899        /* RTC WakeUpTimer EXTI Configuration: Interrupt configuration */
;;;900        __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
;;;901      }
;;;902    #else /* defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;903      __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
;;;904    #endif /* defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
;;;905    
;;;906      __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();
;;;907    
;;;908      /* Configure the Interrupt in the RTC_CR register */
;;;909      __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc, RTC_IT_WUT);
;;;910    
;;;911      /* Enable the Wakeup Timer */
;;;912      __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
;;;913    
;;;914      /* Enable the write protection for RTC registers */
;;;915      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;916    
;;;917      hrtc->State = HAL_RTC_STATE_READY;
;;;918    
;;;919      /* Process Unlocked */
;;;920      __HAL_UNLOCK(hrtc);
;;;921    
;;;922      return HAL_OK;
;;;923    }
000060  e8bd9ff0          POP      {r4-r12,pc}
                  |L30.100|
000064  f7fffffe          BL       HAL_GetTick
000068  1b40              SUBS     r0,r0,r5              ;864
00006a  4548              CMP      r0,r9                 ;864
00006c  d908              BLS      |L30.128|
00006e  6820              LDR      r0,[r4,#0]            ;867
000070  f8c08024          STR      r8,[r0,#0x24]         ;867
000074  2003              MOVS     r0,#3                 ;869
000076  f8840021          STRB     r0,[r4,#0x21]         ;869
00007a  f8847020          STRB     r7,[r4,#0x20]         ;872
00007e  e7ef              B        |L30.96|
                  |L30.128|
000080  6820              LDR      r0,[r4,#0]            ;861
000082  68c0              LDR      r0,[r0,#0xc]          ;861
000084  0740              LSLS     r0,r0,#29             ;861
000086  d5ed              BPL      |L30.100|
                  |L30.136|
000088  6820              LDR      r0,[r4,#0]            ;884
00008a  f8c0a014          STR      r10,[r0,#0x14]        ;884
00008e  6820              LDR      r0,[r4,#0]            ;888
000090  6881              LDR      r1,[r0,#8]            ;888
000092  f0210107          BIC      r1,r1,#7              ;888
000096  ea41010b          ORR      r1,r1,r11             ;888
00009a  6081              STR      r1,[r0,#8]            ;888
00009c  480e              LDR      r0,|L30.216|
00009e  6801              LDR      r1,[r0,#0]            ;903
0000a0  f4411180          ORR      r1,r1,#0x100000       ;903
0000a4  6001              STR      r1,[r0,#0]            ;903
0000a6  480c              LDR      r0,|L30.216|
0000a8  3008              ADDS     r0,r0,#8              ;906
0000aa  6801              LDR      r1,[r0,#0]            ;906
0000ac  f4411180          ORR      r1,r1,#0x100000       ;906
0000b0  6001              STR      r1,[r0,#0]            ;906
0000b2  6820              LDR      r0,[r4,#0]            ;909
0000b4  6881              LDR      r1,[r0,#8]            ;909
0000b6  f4414180          ORR      r1,r1,#0x4000         ;909
0000ba  6081              STR      r1,[r0,#8]            ;909
0000bc  6820              LDR      r0,[r4,#0]            ;912
0000be  6881              LDR      r1,[r0,#8]            ;912
0000c0  f4416180          ORR      r1,r1,#0x400          ;912
0000c4  6081              STR      r1,[r0,#8]            ;912
0000c6  6820              LDR      r0,[r4,#0]            ;915
0000c8  f8c08024          STR      r8,[r0,#0x24]         ;915
0000cc  f8846021          STRB     r6,[r4,#0x21]         ;917
0000d0  f8847020          STRB     r7,[r4,#0x20]         ;920
0000d4  2000              MOVS     r0,#0                 ;922
0000d6  e7c3              B        |L30.96|
;;;924    
                          ENDP

                  |L30.216|
                          DCD      0x40010400

                          AREA ||i.HAL_RTCEx_Tamper1EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper1EventCallback PROC
;;;2262     */
;;;2263   __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;2264   {
;;;2265     /* Prevent unused argument(s) compilation warning */
;;;2266     UNUSED(hrtc);
;;;2267   
;;;2268     /* NOTE : This function should not be modified, when the callback is needed,
;;;2269               the HAL_RTCEx_Tamper1EventCallback could be implemented in the user file
;;;2270      */
;;;2271   }
;;;2272   #endif /* RTC_TAMPER1_SUPPORT */
                          ENDP


                          AREA ||i.HAL_RTCEx_Tamper2EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper2EventCallback PROC
;;;2278     */
;;;2279   __weak void HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;2280   {
;;;2281     /* Prevent unused argument(s) compilation warning */
;;;2282     UNUSED(hrtc);
;;;2283   
;;;2284     /* NOTE : This function should not be modified, when the callback is needed,
;;;2285               the HAL_RTCEx_Tamper2EventCallback could be implemented in the user file
;;;2286      */
;;;2287   }
;;;2288   
                          ENDP


                          AREA ||i.HAL_RTCEx_Tamper3EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper3EventCallback PROC
;;;2294     */
;;;2295   __weak void HAL_RTCEx_Tamper3EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;2296   {
;;;2297     /* Prevent unused argument(s) compilation warning */
;;;2298     UNUSED(hrtc);
;;;2299   
;;;2300     /* NOTE : This function should not be modified, when the callback is needed,
;;;2301               the HAL_RTCEx_Tamper3EventCallback could be implemented in the user file
;;;2302      */
;;;2303   }
;;;2304   #endif /* RTC_TAMPER3_SUPPORT */
                          ENDP


                          AREA ||i.HAL_RTCEx_TamperTimeStampIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_TamperTimeStampIRQHandler PROC
;;;574    
;;;575    void HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;576    {
000002  4604              MOV      r4,r0
;;;577      /* Clear the EXTI's Flag for RTC TimeStamp and Tamper */
;;;578      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();
000004  4926              LDR      r1,|L34.160|
000006  f44f2000          MOV      r0,#0x80000
00000a  6008              STR      r0,[r1,#0]
;;;579    
;;;580      /* Get the TimeStamp interrupt source enable status and pending flag status */
;;;581      if (__HAL_RTC_TIMESTAMP_GET_IT_SOURCE(hrtc, RTC_IT_TS) != 0U)
00000c  6820              LDR      r0,[r4,#0]
00000e  6881              LDR      r1,[r0,#8]
000010  0409              LSLS     r1,r1,#16
000012  d50c              BPL      |L34.46|
;;;582      {
;;;583        if (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) != 0U)
000014  68c0              LDR      r0,[r0,#0xc]
000016  0500              LSLS     r0,r0,#20
000018  d509              BPL      |L34.46|
;;;584        {
;;;585          /* TIMESTAMP callback */
;;;586    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;587          hrtc->TimeStampEventCallback(hrtc);
;;;588    #else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;589          HAL_RTCEx_TimeStampEventCallback(hrtc);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       HAL_RTCEx_TimeStampEventCallback
;;;590    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;591    
;;;592          /* Clear the TIMESTAMP interrupt pending bit (this will clear timestamp time and date registers) */
;;;593          __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0010180          AND      r1,r1,#0x80
000028  f4616108          ORN      r1,r1,#0x880
00002c  60c1              STR      r1,[r0,#0xc]
                  |L34.46|
;;;594        }
;;;595      }
;;;596    
;;;597    #if defined(RTC_TAMPER1_SUPPORT)
;;;598      /* Get the Tamper1 interrupt source enable status and pending flag status */
;;;599      if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP1) != 0U)
00002e  6820              LDR      r0,[r4,#0]
000030  6c01              LDR      r1,[r0,#0x40]
000032  4a1c              LDR      r2,|L34.164|
000034  4211              TST      r1,r2
000036  d00b              BEQ      |L34.80|
;;;600      {
;;;601        if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != 0U)
000038  68c1              LDR      r1,[r0,#0xc]
00003a  0489              LSLS     r1,r1,#18
00003c  d508              BPL      |L34.80|
;;;602        {
;;;603          /* Clear the Tamper1 interrupt pending bit */
;;;604          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
00003e  68c1              LDR      r1,[r0,#0xc]
000040  f0010180          AND      r1,r1,#0x80
000044  f4615102          ORN      r1,r1,#0x2080
000048  60c1              STR      r1,[r0,#0xc]
;;;605    
;;;606          /* Tamper1 callback */
;;;607    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;608          hrtc->Tamper1EventCallback(hrtc);
;;;609    #else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;610          HAL_RTCEx_Tamper1EventCallback(hrtc);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       HAL_RTCEx_Tamper1EventCallback
                  |L34.80|
;;;611    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;612        }
;;;613      }
;;;614    #endif /* RTC_TAMPER1_SUPPORT */
;;;615    
;;;616      /* Get the Tamper2 interrupt source enable status and pending flag status */
;;;617      if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP2) != 0U)
000050  6820              LDR      r0,[r4,#0]
000052  6c01              LDR      r1,[r0,#0x40]
000054  4a14              LDR      r2,|L34.168|
000056  4211              TST      r1,r2
000058  d00b              BEQ      |L34.114|
;;;618      {
;;;619        if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) != 0U)
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  0449              LSLS     r1,r1,#17
00005e  d508              BPL      |L34.114|
;;;620        {
;;;621          /* Clear the Tamper2 interrupt pending bit */
;;;622          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
000060  68c1              LDR      r1,[r0,#0xc]
000062  f0010180          AND      r1,r1,#0x80
000066  f4614181          ORN      r1,r1,#0x4080
00006a  60c1              STR      r1,[r0,#0xc]
;;;623    
;;;624          /* Tamper2 callback */
;;;625    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;626          hrtc->Tamper2EventCallback(hrtc);
;;;627    #else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;628          HAL_RTCEx_Tamper2EventCallback(hrtc);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_RTCEx_Tamper2EventCallback
                  |L34.114|
;;;629    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
;;;630        }
;;;631      }
;;;632    
;;;633    #if defined(RTC_TAMPER3_SUPPORT)
;;;634      /* Get the Tamper3 interrupts source enable status */
;;;635      if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP3) != 0U)
000072  6820              LDR      r0,[r4,#0]
000074  6c01              LDR      r1,[r0,#0x40]
000076  4a0d              LDR      r2,|L34.172|
000078  4211              TST      r1,r2
00007a  d00c              BEQ      |L34.150|
;;;636      {
;;;637        if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) != 0U)
00007c  68c1              LDR      r1,[r0,#0xc]
00007e  0409              LSLS     r1,r1,#16
000080  d509              BPL      |L34.150|
;;;638        {
;;;639          /* Clear the Tamper3 interrupt pending bit */
;;;640          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
000082  68c1              LDR      r1,[r0,#0xc]
000084  f0010180          AND      r1,r1,#0x80
000088  f5a14100          SUB      r1,r1,#0x8000
00008c  3981              SUBS     r1,r1,#0x81
00008e  60c1              STR      r1,[r0,#0xc]
;;;641    
;;;642          /* Tamper3 callback */
;;;643    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;644          hrtc->Tamper3EventCallback(hrtc);
;;;645    #else
;;;646          HAL_RTCEx_Tamper3EventCallback(hrtc);
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       HAL_RTCEx_Tamper3EventCallback
                  |L34.150|
;;;647    #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;648        }
;;;649      }
;;;650    #endif /* RTC_TAMPER3_SUPPORT */
;;;651    
;;;652      /* Change RTC state */
;;;653      hrtc->State = HAL_RTC_STATE_READY;
000096  2001              MOVS     r0,#1
000098  f8840021          STRB     r0,[r4,#0x21]
;;;654    }
00009c  bd10              POP      {r4,pc}
;;;655    #endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
                          ENDP

00009e  0000              DCW      0x0000
                  |L34.160|
                          DCD      0x40010414
                  |L34.164|
                          DCD      0x00010004
                  |L34.168|
                          DCD      0x00080004
                  |L34.172|
                          DCD      0x00400004

                          AREA ||i.HAL_RTCEx_TimeStampEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_TimeStampEventCallback PROC
;;;661      */
;;;662    __weak void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;663    {
;;;664      /* Prevent unused argument(s) compilation warning */
;;;665      UNUSED(hrtc);
;;;666    
;;;667      /* NOTE : This function should not be modified, when the callback is needed,
;;;668                the HAL_RTCEx_TimeStampEventCallback could be implemented in the user file
;;;669       */
;;;670    }
;;;671    
                          ENDP


                          AREA ||i.HAL_RTCEx_WakeUpTimerEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_WakeUpTimerEventCallback PROC
;;;1029     */
;;;1030   __weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1031   {
;;;1032     /* Prevent unused argument(s) compilation warning */
;;;1033     UNUSED(hrtc);
;;;1034   
;;;1035     /* NOTE : This function should not be modified, when the callback is needed,
;;;1036               the HAL_RTCEx_WakeUpTimerEventCallback could be implemented in the user file
;;;1037      */
;;;1038   }
;;;1039   
                          ENDP


                          AREA ||i.HAL_RTCEx_WakeUpTimerIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_WakeUpTimerIRQHandler PROC
;;;992      */
;;;993    void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;994    {
000002  4604              MOV      r4,r0
;;;995      /* Clear the EXTI's line Flag for RTC WakeUpTimer */
;;;996      __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
000004  490a              LDR      r1,|L37.48|
000006  f44f1080          MOV      r0,#0x100000
00000a  6008              STR      r0,[r1,#0]
;;;997    
;;;998    
;;;999    #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
;;;1000     if ((hrtc->Instance->MISR & RTC_MISR_WUTMF) != 0u)
;;;1001     {
;;;1002       /* Immediately clear flags */
;;;1003       hrtc->Instance->SCR = RTC_SCR_CWUTF;
;;;1004   #else
;;;1005     /* Get the pending status of the WAKEUPTIMER Interrupt */
;;;1006     if (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != 0U)
00000c  6821              LDR      r1,[r4,#0]
00000e  68c8              LDR      r0,[r1,#0xc]
000010  0540              LSLS     r0,r0,#21
000012  d508              BPL      |L37.38|
;;;1007     {
;;;1008       /* Clear the WAKEUPTIMER interrupt pending bit */
;;;1009       __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
000014  68c8              LDR      r0,[r1,#0xc]
000016  f0000080          AND      r0,r0,#0x80
00001a  f4606090          ORN      r0,r0,#0x480
00001e  60c8              STR      r0,[r1,#0xc]
;;;1010   #endif
;;;1011   
;;;1012       /* WAKEUPTIMER callback */
;;;1013   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;1014       /* Call WakeUpTimerEvent registered Callback */
;;;1015       hrtc->WakeUpTimerEventCallback(hrtc);
;;;1016   #else
;;;1017       HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_RTCEx_WakeUpTimerEventCallback
                  |L37.38|
;;;1018   #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;1019     }
;;;1020   
;;;1021     /* Change RTC state */
;;;1022     hrtc->State = HAL_RTC_STATE_READY;
000026  2001              MOVS     r0,#1
000028  f8840021          STRB     r0,[r4,#0x21]
;;;1023   }
00002c  bd10              POP      {r4,pc}
;;;1024   
                          ENDP

00002e  0000              DCW      0x0000
                  |L37.48|
                          DCD      0x40010414

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_rtc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rtc_ex_c_7fcc3a7e____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_rtc_ex_c_7fcc3a7e____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rtc_ex_c_7fcc3a7e____REVSH|
#line 507
|__asm___22_stm32l4xx_hal_rtc_ex_c_7fcc3a7e____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_rtc_ex_c_7fcc3a7e____RRX|
#line 694
|__asm___22_stm32l4xx_hal_rtc_ex_c_7fcc3a7e____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
