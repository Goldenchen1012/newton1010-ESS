; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_tsc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_tsc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_tsc.c]
                          THUMB

                          AREA ||i.HAL_TSC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TSC_ConvCpltCallback PROC
;;;1052     */
;;;1053   __weak void HAL_TSC_ConvCpltCallback(TSC_HandleTypeDef *htsc)
000000  4770              BX       lr
;;;1054   {
;;;1055     /* Prevent unused argument(s) compilation warning */
;;;1056     UNUSED(htsc);
;;;1057   
;;;1058     /* NOTE : This function should not be modified, when the callback is needed,
;;;1059               the HAL_TSC_ConvCpltCallback could be implemented in the user file.
;;;1060      */
;;;1061   }
;;;1062   
                          ENDP


                          AREA ||i.HAL_TSC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TSC_DeInit PROC
;;;350      */
;;;351    HAL_StatusTypeDef HAL_TSC_DeInit(TSC_HandleTypeDef *htsc)
000000  b510              PUSH     {r4,lr}
;;;352    {
000002  4604              MOV      r4,r0
;;;353      /* Check TSC handle allocation */
;;;354      if (htsc == NULL)
000004  2c00              CMP      r4,#0
000006  d00a              BEQ      |L2.30|
;;;355      {
;;;356        return HAL_ERROR;
;;;357      }
;;;358    
;;;359      /* Check the parameters */
;;;360      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;361    
;;;362      /* Change TSC state */
;;;363      htsc->State = HAL_TSC_STATE_BUSY;
000008  2002              MOVS     r0,#2
00000a  f884003c          STRB     r0,[r4,#0x3c]
;;;364    
;;;365    #if (USE_HAL_TSC_REGISTER_CALLBACKS == 1)
;;;366      if (htsc->MspDeInitCallback == NULL)
;;;367      {
;;;368        htsc->MspDeInitCallback = HAL_TSC_MspDeInit; /* Legacy weak MspDeInit  */
;;;369      }
;;;370    
;;;371      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;372      htsc->MspDeInitCallback(htsc);
;;;373    #else
;;;374      /* DeInit the low level hardware */
;;;375      HAL_TSC_MspDeInit(htsc);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_TSC_MspDeInit
;;;376    #endif /* USE_HAL_TSC_REGISTER_CALLBACKS */
;;;377    
;;;378      /* Change TSC state */
;;;379      htsc->State = HAL_TSC_STATE_RESET;
000014  2000              MOVS     r0,#0
000016  f8040f3c          STRB     r0,[r4,#0x3c]!
;;;380    
;;;381      /* Process unlocked */
;;;382      __HAL_UNLOCK(htsc);
00001a  7060              STRB     r0,[r4,#1]
;;;383    
;;;384      /* Return function status */
;;;385      return HAL_OK;
;;;386    }
00001c  bd10              POP      {r4,pc}
                  |L2.30|
00001e  2001              MOVS     r0,#1                 ;356
000020  bd10              POP      {r4,pc}
;;;387    
                          ENDP


                          AREA ||i.HAL_TSC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TSC_ErrorCallback PROC
;;;1068     */
;;;1069   __weak void HAL_TSC_ErrorCallback(TSC_HandleTypeDef *htsc)
000000  4770              BX       lr
;;;1070   {
;;;1071     /* Prevent unused argument(s) compilation warning */
;;;1072     UNUSED(htsc);
;;;1073   
;;;1074     /* NOTE : This function should not be modified, when the callback is needed,
;;;1075               the HAL_TSC_ErrorCallback could be implemented in the user file.
;;;1076      */
;;;1077   }
;;;1078   
                          ENDP


                          AREA ||i.HAL_TSC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TSC_GetState PROC
;;;965      */
;;;966    HAL_TSC_StateTypeDef HAL_TSC_GetState(TSC_HandleTypeDef *htsc)
000000  f890103c          LDRB     r1,[r0,#0x3c]
;;;967    {
;;;968      /* Check the parameters */
;;;969      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;970    
;;;971      if (htsc->State == HAL_TSC_STATE_BUSY)
000004  2902              CMP      r1,#2
000006  d10f              BNE      |L4.40|
;;;972      {
;;;973        /* Check end of acquisition flag */
;;;974        if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_EOA) != RESET)
000008  6801              LDR      r1,[r0,#0]
00000a  68ca              LDR      r2,[r1,#0xc]
00000c  43d2              MVNS     r2,r2
00000e  07d2              LSLS     r2,r2,#31
000010  d10a              BNE      |L4.40|
;;;975        {
;;;976          /* Check max count error flag */
;;;977          if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_MCE) != RESET)
000012  68c9              LDR      r1,[r1,#0xc]
000014  43c9              MVNS     r1,r1
000016  0789              LSLS     r1,r1,#30
000018  d403              BMI      |L4.34|
;;;978          {
;;;979            /* Change TSC state */
;;;980            htsc->State = HAL_TSC_STATE_ERROR;
00001a  2103              MOVS     r1,#3
00001c  f880103c          STRB     r1,[r0,#0x3c]
000020  e002              B        |L4.40|
                  |L4.34|
;;;981          }
;;;982          else
;;;983          {
;;;984            /* Change TSC state */
;;;985            htsc->State = HAL_TSC_STATE_READY;
000022  2101              MOVS     r1,#1
000024  f880103c          STRB     r1,[r0,#0x3c]
                  |L4.40|
;;;986          }
;;;987        }
;;;988      }
;;;989    
;;;990      /* Return TSC state */
;;;991      return htsc->State;
000028  f890003c          LDRB     r0,[r0,#0x3c]
;;;992    }
00002c  4770              BX       lr
;;;993    
                          ENDP


                          AREA ||i.HAL_TSC_GroupGetStatus||, CODE, READONLY, ALIGN=1

                  HAL_TSC_GroupGetStatus PROC
;;;824      */
;;;825    TSC_GroupStatusTypeDef HAL_TSC_GroupGetStatus(TSC_HandleTypeDef *htsc, uint32_t gx_index)
000000  6800              LDR      r0,[r0,#0]
;;;826    {
;;;827      /* Check the parameters */
;;;828      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;829      assert_param(IS_TSC_GROUP_INDEX(gx_index));
;;;830    
;;;831      /* Return the group status */
;;;832      return (__HAL_TSC_GET_GROUP_STATUS(htsc, gx_index));
000002  f001020f          AND      r2,r1,#0xf
000006  3210              ADDS     r2,r2,#0x10
000008  2101              MOVS     r1,#1
00000a  6b00              LDR      r0,[r0,#0x30]
00000c  4091              LSLS     r1,r1,r2
00000e  4381              BICS     r1,r1,r0
000010  d001              BEQ      |L5.22|
000012  2000              MOVS     r0,#0
;;;833    }
000014  4770              BX       lr
                  |L5.22|
000016  2001              MOVS     r0,#1                 ;832
000018  4770              BX       lr
;;;834    
                          ENDP


                          AREA ||i.HAL_TSC_GroupGetValue||, CODE, READONLY, ALIGN=1

                  HAL_TSC_GroupGetValue PROC
;;;841      */
;;;842    uint32_t HAL_TSC_GroupGetValue(TSC_HandleTypeDef *htsc, uint32_t gx_index)
000000  6800              LDR      r0,[r0,#0]
;;;843    {
;;;844      /* Check the parameters */
;;;845      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;846      assert_param(IS_TSC_GROUP_INDEX(gx_index));
;;;847    
;;;848      /* Return the group acquisition counter */
;;;849      return htsc->Instance->IOGXCR[gx_index];
000002  2234              MOVS     r2,#0x34
000004  eb020181          ADD      r1,r2,r1,LSL #2
000008  5840              LDR      r0,[r0,r1]
;;;850    }
00000a  4770              BX       lr
;;;851    
                          ENDP


                          AREA ||i.HAL_TSC_IOConfig||, CODE, READONLY, ALIGN=1

                  HAL_TSC_IOConfig PROC
;;;876      */
;;;877    HAL_StatusTypeDef HAL_TSC_IOConfig(TSC_HandleTypeDef *htsc, TSC_IOConfigTypeDef *config)
000000  b510              PUSH     {r4,lr}
;;;878    {
000002  4604              MOV      r4,r0
;;;879      /* Check the parameters */
;;;880      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;881      assert_param(IS_TSC_GROUP(config->ChannelIOs));
;;;882      assert_param(IS_TSC_GROUP(config->ShieldIOs));
;;;883      assert_param(IS_TSC_GROUP(config->SamplingIOs));
;;;884    
;;;885      /* Process locked */
;;;886      __HAL_LOCK(htsc);
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  2801              CMP      r0,#1
00000a  d020              BEQ      |L7.78|
00000c  2001              MOVS     r0,#1
00000e  f884003d          STRB     r0,[r4,#0x3d]
;;;887    
;;;888      /* Stop acquisition */
;;;889      __HAL_TSC_STOP_ACQ(htsc);
000012  6820              LDR      r0,[r4,#0]
000014  6802              LDR      r2,[r0,#0]
000016  f0220202          BIC      r2,r2,#2
00001a  6002              STR      r2,[r0,#0]
;;;890    
;;;891      /* Disable Schmitt trigger hysteresis on all used TSC IOs */
;;;892      htsc->Instance->IOHCR = (~(config->ChannelIOs | config->ShieldIOs | config->SamplingIOs));
00001c  e9d10200          LDRD     r0,r2,[r1,#0]
000020  4310              ORRS     r0,r0,r2
000022  688a              LDR      r2,[r1,#8]
000024  4310              ORRS     r0,r0,r2
000026  6822              LDR      r2,[r4,#0]
000028  43c0              MVNS     r0,r0
00002a  6110              STR      r0,[r2,#0x10]
;;;893    
;;;894      /* Set channel and shield IOs */
;;;895      htsc->Instance->IOCCR = (config->ChannelIOs | config->ShieldIOs);
00002c  e9d10200          LDRD     r0,r2,[r1,#0]
000030  4310              ORRS     r0,r0,r2
000032  6822              LDR      r2,[r4,#0]
000034  6290              STR      r0,[r2,#0x28]
;;;896    
;;;897      /* Set sampling IOs */
;;;898      htsc->Instance->IOSCR = config->SamplingIOs;
000036  6822              LDR      r2,[r4,#0]
000038  6888              LDR      r0,[r1,#8]
00003a  6210              STR      r0,[r2,#0x20]
;;;899    
;;;900      /* Set groups to be acquired */
;;;901      htsc->Instance->IOGCSR = TSC_extract_groups(config->ChannelIOs);
00003c  6808              LDR      r0,[r1,#0]
00003e  f7fffffe          BL       TSC_extract_groups
000042  6821              LDR      r1,[r4,#0]
000044  6308              STR      r0,[r1,#0x30]
;;;902    
;;;903      /* Process unlocked */
;;;904      __HAL_UNLOCK(htsc);
000046  2000              MOVS     r0,#0
000048  f884003d          STRB     r0,[r4,#0x3d]
;;;905    
;;;906      /* Return function status */
;;;907      return HAL_OK;
;;;908    }
00004c  bd10              POP      {r4,pc}
                  |L7.78|
00004e  2002              MOVS     r0,#2                 ;886
000050  bd10              POP      {r4,pc}
;;;909    
                          ENDP


                          AREA ||i.HAL_TSC_IODischarge||, CODE, READONLY, ALIGN=1

                  HAL_TSC_IODischarge PROC
;;;916      */
;;;917    HAL_StatusTypeDef HAL_TSC_IODischarge(TSC_HandleTypeDef *htsc, FunctionalState choice)
000000  f890203d          LDRB     r2,[r0,#0x3d]
;;;918    {
;;;919      /* Check the parameters */
;;;920      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;921    
;;;922      /* Process locked */
;;;923      __HAL_LOCK(htsc);
000004  2a01              CMP      r2,#1
000006  d00e              BEQ      |L8.38|
000008  2201              MOVS     r2,#1
00000a  f880203d          STRB     r2,[r0,#0x3d]
;;;924    
;;;925      if (choice == ENABLE)
00000e  2901              CMP      r1,#1
000010  d00b              BEQ      |L8.42|
;;;926      {
;;;927        __HAL_TSC_SET_IODEF_OUTPPLOW(htsc);
;;;928      }
;;;929      else
;;;930      {
;;;931        __HAL_TSC_SET_IODEF_INFLOAT(htsc);
000012  6801              LDR      r1,[r0,#0]
000014  680a              LDR      r2,[r1,#0]
000016  f0420210          ORR      r2,r2,#0x10
00001a  600a              STR      r2,[r1,#0]
                  |L8.28|
;;;932      }
;;;933    
;;;934      /* Process unlocked */
;;;935      __HAL_UNLOCK(htsc);
00001c  2100              MOVS     r1,#0
00001e  f880103d          STRB     r1,[r0,#0x3d]
;;;936    
;;;937      /* Return the group acquisition counter */
;;;938      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;939    }
000024  4770              BX       lr
                  |L8.38|
000026  2002              MOVS     r0,#2                 ;923
000028  4770              BX       lr
                  |L8.42|
00002a  6801              LDR      r1,[r0,#0]            ;927
00002c  680a              LDR      r2,[r1,#0]            ;927
00002e  f0220210          BIC      r2,r2,#0x10           ;927
000032  600a              STR      r2,[r1,#0]            ;927
000034  e7f2              B        |L8.28|
;;;940    
                          ENDP


                          AREA ||i.HAL_TSC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TSC_IRQHandler PROC
;;;1007     */
;;;1008   void HAL_TSC_IRQHandler(TSC_HandleTypeDef *htsc)
000000  b510              PUSH     {r4,lr}
;;;1009   {
;;;1010     /* Check the parameters */
;;;1011     assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;1012   
;;;1013     /* Check if the end of acquisition occurred */
;;;1014     if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_EOA) != RESET)
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  43d2              MVNS     r2,r2
000008  07d3              LSLS     r3,r2,#31
;;;1015     {
;;;1016       /* Clear EOA flag */
;;;1017       __HAL_TSC_CLEAR_FLAG(htsc, TSC_FLAG_EOA);
00000a  f04f0201          MOV      r2,#1
00000e  d100              BNE      |L9.18|
000010  608a              STR      r2,[r1,#8]
                  |L9.18|
;;;1018     }
;;;1019   
;;;1020     /* Check if max count error occurred */
;;;1021     if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_MCE) != RESET)
000012  6801              LDR      r1,[r0,#0]
000014  68cb              LDR      r3,[r1,#0xc]
000016  43db              MVNS     r3,r3
000018  079b              LSLS     r3,r3,#30
00001a  d407              BMI      |L9.44|
;;;1022     {
;;;1023       /* Clear MCE flag */
;;;1024       __HAL_TSC_CLEAR_FLAG(htsc, TSC_FLAG_MCE);
00001c  2202              MOVS     r2,#2
00001e  608a              STR      r2,[r1,#8]
;;;1025       /* Change TSC state */
;;;1026       htsc->State = HAL_TSC_STATE_ERROR;
000020  2103              MOVS     r1,#3
000022  f880103c          STRB     r1,[r0,#0x3c]
;;;1027   #if (USE_HAL_TSC_REGISTER_CALLBACKS == 1)
;;;1028       htsc->ErrorCallback(htsc);
;;;1029   #else
;;;1030       /* Conversion completed callback */
;;;1031       HAL_TSC_ErrorCallback(htsc);
000026  f7fffffe          BL       HAL_TSC_ErrorCallback
;;;1032   #endif /* USE_HAL_TSC_REGISTER_CALLBACKS */
;;;1033     }
;;;1034     else
;;;1035     {
;;;1036       /* Change TSC state */
;;;1037       htsc->State = HAL_TSC_STATE_READY;
;;;1038   #if (USE_HAL_TSC_REGISTER_CALLBACKS == 1)
;;;1039       htsc->ConvCpltCallback(htsc);
;;;1040   #else
;;;1041       /* Conversion completed callback */
;;;1042       HAL_TSC_ConvCpltCallback(htsc);
;;;1043   #endif /* USE_HAL_TSC_REGISTER_CALLBACKS */
;;;1044     }
;;;1045   }
00002a  bd10              POP      {r4,pc}
                  |L9.44|
00002c  f880203c          STRB     r2,[r0,#0x3c]         ;1037
000030  f7fffffe          BL       HAL_TSC_ConvCpltCallback
000034  bd10              POP      {r4,pc}
;;;1046   
                          ENDP


                          AREA ||i.HAL_TSC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TSC_Init PROC
;;;244      */
;;;245    HAL_StatusTypeDef HAL_TSC_Init(TSC_HandleTypeDef *htsc)
000000  b570              PUSH     {r4-r6,lr}
;;;246    {
000002  4604              MOV      r4,r0
;;;247      /* Check TSC handle allocation */
;;;248      if (htsc == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L10.16|
;;;249      {
;;;250        return HAL_ERROR;
;;;251      }
;;;252    
;;;253      /* Check the parameters */
;;;254      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;255      assert_param(IS_TSC_CTPH(htsc->Init.CTPulseHighLength));
;;;256      assert_param(IS_TSC_CTPL(htsc->Init.CTPulseLowLength));
;;;257      assert_param(IS_TSC_SS(htsc->Init.SpreadSpectrum));
;;;258      assert_param(IS_TSC_SSD(htsc->Init.SpreadSpectrumDeviation));
;;;259      assert_param(IS_TSC_SS_PRESC(htsc->Init.SpreadSpectrumPrescaler));
;;;260      assert_param(IS_TSC_PG_PRESC(htsc->Init.PulseGeneratorPrescaler));
;;;261      assert_param(IS_TSC_PG_PRESC_VS_CTPL(htsc->Init.PulseGeneratorPrescaler, htsc->Init.CTPulseLowLength));
;;;262      assert_param(IS_TSC_MCV(htsc->Init.MaxCountValue));
;;;263      assert_param(IS_TSC_IODEF(htsc->Init.IODefaultMode));
;;;264      assert_param(IS_TSC_SYNC_POL(htsc->Init.SynchroPinPolarity));
;;;265      assert_param(IS_TSC_ACQ_MODE(htsc->Init.AcquisitionMode));
;;;266      assert_param(IS_TSC_MCE_IT(htsc->Init.MaxCountInterrupt));
;;;267      assert_param(IS_TSC_GROUP(htsc->Init.ChannelIOs));
;;;268      assert_param(IS_TSC_GROUP(htsc->Init.ShieldIOs));
;;;269      assert_param(IS_TSC_GROUP(htsc->Init.SamplingIOs));
;;;270    
;;;271      if (htsc->State == HAL_TSC_STATE_RESET)
000008  f894003c          LDRB     r0,[r4,#0x3c]
00000c  b110              CBZ      r0,|L10.20|
00000e  e007              B        |L10.32|
                  |L10.16|
000010  2001              MOVS     r0,#1                 ;250
;;;272      {
;;;273        /* Allocate lock resource and initialize it */
;;;274        htsc->Lock = HAL_UNLOCKED;
;;;275    
;;;276    #if (USE_HAL_TSC_REGISTER_CALLBACKS == 1)
;;;277        /* Init the TSC Callback settings */
;;;278        htsc->ConvCpltCallback  = HAL_TSC_ConvCpltCallback; /* Legacy weak ConvCpltCallback     */
;;;279        htsc->ErrorCallback     = HAL_TSC_ErrorCallback;    /* Legacy weak ErrorCallback        */
;;;280    
;;;281        if (htsc->MspInitCallback == NULL)
;;;282        {
;;;283          htsc->MspInitCallback = HAL_TSC_MspInit; /* Legacy weak MspInit  */
;;;284        }
;;;285    
;;;286        /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
;;;287        htsc->MspInitCallback(htsc);
;;;288    #else
;;;289        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;290        HAL_TSC_MspInit(htsc);
;;;291    #endif /* USE_HAL_TSC_REGISTER_CALLBACKS */
;;;292      }
;;;293    
;;;294      /* Initialize the TSC state */
;;;295      htsc->State = HAL_TSC_STATE_BUSY;
;;;296    
;;;297      /*--------------------------------------------------------------------------*/
;;;298      /* Set TSC parameters */
;;;299    
;;;300      /* Enable TSC */
;;;301      htsc->Instance->CR = TSC_CR_TSCE;
;;;302    
;;;303      /* Set all functions */
;;;304      htsc->Instance->CR |= (htsc->Init.CTPulseHighLength |
;;;305                             htsc->Init.CTPulseLowLength |
;;;306                             (htsc->Init.SpreadSpectrumDeviation << TSC_CR_SSD_Pos) |
;;;307                             htsc->Init.SpreadSpectrumPrescaler |
;;;308                             htsc->Init.PulseGeneratorPrescaler |
;;;309                             htsc->Init.MaxCountValue |
;;;310                             htsc->Init.SynchroPinPolarity |
;;;311                             htsc->Init.AcquisitionMode);
;;;312    
;;;313      /* Spread spectrum */
;;;314      if (htsc->Init.SpreadSpectrum == ENABLE)
;;;315      {
;;;316        htsc->Instance->CR |= TSC_CR_SSE;
;;;317      }
;;;318    
;;;319      /* Disable Schmitt trigger hysteresis on all used TSC IOs */
;;;320      htsc->Instance->IOHCR = (~(htsc->Init.ChannelIOs | htsc->Init.ShieldIOs | htsc->Init.SamplingIOs));
;;;321    
;;;322      /* Set channel and shield IOs */
;;;323      htsc->Instance->IOCCR = (htsc->Init.ChannelIOs | htsc->Init.ShieldIOs);
;;;324    
;;;325      /* Set sampling IOs */
;;;326      htsc->Instance->IOSCR = htsc->Init.SamplingIOs;
;;;327    
;;;328      /* Set the groups to be acquired */
;;;329      htsc->Instance->IOGCSR = TSC_extract_groups(htsc->Init.ChannelIOs);
;;;330    
;;;331      /* Disable interrupts */
;;;332      htsc->Instance->IER &= (~(TSC_IT_EOA | TSC_IT_MCE));
;;;333    
;;;334      /* Clear flags */
;;;335      htsc->Instance->ICR = (TSC_FLAG_EOA | TSC_FLAG_MCE);
;;;336    
;;;337      /*--------------------------------------------------------------------------*/
;;;338    
;;;339      /* Initialize the TSC state */
;;;340      htsc->State = HAL_TSC_STATE_READY;
;;;341    
;;;342      /* Return function status */
;;;343      return HAL_OK;
;;;344    }
000012  bd70              POP      {r4-r6,pc}
                  |L10.20|
000014  2000              MOVS     r0,#0                 ;274
000016  f884003d          STRB     r0,[r4,#0x3d]         ;274
00001a  4620              MOV      r0,r4                 ;290
00001c  f7fffffe          BL       HAL_TSC_MspInit
                  |L10.32|
000020  2002              MOVS     r0,#2                 ;295
000022  f884003c          STRB     r0,[r4,#0x3c]         ;295
000026  6820              LDR      r0,[r4,#0]            ;301
000028  2501              MOVS     r5,#1                 ;301
00002a  6005              STR      r5,[r0,#0]            ;301
00002c  e9d41001          LDRD     r1,r0,[r4,#4]         ;304
000030  4301              ORRS     r1,r1,r0              ;304
000032  8a22              LDRH     r2,[r4,#0x10]         ;304
000034  6960              LDR      r0,[r4,#0x14]         ;304
000036  ea404042          ORR      r0,r0,r2,LSL #17      ;304
00003a  4301              ORRS     r1,r1,r0              ;304
00003c  69a0              LDR      r0,[r4,#0x18]         ;304
00003e  4301              ORRS     r1,r1,r0              ;304
000040  69e0              LDR      r0,[r4,#0x1c]         ;304
000042  4301              ORRS     r1,r1,r0              ;304
000044  6a60              LDR      r0,[r4,#0x24]         ;304
000046  4301              ORRS     r1,r1,r0              ;304
000048  6aa0              LDR      r0,[r4,#0x28]         ;304
00004a  4301              ORRS     r1,r1,r0              ;304
00004c  6820              LDR      r0,[r4,#0]            ;304
00004e  6802              LDR      r2,[r0,#0]            ;304
000050  4311              ORRS     r1,r1,r2              ;304
000052  6001              STR      r1,[r0,#0]            ;304
000054  7b20              LDRB     r0,[r4,#0xc]          ;314
000056  2801              CMP      r0,#1                 ;314
000058  d104              BNE      |L10.100|
00005a  6820              LDR      r0,[r4,#0]            ;316
00005c  6801              LDR      r1,[r0,#0]            ;316
00005e  f4413180          ORR      r1,r1,#0x10000        ;316
000062  6001              STR      r1,[r0,#0]            ;316
                  |L10.100|
000064  e9d4010c          LDRD     r0,r1,[r4,#0x30]      ;320
000068  4308              ORRS     r0,r0,r1              ;320
00006a  6ba1              LDR      r1,[r4,#0x38]         ;320
00006c  4308              ORRS     r0,r0,r1              ;320
00006e  6821              LDR      r1,[r4,#0]            ;320
000070  43c0              MVNS     r0,r0                 ;320
000072  6108              STR      r0,[r1,#0x10]         ;320
000074  e9d4010c          LDRD     r0,r1,[r4,#0x30]      ;323
000078  4308              ORRS     r0,r0,r1              ;323
00007a  6821              LDR      r1,[r4,#0]            ;323
00007c  6288              STR      r0,[r1,#0x28]         ;323
00007e  6821              LDR      r1,[r4,#0]            ;326
000080  6ba0              LDR      r0,[r4,#0x38]         ;326
000082  6208              STR      r0,[r1,#0x20]         ;326
000084  6b20              LDR      r0,[r4,#0x30]         ;329
000086  f7fffffe          BL       TSC_extract_groups
00008a  6821              LDR      r1,[r4,#0]            ;329
00008c  6308              STR      r0,[r1,#0x30]         ;329
00008e  6820              LDR      r0,[r4,#0]            ;332
000090  6841              LDR      r1,[r0,#4]            ;332
000092  f0210103          BIC      r1,r1,#3              ;332
000096  6041              STR      r1,[r0,#4]            ;332
000098  6821              LDR      r1,[r4,#0]            ;335
00009a  2003              MOVS     r0,#3                 ;335
00009c  6088              STR      r0,[r1,#8]            ;335
00009e  f884503c          STRB     r5,[r4,#0x3c]         ;340
0000a2  2000              MOVS     r0,#0                 ;343
0000a4  bd70              POP      {r4-r6,pc}
;;;345    
                          ENDP


                          AREA ||i.HAL_TSC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TSC_MspDeInit PROC
;;;409      */
;;;410    __weak void HAL_TSC_MspDeInit(TSC_HandleTypeDef *htsc)
000000  4770              BX       lr
;;;411    {
;;;412      /* Prevent unused argument(s) compilation warning */
;;;413      UNUSED(htsc);
;;;414    
;;;415      /* NOTE : This function should not be modified, when the callback is needed,
;;;416                the HAL_TSC_MspDeInit could be implemented in the user file.
;;;417       */
;;;418    }
;;;419    
                          ENDP


                          AREA ||i.HAL_TSC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TSC_MspInit PROC
;;;393      */
;;;394    __weak void HAL_TSC_MspInit(TSC_HandleTypeDef *htsc)
000000  4770              BX       lr
;;;395    {
;;;396      /* Prevent unused argument(s) compilation warning */
;;;397      UNUSED(htsc);
;;;398    
;;;399      /* NOTE : This function should not be modified, when the callback is needed,
;;;400                the HAL_TSC_MspInit could be implemented in the user file.
;;;401       */
;;;402    }
;;;403    
                          ENDP


                          AREA ||i.HAL_TSC_PollForAcquisition||, CODE, READONLY, ALIGN=1

                  HAL_TSC_PollForAcquisition PROC
;;;797      */
;;;798    HAL_StatusTypeDef HAL_TSC_PollForAcquisition(TSC_HandleTypeDef *htsc)
000000  b500              PUSH     {lr}
;;;799    {
000002  4603              MOV      r3,r0
;;;800      /* Check the parameters */
;;;801      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;802    
;;;803      /* Process locked */
;;;804      __HAL_LOCK(htsc);
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2801              CMP      r0,#1
00000a  d00b              BEQ      |L13.36|
00000c  2001              MOVS     r0,#1
00000e  f883003d          STRB     r0,[r3,#0x3d]
                  |L13.18|
;;;805    
;;;806      /* Check end of acquisition */
;;;807      while (HAL_TSC_GetState(htsc) == HAL_TSC_STATE_BUSY)
000012  4618              MOV      r0,r3
000014  f7fffffe          BL       HAL_TSC_GetState
000018  2802              CMP      r0,#2
00001a  d0fa              BEQ      |L13.18|
;;;808      {
;;;809        /* The timeout (max count error) is managed by the TSC peripheral itself. */
;;;810      }
;;;811    
;;;812      /* Process unlocked */
;;;813      __HAL_UNLOCK(htsc);
00001c  2000              MOVS     r0,#0
00001e  f883003d          STRB     r0,[r3,#0x3d]
;;;814    
;;;815      return HAL_OK;
;;;816    }
000022  bd00              POP      {pc}
                  |L13.36|
000024  2002              MOVS     r0,#2                 ;804
000026  bd00              POP      {pc}
;;;817    
                          ENDP


                          AREA ||i.HAL_TSC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TSC_Start PROC
;;;629      */
;;;630    HAL_StatusTypeDef HAL_TSC_Start(TSC_HandleTypeDef *htsc)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;631    {
;;;632      /* Check the parameters */
;;;633      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;634    
;;;635      /* Process locked */
;;;636      __HAL_LOCK(htsc);
000004  2901              CMP      r1,#1
000006  d01e              BEQ      |L14.70|
000008  2101              MOVS     r1,#1
00000a  f880103d          STRB     r1,[r0,#0x3d]
;;;637    
;;;638      /* Change TSC state */
;;;639      htsc->State = HAL_TSC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f880103c          STRB     r1,[r0,#0x3c]
;;;640    
;;;641      /* Clear interrupts */
;;;642      __HAL_TSC_DISABLE_IT(htsc, (TSC_IT_EOA | TSC_IT_MCE));
000014  6801              LDR      r1,[r0,#0]
000016  684a              LDR      r2,[r1,#4]
000018  f0220203          BIC      r2,r2,#3
00001c  604a              STR      r2,[r1,#4]
;;;643    
;;;644      /* Clear flags */
;;;645      __HAL_TSC_CLEAR_FLAG(htsc, (TSC_FLAG_EOA | TSC_FLAG_MCE));
00001e  6802              LDR      r2,[r0,#0]
000020  2103              MOVS     r1,#3
000022  6091              STR      r1,[r2,#8]
000024  6a01              LDR      r1,[r0,#0x20]         ;636
000026  b181              CBZ      r1,|L14.74|
;;;646    
;;;647      /* Set touch sensing IOs not acquired to the specified IODefaultMode */
;;;648      if (htsc->Init.IODefaultMode == TSC_IODEF_OUT_PP_LOW)
;;;649      {
;;;650        __HAL_TSC_SET_IODEF_OUTPPLOW(htsc);
;;;651      }
;;;652      else
;;;653      {
;;;654        __HAL_TSC_SET_IODEF_INFLOAT(htsc);
000028  6801              LDR      r1,[r0,#0]
00002a  680a              LDR      r2,[r1,#0]
00002c  f0420210          ORR      r2,r2,#0x10
000030  600a              STR      r2,[r1,#0]
                  |L14.50|
;;;655      }
;;;656    
;;;657      /* Launch the acquisition */
;;;658      __HAL_TSC_START_ACQ(htsc);
000032  6801              LDR      r1,[r0,#0]
000034  680a              LDR      r2,[r1,#0]
000036  f0420202          ORR      r2,r2,#2
00003a  600a              STR      r2,[r1,#0]
;;;659    
;;;660      /* Process unlocked */
;;;661      __HAL_UNLOCK(htsc);
00003c  2100              MOVS     r1,#0
00003e  f880103d          STRB     r1,[r0,#0x3d]
;;;662    
;;;663      /* Return function status */
;;;664      return HAL_OK;
000042  2000              MOVS     r0,#0
;;;665    }
000044  4770              BX       lr
                  |L14.70|
000046  2002              MOVS     r0,#2                 ;636
000048  4770              BX       lr
                  |L14.74|
00004a  6801              LDR      r1,[r0,#0]            ;650
00004c  680a              LDR      r2,[r1,#0]            ;650
00004e  f0220210          BIC      r2,r2,#0x10           ;650
000052  600a              STR      r2,[r1,#0]            ;650
000054  e7ed              B        |L14.50|
;;;666    
                          ENDP


                          AREA ||i.HAL_TSC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TSC_Start_IT PROC
;;;672      */
;;;673    HAL_StatusTypeDef HAL_TSC_Start_IT(TSC_HandleTypeDef *htsc)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;674    {
;;;675      /* Check the parameters */
;;;676      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;677      assert_param(IS_TSC_MCE_IT(htsc->Init.MaxCountInterrupt));
;;;678    
;;;679      /* Process locked */
;;;680      __HAL_LOCK(htsc);
000004  2901              CMP      r1,#1
000006  d027              BEQ      |L15.88|
000008  2101              MOVS     r1,#1
00000a  f880103d          STRB     r1,[r0,#0x3d]
;;;681    
;;;682      /* Change TSC state */
;;;683      htsc->State = HAL_TSC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f880103c          STRB     r1,[r0,#0x3c]
;;;684    
;;;685      /* Enable end of acquisition interrupt */
;;;686      __HAL_TSC_ENABLE_IT(htsc, TSC_IT_EOA);
000014  6801              LDR      r1,[r0,#0]
000016  684a              LDR      r2,[r1,#4]
000018  f0420201          ORR      r2,r2,#1
00001c  604a              STR      r2,[r1,#4]
;;;687    
;;;688      /* Enable max count error interrupt (optional) */
;;;689      if (htsc->Init.MaxCountInterrupt == ENABLE)
00001e  f890102c          LDRB     r1,[r0,#0x2c]
000022  2901              CMP      r1,#1
000024  d01a              BEQ      |L15.92|
;;;690      {
;;;691        __HAL_TSC_ENABLE_IT(htsc, TSC_IT_MCE);
;;;692      }
;;;693      else
;;;694      {
;;;695        __HAL_TSC_DISABLE_IT(htsc, TSC_IT_MCE);
000026  6801              LDR      r1,[r0,#0]
000028  684a              LDR      r2,[r1,#4]
00002a  f0220202          BIC      r2,r2,#2
00002e  604a              STR      r2,[r1,#4]
                  |L15.48|
;;;696      }
;;;697    
;;;698      /* Clear flags */
;;;699      __HAL_TSC_CLEAR_FLAG(htsc, (TSC_FLAG_EOA | TSC_FLAG_MCE));
000030  6802              LDR      r2,[r0,#0]
000032  2103              MOVS     r1,#3
000034  6091              STR      r1,[r2,#8]
;;;700    
;;;701      /* Set touch sensing IOs not acquired to the specified IODefaultMode */
;;;702      if (htsc->Init.IODefaultMode == TSC_IODEF_OUT_PP_LOW)
000036  6a01              LDR      r1,[r0,#0x20]
000038  b1b1              CBZ      r1,|L15.104|
;;;703      {
;;;704        __HAL_TSC_SET_IODEF_OUTPPLOW(htsc);
;;;705      }
;;;706      else
;;;707      {
;;;708        __HAL_TSC_SET_IODEF_INFLOAT(htsc);
00003a  6801              LDR      r1,[r0,#0]
00003c  680a              LDR      r2,[r1,#0]
00003e  f0420210          ORR      r2,r2,#0x10
000042  600a              STR      r2,[r1,#0]
                  |L15.68|
;;;709      }
;;;710    
;;;711      /* Launch the acquisition */
;;;712      __HAL_TSC_START_ACQ(htsc);
000044  6801              LDR      r1,[r0,#0]
000046  680a              LDR      r2,[r1,#0]
000048  f0420202          ORR      r2,r2,#2
00004c  600a              STR      r2,[r1,#0]
;;;713    
;;;714      /* Process unlocked */
;;;715      __HAL_UNLOCK(htsc);
00004e  2100              MOVS     r1,#0
000050  f880103d          STRB     r1,[r0,#0x3d]
;;;716    
;;;717      /* Return function status */
;;;718      return HAL_OK;
000054  2000              MOVS     r0,#0
;;;719    }
000056  4770              BX       lr
                  |L15.88|
000058  2002              MOVS     r0,#2                 ;680
00005a  4770              BX       lr
                  |L15.92|
00005c  6801              LDR      r1,[r0,#0]            ;691
00005e  684a              LDR      r2,[r1,#4]            ;691
000060  f0420202          ORR      r2,r2,#2              ;691
000064  604a              STR      r2,[r1,#4]            ;691
000066  e7e3              B        |L15.48|
                  |L15.104|
000068  6801              LDR      r1,[r0,#0]            ;704
00006a  680a              LDR      r2,[r1,#0]            ;704
00006c  f0220210          BIC      r2,r2,#0x10           ;704
000070  600a              STR      r2,[r1,#0]            ;704
000072  e7e7              B        |L15.68|
;;;720    
                          ENDP


                          AREA ||i.HAL_TSC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TSC_Stop PROC
;;;726      */
;;;727    HAL_StatusTypeDef HAL_TSC_Stop(TSC_HandleTypeDef *htsc)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;728    {
;;;729      /* Check the parameters */
;;;730      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;731    
;;;732      /* Process locked */
;;;733      __HAL_LOCK(htsc);
000004  2901              CMP      r1,#1
000006  d016              BEQ      |L16.54|
000008  2201              MOVS     r2,#1
00000a  f880203d          STRB     r2,[r0,#0x3d]
;;;734    
;;;735      /* Stop the acquisition */
;;;736      __HAL_TSC_STOP_ACQ(htsc);
00000e  6801              LDR      r1,[r0,#0]
000010  680b              LDR      r3,[r1,#0]
000012  f0230302          BIC      r3,r3,#2
000016  600b              STR      r3,[r1,#0]
;;;737    
;;;738      /* Set touch sensing IOs in low power mode (output push-pull) */
;;;739      __HAL_TSC_SET_IODEF_OUTPPLOW(htsc);
000018  6801              LDR      r1,[r0,#0]
00001a  680b              LDR      r3,[r1,#0]
00001c  f0230310          BIC      r3,r3,#0x10
000020  600b              STR      r3,[r1,#0]
;;;740    
;;;741      /* Clear flags */
;;;742      __HAL_TSC_CLEAR_FLAG(htsc, (TSC_FLAG_EOA | TSC_FLAG_MCE));
000022  6803              LDR      r3,[r0,#0]
000024  2103              MOVS     r1,#3
000026  6099              STR      r1,[r3,#8]
;;;743    
;;;744      /* Change TSC state */
;;;745      htsc->State = HAL_TSC_STATE_READY;
000028  f880203c          STRB     r2,[r0,#0x3c]
;;;746    
;;;747      /* Process unlocked */
;;;748      __HAL_UNLOCK(htsc);
00002c  2100              MOVS     r1,#0
00002e  f880103d          STRB     r1,[r0,#0x3d]
;;;749    
;;;750      /* Return function status */
;;;751      return HAL_OK;
000032  2000              MOVS     r0,#0
;;;752    }
000034  4770              BX       lr
                  |L16.54|
000036  2002              MOVS     r0,#2                 ;733
000038  4770              BX       lr
;;;753    
                          ENDP


                          AREA ||i.HAL_TSC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TSC_Stop_IT PROC
;;;759      */
;;;760    HAL_StatusTypeDef HAL_TSC_Stop_IT(TSC_HandleTypeDef *htsc)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;761    {
;;;762      /* Check the parameters */
;;;763      assert_param(IS_TSC_ALL_INSTANCE(htsc->Instance));
;;;764    
;;;765      /* Process locked */
;;;766      __HAL_LOCK(htsc);
000004  2901              CMP      r1,#1
000006  d01b              BEQ      |L17.64|
000008  2201              MOVS     r2,#1
00000a  f880203d          STRB     r2,[r0,#0x3d]
;;;767    
;;;768      /* Stop the acquisition */
;;;769      __HAL_TSC_STOP_ACQ(htsc);
00000e  6801              LDR      r1,[r0,#0]
000010  680b              LDR      r3,[r1,#0]
000012  f0230302          BIC      r3,r3,#2
000016  600b              STR      r3,[r1,#0]
;;;770    
;;;771      /* Set touch sensing IOs in low power mode (output push-pull) */
;;;772      __HAL_TSC_SET_IODEF_OUTPPLOW(htsc);
000018  6801              LDR      r1,[r0,#0]
00001a  680b              LDR      r3,[r1,#0]
00001c  f0230310          BIC      r3,r3,#0x10
000020  600b              STR      r3,[r1,#0]
;;;773    
;;;774      /* Disable interrupts */
;;;775      __HAL_TSC_DISABLE_IT(htsc, (TSC_IT_EOA | TSC_IT_MCE));
000022  6801              LDR      r1,[r0,#0]
000024  684b              LDR      r3,[r1,#4]
000026  f0230303          BIC      r3,r3,#3
00002a  604b              STR      r3,[r1,#4]
;;;776    
;;;777      /* Clear flags */
;;;778      __HAL_TSC_CLEAR_FLAG(htsc, (TSC_FLAG_EOA | TSC_FLAG_MCE));
00002c  6803              LDR      r3,[r0,#0]
00002e  2103              MOVS     r1,#3
000030  6099              STR      r1,[r3,#8]
;;;779    
;;;780      /* Change TSC state */
;;;781      htsc->State = HAL_TSC_STATE_READY;
000032  f880203c          STRB     r2,[r0,#0x3c]
;;;782    
;;;783      /* Process unlocked */
;;;784      __HAL_UNLOCK(htsc);
000036  2100              MOVS     r1,#0
000038  f880103d          STRB     r1,[r0,#0x3d]
;;;785    
;;;786      /* Return function status */
;;;787      return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;788    }
00003e  4770              BX       lr
                  |L17.64|
000040  2002              MOVS     r0,#2                 ;766
000042  4770              BX       lr
;;;789    
                          ENDP


                          AREA ||i.TSC_extract_groups||, CODE, READONLY, ALIGN=1

                  TSC_extract_groups PROC
;;;1096     */
;;;1097   static uint32_t TSC_extract_groups(uint32_t iomask)
000000  b570              PUSH     {r4-r6,lr}
;;;1098   {
000002  4602              MOV      r2,r0
;;;1099     uint32_t groups = 0UL;
000004  2000              MOVS     r0,#0
;;;1100     uint32_t idx;
;;;1101   
;;;1102     for (idx = 0UL; idx < (uint32_t)TSC_NB_OF_GROUPS; idx++)
000006  2100              MOVS     r1,#0
;;;1103     {
;;;1104       if ((iomask & (0x0FUL << (idx * 4UL))) != 0UL )
000008  240f              MOVS     r4,#0xf
;;;1105       {
;;;1106         groups |= (1UL << idx);
00000a  2501              MOVS     r5,#1
                  |L18.12|
00000c  008e              LSLS     r6,r1,#2              ;1104
00000e  fa04f306          LSL      r3,r4,r6              ;1104
000012  4213              TST      r3,r2                 ;1104
000014  d002              BEQ      |L18.28|
000016  fa05f301          LSL      r3,r5,r1
00001a  4318              ORRS     r0,r0,r3
                  |L18.28|
00001c  1c49              ADDS     r1,r1,#1              ;1102
00001e  2908              CMP      r1,#8                 ;1102
000020  d3f4              BCC      |L18.12|
;;;1107       }
;;;1108     }
;;;1109   
;;;1110     return groups;
;;;1111   }
000022  bd70              POP      {r4-r6,pc}
;;;1112   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_tsc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_tsc_c_c4cd125f____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_tsc_c_c4cd125f____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_tsc_c_c4cd125f____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_tsc_c_c4cd125f____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_tsc_c_c4cd125f____RRX|
#line 694
|__asm___19_stm32l4xx_hal_tsc_c_c4cd125f____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
