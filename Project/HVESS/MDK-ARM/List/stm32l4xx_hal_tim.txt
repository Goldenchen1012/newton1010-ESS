; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_tim.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_tim.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;327      */
;;;328    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;329    {
000002  4604              MOV      r4,r0
;;;330      /* Check the parameters */
;;;331      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;332    
;;;333      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;334    
;;;335      /* Disable the TIM Peripheral Clock */
;;;336      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L1.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L1.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L1.38|
;;;337    
;;;338    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;339      if (htim->Base_MspDeInitCallback == NULL)
;;;340      {
;;;341        htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
;;;342      }
;;;343      /* DeInit the low level hardware */
;;;344      htim->Base_MspDeInitCallback(htim);
;;;345    #else
;;;346      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;347      HAL_TIM_Base_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;348    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;349    
;;;350      /* Change the DMA burst operation state */
;;;351      htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7320              STRB     r0,[r4,#0xc]
;;;352    
;;;353      /* Change the TIM channels state */
;;;354      TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
000032  70a0              STRB     r0,[r4,#2]
000034  70e0              STRB     r0,[r4,#3]
000036  7120              STRB     r0,[r4,#4]
000038  7160              STRB     r0,[r4,#5]
00003a  71a0              STRB     r0,[r4,#6]
00003c  71e0              STRB     r0,[r4,#7]
;;;355      TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
00003e  7220              STRB     r0,[r4,#8]
000040  7260              STRB     r0,[r4,#9]
000042  72a0              STRB     r0,[r4,#0xa]
000044  72e0              STRB     r0,[r4,#0xb]
;;;356    
;;;357      /* Change TIM state */
;;;358      htim->State = HAL_TIM_STATE_RESET;
000046  7060              STRB     r0,[r4,#1]
;;;359    
;;;360      /* Release Lock */
;;;361      __HAL_UNLOCK(htim);
000048  7020              STRB     r0,[r4,#0]
;;;362    
;;;363      return HAL_OK;
;;;364    }
00004a  bd10              POP      {r4,pc}
;;;365    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;6302     */
;;;6303   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;6304   {
;;;6305     return htim->State;
;;;6306   }
000004  4770              BX       lr
;;;6307   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;268      */
;;;269    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;270    {
000002  4604              MOV      r4,r0
;;;271      /* Check the TIM handle allocation */
;;;272      if (htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L3.16|
;;;273      {
;;;274        return HAL_ERROR;
;;;275      }
;;;276    
;;;277      /* Check the parameters */
;;;278      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;279      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;280      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;281      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;282    
;;;283      if (htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L3.20|
00000e  e007              B        |L3.32|
                  |L3.16|
000010  2001              MOVS     r0,#1                 ;274
;;;284      {
;;;285        /* Allocate lock resource and initialize it */
;;;286        htim->Lock = HAL_UNLOCKED;
;;;287    
;;;288    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;289        /* Reset interrupt callbacks to legacy weak callbacks */
;;;290        TIM_ResetCallback(htim);
;;;291    
;;;292        if (htim->Base_MspInitCallback == NULL)
;;;293        {
;;;294          htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
;;;295        }
;;;296        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;297        htim->Base_MspInitCallback(htim);
;;;298    #else
;;;299        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;300        HAL_TIM_Base_MspInit(htim);
;;;301    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;302      }
;;;303    
;;;304      /* Set the TIM state */
;;;305      htim->State = HAL_TIM_STATE_BUSY;
;;;306    
;;;307      /* Set the Time Base configuration */
;;;308      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;309    
;;;310      /* Initialize the DMA burst operation state */
;;;311      htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
;;;312    
;;;313      /* Initialize the TIM channels state */
;;;314      TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;315      TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;316    
;;;317      /* Initialize the TIM state*/
;;;318      htim->State = HAL_TIM_STATE_READY;
;;;319    
;;;320      return HAL_OK;
;;;321    }
000012  bd10              POP      {r4,pc}
                  |L3.20|
000014  2000              MOVS     r0,#0                 ;286
000016  f884003c          STRB     r0,[r4,#0x3c]         ;286
00001a  4620              MOV      r0,r4                 ;300
00001c  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.32|
000020  2002              MOVS     r0,#2                 ;305
000022  f884003d          STRB     r0,[r4,#0x3d]         ;305
000026  1d21              ADDS     r1,r4,#4              ;308
000028  6820              LDR      r0,[r4,#0]            ;308
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;311
000030  343d              ADDS     r4,r4,#0x3d           ;311
000032  72e0              STRB     r0,[r4,#0xb]          ;311
000034  7060              STRB     r0,[r4,#1]            ;314
000036  70a0              STRB     r0,[r4,#2]            ;314
000038  70e0              STRB     r0,[r4,#3]            ;314
00003a  7120              STRB     r0,[r4,#4]            ;314
00003c  7160              STRB     r0,[r4,#5]            ;314
00003e  71a0              STRB     r0,[r4,#6]            ;314
000040  71e0              STRB     r0,[r4,#7]            ;315
000042  7220              STRB     r0,[r4,#8]            ;315
000044  7260              STRB     r0,[r4,#9]            ;315
000046  72a0              STRB     r0,[r4,#0xa]          ;315
000048  7020              STRB     r0,[r4,#0]            ;318
00004a  2000              MOVS     r0,#0                 ;320
00004c  bd10              POP      {r4,pc}
;;;322    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;385      */
;;;386    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;387    {
;;;388      /* Prevent unused argument(s) compilation warning */
;;;389      UNUSED(htim);
;;;390    
;;;391      /* NOTE : This function should not be modified, when the callback is needed,
;;;392                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;393       */
;;;394    }
;;;395    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;370      */
;;;371    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;372    {
;;;373      /* Prevent unused argument(s) compilation warning */
;;;374      UNUSED(htim);
;;;375    
;;;376      /* NOTE : This function should not be modified, when the callback is needed,
;;;377                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;378       */
;;;379    }
;;;380    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start PROC
;;;401      */
;;;402    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;403    {
;;;404      uint32_t tmpsmcr;
;;;405    
;;;406      /* Check the parameters */
;;;407      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;408    
;;;409      /* Check the TIM state */
;;;410      if (htim->State != HAL_TIM_STATE_READY)
000004  2901              CMP      r1,#1
000006  d001              BEQ      |L6.12|
;;;411      {
;;;412        return HAL_ERROR;
000008  2001              MOVS     r0,#1
;;;413      }
;;;414    
;;;415      /* Set the TIM state */
;;;416      htim->State = HAL_TIM_STATE_BUSY;
;;;417    
;;;418      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;419      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;420      {
;;;421        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;422        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;423        {
;;;424          __HAL_TIM_ENABLE(htim);
;;;425        }
;;;426      }
;;;427      else
;;;428      {
;;;429        __HAL_TIM_ENABLE(htim);
;;;430      }
;;;431    
;;;432      /* Return function status */
;;;433      return HAL_OK;
;;;434    }
00000a  4770              BX       lr
                  |L6.12|
00000c  2102              MOVS     r1,#2                 ;416
00000e  f880103d          STRB     r1,[r0,#0x3d]         ;416
000012  6800              LDR      r0,[r0,#0]            ;419
000014  4913              LDR      r1,|L6.100|
000016  4288              CMP      r0,r1                 ;419
000018  d011              BEQ      |L6.62|
00001a  f1b04f80          CMP      r0,#0x40000000        ;419
00001e  d00e              BEQ      |L6.62|
000020  4911              LDR      r1,|L6.104|
000022  4288              CMP      r0,r1                 ;419
000024  d00b              BEQ      |L6.62|
000026  4911              LDR      r1,|L6.108|
000028  4288              CMP      r0,r1                 ;419
00002a  d008              BEQ      |L6.62|
00002c  4910              LDR      r1,|L6.112|
00002e  4288              CMP      r0,r1                 ;419
000030  d005              BEQ      |L6.62|
000032  4910              LDR      r1,|L6.116|
000034  4288              CMP      r0,r1                 ;419
000036  d002              BEQ      |L6.62|
000038  490f              LDR      r1,|L6.120|
00003a  4288              CMP      r0,r1                 ;419
00003c  d10c              BNE      |L6.88|
                  |L6.62|
00003e  6881              LDR      r1,[r0,#8]            ;421
000040  4a0e              LDR      r2,|L6.124|
000042  4011              ANDS     r1,r1,r2              ;421
000044  2906              CMP      r1,#6                 ;422
000046  d00b              BEQ      |L6.96|
000048  f5b13f80          CMP      r1,#0x10000           ;422
00004c  d008              BEQ      |L6.96|
00004e  6801              LDR      r1,[r0,#0]            ;424
000050  f0410101          ORR      r1,r1,#1              ;424
000054  6001              STR      r1,[r0,#0]            ;424
000056  e003              B        |L6.96|
                  |L6.88|
000058  6801              LDR      r1,[r0,#0]            ;429
00005a  f0410101          ORR      r1,r1,#1              ;429
00005e  6001              STR      r1,[r0,#0]            ;429
                  |L6.96|
000060  2000              MOVS     r0,#0                 ;433
000062  4770              BX       lr
;;;435    
                          ENDP

                  |L6.100|
                          DCD      0x40012c00
                  |L6.104|
                          DCD      0x40000400
                  |L6.108|
                          DCD      0x40000800
                  |L6.112|
                          DCD      0x40000c00
                  |L6.116|
                          DCD      0x40013400
                  |L6.120|
                          DCD      0x40014000
                  |L6.124|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;527      */
;;;528    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;529    {
000002  4604              MOV      r4,r0
000004  4613              MOV      r3,r2
;;;530      uint32_t tmpsmcr;
;;;531    
;;;532      /* Check the parameters */
;;;533      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;534    
;;;535      /* Set the TIM state */
;;;536      if (htim->State == HAL_TIM_STATE_BUSY)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2802              CMP      r0,#2
00000c  d005              BEQ      |L7.26|
;;;537      {
;;;538        return HAL_BUSY;
;;;539      }
;;;540      else if (htim->State == HAL_TIM_STATE_READY)
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2801              CMP      r0,#1
000014  d003              BEQ      |L7.30|
;;;541      {
;;;542        if ((pData == NULL) && (Length > 0U))
;;;543        {
;;;544          return HAL_ERROR;
;;;545        }
;;;546        else
;;;547        {
;;;548          htim->State = HAL_TIM_STATE_BUSY;
;;;549        }
;;;550      }
;;;551      else
;;;552      {
;;;553        return HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;554      }
;;;555    
;;;556      /* Set the DMA Period elapsed callbacks */
;;;557      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;558      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
;;;559    
;;;560      /* Set the DMA error callback */
;;;561      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;562    
;;;563      /* Enable the DMA channel */
;;;564      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
;;;565      {
;;;566        /* Return error status */
;;;567        return HAL_ERROR;
;;;568      }
;;;569    
;;;570      /* Enable the TIM Update DMA request */
;;;571      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;572    
;;;573      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;574      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;575      {
;;;576        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;577        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;578        {
;;;579          __HAL_TIM_ENABLE(htim);
;;;580        }
;;;581      }
;;;582      else
;;;583      {
;;;584        __HAL_TIM_ENABLE(htim);
;;;585      }
;;;586    
;;;587      /* Return function status */
;;;588      return HAL_OK;
;;;589    }
000018  bd10              POP      {r4,pc}
                  |L7.26|
00001a  2002              MOVS     r0,#2                 ;538
00001c  bd10              POP      {r4,pc}
                  |L7.30|
00001e  b911              CBNZ     r1,|L7.38|
000020  b10b              CBZ      r3,|L7.38|
000022  2001              MOVS     r0,#1                 ;544
000024  bd10              POP      {r4,pc}
                  |L7.38|
000026  2002              MOVS     r0,#2                 ;548
000028  f884003d          STRB     r0,[r4,#0x3d]         ;548
00002c  6a22              LDR      r2,[r4,#0x20]         ;557
00002e  481f              LDR      r0,|L7.172|
000030  62d0              STR      r0,[r2,#0x2c]         ;557
000032  6a22              LDR      r2,[r4,#0x20]         ;558
000034  481e              LDR      r0,|L7.176|
000036  6310              STR      r0,[r2,#0x30]         ;558
000038  6a22              LDR      r2,[r4,#0x20]         ;561
00003a  481e              LDR      r0,|L7.180|
00003c  6350              STR      r0,[r2,#0x34]         ;561
00003e  6822              LDR      r2,[r4,#0]            ;564
000040  6a20              LDR      r0,[r4,#0x20]         ;564
000042  322c              ADDS     r2,r2,#0x2c           ;564
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  b108              CBZ      r0,|L7.78|
00004a  2001              MOVS     r0,#1                 ;567
00004c  bd10              POP      {r4,pc}
                  |L7.78|
00004e  6820              LDR      r0,[r4,#0]            ;571
000050  68c1              LDR      r1,[r0,#0xc]          ;571
000052  f4417180          ORR      r1,r1,#0x100          ;571
000056  60c1              STR      r1,[r0,#0xc]          ;571
000058  4917              LDR      r1,|L7.184|
00005a  6820              LDR      r0,[r4,#0]            ;574
00005c  4288              CMP      r0,r1                 ;574
00005e  d011              BEQ      |L7.132|
000060  f1b04f80          CMP      r0,#0x40000000        ;574
000064  d00e              BEQ      |L7.132|
000066  4915              LDR      r1,|L7.188|
000068  4288              CMP      r0,r1                 ;574
00006a  d00b              BEQ      |L7.132|
00006c  4914              LDR      r1,|L7.192|
00006e  4288              CMP      r0,r1                 ;574
000070  d008              BEQ      |L7.132|
000072  4914              LDR      r1,|L7.196|
000074  4288              CMP      r0,r1                 ;574
000076  d005              BEQ      |L7.132|
000078  4913              LDR      r1,|L7.200|
00007a  4288              CMP      r0,r1                 ;574
00007c  d002              BEQ      |L7.132|
00007e  4913              LDR      r1,|L7.204|
000080  4288              CMP      r0,r1                 ;574
000082  d10c              BNE      |L7.158|
                  |L7.132|
000084  6881              LDR      r1,[r0,#8]            ;576
000086  4a12              LDR      r2,|L7.208|
000088  4011              ANDS     r1,r1,r2              ;576
00008a  2906              CMP      r1,#6                 ;577
00008c  d00b              BEQ      |L7.166|
00008e  f5b13f80          CMP      r1,#0x10000           ;577
000092  d008              BEQ      |L7.166|
000094  6801              LDR      r1,[r0,#0]            ;579
000096  f0410101          ORR      r1,r1,#1              ;579
00009a  6001              STR      r1,[r0,#0]            ;579
00009c  e003              B        |L7.166|
                  |L7.158|
00009e  6801              LDR      r1,[r0,#0]            ;584
0000a0  f0410101          ORR      r1,r1,#1              ;584
0000a4  6001              STR      r1,[r0,#0]            ;584
                  |L7.166|
0000a6  2000              MOVS     r0,#0                 ;588
0000a8  bd10              POP      {r4,pc}
;;;590    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L7.172|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.176|
                          DCD      TIM_DMAPeriodElapsedHalfCplt
                  |L7.180|
                          DCD      TIM_DMAError
                  |L7.184|
                          DCD      0x40012c00
                  |L7.188|
                          DCD      0x40000400
                  |L7.192|
                          DCD      0x40000800
                  |L7.196|
                          DCD      0x40000c00
                  |L7.200|
                          DCD      0x40013400
                  |L7.204|
                          DCD      0x40014000
                  |L7.208|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_IT PROC
;;;460      */
;;;461    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;462    {
;;;463      uint32_t tmpsmcr;
;;;464    
;;;465      /* Check the parameters */
;;;466      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;467    
;;;468      /* Check the TIM state */
;;;469      if (htim->State != HAL_TIM_STATE_READY)
000004  2901              CMP      r1,#1
000006  d001              BEQ      |L8.12|
;;;470      {
;;;471        return HAL_ERROR;
000008  2001              MOVS     r0,#1
;;;472      }
;;;473    
;;;474      /* Set the TIM state */
;;;475      htim->State = HAL_TIM_STATE_BUSY;
;;;476    
;;;477      /* Enable the TIM Update interrupt */
;;;478      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
;;;479    
;;;480      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;481      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;482      {
;;;483        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;484        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;485        {
;;;486          __HAL_TIM_ENABLE(htim);
;;;487        }
;;;488      }
;;;489      else
;;;490      {
;;;491        __HAL_TIM_ENABLE(htim);
;;;492      }
;;;493    
;;;494      /* Return function status */
;;;495      return HAL_OK;
;;;496    }
00000a  4770              BX       lr
                  |L8.12|
00000c  2102              MOVS     r1,#2                 ;475
00000e  f880103d          STRB     r1,[r0,#0x3d]         ;475
000012  6801              LDR      r1,[r0,#0]            ;478
000014  68ca              LDR      r2,[r1,#0xc]          ;478
000016  f0420201          ORR      r2,r2,#1              ;478
00001a  60ca              STR      r2,[r1,#0xc]          ;478
00001c  6800              LDR      r0,[r0,#0]            ;481
00001e  4914              LDR      r1,|L8.112|
000020  4288              CMP      r0,r1                 ;481
000022  d011              BEQ      |L8.72|
000024  f1b04f80          CMP      r0,#0x40000000        ;481
000028  d00e              BEQ      |L8.72|
00002a  4912              LDR      r1,|L8.116|
00002c  4288              CMP      r0,r1                 ;481
00002e  d00b              BEQ      |L8.72|
000030  4911              LDR      r1,|L8.120|
000032  4288              CMP      r0,r1                 ;481
000034  d008              BEQ      |L8.72|
000036  4911              LDR      r1,|L8.124|
000038  4288              CMP      r0,r1                 ;481
00003a  d005              BEQ      |L8.72|
00003c  4910              LDR      r1,|L8.128|
00003e  4288              CMP      r0,r1                 ;481
000040  d002              BEQ      |L8.72|
000042  4910              LDR      r1,|L8.132|
000044  4288              CMP      r0,r1                 ;481
000046  d10c              BNE      |L8.98|
                  |L8.72|
000048  6881              LDR      r1,[r0,#8]            ;483
00004a  4a0f              LDR      r2,|L8.136|
00004c  4011              ANDS     r1,r1,r2              ;483
00004e  2906              CMP      r1,#6                 ;484
000050  d00b              BEQ      |L8.106|
000052  f5b13f80          CMP      r1,#0x10000           ;484
000056  d008              BEQ      |L8.106|
000058  6801              LDR      r1,[r0,#0]            ;486
00005a  f0410101          ORR      r1,r1,#1              ;486
00005e  6001              STR      r1,[r0,#0]            ;486
000060  e003              B        |L8.106|
                  |L8.98|
000062  6801              LDR      r1,[r0,#0]            ;491
000064  f0410101          ORR      r1,r1,#1              ;491
000068  6001              STR      r1,[r0,#0]            ;491
                  |L8.106|
00006a  2000              MOVS     r0,#0                 ;495
00006c  4770              BX       lr
;;;497    
                          ENDP

00006e  0000              DCW      0x0000
                  |L8.112|
                          DCD      0x40012c00
                  |L8.116|
                          DCD      0x40000400
                  |L8.120|
                          DCD      0x40000800
                  |L8.124|
                          DCD      0x40000c00
                  |L8.128|
                          DCD      0x40013400
                  |L8.132|
                          DCD      0x40014000
                  |L8.136|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;440      */
;;;441    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;442    {
;;;443      /* Check the parameters */
;;;444      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;445    
;;;446      /* Disable the Peripheral */
;;;447      __HAL_TIM_DISABLE(htim);
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f2411311          MOV      r3,#0x1111
000008  421a              TST      r2,r3
00000a  d107              BNE      |L9.28|
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  109b              ASRS     r3,r3,#2
000010  421a              TST      r2,r3
000012  d103              BNE      |L9.28|
000014  680a              LDR      r2,[r1,#0]
000016  f0220201          BIC      r2,r2,#1
00001a  600a              STR      r2,[r1,#0]
                  |L9.28|
;;;448    
;;;449      /* Set the TIM state */
;;;450      htim->State = HAL_TIM_STATE_READY;
00001c  2101              MOVS     r1,#1
00001e  f880103d          STRB     r1,[r0,#0x3d]
;;;451    
;;;452      /* Return function status */
;;;453      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;454    }
000024  4770              BX       lr
;;;455    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;595      */
;;;596    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;597    {
000002  4604              MOV      r4,r0
;;;598      /* Check the parameters */
;;;599      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;600    
;;;601      /* Disable the TIM Update DMA request */
;;;602      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217180          BIC      r1,r1,#0x100
00000c  60c1              STR      r1,[r0,#0xc]
;;;603    
;;;604      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
00000e  6a20              LDR      r0,[r4,#0x20]
000010  f7fffffe          BL       HAL_DMA_Abort_IT
;;;605    
;;;606      /* Disable the Peripheral */
;;;607      __HAL_TIM_DISABLE(htim);
000014  6820              LDR      r0,[r4,#0]
000016  6a01              LDR      r1,[r0,#0x20]
000018  f2411211          MOV      r2,#0x1111
00001c  4211              TST      r1,r2
00001e  d107              BNE      |L10.48|
000020  6a01              LDR      r1,[r0,#0x20]
000022  1092              ASRS     r2,r2,#2
000024  4211              TST      r1,r2
000026  d103              BNE      |L10.48|
000028  6801              LDR      r1,[r0,#0]
00002a  f0210101          BIC      r1,r1,#1
00002e  6001              STR      r1,[r0,#0]
                  |L10.48|
;;;608    
;;;609      /* Set the TIM state */
;;;610      htim->State = HAL_TIM_STATE_READY;
000030  2001              MOVS     r0,#1
000032  f884003d          STRB     r0,[r4,#0x3d]
;;;611    
;;;612      /* Return function status */
;;;613      return HAL_OK;
000036  2000              MOVS     r0,#0
;;;614    }
000038  bd10              POP      {r4,pc}
;;;615    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;502      */
;;;503    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;504    {
;;;505      /* Check the parameters */
;;;506      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;507    
;;;508      /* Disable the TIM Update interrupt */
;;;509      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;510    
;;;511      /* Disable the Peripheral */
;;;512      __HAL_TIM_DISABLE(htim);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  f2411311          MOV      r3,#0x1111
000012  421a              TST      r2,r3
000014  d107              BNE      |L11.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L11.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L11.38|
;;;513    
;;;514      /* Set the TIM state */
;;;515      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  f880103d          STRB     r1,[r0,#0x3d]
;;;516    
;;;517      /* Return function status */
;;;518      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;519    }
00002e  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=2

                  HAL_TIM_ConfigClockSource PROC
;;;5289     */
;;;5290   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;5291   {
000002  4604              MOV      r4,r0
;;;5292     uint32_t tmpsmcr;
;;;5293   
;;;5294     /* Process Locked */
;;;5295     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d017              BEQ      |L12.60|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;5296   
;;;5297     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;5298   
;;;5299     /* Check the parameters */
;;;5300     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;5301   
;;;5302     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;5303     tmpsmcr = htim->Instance->SMCR;
000018  6820              LDR      r0,[r4,#0]
00001a  6882              LDR      r2,[r0,#8]
;;;5304     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
00001c  4b31              LDR      r3,|L12.228|
00001e  401a              ANDS     r2,r2,r3
;;;5305     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000020  f422427f          BIC      r2,r2,#0xff00
;;;5306     htim->Instance->SMCR = tmpsmcr;
000024  6082              STR      r2,[r0,#8]
;;;5307   
;;;5308     switch (sClockSourceConfig->ClockSource)
000026  6808              LDR      r0,[r1,#0]
000028  2850              CMP      r0,#0x50
00002a  d031              BEQ      |L12.144|
00002c  dc0d              BGT      |L12.74|
00002e  2820              CMP      r0,#0x20
000030  d04d              BEQ      |L12.206|
000032  dc05              BGT      |L12.64|
000034  b3b0              CBZ      r0,|L12.164|
000036  2810              CMP      r0,#0x10
000038  d14e              BNE      |L12.216|
00003a  e048              B        |L12.206|
                  |L12.60|
00003c  2002              MOVS     r0,#2                 ;5295
;;;5309     {
;;;5310       case TIM_CLOCKSOURCE_INTERNAL:
;;;5311       {
;;;5312         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;5313         break;
;;;5314       }
;;;5315   
;;;5316       case TIM_CLOCKSOURCE_ETRMODE1:
;;;5317       {
;;;5318         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;5319         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;5320   
;;;5321         /* Check ETR input conditioning related parameters */
;;;5322         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;5323         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;5324         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;5325   
;;;5326         /* Configure the ETR Clock source */
;;;5327         TIM_ETR_SetConfig(htim->Instance,
;;;5328                           sClockSourceConfig->ClockPrescaler,
;;;5329                           sClockSourceConfig->ClockPolarity,
;;;5330                           sClockSourceConfig->ClockFilter);
;;;5331   
;;;5332         /* Select the External clock mode1 and the ETRF trigger */
;;;5333         tmpsmcr = htim->Instance->SMCR;
;;;5334         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;5335         /* Write to TIMx SMCR */
;;;5336         htim->Instance->SMCR = tmpsmcr;
;;;5337         break;
;;;5338       }
;;;5339   
;;;5340       case TIM_CLOCKSOURCE_ETRMODE2:
;;;5341       {
;;;5342         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;5343         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;5344   
;;;5345         /* Check ETR input conditioning related parameters */
;;;5346         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;5347         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;5348         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;5349   
;;;5350         /* Configure the ETR Clock source */
;;;5351         TIM_ETR_SetConfig(htim->Instance,
;;;5352                           sClockSourceConfig->ClockPrescaler,
;;;5353                           sClockSourceConfig->ClockPolarity,
;;;5354                           sClockSourceConfig->ClockFilter);
;;;5355         /* Enable the External clock mode2 */
;;;5356         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;5357         break;
;;;5358       }
;;;5359   
;;;5360       case TIM_CLOCKSOURCE_TI1:
;;;5361       {
;;;5362         /* Check whether or not the timer instance supports external clock mode 1 */
;;;5363         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;5364   
;;;5365         /* Check TI1 input conditioning related parameters */
;;;5366         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;5367         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;5368   
;;;5369         TIM_TI1_ConfigInputStage(htim->Instance,
;;;5370                                  sClockSourceConfig->ClockPolarity,
;;;5371                                  sClockSourceConfig->ClockFilter);
;;;5372         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;5373         break;
;;;5374       }
;;;5375   
;;;5376       case TIM_CLOCKSOURCE_TI2:
;;;5377       {
;;;5378         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;5379         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;5380   
;;;5381         /* Check TI2 input conditioning related parameters */
;;;5382         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;5383         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;5384   
;;;5385         TIM_TI2_ConfigInputStage(htim->Instance,
;;;5386                                  sClockSourceConfig->ClockPolarity,
;;;5387                                  sClockSourceConfig->ClockFilter);
;;;5388         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;5389         break;
;;;5390       }
;;;5391   
;;;5392       case TIM_CLOCKSOURCE_TI1ED:
;;;5393       {
;;;5394         /* Check whether or not the timer instance supports external clock mode 1 */
;;;5395         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;5396   
;;;5397         /* Check TI1 input conditioning related parameters */
;;;5398         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;5399         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;5400   
;;;5401         TIM_TI1_ConfigInputStage(htim->Instance,
;;;5402                                  sClockSourceConfig->ClockPolarity,
;;;5403                                  sClockSourceConfig->ClockFilter);
;;;5404         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;5405         break;
;;;5406       }
;;;5407   
;;;5408       case TIM_CLOCKSOURCE_ITR0:
;;;5409       case TIM_CLOCKSOURCE_ITR1:
;;;5410       case TIM_CLOCKSOURCE_ITR2:
;;;5411       case TIM_CLOCKSOURCE_ITR3:
;;;5412         {
;;;5413           /* Check whether or not the timer instance supports internal trigger input */
;;;5414           assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;5415   
;;;5416           TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
;;;5417           break;
;;;5418         }
;;;5419   
;;;5420       default:
;;;5421         break;
;;;5422     }
;;;5423     htim->State = HAL_TIM_STATE_READY;
;;;5424   
;;;5425     __HAL_UNLOCK(htim);
;;;5426   
;;;5427     return HAL_OK;
;;;5428   }
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2830              CMP      r0,#0x30              ;5308
000042  d044              BEQ      |L12.206|
000044  2840              CMP      r0,#0x40              ;5308
000046  d147              BNE      |L12.216|
000048  e037              B        |L12.186|
                  |L12.74|
00004a  2860              CMP      r0,#0x60              ;5308
00004c  d02b              BEQ      |L12.166|
00004e  2870              CMP      r0,#0x70              ;5308
000050  d006              BEQ      |L12.96|
000052  f5b05f80          CMP      r0,#0x1000            ;5308
000056  d03f              BEQ      |L12.216|
000058  f5b05f00          CMP      r0,#0x2000            ;5308
00005c  d13c              BNE      |L12.216|
00005e  e00b              B        |L12.120|
                  |L12.96|
000060  68cb              LDR      r3,[r1,#0xc]          ;5327
000062  e9d12101          LDRD     r2,r1,[r1,#4]         ;5327
000066  6820              LDR      r0,[r4,#0]            ;5327
000068  f7fffffe          BL       TIM_ETR_SetConfig
00006c  6820              LDR      r0,[r4,#0]            ;5333
00006e  6881              LDR      r1,[r0,#8]            ;5333
000070  f0410177          ORR      r1,r1,#0x77           ;5334
000074  6081              STR      r1,[r0,#8]            ;5336
000076  e02f              B        |L12.216|
                  |L12.120|
000078  68cb              LDR      r3,[r1,#0xc]          ;5351
00007a  e9d12101          LDRD     r2,r1,[r1,#4]         ;5351
00007e  6820              LDR      r0,[r4,#0]            ;5351
000080  f7fffffe          BL       TIM_ETR_SetConfig
000084  6820              LDR      r0,[r4,#0]            ;5356
000086  6881              LDR      r1,[r0,#8]            ;5356
000088  f4414180          ORR      r1,r1,#0x4000         ;5356
00008c  6081              STR      r1,[r0,#8]            ;5356
00008e  e023              B        |L12.216|
                  |L12.144|
000090  68ca              LDR      r2,[r1,#0xc]          ;5369
000092  6849              LDR      r1,[r1,#4]            ;5369
000094  6820              LDR      r0,[r4,#0]            ;5369
000096  f7fffffe          BL       TIM_TI1_ConfigInputStage
00009a  2150              MOVS     r1,#0x50              ;5372
00009c  6820              LDR      r0,[r4,#0]            ;5372
00009e  f7fffffe          BL       TIM_ITRx_SetConfig
0000a2  e019              B        |L12.216|
                  |L12.164|
0000a4  e013              B        |L12.206|
                  |L12.166|
0000a6  68ca              LDR      r2,[r1,#0xc]          ;5385
0000a8  6849              LDR      r1,[r1,#4]            ;5385
0000aa  6820              LDR      r0,[r4,#0]            ;5385
0000ac  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000b0  2160              MOVS     r1,#0x60              ;5388
0000b2  6820              LDR      r0,[r4,#0]            ;5388
0000b4  f7fffffe          BL       TIM_ITRx_SetConfig
0000b8  e00e              B        |L12.216|
                  |L12.186|
0000ba  68ca              LDR      r2,[r1,#0xc]          ;5401
0000bc  6849              LDR      r1,[r1,#4]            ;5401
0000be  6820              LDR      r0,[r4,#0]            ;5401
0000c0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000c4  2140              MOVS     r1,#0x40              ;5404
0000c6  6820              LDR      r0,[r4,#0]            ;5404
0000c8  f7fffffe          BL       TIM_ITRx_SetConfig
0000cc  e004              B        |L12.216|
                  |L12.206|
0000ce  6822              LDR      r2,[r4,#0]            ;5416
0000d0  4601              MOV      r1,r0                 ;5416
0000d2  4610              MOV      r0,r2                 ;5416
0000d4  f7fffffe          BL       TIM_ITRx_SetConfig
                  |L12.216|
0000d8  343c              ADDS     r4,r4,#0x3c           ;5423
0000da  7065              STRB     r5,[r4,#1]            ;5423
0000dc  2000              MOVS     r0,#0                 ;5425
0000de  7020              STRB     r0,[r4,#0]            ;5425
0000e0  bd70              POP      {r4-r6,pc}
;;;5429   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L12.228|
                          DCD      0xfffeff88

                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;5128     */
;;;5129   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5130                                              TIM_ClearInputConfigTypeDef *sClearInputConfig,
;;;5131                                              uint32_t Channel)
;;;5132   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;5133     /* Check the parameters */
;;;5134     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;5135     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;5136   
;;;5137     /* Process Locked */
;;;5138     __HAL_LOCK(htim);
00000a  f894003c          LDRB     r0,[r4,#0x3c]
00000e  2801              CMP      r0,#1
000010  d00e              BEQ      |L13.48|
000012  2701              MOVS     r7,#1
000014  f884703c          STRB     r7,[r4,#0x3c]
;;;5139   
;;;5140     htim->State = HAL_TIM_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f884003d          STRB     r0,[r4,#0x3d]
00001e  6868              LDR      r0,[r5,#4]            ;5138
;;;5141   
;;;5142     switch (sClearInputConfig->ClearInputSource)
000020  f04f0800          MOV      r8,#0
000024  b138              CBZ      r0,|L13.54|
000026  2801              CMP      r0,#1
000028  d012              BEQ      |L13.80|
00002a  2802              CMP      r0,#2
00002c  d122              BNE      |L13.116|
00002e  e009              B        |L13.68|
                  |L13.48|
000030  2002              MOVS     r0,#2                 ;5138
                  |L13.50|
;;;5143     {
;;;5144       case TIM_CLEARINPUTSOURCE_NONE:
;;;5145       {
;;;5146         /* Clear the OCREF clear selection bit and the the ETR Bits */
;;;5147         CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_OCCS | TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
;;;5148         break;
;;;5149       }
;;;5150       case TIM_CLEARINPUTSOURCE_OCREFCLR:
;;;5151       {
;;;5152         /* Clear the OCREF clear selection bit */
;;;5153         CLEAR_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
;;;5154       }
;;;5155       break;
;;;5156   
;;;5157       case TIM_CLEARINPUTSOURCE_ETR:
;;;5158       {
;;;5159         /* Check the parameters */
;;;5160         assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;5161         assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;5162         assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;5163   
;;;5164         /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
;;;5165         if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
;;;5166         {
;;;5167           htim->State = HAL_TIM_STATE_READY;
;;;5168           __HAL_UNLOCK(htim);
;;;5169           return HAL_ERROR;
;;;5170         }
;;;5171   
;;;5172         TIM_ETR_SetConfig(htim->Instance,
;;;5173                           sClearInputConfig->ClearInputPrescaler,
;;;5174                           sClearInputConfig->ClearInputPolarity,
;;;5175                           sClearInputConfig->ClearInputFilter);
;;;5176   
;;;5177         /* Set the OCREF clear selection bit */
;;;5178         SET_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
;;;5179         break;
;;;5180       }
;;;5181   
;;;5182       default:
;;;5183         break;
;;;5184     }
;;;5185   
;;;5186     switch (Channel)
;;;5187     {
;;;5188       case TIM_CHANNEL_1:
;;;5189       {
;;;5190         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;5191         {
;;;5192           /* Enable the OCREF clear feature for Channel 1 */
;;;5193           SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
;;;5194         }
;;;5195         else
;;;5196         {
;;;5197           /* Disable the OCREF clear feature for Channel 1 */
;;;5198           CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
;;;5199         }
;;;5200         break;
;;;5201       }
;;;5202       case TIM_CHANNEL_2:
;;;5203       {
;;;5204         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;5205         {
;;;5206           /* Enable the OCREF clear feature for Channel 2 */
;;;5207           SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
;;;5208         }
;;;5209         else
;;;5210         {
;;;5211           /* Disable the OCREF clear feature for Channel 2 */
;;;5212           CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
;;;5213         }
;;;5214         break;
;;;5215       }
;;;5216       case TIM_CHANNEL_3:
;;;5217       {
;;;5218         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;5219         {
;;;5220           /* Enable the OCREF clear feature for Channel 3 */
;;;5221           SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
;;;5222         }
;;;5223         else
;;;5224         {
;;;5225           /* Disable the OCREF clear feature for Channel 3 */
;;;5226           CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
;;;5227         }
;;;5228         break;
;;;5229       }
;;;5230       case TIM_CHANNEL_4:
;;;5231       {
;;;5232         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;5233         {
;;;5234           /* Enable the OCREF clear feature for Channel 4 */
;;;5235           SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
;;;5236         }
;;;5237         else
;;;5238         {
;;;5239           /* Disable the OCREF clear feature for Channel 4 */
;;;5240           CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
;;;5241         }
;;;5242         break;
;;;5243       }
;;;5244       case TIM_CHANNEL_5:
;;;5245       {
;;;5246         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;5247         {
;;;5248           /* Enable the OCREF clear feature for Channel 5 */
;;;5249           SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
;;;5250         }
;;;5251         else
;;;5252         {
;;;5253           /* Disable the OCREF clear feature for Channel 5 */
;;;5254           CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
;;;5255         }
;;;5256         break;
;;;5257       }
;;;5258       case TIM_CHANNEL_6:
;;;5259       {
;;;5260         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;5261         {
;;;5262           /* Enable the OCREF clear feature for Channel 6 */
;;;5263           SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
;;;5264         }
;;;5265         else
;;;5266         {
;;;5267           /* Disable the OCREF clear feature for Channel 6 */
;;;5268           CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
;;;5269         }
;;;5270         break;
;;;5271       }
;;;5272       default:
;;;5273         break;
;;;5274     }
;;;5275   
;;;5276     htim->State = HAL_TIM_STATE_READY;
;;;5277   
;;;5278     __HAL_UNLOCK(htim);
;;;5279   
;;;5280     return HAL_OK;
;;;5281   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L13.54|
000036  6820              LDR      r0,[r4,#0]            ;5147
000038  6881              LDR      r1,[r0,#8]            ;5147
00003a  f64f7208          MOV      r2,#0xff08            ;5147
00003e  4391              BICS     r1,r1,r2              ;5147
000040  6081              STR      r1,[r0,#8]            ;5147
000042  e017              B        |L13.116|
                  |L13.68|
000044  6820              LDR      r0,[r4,#0]            ;5153
000046  6881              LDR      r1,[r0,#8]            ;5153
000048  f0210108          BIC      r1,r1,#8              ;5153
00004c  6081              STR      r1,[r0,#8]            ;5153
00004e  e011              B        |L13.116|
                  |L13.80|
000050  68e9              LDR      r1,[r5,#0xc]          ;5165
000052  b129              CBZ      r1,|L13.96|
000054  f884703d          STRB     r7,[r4,#0x3d]         ;5167
000058  f884803c          STRB     r8,[r4,#0x3c]         ;5168
00005c  2001              MOVS     r0,#1                 ;5169
00005e  e7e8              B        |L13.50|
                  |L13.96|
000060  692b              LDR      r3,[r5,#0x10]         ;5172
000062  68aa              LDR      r2,[r5,#8]            ;5172
000064  6820              LDR      r0,[r4,#0]            ;5172
000066  f7fffffe          BL       TIM_ETR_SetConfig
00006a  6820              LDR      r0,[r4,#0]            ;5178
00006c  6881              LDR      r1,[r0,#8]            ;5178
00006e  f0410108          ORR      r1,r1,#8              ;5178
000072  6081              STR      r1,[r0,#8]            ;5178
                  |L13.116|
000074  2e0c              CMP      r6,#0xc               ;5186
000076  d035              BEQ      |L13.228|
000078  dc05              BGT      |L13.134|
00007a  b14e              CBZ      r6,|L13.144|
00007c  2e04              CMP      r6,#4                 ;5186
00007e  d015              BEQ      |L13.172|
000080  2e08              CMP      r6,#8                 ;5186
000082  d158              BNE      |L13.310|
000084  e020              B        |L13.200|
                  |L13.134|
000086  2e10              CMP      r6,#0x10              ;5186
000088  d03a              BEQ      |L13.256|
00008a  2e14              CMP      r6,#0x14              ;5186
00008c  d153              BNE      |L13.310|
00008e  e045              B        |L13.284|
                  |L13.144|
000090  6828              LDR      r0,[r5,#0]            ;5190
000092  b128              CBZ      r0,|L13.160|
000094  6820              LDR      r0,[r4,#0]            ;5193
000096  6981              LDR      r1,[r0,#0x18]         ;5193
000098  f0410180          ORR      r1,r1,#0x80           ;5193
00009c  6181              STR      r1,[r0,#0x18]         ;5193
00009e  e04a              B        |L13.310|
                  |L13.160|
0000a0  6820              LDR      r0,[r4,#0]            ;5198
0000a2  6981              LDR      r1,[r0,#0x18]         ;5198
0000a4  f0210180          BIC      r1,r1,#0x80           ;5198
0000a8  6181              STR      r1,[r0,#0x18]         ;5198
0000aa  e044              B        |L13.310|
                  |L13.172|
0000ac  6828              LDR      r0,[r5,#0]            ;5204
0000ae  b128              CBZ      r0,|L13.188|
0000b0  6820              LDR      r0,[r4,#0]            ;5207
0000b2  6981              LDR      r1,[r0,#0x18]         ;5207
0000b4  f4414100          ORR      r1,r1,#0x8000         ;5207
0000b8  6181              STR      r1,[r0,#0x18]         ;5207
0000ba  e03c              B        |L13.310|
                  |L13.188|
0000bc  6820              LDR      r0,[r4,#0]            ;5212
0000be  6981              LDR      r1,[r0,#0x18]         ;5212
0000c0  f4214100          BIC      r1,r1,#0x8000         ;5212
0000c4  6181              STR      r1,[r0,#0x18]         ;5212
0000c6  e036              B        |L13.310|
                  |L13.200|
0000c8  6828              LDR      r0,[r5,#0]            ;5218
0000ca  b128              CBZ      r0,|L13.216|
0000cc  6820              LDR      r0,[r4,#0]            ;5221
0000ce  69c1              LDR      r1,[r0,#0x1c]         ;5221
0000d0  f0410180          ORR      r1,r1,#0x80           ;5221
0000d4  61c1              STR      r1,[r0,#0x1c]         ;5221
0000d6  e02e              B        |L13.310|
                  |L13.216|
0000d8  6820              LDR      r0,[r4,#0]            ;5226
0000da  69c1              LDR      r1,[r0,#0x1c]         ;5226
0000dc  f0210180          BIC      r1,r1,#0x80           ;5226
0000e0  61c1              STR      r1,[r0,#0x1c]         ;5226
0000e2  e028              B        |L13.310|
                  |L13.228|
0000e4  6828              LDR      r0,[r5,#0]            ;5232
0000e6  b128              CBZ      r0,|L13.244|
0000e8  6820              LDR      r0,[r4,#0]            ;5235
0000ea  69c1              LDR      r1,[r0,#0x1c]         ;5235
0000ec  f4414100          ORR      r1,r1,#0x8000         ;5235
0000f0  61c1              STR      r1,[r0,#0x1c]         ;5235
0000f2  e020              B        |L13.310|
                  |L13.244|
0000f4  6820              LDR      r0,[r4,#0]            ;5240
0000f6  69c1              LDR      r1,[r0,#0x1c]         ;5240
0000f8  f4214100          BIC      r1,r1,#0x8000         ;5240
0000fc  61c1              STR      r1,[r0,#0x1c]         ;5240
0000fe  e01a              B        |L13.310|
                  |L13.256|
000100  6828              LDR      r0,[r5,#0]            ;5246
000102  b128              CBZ      r0,|L13.272|
000104  6820              LDR      r0,[r4,#0]            ;5249
000106  6d41              LDR      r1,[r0,#0x54]         ;5249
000108  f0410180          ORR      r1,r1,#0x80           ;5249
00010c  6541              STR      r1,[r0,#0x54]         ;5249
00010e  e012              B        |L13.310|
                  |L13.272|
000110  6820              LDR      r0,[r4,#0]            ;5254
000112  6d41              LDR      r1,[r0,#0x54]         ;5254
000114  f0210180          BIC      r1,r1,#0x80           ;5254
000118  6541              STR      r1,[r0,#0x54]         ;5254
00011a  e00c              B        |L13.310|
                  |L13.284|
00011c  6828              LDR      r0,[r5,#0]            ;5260
00011e  b128              CBZ      r0,|L13.300|
000120  6820              LDR      r0,[r4,#0]            ;5263
000122  6d41              LDR      r1,[r0,#0x54]         ;5263
000124  f4414100          ORR      r1,r1,#0x8000         ;5263
000128  6541              STR      r1,[r0,#0x54]         ;5263
00012a  e004              B        |L13.310|
                  |L13.300|
00012c  6820              LDR      r0,[r4,#0]            ;5268
00012e  6d41              LDR      r1,[r0,#0x54]         ;5268
000130  f4214100          BIC      r1,r1,#0x8000         ;5268
000134  6541              STR      r1,[r0,#0x54]         ;5268
                  |L13.310|
000136  f884703d          STRB     r7,[r4,#0x3d]         ;5276
00013a  f884803c          STRB     r8,[r4,#0x3c]         ;5278
00013e  2000              MOVS     r0,#0                 ;5280
000140  e777              B        |L13.50|
;;;5282   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;5441     */
;;;5442   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6800              LDR      r0,[r0,#0]
;;;5443   {
;;;5444     uint32_t tmpcr2;
;;;5445   
;;;5446     /* Check the parameters */
;;;5447     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;5448     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;5449   
;;;5450     /* Get the TIMx CR2 register value */
;;;5451     tmpcr2 = htim->Instance->CR2;
000002  6842              LDR      r2,[r0,#4]
;;;5452   
;;;5453     /* Reset the TI1 selection */
;;;5454     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0220280          BIC      r2,r2,#0x80
;;;5455   
;;;5456     /* Set the TI1 selection */
;;;5457     tmpcr2 |= TI1_Selection;
000008  430a              ORRS     r2,r2,r1
;;;5458   
;;;5459     /* Write to TIMxCR2 */
;;;5460     htim->Instance->CR2 = tmpcr2;
00000a  6042              STR      r2,[r0,#4]
;;;5461   
;;;5462     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;5463   }
00000e  4770              BX       lr
;;;5464   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurstState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurstState PROC
;;;6397     */
;;;6398   HAL_TIM_DMABurstStateTypeDef HAL_TIM_DMABurstState(TIM_HandleTypeDef *htim)
000000  f8900048          LDRB     r0,[r0,#0x48]
;;;6399   {
;;;6400     /* Check the parameters */
;;;6401     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;6402   
;;;6403     return htim->DMABurstState;
;;;6404   }
000004  4770              BX       lr
;;;6405   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_MultiReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_MultiReadStart PROC
;;;4833     */
;;;4834   HAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4835                                                     uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,
;;;4836                                                     uint32_t  BurstLength, uint32_t  DataLength)
;;;4837   {
000004  4615              MOV      r5,r2
000006  461a              MOV      r2,r3
000008  e9dd6306          LDRD     r6,r3,[sp,#0x18]
00000c  4604              MOV      r4,r0
00000e  460f              MOV      r7,r1
;;;4838     /* Check the parameters */
;;;4839     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;4840     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;4841     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4842     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;4843     assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
;;;4844   
;;;4845     if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
000010  f8940048          LDRB     r0,[r4,#0x48]
000014  2802              CMP      r0,#2
000016  d004              BEQ      |L16.34|
;;;4846     {
;;;4847       return HAL_BUSY;
;;;4848     }
;;;4849     else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
000018  f8940048          LDRB     r0,[r4,#0x48]
00001c  2801              CMP      r0,#1
00001e  d003              BEQ      |L16.40|
000020  e009              B        |L16.54|
                  |L16.34|
000022  2002              MOVS     r0,#2                 ;4847
                  |L16.36|
;;;4850     {
;;;4851       if ((BurstBuffer == NULL) && (BurstLength > 0U))
;;;4852       {
;;;4853         return HAL_ERROR;
;;;4854       }
;;;4855       else
;;;4856       {
;;;4857         htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
;;;4858       }
;;;4859     }
;;;4860     else
;;;4861     {
;;;4862       /* nothing to do */
;;;4863     }
;;;4864     switch (BurstRequestSrc)
;;;4865     {
;;;4866       case TIM_DMA_UPDATE:
;;;4867       {
;;;4868         /* Set the DMA Period elapsed callbacks */
;;;4869         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;4870         htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
;;;4871   
;;;4872         /* Set the DMA error callback */
;;;4873         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;4874   
;;;4875         /* Enable the DMA channel */
;;;4876         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
;;;4877                            DataLength) != HAL_OK)
;;;4878         {
;;;4879           /* Return error status */
;;;4880           return HAL_ERROR;
;;;4881         }
;;;4882         break;
;;;4883       }
;;;4884       case TIM_DMA_CC1:
;;;4885       {
;;;4886         /* Set the DMA capture callbacks */
;;;4887         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4888         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4889   
;;;4890         /* Set the DMA error callback */
;;;4891         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;4892   
;;;4893         /* Enable the DMA channel */
;;;4894         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
;;;4895                            DataLength) != HAL_OK)
;;;4896         {
;;;4897           /* Return error status */
;;;4898           return HAL_ERROR;
;;;4899         }
;;;4900         break;
;;;4901       }
;;;4902       case TIM_DMA_CC2:
;;;4903       {
;;;4904         /* Set the DMA capture callbacks */
;;;4905         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4906         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4907   
;;;4908         /* Set the DMA error callback */
;;;4909         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;4910   
;;;4911         /* Enable the DMA channel */
;;;4912         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
;;;4913                            DataLength) != HAL_OK)
;;;4914         {
;;;4915           /* Return error status */
;;;4916           return HAL_ERROR;
;;;4917         }
;;;4918         break;
;;;4919       }
;;;4920       case TIM_DMA_CC3:
;;;4921       {
;;;4922         /* Set the DMA capture callbacks */
;;;4923         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4924         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4925   
;;;4926         /* Set the DMA error callback */
;;;4927         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;4928   
;;;4929         /* Enable the DMA channel */
;;;4930         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
;;;4931                            DataLength) != HAL_OK)
;;;4932         {
;;;4933           /* Return error status */
;;;4934           return HAL_ERROR;
;;;4935         }
;;;4936         break;
;;;4937       }
;;;4938       case TIM_DMA_CC4:
;;;4939       {
;;;4940         /* Set the DMA capture callbacks */
;;;4941         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4942         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4943   
;;;4944         /* Set the DMA error callback */
;;;4945         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;4946   
;;;4947         /* Enable the DMA channel */
;;;4948         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
;;;4949                            DataLength) != HAL_OK)
;;;4950         {
;;;4951           /* Return error status */
;;;4952           return HAL_ERROR;
;;;4953         }
;;;4954         break;
;;;4955       }
;;;4956       case TIM_DMA_COM:
;;;4957       {
;;;4958         /* Set the DMA commutation callbacks */
;;;4959         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;4960         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
;;;4961   
;;;4962         /* Set the DMA error callback */
;;;4963         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;4964   
;;;4965         /* Enable the DMA channel */
;;;4966         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
;;;4967                            DataLength) != HAL_OK)
;;;4968         {
;;;4969           /* Return error status */
;;;4970           return HAL_ERROR;
;;;4971         }
;;;4972         break;
;;;4973       }
;;;4974       case TIM_DMA_TRIGGER:
;;;4975       {
;;;4976         /* Set the DMA trigger callbacks */
;;;4977         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;4978         htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
;;;4979   
;;;4980         /* Set the DMA error callback */
;;;4981         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;4982   
;;;4983         /* Enable the DMA channel */
;;;4984         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
;;;4985                            DataLength) != HAL_OK)
;;;4986         {
;;;4987           /* Return error status */
;;;4988           return HAL_ERROR;
;;;4989         }
;;;4990         break;
;;;4991       }
;;;4992       default:
;;;4993         break;
;;;4994     }
;;;4995   
;;;4996     /* Configure the DMA Burst Mode */
;;;4997     htim->Instance->DCR = (BurstBaseAddress | BurstLength);
;;;4998   
;;;4999     /* Enable the TIM DMA Request */
;;;5000     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;5001   
;;;5002     /* Return function status */
;;;5003     return HAL_OK;
;;;5004   }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L16.40|
000028  b912              CBNZ     r2,|L16.48|
00002a  b10e              CBZ      r6,|L16.48|
00002c  2001              MOVS     r0,#1                 ;4853
00002e  e7f9              B        |L16.36|
                  |L16.48|
000030  2002              MOVS     r0,#2                 ;4857
000032  f8840048          STRB     r0,[r4,#0x48]         ;4857
                  |L16.54|
000036  4853              LDR      r0,|L16.388|
000038  4953              LDR      r1,|L16.392|
00003a  f8dfc150          LDR      r12,|L16.396|
00003e  f5b56f00          CMP      r5,#0x800             ;4864
000042  d04b              BEQ      |L16.220|
000044  dc09              BGT      |L16.90|
000046  f5b57f80          CMP      r5,#0x100             ;4864
00004a  d010              BEQ      |L16.110|
00004c  f5b57f00          CMP      r5,#0x200             ;4864
000050  d022              BEQ      |L16.152|
000052  f5b56f80          CMP      r5,#0x400             ;4864
000056  d163              BNE      |L16.288|
000058  e02f              B        |L16.186|
                  |L16.90|
00005a  f5b55f80          CMP      r5,#0x1000            ;4864
00005e  d04e              BEQ      |L16.254|
000060  f5b55f00          CMP      r5,#0x2000            ;4864
000064  d05d              BEQ      |L16.290|
000066  f5b54f80          CMP      r5,#0x4000            ;4864
00006a  d159              BNE      |L16.288|
00006c  e06d              B        |L16.330|
                  |L16.110|
00006e  f8d4c020          LDR      r12,[r4,#0x20]        ;4869
000072  4947              LDR      r1,|L16.400|
000074  f8cc102c          STR      r1,[r12,#0x2c]        ;4869
000078  f8d4c020          LDR      r12,[r4,#0x20]        ;4870
00007c  4945              LDR      r1,|L16.404|
00007e  f8cc1030          STR      r1,[r12,#0x30]        ;4870
000082  6a21              LDR      r1,[r4,#0x20]         ;4873
000084  6348              STR      r0,[r1,#0x34]         ;4873
000086  6821              LDR      r1,[r4,#0]            ;4876
000088  6a20              LDR      r0,[r4,#0x20]         ;4876
00008a  314c              ADDS     r1,r1,#0x4c           ;4876
00008c  f7fffffe          BL       HAL_DMA_Start_IT
000090  2800              CMP      r0,#0                 ;4876
000092  d06e              BEQ      |L16.370|
000094  2001              MOVS     r0,#1                 ;4880
000096  e7c5              B        |L16.36|
                  |L16.152|
000098  f8d48024          LDR      r8,[r4,#0x24]         ;4887
00009c  f8c8102c          STR      r1,[r8,#0x2c]         ;4887
0000a0  6a61              LDR      r1,[r4,#0x24]         ;4888
0000a2  f8c1c030          STR      r12,[r1,#0x30]        ;4888
0000a6  6a61              LDR      r1,[r4,#0x24]         ;4891
0000a8  6348              STR      r0,[r1,#0x34]         ;4891
0000aa  6821              LDR      r1,[r4,#0]            ;4894
0000ac  6a60              LDR      r0,[r4,#0x24]         ;4894
0000ae  314c              ADDS     r1,r1,#0x4c           ;4894
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  b3a0              CBZ      r0,|L16.288|
0000b6  2001              MOVS     r0,#1                 ;4898
0000b8  e7b4              B        |L16.36|
                  |L16.186|
0000ba  f8d48028          LDR      r8,[r4,#0x28]         ;4905
0000be  f8c8102c          STR      r1,[r8,#0x2c]         ;4905
0000c2  6aa1              LDR      r1,[r4,#0x28]         ;4906
0000c4  f8c1c030          STR      r12,[r1,#0x30]        ;4906
0000c8  6aa1              LDR      r1,[r4,#0x28]         ;4909
0000ca  6348              STR      r0,[r1,#0x34]         ;4909
0000cc  6821              LDR      r1,[r4,#0]            ;4912
0000ce  6aa0              LDR      r0,[r4,#0x28]         ;4912
0000d0  314c              ADDS     r1,r1,#0x4c           ;4912
0000d2  f7fffffe          BL       HAL_DMA_Start_IT
0000d6  b318              CBZ      r0,|L16.288|
0000d8  2001              MOVS     r0,#1                 ;4916
0000da  e7a3              B        |L16.36|
                  |L16.220|
0000dc  f8d4802c          LDR      r8,[r4,#0x2c]         ;4923
0000e0  f8c8102c          STR      r1,[r8,#0x2c]         ;4923
0000e4  6ae1              LDR      r1,[r4,#0x2c]         ;4924
0000e6  f8c1c030          STR      r12,[r1,#0x30]        ;4924
0000ea  6ae1              LDR      r1,[r4,#0x2c]         ;4927
0000ec  6348              STR      r0,[r1,#0x34]         ;4927
0000ee  6821              LDR      r1,[r4,#0]            ;4930
0000f0  6ae0              LDR      r0,[r4,#0x2c]         ;4930
0000f2  314c              ADDS     r1,r1,#0x4c           ;4930
0000f4  f7fffffe          BL       HAL_DMA_Start_IT
0000f8  b190              CBZ      r0,|L16.288|
0000fa  2001              MOVS     r0,#1                 ;4934
0000fc  e792              B        |L16.36|
                  |L16.254|
0000fe  f8d48030          LDR      r8,[r4,#0x30]         ;4941
000102  f8c8102c          STR      r1,[r8,#0x2c]         ;4941
000106  6b21              LDR      r1,[r4,#0x30]         ;4942
000108  f8c1c030          STR      r12,[r1,#0x30]        ;4942
00010c  6b21              LDR      r1,[r4,#0x30]         ;4945
00010e  6348              STR      r0,[r1,#0x34]         ;4945
000110  6821              LDR      r1,[r4,#0]            ;4948
000112  6b20              LDR      r0,[r4,#0x30]         ;4948
000114  314c              ADDS     r1,r1,#0x4c           ;4948
000116  f7fffffe          BL       HAL_DMA_Start_IT
00011a  b108              CBZ      r0,|L16.288|
00011c  2001              MOVS     r0,#1                 ;4952
00011e  e781              B        |L16.36|
                  |L16.288|
000120  e027              B        |L16.370|
                  |L16.290|
000122  f8d4c034          LDR      r12,[r4,#0x34]        ;4959
000126  491c              LDR      r1,|L16.408|
000128  f8cc102c          STR      r1,[r12,#0x2c]        ;4959
00012c  f8d4c034          LDR      r12,[r4,#0x34]        ;4960
000130  491a              LDR      r1,|L16.412|
000132  f8cc1030          STR      r1,[r12,#0x30]        ;4960
000136  6b61              LDR      r1,[r4,#0x34]         ;4963
000138  6348              STR      r0,[r1,#0x34]         ;4963
00013a  6821              LDR      r1,[r4,#0]            ;4966
00013c  6b60              LDR      r0,[r4,#0x34]         ;4966
00013e  314c              ADDS     r1,r1,#0x4c           ;4966
000140  f7fffffe          BL       HAL_DMA_Start_IT
000144  b1a8              CBZ      r0,|L16.370|
000146  2001              MOVS     r0,#1                 ;4970
000148  e76c              B        |L16.36|
                  |L16.330|
00014a  f8d4c038          LDR      r12,[r4,#0x38]        ;4977
00014e  4914              LDR      r1,|L16.416|
000150  f8cc102c          STR      r1,[r12,#0x2c]        ;4977
000154  f8d4c038          LDR      r12,[r4,#0x38]        ;4978
000158  4912              LDR      r1,|L16.420|
00015a  f8cc1030          STR      r1,[r12,#0x30]        ;4978
00015e  6ba1              LDR      r1,[r4,#0x38]         ;4981
000160  6348              STR      r0,[r1,#0x34]         ;4981
000162  6821              LDR      r1,[r4,#0]            ;4984
000164  6ba0              LDR      r0,[r4,#0x38]         ;4984
000166  314c              ADDS     r1,r1,#0x4c           ;4984
000168  f7fffffe          BL       HAL_DMA_Start_IT
00016c  b108              CBZ      r0,|L16.370|
00016e  2001              MOVS     r0,#1                 ;4988
000170  e758              B        |L16.36|
                  |L16.370|
000172  6820              LDR      r0,[r4,#0]            ;4997
000174  4337              ORRS     r7,r7,r6              ;4997
000176  6487              STR      r7,[r0,#0x48]         ;4997
000178  6820              LDR      r0,[r4,#0]            ;5000
00017a  68c1              LDR      r1,[r0,#0xc]          ;5000
00017c  4329              ORRS     r1,r1,r5              ;5000
00017e  60c1              STR      r1,[r0,#0xc]          ;5000
000180  2000              MOVS     r0,#0                 ;5003
000182  e74f              B        |L16.36|
;;;5005   
                          ENDP

                  |L16.388|
                          DCD      TIM_DMAError
                  |L16.392|
                          DCD      TIM_DMACaptureCplt
                  |L16.396|
                          DCD      TIM_DMACaptureHalfCplt
                  |L16.400|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L16.404|
                          DCD      TIM_DMAPeriodElapsedHalfCplt
                  |L16.408|
                          DCD      TIMEx_DMACommutationCplt
                  |L16.412|
                          DCD      TIMEx_DMACommutationHalfCplt
                  |L16.416|
                          DCD      TIM_DMATriggerCplt
                  |L16.420|
                          DCD      TIM_DMATriggerHalfCplt

                          AREA ||i.HAL_TIM_DMABurst_MultiWriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_MultiWriteStart PROC
;;;4503     */
;;;4504   HAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4505                                                      uint32_t BurstRequestSrc, uint32_t *BurstBuffer,
;;;4506                                                      uint32_t  BurstLength,  uint32_t  DataLength)
;;;4507   {
000004  460f              MOV      r7,r1
000006  4619              MOV      r1,r3
000008  e9dd6306          LDRD     r6,r3,[sp,#0x18]
00000c  4604              MOV      r4,r0
00000e  4615              MOV      r5,r2
;;;4508     /* Check the parameters */
;;;4509     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;4510     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;4511     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4512     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;4513     assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
;;;4514   
;;;4515     if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
000010  f8940048          LDRB     r0,[r4,#0x48]
000014  2802              CMP      r0,#2
000016  d004              BEQ      |L17.34|
;;;4516     {
;;;4517       return HAL_BUSY;
;;;4518     }
;;;4519     else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
000018  f8940048          LDRB     r0,[r4,#0x48]
00001c  2801              CMP      r0,#1
00001e  d003              BEQ      |L17.40|
000020  e009              B        |L17.54|
                  |L17.34|
000022  2002              MOVS     r0,#2                 ;4517
                  |L17.36|
;;;4520     {
;;;4521       if ((BurstBuffer == NULL) && (BurstLength > 0U))
;;;4522       {
;;;4523         return HAL_ERROR;
;;;4524       }
;;;4525       else
;;;4526       {
;;;4527         htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
;;;4528       }
;;;4529     }
;;;4530     else
;;;4531     {
;;;4532       /* nothing to do */
;;;4533     }
;;;4534     switch (BurstRequestSrc)
;;;4535     {
;;;4536       case TIM_DMA_UPDATE:
;;;4537       {
;;;4538         /* Set the DMA Period elapsed callbacks */
;;;4539         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;4540         htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
;;;4541   
;;;4542         /* Set the DMA error callback */
;;;4543         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;4544   
;;;4545         /* Enable the DMA channel */
;;;4546         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,
;;;4547                            (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
;;;4548         {
;;;4549           /* Return error status */
;;;4550           return HAL_ERROR;
;;;4551         }
;;;4552         break;
;;;4553       }
;;;4554       case TIM_DMA_CC1:
;;;4555       {
;;;4556         /* Set the DMA compare callbacks */
;;;4557         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;4558         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;4559   
;;;4560         /* Set the DMA error callback */
;;;4561         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;4562   
;;;4563         /* Enable the DMA channel */
;;;4564         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
;;;4565                            (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
;;;4566         {
;;;4567           /* Return error status */
;;;4568           return HAL_ERROR;
;;;4569         }
;;;4570         break;
;;;4571       }
;;;4572       case TIM_DMA_CC2:
;;;4573       {
;;;4574         /* Set the DMA compare callbacks */
;;;4575         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;4576         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;4577   
;;;4578         /* Set the DMA error callback */
;;;4579         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;4580   
;;;4581         /* Enable the DMA channel */
;;;4582         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
;;;4583                            (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
;;;4584         {
;;;4585           /* Return error status */
;;;4586           return HAL_ERROR;
;;;4587         }
;;;4588         break;
;;;4589       }
;;;4590       case TIM_DMA_CC3:
;;;4591       {
;;;4592         /* Set the DMA compare callbacks */
;;;4593         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;4594         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;4595   
;;;4596         /* Set the DMA error callback */
;;;4597         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;4598   
;;;4599         /* Enable the DMA channel */
;;;4600         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
;;;4601                            (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
;;;4602         {
;;;4603           /* Return error status */
;;;4604           return HAL_ERROR;
;;;4605         }
;;;4606         break;
;;;4607       }
;;;4608       case TIM_DMA_CC4:
;;;4609       {
;;;4610         /* Set the DMA compare callbacks */
;;;4611         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;4612         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;4613   
;;;4614         /* Set the DMA error callback */
;;;4615         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;4616   
;;;4617         /* Enable the DMA channel */
;;;4618         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
;;;4619                            (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
;;;4620         {
;;;4621           /* Return error status */
;;;4622           return HAL_ERROR;
;;;4623         }
;;;4624         break;
;;;4625       }
;;;4626       case TIM_DMA_COM:
;;;4627       {
;;;4628         /* Set the DMA commutation callbacks */
;;;4629         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;4630         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
;;;4631   
;;;4632         /* Set the DMA error callback */
;;;4633         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;4634   
;;;4635         /* Enable the DMA channel */
;;;4636         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
;;;4637                            (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
;;;4638         {
;;;4639           /* Return error status */
;;;4640           return HAL_ERROR;
;;;4641         }
;;;4642         break;
;;;4643       }
;;;4644       case TIM_DMA_TRIGGER:
;;;4645       {
;;;4646         /* Set the DMA trigger callbacks */
;;;4647         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;4648         htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
;;;4649   
;;;4650         /* Set the DMA error callback */
;;;4651         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;4652   
;;;4653         /* Enable the DMA channel */
;;;4654         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
;;;4655                            (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
;;;4656         {
;;;4657           /* Return error status */
;;;4658           return HAL_ERROR;
;;;4659         }
;;;4660         break;
;;;4661       }
;;;4662       default:
;;;4663         break;
;;;4664     }
;;;4665   
;;;4666     /* Configure the DMA Burst Mode */
;;;4667     htim->Instance->DCR = (BurstBaseAddress | BurstLength);
;;;4668     /* Enable the TIM DMA Request */
;;;4669     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;4670   
;;;4671     /* Return function status */
;;;4672     return HAL_OK;
;;;4673   }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L17.40|
000028  b911              CBNZ     r1,|L17.48|
00002a  b10e              CBZ      r6,|L17.48|
00002c  2001              MOVS     r0,#1                 ;4523
00002e  e7f9              B        |L17.36|
                  |L17.48|
000030  2002              MOVS     r0,#2                 ;4527
000032  f8840048          STRB     r0,[r4,#0x48]         ;4527
                  |L17.54|
000036  4853              LDR      r0,|L17.388|
000038  4a53              LDR      r2,|L17.392|
00003a  f8dfc150          LDR      r12,|L17.396|
00003e  f5b56f00          CMP      r5,#0x800             ;4534
000042  d04b              BEQ      |L17.220|
000044  dc09              BGT      |L17.90|
000046  f5b57f80          CMP      r5,#0x100             ;4534
00004a  d010              BEQ      |L17.110|
00004c  f5b57f00          CMP      r5,#0x200             ;4534
000050  d022              BEQ      |L17.152|
000052  f5b56f80          CMP      r5,#0x400             ;4534
000056  d163              BNE      |L17.288|
000058  e02f              B        |L17.186|
                  |L17.90|
00005a  f5b55f80          CMP      r5,#0x1000            ;4534
00005e  d04e              BEQ      |L17.254|
000060  f5b55f00          CMP      r5,#0x2000            ;4534
000064  d05d              BEQ      |L17.290|
000066  f5b54f80          CMP      r5,#0x4000            ;4534
00006a  d159              BNE      |L17.288|
00006c  e06d              B        |L17.330|
                  |L17.110|
00006e  f8d4c020          LDR      r12,[r4,#0x20]        ;4539
000072  4a47              LDR      r2,|L17.400|
000074  f8cc202c          STR      r2,[r12,#0x2c]        ;4539
000078  f8d4c020          LDR      r12,[r4,#0x20]        ;4540
00007c  4a45              LDR      r2,|L17.404|
00007e  f8cc2030          STR      r2,[r12,#0x30]        ;4540
000082  6a22              LDR      r2,[r4,#0x20]         ;4543
000084  6350              STR      r0,[r2,#0x34]         ;4543
000086  6822              LDR      r2,[r4,#0]            ;4546
000088  6a20              LDR      r0,[r4,#0x20]         ;4546
00008a  324c              ADDS     r2,r2,#0x4c           ;4546
00008c  f7fffffe          BL       HAL_DMA_Start_IT
000090  2800              CMP      r0,#0                 ;4546
000092  d06e              BEQ      |L17.370|
000094  2001              MOVS     r0,#1                 ;4550
000096  e7c5              B        |L17.36|
                  |L17.152|
000098  f8d48024          LDR      r8,[r4,#0x24]         ;4557
00009c  f8c8202c          STR      r2,[r8,#0x2c]         ;4557
0000a0  6a62              LDR      r2,[r4,#0x24]         ;4558
0000a2  f8c2c030          STR      r12,[r2,#0x30]        ;4558
0000a6  6a62              LDR      r2,[r4,#0x24]         ;4561
0000a8  6350              STR      r0,[r2,#0x34]         ;4561
0000aa  6822              LDR      r2,[r4,#0]            ;4564
0000ac  6a60              LDR      r0,[r4,#0x24]         ;4564
0000ae  324c              ADDS     r2,r2,#0x4c           ;4564
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  b3a0              CBZ      r0,|L17.288|
0000b6  2001              MOVS     r0,#1                 ;4568
0000b8  e7b4              B        |L17.36|
                  |L17.186|
0000ba  f8d48028          LDR      r8,[r4,#0x28]         ;4575
0000be  f8c8202c          STR      r2,[r8,#0x2c]         ;4575
0000c2  6aa2              LDR      r2,[r4,#0x28]         ;4576
0000c4  f8c2c030          STR      r12,[r2,#0x30]        ;4576
0000c8  6aa2              LDR      r2,[r4,#0x28]         ;4579
0000ca  6350              STR      r0,[r2,#0x34]         ;4579
0000cc  6822              LDR      r2,[r4,#0]            ;4582
0000ce  6aa0              LDR      r0,[r4,#0x28]         ;4582
0000d0  324c              ADDS     r2,r2,#0x4c           ;4582
0000d2  f7fffffe          BL       HAL_DMA_Start_IT
0000d6  b318              CBZ      r0,|L17.288|
0000d8  2001              MOVS     r0,#1                 ;4586
0000da  e7a3              B        |L17.36|
                  |L17.220|
0000dc  f8d4802c          LDR      r8,[r4,#0x2c]         ;4593
0000e0  f8c8202c          STR      r2,[r8,#0x2c]         ;4593
0000e4  6ae2              LDR      r2,[r4,#0x2c]         ;4594
0000e6  f8c2c030          STR      r12,[r2,#0x30]        ;4594
0000ea  6ae2              LDR      r2,[r4,#0x2c]         ;4597
0000ec  6350              STR      r0,[r2,#0x34]         ;4597
0000ee  6822              LDR      r2,[r4,#0]            ;4600
0000f0  6ae0              LDR      r0,[r4,#0x2c]         ;4600
0000f2  324c              ADDS     r2,r2,#0x4c           ;4600
0000f4  f7fffffe          BL       HAL_DMA_Start_IT
0000f8  b190              CBZ      r0,|L17.288|
0000fa  2001              MOVS     r0,#1                 ;4604
0000fc  e792              B        |L17.36|
                  |L17.254|
0000fe  f8d48030          LDR      r8,[r4,#0x30]         ;4611
000102  f8c8202c          STR      r2,[r8,#0x2c]         ;4611
000106  6b22              LDR      r2,[r4,#0x30]         ;4612
000108  f8c2c030          STR      r12,[r2,#0x30]        ;4612
00010c  6b22              LDR      r2,[r4,#0x30]         ;4615
00010e  6350              STR      r0,[r2,#0x34]         ;4615
000110  6822              LDR      r2,[r4,#0]            ;4618
000112  6b20              LDR      r0,[r4,#0x30]         ;4618
000114  324c              ADDS     r2,r2,#0x4c           ;4618
000116  f7fffffe          BL       HAL_DMA_Start_IT
00011a  b108              CBZ      r0,|L17.288|
00011c  2001              MOVS     r0,#1                 ;4622
00011e  e781              B        |L17.36|
                  |L17.288|
000120  e027              B        |L17.370|
                  |L17.290|
000122  f8d4c034          LDR      r12,[r4,#0x34]        ;4629
000126  4a1c              LDR      r2,|L17.408|
000128  f8cc202c          STR      r2,[r12,#0x2c]        ;4629
00012c  f8d4c034          LDR      r12,[r4,#0x34]        ;4630
000130  4a1a              LDR      r2,|L17.412|
000132  f8cc2030          STR      r2,[r12,#0x30]        ;4630
000136  6b62              LDR      r2,[r4,#0x34]         ;4633
000138  6350              STR      r0,[r2,#0x34]         ;4633
00013a  6822              LDR      r2,[r4,#0]            ;4636
00013c  6b60              LDR      r0,[r4,#0x34]         ;4636
00013e  324c              ADDS     r2,r2,#0x4c           ;4636
000140  f7fffffe          BL       HAL_DMA_Start_IT
000144  b1a8              CBZ      r0,|L17.370|
000146  2001              MOVS     r0,#1                 ;4640
000148  e76c              B        |L17.36|
                  |L17.330|
00014a  f8d4c038          LDR      r12,[r4,#0x38]        ;4647
00014e  4a14              LDR      r2,|L17.416|
000150  f8cc202c          STR      r2,[r12,#0x2c]        ;4647
000154  f8d4c038          LDR      r12,[r4,#0x38]        ;4648
000158  4a12              LDR      r2,|L17.420|
00015a  f8cc2030          STR      r2,[r12,#0x30]        ;4648
00015e  6ba2              LDR      r2,[r4,#0x38]         ;4651
000160  6350              STR      r0,[r2,#0x34]         ;4651
000162  6822              LDR      r2,[r4,#0]            ;4654
000164  6ba0              LDR      r0,[r4,#0x38]         ;4654
000166  324c              ADDS     r2,r2,#0x4c           ;4654
000168  f7fffffe          BL       HAL_DMA_Start_IT
00016c  b108              CBZ      r0,|L17.370|
00016e  2001              MOVS     r0,#1                 ;4658
000170  e758              B        |L17.36|
                  |L17.370|
000172  6820              LDR      r0,[r4,#0]            ;4667
000174  4337              ORRS     r7,r7,r6              ;4667
000176  6487              STR      r7,[r0,#0x48]         ;4667
000178  6820              LDR      r0,[r4,#0]            ;4669
00017a  68c1              LDR      r1,[r0,#0xc]          ;4669
00017c  4329              ORRS     r1,r1,r5              ;4669
00017e  60c1              STR      r1,[r0,#0xc]          ;4669
000180  2000              MOVS     r0,#0                 ;4672
000182  e74f              B        |L17.36|
;;;4674   
                          ENDP

                  |L17.388|
                          DCD      TIM_DMAError
                  |L17.392|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.396|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L17.400|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.404|
                          DCD      TIM_DMAPeriodElapsedHalfCplt
                  |L17.408|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.412|
                          DCD      TIMEx_DMACommutationHalfCplt
                  |L17.416|
                          DCD      TIM_DMATriggerCplt
                  |L17.420|
                          DCD      TIM_DMATriggerHalfCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStart PROC
;;;4781     */
;;;4782   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
000000  b57c              PUSH     {r2-r6,lr}
;;;4783                                                uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;4784   {
000002  9c06              LDR      r4,[sp,#0x18]
;;;4785     return HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
000004  0a25              LSRS     r5,r4,#8
000006  1c6d              ADDS     r5,r5,#1
000008  e9cd4500          STRD     r4,r5,[sp,#0]
00000c  f7fffffe          BL       HAL_TIM_DMABurst_MultiReadStart
;;;4786                                            ((BurstLength) >> 8U) + 1U);
;;;4787   }
000010  bd7c              POP      {r2-r6,pc}
;;;4788   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;5011     */
;;;5012   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;5013   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;5014     /* Check the parameters */
;;;5015     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;5016   
;;;5017     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;5018     switch (BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L19.78|
00000c  dc09              BGT      |L19.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L19.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L19.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d125              BNE      |L19.108|
000020  e011              B        |L19.70|
                  |L19.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L19.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L19.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11b              BNE      |L19.108|
000034  e017              B        |L19.102|
                  |L19.54|
;;;5019     {
;;;5020       case TIM_DMA_UPDATE:
;;;5021       {
;;;5022         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f7fffffe          BL       HAL_DMA_Abort_IT
;;;5023         break;
00003c  e016              B        |L19.108|
                  |L19.62|
;;;5024       }
;;;5025       case TIM_DMA_CC1:
;;;5026       {
;;;5027         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a60              LDR      r0,[r4,#0x24]
000040  f7fffffe          BL       HAL_DMA_Abort_IT
;;;5028         break;
000044  e012              B        |L19.108|
                  |L19.70|
;;;5029       }
;;;5030       case TIM_DMA_CC2:
;;;5031       {
;;;5032         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000046  6aa0              LDR      r0,[r4,#0x28]
000048  f7fffffe          BL       HAL_DMA_Abort_IT
;;;5033         break;
00004c  e00e              B        |L19.108|
                  |L19.78|
;;;5034       }
;;;5035       case TIM_DMA_CC3:
;;;5036       {
;;;5037         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       HAL_DMA_Abort_IT
;;;5038         break;
000054  e00a              B        |L19.108|
                  |L19.86|
;;;5039       }
;;;5040       case TIM_DMA_CC4:
;;;5041       {
;;;5042         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
000056  6b20              LDR      r0,[r4,#0x30]
000058  f7fffffe          BL       HAL_DMA_Abort_IT
;;;5043         break;
00005c  e006              B        |L19.108|
                  |L19.94|
;;;5044       }
;;;5045       case TIM_DMA_COM:
;;;5046       {
;;;5047         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort_IT
;;;5048         break;
000064  e002              B        |L19.108|
                  |L19.102|
;;;5049       }
;;;5050       case TIM_DMA_TRIGGER:
;;;5051       {
;;;5052         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6ba0              LDR      r0,[r4,#0x38]
000068  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L19.108|
;;;5053         break;
;;;5054       }
;;;5055       default:
;;;5056         break;
;;;5057     }
;;;5058   
;;;5059     /* Disable the TIM Update DMA request */
;;;5060     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
00006c  6820              LDR      r0,[r4,#0]
00006e  68c1              LDR      r1,[r0,#0xc]
000070  43a9              BICS     r1,r1,r5
000072  60c1              STR      r1,[r0,#0xc]
;;;5061   
;;;5062     /* Change the DMA burst operation state */
;;;5063     htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
000074  2001              MOVS     r0,#1
000076  f8840048          STRB     r0,[r4,#0x48]
;;;5064   
;;;5065     /* Return function status */
;;;5066     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;5067   }
00007c  bd70              POP      {r4-r6,pc}
;;;5068   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStart PROC
;;;4451     */
;;;4452   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
000000  b57c              PUSH     {r2-r6,lr}
;;;4453                                                 uint32_t BurstRequestSrc, uint32_t *BurstBuffer, uint32_t  BurstLength)
;;;4454   {
000002  9c06              LDR      r4,[sp,#0x18]
;;;4455     return HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
000004  0a25              LSRS     r5,r4,#8
000006  1c6d              ADDS     r5,r5,#1
000008  e9cd4500          STRD     r4,r5,[sp,#0]
00000c  f7fffffe          BL       HAL_TIM_DMABurst_MultiWriteStart
;;;4456                                             ((BurstLength) >> 8U) + 1U);
;;;4457   }
000010  bd7c              POP      {r2-r6,pc}
;;;4458   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;4680     */
;;;4681   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;4682   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4683     /* Check the parameters */
;;;4684     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4685   
;;;4686     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;4687     switch (BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L21.78|
00000c  dc09              BGT      |L21.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L21.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L21.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d125              BNE      |L21.108|
000020  e011              B        |L21.70|
                  |L21.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L21.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L21.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11b              BNE      |L21.108|
000034  e017              B        |L21.102|
                  |L21.54|
;;;4688     {
;;;4689       case TIM_DMA_UPDATE:
;;;4690       {
;;;4691         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f7fffffe          BL       HAL_DMA_Abort_IT
;;;4692         break;
00003c  e016              B        |L21.108|
                  |L21.62|
;;;4693       }
;;;4694       case TIM_DMA_CC1:
;;;4695       {
;;;4696         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a60              LDR      r0,[r4,#0x24]
000040  f7fffffe          BL       HAL_DMA_Abort_IT
;;;4697         break;
000044  e012              B        |L21.108|
                  |L21.70|
;;;4698       }
;;;4699       case TIM_DMA_CC2:
;;;4700       {
;;;4701         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000046  6aa0              LDR      r0,[r4,#0x28]
000048  f7fffffe          BL       HAL_DMA_Abort_IT
;;;4702         break;
00004c  e00e              B        |L21.108|
                  |L21.78|
;;;4703       }
;;;4704       case TIM_DMA_CC3:
;;;4705       {
;;;4706         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       HAL_DMA_Abort_IT
;;;4707         break;
000054  e00a              B        |L21.108|
                  |L21.86|
;;;4708       }
;;;4709       case TIM_DMA_CC4:
;;;4710       {
;;;4711         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
000056  6b20              LDR      r0,[r4,#0x30]
000058  f7fffffe          BL       HAL_DMA_Abort_IT
;;;4712         break;
00005c  e006              B        |L21.108|
                  |L21.94|
;;;4713       }
;;;4714       case TIM_DMA_COM:
;;;4715       {
;;;4716         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort_IT
;;;4717         break;
000064  e002              B        |L21.108|
                  |L21.102|
;;;4718       }
;;;4719       case TIM_DMA_TRIGGER:
;;;4720       {
;;;4721         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6ba0              LDR      r0,[r4,#0x38]
000068  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L21.108|
;;;4722         break;
;;;4723       }
;;;4724       default:
;;;4725         break;
;;;4726     }
;;;4727   
;;;4728     /* Disable the TIM Update DMA request */
;;;4729     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
00006c  6820              LDR      r0,[r4,#0]
00006e  68c1              LDR      r1,[r0,#0xc]
000070  43a9              BICS     r1,r1,r5
000072  60c1              STR      r1,[r0,#0xc]
;;;4730   
;;;4731     /* Change the DMA burst operation state */
;;;4732     htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
000074  2001              MOVS     r0,#1
000076  f8840048          STRB     r0,[r4,#0x48]
;;;4733   
;;;4734     /* Return function status */
;;;4735     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;4736   }
00007c  bd70              POP      {r4-r6,pc}
;;;4737   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;3056     */
;;;3057   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;3058   {
000002  4604              MOV      r4,r0
;;;3059     /* Check the parameters */
;;;3060     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3061   
;;;3062     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;3063   
;;;3064     /* Disable the TIM Peripheral Clock */
;;;3065     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L22.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L22.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L22.38|
;;;3066   
;;;3067   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3068     if (htim->Encoder_MspDeInitCallback == NULL)
;;;3069     {
;;;3070       htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
;;;3071     }
;;;3072     /* DeInit the low level hardware */
;;;3073     htim->Encoder_MspDeInitCallback(htim);
;;;3074   #else
;;;3075     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;3076     HAL_TIM_Encoder_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;3077   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3078   
;;;3079     /* Change the DMA burst operation state */
;;;3080     htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7320              STRB     r0,[r4,#0xc]
;;;3081   
;;;3082     /* Set the TIM channels state */
;;;3083     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
000032  70a0              STRB     r0,[r4,#2]
;;;3084     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
000034  70e0              STRB     r0,[r4,#3]
;;;3085     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
000036  7220              STRB     r0,[r4,#8]
;;;3086     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
000038  7260              STRB     r0,[r4,#9]
;;;3087   
;;;3088     /* Change TIM state */
;;;3089     htim->State = HAL_TIM_STATE_RESET;
00003a  7060              STRB     r0,[r4,#1]
;;;3090   
;;;3091     /* Release Lock */
;;;3092     __HAL_UNLOCK(htim);
00003c  7020              STRB     r0,[r4,#0]
;;;3093   
;;;3094     return HAL_OK;
;;;3095   }
00003e  bd10              POP      {r4,pc}
;;;3096   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;6352     */
;;;6353   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;6354   {
;;;6355     return htim->State;
;;;6356   }
000004  4770              BX       lr
;;;6357   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Init PROC
;;;2942     */
;;;2943   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2944   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2945     uint32_t tmpsmcr;
;;;2946     uint32_t tmpccmr1;
;;;2947     uint32_t tmpccer;
;;;2948   
;;;2949     /* Check the TIM handle allocation */
;;;2950     if (htim == NULL)
000008  2c00              CMP      r4,#0
00000a  d003              BEQ      |L24.20|
;;;2951     {
;;;2952       return HAL_ERROR;
;;;2953     }
;;;2954   
;;;2955     /* Check the parameters */
;;;2956     assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
;;;2957     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2958     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2959     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2960     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2961     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2962     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2963     assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));
;;;2964     assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));
;;;2965     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2966     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2967     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2968     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2969   
;;;2970     if (htim->State == HAL_TIM_STATE_RESET)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  b118              CBZ      r0,|L24.26|
000012  e008              B        |L24.38|
                  |L24.20|
000014  2001              MOVS     r0,#1                 ;2952
                  |L24.22|
;;;2971     {
;;;2972       /* Allocate lock resource and initialize it */
;;;2973       htim->Lock = HAL_UNLOCKED;
;;;2974   
;;;2975   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2976       /* Reset interrupt callbacks to legacy weak callbacks */
;;;2977       TIM_ResetCallback(htim);
;;;2978   
;;;2979       if (htim->Encoder_MspInitCallback == NULL)
;;;2980       {
;;;2981         htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
;;;2982       }
;;;2983       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2984       htim->Encoder_MspInitCallback(htim);
;;;2985   #else
;;;2986       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2987       HAL_TIM_Encoder_MspInit(htim);
;;;2988   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2989     }
;;;2990   
;;;2991     /* Set the TIM state */
;;;2992     htim->State = HAL_TIM_STATE_BUSY;
;;;2993   
;;;2994     /* Reset the SMS and ECE bits */
;;;2995     htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
;;;2996   
;;;2997     /* Configure the Time base in the Encoder Mode */
;;;2998     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2999   
;;;3000     /* Get the TIMx SMCR register value */
;;;3001     tmpsmcr = htim->Instance->SMCR;
;;;3002   
;;;3003     /* Get the TIMx CCMR1 register value */
;;;3004     tmpccmr1 = htim->Instance->CCMR1;
;;;3005   
;;;3006     /* Get the TIMx CCER register value */
;;;3007     tmpccer = htim->Instance->CCER;
;;;3008   
;;;3009     /* Set the encoder Mode */
;;;3010     tmpsmcr |= sConfig->EncoderMode;
;;;3011   
;;;3012     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3013     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;3014     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;3015   
;;;3016     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;3017     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;3018     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;3019     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;3020     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;3021   
;;;3022     /* Set the TI1 and the TI2 Polarities */
;;;3023     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;3024     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;3025     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;3026   
;;;3027     /* Write to TIMx SMCR */
;;;3028     htim->Instance->SMCR = tmpsmcr;
;;;3029   
;;;3030     /* Write to TIMx CCMR1 */
;;;3031     htim->Instance->CCMR1 = tmpccmr1;
;;;3032   
;;;3033     /* Write to TIMx CCER */
;;;3034     htim->Instance->CCER = tmpccer;
;;;3035   
;;;3036     /* Initialize the DMA burst operation state */
;;;3037     htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
;;;3038   
;;;3039     /* Set the TIM channels state */
;;;3040     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
;;;3041     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
;;;3042     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
;;;3043     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
;;;3044   
;;;3045     /* Initialize the TIM state*/
;;;3046     htim->State = HAL_TIM_STATE_READY;
;;;3047   
;;;3048     return HAL_OK;
;;;3049   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L24.26|
00001a  2000              MOVS     r0,#0                 ;2973
00001c  f884003c          STRB     r0,[r4,#0x3c]         ;2973
000020  4620              MOV      r0,r4                 ;2987
000022  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L24.38|
000026  2002              MOVS     r0,#2                 ;2992
000028  f884003d          STRB     r0,[r4,#0x3d]         ;2992
00002c  6820              LDR      r0,[r4,#0]            ;2995
00002e  6881              LDR      r1,[r0,#8]            ;2995
000030  4a20              LDR      r2,|L24.180|
000032  4011              ANDS     r1,r1,r2              ;2995
000034  6081              STR      r1,[r0,#8]            ;2995
000036  1d21              ADDS     r1,r4,#4              ;2998
000038  6820              LDR      r0,[r4,#0]            ;2998
00003a  f7fffffe          BL       TIM_Base_SetConfig
00003e  3429              ADDS     r4,r4,#0x29           ;3001
000040  f8540c29          LDR      r0,[r4,#-0x29]        ;3001
000044  6881              LDR      r1,[r0,#8]            ;3001
000046  6982              LDR      r2,[r0,#0x18]         ;3004
000048  6a06              LDR      r6,[r0,#0x20]         ;3007
00004a  682b              LDR      r3,[r5,#0]            ;3010
00004c  430b              ORRS     r3,r3,r1              ;3010
00004e  f2403103          MOV      r1,#0x303             ;3013
000052  438a              BICS     r2,r2,r1              ;3013
000054  69af              LDR      r7,[r5,#0x18]         ;3014
000056  68a9              LDR      r1,[r5,#8]            ;3014
000058  ea422207          ORR      r2,r2,r7,LSL #8       ;3014
00005c  4311              ORRS     r1,r1,r2              ;3014
00005e  f640420c          MOV      r2,#0xc0c             ;3017
000062  4391              BICS     r1,r1,r2              ;3017
000064  f24f02f0          MOV      r2,#0xf0f0            ;3018
000068  4391              BICS     r1,r1,r2              ;3018
00006a  69ef              LDR      r7,[r5,#0x1c]         ;3019
00006c  68ea              LDR      r2,[r5,#0xc]          ;3019
00006e  ea412107          ORR      r1,r1,r7,LSL #8       ;3019
000072  430a              ORRS     r2,r2,r1              ;3019
000074  6929              LDR      r1,[r5,#0x10]         ;3020
000076  6a2f              LDR      r7,[r5,#0x20]         ;3020
000078  0109              LSLS     r1,r1,#4              ;3020
00007a  ea413107          ORR      r1,r1,r7,LSL #12      ;3020
00007e  4311              ORRS     r1,r1,r2              ;3020
000080  f0260222          BIC      r2,r6,#0x22           ;3023
000084  f0220688          BIC      r6,r2,#0x88           ;3024
000088  686a              LDR      r2,[r5,#4]            ;3025
00008a  696d              LDR      r5,[r5,#0x14]         ;3025
00008c  ea461505          ORR      r5,r6,r5,LSL #4       ;3025
000090  432a              ORRS     r2,r2,r5              ;3025
000092  6083              STR      r3,[r0,#8]            ;3028
000094  f8540c29          LDR      r0,[r4,#-0x29]        ;3031
000098  6181              STR      r1,[r0,#0x18]         ;3031
00009a  f8540c29          LDR      r0,[r4,#-0x29]        ;3034
00009e  6202              STR      r2,[r0,#0x20]         ;3034
0000a0  2001              MOVS     r0,#1                 ;3037
0000a2  77e0              STRB     r0,[r4,#0x1f]         ;3037
0000a4  7560              STRB     r0,[r4,#0x15]         ;3040
0000a6  75a0              STRB     r0,[r4,#0x16]         ;3041
0000a8  76e0              STRB     r0,[r4,#0x1b]         ;3042
0000aa  7720              STRB     r0,[r4,#0x1c]         ;3043
0000ac  7520              STRB     r0,[r4,#0x14]         ;3046
0000ae  2000              MOVS     r0,#0                 ;3048
0000b0  e7b1              B        |L24.22|
;;;3050   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L24.180|
                          DCD      0xfffebff8

                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;3116     */
;;;3117   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;3118   {
;;;3119     /* Prevent unused argument(s) compilation warning */
;;;3120     UNUSED(htim);
;;;3121   
;;;3122     /* NOTE : This function should not be modified, when the callback is needed,
;;;3123               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;3124      */
;;;3125   }
;;;3126   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;3101     */
;;;3102   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;3103   {
;;;3104     /* Prevent unused argument(s) compilation warning */
;;;3105     UNUSED(htim);
;;;3106   
;;;3107     /* NOTE : This function should not be modified, when the callback is needed,
;;;3108               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;3109      */
;;;3110   }
;;;3111   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;3136     */
;;;3137   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3138   {
000002  4604              MOV      r4,r0
;;;3139     HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
000004  f8140f3e          LDRB     r0,[r4,#0x3e]!
;;;3140     HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
000008  7862              LDRB     r2,[r4,#1]
;;;3141     HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
00000a  79a3              LDRB     r3,[r4,#6]
;;;3142     HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
00000c  79e5              LDRB     r5,[r4,#7]
00000e  3c3e              SUBS     r4,r4,#0x3e
;;;3143   
;;;3144     /* Check the parameters */
;;;3145     assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
;;;3146   
;;;3147     /* Set the TIM channel(s) state */
;;;3148     if (Channel == TIM_CHANNEL_1)
;;;3149     {
;;;3150       if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3151           || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
;;;3152       {
;;;3153         return HAL_ERROR;
;;;3154       }
;;;3155       else
;;;3156       {
;;;3157         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
000010  2602              MOVS     r6,#2
000012  2900              CMP      r1,#0                 ;3148
000014  d004              BEQ      |L27.32|
;;;3158         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3159       }
;;;3160     }
;;;3161     else if (Channel == TIM_CHANNEL_2)
000016  2904              CMP      r1,#4
000018  d00d              BEQ      |L27.54|
;;;3162     {
;;;3163       if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3164           || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
;;;3165       {
;;;3166         return HAL_ERROR;
;;;3167       }
;;;3168       else
;;;3169       {
;;;3170         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3171         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3172       }
;;;3173     }
;;;3174     else
;;;3175     {
;;;3176       if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
00001a  2801              CMP      r0,#1
00001c  d11c              BNE      |L27.88|
00001e  e015              B        |L27.76|
                  |L27.32|
000020  2801              CMP      r0,#1                 ;3150
000022  d101              BNE      |L27.40|
000024  2b01              CMP      r3,#1                 ;3151
000026  d001              BEQ      |L27.44|
                  |L27.40|
000028  2001              MOVS     r0,#1                 ;3153
;;;3177           || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3178           || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3179           || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
;;;3180       {
;;;3181         return HAL_ERROR;
;;;3182       }
;;;3183       else
;;;3184       {
;;;3185         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3186         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3187         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3188         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3189       }
;;;3190     }
;;;3191   
;;;3192     /* Enable the encoder interface channels */
;;;3193     switch (Channel)
;;;3194     {
;;;3195       case TIM_CHANNEL_1:
;;;3196       {
;;;3197         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3198         break;
;;;3199       }
;;;3200   
;;;3201       case TIM_CHANNEL_2:
;;;3202       {
;;;3203         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3204         break;
;;;3205       }
;;;3206   
;;;3207       default :
;;;3208       {
;;;3209         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3210         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3211         break;
;;;3212       }
;;;3213     }
;;;3214     /* Enable the Peripheral */
;;;3215     __HAL_TIM_ENABLE(htim);
;;;3216   
;;;3217     /* Return function status */
;;;3218     return HAL_OK;
;;;3219   }
00002a  bd70              POP      {r4-r6,pc}
                  |L27.44|
00002c  f884603e          STRB     r6,[r4,#0x3e]         ;3157
000030  f8846044          STRB     r6,[r4,#0x44]         ;3158
000034  e018              B        |L27.104|
                  |L27.54|
000036  2a01              CMP      r2,#1                 ;3163
000038  d101              BNE      |L27.62|
00003a  2d01              CMP      r5,#1                 ;3164
00003c  d001              BEQ      |L27.66|
                  |L27.62|
00003e  2001              MOVS     r0,#1                 ;3166
000040  bd70              POP      {r4-r6,pc}
                  |L27.66|
000042  f884603f          STRB     r6,[r4,#0x3f]         ;3170
000046  f8846045          STRB     r6,[r4,#0x45]         ;3171
00004a  e00d              B        |L27.104|
                  |L27.76|
00004c  2a01              CMP      r2,#1                 ;3177
00004e  d103              BNE      |L27.88|
000050  2b01              CMP      r3,#1                 ;3178
000052  d101              BNE      |L27.88|
000054  2d01              CMP      r5,#1                 ;3179
000056  d001              BEQ      |L27.92|
                  |L27.88|
000058  2001              MOVS     r0,#1                 ;3181
00005a  bd70              POP      {r4-r6,pc}
                  |L27.92|
00005c  f8046f3e          STRB     r6,[r4,#0x3e]!        ;3185
000060  7066              STRB     r6,[r4,#1]            ;3186
000062  71a6              STRB     r6,[r4,#6]            ;3187
000064  71e6              STRB     r6,[r4,#7]            ;3188
000066  3c3e              SUBS     r4,r4,#0x3e           ;3188
                  |L27.104|
000068  b191              CBZ      r1,|L27.144|
00006a  2904              CMP      r1,#4                 ;3193
00006c  d016              BEQ      |L27.156|
00006e  2201              MOVS     r2,#1                 ;3209
000070  2100              MOVS     r1,#0                 ;3209
000072  6820              LDR      r0,[r4,#0]            ;3209
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  2201              MOVS     r2,#1                 ;3210
00007a  2104              MOVS     r1,#4                 ;3210
00007c  6820              LDR      r0,[r4,#0]            ;3210
00007e  f7fffffe          BL       TIM_CCxChannelCmd
                  |L27.130|
000082  6820              LDR      r0,[r4,#0]            ;3215
000084  6801              LDR      r1,[r0,#0]            ;3215
000086  f0410101          ORR      r1,r1,#1              ;3215
00008a  6001              STR      r1,[r0,#0]            ;3215
00008c  2000              MOVS     r0,#0                 ;3218
00008e  bd70              POP      {r4-r6,pc}
                  |L27.144|
000090  2201              MOVS     r2,#1                 ;3197
000092  2100              MOVS     r1,#0                 ;3197
000094  6820              LDR      r0,[r4,#0]            ;3197
000096  f7fffffe          BL       TIM_CCxChannelCmd
00009a  e7f2              B        |L27.130|
                  |L27.156|
00009c  2201              MOVS     r2,#1                 ;3203
00009e  2104              MOVS     r1,#4                 ;3203
0000a0  6820              LDR      r0,[r4,#0]            ;3203
0000a2  f7fffffe          BL       TIM_CCxChannelCmd
0000a6  e7ec              B        |L27.130|
;;;3220   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;3455     */
;;;3456   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3457                                               uint32_t *pData2, uint16_t Length)
;;;3458   {
000004  4604              MOV      r4,r0
000006  9e08              LDR      r6,[sp,#0x20]
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;3459     HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
00000c  f8140f3e          LDRB     r0,[r4,#0x3e]!
;;;3460     HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
000010  7862              LDRB     r2,[r4,#1]
;;;3461     HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
000012  79a3              LDRB     r3,[r4,#6]
;;;3462     HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
000014  79e5              LDRB     r5,[r4,#7]
000016  3c3e              SUBS     r4,r4,#0x3e
000018  f04f0c02          MOV      r12,#2                ;3459
;;;3463   
;;;3464     /* Check the parameters */
;;;3465     assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
;;;3466   
;;;3467     /* Set the TIM channel(s) state */
;;;3468     if (Channel == TIM_CHANNEL_1)
00001c  2900              CMP      r1,#0
00001e  d00c              BEQ      |L28.58|
;;;3469     {
;;;3470       if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
;;;3471           || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
;;;3472       {
;;;3473         return HAL_BUSY;
;;;3474       }
;;;3475       else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
;;;3476                && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
;;;3477       {
;;;3478         if ((pData1 == NULL) && (Length > 0U))
;;;3479         {
;;;3480           return HAL_ERROR;
;;;3481         }
;;;3482         else
;;;3483         {
;;;3484           TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3485           TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3486         }
;;;3487       }
;;;3488       else
;;;3489       {
;;;3490         return HAL_ERROR;
;;;3491       }
;;;3492     }
;;;3493     else if (Channel == TIM_CHANNEL_2)
000020  2904              CMP      r1,#4
000022  d021              BEQ      |L28.104|
;;;3494     {
;;;3495       if ((channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
;;;3496           || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
;;;3497       {
;;;3498         return HAL_BUSY;
;;;3499       }
;;;3500       else if ((channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
;;;3501                && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
;;;3502       {
;;;3503         if ((pData2 == NULL) && (Length > 0U))
;;;3504         {
;;;3505           return HAL_ERROR;
;;;3506         }
;;;3507         else
;;;3508         {
;;;3509           TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3510           TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3511         }
;;;3512       }
;;;3513       else
;;;3514       {
;;;3515         return HAL_ERROR;
;;;3516       }
;;;3517     }
;;;3518     else
;;;3519     {
;;;3520       if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
000024  2802              CMP      r0,#2
000026  d037              BEQ      |L28.152|
;;;3521           || (channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
000028  2a02              CMP      r2,#2
00002a  d035              BEQ      |L28.152|
;;;3522           || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
00002c  2b02              CMP      r3,#2
00002e  d033              BEQ      |L28.152|
;;;3523           || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
000030  2d02              CMP      r5,#2
000032  d031              BEQ      |L28.152|
;;;3524       {
;;;3525         return HAL_BUSY;
;;;3526       }
;;;3527       else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
000034  2801              CMP      r0,#1
000036  d031              BEQ      |L28.156|
000038  e036              B        |L28.168|
                  |L28.58|
00003a  2802              CMP      r0,#2                 ;3470
00003c  d004              BEQ      |L28.72|
00003e  2b02              CMP      r3,#2                 ;3471
000040  d002              BEQ      |L28.72|
000042  2801              CMP      r0,#1                 ;3475
000044  d003              BEQ      |L28.78|
000046  e004              B        |L28.82|
                  |L28.72|
000048  2002              MOVS     r0,#2                 ;3473
                  |L28.74|
;;;3528                && (channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
;;;3529                && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
;;;3530                && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
;;;3531       {
;;;3532         if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
;;;3533         {
;;;3534           return HAL_ERROR;
;;;3535         }
;;;3536         else
;;;3537         {
;;;3538           TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3539           TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3540           TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3541           TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3542         }
;;;3543       }
;;;3544       else
;;;3545       {
;;;3546         return HAL_ERROR;
;;;3547       }
;;;3548     }
;;;3549   
;;;3550     switch (Channel)
;;;3551     {
;;;3552       case TIM_CHANNEL_1:
;;;3553       {
;;;3554         /* Set the DMA capture callbacks */
;;;3555         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3556         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;3557   
;;;3558         /* Set the DMA error callback */
;;;3559         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3560   
;;;3561         /* Enable the DMA channel */
;;;3562         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
;;;3563         {
;;;3564           /* Return error status */
;;;3565           return HAL_ERROR;
;;;3566         }
;;;3567         /* Enable the TIM Input Capture DMA request */
;;;3568         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;3569   
;;;3570         /* Enable the Peripheral */
;;;3571         __HAL_TIM_ENABLE(htim);
;;;3572   
;;;3573         /* Enable the Capture compare channel */
;;;3574         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3575         break;
;;;3576       }
;;;3577   
;;;3578       case TIM_CHANNEL_2:
;;;3579       {
;;;3580         /* Set the DMA capture callbacks */
;;;3581         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3582         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;3583   
;;;3584         /* Set the DMA error callback */
;;;3585         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;3586         /* Enable the DMA channel */
;;;3587         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
;;;3588         {
;;;3589           /* Return error status */
;;;3590           return HAL_ERROR;
;;;3591         }
;;;3592         /* Enable the TIM Input Capture  DMA request */
;;;3593         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;3594   
;;;3595         /* Enable the Peripheral */
;;;3596         __HAL_TIM_ENABLE(htim);
;;;3597   
;;;3598         /* Enable the Capture compare channel */
;;;3599         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3600         break;
;;;3601       }
;;;3602   
;;;3603       case TIM_CHANNEL_ALL:
;;;3604       {
;;;3605         /* Set the DMA capture callbacks */
;;;3606         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3607         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;3608   
;;;3609         /* Set the DMA error callback */
;;;3610         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3611   
;;;3612         /* Enable the DMA channel */
;;;3613         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
;;;3614         {
;;;3615           /* Return error status */
;;;3616           return HAL_ERROR;
;;;3617         }
;;;3618   
;;;3619         /* Set the DMA capture callbacks */
;;;3620         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3621         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;3622   
;;;3623         /* Set the DMA error callback */
;;;3624         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3625   
;;;3626         /* Enable the DMA channel */
;;;3627         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
;;;3628         {
;;;3629           /* Return error status */
;;;3630           return HAL_ERROR;
;;;3631         }
;;;3632         /* Enable the Peripheral */
;;;3633         __HAL_TIM_ENABLE(htim);
;;;3634   
;;;3635         /* Enable the Capture compare channel */
;;;3636         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3637         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3638   
;;;3639         /* Enable the TIM Input Capture  DMA request */
;;;3640         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;3641         /* Enable the TIM Input Capture  DMA request */
;;;3642         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;3643         break;
;;;3644       }
;;;3645   
;;;3646       default:
;;;3647         break;
;;;3648     }
;;;3649   
;;;3650     /* Return function status */
;;;3651     return HAL_OK;
;;;3652   }
00004a  e8bd87f0          POP      {r4-r10,pc}
                  |L28.78|
00004e  2b01              CMP      r3,#1                 ;3476
000050  d001              BEQ      |L28.86|
                  |L28.82|
000052  2001              MOVS     r0,#1                 ;3490
000054  e7f9              B        |L28.74|
                  |L28.86|
000056  b917              CBNZ     r7,|L28.94|
000058  b10e              CBZ      r6,|L28.94|
00005a  2001              MOVS     r0,#1                 ;3480
00005c  e7f5              B        |L28.74|
                  |L28.94|
00005e  f884c03e          STRB     r12,[r4,#0x3e]        ;3484
000062  f884c044          STRB     r12,[r4,#0x44]        ;3485
000066  e030              B        |L28.202|
                  |L28.104|
000068  2a02              CMP      r2,#2                 ;3495
00006a  d004              BEQ      |L28.118|
00006c  2d02              CMP      r5,#2                 ;3496
00006e  d002              BEQ      |L28.118|
000070  2a01              CMP      r2,#1                 ;3500
000072  d002              BEQ      |L28.122|
000074  e003              B        |L28.126|
                  |L28.118|
000076  2002              MOVS     r0,#2                 ;3498
000078  e7e7              B        |L28.74|
                  |L28.122|
00007a  2d01              CMP      r5,#1                 ;3501
00007c  d001              BEQ      |L28.130|
                  |L28.126|
00007e  2001              MOVS     r0,#1                 ;3515
000080  e7e3              B        |L28.74|
                  |L28.130|
000082  f1b80f00          CMP      r8,#0                 ;3503
000086  d102              BNE      |L28.142|
000088  b10e              CBZ      r6,|L28.142|
00008a  2001              MOVS     r0,#1                 ;3505
00008c  e7dd              B        |L28.74|
                  |L28.142|
00008e  f884c03f          STRB     r12,[r4,#0x3f]        ;3509
000092  f884c045          STRB     r12,[r4,#0x45]        ;3510
000096  e018              B        |L28.202|
                  |L28.152|
000098  2002              MOVS     r0,#2                 ;3525
00009a  e7d6              B        |L28.74|
                  |L28.156|
00009c  2a01              CMP      r2,#1                 ;3528
00009e  d103              BNE      |L28.168|
0000a0  2b01              CMP      r3,#1                 ;3529
0000a2  d101              BNE      |L28.168|
0000a4  2d01              CMP      r5,#1                 ;3530
0000a6  d001              BEQ      |L28.172|
                  |L28.168|
0000a8  2001              MOVS     r0,#1                 ;3546
0000aa  e7ce              B        |L28.74|
                  |L28.172|
0000ac  b117              CBZ      r7,|L28.180|
0000ae  f1b80f00          CMP      r8,#0                 ;3532
0000b2  d102              BNE      |L28.186|
                  |L28.180|
0000b4  b10e              CBZ      r6,|L28.186|
0000b6  2001              MOVS     r0,#1                 ;3534
0000b8  e7c7              B        |L28.74|
                  |L28.186|
0000ba  f884c03e          STRB     r12,[r4,#0x3e]        ;3538
0000be  f884c03f          STRB     r12,[r4,#0x3f]        ;3539
0000c2  f884c044          STRB     r12,[r4,#0x44]        ;3540
0000c6  f884c045          STRB     r12,[r4,#0x45]        ;3541
                  |L28.202|
0000ca  4d47              LDR      r5,|L28.488|
0000cc  f8df911c          LDR      r9,|L28.492|
0000d0  f8dfa11c          LDR      r10,|L28.496|
0000d4  b121              CBZ      r1,|L28.224|
0000d6  2904              CMP      r1,#4                 ;3550
0000d8  d024              BEQ      |L28.292|
0000da  293c              CMP      r1,#0x3c              ;3550
0000dc  d121              BNE      |L28.290|
0000de  e043              B        |L28.360|
                  |L28.224|
0000e0  6a60              LDR      r0,[r4,#0x24]         ;3555
0000e2  62c5              STR      r5,[r0,#0x2c]         ;3555
0000e4  6a60              LDR      r0,[r4,#0x24]         ;3556
0000e6  f8c09030          STR      r9,[r0,#0x30]         ;3556
0000ea  6a60              LDR      r0,[r4,#0x24]         ;3559
0000ec  f8c0a034          STR      r10,[r0,#0x34]        ;3559
0000f0  6821              LDR      r1,[r4,#0]            ;3562
0000f2  4633              MOV      r3,r6                 ;3562
0000f4  3134              ADDS     r1,r1,#0x34           ;3562
0000f6  463a              MOV      r2,r7                 ;3562
0000f8  6a60              LDR      r0,[r4,#0x24]         ;3562
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  b108              CBZ      r0,|L28.260|
000100  2001              MOVS     r0,#1                 ;3565
000102  e7a2              B        |L28.74|
                  |L28.260|
000104  6820              LDR      r0,[r4,#0]            ;3568
000106  68c1              LDR      r1,[r0,#0xc]          ;3568
000108  f4417100          ORR      r1,r1,#0x200          ;3568
00010c  60c1              STR      r1,[r0,#0xc]          ;3568
00010e  6820              LDR      r0,[r4,#0]            ;3571
000110  6801              LDR      r1,[r0,#0]            ;3571
000112  f0410101          ORR      r1,r1,#1              ;3571
000116  6001              STR      r1,[r0,#0]            ;3571
000118  2201              MOVS     r2,#1                 ;3574
00011a  2100              MOVS     r1,#0                 ;3574
00011c  6820              LDR      r0,[r4,#0]            ;3574
00011e  f7fffffe          BL       TIM_CCxChannelCmd
                  |L28.290|
000122  e05e              B        |L28.482|
                  |L28.292|
000124  6aa0              LDR      r0,[r4,#0x28]         ;3581
000126  62c5              STR      r5,[r0,#0x2c]         ;3581
000128  6aa0              LDR      r0,[r4,#0x28]         ;3582
00012a  f8c09030          STR      r9,[r0,#0x30]         ;3582
00012e  6aa0              LDR      r0,[r4,#0x28]         ;3585
000130  f8c0a034          STR      r10,[r0,#0x34]        ;3585
000134  6821              LDR      r1,[r4,#0]            ;3587
000136  4633              MOV      r3,r6                 ;3587
000138  3138              ADDS     r1,r1,#0x38           ;3587
00013a  4642              MOV      r2,r8                 ;3587
00013c  6aa0              LDR      r0,[r4,#0x28]         ;3587
00013e  f7fffffe          BL       HAL_DMA_Start_IT
000142  b108              CBZ      r0,|L28.328|
000144  2001              MOVS     r0,#1                 ;3590
000146  e780              B        |L28.74|
                  |L28.328|
000148  6820              LDR      r0,[r4,#0]            ;3593
00014a  68c1              LDR      r1,[r0,#0xc]          ;3593
00014c  f4416180          ORR      r1,r1,#0x400          ;3593
000150  60c1              STR      r1,[r0,#0xc]          ;3593
000152  6820              LDR      r0,[r4,#0]            ;3596
000154  6801              LDR      r1,[r0,#0]            ;3596
000156  f0410101          ORR      r1,r1,#1              ;3596
00015a  6001              STR      r1,[r0,#0]            ;3596
00015c  2201              MOVS     r2,#1                 ;3599
00015e  2104              MOVS     r1,#4                 ;3599
000160  6820              LDR      r0,[r4,#0]            ;3599
000162  f7fffffe          BL       TIM_CCxChannelCmd
000166  e03c              B        |L28.482|
                  |L28.360|
000168  6a60              LDR      r0,[r4,#0x24]         ;3606
00016a  62c5              STR      r5,[r0,#0x2c]         ;3606
00016c  6a60              LDR      r0,[r4,#0x24]         ;3607
00016e  f8c09030          STR      r9,[r0,#0x30]         ;3607
000172  6a60              LDR      r0,[r4,#0x24]         ;3610
000174  f8c0a034          STR      r10,[r0,#0x34]        ;3610
000178  6821              LDR      r1,[r4,#0]            ;3613
00017a  4633              MOV      r3,r6                 ;3613
00017c  3134              ADDS     r1,r1,#0x34           ;3613
00017e  463a              MOV      r2,r7                 ;3613
000180  6a60              LDR      r0,[r4,#0x24]         ;3613
000182  f7fffffe          BL       HAL_DMA_Start_IT
000186  b108              CBZ      r0,|L28.396|
000188  2001              MOVS     r0,#1                 ;3616
00018a  e75e              B        |L28.74|
                  |L28.396|
00018c  6aa0              LDR      r0,[r4,#0x28]         ;3620
00018e  62c5              STR      r5,[r0,#0x2c]         ;3620
000190  6aa0              LDR      r0,[r4,#0x28]         ;3621
000192  f8c09030          STR      r9,[r0,#0x30]         ;3621
000196  6aa0              LDR      r0,[r4,#0x28]         ;3624
000198  f8c0a034          STR      r10,[r0,#0x34]        ;3624
00019c  6821              LDR      r1,[r4,#0]            ;3627
00019e  4633              MOV      r3,r6                 ;3627
0001a0  3138              ADDS     r1,r1,#0x38           ;3627
0001a2  4642              MOV      r2,r8                 ;3627
0001a4  6aa0              LDR      r0,[r4,#0x28]         ;3627
0001a6  f7fffffe          BL       HAL_DMA_Start_IT
0001aa  b108              CBZ      r0,|L28.432|
0001ac  2001              MOVS     r0,#1                 ;3630
0001ae  e74c              B        |L28.74|
                  |L28.432|
0001b0  6820              LDR      r0,[r4,#0]            ;3633
0001b2  6801              LDR      r1,[r0,#0]            ;3633
0001b4  f0410101          ORR      r1,r1,#1              ;3633
0001b8  6001              STR      r1,[r0,#0]            ;3633
0001ba  2201              MOVS     r2,#1                 ;3636
0001bc  2100              MOVS     r1,#0                 ;3636
0001be  6820              LDR      r0,[r4,#0]            ;3636
0001c0  f7fffffe          BL       TIM_CCxChannelCmd
0001c4  2201              MOVS     r2,#1                 ;3637
0001c6  2104              MOVS     r1,#4                 ;3637
0001c8  6820              LDR      r0,[r4,#0]            ;3637
0001ca  f7fffffe          BL       TIM_CCxChannelCmd
0001ce  6820              LDR      r0,[r4,#0]            ;3640
0001d0  68c1              LDR      r1,[r0,#0xc]          ;3640
0001d2  f4417100          ORR      r1,r1,#0x200          ;3640
0001d6  60c1              STR      r1,[r0,#0xc]          ;3640
0001d8  6820              LDR      r0,[r4,#0]            ;3642
0001da  68c1              LDR      r1,[r0,#0xc]          ;3642
0001dc  f4416180          ORR      r1,r1,#0x400          ;3642
0001e0  60c1              STR      r1,[r0,#0xc]          ;3642
                  |L28.482|
0001e2  2000              MOVS     r0,#0                 ;3651
0001e4  e731              B        |L28.74|
;;;3653   
                          ENDP

0001e6  0000              DCW      0x0000
                  |L28.488|
                          DCD      TIM_DMACaptureCplt
                  |L28.492|
                          DCD      TIM_DMACaptureHalfCplt
                  |L28.496|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;3290     */
;;;3291   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3292   {
000002  4604              MOV      r4,r0
;;;3293     HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
000004  f8140f3e          LDRB     r0,[r4,#0x3e]!
;;;3294     HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
000008  7862              LDRB     r2,[r4,#1]
;;;3295     HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
00000a  79a3              LDRB     r3,[r4,#6]
;;;3296     HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
00000c  79e5              LDRB     r5,[r4,#7]
00000e  3c3e              SUBS     r4,r4,#0x3e
;;;3297   
;;;3298     /* Check the parameters */
;;;3299     assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
;;;3300   
;;;3301     /* Set the TIM channel(s) state */
;;;3302     if (Channel == TIM_CHANNEL_1)
;;;3303     {
;;;3304       if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3305           || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
;;;3306       {
;;;3307         return HAL_ERROR;
;;;3308       }
;;;3309       else
;;;3310       {
;;;3311         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
000010  2602              MOVS     r6,#2
000012  2900              CMP      r1,#0                 ;3302
000014  d004              BEQ      |L29.32|
;;;3312         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3313       }
;;;3314     }
;;;3315     else if (Channel == TIM_CHANNEL_2)
000016  2904              CMP      r1,#4
000018  d00d              BEQ      |L29.54|
;;;3316     {
;;;3317       if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3318           || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
;;;3319       {
;;;3320         return HAL_ERROR;
;;;3321       }
;;;3322       else
;;;3323       {
;;;3324         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3325         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3326       }
;;;3327     }
;;;3328     else
;;;3329     {
;;;3330       if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
00001a  2801              CMP      r0,#1
00001c  d11c              BNE      |L29.88|
00001e  e015              B        |L29.76|
                  |L29.32|
000020  2801              CMP      r0,#1                 ;3304
000022  d101              BNE      |L29.40|
000024  2b01              CMP      r3,#1                 ;3305
000026  d001              BEQ      |L29.44|
                  |L29.40|
000028  2001              MOVS     r0,#1                 ;3307
;;;3331           || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3332           || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
;;;3333           || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
;;;3334       {
;;;3335         return HAL_ERROR;
;;;3336       }
;;;3337       else
;;;3338       {
;;;3339         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3340         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3341         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3342         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;3343       }
;;;3344     }
;;;3345   
;;;3346     /* Enable the encoder interface channels */
;;;3347     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;3348     switch (Channel)
;;;3349     {
;;;3350       case TIM_CHANNEL_1:
;;;3351       {
;;;3352         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3353         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;3354         break;
;;;3355       }
;;;3356   
;;;3357       case TIM_CHANNEL_2:
;;;3358       {
;;;3359         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3360         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;3361         break;
;;;3362       }
;;;3363   
;;;3364       default :
;;;3365       {
;;;3366         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3367         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3368         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;3369         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;3370         break;
;;;3371       }
;;;3372     }
;;;3373   
;;;3374     /* Enable the Peripheral */
;;;3375     __HAL_TIM_ENABLE(htim);
;;;3376   
;;;3377     /* Return function status */
;;;3378     return HAL_OK;
;;;3379   }
00002a  bd70              POP      {r4-r6,pc}
                  |L29.44|
00002c  f884603e          STRB     r6,[r4,#0x3e]         ;3311
000030  f8846044          STRB     r6,[r4,#0x44]         ;3312
000034  e018              B        |L29.104|
                  |L29.54|
000036  2a01              CMP      r2,#1                 ;3317
000038  d101              BNE      |L29.62|
00003a  2d01              CMP      r5,#1                 ;3318
00003c  d001              BEQ      |L29.66|
                  |L29.62|
00003e  2001              MOVS     r0,#1                 ;3320
000040  bd70              POP      {r4-r6,pc}
                  |L29.66|
000042  f884603f          STRB     r6,[r4,#0x3f]         ;3324
000046  f8846045          STRB     r6,[r4,#0x45]         ;3325
00004a  e00d              B        |L29.104|
                  |L29.76|
00004c  2a01              CMP      r2,#1                 ;3331
00004e  d103              BNE      |L29.88|
000050  2b01              CMP      r3,#1                 ;3332
000052  d101              BNE      |L29.88|
000054  2d01              CMP      r5,#1                 ;3333
000056  d001              BEQ      |L29.92|
                  |L29.88|
000058  2001              MOVS     r0,#1                 ;3335
00005a  bd70              POP      {r4-r6,pc}
                  |L29.92|
00005c  f8046f3e          STRB     r6,[r4,#0x3e]!        ;3339
000060  7066              STRB     r6,[r4,#1]            ;3340
000062  71a6              STRB     r6,[r4,#6]            ;3341
000064  71e6              STRB     r6,[r4,#7]            ;3342
000066  3c3e              SUBS     r4,r4,#0x3e           ;3342
                  |L29.104|
000068  b1e1              CBZ      r1,|L29.164|
00006a  2904              CMP      r1,#4                 ;3348
00006c  d025              BEQ      |L29.186|
00006e  2201              MOVS     r2,#1                 ;3366
000070  2100              MOVS     r1,#0                 ;3366
000072  6820              LDR      r0,[r4,#0]            ;3366
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  2201              MOVS     r2,#1                 ;3367
00007a  2104              MOVS     r1,#4                 ;3367
00007c  6820              LDR      r0,[r4,#0]            ;3367
00007e  f7fffffe          BL       TIM_CCxChannelCmd
000082  6820              LDR      r0,[r4,#0]            ;3368
000084  68c1              LDR      r1,[r0,#0xc]          ;3368
000086  f0410102          ORR      r1,r1,#2              ;3368
00008a  60c1              STR      r1,[r0,#0xc]          ;3368
00008c  6820              LDR      r0,[r4,#0]            ;3369
00008e  68c1              LDR      r1,[r0,#0xc]          ;3369
000090  f0410104          ORR      r1,r1,#4              ;3369
000094  60c1              STR      r1,[r0,#0xc]          ;3369
                  |L29.150|
000096  6820              LDR      r0,[r4,#0]            ;3375
000098  6801              LDR      r1,[r0,#0]            ;3375
00009a  f0410101          ORR      r1,r1,#1              ;3375
00009e  6001              STR      r1,[r0,#0]            ;3375
0000a0  2000              MOVS     r0,#0                 ;3378
0000a2  bd70              POP      {r4-r6,pc}
                  |L29.164|
0000a4  2201              MOVS     r2,#1                 ;3352
0000a6  2100              MOVS     r1,#0                 ;3352
0000a8  6820              LDR      r0,[r4,#0]            ;3352
0000aa  f7fffffe          BL       TIM_CCxChannelCmd
0000ae  6820              LDR      r0,[r4,#0]            ;3353
0000b0  68c1              LDR      r1,[r0,#0xc]          ;3353
0000b2  f0410102          ORR      r1,r1,#2              ;3353
0000b6  60c1              STR      r1,[r0,#0xc]          ;3353
0000b8  e7ed              B        |L29.150|
                  |L29.186|
0000ba  2201              MOVS     r2,#1                 ;3359
0000bc  2104              MOVS     r1,#4                 ;3359
0000be  6820              LDR      r0,[r4,#0]            ;3359
0000c0  f7fffffe          BL       TIM_CCxChannelCmd
0000c4  6820              LDR      r0,[r4,#0]            ;3360
0000c6  68c1              LDR      r1,[r0,#0xc]          ;3360
0000c8  f0410104          ORR      r1,r1,#4              ;3360
0000cc  60c1              STR      r1,[r0,#0xc]          ;3360
0000ce  e7e2              B        |L29.150|
;;;3380   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;3230     */
;;;3231   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;3232   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3233     /* Check the parameters */
;;;3234     assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
;;;3235   
;;;3236     /* Disable the Input Capture channels 1 and 2
;;;3237       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;3238     switch (Channel)
;;;3239     {
;;;3240       case TIM_CHANNEL_1:
;;;3241       {
;;;3242         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;3238
00000a  d023              BEQ      |L30.84|
00000c  2d04              CMP      r5,#4                 ;3238
00000e  d026              BEQ      |L30.94|
;;;3243         break;
;;;3244       }
;;;3245   
;;;3246       case TIM_CHANNEL_2:
;;;3247       {
;;;3248         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;3249         break;
;;;3250       }
;;;3251   
;;;3252       default :
;;;3253       {
;;;3254         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000010  2200              MOVS     r2,#0
000012  4611              MOV      r1,r2
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;3255         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000018  2200              MOVS     r2,#0
00001a  2104              MOVS     r1,#4
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
                  |L30.34|
;;;3256         break;
;;;3257       }
;;;3258     }
;;;3259   
;;;3260     /* Disable the Peripheral */
;;;3261     __HAL_TIM_DISABLE(htim);
000022  6820              LDR      r0,[r4,#0]
000024  6a01              LDR      r1,[r0,#0x20]
000026  f2411211          MOV      r2,#0x1111
00002a  4211              TST      r1,r2
00002c  d107              BNE      |L30.62|
00002e  6a01              LDR      r1,[r0,#0x20]
000030  1092              ASRS     r2,r2,#2
000032  4211              TST      r1,r2
000034  d103              BNE      |L30.62|
000036  6801              LDR      r1,[r0,#0]
000038  f0210101          BIC      r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
                  |L30.62|
;;;3262   
;;;3263     /* Set the TIM channel(s) state */
;;;3264     if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
;;;3265     {
;;;3266       TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
00003e  2001              MOVS     r0,#1
000040  b195              CBZ      r5,|L30.104|
000042  2d04              CMP      r5,#4                 ;3264
000044  d010              BEQ      |L30.104|
;;;3267       TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
;;;3268     }
;;;3269     else
;;;3270     {
;;;3271       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000046  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;3272       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00004a  7060              STRB     r0,[r4,#1]
;;;3273       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00004c  71a0              STRB     r0,[r4,#6]
;;;3274       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00004e  71e0              STRB     r0,[r4,#7]
                  |L30.80|
;;;3275     }
;;;3276   
;;;3277     /* Return function status */
;;;3278     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;3279   }
000052  bd30              POP      {r4,r5,pc}
                  |L30.84|
000054  2200              MOVS     r2,#0                 ;3242
000056  4611              MOV      r1,r2                 ;3242
000058  f7fffffe          BL       TIM_CCxChannelCmd
00005c  e7e1              B        |L30.34|
                  |L30.94|
00005e  2200              MOVS     r2,#0                 ;3248
000060  2104              MOVS     r1,#4                 ;3248
000062  f7fffffe          BL       TIM_CCxChannelCmd
000066  e7dc              B        |L30.34|
                  |L30.104|
000068  b18d              CBZ      r5,|L30.142|
00006a  2d04              CMP      r5,#4                 ;3266
00006c  d012              BEQ      |L30.148|
00006e  2d08              CMP      r5,#8                 ;3266
000070  d013              BEQ      |L30.154|
000072  2d0c              CMP      r5,#0xc               ;3266
000074  d014              BEQ      |L30.160|
000076  2d10              CMP      r5,#0x10              ;3266
000078  d015              BEQ      |L30.166|
00007a  f8840043          STRB     r0,[r4,#0x43]         ;3266
                  |L30.126|
00007e  b1ad              CBZ      r5,|L30.172|
000080  2d04              CMP      r5,#4                 ;3267
000082  d016              BEQ      |L30.178|
000084  2d08              CMP      r5,#8                 ;3267
000086  d017              BEQ      |L30.184|
000088  f8840047          STRB     r0,[r4,#0x47]         ;3267
00008c  e7e0              B        |L30.80|
                  |L30.142|
00008e  f884003e          STRB     r0,[r4,#0x3e]         ;3266
000092  e7f4              B        |L30.126|
                  |L30.148|
000094  f884003f          STRB     r0,[r4,#0x3f]         ;3266
000098  e7f1              B        |L30.126|
                  |L30.154|
00009a  f8840040          STRB     r0,[r4,#0x40]         ;3266
00009e  e7ee              B        |L30.126|
                  |L30.160|
0000a0  f8840041          STRB     r0,[r4,#0x41]         ;3266
0000a4  e7eb              B        |L30.126|
                  |L30.166|
0000a6  f8840042          STRB     r0,[r4,#0x42]         ;3266
0000aa  e7e8              B        |L30.126|
                  |L30.172|
0000ac  f8840044          STRB     r0,[r4,#0x44]         ;3267
0000b0  e7ce              B        |L30.80|
                  |L30.178|
0000b2  f8840045          STRB     r0,[r4,#0x45]         ;3267
0000b6  e7cb              B        |L30.80|
                  |L30.184|
0000b8  f8840046          STRB     r0,[r4,#0x46]         ;3267
0000bc  e7c8              B        |L30.80|
;;;3280   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;3663     */
;;;3664   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3665   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3666     /* Check the parameters */
;;;3667     assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
;;;3668   
;;;3669     /* Disable the Input Capture channels 1 and 2
;;;3670       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;3671     if (Channel == TIM_CHANNEL_1)
;;;3672     {
;;;3673       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;3671
00000a  d033              BEQ      |L31.116|
;;;3674   
;;;3675       /* Disable the capture compare DMA Request 1 */
;;;3676       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;3677       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
;;;3678     }
;;;3679     else if (Channel == TIM_CHANNEL_2)
00000c  2d04              CMP      r5,#4
00000e  d03e              BEQ      |L31.142|
;;;3680     {
;;;3681       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;3682   
;;;3683       /* Disable the capture compare DMA Request 2 */
;;;3684       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;3685       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
;;;3686     }
;;;3687     else
;;;3688     {
;;;3689       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000010  2200              MOVS     r2,#0
000012  4611              MOV      r1,r2
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;3690       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000018  2200              MOVS     r2,#0
00001a  2104              MOVS     r1,#4
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;3691   
;;;3692       /* Disable the capture compare DMA Request 1 and 2 */
;;;3693       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000022  6820              LDR      r0,[r4,#0]
000024  68c1              LDR      r1,[r0,#0xc]
000026  f4217100          BIC      r1,r1,#0x200
00002a  60c1              STR      r1,[r0,#0xc]
;;;3694       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002c  6820              LDR      r0,[r4,#0]
00002e  68c1              LDR      r1,[r0,#0xc]
000030  f4216180          BIC      r1,r1,#0x400
000034  60c1              STR      r1,[r0,#0xc]
;;;3695       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000036  6a60              LDR      r0,[r4,#0x24]
000038  f7fffffe          BL       HAL_DMA_Abort_IT
;;;3696       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L31.66|
;;;3697     }
;;;3698   
;;;3699     /* Disable the Peripheral */
;;;3700     __HAL_TIM_DISABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6a01              LDR      r1,[r0,#0x20]
000046  f2411211          MOV      r2,#0x1111
00004a  4211              TST      r1,r2
00004c  d107              BNE      |L31.94|
00004e  6a01              LDR      r1,[r0,#0x20]
000050  1092              ASRS     r2,r2,#2
000052  4211              TST      r1,r2
000054  d103              BNE      |L31.94|
000056  6801              LDR      r1,[r0,#0]
000058  f0210101          BIC      r1,r1,#1
00005c  6001              STR      r1,[r0,#0]
                  |L31.94|
;;;3701   
;;;3702     /* Set the TIM channel(s) state */
;;;3703     if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
;;;3704     {
;;;3705       TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
00005e  2001              MOVS     r0,#1
000060  b315              CBZ      r5,|L31.168|
000062  2d04              CMP      r5,#4                 ;3703
000064  d020              BEQ      |L31.168|
;;;3706       TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
;;;3707     }
;;;3708     else
;;;3709     {
;;;3710       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000066  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;3711       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00006a  7060              STRB     r0,[r4,#1]
;;;3712       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00006c  71a0              STRB     r0,[r4,#6]
;;;3713       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00006e  71e0              STRB     r0,[r4,#7]
                  |L31.112|
;;;3714     }
;;;3715   
;;;3716     /* Return function status */
;;;3717     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;3718   }
000072  bd70              POP      {r4-r6,pc}
                  |L31.116|
000074  2200              MOVS     r2,#0                 ;3673
000076  4611              MOV      r1,r2                 ;3673
000078  f7fffffe          BL       TIM_CCxChannelCmd
00007c  6820              LDR      r0,[r4,#0]            ;3676
00007e  68c1              LDR      r1,[r0,#0xc]          ;3676
000080  f4217100          BIC      r1,r1,#0x200          ;3676
000084  60c1              STR      r1,[r0,#0xc]          ;3676
000086  6a60              LDR      r0,[r4,#0x24]         ;3677
000088  f7fffffe          BL       HAL_DMA_Abort_IT
00008c  e7d9              B        |L31.66|
                  |L31.142|
00008e  2200              MOVS     r2,#0                 ;3681
000090  2104              MOVS     r1,#4                 ;3681
000092  f7fffffe          BL       TIM_CCxChannelCmd
000096  6820              LDR      r0,[r4,#0]            ;3684
000098  68c1              LDR      r1,[r0,#0xc]          ;3684
00009a  f4216180          BIC      r1,r1,#0x400          ;3684
00009e  60c1              STR      r1,[r0,#0xc]          ;3684
0000a0  6aa0              LDR      r0,[r4,#0x28]         ;3685
0000a2  f7fffffe          BL       HAL_DMA_Abort_IT
0000a6  e7cc              B        |L31.66|
                  |L31.168|
0000a8  b18d              CBZ      r5,|L31.206|
0000aa  2d04              CMP      r5,#4                 ;3705
0000ac  d012              BEQ      |L31.212|
0000ae  2d08              CMP      r5,#8                 ;3705
0000b0  d013              BEQ      |L31.218|
0000b2  2d0c              CMP      r5,#0xc               ;3705
0000b4  d014              BEQ      |L31.224|
0000b6  2d10              CMP      r5,#0x10              ;3705
0000b8  d015              BEQ      |L31.230|
0000ba  f8840043          STRB     r0,[r4,#0x43]         ;3705
                  |L31.190|
0000be  b1ad              CBZ      r5,|L31.236|
0000c0  2d04              CMP      r5,#4                 ;3706
0000c2  d016              BEQ      |L31.242|
0000c4  2d08              CMP      r5,#8                 ;3706
0000c6  d017              BEQ      |L31.248|
0000c8  f8840047          STRB     r0,[r4,#0x47]         ;3706
0000cc  e7d0              B        |L31.112|
                  |L31.206|
0000ce  f884003e          STRB     r0,[r4,#0x3e]         ;3705
0000d2  e7f4              B        |L31.190|
                  |L31.212|
0000d4  f884003f          STRB     r0,[r4,#0x3f]         ;3705
0000d8  e7f1              B        |L31.190|
                  |L31.218|
0000da  f8840040          STRB     r0,[r4,#0x40]         ;3705
0000de  e7ee              B        |L31.190|
                  |L31.224|
0000e0  f8840041          STRB     r0,[r4,#0x41]         ;3705
0000e4  e7eb              B        |L31.190|
                  |L31.230|
0000e6  f8840042          STRB     r0,[r4,#0x42]         ;3705
0000ea  e7e8              B        |L31.190|
                  |L31.236|
0000ec  f8840044          STRB     r0,[r4,#0x44]         ;3706
0000f0  e7be              B        |L31.112|
                  |L31.242|
0000f2  f8840045          STRB     r0,[r4,#0x45]         ;3706
0000f6  e7bb              B        |L31.112|
                  |L31.248|
0000f8  f8840046          STRB     r0,[r4,#0x46]         ;3706
0000fc  e7b8              B        |L31.112|
;;;3719   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;3390     */
;;;3391   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;3392   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3393     /* Check the parameters */
;;;3394     assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));
;;;3395   
;;;3396     /* Disable the Input Capture channels 1 and 2
;;;3397       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;3398     if (Channel == TIM_CHANNEL_1)
;;;3399     {
;;;3400       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;3398
00000a  d02d              BEQ      |L32.104|
;;;3401   
;;;3402       /* Disable the capture compare Interrupts 1 */
;;;3403       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;3404     }
;;;3405     else if (Channel == TIM_CHANNEL_2)
00000c  2d04              CMP      r5,#4
00000e  d035              BEQ      |L32.124|
;;;3406     {
;;;3407       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;3408   
;;;3409       /* Disable the capture compare Interrupts 2 */
;;;3410       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;3411     }
;;;3412     else
;;;3413     {
;;;3414       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000010  2200              MOVS     r2,#0
000012  4611              MOV      r1,r2
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;3415       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000018  2200              MOVS     r2,#0
00001a  2104              MOVS     r1,#4
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;3416   
;;;3417       /* Disable the capture compare Interrupts 1 and 2 */
;;;3418       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000022  6820              LDR      r0,[r4,#0]
000024  68c1              LDR      r1,[r0,#0xc]
000026  f0210102          BIC      r1,r1,#2
00002a  60c1              STR      r1,[r0,#0xc]
;;;3419       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002c  6820              LDR      r0,[r4,#0]
00002e  68c1              LDR      r1,[r0,#0xc]
000030  f0210104          BIC      r1,r1,#4
000034  60c1              STR      r1,[r0,#0xc]
                  |L32.54|
;;;3420     }
;;;3421   
;;;3422     /* Disable the Peripheral */
;;;3423     __HAL_TIM_DISABLE(htim);
000036  6820              LDR      r0,[r4,#0]
000038  6a01              LDR      r1,[r0,#0x20]
00003a  f2411211          MOV      r2,#0x1111
00003e  4211              TST      r1,r2
000040  d107              BNE      |L32.82|
000042  6a01              LDR      r1,[r0,#0x20]
000044  1092              ASRS     r2,r2,#2
000046  4211              TST      r1,r2
000048  d103              BNE      |L32.82|
00004a  6801              LDR      r1,[r0,#0]
00004c  f0210101          BIC      r1,r1,#1
000050  6001              STR      r1,[r0,#0]
                  |L32.82|
;;;3424   
;;;3425     /* Set the TIM channel(s) state */
;;;3426     if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
;;;3427     {
;;;3428       TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000052  2001              MOVS     r0,#1
000054  b1e5              CBZ      r5,|L32.144|
000056  2d04              CMP      r5,#4                 ;3426
000058  d01a              BEQ      |L32.144|
;;;3429       TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
;;;3430     }
;;;3431     else
;;;3432     {
;;;3433       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00005a  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;3434       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00005e  7060              STRB     r0,[r4,#1]
;;;3435       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000060  71a0              STRB     r0,[r4,#6]
;;;3436       TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000062  71e0              STRB     r0,[r4,#7]
                  |L32.100|
;;;3437     }
;;;3438   
;;;3439     /* Return function status */
;;;3440     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;3441   }
000066  bd30              POP      {r4,r5,pc}
                  |L32.104|
000068  2200              MOVS     r2,#0                 ;3400
00006a  4611              MOV      r1,r2                 ;3400
00006c  f7fffffe          BL       TIM_CCxChannelCmd
000070  6820              LDR      r0,[r4,#0]            ;3403
000072  68c1              LDR      r1,[r0,#0xc]          ;3403
000074  f0210102          BIC      r1,r1,#2              ;3403
000078  60c1              STR      r1,[r0,#0xc]          ;3403
00007a  e7dc              B        |L32.54|
                  |L32.124|
00007c  2200              MOVS     r2,#0                 ;3407
00007e  2104              MOVS     r1,#4                 ;3407
000080  f7fffffe          BL       TIM_CCxChannelCmd
000084  6820              LDR      r0,[r4,#0]            ;3410
000086  68c1              LDR      r1,[r0,#0xc]          ;3410
000088  f0210104          BIC      r1,r1,#4              ;3410
00008c  60c1              STR      r1,[r0,#0xc]          ;3410
00008e  e7d2              B        |L32.54|
                  |L32.144|
000090  b18d              CBZ      r5,|L32.182|
000092  2d04              CMP      r5,#4                 ;3428
000094  d012              BEQ      |L32.188|
000096  2d08              CMP      r5,#8                 ;3428
000098  d013              BEQ      |L32.194|
00009a  2d0c              CMP      r5,#0xc               ;3428
00009c  d014              BEQ      |L32.200|
00009e  2d10              CMP      r5,#0x10              ;3428
0000a0  d015              BEQ      |L32.206|
0000a2  f8840043          STRB     r0,[r4,#0x43]         ;3428
                  |L32.166|
0000a6  b1ad              CBZ      r5,|L32.212|
0000a8  2d04              CMP      r5,#4                 ;3429
0000aa  d016              BEQ      |L32.218|
0000ac  2d08              CMP      r5,#8                 ;3429
0000ae  d017              BEQ      |L32.224|
0000b0  f8840047          STRB     r0,[r4,#0x47]         ;3429
0000b4  e7d6              B        |L32.100|
                  |L32.182|
0000b6  f884003e          STRB     r0,[r4,#0x3e]         ;3428
0000ba  e7f4              B        |L32.166|
                  |L32.188|
0000bc  f884003f          STRB     r0,[r4,#0x3f]         ;3428
0000c0  e7f1              B        |L32.166|
                  |L32.194|
0000c2  f8840040          STRB     r0,[r4,#0x40]         ;3428
0000c6  e7ee              B        |L32.166|
                  |L32.200|
0000c8  f8840041          STRB     r0,[r4,#0x41]         ;3428
0000cc  e7eb              B        |L32.166|
                  |L32.206|
0000ce  f8840042          STRB     r0,[r4,#0x42]         ;3428
0000d2  e7e8              B        |L32.166|
                  |L32.212|
0000d4  f8840044          STRB     r0,[r4,#0x44]         ;3429
0000d8  e7c4              B        |L32.100|
                  |L32.218|
0000da  f8840045          STRB     r0,[r4,#0x45]         ;3429
0000de  e7c1              B        |L32.100|
                  |L32.224|
0000e0  f8840046          STRB     r0,[r4,#0x46]         ;3429
0000e4  e7be              B        |L32.100|
;;;3442   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;5775     */
;;;5776   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5777   {
;;;5778     /* Prevent unused argument(s) compilation warning */
;;;5779     UNUSED(htim);
;;;5780   
;;;5781     /* NOTE : This function should not be modified, when the callback is needed,
;;;5782               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;5783      */
;;;5784   }
;;;5785   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;5089   
;;;5090   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  f890203c          LDRB     r2,[r0,#0x3c]
;;;5091   {
;;;5092     /* Check the parameters */
;;;5093     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;5094     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;5095   
;;;5096     /* Process Locked */
;;;5097     __HAL_LOCK(htim);
000004  2a01              CMP      r2,#1
000006  d00c              BEQ      |L34.34|
000008  2201              MOVS     r2,#1
00000a  f8002f3c          STRB     r2,[r0,#0x3c]!
;;;5098   
;;;5099     /* Change the TIM state */
;;;5100     htim->State = HAL_TIM_STATE_BUSY;
00000e  2302              MOVS     r3,#2
000010  7043              STRB     r3,[r0,#1]
;;;5101   
;;;5102     /* Set the event sources */
;;;5103     htim->Instance->EGR = EventSource;
000012  f8503c3c          LDR      r3,[r0,#-0x3c]
000016  6159              STR      r1,[r3,#0x14]
;;;5104   
;;;5105     /* Change the TIM state */
;;;5106     htim->State = HAL_TIM_STATE_READY;
000018  7042              STRB     r2,[r0,#1]
;;;5107   
;;;5108     __HAL_UNLOCK(htim);
00001a  2100              MOVS     r1,#0
00001c  7001              STRB     r1,[r0,#0]
;;;5109   
;;;5110     /* Return function status */
;;;5111     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;5112   }
000020  4770              BX       lr
                  |L34.34|
000022  2002              MOVS     r0,#2                 ;5097
000024  4770              BX       lr
;;;5113   
                          ENDP


                          AREA ||i.HAL_TIM_GetActiveChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GetActiveChannel PROC
;;;6362     */
;;;6363   HAL_TIM_ActiveChannel HAL_TIM_GetActiveChannel(TIM_HandleTypeDef *htim)
000000  7f00              LDRB     r0,[r0,#0x1c]
;;;6364   {
;;;6365     return htim->Channel;
;;;6366   }
000002  4770              BX       lr
;;;6367   
                          ENDP


                          AREA ||i.HAL_TIM_GetChannelState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GetChannelState PROC
;;;6380     */
;;;6381   HAL_TIM_ChannelStateTypeDef HAL_TIM_GetChannelState(TIM_HandleTypeDef *htim,  uint32_t Channel)
000000  2900              CMP      r1,#0
;;;6382   {
000002  d00a              BEQ      |L36.26|
;;;6383     HAL_TIM_ChannelStateTypeDef channel_state;
;;;6384   
;;;6385     /* Check the parameters */
;;;6386     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;6387   
;;;6388     channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
000004  2904              CMP      r1,#4
000006  d00b              BEQ      |L36.32|
000008  2908              CMP      r1,#8
00000a  d00c              BEQ      |L36.38|
00000c  290c              CMP      r1,#0xc
00000e  d00d              BEQ      |L36.44|
000010  2910              CMP      r1,#0x10
000012  d00e              BEQ      |L36.50|
000014  f8900043          LDRB     r0,[r0,#0x43]
;;;6389   
;;;6390     return channel_state;
;;;6391   }
000018  4770              BX       lr
                  |L36.26|
00001a  f890003e          LDRB     r0,[r0,#0x3e]         ;6388
00001e  4770              BX       lr
                  |L36.32|
000020  f890003f          LDRB     r0,[r0,#0x3f]         ;6388
000024  4770              BX       lr
                  |L36.38|
000026  f8900040          LDRB     r0,[r0,#0x40]         ;6388
00002a  4770              BX       lr
                  |L36.44|
00002c  f8900041          LDRB     r0,[r0,#0x41]         ;6388
000030  4770              BX       lr
                  |L36.50|
000032  f8900042          LDRB     r0,[r0,#0x42]         ;6388
000036  4770              BX       lr
;;;6392   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;5685     */
;;;5686   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5687   {
;;;5688     /* Prevent unused argument(s) compilation warning */
;;;5689     UNUSED(htim);
;;;5690   
;;;5691     /* NOTE : This function should not be modified, when the callback is needed,
;;;5692               the HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;5693      */
;;;5694   }
;;;5695   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureHalfCpltCallback PROC
;;;5700     */
;;;5701   __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5702   {
;;;5703     /* Prevent unused argument(s) compilation warning */
;;;5704     UNUSED(htim);
;;;5705   
;;;5706     /* NOTE : This function should not be modified, when the callback is needed,
;;;5707               the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
;;;5708      */
;;;5709   }
;;;5710   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;4066     */
;;;4067   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;4068   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;4069     /* Check the parameters */
;;;4070     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4071     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;4072     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;4073     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;4074     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;4075   
;;;4076     /* Process Locked */
;;;4077     __HAL_LOCK(htim);
000006  f895003c          LDRB     r0,[r5,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d01c              BEQ      |L39.72|
00000e  2001              MOVS     r0,#1
000010  f885003c          STRB     r0,[r5,#0x3c]
000014  b1d2              CBZ      r2,|L39.76|
;;;4078   
;;;4079     if (Channel == TIM_CHANNEL_1)
;;;4080     {
;;;4081       /* TI1 Configuration */
;;;4082       TIM_TI1_SetConfig(htim->Instance,
;;;4083                         sConfig->ICPolarity,
;;;4084                         sConfig->ICSelection,
;;;4085                         sConfig->ICFilter);
;;;4086   
;;;4087       /* Reset the IC1PSC Bits */
;;;4088       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;4089   
;;;4090       /* Set the IC1PSC value */
;;;4091       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;4092     }
;;;4093     else if (Channel == TIM_CHANNEL_2)
000016  2a04              CMP      r2,#4
000018  d029              BEQ      |L39.110|
;;;4094     {
;;;4095       /* TI2 Configuration */
;;;4096       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4097   
;;;4098       TIM_TI2_SetConfig(htim->Instance,
;;;4099                         sConfig->ICPolarity,
;;;4100                         sConfig->ICSelection,
;;;4101                         sConfig->ICFilter);
;;;4102   
;;;4103       /* Reset the IC2PSC Bits */
;;;4104       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;4105   
;;;4106       /* Set the IC2PSC value */
;;;4107       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;4108     }
;;;4109     else if (Channel == TIM_CHANNEL_3)
00001a  2a08              CMP      r2,#8
00001c  d039              BEQ      |L39.146|
;;;4110     {
;;;4111       /* TI3 Configuration */
;;;4112       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4113   
;;;4114       TIM_TI3_SetConfig(htim->Instance,
;;;4115                         sConfig->ICPolarity,
;;;4116                         sConfig->ICSelection,
;;;4117                         sConfig->ICFilter);
;;;4118   
;;;4119       /* Reset the IC3PSC Bits */
;;;4120       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;4121   
;;;4122       /* Set the IC3PSC value */
;;;4123       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;4124     }
;;;4125     else
;;;4126     {
;;;4127       /* TI4 Configuration */
;;;4128       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4129   
;;;4130       TIM_TI4_SetConfig(htim->Instance,
00001e  e9d41200          LDRD     r1,r2,[r4,#0]
000022  68e3              LDR      r3,[r4,#0xc]
000024  6828              LDR      r0,[r5,#0]
000026  f7fffffe          BL       TIM_TI4_SetConfig
;;;4131                         sConfig->ICPolarity,
;;;4132                         sConfig->ICSelection,
;;;4133                         sConfig->ICFilter);
;;;4134   
;;;4135       /* Reset the IC4PSC Bits */
;;;4136       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
00002a  6828              LDR      r0,[r5,#0]
00002c  69c1              LDR      r1,[r0,#0x1c]
00002e  f4216140          BIC      r1,r1,#0xc00
000032  61c1              STR      r1,[r0,#0x1c]
;;;4137   
;;;4138       /* Set the IC4PSC value */
;;;4139       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
000034  6828              LDR      r0,[r5,#0]
000036  69c1              LDR      r1,[r0,#0x1c]
000038  68a2              LDR      r2,[r4,#8]
00003a  ea412102          ORR      r1,r1,r2,LSL #8
00003e  61c1              STR      r1,[r0,#0x1c]
                  |L39.64|
;;;4140     }
;;;4141   
;;;4142     __HAL_UNLOCK(htim);
000040  2000              MOVS     r0,#0
000042  f885003c          STRB     r0,[r5,#0x3c]
;;;4143   
;;;4144     return HAL_OK;
;;;4145   }
000046  bd70              POP      {r4-r6,pc}
                  |L39.72|
000048  2002              MOVS     r0,#2                 ;4077
00004a  bd70              POP      {r4-r6,pc}
                  |L39.76|
00004c  e9d41200          LDRD     r1,r2,[r4,#0]         ;4082
000050  68e3              LDR      r3,[r4,#0xc]          ;4082
000052  6828              LDR      r0,[r5,#0]            ;4082
000054  f7fffffe          BL       TIM_TI1_SetConfig
000058  6828              LDR      r0,[r5,#0]            ;4088
00005a  6981              LDR      r1,[r0,#0x18]         ;4088
00005c  f021010c          BIC      r1,r1,#0xc            ;4088
000060  6181              STR      r1,[r0,#0x18]         ;4088
000062  6828              LDR      r0,[r5,#0]            ;4091
000064  6981              LDR      r1,[r0,#0x18]         ;4091
000066  68a2              LDR      r2,[r4,#8]            ;4091
000068  4311              ORRS     r1,r1,r2              ;4091
00006a  6181              STR      r1,[r0,#0x18]         ;4091
00006c  e7e8              B        |L39.64|
                  |L39.110|
00006e  e9d41200          LDRD     r1,r2,[r4,#0]         ;4098
000072  68e3              LDR      r3,[r4,#0xc]          ;4098
000074  6828              LDR      r0,[r5,#0]            ;4098
000076  f7fffffe          BL       TIM_TI2_SetConfig
00007a  6828              LDR      r0,[r5,#0]            ;4104
00007c  6981              LDR      r1,[r0,#0x18]         ;4104
00007e  f4216140          BIC      r1,r1,#0xc00          ;4104
000082  6181              STR      r1,[r0,#0x18]         ;4104
000084  6828              LDR      r0,[r5,#0]            ;4107
000086  6981              LDR      r1,[r0,#0x18]         ;4107
000088  68a2              LDR      r2,[r4,#8]            ;4107
00008a  ea412102          ORR      r1,r1,r2,LSL #8       ;4107
00008e  6181              STR      r1,[r0,#0x18]         ;4107
000090  e7d6              B        |L39.64|
                  |L39.146|
000092  e9d41200          LDRD     r1,r2,[r4,#0]         ;4114
000096  68e3              LDR      r3,[r4,#0xc]          ;4114
000098  6828              LDR      r0,[r5,#0]            ;4114
00009a  f7fffffe          BL       TIM_TI3_SetConfig
00009e  6828              LDR      r0,[r5,#0]            ;4120
0000a0  69c1              LDR      r1,[r0,#0x1c]         ;4120
0000a2  f021010c          BIC      r1,r1,#0xc            ;4120
0000a6  61c1              STR      r1,[r0,#0x1c]         ;4120
0000a8  6828              LDR      r0,[r5,#0]            ;4123
0000aa  69c1              LDR      r1,[r0,#0x1c]         ;4123
0000ac  68a2              LDR      r2,[r4,#8]            ;4123
0000ae  4311              ORRS     r1,r1,r2              ;4123
0000b0  61c1              STR      r1,[r0,#0x1c]         ;4123
0000b2  e7c5              B        |L39.64|
;;;4146   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1989     */
;;;1990   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1991   {
000002  4604              MOV      r4,r0
;;;1992     /* Check the parameters */
;;;1993     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1994   
;;;1995     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1996   
;;;1997     /* Disable the TIM Peripheral Clock */
;;;1998     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L40.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L40.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L40.38|
;;;1999   
;;;2000   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2001     if (htim->IC_MspDeInitCallback == NULL)
;;;2002     {
;;;2003       htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
;;;2004     }
;;;2005     /* DeInit the low level hardware */
;;;2006     htim->IC_MspDeInitCallback(htim);
;;;2007   #else
;;;2008     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;2009     HAL_TIM_IC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;2010   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2011   
;;;2012     /* Change the DMA burst operation state */
;;;2013     htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7320              STRB     r0,[r4,#0xc]
;;;2014   
;;;2015     /* Change the TIM channels state */
;;;2016     TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
000032  70a0              STRB     r0,[r4,#2]
000034  70e0              STRB     r0,[r4,#3]
000036  7120              STRB     r0,[r4,#4]
000038  7160              STRB     r0,[r4,#5]
00003a  71a0              STRB     r0,[r4,#6]
00003c  71e0              STRB     r0,[r4,#7]
;;;2017     TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
00003e  7220              STRB     r0,[r4,#8]
000040  7260              STRB     r0,[r4,#9]
000042  72a0              STRB     r0,[r4,#0xa]
000044  72e0              STRB     r0,[r4,#0xb]
;;;2018   
;;;2019     /* Change TIM state */
;;;2020     htim->State = HAL_TIM_STATE_RESET;
000046  7060              STRB     r0,[r4,#1]
;;;2021   
;;;2022     /* Release Lock */
;;;2023     __HAL_UNLOCK(htim);
000048  7020              STRB     r0,[r4,#0]
;;;2024   
;;;2025     return HAL_OK;
;;;2026   }
00004a  bd10              POP      {r4,pc}
;;;2027   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;6332     */
;;;6333   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;6334   {
;;;6335     return htim->State;
;;;6336   }
000004  4770              BX       lr
;;;6337   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1930     */
;;;1931   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1932   {
000002  4604              MOV      r4,r0
;;;1933     /* Check the TIM handle allocation */
;;;1934     if (htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L42.16|
;;;1935     {
;;;1936       return HAL_ERROR;
;;;1937     }
;;;1938   
;;;1939     /* Check the parameters */
;;;1940     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1941     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1942     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1943     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1944   
;;;1945     if (htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L42.20|
00000e  e007              B        |L42.32|
                  |L42.16|
000010  2001              MOVS     r0,#1                 ;1936
;;;1946     {
;;;1947       /* Allocate lock resource and initialize it */
;;;1948       htim->Lock = HAL_UNLOCKED;
;;;1949   
;;;1950   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1951       /* Reset interrupt callbacks to legacy weak callbacks */
;;;1952       TIM_ResetCallback(htim);
;;;1953   
;;;1954       if (htim->IC_MspInitCallback == NULL)
;;;1955       {
;;;1956         htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
;;;1957       }
;;;1958       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1959       htim->IC_MspInitCallback(htim);
;;;1960   #else
;;;1961       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1962       HAL_TIM_IC_MspInit(htim);
;;;1963   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1964     }
;;;1965   
;;;1966     /* Set the TIM state */
;;;1967     htim->State = HAL_TIM_STATE_BUSY;
;;;1968   
;;;1969     /* Init the base time for the input capture */
;;;1970     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1971   
;;;1972     /* Initialize the DMA burst operation state */
;;;1973     htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
;;;1974   
;;;1975     /* Initialize the TIM channels state */
;;;1976     TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;1977     TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;1978   
;;;1979     /* Initialize the TIM state*/
;;;1980     htim->State = HAL_TIM_STATE_READY;
;;;1981   
;;;1982     return HAL_OK;
;;;1983   }
000012  bd10              POP      {r4,pc}
                  |L42.20|
000014  2000              MOVS     r0,#0                 ;1948
000016  f884003c          STRB     r0,[r4,#0x3c]         ;1948
00001a  4620              MOV      r0,r4                 ;1962
00001c  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L42.32|
000020  2002              MOVS     r0,#2                 ;1967
000022  f884003d          STRB     r0,[r4,#0x3d]         ;1967
000026  1d21              ADDS     r1,r4,#4              ;1970
000028  6820              LDR      r0,[r4,#0]            ;1970
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;1973
000030  343d              ADDS     r4,r4,#0x3d           ;1973
000032  72e0              STRB     r0,[r4,#0xb]          ;1973
000034  7060              STRB     r0,[r4,#1]            ;1976
000036  70a0              STRB     r0,[r4,#2]            ;1976
000038  70e0              STRB     r0,[r4,#3]            ;1976
00003a  7120              STRB     r0,[r4,#4]            ;1976
00003c  7160              STRB     r0,[r4,#5]            ;1976
00003e  71a0              STRB     r0,[r4,#6]            ;1976
000040  71e0              STRB     r0,[r4,#7]            ;1977
000042  7220              STRB     r0,[r4,#8]            ;1977
000044  7260              STRB     r0,[r4,#9]            ;1977
000046  72a0              STRB     r0,[r4,#0xa]          ;1977
000048  7020              STRB     r0,[r4,#0]            ;1980
00004a  2000              MOVS     r0,#0                 ;1982
00004c  bd10              POP      {r4,pc}
;;;1984   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;2047     */
;;;2048   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2049   {
;;;2050     /* Prevent unused argument(s) compilation warning */
;;;2051     UNUSED(htim);
;;;2052   
;;;2053     /* NOTE : This function should not be modified, when the callback is needed,
;;;2054               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;2055      */
;;;2056   }
;;;2057   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;2032     */
;;;2033   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2034   {
;;;2035     /* Prevent unused argument(s) compilation warning */
;;;2036     UNUSED(htim);
;;;2037   
;;;2038     /* NOTE : This function should not be modified, when the callback is needed,
;;;2039               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;2040      */
;;;2041   }
;;;2042   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start PROC
;;;2068     */
;;;2069   HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2070   {
000002  4604              MOV      r4,r0
;;;2071     uint32_t tmpsmcr;
;;;2072     HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
000004  2900              CMP      r1,#0
000006  d013              BEQ      |L45.48|
000008  2904              CMP      r1,#4
00000a  d014              BEQ      |L45.54|
00000c  2908              CMP      r1,#8
00000e  d015              BEQ      |L45.60|
000010  290c              CMP      r1,#0xc
000012  d016              BEQ      |L45.66|
000014  2910              CMP      r1,#0x10
000016  d017              BEQ      |L45.72|
000018  f8940043          LDRB     r0,[r4,#0x43]
                  |L45.28|
;;;2073     HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
00001c  b1b9              CBZ      r1,|L45.78|
00001e  2904              CMP      r1,#4
000020  d018              BEQ      |L45.84|
000022  2908              CMP      r1,#8
000024  d019              BEQ      |L45.90|
000026  f8942047          LDRB     r2,[r4,#0x47]
                  |L45.42|
;;;2074   
;;;2075     /* Check the parameters */
;;;2076     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2077   
;;;2078     /* Check the TIM channel state */
;;;2079     if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
00002a  2801              CMP      r0,#1
00002c  d11a              BNE      |L45.100|
00002e  e017              B        |L45.96|
                  |L45.48|
000030  f894003e          LDRB     r0,[r4,#0x3e]         ;2072
000034  e7f2              B        |L45.28|
                  |L45.54|
000036  f894003f          LDRB     r0,[r4,#0x3f]         ;2072
00003a  e7ef              B        |L45.28|
                  |L45.60|
00003c  f8940040          LDRB     r0,[r4,#0x40]         ;2072
000040  e7ec              B        |L45.28|
                  |L45.66|
000042  f8940041          LDRB     r0,[r4,#0x41]         ;2072
000046  e7e9              B        |L45.28|
                  |L45.72|
000048  f8940042          LDRB     r0,[r4,#0x42]         ;2072
00004c  e7e6              B        |L45.28|
                  |L45.78|
00004e  f8942044          LDRB     r2,[r4,#0x44]         ;2073
000052  e7ea              B        |L45.42|
                  |L45.84|
000054  f8942045          LDRB     r2,[r4,#0x45]         ;2073
000058  e7e7              B        |L45.42|
                  |L45.90|
00005a  f8942046          LDRB     r2,[r4,#0x46]         ;2073
00005e  e7e4              B        |L45.42|
                  |L45.96|
;;;2080         || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
000060  2a01              CMP      r2,#1
000062  d001              BEQ      |L45.104|
                  |L45.100|
;;;2081     {
;;;2082       return HAL_ERROR;
000064  2001              MOVS     r0,#1
;;;2083     }
;;;2084   
;;;2085     /* Set the TIM channel state */
;;;2086     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2087     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2088   
;;;2089     /* Enable the Input Capture channel */
;;;2090     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;2091   
;;;2092     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;2093     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;2094     {
;;;2095       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;2096       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;2097       {
;;;2098         __HAL_TIM_ENABLE(htim);
;;;2099       }
;;;2100     }
;;;2101     else
;;;2102     {
;;;2103       __HAL_TIM_ENABLE(htim);
;;;2104     }
;;;2105   
;;;2106     /* Return function status */
;;;2107     return HAL_OK;
;;;2108   }
000066  bd10              POP      {r4,pc}
                  |L45.104|
000068  2002              MOVS     r0,#2                 ;2086
00006a  b3b9              CBZ      r1,|L45.220|
00006c  2904              CMP      r1,#4                 ;2086
00006e  d03a              BEQ      |L45.230|
000070  2908              CMP      r1,#8                 ;2086
000072  d03b              BEQ      |L45.236|
000074  290c              CMP      r1,#0xc               ;2086
000076  d03c              BEQ      |L45.242|
000078  2910              CMP      r1,#0x10              ;2086
00007a  d03d              BEQ      |L45.248|
00007c  f8840043          STRB     r0,[r4,#0x43]         ;2086
                  |L45.128|
000080  b369              CBZ      r1,|L45.222|
000082  2904              CMP      r1,#4                 ;2087
000084  d03e              BEQ      |L45.260|
000086  2908              CMP      r1,#8                 ;2087
000088  d03f              BEQ      |L45.266|
00008a  f8840047          STRB     r0,[r4,#0x47]         ;2087
                  |L45.142|
00008e  2201              MOVS     r2,#1                 ;2090
000090  6820              LDR      r0,[r4,#0]            ;2090
000092  f7fffffe          BL       TIM_CCxChannelCmd
000096  4921              LDR      r1,|L45.284|
000098  6820              LDR      r0,[r4,#0]            ;2093
00009a  4288              CMP      r0,r1                 ;2093
00009c  d011              BEQ      |L45.194|
00009e  f1b04f80          CMP      r0,#0x40000000        ;2093
0000a2  d00e              BEQ      |L45.194|
0000a4  491e              LDR      r1,|L45.288|
0000a6  4288              CMP      r0,r1                 ;2093
0000a8  d00b              BEQ      |L45.194|
0000aa  491e              LDR      r1,|L45.292|
0000ac  4288              CMP      r0,r1                 ;2093
0000ae  d008              BEQ      |L45.194|
0000b0  491d              LDR      r1,|L45.296|
0000b2  4288              CMP      r0,r1                 ;2093
0000b4  d005              BEQ      |L45.194|
0000b6  491d              LDR      r1,|L45.300|
0000b8  4288              CMP      r0,r1                 ;2093
0000ba  d002              BEQ      |L45.194|
0000bc  491c              LDR      r1,|L45.304|
0000be  4288              CMP      r0,r1                 ;2093
0000c0  d126              BNE      |L45.272|
                  |L45.194|
0000c2  6881              LDR      r1,[r0,#8]            ;2095
0000c4  4a1b              LDR      r2,|L45.308|
0000c6  4011              ANDS     r1,r1,r2              ;2095
0000c8  2906              CMP      r1,#6                 ;2096
0000ca  d025              BEQ      |L45.280|
0000cc  f5b13f80          CMP      r1,#0x10000           ;2096
0000d0  d022              BEQ      |L45.280|
0000d2  6801              LDR      r1,[r0,#0]            ;2098
0000d4  f0410101          ORR      r1,r1,#1              ;2098
0000d8  6001              STR      r1,[r0,#0]            ;2098
0000da  e01d              B        |L45.280|
                  |L45.220|
0000dc  e000              B        |L45.224|
                  |L45.222|
0000de  e00e              B        |L45.254|
                  |L45.224|
0000e0  f884003e          STRB     r0,[r4,#0x3e]         ;2086
0000e4  e7cc              B        |L45.128|
                  |L45.230|
0000e6  f884003f          STRB     r0,[r4,#0x3f]         ;2086
0000ea  e7c9              B        |L45.128|
                  |L45.236|
0000ec  f8840040          STRB     r0,[r4,#0x40]         ;2086
0000f0  e7c6              B        |L45.128|
                  |L45.242|
0000f2  f8840041          STRB     r0,[r4,#0x41]         ;2086
0000f6  e7c3              B        |L45.128|
                  |L45.248|
0000f8  f8840042          STRB     r0,[r4,#0x42]         ;2086
0000fc  e7c0              B        |L45.128|
                  |L45.254|
0000fe  f8840044          STRB     r0,[r4,#0x44]         ;2087
000102  e7c4              B        |L45.142|
                  |L45.260|
000104  f8840045          STRB     r0,[r4,#0x45]         ;2087
000108  e7c1              B        |L45.142|
                  |L45.266|
00010a  f8840046          STRB     r0,[r4,#0x46]         ;2087
00010e  e7be              B        |L45.142|
                  |L45.272|
000110  6801              LDR      r1,[r0,#0]            ;2103
000112  f0410101          ORR      r1,r1,#1              ;2103
000116  6001              STR      r1,[r0,#0]            ;2103
                  |L45.280|
000118  2000              MOVS     r0,#0                 ;2107
00011a  bd10              POP      {r4,pc}
;;;2109   
                          ENDP

                  |L45.284|
                          DCD      0x40012c00
                  |L45.288|
                          DCD      0x40000400
                  |L45.292|
                          DCD      0x40000800
                  |L45.296|
                          DCD      0x40000c00
                  |L45.300|
                          DCD      0x40013400
                  |L45.304|
                          DCD      0x40014000
                  |L45.308|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;2301     */
;;;2302   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2303   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2304     uint32_t tmpsmcr;
;;;2305     HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
00000c  2d00              CMP      r5,#0
00000e  d017              BEQ      |L46.64|
000010  2d04              CMP      r5,#4
000012  d018              BEQ      |L46.70|
000014  2d08              CMP      r5,#8
000016  d019              BEQ      |L46.76|
000018  2d0c              CMP      r5,#0xc
00001a  d01a              BEQ      |L46.82|
00001c  2d10              CMP      r5,#0x10
00001e  d01b              BEQ      |L46.88|
000020  f8940043          LDRB     r0,[r4,#0x43]
                  |L46.36|
;;;2306     HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
000024  b1dd              CBZ      r5,|L46.94|
000026  2d04              CMP      r5,#4
000028  d01c              BEQ      |L46.100|
00002a  2d08              CMP      r5,#8
00002c  d01d              BEQ      |L46.106|
00002e  f8941047          LDRB     r1,[r4,#0x47]
                  |L46.50|
;;;2307   
;;;2308     /* Check the parameters */
;;;2309     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2310     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2311   
;;;2312     /* Set the TIM channel state */
;;;2313     if ((channel_state == HAL_TIM_CHANNEL_STATE_BUSY)
000032  2802              CMP      r0,#2
000034  d01c              BEQ      |L46.112|
;;;2314         || (complementary_channel_state == HAL_TIM_CHANNEL_STATE_BUSY))
000036  2902              CMP      r1,#2
000038  d01a              BEQ      |L46.112|
;;;2315     {
;;;2316       return HAL_BUSY;
;;;2317     }
;;;2318     else if ((channel_state == HAL_TIM_CHANNEL_STATE_READY)
00003a  2801              CMP      r0,#1
00003c  d01b              BEQ      |L46.118|
00003e  e01c              B        |L46.122|
                  |L46.64|
000040  f894003e          LDRB     r0,[r4,#0x3e]         ;2305
000044  e7ee              B        |L46.36|
                  |L46.70|
000046  f894003f          LDRB     r0,[r4,#0x3f]         ;2305
00004a  e7eb              B        |L46.36|
                  |L46.76|
00004c  f8940040          LDRB     r0,[r4,#0x40]         ;2305
000050  e7e8              B        |L46.36|
                  |L46.82|
000052  f8940041          LDRB     r0,[r4,#0x41]         ;2305
000056  e7e5              B        |L46.36|
                  |L46.88|
000058  f8940042          LDRB     r0,[r4,#0x42]         ;2305
00005c  e7e2              B        |L46.36|
                  |L46.94|
00005e  f8941044          LDRB     r1,[r4,#0x44]         ;2306
000062  e7e6              B        |L46.50|
                  |L46.100|
000064  f8941045          LDRB     r1,[r4,#0x45]         ;2306
000068  e7e3              B        |L46.50|
                  |L46.106|
00006a  f8941046          LDRB     r1,[r4,#0x46]         ;2306
00006e  e7e0              B        |L46.50|
                  |L46.112|
000070  2002              MOVS     r0,#2                 ;2316
                  |L46.114|
;;;2319              && (complementary_channel_state == HAL_TIM_CHANNEL_STATE_READY))
;;;2320     {
;;;2321       if ((pData == NULL) && (Length > 0U))
;;;2322       {
;;;2323         return HAL_ERROR;
;;;2324       }
;;;2325       else
;;;2326       {
;;;2327         TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2328         TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2329       }
;;;2330     }
;;;2331     else
;;;2332     {
;;;2333       return HAL_ERROR;
;;;2334     }
;;;2335   
;;;2336     /* Enable the Input Capture channel */
;;;2337     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;2338   
;;;2339     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;2340     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;2341     {
;;;2342       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;2343       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;2344       {
;;;2345         __HAL_TIM_ENABLE(htim);
;;;2346       }
;;;2347     }
;;;2348     else
;;;2349     {
;;;2350       __HAL_TIM_ENABLE(htim);
;;;2351     }
;;;2352   
;;;2353     switch (Channel)
;;;2354     {
;;;2355       case TIM_CHANNEL_1:
;;;2356       {
;;;2357         /* Set the DMA capture callbacks */
;;;2358         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2359         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2360   
;;;2361         /* Set the DMA error callback */
;;;2362         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2363   
;;;2364         /* Enable the DMA channel */
;;;2365         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
;;;2366         {
;;;2367           /* Return error status */
;;;2368           return HAL_ERROR;
;;;2369         }
;;;2370         /* Enable the TIM Capture/Compare 1 DMA request */
;;;2371         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2372         break;
;;;2373       }
;;;2374   
;;;2375       case TIM_CHANNEL_2:
;;;2376       {
;;;2377         /* Set the DMA capture callbacks */
;;;2378         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2379         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2380   
;;;2381         /* Set the DMA error callback */
;;;2382         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2383   
;;;2384         /* Enable the DMA channel */
;;;2385         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
;;;2386         {
;;;2387           /* Return error status */
;;;2388           return HAL_ERROR;
;;;2389         }
;;;2390         /* Enable the TIM Capture/Compare 2  DMA request */
;;;2391         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2392         break;
;;;2393       }
;;;2394   
;;;2395       case TIM_CHANNEL_3:
;;;2396       {
;;;2397         /* Set the DMA capture callbacks */
;;;2398         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2399         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2400   
;;;2401         /* Set the DMA error callback */
;;;2402         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;2403   
;;;2404         /* Enable the DMA channel */
;;;2405         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
;;;2406         {
;;;2407           /* Return error status */
;;;2408           return HAL_ERROR;
;;;2409         }
;;;2410         /* Enable the TIM Capture/Compare 3  DMA request */
;;;2411         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;2412         break;
;;;2413       }
;;;2414   
;;;2415       case TIM_CHANNEL_4:
;;;2416       {
;;;2417         /* Set the DMA capture callbacks */
;;;2418         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2419         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2420   
;;;2421         /* Set the DMA error callback */
;;;2422         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;2423   
;;;2424         /* Enable the DMA channel */
;;;2425         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
;;;2426         {
;;;2427           /* Return error status */
;;;2428           return HAL_ERROR;
;;;2429         }
;;;2430         /* Enable the TIM Capture/Compare 4  DMA request */
;;;2431         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;2432         break;
;;;2433       }
;;;2434   
;;;2435       default:
;;;2436         break;
;;;2437     }
;;;2438   
;;;2439     /* Return function status */
;;;2440     return HAL_OK;
;;;2441   }
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L46.118|
000076  2901              CMP      r1,#1                 ;2319
000078  d001              BEQ      |L46.126|
                  |L46.122|
00007a  2001              MOVS     r0,#1                 ;2333
00007c  e7f9              B        |L46.114|
                  |L46.126|
00007e  b916              CBNZ     r6,|L46.134|
000080  b10f              CBZ      r7,|L46.134|
000082  2001              MOVS     r0,#1                 ;2323
000084  e7f5              B        |L46.114|
                  |L46.134|
000086  2002              MOVS     r0,#2                 ;2305
000088  b18d              CBZ      r5,|L46.174|
00008a  2d04              CMP      r5,#4                 ;2327
00008c  d012              BEQ      |L46.180|
00008e  2d08              CMP      r5,#8                 ;2327
000090  d013              BEQ      |L46.186|
000092  2d0c              CMP      r5,#0xc               ;2327
000094  d014              BEQ      |L46.192|
000096  2d10              CMP      r5,#0x10              ;2327
000098  d015              BEQ      |L46.198|
00009a  f8840043          STRB     r0,[r4,#0x43]         ;2327
                  |L46.158|
00009e  b1ad              CBZ      r5,|L46.204|
0000a0  2d04              CMP      r5,#4                 ;2328
0000a2  d016              BEQ      |L46.210|
0000a4  2d08              CMP      r5,#8                 ;2328
0000a6  d017              BEQ      |L46.216|
0000a8  f8840047          STRB     r0,[r4,#0x47]         ;2328
0000ac  e016              B        |L46.220|
                  |L46.174|
0000ae  f884003e          STRB     r0,[r4,#0x3e]         ;2327
0000b2  e7f4              B        |L46.158|
                  |L46.180|
0000b4  f884003f          STRB     r0,[r4,#0x3f]         ;2327
0000b8  e7f1              B        |L46.158|
                  |L46.186|
0000ba  f8840040          STRB     r0,[r4,#0x40]         ;2327
0000be  e7ee              B        |L46.158|
                  |L46.192|
0000c0  f8840041          STRB     r0,[r4,#0x41]         ;2327
0000c4  e7eb              B        |L46.158|
                  |L46.198|
0000c6  f8840042          STRB     r0,[r4,#0x42]         ;2327
0000ca  e7e8              B        |L46.158|
                  |L46.204|
0000cc  f8840044          STRB     r0,[r4,#0x44]         ;2328
0000d0  e004              B        |L46.220|
                  |L46.210|
0000d2  f8840045          STRB     r0,[r4,#0x45]         ;2328
0000d6  e001              B        |L46.220|
                  |L46.216|
0000d8  f8840046          STRB     r0,[r4,#0x46]         ;2328
                  |L46.220|
0000dc  2201              MOVS     r2,#1                 ;2337
0000de  4629              MOV      r1,r5                 ;2337
0000e0  6820              LDR      r0,[r4,#0]            ;2337
0000e2  f7fffffe          BL       TIM_CCxChannelCmd
0000e6  4945              LDR      r1,|L46.508|
0000e8  6820              LDR      r0,[r4,#0]            ;2340
0000ea  4288              CMP      r0,r1                 ;2340
0000ec  d011              BEQ      |L46.274|
0000ee  f1b04f80          CMP      r0,#0x40000000        ;2340
0000f2  d00e              BEQ      |L46.274|
0000f4  4942              LDR      r1,|L46.512|
0000f6  4288              CMP      r0,r1                 ;2340
0000f8  d00b              BEQ      |L46.274|
0000fa  4942              LDR      r1,|L46.516|
0000fc  4288              CMP      r0,r1                 ;2340
0000fe  d008              BEQ      |L46.274|
000100  4941              LDR      r1,|L46.520|
000102  4288              CMP      r0,r1                 ;2340
000104  d005              BEQ      |L46.274|
000106  4941              LDR      r1,|L46.524|
000108  4288              CMP      r0,r1                 ;2340
00010a  d002              BEQ      |L46.274|
00010c  4940              LDR      r1,|L46.528|
00010e  4288              CMP      r0,r1                 ;2340
000110  d10c              BNE      |L46.300|
                  |L46.274|
000112  6881              LDR      r1,[r0,#8]            ;2342
000114  4a3f              LDR      r2,|L46.532|
000116  4011              ANDS     r1,r1,r2              ;2342
000118  2906              CMP      r1,#6                 ;2343
00011a  d00b              BEQ      |L46.308|
00011c  f5b13f80          CMP      r1,#0x10000           ;2343
000120  d008              BEQ      |L46.308|
000122  6801              LDR      r1,[r0,#0]            ;2345
000124  f0410101          ORR      r1,r1,#1              ;2345
000128  6001              STR      r1,[r0,#0]            ;2345
00012a  e003              B        |L46.308|
                  |L46.300|
00012c  6801              LDR      r1,[r0,#0]            ;2350
00012e  f0410101          ORR      r1,r1,#1              ;2350
000132  6001              STR      r1,[r0,#0]            ;2350
                  |L46.308|
000134  4838              LDR      r0,|L46.536|
000136  4939              LDR      r1,|L46.540|
000138  4a39              LDR      r2,|L46.544|
00013a  b135              CBZ      r5,|L46.330|
00013c  2d04              CMP      r5,#4                 ;2353
00013e  d01a              BEQ      |L46.374|
000140  2d08              CMP      r5,#8                 ;2353
000142  d02e              BEQ      |L46.418|
000144  2d0c              CMP      r5,#0xc               ;2353
000146  d157              BNE      |L46.504|
000148  e041              B        |L46.462|
                  |L46.330|
00014a  6a63              LDR      r3,[r4,#0x24]         ;2358
00014c  62d8              STR      r0,[r3,#0x2c]         ;2358
00014e  6a60              LDR      r0,[r4,#0x24]         ;2359
000150  6301              STR      r1,[r0,#0x30]         ;2359
000152  6a60              LDR      r0,[r4,#0x24]         ;2362
000154  6342              STR      r2,[r0,#0x34]         ;2362
000156  6821              LDR      r1,[r4,#0]            ;2365
000158  463b              MOV      r3,r7                 ;2365
00015a  3134              ADDS     r1,r1,#0x34           ;2365
00015c  4632              MOV      r2,r6                 ;2365
00015e  6a60              LDR      r0,[r4,#0x24]         ;2365
000160  f7fffffe          BL       HAL_DMA_Start_IT
000164  b108              CBZ      r0,|L46.362|
000166  2001              MOVS     r0,#1                 ;2368
000168  e783              B        |L46.114|
                  |L46.362|
00016a  6820              LDR      r0,[r4,#0]            ;2371
00016c  68c1              LDR      r1,[r0,#0xc]          ;2371
00016e  f4417100          ORR      r1,r1,#0x200          ;2371
000172  60c1              STR      r1,[r0,#0xc]          ;2371
000174  e040              B        |L46.504|
                  |L46.374|
000176  6aa3              LDR      r3,[r4,#0x28]         ;2378
000178  62d8              STR      r0,[r3,#0x2c]         ;2378
00017a  6aa0              LDR      r0,[r4,#0x28]         ;2379
00017c  6301              STR      r1,[r0,#0x30]         ;2379
00017e  6aa0              LDR      r0,[r4,#0x28]         ;2382
000180  6342              STR      r2,[r0,#0x34]         ;2382
000182  6821              LDR      r1,[r4,#0]            ;2385
000184  463b              MOV      r3,r7                 ;2385
000186  3138              ADDS     r1,r1,#0x38           ;2385
000188  4632              MOV      r2,r6                 ;2385
00018a  6aa0              LDR      r0,[r4,#0x28]         ;2385
00018c  f7fffffe          BL       HAL_DMA_Start_IT
000190  b108              CBZ      r0,|L46.406|
000192  2001              MOVS     r0,#1                 ;2388
000194  e76d              B        |L46.114|
                  |L46.406|
000196  6820              LDR      r0,[r4,#0]            ;2391
000198  68c1              LDR      r1,[r0,#0xc]          ;2391
00019a  f4416180          ORR      r1,r1,#0x400          ;2391
00019e  60c1              STR      r1,[r0,#0xc]          ;2391
0001a0  e02a              B        |L46.504|
                  |L46.418|
0001a2  6ae3              LDR      r3,[r4,#0x2c]         ;2398
0001a4  62d8              STR      r0,[r3,#0x2c]         ;2398
0001a6  6ae0              LDR      r0,[r4,#0x2c]         ;2399
0001a8  6301              STR      r1,[r0,#0x30]         ;2399
0001aa  6ae0              LDR      r0,[r4,#0x2c]         ;2402
0001ac  6342              STR      r2,[r0,#0x34]         ;2402
0001ae  6821              LDR      r1,[r4,#0]            ;2405
0001b0  463b              MOV      r3,r7                 ;2405
0001b2  313c              ADDS     r1,r1,#0x3c           ;2405
0001b4  4632              MOV      r2,r6                 ;2405
0001b6  6ae0              LDR      r0,[r4,#0x2c]         ;2405
0001b8  f7fffffe          BL       HAL_DMA_Start_IT
0001bc  b108              CBZ      r0,|L46.450|
0001be  2001              MOVS     r0,#1                 ;2408
0001c0  e757              B        |L46.114|
                  |L46.450|
0001c2  6820              LDR      r0,[r4,#0]            ;2411
0001c4  68c1              LDR      r1,[r0,#0xc]          ;2411
0001c6  f4416100          ORR      r1,r1,#0x800          ;2411
0001ca  60c1              STR      r1,[r0,#0xc]          ;2411
0001cc  e014              B        |L46.504|
                  |L46.462|
0001ce  6b23              LDR      r3,[r4,#0x30]         ;2418
0001d0  62d8              STR      r0,[r3,#0x2c]         ;2418
0001d2  6b20              LDR      r0,[r4,#0x30]         ;2419
0001d4  6301              STR      r1,[r0,#0x30]         ;2419
0001d6  6b20              LDR      r0,[r4,#0x30]         ;2422
0001d8  6342              STR      r2,[r0,#0x34]         ;2422
0001da  6821              LDR      r1,[r4,#0]            ;2425
0001dc  463b              MOV      r3,r7                 ;2425
0001de  3140              ADDS     r1,r1,#0x40           ;2425
0001e0  4632              MOV      r2,r6                 ;2425
0001e2  6b20              LDR      r0,[r4,#0x30]         ;2425
0001e4  f7fffffe          BL       HAL_DMA_Start_IT
0001e8  b108              CBZ      r0,|L46.494|
0001ea  2001              MOVS     r0,#1                 ;2428
0001ec  e741              B        |L46.114|
                  |L46.494|
0001ee  6820              LDR      r0,[r4,#0]            ;2431
0001f0  68c1              LDR      r1,[r0,#0xc]          ;2431
0001f2  f4415180          ORR      r1,r1,#0x1000         ;2431
0001f6  60c1              STR      r1,[r0,#0xc]          ;2431
                  |L46.504|
0001f8  2000              MOVS     r0,#0                 ;2440
0001fa  e73a              B        |L46.114|
;;;2442   
                          ENDP

                  |L46.508|
                          DCD      0x40012c00
                  |L46.512|
                          DCD      0x40000400
                  |L46.516|
                          DCD      0x40000800
                  |L46.520|
                          DCD      0x40000c00
                  |L46.524|
                          DCD      0x40013400
                  |L46.528|
                          DCD      0x40014000
                  |L46.532|
                          DCD      0x00010007
                  |L46.536|
                          DCD      TIM_DMACaptureCplt
                  |L46.540|
                          DCD      TIM_DMACaptureHalfCplt
                  |L46.544|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_IT PROC
;;;2150     */
;;;2151   HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2152   {
000002  4604              MOV      r4,r0
;;;2153     uint32_t tmpsmcr;
;;;2154     HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
000004  2900              CMP      r1,#0
000006  d013              BEQ      |L47.48|
000008  2904              CMP      r1,#4
00000a  d014              BEQ      |L47.54|
00000c  2908              CMP      r1,#8
00000e  d015              BEQ      |L47.60|
000010  290c              CMP      r1,#0xc
000012  d016              BEQ      |L47.66|
000014  2910              CMP      r1,#0x10
000016  d017              BEQ      |L47.72|
000018  f8940043          LDRB     r0,[r4,#0x43]
                  |L47.28|
;;;2155     HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
00001c  b1b9              CBZ      r1,|L47.78|
00001e  2904              CMP      r1,#4
000020  d018              BEQ      |L47.84|
000022  2908              CMP      r1,#8
000024  d019              BEQ      |L47.90|
000026  f8942047          LDRB     r2,[r4,#0x47]
                  |L47.42|
;;;2156   
;;;2157     /* Check the parameters */
;;;2158     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2159   
;;;2160     /* Check the TIM channel state */
;;;2161     if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
00002a  2801              CMP      r0,#1
00002c  d11a              BNE      |L47.100|
00002e  e017              B        |L47.96|
                  |L47.48|
000030  f894003e          LDRB     r0,[r4,#0x3e]         ;2154
000034  e7f2              B        |L47.28|
                  |L47.54|
000036  f894003f          LDRB     r0,[r4,#0x3f]         ;2154
00003a  e7ef              B        |L47.28|
                  |L47.60|
00003c  f8940040          LDRB     r0,[r4,#0x40]         ;2154
000040  e7ec              B        |L47.28|
                  |L47.66|
000042  f8940041          LDRB     r0,[r4,#0x41]         ;2154
000046  e7e9              B        |L47.28|
                  |L47.72|
000048  f8940042          LDRB     r0,[r4,#0x42]         ;2154
00004c  e7e6              B        |L47.28|
                  |L47.78|
00004e  f8942044          LDRB     r2,[r4,#0x44]         ;2155
000052  e7ea              B        |L47.42|
                  |L47.84|
000054  f8942045          LDRB     r2,[r4,#0x45]         ;2155
000058  e7e7              B        |L47.42|
                  |L47.90|
00005a  f8942046          LDRB     r2,[r4,#0x46]         ;2155
00005e  e7e4              B        |L47.42|
                  |L47.96|
;;;2162         || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
000060  2a01              CMP      r2,#1
000062  d001              BEQ      |L47.104|
                  |L47.100|
;;;2163     {
;;;2164       return HAL_ERROR;
000064  2001              MOVS     r0,#1
;;;2165     }
;;;2166   
;;;2167     /* Set the TIM channel state */
;;;2168     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2169     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2170   
;;;2171     switch (Channel)
;;;2172     {
;;;2173       case TIM_CHANNEL_1:
;;;2174       {
;;;2175         /* Enable the TIM Capture/Compare 1 interrupt */
;;;2176         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2177         break;
;;;2178       }
;;;2179   
;;;2180       case TIM_CHANNEL_2:
;;;2181       {
;;;2182         /* Enable the TIM Capture/Compare 2 interrupt */
;;;2183         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2184         break;
;;;2185       }
;;;2186   
;;;2187       case TIM_CHANNEL_3:
;;;2188       {
;;;2189         /* Enable the TIM Capture/Compare 3 interrupt */
;;;2190         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;2191         break;
;;;2192       }
;;;2193   
;;;2194       case TIM_CHANNEL_4:
;;;2195       {
;;;2196         /* Enable the TIM Capture/Compare 4 interrupt */
;;;2197         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;2198         break;
;;;2199       }
;;;2200   
;;;2201       default:
;;;2202         break;
;;;2203     }
;;;2204     /* Enable the Input Capture channel */
;;;2205     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;2206   
;;;2207     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;2208     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;2209     {
;;;2210       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;2211       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;2212       {
;;;2213         __HAL_TIM_ENABLE(htim);
;;;2214       }
;;;2215     }
;;;2216     else
;;;2217     {
;;;2218       __HAL_TIM_ENABLE(htim);
;;;2219     }
;;;2220   
;;;2221     /* Return function status */
;;;2222     return HAL_OK;
;;;2223   }
000066  bd10              POP      {r4,pc}
                  |L47.104|
000068  2002              MOVS     r0,#2                 ;2168
00006a  b1c1              CBZ      r1,|L47.158|
00006c  2904              CMP      r1,#4                 ;2168
00006e  d019              BEQ      |L47.164|
000070  2908              CMP      r1,#8                 ;2168
000072  d01a              BEQ      |L47.170|
000074  290c              CMP      r1,#0xc               ;2168
000076  d01b              BEQ      |L47.176|
000078  2910              CMP      r1,#0x10              ;2168
00007a  d01c              BEQ      |L47.182|
00007c  f8840043          STRB     r0,[r4,#0x43]         ;2168
                  |L47.128|
000080  b1e1              CBZ      r1,|L47.188|
000082  2904              CMP      r1,#4                 ;2169
000084  d01d              BEQ      |L47.194|
000086  2908              CMP      r1,#8                 ;2169
000088  d01e              BEQ      |L47.200|
00008a  f8840047          STRB     r0,[r4,#0x47]         ;2169
                  |L47.142|
00008e  b1f1              CBZ      r1,|L47.206|
000090  2904              CMP      r1,#4                 ;2171
000092  d022              BEQ      |L47.218|
000094  2908              CMP      r1,#8                 ;2171
000096  d026              BEQ      |L47.230|
000098  290c              CMP      r1,#0xc               ;2171
00009a  d12f              BNE      |L47.252|
00009c  e029              B        |L47.242|
                  |L47.158|
00009e  f884003e          STRB     r0,[r4,#0x3e]         ;2168
0000a2  e7ed              B        |L47.128|
                  |L47.164|
0000a4  f884003f          STRB     r0,[r4,#0x3f]         ;2168
0000a8  e7ea              B        |L47.128|
                  |L47.170|
0000aa  f8840040          STRB     r0,[r4,#0x40]         ;2168
0000ae  e7e7              B        |L47.128|
                  |L47.176|
0000b0  f8840041          STRB     r0,[r4,#0x41]         ;2168
0000b4  e7e4              B        |L47.128|
                  |L47.182|
0000b6  f8840042          STRB     r0,[r4,#0x42]         ;2168
0000ba  e7e1              B        |L47.128|
                  |L47.188|
0000bc  f8840044          STRB     r0,[r4,#0x44]         ;2169
0000c0  e7e5              B        |L47.142|
                  |L47.194|
0000c2  f8840045          STRB     r0,[r4,#0x45]         ;2169
0000c6  e7e2              B        |L47.142|
                  |L47.200|
0000c8  f8840046          STRB     r0,[r4,#0x46]         ;2169
0000cc  e7df              B        |L47.142|
                  |L47.206|
0000ce  6820              LDR      r0,[r4,#0]            ;2176
0000d0  68c2              LDR      r2,[r0,#0xc]          ;2176
0000d2  f0420202          ORR      r2,r2,#2              ;2176
0000d6  60c2              STR      r2,[r0,#0xc]          ;2176
0000d8  e010              B        |L47.252|
                  |L47.218|
0000da  6820              LDR      r0,[r4,#0]            ;2183
0000dc  68c2              LDR      r2,[r0,#0xc]          ;2183
0000de  f0420204          ORR      r2,r2,#4              ;2183
0000e2  60c2              STR      r2,[r0,#0xc]          ;2183
0000e4  e00a              B        |L47.252|
                  |L47.230|
0000e6  6820              LDR      r0,[r4,#0]            ;2190
0000e8  68c2              LDR      r2,[r0,#0xc]          ;2190
0000ea  f0420208          ORR      r2,r2,#8              ;2190
0000ee  60c2              STR      r2,[r0,#0xc]          ;2190
0000f0  e004              B        |L47.252|
                  |L47.242|
0000f2  6820              LDR      r0,[r4,#0]            ;2197
0000f4  68c2              LDR      r2,[r0,#0xc]          ;2197
0000f6  f0420210          ORR      r2,r2,#0x10           ;2197
0000fa  60c2              STR      r2,[r0,#0xc]          ;2197
                  |L47.252|
0000fc  2201              MOVS     r2,#1                 ;2205
0000fe  6820              LDR      r0,[r4,#0]            ;2205
000100  f7fffffe          BL       TIM_CCxChannelCmd
000104  4914              LDR      r1,|L47.344|
000106  6820              LDR      r0,[r4,#0]            ;2208
000108  4288              CMP      r0,r1                 ;2208
00010a  d011              BEQ      |L47.304|
00010c  f1b04f80          CMP      r0,#0x40000000        ;2208
000110  d00e              BEQ      |L47.304|
000112  4912              LDR      r1,|L47.348|
000114  4288              CMP      r0,r1                 ;2208
000116  d00b              BEQ      |L47.304|
000118  4911              LDR      r1,|L47.352|
00011a  4288              CMP      r0,r1                 ;2208
00011c  d008              BEQ      |L47.304|
00011e  4911              LDR      r1,|L47.356|
000120  4288              CMP      r0,r1                 ;2208
000122  d005              BEQ      |L47.304|
000124  4910              LDR      r1,|L47.360|
000126  4288              CMP      r0,r1                 ;2208
000128  d002              BEQ      |L47.304|
00012a  4910              LDR      r1,|L47.364|
00012c  4288              CMP      r0,r1                 ;2208
00012e  d10c              BNE      |L47.330|
                  |L47.304|
000130  6881              LDR      r1,[r0,#8]            ;2210
000132  4a0f              LDR      r2,|L47.368|
000134  4011              ANDS     r1,r1,r2              ;2210
000136  2906              CMP      r1,#6                 ;2211
000138  d00b              BEQ      |L47.338|
00013a  f5b13f80          CMP      r1,#0x10000           ;2211
00013e  d008              BEQ      |L47.338|
000140  6801              LDR      r1,[r0,#0]            ;2213
000142  f0410101          ORR      r1,r1,#1              ;2213
000146  6001              STR      r1,[r0,#0]            ;2213
000148  e003              B        |L47.338|
                  |L47.330|
00014a  6801              LDR      r1,[r0,#0]            ;2218
00014c  f0410101          ORR      r1,r1,#1              ;2218
000150  6001              STR      r1,[r0,#0]            ;2218
                  |L47.338|
000152  2000              MOVS     r0,#0                 ;2222
000154  bd10              POP      {r4,pc}
;;;2224   
                          ENDP

000156  0000              DCW      0x0000
                  |L47.344|
                          DCD      0x40012c00
                  |L47.348|
                          DCD      0x40000400
                  |L47.352|
                          DCD      0x40000800
                  |L47.356|
                          DCD      0x40000c00
                  |L47.360|
                          DCD      0x40013400
                  |L47.364|
                          DCD      0x40014000
                  |L47.368|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;2120     */
;;;2121   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2122   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2123     /* Check the parameters */
;;;2124     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2125   
;;;2126     /* Disable the Input Capture channel */
;;;2127     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2128   
;;;2129     /* Disable the Peripheral */
;;;2130     __HAL_TIM_DISABLE(htim);
000010  6820              LDR      r0,[r4,#0]
000012  6a01              LDR      r1,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4211              TST      r1,r2
00001a  d107              BNE      |L48.44|
00001c  6a01              LDR      r1,[r0,#0x20]
00001e  1092              ASRS     r2,r2,#2
000020  4211              TST      r1,r2
000022  d103              BNE      |L48.44|
000024  6801              LDR      r1,[r0,#0]
000026  f0210101          BIC      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L48.44|
;;;2131   
;;;2132     /* Set the TIM channel state */
;;;2133     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
00002c  2001              MOVS     r0,#1
00002e  b195              CBZ      r5,|L48.86|
000030  2d04              CMP      r5,#4
000032  d013              BEQ      |L48.92|
000034  2d08              CMP      r5,#8
000036  d014              BEQ      |L48.98|
000038  2d0c              CMP      r5,#0xc
00003a  d015              BEQ      |L48.104|
00003c  2d10              CMP      r5,#0x10
00003e  d016              BEQ      |L48.110|
000040  f8840043          STRB     r0,[r4,#0x43]
                  |L48.68|
;;;2134     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000044  b1b5              CBZ      r5,|L48.116|
000046  2d04              CMP      r5,#4
000048  d017              BEQ      |L48.122|
00004a  2d08              CMP      r5,#8
00004c  d018              BEQ      |L48.128|
00004e  f8840047          STRB     r0,[r4,#0x47]
                  |L48.82|
;;;2135   
;;;2136     /* Return function status */
;;;2137     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;2138   }
000054  bd30              POP      {r4,r5,pc}
                  |L48.86|
000056  f884003e          STRB     r0,[r4,#0x3e]         ;2133
00005a  e7f3              B        |L48.68|
                  |L48.92|
00005c  f884003f          STRB     r0,[r4,#0x3f]         ;2133
000060  e7f0              B        |L48.68|
                  |L48.98|
000062  f8840040          STRB     r0,[r4,#0x40]         ;2133
000066  e7ed              B        |L48.68|
                  |L48.104|
000068  f8840041          STRB     r0,[r4,#0x41]         ;2133
00006c  e7ea              B        |L48.68|
                  |L48.110|
00006e  f8840042          STRB     r0,[r4,#0x42]         ;2133
000072  e7e7              B        |L48.68|
                  |L48.116|
000074  f8840044          STRB     r0,[r4,#0x44]         ;2134
000078  e7eb              B        |L48.82|
                  |L48.122|
00007a  f8840045          STRB     r0,[r4,#0x45]         ;2134
00007e  e7e8              B        |L48.82|
                  |L48.128|
000080  f8840046          STRB     r0,[r4,#0x46]         ;2134
000084  e7e5              B        |L48.82|
;;;2139   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;2453     */
;;;2454   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2455   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2456     /* Check the parameters */
;;;2457     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2458     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2459   
;;;2460     /* Disable the Input Capture channel */
;;;2461     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2462   
;;;2463     switch (Channel)
000010  b135              CBZ      r5,|L49.32|
000012  2d04              CMP      r5,#4
000014  d00d              BEQ      |L49.50|
000016  2d08              CMP      r5,#8
000018  d014              BEQ      |L49.68|
00001a  2d0c              CMP      r5,#0xc
00001c  d123              BNE      |L49.102|
00001e  e01a              B        |L49.86|
                  |L49.32|
;;;2464     {
;;;2465       case TIM_CHANNEL_1:
;;;2466       {
;;;2467         /* Disable the TIM Capture/Compare 1 DMA request */
;;;2468         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f4217100          BIC      r1,r1,#0x200
000028  60c1              STR      r1,[r0,#0xc]
;;;2469         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00002a  6a60              LDR      r0,[r4,#0x24]
00002c  f7fffffe          BL       HAL_DMA_Abort_IT
;;;2470         break;
000030  e019              B        |L49.102|
                  |L49.50|
;;;2471       }
;;;2472   
;;;2473       case TIM_CHANNEL_2:
;;;2474       {
;;;2475         /* Disable the TIM Capture/Compare 2 DMA request */
;;;2476         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000032  6820              LDR      r0,[r4,#0]
000034  68c1              LDR      r1,[r0,#0xc]
000036  f4216180          BIC      r1,r1,#0x400
00003a  60c1              STR      r1,[r0,#0xc]
;;;2477         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  f7fffffe          BL       HAL_DMA_Abort_IT
;;;2478         break;
000042  e010              B        |L49.102|
                  |L49.68|
;;;2479       }
;;;2480   
;;;2481       case TIM_CHANNEL_3:
;;;2482       {
;;;2483         /* Disable the TIM Capture/Compare 3  DMA request */
;;;2484         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000044  6820              LDR      r0,[r4,#0]
000046  68c1              LDR      r1,[r0,#0xc]
000048  f4216100          BIC      r1,r1,#0x800
00004c  60c1              STR      r1,[r0,#0xc]
;;;2485         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       HAL_DMA_Abort_IT
;;;2486         break;
000054  e007              B        |L49.102|
                  |L49.86|
;;;2487       }
;;;2488   
;;;2489       case TIM_CHANNEL_4:
;;;2490       {
;;;2491         /* Disable the TIM Capture/Compare 4  DMA request */
;;;2492         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000056  6820              LDR      r0,[r4,#0]
000058  68c1              LDR      r1,[r0,#0xc]
00005a  f4215180          BIC      r1,r1,#0x1000
00005e  60c1              STR      r1,[r0,#0xc]
;;;2493         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
000060  6b20              LDR      r0,[r4,#0x30]
000062  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L49.102|
;;;2494         break;
;;;2495       }
;;;2496   
;;;2497       default:
;;;2498         break;
;;;2499     }
;;;2500   
;;;2501     /* Disable the Peripheral */
;;;2502     __HAL_TIM_DISABLE(htim);
000066  6820              LDR      r0,[r4,#0]
000068  6a01              LDR      r1,[r0,#0x20]
00006a  f2411211          MOV      r2,#0x1111
00006e  4211              TST      r1,r2
000070  d107              BNE      |L49.130|
000072  6a01              LDR      r1,[r0,#0x20]
000074  1092              ASRS     r2,r2,#2
000076  4211              TST      r1,r2
000078  d103              BNE      |L49.130|
00007a  6801              LDR      r1,[r0,#0]
00007c  f0210101          BIC      r1,r1,#1
000080  6001              STR      r1,[r0,#0]
                  |L49.130|
;;;2503   
;;;2504     /* Set the TIM channel state */
;;;2505     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000082  2001              MOVS     r0,#1
000084  b195              CBZ      r5,|L49.172|
000086  2d04              CMP      r5,#4
000088  d013              BEQ      |L49.178|
00008a  2d08              CMP      r5,#8
00008c  d014              BEQ      |L49.184|
00008e  2d0c              CMP      r5,#0xc
000090  d015              BEQ      |L49.190|
000092  2d10              CMP      r5,#0x10
000094  d016              BEQ      |L49.196|
000096  f8840043          STRB     r0,[r4,#0x43]
                  |L49.154|
;;;2506     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
00009a  b1b5              CBZ      r5,|L49.202|
00009c  2d04              CMP      r5,#4
00009e  d017              BEQ      |L49.208|
0000a0  2d08              CMP      r5,#8
0000a2  d018              BEQ      |L49.214|
0000a4  f8840047          STRB     r0,[r4,#0x47]
                  |L49.168|
;;;2507   
;;;2508     /* Return function status */
;;;2509     return HAL_OK;
0000a8  2000              MOVS     r0,#0
;;;2510   }
0000aa  bd70              POP      {r4-r6,pc}
                  |L49.172|
0000ac  f884003e          STRB     r0,[r4,#0x3e]         ;2505
0000b0  e7f3              B        |L49.154|
                  |L49.178|
0000b2  f884003f          STRB     r0,[r4,#0x3f]         ;2505
0000b6  e7f0              B        |L49.154|
                  |L49.184|
0000b8  f8840040          STRB     r0,[r4,#0x40]         ;2505
0000bc  e7ed              B        |L49.154|
                  |L49.190|
0000be  f8840041          STRB     r0,[r4,#0x41]         ;2505
0000c2  e7ea              B        |L49.154|
                  |L49.196|
0000c4  f8840042          STRB     r0,[r4,#0x42]         ;2505
0000c8  e7e7              B        |L49.154|
                  |L49.202|
0000ca  f8840044          STRB     r0,[r4,#0x44]         ;2506
0000ce  e7eb              B        |L49.168|
                  |L49.208|
0000d0  f8840045          STRB     r0,[r4,#0x45]         ;2506
0000d4  e7e8              B        |L49.168|
                  |L49.214|
0000d6  f8840046          STRB     r0,[r4,#0x46]         ;2506
0000da  e7e5              B        |L49.168|
;;;2511   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;2235     */
;;;2236   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2237   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2238     /* Check the parameters */
;;;2239     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2240   
;;;2241     switch (Channel)
;;;2242     {
;;;2243       case TIM_CHANNEL_1:
;;;2244       {
;;;2245         /* Disable the TIM Capture/Compare 1 interrupt */
;;;2246         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;2241
00000a  d006              BEQ      |L50.26|
00000c  2d04              CMP      r5,#4                 ;2241
00000e  d009              BEQ      |L50.36|
000010  2d08              CMP      r5,#8                 ;2241
000012  d00c              BEQ      |L50.46|
000014  2d0c              CMP      r5,#0xc               ;2241
000016  d113              BNE      |L50.64|
000018  e00e              B        |L50.56|
                  |L50.26|
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  f0210102          BIC      r1,r1,#2
000020  60c1              STR      r1,[r0,#0xc]
;;;2247         break;
000022  e00d              B        |L50.64|
                  |L50.36|
;;;2248       }
;;;2249   
;;;2250       case TIM_CHANNEL_2:
;;;2251       {
;;;2252         /* Disable the TIM Capture/Compare 2 interrupt */
;;;2253         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  68c1              LDR      r1,[r0,#0xc]
000026  f0210104          BIC      r1,r1,#4
00002a  60c1              STR      r1,[r0,#0xc]
;;;2254         break;
00002c  e008              B        |L50.64|
                  |L50.46|
;;;2255       }
;;;2256   
;;;2257       case TIM_CHANNEL_3:
;;;2258       {
;;;2259         /* Disable the TIM Capture/Compare 3 interrupt */
;;;2260         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002e  68c1              LDR      r1,[r0,#0xc]
000030  f0210108          BIC      r1,r1,#8
000034  60c1              STR      r1,[r0,#0xc]
;;;2261         break;
000036  e003              B        |L50.64|
                  |L50.56|
;;;2262       }
;;;2263   
;;;2264       case TIM_CHANNEL_4:
;;;2265       {
;;;2266         /* Disable the TIM Capture/Compare 4 interrupt */
;;;2267         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000038  68c1              LDR      r1,[r0,#0xc]
00003a  f0210110          BIC      r1,r1,#0x10
00003e  60c1              STR      r1,[r0,#0xc]
                  |L50.64|
;;;2268         break;
;;;2269       }
;;;2270   
;;;2271       default:
;;;2272         break;
;;;2273     }
;;;2274   
;;;2275     /* Disable the Input Capture channel */
;;;2276     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000040  2200              MOVS     r2,#0
000042  4629              MOV      r1,r5
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       TIM_CCxChannelCmd
;;;2277   
;;;2278     /* Disable the Peripheral */
;;;2279     __HAL_TIM_DISABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6a01              LDR      r1,[r0,#0x20]
00004e  f2411211          MOV      r2,#0x1111
000052  4211              TST      r1,r2
000054  d107              BNE      |L50.102|
000056  6a01              LDR      r1,[r0,#0x20]
000058  1092              ASRS     r2,r2,#2
00005a  4211              TST      r1,r2
00005c  d103              BNE      |L50.102|
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
                  |L50.102|
;;;2280   
;;;2281     /* Set the TIM channel state */
;;;2282     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000066  2001              MOVS     r0,#1
000068  b195              CBZ      r5,|L50.144|
00006a  2d04              CMP      r5,#4
00006c  d013              BEQ      |L50.150|
00006e  2d08              CMP      r5,#8
000070  d014              BEQ      |L50.156|
000072  2d0c              CMP      r5,#0xc
000074  d015              BEQ      |L50.162|
000076  2d10              CMP      r5,#0x10
000078  d016              BEQ      |L50.168|
00007a  f8840043          STRB     r0,[r4,#0x43]
                  |L50.126|
;;;2283     TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
00007e  b1b5              CBZ      r5,|L50.174|
000080  2d04              CMP      r5,#4
000082  d017              BEQ      |L50.180|
000084  2d08              CMP      r5,#8
000086  d018              BEQ      |L50.186|
000088  f8840047          STRB     r0,[r4,#0x47]
                  |L50.140|
;;;2284   
;;;2285     /* Return function status */
;;;2286     return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;2287   }
00008e  bd30              POP      {r4,r5,pc}
                  |L50.144|
000090  f884003e          STRB     r0,[r4,#0x3e]         ;2282
000094  e7f3              B        |L50.126|
                  |L50.150|
000096  f884003f          STRB     r0,[r4,#0x3f]         ;2282
00009a  e7f0              B        |L50.126|
                  |L50.156|
00009c  f8840040          STRB     r0,[r4,#0x40]         ;2282
0000a0  e7ed              B        |L50.126|
                  |L50.162|
0000a2  f8840041          STRB     r0,[r4,#0x41]         ;2282
0000a6  e7ea              B        |L50.126|
                  |L50.168|
0000a8  f8840042          STRB     r0,[r4,#0x42]         ;2282
0000ac  e7e7              B        |L50.126|
                  |L50.174|
0000ae  f8840044          STRB     r0,[r4,#0x44]         ;2283
0000b2  e7eb              B        |L50.140|
                  |L50.180|
0000b4  f8840045          STRB     r0,[r4,#0x45]         ;2283
0000b8  e7e8              B        |L50.140|
                  |L50.186|
0000ba  f8840046          STRB     r0,[r4,#0x46]         ;2283
0000be  e7e5              B        |L50.140|
;;;2288   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;3740     */
;;;3741   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;3742   {
000002  4604              MOV      r4,r0
;;;3743     /* Capture compare 1 event */
;;;3744     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  f04f0500          MOV      r5,#0
00000c  43c9              MVNS     r1,r1
00000e  0789              LSLS     r1,r1,#30
000010  d416              BMI      |L51.64|
;;;3745     {
;;;3746       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
000012  68c1              LDR      r1,[r0,#0xc]
000014  43c9              MVNS     r1,r1
000016  0789              LSLS     r1,r1,#30
000018  d412              BMI      |L51.64|
;;;3747       {
;;;3748         {
;;;3749           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  1ee9              SUBS     r1,r5,#3
00001c  6101              STR      r1,[r0,#0x10]
;;;3750           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00001e  2001              MOVS     r0,#1
000020  7720              STRB     r0,[r4,#0x1c]
;;;3751   
;;;3752           /* Input capture event */
;;;3753           if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000022  6820              LDR      r0,[r4,#0]
000024  6980              LDR      r0,[r0,#0x18]
000026  0780              LSLS     r0,r0,#30
000028  d003              BEQ      |L51.50|
;;;3754           {
;;;3755   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3756             htim->IC_CaptureCallback(htim);
;;;3757   #else
;;;3758             HAL_TIM_IC_CaptureCallback(htim);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000030  e005              B        |L51.62|
                  |L51.50|
;;;3759   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3760           }
;;;3761           /* Output compare event */
;;;3762           else
;;;3763           {
;;;3764   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3765             htim->OC_DelayElapsedCallback(htim);
;;;3766             htim->PWM_PulseFinishedCallback(htim);
;;;3767   #else
;;;3768             HAL_TIM_OC_DelayElapsedCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3769             HAL_TIM_PWM_PulseFinishedCallback(htim);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L51.62|
;;;3770   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3771           }
;;;3772           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003e  7725              STRB     r5,[r4,#0x1c]
                  |L51.64|
;;;3773         }
;;;3774       }
;;;3775     }
;;;3776     /* Capture compare 2 event */
;;;3777     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000040  6820              LDR      r0,[r4,#0]
000042  6901              LDR      r1,[r0,#0x10]
000044  43c9              MVNS     r1,r1
000046  0749              LSLS     r1,r1,#29
000048  d418              BMI      |L51.124|
;;;3778     {
;;;3779       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
00004a  68c1              LDR      r1,[r0,#0xc]
00004c  43c9              MVNS     r1,r1
00004e  0749              LSLS     r1,r1,#29
000050  d414              BMI      |L51.124|
;;;3780       {
;;;3781         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000052  f06f0104          MVN      r1,#4
000056  6101              STR      r1,[r0,#0x10]
;;;3782         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000058  2002              MOVS     r0,#2
00005a  7720              STRB     r0,[r4,#0x1c]
;;;3783         /* Input capture event */
;;;3784         if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
00005c  6820              LDR      r0,[r4,#0]
00005e  6980              LDR      r0,[r0,#0x18]
000060  f4107f40          TST      r0,#0x300
000064  d003              BEQ      |L51.110|
;;;3785         {
;;;3786   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3787           htim->IC_CaptureCallback(htim);
;;;3788   #else
;;;3789           HAL_TIM_IC_CaptureCallback(htim);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006c  e005              B        |L51.122|
                  |L51.110|
;;;3790   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3791         }
;;;3792         /* Output compare event */
;;;3793         else
;;;3794         {
;;;3795   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3796           htim->OC_DelayElapsedCallback(htim);
;;;3797           htim->PWM_PulseFinishedCallback(htim);
;;;3798   #else
;;;3799           HAL_TIM_OC_DelayElapsedCallback(htim);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3800           HAL_TIM_PWM_PulseFinishedCallback(htim);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L51.122|
;;;3801   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3802         }
;;;3803         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00007a  7725              STRB     r5,[r4,#0x1c]
                  |L51.124|
;;;3804       }
;;;3805     }
;;;3806     /* Capture compare 3 event */
;;;3807     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
00007c  6820              LDR      r0,[r4,#0]
00007e  6901              LDR      r1,[r0,#0x10]
000080  43c9              MVNS     r1,r1
000082  0709              LSLS     r1,r1,#28
000084  d417              BMI      |L51.182|
;;;3808     {
;;;3809       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
000086  68c1              LDR      r1,[r0,#0xc]
000088  43c9              MVNS     r1,r1
00008a  0709              LSLS     r1,r1,#28
00008c  d413              BMI      |L51.182|
;;;3810       {
;;;3811         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00008e  f06f0108          MVN      r1,#8
000092  6101              STR      r1,[r0,#0x10]
;;;3812         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000094  2004              MOVS     r0,#4
000096  7720              STRB     r0,[r4,#0x1c]
;;;3813         /* Input capture event */
;;;3814         if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
000098  6820              LDR      r0,[r4,#0]
00009a  69c0              LDR      r0,[r0,#0x1c]
00009c  0780              LSLS     r0,r0,#30
00009e  d003              BEQ      |L51.168|
;;;3815         {
;;;3816   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3817           htim->IC_CaptureCallback(htim);
;;;3818   #else
;;;3819           HAL_TIM_IC_CaptureCallback(htim);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a6  e005              B        |L51.180|
                  |L51.168|
;;;3820   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3821         }
;;;3822         /* Output compare event */
;;;3823         else
;;;3824         {
;;;3825   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3826           htim->OC_DelayElapsedCallback(htim);
;;;3827           htim->PWM_PulseFinishedCallback(htim);
;;;3828   #else
;;;3829           HAL_TIM_OC_DelayElapsedCallback(htim);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3830           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L51.180|
;;;3831   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3832         }
;;;3833         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000b4  7725              STRB     r5,[r4,#0x1c]
                  |L51.182|
;;;3834       }
;;;3835     }
;;;3836     /* Capture compare 4 event */
;;;3837     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6901              LDR      r1,[r0,#0x10]
0000ba  43c9              MVNS     r1,r1
0000bc  06c9              LSLS     r1,r1,#27
0000be  d418              BMI      |L51.242|
;;;3838     {
;;;3839       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
0000c0  68c1              LDR      r1,[r0,#0xc]
0000c2  43c9              MVNS     r1,r1
0000c4  06c9              LSLS     r1,r1,#27
0000c6  d414              BMI      |L51.242|
;;;3840       {
;;;3841         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000c8  f06f0110          MVN      r1,#0x10
0000cc  6101              STR      r1,[r0,#0x10]
;;;3842         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000ce  2008              MOVS     r0,#8
0000d0  7720              STRB     r0,[r4,#0x1c]
;;;3843         /* Input capture event */
;;;3844         if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
0000d2  6820              LDR      r0,[r4,#0]
0000d4  69c0              LDR      r0,[r0,#0x1c]
0000d6  f4107f40          TST      r0,#0x300
0000da  d003              BEQ      |L51.228|
;;;3845         {
;;;3846   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3847           htim->IC_CaptureCallback(htim);
;;;3848   #else
;;;3849           HAL_TIM_IC_CaptureCallback(htim);
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000e2  e005              B        |L51.240|
                  |L51.228|
;;;3850   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3851         }
;;;3852         /* Output compare event */
;;;3853         else
;;;3854         {
;;;3855   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3856           htim->OC_DelayElapsedCallback(htim);
;;;3857           htim->PWM_PulseFinishedCallback(htim);
;;;3858   #else
;;;3859           HAL_TIM_OC_DelayElapsedCallback(htim);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3860           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L51.240|
;;;3861   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3862         }
;;;3863         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000f0  7725              STRB     r5,[r4,#0x1c]
                  |L51.242|
;;;3864       }
;;;3865     }
;;;3866     /* TIM Update event */
;;;3867     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6901              LDR      r1,[r0,#0x10]
0000f6  43c9              MVNS     r1,r1
0000f8  07c9              LSLS     r1,r1,#31
0000fa  d108              BNE      |L51.270|
;;;3868     {
;;;3869       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
0000fc  68c1              LDR      r1,[r0,#0xc]
0000fe  43c9              MVNS     r1,r1
000100  07c9              LSLS     r1,r1,#31
000102  d104              BNE      |L51.270|
;;;3870       {
;;;3871         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000104  1e89              SUBS     r1,r1,#2
000106  6101              STR      r1,[r0,#0x10]
;;;3872   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3873         htim->PeriodElapsedCallback(htim);
;;;3874   #else
;;;3875         HAL_TIM_PeriodElapsedCallback(htim);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L51.270|
;;;3876   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3877       }
;;;3878     }
;;;3879     /* TIM Break input event */
;;;3880     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00010e  6820              LDR      r0,[r4,#0]
000110  6901              LDR      r1,[r0,#0x10]
000112  43c9              MVNS     r1,r1
000114  0609              LSLS     r1,r1,#24
000116  d409              BMI      |L51.300|
;;;3881     {
;;;3882       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
000118  68c1              LDR      r1,[r0,#0xc]
00011a  43c9              MVNS     r1,r1
00011c  0609              LSLS     r1,r1,#24
00011e  d405              BMI      |L51.300|
;;;3883       {
;;;3884         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000120  f06f0180          MVN      r1,#0x80
000124  6101              STR      r1,[r0,#0x10]
;;;3885   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3886         htim->BreakCallback(htim);
;;;3887   #else
;;;3888         HAL_TIMEx_BreakCallback(htim);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L51.300|
;;;3889   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3890       }
;;;3891     }
;;;3892     /* TIM Break2 input event */
;;;3893     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
00012c  6820              LDR      r0,[r4,#0]
00012e  6901              LDR      r1,[r0,#0x10]
000130  43c9              MVNS     r1,r1
000132  05c9              LSLS     r1,r1,#23
000134  d409              BMI      |L51.330|
;;;3894     {
;;;3895       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
000136  68c1              LDR      r1,[r0,#0xc]
000138  43c9              MVNS     r1,r1
00013a  0609              LSLS     r1,r1,#24
00013c  d405              BMI      |L51.330|
;;;3896       {
;;;3897         __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
00013e  f46f7180          MVN      r1,#0x100
000142  6101              STR      r1,[r0,#0x10]
;;;3898   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3899         htim->Break2Callback(htim);
;;;3900   #else
;;;3901         HAL_TIMEx_Break2Callback(htim);
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       HAL_TIMEx_Break2Callback
                  |L51.330|
;;;3902   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3903       }
;;;3904     }
;;;3905     /* TIM Trigger detection event */
;;;3906     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
00014a  6820              LDR      r0,[r4,#0]
00014c  6901              LDR      r1,[r0,#0x10]
00014e  43c9              MVNS     r1,r1
000150  0649              LSLS     r1,r1,#25
000152  d409              BMI      |L51.360|
;;;3907     {
;;;3908       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
000154  68c1              LDR      r1,[r0,#0xc]
000156  43c9              MVNS     r1,r1
000158  0649              LSLS     r1,r1,#25
00015a  d405              BMI      |L51.360|
;;;3909       {
;;;3910         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
00015c  f06f0140          MVN      r1,#0x40
000160  6101              STR      r1,[r0,#0x10]
;;;3911   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3912         htim->TriggerCallback(htim);
;;;3913   #else
;;;3914         HAL_TIM_TriggerCallback(htim);
000162  4620              MOV      r0,r4
000164  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L51.360|
;;;3915   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3916       }
;;;3917     }
;;;3918     /* TIM commutation event */
;;;3919     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000168  6820              LDR      r0,[r4,#0]
00016a  6901              LDR      r1,[r0,#0x10]
00016c  43c9              MVNS     r1,r1
00016e  0689              LSLS     r1,r1,#26
000170  d40b              BMI      |L51.394|
;;;3920     {
;;;3921       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
000172  68c1              LDR      r1,[r0,#0xc]
000174  43c9              MVNS     r1,r1
000176  0689              LSLS     r1,r1,#26
000178  d407              BMI      |L51.394|
;;;3922       {
;;;3923         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
00017a  f06f0120          MVN      r1,#0x20
00017e  6101              STR      r1,[r0,#0x10]
;;;3924   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3925         htim->CommutationCallback(htim);
;;;3926   #else
;;;3927         HAL_TIMEx_CommutCallback(htim);
000180  4620              MOV      r0,r4
000182  e8bd4070          POP      {r4-r6,lr}
000186  f7ffbffe          B.W      HAL_TIMEx_CommutCallback
                  |L51.394|
;;;3928   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3929       }
;;;3930     }
;;;3931   }
00018a  bd70              POP      {r4-r6,pc}
;;;3932   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;3970     */
;;;3971   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
000000  b510              PUSH     {r4,lr}
;;;3972                                              TIM_OC_InitTypeDef *sConfig,
;;;3973                                              uint32_t Channel)
;;;3974   {
000002  4604              MOV      r4,r0
;;;3975     /* Check the parameters */
;;;3976     assert_param(IS_TIM_CHANNELS(Channel));
;;;3977     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;3978     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3979   
;;;3980     /* Process Locked */
;;;3981     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d00b              BEQ      |L52.36|
00000c  2001              MOVS     r0,#1
00000e  f884003c          STRB     r0,[r4,#0x3c]
;;;3982   
;;;3983     switch (Channel)
000012  2a0c              CMP      r2,#0xc
000014  d019              BEQ      |L52.74|
000016  dc07              BGT      |L52.40|
000018  b15a              CBZ      r2,|L52.50|
00001a  2a04              CMP      r2,#4
00001c  d00d              BEQ      |L52.58|
00001e  2a08              CMP      r2,#8
000020  d11e              BNE      |L52.96|
000022  e00e              B        |L52.66|
                  |L52.36|
000024  2002              MOVS     r0,#2                 ;3981
;;;3984     {
;;;3985       case TIM_CHANNEL_1:
;;;3986       {
;;;3987         /* Check the parameters */
;;;3988         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3989   
;;;3990         /* Configure the TIM Channel 1 in Output Compare */
;;;3991         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3992         break;
;;;3993       }
;;;3994   
;;;3995       case TIM_CHANNEL_2:
;;;3996       {
;;;3997         /* Check the parameters */
;;;3998         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3999   
;;;4000         /* Configure the TIM Channel 2 in Output Compare */
;;;4001         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;4002         break;
;;;4003       }
;;;4004   
;;;4005       case TIM_CHANNEL_3:
;;;4006       {
;;;4007         /* Check the parameters */
;;;4008         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4009   
;;;4010         /* Configure the TIM Channel 3 in Output Compare */
;;;4011         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;4012         break;
;;;4013       }
;;;4014   
;;;4015       case TIM_CHANNEL_4:
;;;4016       {
;;;4017         /* Check the parameters */
;;;4018         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4019   
;;;4020         /* Configure the TIM Channel 4 in Output Compare */
;;;4021         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;4022         break;
;;;4023       }
;;;4024   
;;;4025       case TIM_CHANNEL_5:
;;;4026       {
;;;4027         /* Check the parameters */
;;;4028         assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
;;;4029   
;;;4030         /* Configure the TIM Channel 5 in Output Compare */
;;;4031         TIM_OC5_SetConfig(htim->Instance, sConfig);
;;;4032         break;
;;;4033       }
;;;4034   
;;;4035       case TIM_CHANNEL_6:
;;;4036       {
;;;4037         /* Check the parameters */
;;;4038         assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
;;;4039   
;;;4040         /* Configure the TIM Channel 6 in Output Compare */
;;;4041         TIM_OC6_SetConfig(htim->Instance, sConfig);
;;;4042         break;
;;;4043       }
;;;4044   
;;;4045       default:
;;;4046         break;
;;;4047     }
;;;4048   
;;;4049     __HAL_UNLOCK(htim);
;;;4050   
;;;4051     return HAL_OK;
;;;4052   }
000026  bd10              POP      {r4,pc}
                  |L52.40|
000028  2a10              CMP      r2,#0x10              ;3983
00002a  d012              BEQ      |L52.82|
00002c  2a14              CMP      r2,#0x14              ;3983
00002e  d117              BNE      |L52.96|
000030  e013              B        |L52.90|
                  |L52.50|
000032  6820              LDR      r0,[r4,#0]            ;3991
000034  f7fffffe          BL       TIM_OC1_SetConfig
000038  e012              B        |L52.96|
                  |L52.58|
00003a  6820              LDR      r0,[r4,#0]            ;4001
00003c  f7fffffe          BL       TIM_OC2_SetConfig
000040  e00e              B        |L52.96|
                  |L52.66|
000042  6820              LDR      r0,[r4,#0]            ;4011
000044  f7fffffe          BL       TIM_OC3_SetConfig
000048  e00a              B        |L52.96|
                  |L52.74|
00004a  6820              LDR      r0,[r4,#0]            ;4021
00004c  f7fffffe          BL       TIM_OC4_SetConfig
000050  e006              B        |L52.96|
                  |L52.82|
000052  6820              LDR      r0,[r4,#0]            ;4031
000054  f7fffffe          BL       TIM_OC5_SetConfig
000058  e002              B        |L52.96|
                  |L52.90|
00005a  6820              LDR      r0,[r4,#0]            ;4041
00005c  f7fffffe          BL       TIM_OC6_SetConfig
                  |L52.96|
000060  2000              MOVS     r0,#0                 ;4049
000062  f884003c          STRB     r0,[r4,#0x3c]         ;4049
000066  bd10              POP      {r4,pc}
;;;4053   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;709      */
;;;710    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;711    {
000002  4604              MOV      r4,r0
;;;712      /* Check the parameters */
;;;713      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;714    
;;;715      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;716    
;;;717      /* Disable the TIM Peripheral Clock */
;;;718      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L53.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L53.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L53.38|
;;;719    
;;;720    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;721      if (htim->OC_MspDeInitCallback == NULL)
;;;722      {
;;;723        htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
;;;724      }
;;;725      /* DeInit the low level hardware */
;;;726      htim->OC_MspDeInitCallback(htim);
;;;727    #else
;;;728      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;729      HAL_TIM_OC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;730    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;731    
;;;732      /* Change the DMA burst operation state */
;;;733      htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7320              STRB     r0,[r4,#0xc]
;;;734    
;;;735      /* Change the TIM channels state */
;;;736      TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
000032  70a0              STRB     r0,[r4,#2]
000034  70e0              STRB     r0,[r4,#3]
000036  7120              STRB     r0,[r4,#4]
000038  7160              STRB     r0,[r4,#5]
00003a  71a0              STRB     r0,[r4,#6]
00003c  71e0              STRB     r0,[r4,#7]
;;;737      TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
00003e  7220              STRB     r0,[r4,#8]
000040  7260              STRB     r0,[r4,#9]
000042  72a0              STRB     r0,[r4,#0xa]
000044  72e0              STRB     r0,[r4,#0xb]
;;;738    
;;;739      /* Change TIM state */
;;;740      htim->State = HAL_TIM_STATE_RESET;
000046  7060              STRB     r0,[r4,#1]
;;;741    
;;;742      /* Release Lock */
;;;743      __HAL_UNLOCK(htim);
000048  7020              STRB     r0,[r4,#0]
;;;744    
;;;745      return HAL_OK;
;;;746    }
00004a  bd10              POP      {r4,pc}
;;;747    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;5670     */
;;;5671   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5672   {
;;;5673     /* Prevent unused argument(s) compilation warning */
;;;5674     UNUSED(htim);
;;;5675   
;;;5676     /* NOTE : This function should not be modified, when the callback is needed,
;;;5677               the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;5678      */
;;;5679   }
;;;5680   
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;6312     */
;;;6313   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;6314   {
;;;6315     return htim->State;
;;;6316   }
000004  4770              BX       lr
;;;6317   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;650      */
;;;651    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;652    {
000002  4604              MOV      r4,r0
;;;653      /* Check the TIM handle allocation */
;;;654      if (htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L56.16|
;;;655      {
;;;656        return HAL_ERROR;
;;;657      }
;;;658    
;;;659      /* Check the parameters */
;;;660      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;661      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;662      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;663      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;664    
;;;665      if (htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L56.20|
00000e  e007              B        |L56.32|
                  |L56.16|
000010  2001              MOVS     r0,#1                 ;656
;;;666      {
;;;667        /* Allocate lock resource and initialize it */
;;;668        htim->Lock = HAL_UNLOCKED;
;;;669    
;;;670    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;671        /* Reset interrupt callbacks to legacy weak callbacks */
;;;672        TIM_ResetCallback(htim);
;;;673    
;;;674        if (htim->OC_MspInitCallback == NULL)
;;;675        {
;;;676          htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
;;;677        }
;;;678        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;679        htim->OC_MspInitCallback(htim);
;;;680    #else
;;;681        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;682        HAL_TIM_OC_MspInit(htim);
;;;683    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;684      }
;;;685    
;;;686      /* Set the TIM state */
;;;687      htim->State = HAL_TIM_STATE_BUSY;
;;;688    
;;;689      /* Init the base time for the Output Compare */
;;;690      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;691    
;;;692      /* Initialize the DMA burst operation state */
;;;693      htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
;;;694    
;;;695      /* Initialize the TIM channels state */
;;;696      TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;697      TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;698    
;;;699      /* Initialize the TIM state*/
;;;700      htim->State = HAL_TIM_STATE_READY;
;;;701    
;;;702      return HAL_OK;
;;;703    }
000012  bd10              POP      {r4,pc}
                  |L56.20|
000014  2000              MOVS     r0,#0                 ;668
000016  f884003c          STRB     r0,[r4,#0x3c]         ;668
00001a  4620              MOV      r0,r4                 ;682
00001c  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L56.32|
000020  2002              MOVS     r0,#2                 ;687
000022  f884003d          STRB     r0,[r4,#0x3d]         ;687
000026  1d21              ADDS     r1,r4,#4              ;690
000028  6820              LDR      r0,[r4,#0]            ;690
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;693
000030  343d              ADDS     r4,r4,#0x3d           ;693
000032  72e0              STRB     r0,[r4,#0xb]          ;693
000034  7060              STRB     r0,[r4,#1]            ;696
000036  70a0              STRB     r0,[r4,#2]            ;696
000038  70e0              STRB     r0,[r4,#3]            ;696
00003a  7120              STRB     r0,[r4,#4]            ;696
00003c  7160              STRB     r0,[r4,#5]            ;696
00003e  71a0              STRB     r0,[r4,#6]            ;696
000040  71e0              STRB     r0,[r4,#7]            ;697
000042  7220              STRB     r0,[r4,#8]            ;697
000044  7260              STRB     r0,[r4,#9]            ;697
000046  72a0              STRB     r0,[r4,#0xa]          ;697
000048  7020              STRB     r0,[r4,#0]            ;700
00004a  2000              MOVS     r0,#0                 ;702
00004c  bd10              POP      {r4,pc}
;;;704    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;767      */
;;;768    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;769    {
;;;770      /* Prevent unused argument(s) compilation warning */
;;;771      UNUSED(htim);
;;;772    
;;;773      /* NOTE : This function should not be modified, when the callback is needed,
;;;774                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;775       */
;;;776    }
;;;777    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;752      */
;;;753    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;754    {
;;;755      /* Prevent unused argument(s) compilation warning */
;;;756      UNUSED(htim);
;;;757    
;;;758      /* NOTE : This function should not be modified, when the callback is needed,
;;;759                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;760       */
;;;761    }
;;;762    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;790      */
;;;791    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;792    {
000002  4604              MOV      r4,r0
;;;793      uint32_t tmpsmcr;
;;;794    
;;;795      /* Check the parameters */
;;;796      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;797    
;;;798      /* Check the TIM channel state */
;;;799      if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d00d              BEQ      |L59.36|
000008  2904              CMP      r1,#4
00000a  d00e              BEQ      |L59.42|
00000c  2908              CMP      r1,#8
00000e  d00f              BEQ      |L59.48|
000010  290c              CMP      r1,#0xc
000012  d010              BEQ      |L59.54|
000014  2910              CMP      r1,#0x10
000016  d011              BEQ      |L59.60|
000018  f8940043          LDRB     r0,[r4,#0x43]
                  |L59.28|
00001c  2801              CMP      r0,#1
00001e  d010              BEQ      |L59.66|
;;;800      {
;;;801        return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;802      }
;;;803    
;;;804      /* Set the TIM channel state */
;;;805      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;806    
;;;807      /* Enable the Output compare channel */
;;;808      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;809    
;;;810      if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;811      {
;;;812        /* Enable the main output */
;;;813        __HAL_TIM_MOE_ENABLE(htim);
;;;814      }
;;;815    
;;;816      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;817      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;818      {
;;;819        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;820        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;821        {
;;;822          __HAL_TIM_ENABLE(htim);
;;;823        }
;;;824      }
;;;825      else
;;;826      {
;;;827        __HAL_TIM_ENABLE(htim);
;;;828      }
;;;829    
;;;830      /* Return function status */
;;;831      return HAL_OK;
;;;832    }
000022  bd30              POP      {r4,r5,pc}
                  |L59.36|
000024  f894003e          LDRB     r0,[r4,#0x3e]         ;799
000028  e7f8              B        |L59.28|
                  |L59.42|
00002a  f894003f          LDRB     r0,[r4,#0x3f]         ;799
00002e  e7f5              B        |L59.28|
                  |L59.48|
000030  f8940040          LDRB     r0,[r4,#0x40]         ;799
000034  e7f2              B        |L59.28|
                  |L59.54|
000036  f8940041          LDRB     r0,[r4,#0x41]         ;799
00003a  e7ef              B        |L59.28|
                  |L59.60|
00003c  f8940042          LDRB     r0,[r4,#0x42]         ;799
000040  e7ec              B        |L59.28|
                  |L59.66|
000042  2002              MOVS     r0,#2                 ;805
000044  b3f1              CBZ      r1,|L59.196|
000046  2904              CMP      r1,#4                 ;805
000048  d044              BEQ      |L59.212|
00004a  2908              CMP      r1,#8                 ;805
00004c  d045              BEQ      |L59.218|
00004e  290c              CMP      r1,#0xc               ;805
000050  d046              BEQ      |L59.224|
000052  2910              CMP      r1,#0x10              ;805
000054  d047              BEQ      |L59.230|
000056  f8840043          STRB     r0,[r4,#0x43]         ;805
                  |L59.90|
00005a  2201              MOVS     r2,#1                 ;808
00005c  6820              LDR      r0,[r4,#0]            ;808
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  4925              LDR      r1,|L59.248|
000064  6820              LDR      r0,[r4,#0]            ;810
000066  4a25              LDR      r2,|L59.252|
000068  4b25              LDR      r3,|L59.256|
00006a  4288              CMP      r0,r1                 ;810
00006c  d009              BEQ      |L59.130|
00006e  4290              CMP      r0,r2                 ;810
000070  d007              BEQ      |L59.130|
000072  4298              CMP      r0,r3                 ;810
000074  d005              BEQ      |L59.130|
000076  4d23              LDR      r5,|L59.260|
000078  42a8              CMP      r0,r5                 ;810
00007a  d002              BEQ      |L59.130|
00007c  4d22              LDR      r5,|L59.264|
00007e  42a8              CMP      r0,r5                 ;810
000080  d103              BNE      |L59.138|
                  |L59.130|
000082  6c45              LDR      r5,[r0,#0x44]         ;813
000084  f4454500          ORR      r5,r5,#0x8000         ;813
000088  6445              STR      r5,[r0,#0x44]         ;813
                  |L59.138|
00008a  6820              LDR      r0,[r4,#0]            ;817
00008c  4288              CMP      r0,r1                 ;817
00008e  d00f              BEQ      |L59.176|
000090  f1b04f80          CMP      r0,#0x40000000        ;817
000094  d00c              BEQ      |L59.176|
000096  491d              LDR      r1,|L59.268|
000098  4288              CMP      r0,r1                 ;817
00009a  d009              BEQ      |L59.176|
00009c  491c              LDR      r1,|L59.272|
00009e  4288              CMP      r0,r1                 ;817
0000a0  d006              BEQ      |L59.176|
0000a2  491c              LDR      r1,|L59.276|
0000a4  4288              CMP      r0,r1                 ;817
0000a6  d003              BEQ      |L59.176|
0000a8  4290              CMP      r0,r2                 ;817
0000aa  d001              BEQ      |L59.176|
0000ac  4298              CMP      r0,r3                 ;817
0000ae  d11d              BNE      |L59.236|
                  |L59.176|
0000b0  6881              LDR      r1,[r0,#8]            ;819
0000b2  4a19              LDR      r2,|L59.280|
0000b4  4011              ANDS     r1,r1,r2              ;819
0000b6  2906              CMP      r1,#6                 ;820
0000b8  d01c              BEQ      |L59.244|
0000ba  f5b13f80          CMP      r1,#0x10000           ;820
0000be  d019              BEQ      |L59.244|
0000c0  6801              LDR      r1,[r0,#0]            ;822
0000c2  e000              B        |L59.198|
                  |L59.196|
0000c4  e003              B        |L59.206|
                  |L59.198|
0000c6  f0410101          ORR      r1,r1,#1              ;822
0000ca  6001              STR      r1,[r0,#0]            ;822
0000cc  e012              B        |L59.244|
                  |L59.206|
0000ce  f884003e          STRB     r0,[r4,#0x3e]         ;805
0000d2  e7c2              B        |L59.90|
                  |L59.212|
0000d4  f884003f          STRB     r0,[r4,#0x3f]         ;805
0000d8  e7bf              B        |L59.90|
                  |L59.218|
0000da  f8840040          STRB     r0,[r4,#0x40]         ;805
0000de  e7bc              B        |L59.90|
                  |L59.224|
0000e0  f8840041          STRB     r0,[r4,#0x41]         ;805
0000e4  e7b9              B        |L59.90|
                  |L59.230|
0000e6  f8840042          STRB     r0,[r4,#0x42]         ;805
0000ea  e7b6              B        |L59.90|
                  |L59.236|
0000ec  6801              LDR      r1,[r0,#0]            ;827
0000ee  f0410101          ORR      r1,r1,#1              ;827
0000f2  6001              STR      r1,[r0,#0]            ;827
                  |L59.244|
0000f4  2000              MOVS     r0,#0                 ;831
0000f6  bd30              POP      {r4,r5,pc}
;;;833    
                          ENDP

                  |L59.248|
                          DCD      0x40012c00
                  |L59.252|
                          DCD      0x40013400
                  |L59.256|
                          DCD      0x40014000
                  |L59.260|
                          DCD      0x40014400
                  |L59.264|
                          DCD      0x40014800
                  |L59.268|
                          DCD      0x40000400
                  |L59.272|
                          DCD      0x40000800
                  |L59.276|
                          DCD      0x40000c00
                  |L59.280|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;1040     */
;;;1041   HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1042   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  4611              MOV      r1,r2
;;;1043     uint32_t tmpsmcr;
;;;1044   
;;;1045     /* Check the parameters */
;;;1046     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1047   
;;;1048     /* Set the TIM channel state */
;;;1049     if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
00000a  2d00              CMP      r5,#0
00000c  d01b              BEQ      |L60.70|
00000e  2d04              CMP      r5,#4
000010  d01c              BEQ      |L60.76|
000012  2d08              CMP      r5,#8
000014  d01d              BEQ      |L60.82|
000016  2d0c              CMP      r5,#0xc
000018  d01e              BEQ      |L60.88|
00001a  2d10              CMP      r5,#0x10
00001c  d01f              BEQ      |L60.94|
00001e  f8940043          LDRB     r0,[r4,#0x43]
                  |L60.34|
000022  2802              CMP      r0,#2
000024  d01e              BEQ      |L60.100|
;;;1050     {
;;;1051       return HAL_BUSY;
;;;1052     }
;;;1053     else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
000026  b1fd              CBZ      r5,|L60.104|
000028  2d04              CMP      r5,#4
00002a  d020              BEQ      |L60.110|
00002c  2d08              CMP      r5,#8
00002e  d021              BEQ      |L60.116|
000030  2d0c              CMP      r5,#0xc
000032  d022              BEQ      |L60.122|
000034  2d10              CMP      r5,#0x10
000036  d023              BEQ      |L60.128|
000038  f8940043          LDRB     r0,[r4,#0x43]
                  |L60.60|
00003c  2801              CMP      r0,#1
00003e  d022              BEQ      |L60.134|
;;;1054     {
;;;1055       if ((pData == NULL) && (Length > 0U))
;;;1056       {
;;;1057         return HAL_ERROR;
;;;1058       }
;;;1059       else
;;;1060       {
;;;1061         TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1062       }
;;;1063     }
;;;1064     else
;;;1065     {
;;;1066       return HAL_ERROR;
000040  2001              MOVS     r0,#1
                  |L60.66|
;;;1067     }
;;;1068   
;;;1069     switch (Channel)
;;;1070     {
;;;1071       case TIM_CHANNEL_1:
;;;1072       {
;;;1073         /* Set the DMA compare callbacks */
;;;1074         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1075         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1076   
;;;1077         /* Set the DMA error callback */
;;;1078         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1079   
;;;1080         /* Enable the DMA channel */
;;;1081         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;1082         {
;;;1083           /* Return error status */
;;;1084           return HAL_ERROR;
;;;1085         }
;;;1086   
;;;1087         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1088         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1089         break;
;;;1090       }
;;;1091   
;;;1092       case TIM_CHANNEL_2:
;;;1093       {
;;;1094         /* Set the DMA compare callbacks */
;;;1095         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1096         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1097   
;;;1098         /* Set the DMA error callback */
;;;1099         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1100   
;;;1101         /* Enable the DMA channel */
;;;1102         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;1103         {
;;;1104           /* Return error status */
;;;1105           return HAL_ERROR;
;;;1106         }
;;;1107   
;;;1108         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1109         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1110         break;
;;;1111       }
;;;1112   
;;;1113       case TIM_CHANNEL_3:
;;;1114       {
;;;1115         /* Set the DMA compare callbacks */
;;;1116         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1117         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1118   
;;;1119         /* Set the DMA error callback */
;;;1120         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1121   
;;;1122         /* Enable the DMA channel */
;;;1123         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;1124         {
;;;1125           /* Return error status */
;;;1126           return HAL_ERROR;
;;;1127         }
;;;1128         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1129         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1130         break;
;;;1131       }
;;;1132   
;;;1133       case TIM_CHANNEL_4:
;;;1134       {
;;;1135         /* Set the DMA compare callbacks */
;;;1136         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1137         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1138   
;;;1139         /* Set the DMA error callback */
;;;1140         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1141   
;;;1142         /* Enable the DMA channel */
;;;1143         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
;;;1144         {
;;;1145           /* Return error status */
;;;1146           return HAL_ERROR;
;;;1147         }
;;;1148         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1149         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1150         break;
;;;1151       }
;;;1152   
;;;1153       default:
;;;1154         break;
;;;1155     }
;;;1156   
;;;1157     /* Enable the Output compare channel */
;;;1158     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1159   
;;;1160     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1161     {
;;;1162       /* Enable the main output */
;;;1163       __HAL_TIM_MOE_ENABLE(htim);
;;;1164     }
;;;1165   
;;;1166     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1167     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;1168     {
;;;1169       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1170       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1171       {
;;;1172         __HAL_TIM_ENABLE(htim);
;;;1173       }
;;;1174     }
;;;1175     else
;;;1176     {
;;;1177       __HAL_TIM_ENABLE(htim);
;;;1178     }
;;;1179   
;;;1180     /* Return function status */
;;;1181     return HAL_OK;
;;;1182   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L60.70|
000046  f894003e          LDRB     r0,[r4,#0x3e]         ;1049
00004a  e7ea              B        |L60.34|
                  |L60.76|
00004c  f894003f          LDRB     r0,[r4,#0x3f]         ;1049
000050  e7e7              B        |L60.34|
                  |L60.82|
000052  f8940040          LDRB     r0,[r4,#0x40]         ;1049
000056  e7e4              B        |L60.34|
                  |L60.88|
000058  f8940041          LDRB     r0,[r4,#0x41]         ;1049
00005c  e7e1              B        |L60.34|
                  |L60.94|
00005e  f8940042          LDRB     r0,[r4,#0x42]         ;1049
000062  e7de              B        |L60.34|
                  |L60.100|
000064  2002              MOVS     r0,#2                 ;1051
000066  e7ec              B        |L60.66|
                  |L60.104|
000068  f894003e          LDRB     r0,[r4,#0x3e]         ;1053
00006c  e7e6              B        |L60.60|
                  |L60.110|
00006e  f894003f          LDRB     r0,[r4,#0x3f]         ;1053
000072  e7e3              B        |L60.60|
                  |L60.116|
000074  f8940040          LDRB     r0,[r4,#0x40]         ;1053
000078  e7e0              B        |L60.60|
                  |L60.122|
00007a  f8940041          LDRB     r0,[r4,#0x41]         ;1053
00007e  e7dd              B        |L60.60|
                  |L60.128|
000080  f8940042          LDRB     r0,[r4,#0x42]         ;1053
000084  e7da              B        |L60.60|
                  |L60.134|
000086  b911              CBNZ     r1,|L60.142|
000088  b10b              CBZ      r3,|L60.142|
00008a  2001              MOVS     r0,#1                 ;1057
00008c  e7d9              B        |L60.66|
                  |L60.142|
00008e  2002              MOVS     r0,#2                 ;1051
000090  b155              CBZ      r5,|L60.168|
000092  2d04              CMP      r5,#4                 ;1061
000094  d00b              BEQ      |L60.174|
000096  2d08              CMP      r5,#8                 ;1061
000098  d00c              BEQ      |L60.180|
00009a  2d0c              CMP      r5,#0xc               ;1061
00009c  d00d              BEQ      |L60.186|
00009e  2d10              CMP      r5,#0x10              ;1061
0000a0  d00e              BEQ      |L60.192|
0000a2  f8840043          STRB     r0,[r4,#0x43]         ;1061
0000a6  e00d              B        |L60.196|
                  |L60.168|
0000a8  f884003e          STRB     r0,[r4,#0x3e]         ;1061
0000ac  e00a              B        |L60.196|
                  |L60.174|
0000ae  f884003f          STRB     r0,[r4,#0x3f]         ;1061
0000b2  e007              B        |L60.196|
                  |L60.180|
0000b4  f8840040          STRB     r0,[r4,#0x40]         ;1061
0000b8  e004              B        |L60.196|
                  |L60.186|
0000ba  f8840041          STRB     r0,[r4,#0x41]         ;1061
0000be  e001              B        |L60.196|
                  |L60.192|
0000c0  f8840042          STRB     r0,[r4,#0x42]         ;1061
                  |L60.196|
0000c4  484c              LDR      r0,|L60.504|
0000c6  4a4d              LDR      r2,|L60.508|
0000c8  4e4d              LDR      r6,|L60.512|
0000ca  b135              CBZ      r5,|L60.218|
0000cc  2d04              CMP      r5,#4                 ;1069
0000ce  d018              BEQ      |L60.258|
0000d0  2d08              CMP      r5,#8                 ;1069
0000d2  d02a              BEQ      |L60.298|
0000d4  2d0c              CMP      r5,#0xc               ;1069
0000d6  d14f              BNE      |L60.376|
0000d8  e03b              B        |L60.338|
                  |L60.218|
0000da  6a67              LDR      r7,[r4,#0x24]         ;1074
0000dc  62f8              STR      r0,[r7,#0x2c]         ;1074
0000de  6a60              LDR      r0,[r4,#0x24]         ;1075
0000e0  6302              STR      r2,[r0,#0x30]         ;1075
0000e2  6a60              LDR      r0,[r4,#0x24]         ;1078
0000e4  6346              STR      r6,[r0,#0x34]         ;1078
0000e6  6822              LDR      r2,[r4,#0]            ;1081
0000e8  6a60              LDR      r0,[r4,#0x24]         ;1081
0000ea  3234              ADDS     r2,r2,#0x34           ;1081
0000ec  f7fffffe          BL       HAL_DMA_Start_IT
0000f0  b108              CBZ      r0,|L60.246|
0000f2  2001              MOVS     r0,#1                 ;1084
0000f4  e7a5              B        |L60.66|
                  |L60.246|
0000f6  6820              LDR      r0,[r4,#0]            ;1088
0000f8  68c1              LDR      r1,[r0,#0xc]          ;1088
0000fa  f4417100          ORR      r1,r1,#0x200          ;1088
0000fe  60c1              STR      r1,[r0,#0xc]          ;1088
000100  e03a              B        |L60.376|
                  |L60.258|
000102  6aa7              LDR      r7,[r4,#0x28]         ;1095
000104  62f8              STR      r0,[r7,#0x2c]         ;1095
000106  6aa0              LDR      r0,[r4,#0x28]         ;1096
000108  6302              STR      r2,[r0,#0x30]         ;1096
00010a  6aa0              LDR      r0,[r4,#0x28]         ;1099
00010c  6346              STR      r6,[r0,#0x34]         ;1099
00010e  6822              LDR      r2,[r4,#0]            ;1102
000110  6aa0              LDR      r0,[r4,#0x28]         ;1102
000112  3238              ADDS     r2,r2,#0x38           ;1102
000114  f7fffffe          BL       HAL_DMA_Start_IT
000118  b108              CBZ      r0,|L60.286|
00011a  2001              MOVS     r0,#1                 ;1105
00011c  e791              B        |L60.66|
                  |L60.286|
00011e  6820              LDR      r0,[r4,#0]            ;1109
000120  68c1              LDR      r1,[r0,#0xc]          ;1109
000122  f4416180          ORR      r1,r1,#0x400          ;1109
000126  60c1              STR      r1,[r0,#0xc]          ;1109
000128  e026              B        |L60.376|
                  |L60.298|
00012a  6ae7              LDR      r7,[r4,#0x2c]         ;1116
00012c  62f8              STR      r0,[r7,#0x2c]         ;1116
00012e  6ae0              LDR      r0,[r4,#0x2c]         ;1117
000130  6302              STR      r2,[r0,#0x30]         ;1117
000132  6ae0              LDR      r0,[r4,#0x2c]         ;1120
000134  6346              STR      r6,[r0,#0x34]         ;1120
000136  6822              LDR      r2,[r4,#0]            ;1123
000138  6ae0              LDR      r0,[r4,#0x2c]         ;1123
00013a  323c              ADDS     r2,r2,#0x3c           ;1123
00013c  f7fffffe          BL       HAL_DMA_Start_IT
000140  b108              CBZ      r0,|L60.326|
000142  2001              MOVS     r0,#1                 ;1126
000144  e77d              B        |L60.66|
                  |L60.326|
000146  6820              LDR      r0,[r4,#0]            ;1129
000148  68c1              LDR      r1,[r0,#0xc]          ;1129
00014a  f4416100          ORR      r1,r1,#0x800          ;1129
00014e  60c1              STR      r1,[r0,#0xc]          ;1129
000150  e012              B        |L60.376|
                  |L60.338|
000152  6b27              LDR      r7,[r4,#0x30]         ;1136
000154  62f8              STR      r0,[r7,#0x2c]         ;1136
000156  6b20              LDR      r0,[r4,#0x30]         ;1137
000158  6302              STR      r2,[r0,#0x30]         ;1137
00015a  6b20              LDR      r0,[r4,#0x30]         ;1140
00015c  6346              STR      r6,[r0,#0x34]         ;1140
00015e  6822              LDR      r2,[r4,#0]            ;1143
000160  6b20              LDR      r0,[r4,#0x30]         ;1143
000162  3240              ADDS     r2,r2,#0x40           ;1143
000164  f7fffffe          BL       HAL_DMA_Start_IT
000168  b108              CBZ      r0,|L60.366|
00016a  2001              MOVS     r0,#1                 ;1146
00016c  e769              B        |L60.66|
                  |L60.366|
00016e  6820              LDR      r0,[r4,#0]            ;1149
000170  68c1              LDR      r1,[r0,#0xc]          ;1149
000172  f4415180          ORR      r1,r1,#0x1000         ;1149
000176  60c1              STR      r1,[r0,#0xc]          ;1149
                  |L60.376|
000178  2201              MOVS     r2,#1                 ;1158
00017a  4629              MOV      r1,r5                 ;1158
00017c  6820              LDR      r0,[r4,#0]            ;1158
00017e  f7fffffe          BL       TIM_CCxChannelCmd
000182  4920              LDR      r1,|L60.516|
000184  6820              LDR      r0,[r4,#0]            ;1160
000186  4a20              LDR      r2,|L60.520|
000188  4b20              LDR      r3,|L60.524|
00018a  4288              CMP      r0,r1                 ;1160
00018c  d009              BEQ      |L60.418|
00018e  4290              CMP      r0,r2                 ;1160
000190  d007              BEQ      |L60.418|
000192  4298              CMP      r0,r3                 ;1160
000194  d005              BEQ      |L60.418|
000196  4d1e              LDR      r5,|L60.528|
000198  42a8              CMP      r0,r5                 ;1160
00019a  d002              BEQ      |L60.418|
00019c  4d1d              LDR      r5,|L60.532|
00019e  42a8              CMP      r0,r5                 ;1160
0001a0  d103              BNE      |L60.426|
                  |L60.418|
0001a2  6c45              LDR      r5,[r0,#0x44]         ;1163
0001a4  f4454500          ORR      r5,r5,#0x8000         ;1163
0001a8  6445              STR      r5,[r0,#0x44]         ;1163
                  |L60.426|
0001aa  6820              LDR      r0,[r4,#0]            ;1167
0001ac  4288              CMP      r0,r1                 ;1167
0001ae  d00f              BEQ      |L60.464|
0001b0  f1b04f80          CMP      r0,#0x40000000        ;1167
0001b4  d00c              BEQ      |L60.464|
0001b6  4918              LDR      r1,|L60.536|
0001b8  4288              CMP      r0,r1                 ;1167
0001ba  d009              BEQ      |L60.464|
0001bc  4917              LDR      r1,|L60.540|
0001be  4288              CMP      r0,r1                 ;1167
0001c0  d006              BEQ      |L60.464|
0001c2  4917              LDR      r1,|L60.544|
0001c4  4288              CMP      r0,r1                 ;1167
0001c6  d003              BEQ      |L60.464|
0001c8  4290              CMP      r0,r2                 ;1167
0001ca  d001              BEQ      |L60.464|
0001cc  4298              CMP      r0,r3                 ;1167
0001ce  d10c              BNE      |L60.490|
                  |L60.464|
0001d0  6881              LDR      r1,[r0,#8]            ;1169
0001d2  4a14              LDR      r2,|L60.548|
0001d4  4011              ANDS     r1,r1,r2              ;1169
0001d6  2906              CMP      r1,#6                 ;1170
0001d8  d00b              BEQ      |L60.498|
0001da  f5b13f80          CMP      r1,#0x10000           ;1170
0001de  d008              BEQ      |L60.498|
0001e0  6801              LDR      r1,[r0,#0]            ;1172
0001e2  f0410101          ORR      r1,r1,#1              ;1172
0001e6  6001              STR      r1,[r0,#0]            ;1172
0001e8  e003              B        |L60.498|
                  |L60.490|
0001ea  6801              LDR      r1,[r0,#0]            ;1177
0001ec  f0410101          ORR      r1,r1,#1              ;1177
0001f0  6001              STR      r1,[r0,#0]            ;1177
                  |L60.498|
0001f2  2000              MOVS     r0,#0                 ;1181
0001f4  e725              B        |L60.66|
;;;1183   
                          ENDP

0001f6  0000              DCW      0x0000
                  |L60.504|
                          DCD      TIM_DMADelayPulseCplt
                  |L60.508|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L60.512|
                          DCD      TIM_DMAError
                  |L60.516|
                          DCD      0x40012c00
                  |L60.520|
                          DCD      0x40013400
                  |L60.524|
                          DCD      0x40014000
                  |L60.528|
                          DCD      0x40014400
                  |L60.532|
                          DCD      0x40014800
                  |L60.536|
                          DCD      0x40000400
                  |L60.540|
                          DCD      0x40000800
                  |L60.544|
                          DCD      0x40000c00
                  |L60.548|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;881      */
;;;882    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;883    {
000002  4604              MOV      r4,r0
;;;884      uint32_t tmpsmcr;
;;;885    
;;;886      /* Check the parameters */
;;;887      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;888    
;;;889      /* Check the TIM channel state */
;;;890      if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d00d              BEQ      |L61.36|
000008  2904              CMP      r1,#4
00000a  d00e              BEQ      |L61.42|
00000c  2908              CMP      r1,#8
00000e  d00f              BEQ      |L61.48|
000010  290c              CMP      r1,#0xc
000012  d010              BEQ      |L61.54|
000014  2910              CMP      r1,#0x10
000016  d011              BEQ      |L61.60|
000018  f8940043          LDRB     r0,[r4,#0x43]
                  |L61.28|
00001c  2801              CMP      r0,#1
00001e  d010              BEQ      |L61.66|
;;;891      {
;;;892        return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;893      }
;;;894    
;;;895      /* Set the TIM channel state */
;;;896      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;897    
;;;898      switch (Channel)
;;;899      {
;;;900        case TIM_CHANNEL_1:
;;;901        {
;;;902          /* Enable the TIM Capture/Compare 1 interrupt */
;;;903          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;904          break;
;;;905        }
;;;906    
;;;907        case TIM_CHANNEL_2:
;;;908        {
;;;909          /* Enable the TIM Capture/Compare 2 interrupt */
;;;910          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;911          break;
;;;912        }
;;;913    
;;;914        case TIM_CHANNEL_3:
;;;915        {
;;;916          /* Enable the TIM Capture/Compare 3 interrupt */
;;;917          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;918          break;
;;;919        }
;;;920    
;;;921        case TIM_CHANNEL_4:
;;;922        {
;;;923          /* Enable the TIM Capture/Compare 4 interrupt */
;;;924          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;925          break;
;;;926        }
;;;927    
;;;928        default:
;;;929          break;
;;;930      }
;;;931    
;;;932      /* Enable the Output compare channel */
;;;933      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;934    
;;;935      if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;936      {
;;;937        /* Enable the main output */
;;;938        __HAL_TIM_MOE_ENABLE(htim);
;;;939      }
;;;940    
;;;941      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;942      if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;943      {
;;;944        tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;945        if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;946        {
;;;947          __HAL_TIM_ENABLE(htim);
;;;948        }
;;;949      }
;;;950      else
;;;951      {
;;;952        __HAL_TIM_ENABLE(htim);
;;;953      }
;;;954    
;;;955      /* Return function status */
;;;956      return HAL_OK;
;;;957    }
000022  bd30              POP      {r4,r5,pc}
                  |L61.36|
000024  f894003e          LDRB     r0,[r4,#0x3e]         ;890
000028  e7f8              B        |L61.28|
                  |L61.42|
00002a  f894003f          LDRB     r0,[r4,#0x3f]         ;890
00002e  e7f5              B        |L61.28|
                  |L61.48|
000030  f8940040          LDRB     r0,[r4,#0x40]         ;890
000034  e7f2              B        |L61.28|
                  |L61.54|
000036  f8940041          LDRB     r0,[r4,#0x41]         ;890
00003a  e7ef              B        |L61.28|
                  |L61.60|
00003c  f8940042          LDRB     r0,[r4,#0x42]         ;890
000040  e7ec              B        |L61.28|
                  |L61.66|
000042  2002              MOVS     r0,#2                 ;896
000044  b189              CBZ      r1,|L61.106|
000046  2904              CMP      r1,#4                 ;896
000048  d012              BEQ      |L61.112|
00004a  2908              CMP      r1,#8                 ;896
00004c  d013              BEQ      |L61.118|
00004e  290c              CMP      r1,#0xc               ;896
000050  d014              BEQ      |L61.124|
000052  2910              CMP      r1,#0x10              ;896
000054  d015              BEQ      |L61.130|
000056  f8840043          STRB     r0,[r4,#0x43]         ;896
                  |L61.90|
00005a  b1a9              CBZ      r1,|L61.136|
00005c  2904              CMP      r1,#4                 ;898
00005e  d019              BEQ      |L61.148|
000060  2908              CMP      r1,#8                 ;898
000062  d01d              BEQ      |L61.160|
000064  290c              CMP      r1,#0xc               ;898
000066  d126              BNE      |L61.182|
000068  e020              B        |L61.172|
                  |L61.106|
00006a  f884003e          STRB     r0,[r4,#0x3e]         ;896
00006e  e7f4              B        |L61.90|
                  |L61.112|
000070  f884003f          STRB     r0,[r4,#0x3f]         ;896
000074  e7f1              B        |L61.90|
                  |L61.118|
000076  f8840040          STRB     r0,[r4,#0x40]         ;896
00007a  e7ee              B        |L61.90|
                  |L61.124|
00007c  f8840041          STRB     r0,[r4,#0x41]         ;896
000080  e7eb              B        |L61.90|
                  |L61.130|
000082  f8840042          STRB     r0,[r4,#0x42]         ;896
000086  e7e8              B        |L61.90|
                  |L61.136|
000088  6820              LDR      r0,[r4,#0]            ;903
00008a  68c2              LDR      r2,[r0,#0xc]          ;903
00008c  f0420202          ORR      r2,r2,#2              ;903
000090  60c2              STR      r2,[r0,#0xc]          ;903
000092  e010              B        |L61.182|
                  |L61.148|
000094  6820              LDR      r0,[r4,#0]            ;910
000096  68c2              LDR      r2,[r0,#0xc]          ;910
000098  f0420204          ORR      r2,r2,#4              ;910
00009c  60c2              STR      r2,[r0,#0xc]          ;910
00009e  e00a              B        |L61.182|
                  |L61.160|
0000a0  6820              LDR      r0,[r4,#0]            ;917
0000a2  68c2              LDR      r2,[r0,#0xc]          ;917
0000a4  f0420208          ORR      r2,r2,#8              ;917
0000a8  60c2              STR      r2,[r0,#0xc]          ;917
0000aa  e004              B        |L61.182|
                  |L61.172|
0000ac  6820              LDR      r0,[r4,#0]            ;924
0000ae  68c2              LDR      r2,[r0,#0xc]          ;924
0000b0  f0420210          ORR      r2,r2,#0x10           ;924
0000b4  60c2              STR      r2,[r0,#0xc]          ;924
                  |L61.182|
0000b6  2201              MOVS     r2,#1                 ;933
0000b8  6820              LDR      r0,[r4,#0]            ;933
0000ba  f7fffffe          BL       TIM_CCxChannelCmd
0000be  491d              LDR      r1,|L61.308|
0000c0  6820              LDR      r0,[r4,#0]            ;935
0000c2  4a1d              LDR      r2,|L61.312|
0000c4  4b1d              LDR      r3,|L61.316|
0000c6  4288              CMP      r0,r1                 ;935
0000c8  d009              BEQ      |L61.222|
0000ca  4290              CMP      r0,r2                 ;935
0000cc  d007              BEQ      |L61.222|
0000ce  4298              CMP      r0,r3                 ;935
0000d0  d005              BEQ      |L61.222|
0000d2  4d1b              LDR      r5,|L61.320|
0000d4  42a8              CMP      r0,r5                 ;935
0000d6  d002              BEQ      |L61.222|
0000d8  4d1a              LDR      r5,|L61.324|
0000da  42a8              CMP      r0,r5                 ;935
0000dc  d103              BNE      |L61.230|
                  |L61.222|
0000de  6c45              LDR      r5,[r0,#0x44]         ;938
0000e0  f4454500          ORR      r5,r5,#0x8000         ;938
0000e4  6445              STR      r5,[r0,#0x44]         ;938
                  |L61.230|
0000e6  6820              LDR      r0,[r4,#0]            ;942
0000e8  4288              CMP      r0,r1                 ;942
0000ea  d00f              BEQ      |L61.268|
0000ec  f1b04f80          CMP      r0,#0x40000000        ;942
0000f0  d00c              BEQ      |L61.268|
0000f2  4915              LDR      r1,|L61.328|
0000f4  4288              CMP      r0,r1                 ;942
0000f6  d009              BEQ      |L61.268|
0000f8  4914              LDR      r1,|L61.332|
0000fa  4288              CMP      r0,r1                 ;942
0000fc  d006              BEQ      |L61.268|
0000fe  4914              LDR      r1,|L61.336|
000100  4288              CMP      r0,r1                 ;942
000102  d003              BEQ      |L61.268|
000104  4290              CMP      r0,r2                 ;942
000106  d001              BEQ      |L61.268|
000108  4298              CMP      r0,r3                 ;942
00010a  d10c              BNE      |L61.294|
                  |L61.268|
00010c  6881              LDR      r1,[r0,#8]            ;944
00010e  4a11              LDR      r2,|L61.340|
000110  4011              ANDS     r1,r1,r2              ;944
000112  2906              CMP      r1,#6                 ;945
000114  d00b              BEQ      |L61.302|
000116  f5b13f80          CMP      r1,#0x10000           ;945
00011a  d008              BEQ      |L61.302|
00011c  6801              LDR      r1,[r0,#0]            ;947
00011e  f0410101          ORR      r1,r1,#1              ;947
000122  6001              STR      r1,[r0,#0]            ;947
000124  e003              B        |L61.302|
                  |L61.294|
000126  6801              LDR      r1,[r0,#0]            ;952
000128  f0410101          ORR      r1,r1,#1              ;952
00012c  6001              STR      r1,[r0,#0]            ;952
                  |L61.302|
00012e  2000              MOVS     r0,#0                 ;956
000130  bd30              POP      {r4,r5,pc}
;;;958    
                          ENDP

000132  0000              DCW      0x0000
                  |L61.308|
                          DCD      0x40012c00
                  |L61.312|
                          DCD      0x40013400
                  |L61.316|
                          DCD      0x40014000
                  |L61.320|
                          DCD      0x40014400
                  |L61.324|
                          DCD      0x40014800
                  |L61.328|
                          DCD      0x40000400
                  |L61.332|
                          DCD      0x40000800
                  |L61.336|
                          DCD      0x40000c00
                  |L61.340|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;846      */
;;;847    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;848    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;849      /* Check the parameters */
;;;850      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;851    
;;;852      /* Disable the Output compare channel */
;;;853      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;854    
;;;855      if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  4922              LDR      r1,|L62.156|
;;;856      {
;;;857        /* Disable the Main Output */
;;;858        __HAL_TIM_MOE_DISABLE(htim);
000012  f2411211          MOV      r2,#0x1111
000016  6820              LDR      r0,[r4,#0]            ;855
000018  1093              ASRS     r3,r2,#2
00001a  4288              CMP      r0,r1                 ;855
00001c  d00b              BEQ      |L62.54|
00001e  4920              LDR      r1,|L62.160|
000020  4288              CMP      r0,r1                 ;855
000022  d008              BEQ      |L62.54|
000024  491f              LDR      r1,|L62.164|
000026  4288              CMP      r0,r1                 ;855
000028  d005              BEQ      |L62.54|
00002a  491f              LDR      r1,|L62.168|
00002c  4288              CMP      r0,r1                 ;855
00002e  d002              BEQ      |L62.54|
000030  491e              LDR      r1,|L62.172|
000032  4288              CMP      r0,r1                 ;855
000034  d109              BNE      |L62.74|
                  |L62.54|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d106              BNE      |L62.74|
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4219              TST      r1,r3
000040  d103              BNE      |L62.74|
000042  6c41              LDR      r1,[r0,#0x44]
000044  f4214100          BIC      r1,r1,#0x8000
000048  6441              STR      r1,[r0,#0x44]
                  |L62.74|
;;;859      }
;;;860    
;;;861      /* Disable the Peripheral */
;;;862      __HAL_TIM_DISABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6a01              LDR      r1,[r0,#0x20]
00004e  4211              TST      r1,r2
000050  d106              BNE      |L62.96|
000052  6a01              LDR      r1,[r0,#0x20]
000054  4219              TST      r1,r3
000056  d103              BNE      |L62.96|
000058  6801              LDR      r1,[r0,#0]
00005a  f0210101          BIC      r1,r1,#1
00005e  6001              STR      r1,[r0,#0]
                  |L62.96|
;;;863    
;;;864      /* Set the TIM channel state */
;;;865      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000060  2001              MOVS     r0,#1
000062  b15d              CBZ      r5,|L62.124|
000064  2d04              CMP      r5,#4
000066  d00c              BEQ      |L62.130|
000068  2d08              CMP      r5,#8
00006a  d00d              BEQ      |L62.136|
00006c  2d0c              CMP      r5,#0xc
00006e  d00e              BEQ      |L62.142|
000070  2d10              CMP      r5,#0x10
000072  d00f              BEQ      |L62.148|
000074  f8840043          STRB     r0,[r4,#0x43]
                  |L62.120|
;;;866    
;;;867      /* Return function status */
;;;868      return HAL_OK;
000078  2000              MOVS     r0,#0
;;;869    }
00007a  bd30              POP      {r4,r5,pc}
                  |L62.124|
00007c  f884003e          STRB     r0,[r4,#0x3e]         ;865
000080  e7fa              B        |L62.120|
                  |L62.130|
000082  f884003f          STRB     r0,[r4,#0x3f]         ;865
000086  e7f7              B        |L62.120|
                  |L62.136|
000088  f8840040          STRB     r0,[r4,#0x40]         ;865
00008c  e7f4              B        |L62.120|
                  |L62.142|
00008e  f8840041          STRB     r0,[r4,#0x41]         ;865
000092  e7f1              B        |L62.120|
                  |L62.148|
000094  f8840042          STRB     r0,[r4,#0x42]         ;865
000098  e7ee              B        |L62.120|
;;;870    
                          ENDP

00009a  0000              DCW      0x0000
                  |L62.156|
                          DCD      0x40012c00
                  |L62.160|
                          DCD      0x40013400
                  |L62.164|
                          DCD      0x40014000
                  |L62.168|
                          DCD      0x40014400
                  |L62.172|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;1194     */
;;;1195   HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1196   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1197     /* Check the parameters */
;;;1198     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1199   
;;;1200     switch (Channel)
;;;1201     {
;;;1202       case TIM_CHANNEL_1:
;;;1203       {
;;;1204         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1205         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;1200
00000a  d006              BEQ      |L63.26|
00000c  2d04              CMP      r5,#4                 ;1200
00000e  d00c              BEQ      |L63.42|
000010  2d08              CMP      r5,#8                 ;1200
000012  d012              BEQ      |L63.58|
000014  2d0c              CMP      r5,#0xc               ;1200
000016  d11f              BNE      |L63.88|
000018  e017              B        |L63.74|
                  |L63.26|
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  f4217100          BIC      r1,r1,#0x200
000020  60c1              STR      r1,[r0,#0xc]
;;;1206         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000022  6a60              LDR      r0,[r4,#0x24]
000024  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1207         break;
000028  e016              B        |L63.88|
                  |L63.42|
;;;1208       }
;;;1209   
;;;1210       case TIM_CHANNEL_2:
;;;1211       {
;;;1212         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1213         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4216180          BIC      r1,r1,#0x400
000030  60c1              STR      r1,[r0,#0xc]
;;;1214         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000032  6aa0              LDR      r0,[r4,#0x28]
000034  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1215         break;
000038  e00e              B        |L63.88|
                  |L63.58|
;;;1216       }
;;;1217   
;;;1218       case TIM_CHANNEL_3:
;;;1219       {
;;;1220         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1221         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00003a  68c1              LDR      r1,[r0,#0xc]
00003c  f4216100          BIC      r1,r1,#0x800
000040  60c1              STR      r1,[r0,#0xc]
;;;1222         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
000042  6ae0              LDR      r0,[r4,#0x2c]
000044  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1223         break;
000048  e006              B        |L63.88|
                  |L63.74|
;;;1224       }
;;;1225   
;;;1226       case TIM_CHANNEL_4:
;;;1227       {
;;;1228         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1229         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00004a  68c1              LDR      r1,[r0,#0xc]
00004c  f4215180          BIC      r1,r1,#0x1000
000050  60c1              STR      r1,[r0,#0xc]
;;;1230         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
000052  6b20              LDR      r0,[r4,#0x30]
000054  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L63.88|
;;;1231         break;
;;;1232       }
;;;1233   
;;;1234       default:
;;;1235         break;
;;;1236     }
;;;1237   
;;;1238     /* Disable the Output compare channel */
;;;1239     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000058  2200              MOVS     r2,#0
00005a  4629              MOV      r1,r5
00005c  6820              LDR      r0,[r4,#0]
00005e  f7fffffe          BL       TIM_CCxChannelCmd
;;;1240   
;;;1241     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000062  4a22              LDR      r2,|L63.236|
;;;1242     {
;;;1243       /* Disable the Main Output */
;;;1244       __HAL_TIM_MOE_DISABLE(htim);
000064  f2411111          MOV      r1,#0x1111
000068  6820              LDR      r0,[r4,#0]            ;1241
00006a  108b              ASRS     r3,r1,#2
00006c  4290              CMP      r0,r2                 ;1241
00006e  d00b              BEQ      |L63.136|
000070  4a1f              LDR      r2,|L63.240|
000072  4290              CMP      r0,r2                 ;1241
000074  d008              BEQ      |L63.136|
000076  4a1f              LDR      r2,|L63.244|
000078  4290              CMP      r0,r2                 ;1241
00007a  d005              BEQ      |L63.136|
00007c  4a1e              LDR      r2,|L63.248|
00007e  4290              CMP      r0,r2                 ;1241
000080  d002              BEQ      |L63.136|
000082  4a1e              LDR      r2,|L63.252|
000084  4290              CMP      r0,r2                 ;1241
000086  d109              BNE      |L63.156|
                  |L63.136|
000088  6a02              LDR      r2,[r0,#0x20]
00008a  420a              TST      r2,r1
00008c  d106              BNE      |L63.156|
00008e  6a02              LDR      r2,[r0,#0x20]
000090  421a              TST      r2,r3
000092  d103              BNE      |L63.156|
000094  6c42              LDR      r2,[r0,#0x44]
000096  f4224200          BIC      r2,r2,#0x8000
00009a  6442              STR      r2,[r0,#0x44]
                  |L63.156|
;;;1245     }
;;;1246   
;;;1247     /* Disable the Peripheral */
;;;1248     __HAL_TIM_DISABLE(htim);
00009c  6820              LDR      r0,[r4,#0]
00009e  6a02              LDR      r2,[r0,#0x20]
0000a0  420a              TST      r2,r1
0000a2  d106              BNE      |L63.178|
0000a4  6a01              LDR      r1,[r0,#0x20]
0000a6  4219              TST      r1,r3
0000a8  d103              BNE      |L63.178|
0000aa  6801              LDR      r1,[r0,#0]
0000ac  f0210101          BIC      r1,r1,#1
0000b0  6001              STR      r1,[r0,#0]
                  |L63.178|
;;;1249   
;;;1250     /* Set the TIM channel state */
;;;1251     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
0000b2  2001              MOVS     r0,#1
0000b4  b15d              CBZ      r5,|L63.206|
0000b6  2d04              CMP      r5,#4
0000b8  d00c              BEQ      |L63.212|
0000ba  2d08              CMP      r5,#8
0000bc  d00d              BEQ      |L63.218|
0000be  2d0c              CMP      r5,#0xc
0000c0  d00e              BEQ      |L63.224|
0000c2  2d10              CMP      r5,#0x10
0000c4  d00f              BEQ      |L63.230|
0000c6  f8840043          STRB     r0,[r4,#0x43]
                  |L63.202|
;;;1252   
;;;1253     /* Return function status */
;;;1254     return HAL_OK;
0000ca  2000              MOVS     r0,#0
;;;1255   }
0000cc  bd70              POP      {r4-r6,pc}
                  |L63.206|
0000ce  f884003e          STRB     r0,[r4,#0x3e]         ;1251
0000d2  e7fa              B        |L63.202|
                  |L63.212|
0000d4  f884003f          STRB     r0,[r4,#0x3f]         ;1251
0000d8  e7f7              B        |L63.202|
                  |L63.218|
0000da  f8840040          STRB     r0,[r4,#0x40]         ;1251
0000de  e7f4              B        |L63.202|
                  |L63.224|
0000e0  f8840041          STRB     r0,[r4,#0x41]         ;1251
0000e4  e7f1              B        |L63.202|
                  |L63.230|
0000e6  f8840042          STRB     r0,[r4,#0x42]         ;1251
0000ea  e7ee              B        |L63.202|
;;;1256   
                          ENDP

                  |L63.236|
                          DCD      0x40012c00
                  |L63.240|
                          DCD      0x40013400
                  |L63.244|
                          DCD      0x40014000
                  |L63.248|
                          DCD      0x40014400
                  |L63.252|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;969      */
;;;970    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;971    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;972      /* Check the parameters */
;;;973      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;974    
;;;975      switch (Channel)
;;;976      {
;;;977        case TIM_CHANNEL_1:
;;;978        {
;;;979          /* Disable the TIM Capture/Compare 1 interrupt */
;;;980          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;975
00000a  d006              BEQ      |L64.26|
00000c  2d04              CMP      r5,#4                 ;975
00000e  d009              BEQ      |L64.36|
000010  2d08              CMP      r5,#8                 ;975
000012  d00c              BEQ      |L64.46|
000014  2d0c              CMP      r5,#0xc               ;975
000016  d113              BNE      |L64.64|
000018  e00e              B        |L64.56|
                  |L64.26|
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  f0210102          BIC      r1,r1,#2
000020  60c1              STR      r1,[r0,#0xc]
;;;981          break;
000022  e00d              B        |L64.64|
                  |L64.36|
;;;982        }
;;;983    
;;;984        case TIM_CHANNEL_2:
;;;985        {
;;;986          /* Disable the TIM Capture/Compare 2 interrupt */
;;;987          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  68c1              LDR      r1,[r0,#0xc]
000026  f0210104          BIC      r1,r1,#4
00002a  60c1              STR      r1,[r0,#0xc]
;;;988          break;
00002c  e008              B        |L64.64|
                  |L64.46|
;;;989        }
;;;990    
;;;991        case TIM_CHANNEL_3:
;;;992        {
;;;993          /* Disable the TIM Capture/Compare 3 interrupt */
;;;994          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002e  68c1              LDR      r1,[r0,#0xc]
000030  f0210108          BIC      r1,r1,#8
000034  60c1              STR      r1,[r0,#0xc]
;;;995          break;
000036  e003              B        |L64.64|
                  |L64.56|
;;;996        }
;;;997    
;;;998        case TIM_CHANNEL_4:
;;;999        {
;;;1000         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1001         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000038  68c1              LDR      r1,[r0,#0xc]
00003a  f0210110          BIC      r1,r1,#0x10
00003e  60c1              STR      r1,[r0,#0xc]
                  |L64.64|
;;;1002         break;
;;;1003       }
;;;1004   
;;;1005       default:
;;;1006         break;
;;;1007     }
;;;1008   
;;;1009     /* Disable the Output compare channel */
;;;1010     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000040  2200              MOVS     r2,#0
000042  4629              MOV      r1,r5
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       TIM_CCxChannelCmd
;;;1011   
;;;1012     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00004a  4922              LDR      r1,|L64.212|
;;;1013     {
;;;1014       /* Disable the Main Output */
;;;1015       __HAL_TIM_MOE_DISABLE(htim);
00004c  f2411211          MOV      r2,#0x1111
000050  6820              LDR      r0,[r4,#0]            ;1012
000052  1093              ASRS     r3,r2,#2
000054  4288              CMP      r0,r1                 ;1012
000056  d00b              BEQ      |L64.112|
000058  491f              LDR      r1,|L64.216|
00005a  4288              CMP      r0,r1                 ;1012
00005c  d008              BEQ      |L64.112|
00005e  491f              LDR      r1,|L64.220|
000060  4288              CMP      r0,r1                 ;1012
000062  d005              BEQ      |L64.112|
000064  491e              LDR      r1,|L64.224|
000066  4288              CMP      r0,r1                 ;1012
000068  d002              BEQ      |L64.112|
00006a  491e              LDR      r1,|L64.228|
00006c  4288              CMP      r0,r1                 ;1012
00006e  d109              BNE      |L64.132|
                  |L64.112|
000070  6a01              LDR      r1,[r0,#0x20]
000072  4211              TST      r1,r2
000074  d106              BNE      |L64.132|
000076  6a01              LDR      r1,[r0,#0x20]
000078  4219              TST      r1,r3
00007a  d103              BNE      |L64.132|
00007c  6c41              LDR      r1,[r0,#0x44]
00007e  f4214100          BIC      r1,r1,#0x8000
000082  6441              STR      r1,[r0,#0x44]
                  |L64.132|
;;;1016     }
;;;1017   
;;;1018     /* Disable the Peripheral */
;;;1019     __HAL_TIM_DISABLE(htim);
000084  6820              LDR      r0,[r4,#0]
000086  6a01              LDR      r1,[r0,#0x20]
000088  4211              TST      r1,r2
00008a  d106              BNE      |L64.154|
00008c  6a01              LDR      r1,[r0,#0x20]
00008e  4219              TST      r1,r3
000090  d103              BNE      |L64.154|
000092  6801              LDR      r1,[r0,#0]
000094  f0210101          BIC      r1,r1,#1
000098  6001              STR      r1,[r0,#0]
                  |L64.154|
;;;1020   
;;;1021     /* Set the TIM channel state */
;;;1022     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
00009a  2001              MOVS     r0,#1
00009c  b15d              CBZ      r5,|L64.182|
00009e  2d04              CMP      r5,#4
0000a0  d00c              BEQ      |L64.188|
0000a2  2d08              CMP      r5,#8
0000a4  d00d              BEQ      |L64.194|
0000a6  2d0c              CMP      r5,#0xc
0000a8  d00e              BEQ      |L64.200|
0000aa  2d10              CMP      r5,#0x10
0000ac  d00f              BEQ      |L64.206|
0000ae  f8840043          STRB     r0,[r4,#0x43]
                  |L64.178|
;;;1023   
;;;1024     /* Return function status */
;;;1025     return HAL_OK;
0000b2  2000              MOVS     r0,#0
;;;1026   }
0000b4  bd30              POP      {r4,r5,pc}
                  |L64.182|
0000b6  f884003e          STRB     r0,[r4,#0x3e]         ;1022
0000ba  e7fa              B        |L64.178|
                  |L64.188|
0000bc  f884003f          STRB     r0,[r4,#0x3f]         ;1022
0000c0  e7f7              B        |L64.178|
                  |L64.194|
0000c2  f8840040          STRB     r0,[r4,#0x40]         ;1022
0000c6  e7f4              B        |L64.178|
                  |L64.200|
0000c8  f8840041          STRB     r0,[r4,#0x41]         ;1022
0000cc  e7f1              B        |L64.178|
                  |L64.206|
0000ce  f8840042          STRB     r0,[r4,#0x42]         ;1022
0000d2  e7ee              B        |L64.178|
;;;1027   
                          ENDP

                  |L64.212|
                          DCD      0x40012c00
                  |L64.216|
                          DCD      0x40013400
                  |L64.220|
                          DCD      0x40014000
                  |L64.224|
                          DCD      0x40014400
                  |L64.228|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;4306     */
;;;4307   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4308                                                    uint32_t OutputChannel,  uint32_t InputChannel)
;;;4309   {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4698              MOV      r8,r3
;;;4310     TIM_OC_InitTypeDef temp1;
;;;4311   
;;;4312     /* Check the parameters */
;;;4313     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;4314     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;4315   
;;;4316     if (OutputChannel != InputChannel)
00000c  4542              CMP      r2,r8
00000e  d06f              BEQ      |L65.240|
;;;4317     {
;;;4318       /* Process Locked */
;;;4319       __HAL_LOCK(htim);
000010  f894003c          LDRB     r0,[r4,#0x3c]
000014  2801              CMP      r0,#1
000016  d015              BEQ      |L65.68|
000018  2601              MOVS     r6,#1
00001a  f884603c          STRB     r6,[r4,#0x3c]
;;;4320   
;;;4321       htim->State = HAL_TIM_STATE_BUSY;
00001e  2002              MOVS     r0,#2
000020  f884003d          STRB     r0,[r4,#0x3d]
;;;4322   
;;;4323       /* Extract the Output compare configuration from sConfig structure */
;;;4324       temp1.OCMode = sConfig->OCMode;
000024  6828              LDR      r0,[r5,#0]
000026  9001              STR      r0,[sp,#4]
;;;4325       temp1.Pulse = sConfig->Pulse;
000028  6868              LDR      r0,[r5,#4]
00002a  9002              STR      r0,[sp,#8]
;;;4326       temp1.OCPolarity = sConfig->OCPolarity;
00002c  68a8              LDR      r0,[r5,#8]
00002e  9003              STR      r0,[sp,#0xc]
;;;4327       temp1.OCNPolarity = sConfig->OCNPolarity;
000030  68e8              LDR      r0,[r5,#0xc]
000032  9004              STR      r0,[sp,#0x10]
;;;4328       temp1.OCIdleState = sConfig->OCIdleState;
000034  6928              LDR      r0,[r5,#0x10]
000036  9006              STR      r0,[sp,#0x18]
;;;4329       temp1.OCNIdleState = sConfig->OCNIdleState;
000038  6968              LDR      r0,[r5,#0x14]
00003a  9007              STR      r0,[sp,#0x1c]
00003c  b132              CBZ      r2,|L65.76|
;;;4330   
;;;4331       switch (OutputChannel)
00003e  2a04              CMP      r2,#4
000040  d10d              BNE      |L65.94|
000042  e008              B        |L65.86|
                  |L65.68|
000044  2002              MOVS     r0,#2                 ;4319
                  |L65.70|
;;;4332       {
;;;4333         case TIM_CHANNEL_1:
;;;4334         {
;;;4335           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4336   
;;;4337           TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;4338           break;
;;;4339         }
;;;4340         case TIM_CHANNEL_2:
;;;4341         {
;;;4342           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4343   
;;;4344           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;4345           break;
;;;4346         }
;;;4347         default:
;;;4348           break;
;;;4349       }
;;;4350   
;;;4351       switch (InputChannel)
;;;4352       {
;;;4353         case TIM_CHANNEL_1:
;;;4354         {
;;;4355           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4356   
;;;4357           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;4358                             sConfig->ICSelection, sConfig->ICFilter);
;;;4359   
;;;4360           /* Reset the IC1PSC Bits */
;;;4361           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;4362   
;;;4363           /* Select the Trigger source */
;;;4364           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;4365           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;4366   
;;;4367           /* Select the Slave Mode */
;;;4368           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;4369           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;4370           break;
;;;4371         }
;;;4372         case TIM_CHANNEL_2:
;;;4373         {
;;;4374           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4375   
;;;4376           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;4377                             sConfig->ICSelection, sConfig->ICFilter);
;;;4378   
;;;4379           /* Reset the IC2PSC Bits */
;;;4380           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;4381   
;;;4382           /* Select the Trigger source */
;;;4383           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;4384           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;4385   
;;;4386           /* Select the Slave Mode */
;;;4387           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;4388           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;4389           break;
;;;4390         }
;;;4391   
;;;4392         default:
;;;4393           break;
;;;4394       }
;;;4395   
;;;4396       htim->State = HAL_TIM_STATE_READY;
;;;4397   
;;;4398       __HAL_UNLOCK(htim);
;;;4399   
;;;4400       return HAL_OK;
;;;4401     }
;;;4402     else
;;;4403     {
;;;4404       return HAL_ERROR;
;;;4405     }
;;;4406   }
000046  b008              ADD      sp,sp,#0x20
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L65.76|
00004c  a901              ADD      r1,sp,#4              ;4337
00004e  6820              LDR      r0,[r4,#0]            ;4337
000050  f7fffffe          BL       TIM_OC1_SetConfig
000054  e003              B        |L65.94|
                  |L65.86|
000056  a901              ADD      r1,sp,#4              ;4344
000058  6820              LDR      r0,[r4,#0]            ;4344
00005a  f7fffffe          BL       TIM_OC2_SetConfig
                  |L65.94|
00005e  4f25              LDR      r7,|L65.244|
000060  f1b80f00          CMP      r8,#0                 ;4351
000064  d003              BEQ      |L65.110|
000066  f1b80f04          CMP      r8,#4                 ;4351
00006a  d13b              BNE      |L65.228|
00006c  e01d              B        |L65.170|
                  |L65.110|
00006e  3518              ADDS     r5,r5,#0x18           ;4357
000070  6820              LDR      r0,[r4,#0]            ;4357
000072  cd0e              LDM      r5!,{r1-r3}           ;4357
000074  f7fffffe          BL       TIM_TI1_SetConfig
000078  6820              LDR      r0,[r4,#0]            ;4361
00007a  6981              LDR      r1,[r0,#0x18]         ;4361
00007c  f021010c          BIC      r1,r1,#0xc            ;4361
000080  6181              STR      r1,[r0,#0x18]         ;4361
000082  6820              LDR      r0,[r4,#0]            ;4364
000084  6881              LDR      r1,[r0,#8]            ;4364
000086  f0210170          BIC      r1,r1,#0x70           ;4364
00008a  6081              STR      r1,[r0,#8]            ;4364
00008c  6820              LDR      r0,[r4,#0]            ;4365
00008e  6881              LDR      r1,[r0,#8]            ;4365
000090  f0410150          ORR      r1,r1,#0x50           ;4365
000094  6081              STR      r1,[r0,#8]            ;4365
000096  6820              LDR      r0,[r4,#0]            ;4368
000098  6881              LDR      r1,[r0,#8]            ;4368
00009a  4039              ANDS     r1,r1,r7              ;4368
00009c  6081              STR      r1,[r0,#8]            ;4368
00009e  6820              LDR      r0,[r4,#0]            ;4369
0000a0  6881              LDR      r1,[r0,#8]            ;4369
0000a2  f0410106          ORR      r1,r1,#6              ;4369
0000a6  6081              STR      r1,[r0,#8]            ;4369
0000a8  e01c              B        |L65.228|
                  |L65.170|
0000aa  3518              ADDS     r5,r5,#0x18           ;4376
0000ac  6820              LDR      r0,[r4,#0]            ;4376
0000ae  cd0e              LDM      r5!,{r1-r3}           ;4376
0000b0  f7fffffe          BL       TIM_TI2_SetConfig
0000b4  6820              LDR      r0,[r4,#0]            ;4380
0000b6  6981              LDR      r1,[r0,#0x18]         ;4380
0000b8  f4216140          BIC      r1,r1,#0xc00          ;4380
0000bc  6181              STR      r1,[r0,#0x18]         ;4380
0000be  6820              LDR      r0,[r4,#0]            ;4383
0000c0  6881              LDR      r1,[r0,#8]            ;4383
0000c2  f0210170          BIC      r1,r1,#0x70           ;4383
0000c6  6081              STR      r1,[r0,#8]            ;4383
0000c8  6820              LDR      r0,[r4,#0]            ;4384
0000ca  6881              LDR      r1,[r0,#8]            ;4384
0000cc  f0410160          ORR      r1,r1,#0x60           ;4384
0000d0  6081              STR      r1,[r0,#8]            ;4384
0000d2  6820              LDR      r0,[r4,#0]            ;4387
0000d4  6881              LDR      r1,[r0,#8]            ;4387
0000d6  4039              ANDS     r1,r1,r7              ;4387
0000d8  6081              STR      r1,[r0,#8]            ;4387
0000da  6820              LDR      r0,[r4,#0]            ;4388
0000dc  6881              LDR      r1,[r0,#8]            ;4388
0000de  f0410106          ORR      r1,r1,#6              ;4388
0000e2  6081              STR      r1,[r0,#8]            ;4388
                  |L65.228|
0000e4  343c              ADDS     r4,r4,#0x3c           ;4396
0000e6  7066              STRB     r6,[r4,#1]            ;4396
0000e8  2000              MOVS     r0,#0                 ;4398
0000ea  7020              STRB     r0,[r4,#0]            ;4398
0000ec  e7ab              B        |L65.70|
0000ee  e7ff              B        |L65.240|
                  |L65.240|
0000f0  2001              MOVS     r0,#1                 ;4404
0000f2  e7a8              B        |L65.70|
;;;4407   
                          ENDP

                  |L65.244|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2620     */
;;;2621   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2622   {
000002  4604              MOV      r4,r0
;;;2623     /* Check the parameters */
;;;2624     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2625   
;;;2626     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;2627   
;;;2628     /* Disable the TIM Peripheral Clock */
;;;2629     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L66.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L66.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L66.38|
;;;2630   
;;;2631   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2632     if (htim->OnePulse_MspDeInitCallback == NULL)
;;;2633     {
;;;2634       htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
;;;2635     }
;;;2636     /* DeInit the low level hardware */
;;;2637     htim->OnePulse_MspDeInitCallback(htim);
;;;2638   #else
;;;2639     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2640     HAL_TIM_OnePulse_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2641   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2642   
;;;2643     /* Change the DMA burst operation state */
;;;2644     htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7320              STRB     r0,[r4,#0xc]
;;;2645   
;;;2646     /* Set the TIM channel state */
;;;2647     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
000032  70a0              STRB     r0,[r4,#2]
;;;2648     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
000034  70e0              STRB     r0,[r4,#3]
;;;2649     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
000036  7220              STRB     r0,[r4,#8]
;;;2650     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
000038  7260              STRB     r0,[r4,#9]
;;;2651   
;;;2652     /* Change TIM state */
;;;2653     htim->State = HAL_TIM_STATE_RESET;
00003a  7060              STRB     r0,[r4,#1]
;;;2654   
;;;2655     /* Release Lock */
;;;2656     __HAL_UNLOCK(htim);
00003c  7020              STRB     r0,[r4,#0]
;;;2657   
;;;2658     return HAL_OK;
;;;2659   }
00003e  bd10              POP      {r4,pc}
;;;2660   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;6342     */
;;;6343   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;6344   {
;;;6345     return htim->State;
;;;6346   }
000004  4770              BX       lr
;;;6347   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;2552     */
;;;2553   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2554   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2555     /* Check the TIM handle allocation */
;;;2556     if (htim == NULL)
000006  2c00              CMP      r4,#0
000008  d003              BEQ      |L68.18|
;;;2557     {
;;;2558       return HAL_ERROR;
;;;2559     }
;;;2560   
;;;2561     /* Check the parameters */
;;;2562     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2563     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2564     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2565     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2566     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2567   
;;;2568     if (htim->State == HAL_TIM_STATE_RESET)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  b110              CBZ      r0,|L68.22|
000010  e007              B        |L68.34|
                  |L68.18|
000012  2001              MOVS     r0,#1                 ;2558
;;;2569     {
;;;2570       /* Allocate lock resource and initialize it */
;;;2571       htim->Lock = HAL_UNLOCKED;
;;;2572   
;;;2573   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2574       /* Reset interrupt callbacks to legacy weak callbacks */
;;;2575       TIM_ResetCallback(htim);
;;;2576   
;;;2577       if (htim->OnePulse_MspInitCallback == NULL)
;;;2578       {
;;;2579         htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
;;;2580       }
;;;2581       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2582       htim->OnePulse_MspInitCallback(htim);
;;;2583   #else
;;;2584       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2585       HAL_TIM_OnePulse_MspInit(htim);
;;;2586   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2587     }
;;;2588   
;;;2589     /* Set the TIM state */
;;;2590     htim->State = HAL_TIM_STATE_BUSY;
;;;2591   
;;;2592     /* Configure the Time base in the One Pulse Mode */
;;;2593     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2594   
;;;2595     /* Reset the OPM Bit */
;;;2596     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2597   
;;;2598     /* Configure the OPM Mode */
;;;2599     htim->Instance->CR1 |= OnePulseMode;
;;;2600   
;;;2601     /* Initialize the DMA burst operation state */
;;;2602     htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
;;;2603   
;;;2604     /* Initialize the TIM channels state */
;;;2605     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
;;;2606     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
;;;2607     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
;;;2608     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
;;;2609   
;;;2610     /* Initialize the TIM state*/
;;;2611     htim->State = HAL_TIM_STATE_READY;
;;;2612   
;;;2613     return HAL_OK;
;;;2614   }
000014  bd70              POP      {r4-r6,pc}
                  |L68.22|
000016  2000              MOVS     r0,#0                 ;2571
000018  f884003c          STRB     r0,[r4,#0x3c]         ;2571
00001c  4620              MOV      r0,r4                 ;2585
00001e  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L68.34|
000022  2002              MOVS     r0,#2                 ;2590
000024  f884003d          STRB     r0,[r4,#0x3d]         ;2590
000028  1d21              ADDS     r1,r4,#4              ;2593
00002a  6820              LDR      r0,[r4,#0]            ;2593
00002c  f7fffffe          BL       TIM_Base_SetConfig
000030  3429              ADDS     r4,r4,#0x29           ;2596
000032  f8540c29          LDR      r0,[r4,#-0x29]        ;2596
000036  6801              LDR      r1,[r0,#0]            ;2596
000038  f0210108          BIC      r1,r1,#8              ;2596
00003c  6001              STR      r1,[r0,#0]            ;2596
00003e  f8540c29          LDR      r0,[r4,#-0x29]        ;2599
000042  6801              LDR      r1,[r0,#0]            ;2599
000044  4329              ORRS     r1,r1,r5              ;2599
000046  6001              STR      r1,[r0,#0]            ;2599
000048  2001              MOVS     r0,#1                 ;2602
00004a  77e0              STRB     r0,[r4,#0x1f]         ;2602
00004c  7560              STRB     r0,[r4,#0x15]         ;2605
00004e  75a0              STRB     r0,[r4,#0x16]         ;2606
000050  76e0              STRB     r0,[r4,#0x1b]         ;2607
000052  7720              STRB     r0,[r4,#0x1c]         ;2608
000054  7520              STRB     r0,[r4,#0x14]         ;2611
000056  2000              MOVS     r0,#0                 ;2613
000058  bd70              POP      {r4-r6,pc}
;;;2615   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2680     */
;;;2681   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2682   {
;;;2683     /* Prevent unused argument(s) compilation warning */
;;;2684     UNUSED(htim);
;;;2685   
;;;2686     /* NOTE : This function should not be modified, when the callback is needed,
;;;2687               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2688      */
;;;2689   }
;;;2690   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2665     */
;;;2666   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2667   {
;;;2668     /* Prevent unused argument(s) compilation warning */
;;;2669     UNUSED(htim);
;;;2670   
;;;2671     /* NOTE : This function should not be modified, when the callback is needed,
;;;2672               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2673      */
;;;2674   }
;;;2675   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2700     */
;;;2701   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2702   {
000002  4604              MOV      r4,r0
;;;2703     HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
000004  f8140f3e          LDRB     r0,[r4,#0x3e]!
;;;2704     HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
000008  7861              LDRB     r1,[r4,#1]
;;;2705     HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
00000a  79a2              LDRB     r2,[r4,#6]
;;;2706     HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
00000c  79e3              LDRB     r3,[r4,#7]
00000e  3c3e              SUBS     r4,r4,#0x3e
;;;2707   
;;;2708     /* Prevent unused argument(s) compilation warning */
;;;2709     UNUSED(OutputChannel);
;;;2710   
;;;2711     /* Check the TIM channels state */
;;;2712     if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000010  2801              CMP      r0,#1
000012  d105              BNE      |L71.32|
;;;2713         || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
000014  2901              CMP      r1,#1
000016  d103              BNE      |L71.32|
;;;2714         || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000018  2a01              CMP      r2,#1
00001a  d101              BNE      |L71.32|
;;;2715         || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
00001c  2b01              CMP      r3,#1
00001e  d001              BEQ      |L71.36|
                  |L71.32|
;;;2716     {
;;;2717       return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;2718     }
;;;2719   
;;;2720     /* Set the TIM channels state */
;;;2721     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2722     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2723     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2724     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2725   
;;;2726     /* Enable the Capture compare and the Input Capture channels
;;;2727       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2728       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2729       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2730       whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
;;;2731   
;;;2732       No need to enable the counter, it's enabled automatically by hardware
;;;2733       (the counter starts in response to a stimulus and generate a pulse */
;;;2734   
;;;2735     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2736     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2737   
;;;2738     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2739     {
;;;2740       /* Enable the main output */
;;;2741       __HAL_TIM_MOE_ENABLE(htim);
;;;2742     }
;;;2743   
;;;2744     /* Return function status */
;;;2745     return HAL_OK;
;;;2746   }
000022  bd10              POP      {r4,pc}
                  |L71.36|
000024  2002              MOVS     r0,#2                 ;2721
000026  f884003e          STRB     r0,[r4,#0x3e]         ;2721
00002a  f884003f          STRB     r0,[r4,#0x3f]         ;2722
00002e  f8840044          STRB     r0,[r4,#0x44]         ;2723
000032  f8840045          STRB     r0,[r4,#0x45]         ;2724
000036  2201              MOVS     r2,#1                 ;2735
000038  2100              MOVS     r1,#0                 ;2735
00003a  6820              LDR      r0,[r4,#0]            ;2735
00003c  f7fffffe          BL       TIM_CCxChannelCmd
000040  2201              MOVS     r2,#1                 ;2736
000042  2104              MOVS     r1,#4                 ;2736
000044  6820              LDR      r0,[r4,#0]            ;2736
000046  f7fffffe          BL       TIM_CCxChannelCmd
00004a  490b              LDR      r1,|L71.120|
00004c  6820              LDR      r0,[r4,#0]            ;2738
00004e  4288              CMP      r0,r1                 ;2738
000050  d00b              BEQ      |L71.106|
000052  490a              LDR      r1,|L71.124|
000054  4288              CMP      r0,r1                 ;2738
000056  d008              BEQ      |L71.106|
000058  4909              LDR      r1,|L71.128|
00005a  4288              CMP      r0,r1                 ;2738
00005c  d005              BEQ      |L71.106|
00005e  4909              LDR      r1,|L71.132|
000060  4288              CMP      r0,r1                 ;2738
000062  d002              BEQ      |L71.106|
000064  4908              LDR      r1,|L71.136|
000066  4288              CMP      r0,r1                 ;2738
000068  d103              BNE      |L71.114|
                  |L71.106|
00006a  6c41              LDR      r1,[r0,#0x44]         ;2741
00006c  f4414100          ORR      r1,r1,#0x8000         ;2741
000070  6441              STR      r1,[r0,#0x44]         ;2741
                  |L71.114|
000072  2000              MOVS     r0,#0                 ;2745
000074  bd10              POP      {r4,pc}
;;;2747   
                          ENDP

000076  0000              DCW      0x0000
                  |L71.120|
                          DCD      0x40012c00
                  |L71.124|
                          DCD      0x40013400
                  |L71.128|
                          DCD      0x40014000
                  |L71.132|
                          DCD      0x40014400
                  |L71.136|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2800     */
;;;2801   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2802   {
000002  4604              MOV      r4,r0
;;;2803     HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
000004  f8140f3e          LDRB     r0,[r4,#0x3e]!
;;;2804     HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
000008  7861              LDRB     r1,[r4,#1]
;;;2805     HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
00000a  79a2              LDRB     r2,[r4,#6]
;;;2806     HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
00000c  79e3              LDRB     r3,[r4,#7]
00000e  3c3e              SUBS     r4,r4,#0x3e
;;;2807   
;;;2808     /* Prevent unused argument(s) compilation warning */
;;;2809     UNUSED(OutputChannel);
;;;2810   
;;;2811     /* Check the TIM channels state */
;;;2812     if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000010  2801              CMP      r0,#1
000012  d105              BNE      |L72.32|
;;;2813         || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
000014  2901              CMP      r1,#1
000016  d103              BNE      |L72.32|
;;;2814         || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
000018  2a01              CMP      r2,#1
00001a  d101              BNE      |L72.32|
;;;2815         || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
00001c  2b01              CMP      r3,#1
00001e  d001              BEQ      |L72.36|
                  |L72.32|
;;;2816     {
;;;2817       return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;2818     }
;;;2819   
;;;2820     /* Set the TIM channels state */
;;;2821     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2822     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2823     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2824     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
;;;2825   
;;;2826     /* Enable the Capture compare and the Input Capture channels
;;;2827       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2828       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2829       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2830       whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
;;;2831   
;;;2832       No need to enable the counter, it's enabled automatically by hardware
;;;2833       (the counter starts in response to a stimulus and generate a pulse */
;;;2834   
;;;2835     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2836     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2837   
;;;2838     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2839     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2840   
;;;2841     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2842     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2843   
;;;2844     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2845     {
;;;2846       /* Enable the main output */
;;;2847       __HAL_TIM_MOE_ENABLE(htim);
;;;2848     }
;;;2849   
;;;2850     /* Return function status */
;;;2851     return HAL_OK;
;;;2852   }
000022  bd10              POP      {r4,pc}
                  |L72.36|
000024  2002              MOVS     r0,#2                 ;2821
000026  f884003e          STRB     r0,[r4,#0x3e]         ;2821
00002a  f884003f          STRB     r0,[r4,#0x3f]         ;2822
00002e  f8840044          STRB     r0,[r4,#0x44]         ;2823
000032  f8840045          STRB     r0,[r4,#0x45]         ;2824
000036  6820              LDR      r0,[r4,#0]            ;2836
000038  68c1              LDR      r1,[r0,#0xc]          ;2836
00003a  f0410102          ORR      r1,r1,#2              ;2836
00003e  60c1              STR      r1,[r0,#0xc]          ;2836
000040  6820              LDR      r0,[r4,#0]            ;2839
000042  68c1              LDR      r1,[r0,#0xc]          ;2839
000044  f0410104          ORR      r1,r1,#4              ;2839
000048  60c1              STR      r1,[r0,#0xc]          ;2839
00004a  2201              MOVS     r2,#1                 ;2841
00004c  2100              MOVS     r1,#0                 ;2841
00004e  6820              LDR      r0,[r4,#0]            ;2841
000050  f7fffffe          BL       TIM_CCxChannelCmd
000054  2201              MOVS     r2,#1                 ;2842
000056  2104              MOVS     r1,#4                 ;2842
000058  6820              LDR      r0,[r4,#0]            ;2842
00005a  f7fffffe          BL       TIM_CCxChannelCmd
00005e  490b              LDR      r1,|L72.140|
000060  6820              LDR      r0,[r4,#0]            ;2844
000062  4288              CMP      r0,r1                 ;2844
000064  d00b              BEQ      |L72.126|
000066  490a              LDR      r1,|L72.144|
000068  4288              CMP      r0,r1                 ;2844
00006a  d008              BEQ      |L72.126|
00006c  4909              LDR      r1,|L72.148|
00006e  4288              CMP      r0,r1                 ;2844
000070  d005              BEQ      |L72.126|
000072  4909              LDR      r1,|L72.152|
000074  4288              CMP      r0,r1                 ;2844
000076  d002              BEQ      |L72.126|
000078  4908              LDR      r1,|L72.156|
00007a  4288              CMP      r0,r1                 ;2844
00007c  d103              BNE      |L72.134|
                  |L72.126|
00007e  6c41              LDR      r1,[r0,#0x44]         ;2847
000080  f4414100          ORR      r1,r1,#0x8000         ;2847
000084  6441              STR      r1,[r0,#0x44]         ;2847
                  |L72.134|
000086  2000              MOVS     r0,#0                 ;2851
000088  bd10              POP      {r4,pc}
;;;2853   
                          ENDP

00008a  0000              DCW      0x0000
                  |L72.140|
                          DCD      0x40012c00
                  |L72.144|
                          DCD      0x40013400
                  |L72.148|
                          DCD      0x40014000
                  |L72.152|
                          DCD      0x40014400
                  |L72.156|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2757     */
;;;2758   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2759   {
000002  4604              MOV      r4,r0
;;;2760     /* Prevent unused argument(s) compilation warning */
;;;2761     UNUSED(OutputChannel);
;;;2762   
;;;2763     /* Disable the Capture compare and the Input Capture channels
;;;2764     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2765     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2766     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2767     whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2768   
;;;2769     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2770     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2771   
;;;2772     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000018  4817              LDR      r0,|L73.120|
;;;2773     {
;;;2774       /* Disable the Main Output */
;;;2775       __HAL_TIM_MOE_DISABLE(htim);
00001a  f2411311          MOV      r3,#0x1111
00001e  6821              LDR      r1,[r4,#0]            ;2772
000020  109a              ASRS     r2,r3,#2
000022  4281              CMP      r1,r0                 ;2772
000024  d00b              BEQ      |L73.62|
000026  4815              LDR      r0,|L73.124|
000028  4281              CMP      r1,r0                 ;2772
00002a  d008              BEQ      |L73.62|
00002c  4814              LDR      r0,|L73.128|
00002e  4281              CMP      r1,r0                 ;2772
000030  d005              BEQ      |L73.62|
000032  4814              LDR      r0,|L73.132|
000034  4281              CMP      r1,r0                 ;2772
000036  d002              BEQ      |L73.62|
000038  4813              LDR      r0,|L73.136|
00003a  4281              CMP      r1,r0                 ;2772
00003c  d109              BNE      |L73.82|
                  |L73.62|
00003e  6a08              LDR      r0,[r1,#0x20]
000040  4218              TST      r0,r3
000042  d106              BNE      |L73.82|
000044  6a08              LDR      r0,[r1,#0x20]
000046  4210              TST      r0,r2
000048  d103              BNE      |L73.82|
00004a  6c48              LDR      r0,[r1,#0x44]
00004c  f4204000          BIC      r0,r0,#0x8000
000050  6448              STR      r0,[r1,#0x44]
                  |L73.82|
;;;2776     }
;;;2777   
;;;2778     /* Disable the Peripheral */
;;;2779     __HAL_TIM_DISABLE(htim);
000052  6820              LDR      r0,[r4,#0]
000054  6a01              LDR      r1,[r0,#0x20]
000056  4219              TST      r1,r3
000058  d106              BNE      |L73.104|
00005a  6a01              LDR      r1,[r0,#0x20]
00005c  4211              TST      r1,r2
00005e  d103              BNE      |L73.104|
000060  6801              LDR      r1,[r0,#0]
000062  f0210101          BIC      r1,r1,#1
000066  6001              STR      r1,[r0,#0]
                  |L73.104|
;;;2780   
;;;2781     /* Set the TIM channels state */
;;;2782     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000068  2001              MOVS     r0,#1
00006a  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;2783     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00006e  7060              STRB     r0,[r4,#1]
;;;2784     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000070  71a0              STRB     r0,[r4,#6]
;;;2785     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000072  71e0              STRB     r0,[r4,#7]
;;;2786   
;;;2787     /* Return function status */
;;;2788     return HAL_OK;
000074  2000              MOVS     r0,#0
;;;2789   }
000076  bd10              POP      {r4,pc}
;;;2790   
                          ENDP

                  |L73.120|
                          DCD      0x40012c00
                  |L73.124|
                          DCD      0x40013400
                  |L73.128|
                          DCD      0x40014000
                  |L73.132|
                          DCD      0x40014400
                  |L73.136|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2863     */
;;;2864   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2865   {
000002  4604              MOV      r4,r0
;;;2866     /* Prevent unused argument(s) compilation warning */
;;;2867     UNUSED(OutputChannel);
;;;2868   
;;;2869     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2870     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0210102          BIC      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2871   
;;;2872     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2873     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210104          BIC      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2874   
;;;2875     /* Disable the Capture compare and the Input Capture channels
;;;2876     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2877     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2878     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2879     whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2880     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2881     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000022  2200              MOVS     r2,#0
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2882   
;;;2883     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00002c  4b17              LDR      r3,|L74.140|
;;;2884     {
;;;2885       /* Disable the Main Output */
;;;2886       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411211          MOV      r2,#0x1111
000032  6820              LDR      r0,[r4,#0]            ;2883
000034  1091              ASRS     r1,r2,#2
000036  4298              CMP      r0,r3                 ;2883
000038  d00b              BEQ      |L74.82|
00003a  4b15              LDR      r3,|L74.144|
00003c  4298              CMP      r0,r3                 ;2883
00003e  d008              BEQ      |L74.82|
000040  4b14              LDR      r3,|L74.148|
000042  4298              CMP      r0,r3                 ;2883
000044  d005              BEQ      |L74.82|
000046  4b14              LDR      r3,|L74.152|
000048  4298              CMP      r0,r3                 ;2883
00004a  d002              BEQ      |L74.82|
00004c  4b13              LDR      r3,|L74.156|
00004e  4298              CMP      r0,r3                 ;2883
000050  d109              BNE      |L74.102|
                  |L74.82|
000052  6a03              LDR      r3,[r0,#0x20]
000054  4213              TST      r3,r2
000056  d106              BNE      |L74.102|
000058  6a03              LDR      r3,[r0,#0x20]
00005a  420b              TST      r3,r1
00005c  d103              BNE      |L74.102|
00005e  6c43              LDR      r3,[r0,#0x44]
000060  f4234300          BIC      r3,r3,#0x8000
000064  6443              STR      r3,[r0,#0x44]
                  |L74.102|
;;;2887     }
;;;2888   
;;;2889     /* Disable the Peripheral */
;;;2890     __HAL_TIM_DISABLE(htim);
000066  6820              LDR      r0,[r4,#0]
000068  6a03              LDR      r3,[r0,#0x20]
00006a  4213              TST      r3,r2
00006c  d106              BNE      |L74.124|
00006e  6a02              LDR      r2,[r0,#0x20]
000070  420a              TST      r2,r1
000072  d103              BNE      |L74.124|
000074  6801              LDR      r1,[r0,#0]
000076  f0210101          BIC      r1,r1,#1
00007a  6001              STR      r1,[r0,#0]
                  |L74.124|
;;;2891   
;;;2892     /* Set the TIM channels state */
;;;2893     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00007c  2001              MOVS     r0,#1
00007e  f8040f3e          STRB     r0,[r4,#0x3e]!
;;;2894     TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000082  7060              STRB     r0,[r4,#1]
;;;2895     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000084  71a0              STRB     r0,[r4,#6]
;;;2896     TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000086  71e0              STRB     r0,[r4,#7]
;;;2897   
;;;2898     /* Return function status */
;;;2899     return HAL_OK;
000088  2000              MOVS     r0,#0
;;;2900   }
00008a  bd10              POP      {r4,pc}
;;;2901   
                          ENDP

                  |L74.140|
                          DCD      0x40012c00
                  |L74.144|
                          DCD      0x40013400
                  |L74.148|
                          DCD      0x40014000
                  |L74.152|
                          DCD      0x40014400
                  |L74.156|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;4161     */
;;;4162   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4163                                               TIM_OC_InitTypeDef *sConfig,
;;;4164                                               uint32_t Channel)
;;;4165   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4166     /* Check the parameters */
;;;4167     assert_param(IS_TIM_CHANNELS(Channel));
;;;4168     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;4169     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;4170     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;4171   
;;;4172     /* Process Locked */
;;;4173     __HAL_LOCK(htim);
000006  f894003c          LDRB     r0,[r4,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d00b              BEQ      |L75.38|
00000e  2001              MOVS     r0,#1
000010  f884003c          STRB     r0,[r4,#0x3c]
;;;4174   
;;;4175     switch (Channel)
000014  2a0c              CMP      r2,#0xc
000016  d04a              BEQ      |L75.174|
000018  dc07              BGT      |L75.42|
00001a  b15a              CBZ      r2,|L75.52|
00001c  2a04              CMP      r2,#4
00001e  d01d              BEQ      |L75.92|
000020  2a08              CMP      r2,#8
000022  d11a              BNE      |L75.90|
000024  e02f              B        |L75.134|
                  |L75.38|
000026  2002              MOVS     r0,#2                 ;4173
;;;4176     {
;;;4177       case TIM_CHANNEL_1:
;;;4178       {
;;;4179         /* Check the parameters */
;;;4180         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4181   
;;;4182         /* Configure the Channel 1 in PWM mode */
;;;4183         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;4184   
;;;4185         /* Set the Preload enable bit for channel1 */
;;;4186         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;4187   
;;;4188         /* Configure the Output Fast mode */
;;;4189         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;4190         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;4191         break;
;;;4192       }
;;;4193   
;;;4194       case TIM_CHANNEL_2:
;;;4195       {
;;;4196         /* Check the parameters */
;;;4197         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4198   
;;;4199         /* Configure the Channel 2 in PWM mode */
;;;4200         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;4201   
;;;4202         /* Set the Preload enable bit for channel2 */
;;;4203         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;4204   
;;;4205         /* Configure the Output Fast mode */
;;;4206         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;4207         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
;;;4208         break;
;;;4209       }
;;;4210   
;;;4211       case TIM_CHANNEL_3:
;;;4212       {
;;;4213         /* Check the parameters */
;;;4214         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4215   
;;;4216         /* Configure the Channel 3 in PWM mode */
;;;4217         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;4218   
;;;4219         /* Set the Preload enable bit for channel3 */
;;;4220         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;4221   
;;;4222         /* Configure the Output Fast mode */
;;;4223         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;4224         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;4225         break;
;;;4226       }
;;;4227   
;;;4228       case TIM_CHANNEL_4:
;;;4229       {
;;;4230         /* Check the parameters */
;;;4231         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4232   
;;;4233         /* Configure the Channel 4 in PWM mode */
;;;4234         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;4235   
;;;4236         /* Set the Preload enable bit for channel4 */
;;;4237         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;4238   
;;;4239         /* Configure the Output Fast mode */
;;;4240         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;4241         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
;;;4242         break;
;;;4243       }
;;;4244   
;;;4245       case TIM_CHANNEL_5:
;;;4246       {
;;;4247         /* Check the parameters */
;;;4248         assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
;;;4249   
;;;4250         /* Configure the Channel 5 in PWM mode */
;;;4251         TIM_OC5_SetConfig(htim->Instance, sConfig);
;;;4252   
;;;4253         /* Set the Preload enable bit for channel5*/
;;;4254         htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
;;;4255   
;;;4256         /* Configure the Output Fast mode */
;;;4257         htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
;;;4258         htim->Instance->CCMR3 |= sConfig->OCFastMode;
;;;4259         break;
;;;4260       }
;;;4261   
;;;4262       case TIM_CHANNEL_6:
;;;4263       {
;;;4264         /* Check the parameters */
;;;4265         assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
;;;4266   
;;;4267         /* Configure the Channel 6 in PWM mode */
;;;4268         TIM_OC6_SetConfig(htim->Instance, sConfig);
;;;4269   
;;;4270         /* Set the Preload enable bit for channel6 */
;;;4271         htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
;;;4272   
;;;4273         /* Configure the Output Fast mode */
;;;4274         htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
;;;4275         htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
;;;4276         break;
;;;4277       }
;;;4278   
;;;4279       default:
;;;4280         break;
;;;4281     }
;;;4282   
;;;4283     __HAL_UNLOCK(htim);
;;;4284   
;;;4285     return HAL_OK;
;;;4286   }
000028  bd70              POP      {r4-r6,pc}
                  |L75.42|
00002a  2a10              CMP      r2,#0x10              ;4175
00002c  d054              BEQ      |L75.216|
00002e  2a14              CMP      r2,#0x14              ;4175
000030  d17a              BNE      |L75.296|
000032  e065              B        |L75.256|
                  |L75.52|
000034  4629              MOV      r1,r5                 ;4183
000036  6820              LDR      r0,[r4,#0]            ;4183
000038  f7fffffe          BL       TIM_OC1_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;4186
00003e  6981              LDR      r1,[r0,#0x18]         ;4186
000040  f0410108          ORR      r1,r1,#8              ;4186
000044  6181              STR      r1,[r0,#0x18]         ;4186
000046  6820              LDR      r0,[r4,#0]            ;4189
000048  6981              LDR      r1,[r0,#0x18]         ;4189
00004a  f0210104          BIC      r1,r1,#4              ;4189
00004e  6181              STR      r1,[r0,#0x18]         ;4189
000050  6820              LDR      r0,[r4,#0]            ;4190
000052  6981              LDR      r1,[r0,#0x18]         ;4190
000054  692a              LDR      r2,[r5,#0x10]         ;4190
000056  4311              ORRS     r1,r1,r2              ;4190
000058  6181              STR      r1,[r0,#0x18]         ;4190
                  |L75.90|
00005a  e065              B        |L75.296|
                  |L75.92|
00005c  4629              MOV      r1,r5                 ;4200
00005e  6820              LDR      r0,[r4,#0]            ;4200
000060  f7fffffe          BL       TIM_OC2_SetConfig
000064  6820              LDR      r0,[r4,#0]            ;4203
000066  6981              LDR      r1,[r0,#0x18]         ;4203
000068  f4416100          ORR      r1,r1,#0x800          ;4203
00006c  6181              STR      r1,[r0,#0x18]         ;4203
00006e  6820              LDR      r0,[r4,#0]            ;4206
000070  6981              LDR      r1,[r0,#0x18]         ;4206
000072  f4216180          BIC      r1,r1,#0x400          ;4206
000076  6181              STR      r1,[r0,#0x18]         ;4206
000078  6820              LDR      r0,[r4,#0]            ;4207
00007a  6981              LDR      r1,[r0,#0x18]         ;4207
00007c  692a              LDR      r2,[r5,#0x10]         ;4207
00007e  ea412102          ORR      r1,r1,r2,LSL #8       ;4207
000082  6181              STR      r1,[r0,#0x18]         ;4207
000084  e050              B        |L75.296|
                  |L75.134|
000086  4629              MOV      r1,r5                 ;4217
000088  6820              LDR      r0,[r4,#0]            ;4217
00008a  f7fffffe          BL       TIM_OC3_SetConfig
00008e  6820              LDR      r0,[r4,#0]            ;4220
000090  69c1              LDR      r1,[r0,#0x1c]         ;4220
000092  f0410108          ORR      r1,r1,#8              ;4220
000096  61c1              STR      r1,[r0,#0x1c]         ;4220
000098  6820              LDR      r0,[r4,#0]            ;4223
00009a  69c1              LDR      r1,[r0,#0x1c]         ;4223
00009c  f0210104          BIC      r1,r1,#4              ;4223
0000a0  61c1              STR      r1,[r0,#0x1c]         ;4223
0000a2  6820              LDR      r0,[r4,#0]            ;4224
0000a4  69c1              LDR      r1,[r0,#0x1c]         ;4224
0000a6  692a              LDR      r2,[r5,#0x10]         ;4224
0000a8  4311              ORRS     r1,r1,r2              ;4224
0000aa  61c1              STR      r1,[r0,#0x1c]         ;4224
0000ac  e03c              B        |L75.296|
                  |L75.174|
0000ae  4629              MOV      r1,r5                 ;4234
0000b0  6820              LDR      r0,[r4,#0]            ;4234
0000b2  f7fffffe          BL       TIM_OC4_SetConfig
0000b6  6820              LDR      r0,[r4,#0]            ;4237
0000b8  69c1              LDR      r1,[r0,#0x1c]         ;4237
0000ba  f4416100          ORR      r1,r1,#0x800          ;4237
0000be  61c1              STR      r1,[r0,#0x1c]         ;4237
0000c0  6820              LDR      r0,[r4,#0]            ;4240
0000c2  69c1              LDR      r1,[r0,#0x1c]         ;4240
0000c4  f4216180          BIC      r1,r1,#0x400          ;4240
0000c8  61c1              STR      r1,[r0,#0x1c]         ;4240
0000ca  6820              LDR      r0,[r4,#0]            ;4241
0000cc  69c1              LDR      r1,[r0,#0x1c]         ;4241
0000ce  692a              LDR      r2,[r5,#0x10]         ;4241
0000d0  ea412102          ORR      r1,r1,r2,LSL #8       ;4241
0000d4  61c1              STR      r1,[r0,#0x1c]         ;4241
0000d6  e027              B        |L75.296|
                  |L75.216|
0000d8  4629              MOV      r1,r5                 ;4251
0000da  6820              LDR      r0,[r4,#0]            ;4251
0000dc  f7fffffe          BL       TIM_OC5_SetConfig
0000e0  6820              LDR      r0,[r4,#0]            ;4254
0000e2  6d41              LDR      r1,[r0,#0x54]         ;4254
0000e4  f0410108          ORR      r1,r1,#8              ;4254
0000e8  6541              STR      r1,[r0,#0x54]         ;4254
0000ea  6820              LDR      r0,[r4,#0]            ;4257
0000ec  6d41              LDR      r1,[r0,#0x54]         ;4257
0000ee  f0210104          BIC      r1,r1,#4              ;4257
0000f2  6541              STR      r1,[r0,#0x54]         ;4257
0000f4  6820              LDR      r0,[r4,#0]            ;4258
0000f6  6d41              LDR      r1,[r0,#0x54]         ;4258
0000f8  692a              LDR      r2,[r5,#0x10]         ;4258
0000fa  4311              ORRS     r1,r1,r2              ;4258
0000fc  6541              STR      r1,[r0,#0x54]         ;4258
0000fe  e013              B        |L75.296|
                  |L75.256|
000100  4629              MOV      r1,r5                 ;4268
000102  6820              LDR      r0,[r4,#0]            ;4268
000104  f7fffffe          BL       TIM_OC6_SetConfig
000108  6820              LDR      r0,[r4,#0]            ;4271
00010a  6d41              LDR      r1,[r0,#0x54]         ;4271
00010c  f4416100          ORR      r1,r1,#0x800          ;4271
000110  6541              STR      r1,[r0,#0x54]         ;4271
000112  6820              LDR      r0,[r4,#0]            ;4274
000114  6d41              LDR      r1,[r0,#0x54]         ;4274
000116  f4216180          BIC      r1,r1,#0x400          ;4274
00011a  6541              STR      r1,[r0,#0x54]         ;4274
00011c  6820              LDR      r0,[r4,#0]            ;4275
00011e  6d41              LDR      r1,[r0,#0x54]         ;4275
000120  692a              LDR      r2,[r5,#0x10]         ;4275
000122  ea412102          ORR      r1,r1,r2,LSL #8       ;4275
000126  6541              STR      r1,[r0,#0x54]         ;4275
                  |L75.296|
000128  2000              MOVS     r0,#0                 ;4283
00012a  f884003c          STRB     r0,[r4,#0x3c]         ;4283
00012e  bd70              POP      {r4-r6,pc}
;;;4287   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1350     */
;;;1351   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1352   {
000002  4604              MOV      r4,r0
;;;1353     /* Check the parameters */
;;;1354     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1355   
;;;1356     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1357   
;;;1358     /* Disable the TIM Peripheral Clock */
;;;1359     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L76.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L76.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L76.38|
;;;1360   
;;;1361   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1362     if (htim->PWM_MspDeInitCallback == NULL)
;;;1363     {
;;;1364       htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
;;;1365     }
;;;1366     /* DeInit the low level hardware */
;;;1367     htim->PWM_MspDeInitCallback(htim);
;;;1368   #else
;;;1369     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1370     HAL_TIM_PWM_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1371   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1372   
;;;1373     /* Change the DMA burst operation state */
;;;1374     htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  343c              ADDS     r4,r4,#0x3c
000030  7320              STRB     r0,[r4,#0xc]
;;;1375   
;;;1376     /* Change the TIM channels state */
;;;1377     TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
000032  70a0              STRB     r0,[r4,#2]
000034  70e0              STRB     r0,[r4,#3]
000036  7120              STRB     r0,[r4,#4]
000038  7160              STRB     r0,[r4,#5]
00003a  71a0              STRB     r0,[r4,#6]
00003c  71e0              STRB     r0,[r4,#7]
;;;1378     TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
00003e  7220              STRB     r0,[r4,#8]
000040  7260              STRB     r0,[r4,#9]
000042  72a0              STRB     r0,[r4,#0xa]
000044  72e0              STRB     r0,[r4,#0xb]
;;;1379   
;;;1380     /* Change TIM state */
;;;1381     htim->State = HAL_TIM_STATE_RESET;
000046  7060              STRB     r0,[r4,#1]
;;;1382   
;;;1383     /* Release Lock */
;;;1384     __HAL_UNLOCK(htim);
000048  7020              STRB     r0,[r4,#0]
;;;1385   
;;;1386     return HAL_OK;
;;;1387   }
00004a  bd10              POP      {r4,pc}
;;;1388   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;6322     */
;;;6323   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;6324   {
;;;6325     return htim->State;
;;;6326   }
000004  4770              BX       lr
;;;6327   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;1291     */
;;;1292   HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1293   {
000002  4604              MOV      r4,r0
;;;1294     /* Check the TIM handle allocation */
;;;1295     if (htim == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L78.16|
;;;1296     {
;;;1297       return HAL_ERROR;
;;;1298     }
;;;1299   
;;;1300     /* Check the parameters */
;;;1301     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1302     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1303     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1304     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1305   
;;;1306     if (htim->State == HAL_TIM_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  b110              CBZ      r0,|L78.20|
00000e  e007              B        |L78.32|
                  |L78.16|
000010  2001              MOVS     r0,#1                 ;1297
;;;1307     {
;;;1308       /* Allocate lock resource and initialize it */
;;;1309       htim->Lock = HAL_UNLOCKED;
;;;1310   
;;;1311   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1312       /* Reset interrupt callbacks to legacy weak callbacks */
;;;1313       TIM_ResetCallback(htim);
;;;1314   
;;;1315       if (htim->PWM_MspInitCallback == NULL)
;;;1316       {
;;;1317         htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
;;;1318       }
;;;1319       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1320       htim->PWM_MspInitCallback(htim);
;;;1321   #else
;;;1322       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1323       HAL_TIM_PWM_MspInit(htim);
;;;1324   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1325     }
;;;1326   
;;;1327     /* Set the TIM state */
;;;1328     htim->State = HAL_TIM_STATE_BUSY;
;;;1329   
;;;1330     /* Init the base time for the PWM */
;;;1331     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1332   
;;;1333     /* Initialize the DMA burst operation state */
;;;1334     htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
;;;1335   
;;;1336     /* Initialize the TIM channels state */
;;;1337     TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;1338     TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
;;;1339   
;;;1340     /* Initialize the TIM state*/
;;;1341     htim->State = HAL_TIM_STATE_READY;
;;;1342   
;;;1343     return HAL_OK;
;;;1344   }
000012  bd10              POP      {r4,pc}
                  |L78.20|
000014  2000              MOVS     r0,#0                 ;1309
000016  f884003c          STRB     r0,[r4,#0x3c]         ;1309
00001a  4620              MOV      r0,r4                 ;1323
00001c  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L78.32|
000020  2002              MOVS     r0,#2                 ;1328
000022  f884003d          STRB     r0,[r4,#0x3d]         ;1328
000026  1d21              ADDS     r1,r4,#4              ;1331
000028  6820              LDR      r0,[r4,#0]            ;1331
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2001              MOVS     r0,#1                 ;1334
000030  343d              ADDS     r4,r4,#0x3d           ;1334
000032  72e0              STRB     r0,[r4,#0xb]          ;1334
000034  7060              STRB     r0,[r4,#1]            ;1337
000036  70a0              STRB     r0,[r4,#2]            ;1337
000038  70e0              STRB     r0,[r4,#3]            ;1337
00003a  7120              STRB     r0,[r4,#4]            ;1337
00003c  7160              STRB     r0,[r4,#5]            ;1337
00003e  71a0              STRB     r0,[r4,#6]            ;1337
000040  71e0              STRB     r0,[r4,#7]            ;1338
000042  7220              STRB     r0,[r4,#8]            ;1338
000044  7260              STRB     r0,[r4,#9]            ;1338
000046  72a0              STRB     r0,[r4,#0xa]          ;1338
000048  7020              STRB     r0,[r4,#0]            ;1341
00004a  2000              MOVS     r0,#0                 ;1343
00004c  bd10              POP      {r4,pc}
;;;1345   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1408     */
;;;1409   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1410   {
;;;1411     /* Prevent unused argument(s) compilation warning */
;;;1412     UNUSED(htim);
;;;1413   
;;;1414     /* NOTE : This function should not be modified, when the callback is needed,
;;;1415               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1416      */
;;;1417   }
;;;1418   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1393     */
;;;1394   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1395   {
;;;1396     /* Prevent unused argument(s) compilation warning */
;;;1397     UNUSED(htim);
;;;1398   
;;;1399     /* NOTE : This function should not be modified, when the callback is needed,
;;;1400               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1401      */
;;;1402   }
;;;1403   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;5715     */
;;;5716   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5717   {
;;;5718     /* Prevent unused argument(s) compilation warning */
;;;5719     UNUSED(htim);
;;;5720   
;;;5721     /* NOTE : This function should not be modified, when the callback is needed,
;;;5722               the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;5723      */
;;;5724   }
;;;5725   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedHalfCpltCallback PROC
;;;5730     */
;;;5731   __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5732   {
;;;5733     /* Prevent unused argument(s) compilation warning */
;;;5734     UNUSED(htim);
;;;5735   
;;;5736     /* NOTE : This function should not be modified, when the callback is needed,
;;;5737               the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
;;;5738      */
;;;5739   }
;;;5740   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1431     */
;;;1432   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1433   {
000002  4604              MOV      r4,r0
;;;1434     uint32_t tmpsmcr;
;;;1435   
;;;1436     /* Check the parameters */
;;;1437     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1438   
;;;1439     /* Check the TIM channel state */
;;;1440     if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d00d              BEQ      |L83.36|
000008  2904              CMP      r1,#4
00000a  d00e              BEQ      |L83.42|
00000c  2908              CMP      r1,#8
00000e  d00f              BEQ      |L83.48|
000010  290c              CMP      r1,#0xc
000012  d010              BEQ      |L83.54|
000014  2910              CMP      r1,#0x10
000016  d011              BEQ      |L83.60|
000018  f8940043          LDRB     r0,[r4,#0x43]
                  |L83.28|
00001c  2801              CMP      r0,#1
00001e  d010              BEQ      |L83.66|
;;;1441     {
;;;1442       return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;1443     }
;;;1444   
;;;1445     /* Set the TIM channel state */
;;;1446     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1447   
;;;1448     /* Enable the Capture compare channel */
;;;1449     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1450   
;;;1451     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1452     {
;;;1453       /* Enable the main output */
;;;1454       __HAL_TIM_MOE_ENABLE(htim);
;;;1455     }
;;;1456   
;;;1457     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1458     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;1459     {
;;;1460       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1461       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1462       {
;;;1463         __HAL_TIM_ENABLE(htim);
;;;1464       }
;;;1465     }
;;;1466     else
;;;1467     {
;;;1468       __HAL_TIM_ENABLE(htim);
;;;1469     }
;;;1470   
;;;1471     /* Return function status */
;;;1472     return HAL_OK;
;;;1473   }
000022  bd30              POP      {r4,r5,pc}
                  |L83.36|
000024  f894003e          LDRB     r0,[r4,#0x3e]         ;1440
000028  e7f8              B        |L83.28|
                  |L83.42|
00002a  f894003f          LDRB     r0,[r4,#0x3f]         ;1440
00002e  e7f5              B        |L83.28|
                  |L83.48|
000030  f8940040          LDRB     r0,[r4,#0x40]         ;1440
000034  e7f2              B        |L83.28|
                  |L83.54|
000036  f8940041          LDRB     r0,[r4,#0x41]         ;1440
00003a  e7ef              B        |L83.28|
                  |L83.60|
00003c  f8940042          LDRB     r0,[r4,#0x42]         ;1440
000040  e7ec              B        |L83.28|
                  |L83.66|
000042  2002              MOVS     r0,#2                 ;1446
000044  b3f1              CBZ      r1,|L83.196|
000046  2904              CMP      r1,#4                 ;1446
000048  d044              BEQ      |L83.212|
00004a  2908              CMP      r1,#8                 ;1446
00004c  d045              BEQ      |L83.218|
00004e  290c              CMP      r1,#0xc               ;1446
000050  d046              BEQ      |L83.224|
000052  2910              CMP      r1,#0x10              ;1446
000054  d047              BEQ      |L83.230|
000056  f8840043          STRB     r0,[r4,#0x43]         ;1446
                  |L83.90|
00005a  2201              MOVS     r2,#1                 ;1449
00005c  6820              LDR      r0,[r4,#0]            ;1449
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  4925              LDR      r1,|L83.248|
000064  6820              LDR      r0,[r4,#0]            ;1451
000066  4a25              LDR      r2,|L83.252|
000068  4b25              LDR      r3,|L83.256|
00006a  4288              CMP      r0,r1                 ;1451
00006c  d009              BEQ      |L83.130|
00006e  4290              CMP      r0,r2                 ;1451
000070  d007              BEQ      |L83.130|
000072  4298              CMP      r0,r3                 ;1451
000074  d005              BEQ      |L83.130|
000076  4d23              LDR      r5,|L83.260|
000078  42a8              CMP      r0,r5                 ;1451
00007a  d002              BEQ      |L83.130|
00007c  4d22              LDR      r5,|L83.264|
00007e  42a8              CMP      r0,r5                 ;1451
000080  d103              BNE      |L83.138|
                  |L83.130|
000082  6c45              LDR      r5,[r0,#0x44]         ;1454
000084  f4454500          ORR      r5,r5,#0x8000         ;1454
000088  6445              STR      r5,[r0,#0x44]         ;1454
                  |L83.138|
00008a  6820              LDR      r0,[r4,#0]            ;1458
00008c  4288              CMP      r0,r1                 ;1458
00008e  d00f              BEQ      |L83.176|
000090  f1b04f80          CMP      r0,#0x40000000        ;1458
000094  d00c              BEQ      |L83.176|
000096  491d              LDR      r1,|L83.268|
000098  4288              CMP      r0,r1                 ;1458
00009a  d009              BEQ      |L83.176|
00009c  491c              LDR      r1,|L83.272|
00009e  4288              CMP      r0,r1                 ;1458
0000a0  d006              BEQ      |L83.176|
0000a2  491c              LDR      r1,|L83.276|
0000a4  4288              CMP      r0,r1                 ;1458
0000a6  d003              BEQ      |L83.176|
0000a8  4290              CMP      r0,r2                 ;1458
0000aa  d001              BEQ      |L83.176|
0000ac  4298              CMP      r0,r3                 ;1458
0000ae  d11d              BNE      |L83.236|
                  |L83.176|
0000b0  6881              LDR      r1,[r0,#8]            ;1460
0000b2  4a19              LDR      r2,|L83.280|
0000b4  4011              ANDS     r1,r1,r2              ;1460
0000b6  2906              CMP      r1,#6                 ;1461
0000b8  d01c              BEQ      |L83.244|
0000ba  f5b13f80          CMP      r1,#0x10000           ;1461
0000be  d019              BEQ      |L83.244|
0000c0  6801              LDR      r1,[r0,#0]            ;1463
0000c2  e000              B        |L83.198|
                  |L83.196|
0000c4  e003              B        |L83.206|
                  |L83.198|
0000c6  f0410101          ORR      r1,r1,#1              ;1463
0000ca  6001              STR      r1,[r0,#0]            ;1463
0000cc  e012              B        |L83.244|
                  |L83.206|
0000ce  f884003e          STRB     r0,[r4,#0x3e]         ;1446
0000d2  e7c2              B        |L83.90|
                  |L83.212|
0000d4  f884003f          STRB     r0,[r4,#0x3f]         ;1446
0000d8  e7bf              B        |L83.90|
                  |L83.218|
0000da  f8840040          STRB     r0,[r4,#0x40]         ;1446
0000de  e7bc              B        |L83.90|
                  |L83.224|
0000e0  f8840041          STRB     r0,[r4,#0x41]         ;1446
0000e4  e7b9              B        |L83.90|
                  |L83.230|
0000e6  f8840042          STRB     r0,[r4,#0x42]         ;1446
0000ea  e7b6              B        |L83.90|
                  |L83.236|
0000ec  6801              LDR      r1,[r0,#0]            ;1468
0000ee  f0410101          ORR      r1,r1,#1              ;1468
0000f2  6001              STR      r1,[r0,#0]            ;1468
                  |L83.244|
0000f4  2000              MOVS     r0,#0                 ;1472
0000f6  bd30              POP      {r4,r5,pc}
;;;1474   
                          ENDP

                  |L83.248|
                          DCD      0x40012c00
                  |L83.252|
                          DCD      0x40013400
                  |L83.256|
                          DCD      0x40014000
                  |L83.260|
                          DCD      0x40014400
                  |L83.264|
                          DCD      0x40014800
                  |L83.268|
                          DCD      0x40000400
                  |L83.272|
                          DCD      0x40000800
                  |L83.276|
                          DCD      0x40000c00
                  |L83.280|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1680     */
;;;1681   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1682   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  4611              MOV      r1,r2
;;;1683     uint32_t tmpsmcr;
;;;1684   
;;;1685     /* Check the parameters */
;;;1686     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1687   
;;;1688     /* Set the TIM channel state */
;;;1689     if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
00000a  2d00              CMP      r5,#0
00000c  d01b              BEQ      |L84.70|
00000e  2d04              CMP      r5,#4
000010  d01c              BEQ      |L84.76|
000012  2d08              CMP      r5,#8
000014  d01d              BEQ      |L84.82|
000016  2d0c              CMP      r5,#0xc
000018  d01e              BEQ      |L84.88|
00001a  2d10              CMP      r5,#0x10
00001c  d01f              BEQ      |L84.94|
00001e  f8940043          LDRB     r0,[r4,#0x43]
                  |L84.34|
000022  2802              CMP      r0,#2
000024  d01e              BEQ      |L84.100|
;;;1690     {
;;;1691       return HAL_BUSY;
;;;1692     }
;;;1693     else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
000026  b1fd              CBZ      r5,|L84.104|
000028  2d04              CMP      r5,#4
00002a  d020              BEQ      |L84.110|
00002c  2d08              CMP      r5,#8
00002e  d021              BEQ      |L84.116|
000030  2d0c              CMP      r5,#0xc
000032  d022              BEQ      |L84.122|
000034  2d10              CMP      r5,#0x10
000036  d023              BEQ      |L84.128|
000038  f8940043          LDRB     r0,[r4,#0x43]
                  |L84.60|
00003c  2801              CMP      r0,#1
00003e  d022              BEQ      |L84.134|
;;;1694     {
;;;1695       if ((pData == NULL) && (Length > 0U))
;;;1696       {
;;;1697         return HAL_ERROR;
;;;1698       }
;;;1699       else
;;;1700       {
;;;1701         TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1702       }
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       return HAL_ERROR;
000040  2001              MOVS     r0,#1
                  |L84.66|
;;;1707     }
;;;1708   
;;;1709     switch (Channel)
;;;1710     {
;;;1711       case TIM_CHANNEL_1:
;;;1712       {
;;;1713         /* Set the DMA compare callbacks */
;;;1714         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1715         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1716   
;;;1717         /* Set the DMA error callback */
;;;1718         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1719   
;;;1720         /* Enable the DMA channel */
;;;1721         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;1722         {
;;;1723           /* Return error status */
;;;1724           return HAL_ERROR;
;;;1725         }
;;;1726   
;;;1727         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1728         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1729         break;
;;;1730       }
;;;1731   
;;;1732       case TIM_CHANNEL_2:
;;;1733       {
;;;1734         /* Set the DMA compare callbacks */
;;;1735         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1736         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1737   
;;;1738         /* Set the DMA error callback */
;;;1739         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1740   
;;;1741         /* Enable the DMA channel */
;;;1742         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;1743         {
;;;1744           /* Return error status */
;;;1745           return HAL_ERROR;
;;;1746         }
;;;1747         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1748         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1749         break;
;;;1750       }
;;;1751   
;;;1752       case TIM_CHANNEL_3:
;;;1753       {
;;;1754         /* Set the DMA compare callbacks */
;;;1755         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1756         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1757   
;;;1758         /* Set the DMA error callback */
;;;1759         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1760   
;;;1761         /* Enable the DMA channel */
;;;1762         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;1763         {
;;;1764           /* Return error status */
;;;1765           return HAL_ERROR;
;;;1766         }
;;;1767         /* Enable the TIM Output Capture/Compare 3 request */
;;;1768         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1769         break;
;;;1770       }
;;;1771   
;;;1772       case TIM_CHANNEL_4:
;;;1773       {
;;;1774         /* Set the DMA compare callbacks */
;;;1775         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1776         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1777   
;;;1778         /* Set the DMA error callback */
;;;1779         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1780   
;;;1781         /* Enable the DMA channel */
;;;1782         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
;;;1783         {
;;;1784           /* Return error status */
;;;1785           return HAL_ERROR;
;;;1786         }
;;;1787         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1788         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1789         break;
;;;1790       }
;;;1791   
;;;1792       default:
;;;1793         break;
;;;1794     }
;;;1795   
;;;1796     /* Enable the Capture compare channel */
;;;1797     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1798   
;;;1799     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1800     {
;;;1801       /* Enable the main output */
;;;1802       __HAL_TIM_MOE_ENABLE(htim);
;;;1803     }
;;;1804   
;;;1805     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1806     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;1807     {
;;;1808       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1809       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1810       {
;;;1811         __HAL_TIM_ENABLE(htim);
;;;1812       }
;;;1813     }
;;;1814     else
;;;1815     {
;;;1816       __HAL_TIM_ENABLE(htim);
;;;1817     }
;;;1818   
;;;1819     /* Return function status */
;;;1820     return HAL_OK;
;;;1821   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L84.70|
000046  f894003e          LDRB     r0,[r4,#0x3e]         ;1689
00004a  e7ea              B        |L84.34|
                  |L84.76|
00004c  f894003f          LDRB     r0,[r4,#0x3f]         ;1689
000050  e7e7              B        |L84.34|
                  |L84.82|
000052  f8940040          LDRB     r0,[r4,#0x40]         ;1689
000056  e7e4              B        |L84.34|
                  |L84.88|
000058  f8940041          LDRB     r0,[r4,#0x41]         ;1689
00005c  e7e1              B        |L84.34|
                  |L84.94|
00005e  f8940042          LDRB     r0,[r4,#0x42]         ;1689
000062  e7de              B        |L84.34|
                  |L84.100|
000064  2002              MOVS     r0,#2                 ;1691
000066  e7ec              B        |L84.66|
                  |L84.104|
000068  f894003e          LDRB     r0,[r4,#0x3e]         ;1693
00006c  e7e6              B        |L84.60|
                  |L84.110|
00006e  f894003f          LDRB     r0,[r4,#0x3f]         ;1693
000072  e7e3              B        |L84.60|
                  |L84.116|
000074  f8940040          LDRB     r0,[r4,#0x40]         ;1693
000078  e7e0              B        |L84.60|
                  |L84.122|
00007a  f8940041          LDRB     r0,[r4,#0x41]         ;1693
00007e  e7dd              B        |L84.60|
                  |L84.128|
000080  f8940042          LDRB     r0,[r4,#0x42]         ;1693
000084  e7da              B        |L84.60|
                  |L84.134|
000086  b911              CBNZ     r1,|L84.142|
000088  b10b              CBZ      r3,|L84.142|
00008a  2001              MOVS     r0,#1                 ;1697
00008c  e7d9              B        |L84.66|
                  |L84.142|
00008e  2002              MOVS     r0,#2                 ;1691
000090  b155              CBZ      r5,|L84.168|
000092  2d04              CMP      r5,#4                 ;1701
000094  d00b              BEQ      |L84.174|
000096  2d08              CMP      r5,#8                 ;1701
000098  d00c              BEQ      |L84.180|
00009a  2d0c              CMP      r5,#0xc               ;1701
00009c  d00d              BEQ      |L84.186|
00009e  2d10              CMP      r5,#0x10              ;1701
0000a0  d00e              BEQ      |L84.192|
0000a2  f8840043          STRB     r0,[r4,#0x43]         ;1701
0000a6  e00d              B        |L84.196|
                  |L84.168|
0000a8  f884003e          STRB     r0,[r4,#0x3e]         ;1701
0000ac  e00a              B        |L84.196|
                  |L84.174|
0000ae  f884003f          STRB     r0,[r4,#0x3f]         ;1701
0000b2  e007              B        |L84.196|
                  |L84.180|
0000b4  f8840040          STRB     r0,[r4,#0x40]         ;1701
0000b8  e004              B        |L84.196|
                  |L84.186|
0000ba  f8840041          STRB     r0,[r4,#0x41]         ;1701
0000be  e001              B        |L84.196|
                  |L84.192|
0000c0  f8840042          STRB     r0,[r4,#0x42]         ;1701
                  |L84.196|
0000c4  484c              LDR      r0,|L84.504|
0000c6  4a4d              LDR      r2,|L84.508|
0000c8  4e4d              LDR      r6,|L84.512|
0000ca  b135              CBZ      r5,|L84.218|
0000cc  2d04              CMP      r5,#4                 ;1709
0000ce  d018              BEQ      |L84.258|
0000d0  2d08              CMP      r5,#8                 ;1709
0000d2  d02a              BEQ      |L84.298|
0000d4  2d0c              CMP      r5,#0xc               ;1709
0000d6  d14f              BNE      |L84.376|
0000d8  e03b              B        |L84.338|
                  |L84.218|
0000da  6a67              LDR      r7,[r4,#0x24]         ;1714
0000dc  62f8              STR      r0,[r7,#0x2c]         ;1714
0000de  6a60              LDR      r0,[r4,#0x24]         ;1715
0000e0  6302              STR      r2,[r0,#0x30]         ;1715
0000e2  6a60              LDR      r0,[r4,#0x24]         ;1718
0000e4  6346              STR      r6,[r0,#0x34]         ;1718
0000e6  6822              LDR      r2,[r4,#0]            ;1721
0000e8  6a60              LDR      r0,[r4,#0x24]         ;1721
0000ea  3234              ADDS     r2,r2,#0x34           ;1721
0000ec  f7fffffe          BL       HAL_DMA_Start_IT
0000f0  b108              CBZ      r0,|L84.246|
0000f2  2001              MOVS     r0,#1                 ;1724
0000f4  e7a5              B        |L84.66|
                  |L84.246|
0000f6  6820              LDR      r0,[r4,#0]            ;1728
0000f8  68c1              LDR      r1,[r0,#0xc]          ;1728
0000fa  f4417100          ORR      r1,r1,#0x200          ;1728
0000fe  60c1              STR      r1,[r0,#0xc]          ;1728
000100  e03a              B        |L84.376|
                  |L84.258|
000102  6aa7              LDR      r7,[r4,#0x28]         ;1735
000104  62f8              STR      r0,[r7,#0x2c]         ;1735
000106  6aa0              LDR      r0,[r4,#0x28]         ;1736
000108  6302              STR      r2,[r0,#0x30]         ;1736
00010a  6aa0              LDR      r0,[r4,#0x28]         ;1739
00010c  6346              STR      r6,[r0,#0x34]         ;1739
00010e  6822              LDR      r2,[r4,#0]            ;1742
000110  6aa0              LDR      r0,[r4,#0x28]         ;1742
000112  3238              ADDS     r2,r2,#0x38           ;1742
000114  f7fffffe          BL       HAL_DMA_Start_IT
000118  b108              CBZ      r0,|L84.286|
00011a  2001              MOVS     r0,#1                 ;1745
00011c  e791              B        |L84.66|
                  |L84.286|
00011e  6820              LDR      r0,[r4,#0]            ;1748
000120  68c1              LDR      r1,[r0,#0xc]          ;1748
000122  f4416180          ORR      r1,r1,#0x400          ;1748
000126  60c1              STR      r1,[r0,#0xc]          ;1748
000128  e026              B        |L84.376|
                  |L84.298|
00012a  6ae7              LDR      r7,[r4,#0x2c]         ;1755
00012c  62f8              STR      r0,[r7,#0x2c]         ;1755
00012e  6ae0              LDR      r0,[r4,#0x2c]         ;1756
000130  6302              STR      r2,[r0,#0x30]         ;1756
000132  6ae0              LDR      r0,[r4,#0x2c]         ;1759
000134  6346              STR      r6,[r0,#0x34]         ;1759
000136  6822              LDR      r2,[r4,#0]            ;1762
000138  6ae0              LDR      r0,[r4,#0x2c]         ;1762
00013a  323c              ADDS     r2,r2,#0x3c           ;1762
00013c  f7fffffe          BL       HAL_DMA_Start_IT
000140  b108              CBZ      r0,|L84.326|
000142  2001              MOVS     r0,#1                 ;1765
000144  e77d              B        |L84.66|
                  |L84.326|
000146  6820              LDR      r0,[r4,#0]            ;1768
000148  68c1              LDR      r1,[r0,#0xc]          ;1768
00014a  f4416100          ORR      r1,r1,#0x800          ;1768
00014e  60c1              STR      r1,[r0,#0xc]          ;1768
000150  e012              B        |L84.376|
                  |L84.338|
000152  6b27              LDR      r7,[r4,#0x30]         ;1775
000154  62f8              STR      r0,[r7,#0x2c]         ;1775
000156  6b20              LDR      r0,[r4,#0x30]         ;1776
000158  6302              STR      r2,[r0,#0x30]         ;1776
00015a  6b20              LDR      r0,[r4,#0x30]         ;1779
00015c  6346              STR      r6,[r0,#0x34]         ;1779
00015e  6822              LDR      r2,[r4,#0]            ;1782
000160  6b20              LDR      r0,[r4,#0x30]         ;1782
000162  3240              ADDS     r2,r2,#0x40           ;1782
000164  f7fffffe          BL       HAL_DMA_Start_IT
000168  b108              CBZ      r0,|L84.366|
00016a  2001              MOVS     r0,#1                 ;1785
00016c  e769              B        |L84.66|
                  |L84.366|
00016e  6820              LDR      r0,[r4,#0]            ;1788
000170  68c1              LDR      r1,[r0,#0xc]          ;1788
000172  f4415180          ORR      r1,r1,#0x1000         ;1788
000176  60c1              STR      r1,[r0,#0xc]          ;1788
                  |L84.376|
000178  2201              MOVS     r2,#1                 ;1797
00017a  4629              MOV      r1,r5                 ;1797
00017c  6820              LDR      r0,[r4,#0]            ;1797
00017e  f7fffffe          BL       TIM_CCxChannelCmd
000182  4920              LDR      r1,|L84.516|
000184  6820              LDR      r0,[r4,#0]            ;1799
000186  4a20              LDR      r2,|L84.520|
000188  4b20              LDR      r3,|L84.524|
00018a  4288              CMP      r0,r1                 ;1799
00018c  d009              BEQ      |L84.418|
00018e  4290              CMP      r0,r2                 ;1799
000190  d007              BEQ      |L84.418|
000192  4298              CMP      r0,r3                 ;1799
000194  d005              BEQ      |L84.418|
000196  4d1e              LDR      r5,|L84.528|
000198  42a8              CMP      r0,r5                 ;1799
00019a  d002              BEQ      |L84.418|
00019c  4d1d              LDR      r5,|L84.532|
00019e  42a8              CMP      r0,r5                 ;1799
0001a0  d103              BNE      |L84.426|
                  |L84.418|
0001a2  6c45              LDR      r5,[r0,#0x44]         ;1802
0001a4  f4454500          ORR      r5,r5,#0x8000         ;1802
0001a8  6445              STR      r5,[r0,#0x44]         ;1802
                  |L84.426|
0001aa  6820              LDR      r0,[r4,#0]            ;1806
0001ac  4288              CMP      r0,r1                 ;1806
0001ae  d00f              BEQ      |L84.464|
0001b0  f1b04f80          CMP      r0,#0x40000000        ;1806
0001b4  d00c              BEQ      |L84.464|
0001b6  4918              LDR      r1,|L84.536|
0001b8  4288              CMP      r0,r1                 ;1806
0001ba  d009              BEQ      |L84.464|
0001bc  4917              LDR      r1,|L84.540|
0001be  4288              CMP      r0,r1                 ;1806
0001c0  d006              BEQ      |L84.464|
0001c2  4917              LDR      r1,|L84.544|
0001c4  4288              CMP      r0,r1                 ;1806
0001c6  d003              BEQ      |L84.464|
0001c8  4290              CMP      r0,r2                 ;1806
0001ca  d001              BEQ      |L84.464|
0001cc  4298              CMP      r0,r3                 ;1806
0001ce  d10c              BNE      |L84.490|
                  |L84.464|
0001d0  6881              LDR      r1,[r0,#8]            ;1808
0001d2  4a14              LDR      r2,|L84.548|
0001d4  4011              ANDS     r1,r1,r2              ;1808
0001d6  2906              CMP      r1,#6                 ;1809
0001d8  d00b              BEQ      |L84.498|
0001da  f5b13f80          CMP      r1,#0x10000           ;1809
0001de  d008              BEQ      |L84.498|
0001e0  6801              LDR      r1,[r0,#0]            ;1811
0001e2  f0410101          ORR      r1,r1,#1              ;1811
0001e6  6001              STR      r1,[r0,#0]            ;1811
0001e8  e003              B        |L84.498|
                  |L84.490|
0001ea  6801              LDR      r1,[r0,#0]            ;1816
0001ec  f0410101          ORR      r1,r1,#1              ;1816
0001f0  6001              STR      r1,[r0,#0]            ;1816
                  |L84.498|
0001f2  2000              MOVS     r0,#0                 ;1820
0001f4  e725              B        |L84.66|
;;;1822   
                          ENDP

0001f6  0000              DCW      0x0000
                  |L84.504|
                          DCD      TIM_DMADelayPulseCplt
                  |L84.508|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L84.512|
                          DCD      TIM_DMAError
                  |L84.516|
                          DCD      0x40012c00
                  |L84.520|
                          DCD      0x40013400
                  |L84.524|
                          DCD      0x40014000
                  |L84.528|
                          DCD      0x40014400
                  |L84.532|
                          DCD      0x40014800
                  |L84.536|
                          DCD      0x40000400
                  |L84.540|
                          DCD      0x40000800
                  |L84.544|
                          DCD      0x40000c00
                  |L84.548|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1522     */
;;;1523   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1524   {
000002  4604              MOV      r4,r0
;;;1525     uint32_t tmpsmcr;
;;;1526     /* Check the parameters */
;;;1527     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1528   
;;;1529     /* Check the TIM channel state */
;;;1530     if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
000004  2900              CMP      r1,#0
000006  d00d              BEQ      |L85.36|
000008  2904              CMP      r1,#4
00000a  d00e              BEQ      |L85.42|
00000c  2908              CMP      r1,#8
00000e  d00f              BEQ      |L85.48|
000010  290c              CMP      r1,#0xc
000012  d010              BEQ      |L85.54|
000014  2910              CMP      r1,#0x10
000016  d011              BEQ      |L85.60|
000018  f8940043          LDRB     r0,[r4,#0x43]
                  |L85.28|
00001c  2801              CMP      r0,#1
00001e  d010              BEQ      |L85.66|
;;;1531     {
;;;1532       return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;1533     }
;;;1534   
;;;1535     /* Set the TIM channel state */
;;;1536     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
;;;1537   
;;;1538     switch (Channel)
;;;1539     {
;;;1540       case TIM_CHANNEL_1:
;;;1541       {
;;;1542         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1543         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;1544         break;
;;;1545       }
;;;1546   
;;;1547       case TIM_CHANNEL_2:
;;;1548       {
;;;1549         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1550         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;1551         break;
;;;1552       }
;;;1553   
;;;1554       case TIM_CHANNEL_3:
;;;1555       {
;;;1556         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1557         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1558         break;
;;;1559       }
;;;1560   
;;;1561       case TIM_CHANNEL_4:
;;;1562       {
;;;1563         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1564         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1565         break;
;;;1566       }
;;;1567   
;;;1568       default:
;;;1569         break;
;;;1570     }
;;;1571   
;;;1572     /* Enable the Capture compare channel */
;;;1573     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1574   
;;;1575     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1576     {
;;;1577       /* Enable the main output */
;;;1578       __HAL_TIM_MOE_ENABLE(htim);
;;;1579     }
;;;1580   
;;;1581     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1582     if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
;;;1583     {
;;;1584       tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1585       if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1586       {
;;;1587         __HAL_TIM_ENABLE(htim);
;;;1588       }
;;;1589     }
;;;1590     else
;;;1591     {
;;;1592       __HAL_TIM_ENABLE(htim);
;;;1593     }
;;;1594   
;;;1595     /* Return function status */
;;;1596     return HAL_OK;
;;;1597   }
000022  bd30              POP      {r4,r5,pc}
                  |L85.36|
000024  f894003e          LDRB     r0,[r4,#0x3e]         ;1530
000028  e7f8              B        |L85.28|
                  |L85.42|
00002a  f894003f          LDRB     r0,[r4,#0x3f]         ;1530
00002e  e7f5              B        |L85.28|
                  |L85.48|
000030  f8940040          LDRB     r0,[r4,#0x40]         ;1530
000034  e7f2              B        |L85.28|
                  |L85.54|
000036  f8940041          LDRB     r0,[r4,#0x41]         ;1530
00003a  e7ef              B        |L85.28|
                  |L85.60|
00003c  f8940042          LDRB     r0,[r4,#0x42]         ;1530
000040  e7ec              B        |L85.28|
                  |L85.66|
000042  2002              MOVS     r0,#2                 ;1536
000044  b189              CBZ      r1,|L85.106|
000046  2904              CMP      r1,#4                 ;1536
000048  d012              BEQ      |L85.112|
00004a  2908              CMP      r1,#8                 ;1536
00004c  d013              BEQ      |L85.118|
00004e  290c              CMP      r1,#0xc               ;1536
000050  d014              BEQ      |L85.124|
000052  2910              CMP      r1,#0x10              ;1536
000054  d015              BEQ      |L85.130|
000056  f8840043          STRB     r0,[r4,#0x43]         ;1536
                  |L85.90|
00005a  b1a9              CBZ      r1,|L85.136|
00005c  2904              CMP      r1,#4                 ;1538
00005e  d019              BEQ      |L85.148|
000060  2908              CMP      r1,#8                 ;1538
000062  d01d              BEQ      |L85.160|
000064  290c              CMP      r1,#0xc               ;1538
000066  d126              BNE      |L85.182|
000068  e020              B        |L85.172|
                  |L85.106|
00006a  f884003e          STRB     r0,[r4,#0x3e]         ;1536
00006e  e7f4              B        |L85.90|
                  |L85.112|
000070  f884003f          STRB     r0,[r4,#0x3f]         ;1536
000074  e7f1              B        |L85.90|
                  |L85.118|
000076  f8840040          STRB     r0,[r4,#0x40]         ;1536
00007a  e7ee              B        |L85.90|
                  |L85.124|
00007c  f8840041          STRB     r0,[r4,#0x41]         ;1536
000080  e7eb              B        |L85.90|
                  |L85.130|
000082  f8840042          STRB     r0,[r4,#0x42]         ;1536
000086  e7e8              B        |L85.90|
                  |L85.136|
000088  6820              LDR      r0,[r4,#0]            ;1543
00008a  68c2              LDR      r2,[r0,#0xc]          ;1543
00008c  f0420202          ORR      r2,r2,#2              ;1543
000090  60c2              STR      r2,[r0,#0xc]          ;1543
000092  e010              B        |L85.182|
                  |L85.148|
000094  6820              LDR      r0,[r4,#0]            ;1550
000096  68c2              LDR      r2,[r0,#0xc]          ;1550
000098  f0420204          ORR      r2,r2,#4              ;1550
00009c  60c2              STR      r2,[r0,#0xc]          ;1550
00009e  e00a              B        |L85.182|
                  |L85.160|
0000a0  6820              LDR      r0,[r4,#0]            ;1557
0000a2  68c2              LDR      r2,[r0,#0xc]          ;1557
0000a4  f0420208          ORR      r2,r2,#8              ;1557
0000a8  60c2              STR      r2,[r0,#0xc]          ;1557
0000aa  e004              B        |L85.182|
                  |L85.172|
0000ac  6820              LDR      r0,[r4,#0]            ;1564
0000ae  68c2              LDR      r2,[r0,#0xc]          ;1564
0000b0  f0420210          ORR      r2,r2,#0x10           ;1564
0000b4  60c2              STR      r2,[r0,#0xc]          ;1564
                  |L85.182|
0000b6  2201              MOVS     r2,#1                 ;1573
0000b8  6820              LDR      r0,[r4,#0]            ;1573
0000ba  f7fffffe          BL       TIM_CCxChannelCmd
0000be  491d              LDR      r1,|L85.308|
0000c0  6820              LDR      r0,[r4,#0]            ;1575
0000c2  4a1d              LDR      r2,|L85.312|
0000c4  4b1d              LDR      r3,|L85.316|
0000c6  4288              CMP      r0,r1                 ;1575
0000c8  d009              BEQ      |L85.222|
0000ca  4290              CMP      r0,r2                 ;1575
0000cc  d007              BEQ      |L85.222|
0000ce  4298              CMP      r0,r3                 ;1575
0000d0  d005              BEQ      |L85.222|
0000d2  4d1b              LDR      r5,|L85.320|
0000d4  42a8              CMP      r0,r5                 ;1575
0000d6  d002              BEQ      |L85.222|
0000d8  4d1a              LDR      r5,|L85.324|
0000da  42a8              CMP      r0,r5                 ;1575
0000dc  d103              BNE      |L85.230|
                  |L85.222|
0000de  6c45              LDR      r5,[r0,#0x44]         ;1578
0000e0  f4454500          ORR      r5,r5,#0x8000         ;1578
0000e4  6445              STR      r5,[r0,#0x44]         ;1578
                  |L85.230|
0000e6  6820              LDR      r0,[r4,#0]            ;1582
0000e8  4288              CMP      r0,r1                 ;1582
0000ea  d00f              BEQ      |L85.268|
0000ec  f1b04f80          CMP      r0,#0x40000000        ;1582
0000f0  d00c              BEQ      |L85.268|
0000f2  4915              LDR      r1,|L85.328|
0000f4  4288              CMP      r0,r1                 ;1582
0000f6  d009              BEQ      |L85.268|
0000f8  4914              LDR      r1,|L85.332|
0000fa  4288              CMP      r0,r1                 ;1582
0000fc  d006              BEQ      |L85.268|
0000fe  4914              LDR      r1,|L85.336|
000100  4288              CMP      r0,r1                 ;1582
000102  d003              BEQ      |L85.268|
000104  4290              CMP      r0,r2                 ;1582
000106  d001              BEQ      |L85.268|
000108  4298              CMP      r0,r3                 ;1582
00010a  d10c              BNE      |L85.294|
                  |L85.268|
00010c  6881              LDR      r1,[r0,#8]            ;1584
00010e  4a11              LDR      r2,|L85.340|
000110  4011              ANDS     r1,r1,r2              ;1584
000112  2906              CMP      r1,#6                 ;1585
000114  d00b              BEQ      |L85.302|
000116  f5b13f80          CMP      r1,#0x10000           ;1585
00011a  d008              BEQ      |L85.302|
00011c  6801              LDR      r1,[r0,#0]            ;1587
00011e  f0410101          ORR      r1,r1,#1              ;1587
000122  6001              STR      r1,[r0,#0]            ;1587
000124  e003              B        |L85.302|
                  |L85.294|
000126  6801              LDR      r1,[r0,#0]            ;1592
000128  f0410101          ORR      r1,r1,#1              ;1592
00012c  6001              STR      r1,[r0,#0]            ;1592
                  |L85.302|
00012e  2000              MOVS     r0,#0                 ;1596
000130  bd30              POP      {r4,r5,pc}
;;;1598   
                          ENDP

000132  0000              DCW      0x0000
                  |L85.308|
                          DCD      0x40012c00
                  |L85.312|
                          DCD      0x40013400
                  |L85.316|
                          DCD      0x40014000
                  |L85.320|
                          DCD      0x40014400
                  |L85.324|
                          DCD      0x40014800
                  |L85.328|
                          DCD      0x40000400
                  |L85.332|
                          DCD      0x40000800
                  |L85.336|
                          DCD      0x40000c00
                  |L85.340|
                          DCD      0x00010007

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1487     */
;;;1488   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1489   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1490     /* Check the parameters */
;;;1491     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1492   
;;;1493     /* Disable the Capture compare channel */
;;;1494     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1495   
;;;1496     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  4922              LDR      r1,|L86.156|
;;;1497     {
;;;1498       /* Disable the Main Output */
;;;1499       __HAL_TIM_MOE_DISABLE(htim);
000012  f2411211          MOV      r2,#0x1111
000016  6820              LDR      r0,[r4,#0]            ;1496
000018  1093              ASRS     r3,r2,#2
00001a  4288              CMP      r0,r1                 ;1496
00001c  d00b              BEQ      |L86.54|
00001e  4920              LDR      r1,|L86.160|
000020  4288              CMP      r0,r1                 ;1496
000022  d008              BEQ      |L86.54|
000024  491f              LDR      r1,|L86.164|
000026  4288              CMP      r0,r1                 ;1496
000028  d005              BEQ      |L86.54|
00002a  491f              LDR      r1,|L86.168|
00002c  4288              CMP      r0,r1                 ;1496
00002e  d002              BEQ      |L86.54|
000030  491e              LDR      r1,|L86.172|
000032  4288              CMP      r0,r1                 ;1496
000034  d109              BNE      |L86.74|
                  |L86.54|
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d106              BNE      |L86.74|
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4219              TST      r1,r3
000040  d103              BNE      |L86.74|
000042  6c41              LDR      r1,[r0,#0x44]
000044  f4214100          BIC      r1,r1,#0x8000
000048  6441              STR      r1,[r0,#0x44]
                  |L86.74|
;;;1500     }
;;;1501   
;;;1502     /* Disable the Peripheral */
;;;1503     __HAL_TIM_DISABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6a01              LDR      r1,[r0,#0x20]
00004e  4211              TST      r1,r2
000050  d106              BNE      |L86.96|
000052  6a01              LDR      r1,[r0,#0x20]
000054  4219              TST      r1,r3
000056  d103              BNE      |L86.96|
000058  6801              LDR      r1,[r0,#0]
00005a  f0210101          BIC      r1,r1,#1
00005e  6001              STR      r1,[r0,#0]
                  |L86.96|
;;;1504   
;;;1505     /* Set the TIM channel state */
;;;1506     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
000060  2001              MOVS     r0,#1
000062  b15d              CBZ      r5,|L86.124|
000064  2d04              CMP      r5,#4
000066  d00c              BEQ      |L86.130|
000068  2d08              CMP      r5,#8
00006a  d00d              BEQ      |L86.136|
00006c  2d0c              CMP      r5,#0xc
00006e  d00e              BEQ      |L86.142|
000070  2d10              CMP      r5,#0x10
000072  d00f              BEQ      |L86.148|
000074  f8840043          STRB     r0,[r4,#0x43]
                  |L86.120|
;;;1507   
;;;1508     /* Return function status */
;;;1509     return HAL_OK;
000078  2000              MOVS     r0,#0
;;;1510   }
00007a  bd30              POP      {r4,r5,pc}
                  |L86.124|
00007c  f884003e          STRB     r0,[r4,#0x3e]         ;1506
000080  e7fa              B        |L86.120|
                  |L86.130|
000082  f884003f          STRB     r0,[r4,#0x3f]         ;1506
000086  e7f7              B        |L86.120|
                  |L86.136|
000088  f8840040          STRB     r0,[r4,#0x40]         ;1506
00008c  e7f4              B        |L86.120|
                  |L86.142|
00008e  f8840041          STRB     r0,[r4,#0x41]         ;1506
000092  e7f1              B        |L86.120|
                  |L86.148|
000094  f8840042          STRB     r0,[r4,#0x42]         ;1506
000098  e7ee              B        |L86.120|
;;;1511   
                          ENDP

00009a  0000              DCW      0x0000
                  |L86.156|
                          DCD      0x40012c00
                  |L86.160|
                          DCD      0x40013400
                  |L86.164|
                          DCD      0x40014000
                  |L86.168|
                          DCD      0x40014400
                  |L86.172|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1833     */
;;;1834   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1835   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1836     /* Check the parameters */
;;;1837     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1838   
;;;1839     switch (Channel)
;;;1840     {
;;;1841       case TIM_CHANNEL_1:
;;;1842       {
;;;1843         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1844         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;1839
00000a  d006              BEQ      |L87.26|
00000c  2d04              CMP      r5,#4                 ;1839
00000e  d00c              BEQ      |L87.42|
000010  2d08              CMP      r5,#8                 ;1839
000012  d012              BEQ      |L87.58|
000014  2d0c              CMP      r5,#0xc               ;1839
000016  d11f              BNE      |L87.88|
000018  e017              B        |L87.74|
                  |L87.26|
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  f4217100          BIC      r1,r1,#0x200
000020  60c1              STR      r1,[r0,#0xc]
;;;1845         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000022  6a60              LDR      r0,[r4,#0x24]
000024  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1846         break;
000028  e016              B        |L87.88|
                  |L87.42|
;;;1847       }
;;;1848   
;;;1849       case TIM_CHANNEL_2:
;;;1850       {
;;;1851         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1852         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f4216180          BIC      r1,r1,#0x400
000030  60c1              STR      r1,[r0,#0xc]
;;;1853         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000032  6aa0              LDR      r0,[r4,#0x28]
000034  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1854         break;
000038  e00e              B        |L87.88|
                  |L87.58|
;;;1855       }
;;;1856   
;;;1857       case TIM_CHANNEL_3:
;;;1858       {
;;;1859         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1860         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00003a  68c1              LDR      r1,[r0,#0xc]
00003c  f4216100          BIC      r1,r1,#0x800
000040  60c1              STR      r1,[r0,#0xc]
;;;1861         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
000042  6ae0              LDR      r0,[r4,#0x2c]
000044  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1862         break;
000048  e006              B        |L87.88|
                  |L87.74|
;;;1863       }
;;;1864   
;;;1865       case TIM_CHANNEL_4:
;;;1866       {
;;;1867         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1868         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00004a  68c1              LDR      r1,[r0,#0xc]
00004c  f4215180          BIC      r1,r1,#0x1000
000050  60c1              STR      r1,[r0,#0xc]
;;;1869         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
000052  6b20              LDR      r0,[r4,#0x30]
000054  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L87.88|
;;;1870         break;
;;;1871       }
;;;1872   
;;;1873       default:
;;;1874         break;
;;;1875     }
;;;1876   
;;;1877     /* Disable the Capture compare channel */
;;;1878     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000058  2200              MOVS     r2,#0
00005a  4629              MOV      r1,r5
00005c  6820              LDR      r0,[r4,#0]
00005e  f7fffffe          BL       TIM_CCxChannelCmd
;;;1879   
;;;1880     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000062  4a22              LDR      r2,|L87.236|
;;;1881     {
;;;1882       /* Disable the Main Output */
;;;1883       __HAL_TIM_MOE_DISABLE(htim);
000064  f2411111          MOV      r1,#0x1111
000068  6820              LDR      r0,[r4,#0]            ;1880
00006a  108b              ASRS     r3,r1,#2
00006c  4290              CMP      r0,r2                 ;1880
00006e  d00b              BEQ      |L87.136|
000070  4a1f              LDR      r2,|L87.240|
000072  4290              CMP      r0,r2                 ;1880
000074  d008              BEQ      |L87.136|
000076  4a1f              LDR      r2,|L87.244|
000078  4290              CMP      r0,r2                 ;1880
00007a  d005              BEQ      |L87.136|
00007c  4a1e              LDR      r2,|L87.248|
00007e  4290              CMP      r0,r2                 ;1880
000080  d002              BEQ      |L87.136|
000082  4a1e              LDR      r2,|L87.252|
000084  4290              CMP      r0,r2                 ;1880
000086  d109              BNE      |L87.156|
                  |L87.136|
000088  6a02              LDR      r2,[r0,#0x20]
00008a  420a              TST      r2,r1
00008c  d106              BNE      |L87.156|
00008e  6a02              LDR      r2,[r0,#0x20]
000090  421a              TST      r2,r3
000092  d103              BNE      |L87.156|
000094  6c42              LDR      r2,[r0,#0x44]
000096  f4224200          BIC      r2,r2,#0x8000
00009a  6442              STR      r2,[r0,#0x44]
                  |L87.156|
;;;1884     }
;;;1885   
;;;1886     /* Disable the Peripheral */
;;;1887     __HAL_TIM_DISABLE(htim);
00009c  6820              LDR      r0,[r4,#0]
00009e  6a02              LDR      r2,[r0,#0x20]
0000a0  420a              TST      r2,r1
0000a2  d106              BNE      |L87.178|
0000a4  6a01              LDR      r1,[r0,#0x20]
0000a6  4219              TST      r1,r3
0000a8  d103              BNE      |L87.178|
0000aa  6801              LDR      r1,[r0,#0]
0000ac  f0210101          BIC      r1,r1,#1
0000b0  6001              STR      r1,[r0,#0]
                  |L87.178|
;;;1888   
;;;1889     /* Set the TIM channel state */
;;;1890     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
0000b2  2001              MOVS     r0,#1
0000b4  b15d              CBZ      r5,|L87.206|
0000b6  2d04              CMP      r5,#4
0000b8  d00c              BEQ      |L87.212|
0000ba  2d08              CMP      r5,#8
0000bc  d00d              BEQ      |L87.218|
0000be  2d0c              CMP      r5,#0xc
0000c0  d00e              BEQ      |L87.224|
0000c2  2d10              CMP      r5,#0x10
0000c4  d00f              BEQ      |L87.230|
0000c6  f8840043          STRB     r0,[r4,#0x43]
                  |L87.202|
;;;1891   
;;;1892     /* Return function status */
;;;1893     return HAL_OK;
0000ca  2000              MOVS     r0,#0
;;;1894   }
0000cc  bd70              POP      {r4-r6,pc}
                  |L87.206|
0000ce  f884003e          STRB     r0,[r4,#0x3e]         ;1890
0000d2  e7fa              B        |L87.202|
                  |L87.212|
0000d4  f884003f          STRB     r0,[r4,#0x3f]         ;1890
0000d8  e7f7              B        |L87.202|
                  |L87.218|
0000da  f8840040          STRB     r0,[r4,#0x40]         ;1890
0000de  e7f4              B        |L87.202|
                  |L87.224|
0000e0  f8840041          STRB     r0,[r4,#0x41]         ;1890
0000e4  e7f1              B        |L87.202|
                  |L87.230|
0000e6  f8840042          STRB     r0,[r4,#0x42]         ;1890
0000ea  e7ee              B        |L87.202|
;;;1895   
                          ENDP

                  |L87.236|
                          DCD      0x40012c00
                  |L87.240|
                          DCD      0x40013400
                  |L87.244|
                          DCD      0x40014000
                  |L87.248|
                          DCD      0x40014400
                  |L87.252|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1609     */
;;;1610   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1611   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1612     /* Check the parameters */
;;;1613     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1614   
;;;1615     switch (Channel)
;;;1616     {
;;;1617       case TIM_CHANNEL_1:
;;;1618       {
;;;1619         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1620         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  2d00              CMP      r5,#0                 ;1615
00000a  d006              BEQ      |L88.26|
00000c  2d04              CMP      r5,#4                 ;1615
00000e  d009              BEQ      |L88.36|
000010  2d08              CMP      r5,#8                 ;1615
000012  d00c              BEQ      |L88.46|
000014  2d0c              CMP      r5,#0xc               ;1615
000016  d113              BNE      |L88.64|
000018  e00e              B        |L88.56|
                  |L88.26|
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  f0210102          BIC      r1,r1,#2
000020  60c1              STR      r1,[r0,#0xc]
;;;1621         break;
000022  e00d              B        |L88.64|
                  |L88.36|
;;;1622       }
;;;1623   
;;;1624       case TIM_CHANNEL_2:
;;;1625       {
;;;1626         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1627         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  68c1              LDR      r1,[r0,#0xc]
000026  f0210104          BIC      r1,r1,#4
00002a  60c1              STR      r1,[r0,#0xc]
;;;1628         break;
00002c  e008              B        |L88.64|
                  |L88.46|
;;;1629       }
;;;1630   
;;;1631       case TIM_CHANNEL_3:
;;;1632       {
;;;1633         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1634         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002e  68c1              LDR      r1,[r0,#0xc]
000030  f0210108          BIC      r1,r1,#8
000034  60c1              STR      r1,[r0,#0xc]
;;;1635         break;
000036  e003              B        |L88.64|
                  |L88.56|
;;;1636       }
;;;1637   
;;;1638       case TIM_CHANNEL_4:
;;;1639       {
;;;1640         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1641         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000038  68c1              LDR      r1,[r0,#0xc]
00003a  f0210110          BIC      r1,r1,#0x10
00003e  60c1              STR      r1,[r0,#0xc]
                  |L88.64|
;;;1642         break;
;;;1643       }
;;;1644   
;;;1645       default:
;;;1646         break;
;;;1647     }
;;;1648   
;;;1649     /* Disable the Capture compare channel */
;;;1650     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000040  2200              MOVS     r2,#0
000042  4629              MOV      r1,r5
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       TIM_CCxChannelCmd
;;;1651   
;;;1652     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00004a  4922              LDR      r1,|L88.212|
;;;1653     {
;;;1654       /* Disable the Main Output */
;;;1655       __HAL_TIM_MOE_DISABLE(htim);
00004c  f2411211          MOV      r2,#0x1111
000050  6820              LDR      r0,[r4,#0]            ;1652
000052  1093              ASRS     r3,r2,#2
000054  4288              CMP      r0,r1                 ;1652
000056  d00b              BEQ      |L88.112|
000058  491f              LDR      r1,|L88.216|
00005a  4288              CMP      r0,r1                 ;1652
00005c  d008              BEQ      |L88.112|
00005e  491f              LDR      r1,|L88.220|
000060  4288              CMP      r0,r1                 ;1652
000062  d005              BEQ      |L88.112|
000064  491e              LDR      r1,|L88.224|
000066  4288              CMP      r0,r1                 ;1652
000068  d002              BEQ      |L88.112|
00006a  491e              LDR      r1,|L88.228|
00006c  4288              CMP      r0,r1                 ;1652
00006e  d109              BNE      |L88.132|
                  |L88.112|
000070  6a01              LDR      r1,[r0,#0x20]
000072  4211              TST      r1,r2
000074  d106              BNE      |L88.132|
000076  6a01              LDR      r1,[r0,#0x20]
000078  4219              TST      r1,r3
00007a  d103              BNE      |L88.132|
00007c  6c41              LDR      r1,[r0,#0x44]
00007e  f4214100          BIC      r1,r1,#0x8000
000082  6441              STR      r1,[r0,#0x44]
                  |L88.132|
;;;1656     }
;;;1657   
;;;1658     /* Disable the Peripheral */
;;;1659     __HAL_TIM_DISABLE(htim);
000084  6820              LDR      r0,[r4,#0]
000086  6a01              LDR      r1,[r0,#0x20]
000088  4211              TST      r1,r2
00008a  d106              BNE      |L88.154|
00008c  6a01              LDR      r1,[r0,#0x20]
00008e  4219              TST      r1,r3
000090  d103              BNE      |L88.154|
000092  6801              LDR      r1,[r0,#0]
000094  f0210101          BIC      r1,r1,#1
000098  6001              STR      r1,[r0,#0]
                  |L88.154|
;;;1660   
;;;1661     /* Set the TIM channel state */
;;;1662     TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
00009a  2001              MOVS     r0,#1
00009c  b15d              CBZ      r5,|L88.182|
00009e  2d04              CMP      r5,#4
0000a0  d00c              BEQ      |L88.188|
0000a2  2d08              CMP      r5,#8
0000a4  d00d              BEQ      |L88.194|
0000a6  2d0c              CMP      r5,#0xc
0000a8  d00e              BEQ      |L88.200|
0000aa  2d10              CMP      r5,#0x10
0000ac  d00f              BEQ      |L88.206|
0000ae  f8840043          STRB     r0,[r4,#0x43]
                  |L88.178|
;;;1663   
;;;1664     /* Return function status */
;;;1665     return HAL_OK;
0000b2  2000              MOVS     r0,#0
;;;1666   }
0000b4  bd30              POP      {r4,r5,pc}
                  |L88.182|
0000b6  f884003e          STRB     r0,[r4,#0x3e]         ;1662
0000ba  e7fa              B        |L88.178|
                  |L88.188|
0000bc  f884003f          STRB     r0,[r4,#0x3f]         ;1662
0000c0  e7f7              B        |L88.178|
                  |L88.194|
0000c2  f8840040          STRB     r0,[r4,#0x40]         ;1662
0000c6  e7f4              B        |L88.178|
                  |L88.200|
0000c8  f8840041          STRB     r0,[r4,#0x41]         ;1662
0000cc  e7f1              B        |L88.178|
                  |L88.206|
0000ce  f8840042          STRB     r0,[r4,#0x42]         ;1662
0000d2  e7ee              B        |L88.178|
;;;1667   
                          ENDP

                  |L88.212|
                          DCD      0x40012c00
                  |L88.216|
                          DCD      0x40013400
                  |L88.220|
                          DCD      0x40014000
                  |L88.224|
                          DCD      0x40014400
                  |L88.228|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;5640     */
;;;5641   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5642   {
;;;5643     /* Prevent unused argument(s) compilation warning */
;;;5644     UNUSED(htim);
;;;5645   
;;;5646     /* NOTE : This function should not be modified, when the callback is needed,
;;;5647               the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;5648      */
;;;5649   }
;;;5650   
                          ENDP


                          AREA ||i.HAL_TIM_PeriodElapsedHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedHalfCpltCallback PROC
;;;5655     */
;;;5656   __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5657   {
;;;5658     /* Prevent unused argument(s) compilation warning */
;;;5659     UNUSED(htim);
;;;5660   
;;;5661     /* NOTE : This function should not be modified, when the callback is needed,
;;;5662               the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
;;;5663      */
;;;5664   }
;;;5665   
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;5556     */
;;;5557   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;5558   {
;;;5559     uint32_t tmpreg = 0U;
000002  2000              MOVS     r0,#0
;;;5560   
;;;5561     switch (Channel)
000004  2900              CMP      r1,#0
000006  d008              BEQ      |L91.26|
000008  2904              CMP      r1,#4
00000a  d009              BEQ      |L91.32|
00000c  2908              CMP      r1,#8
00000e  d00a              BEQ      |L91.38|
000010  290c              CMP      r1,#0xc
000012  d101              BNE      |L91.24|
;;;5562     {
;;;5563       case TIM_CHANNEL_1:
;;;5564       {
;;;5565         /* Check the parameters */
;;;5566         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5567   
;;;5568         /* Return the capture 1 value */
;;;5569         tmpreg =  htim->Instance->CCR1;
;;;5570   
;;;5571         break;
;;;5572       }
;;;5573       case TIM_CHANNEL_2:
;;;5574       {
;;;5575         /* Check the parameters */
;;;5576         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5577   
;;;5578         /* Return the capture 2 value */
;;;5579         tmpreg =   htim->Instance->CCR2;
;;;5580   
;;;5581         break;
;;;5582       }
;;;5583   
;;;5584       case TIM_CHANNEL_3:
;;;5585       {
;;;5586         /* Check the parameters */
;;;5587         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;5588   
;;;5589         /* Return the capture 3 value */
;;;5590         tmpreg =   htim->Instance->CCR3;
;;;5591   
;;;5592         break;
;;;5593       }
;;;5594   
;;;5595       case TIM_CHANNEL_4:
;;;5596       {
;;;5597         /* Check the parameters */
;;;5598         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;5599   
;;;5600         /* Return the capture 4 value */
;;;5601         tmpreg =   htim->Instance->CCR4;
000014  6810              LDR      r0,[r2,#0]
000016  6c00              LDR      r0,[r0,#0x40]
                  |L91.24|
;;;5602   
;;;5603         break;
;;;5604       }
;;;5605   
;;;5606       default:
;;;5607         break;
;;;5608     }
;;;5609   
;;;5610     return tmpreg;
;;;5611   }
000018  4770              BX       lr
                  |L91.26|
00001a  6810              LDR      r0,[r2,#0]            ;5569
00001c  6b40              LDR      r0,[r0,#0x34]         ;5569
00001e  4770              BX       lr
                  |L91.32|
000020  6810              LDR      r0,[r2,#0]            ;5579
000022  6b80              LDR      r0,[r0,#0x38]         ;5579
000024  4770              BX       lr
                  |L91.38|
000026  6810              LDR      r0,[r2,#0]            ;5590
000028  6bc0              LDR      r0,[r0,#0x3c]         ;5590
00002a  4770              BX       lr
;;;5612   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchro||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchro PROC
;;;5473     */
;;;5474   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;5475   {
000002  4604              MOV      r4,r0
;;;5476     /* Check the parameters */
;;;5477     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;5478     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;5479     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;5480   
;;;5481     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d00f              BEQ      |L92.44|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;5482   
;;;5483     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;5484   
;;;5485     if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00001e  2100              MOVS     r1,#0
000020  b130              CBZ      r0,|L92.48|
;;;5486     {
;;;5487       htim->State = HAL_TIM_STATE_READY;
000022  343c              ADDS     r4,r4,#0x3c
000024  7065              STRB     r5,[r4,#1]
;;;5488       __HAL_UNLOCK(htim);
000026  7021              STRB     r1,[r4,#0]
;;;5489       return HAL_ERROR;
000028  2001              MOVS     r0,#1
;;;5490     }
;;;5491   
;;;5492     /* Disable Trigger Interrupt */
;;;5493     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
;;;5494   
;;;5495     /* Disable Trigger DMA request */
;;;5496     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;5497   
;;;5498     htim->State = HAL_TIM_STATE_READY;
;;;5499   
;;;5500     __HAL_UNLOCK(htim);
;;;5501   
;;;5502     return HAL_OK;
;;;5503   }
00002a  bd70              POP      {r4-r6,pc}
                  |L92.44|
00002c  2002              MOVS     r0,#2                 ;5481
00002e  bd70              POP      {r4-r6,pc}
                  |L92.48|
000030  6820              LDR      r0,[r4,#0]            ;5493
000032  68c2              LDR      r2,[r0,#0xc]          ;5493
000034  f0220240          BIC      r2,r2,#0x40           ;5493
000038  60c2              STR      r2,[r0,#0xc]          ;5493
00003a  6820              LDR      r0,[r4,#0]            ;5496
00003c  68c2              LDR      r2,[r0,#0xc]          ;5496
00003e  f4224280          BIC      r2,r2,#0x4000         ;5496
000042  60c2              STR      r2,[r0,#0xc]          ;5496
000044  f884503d          STRB     r5,[r4,#0x3d]         ;5498
000048  f884103c          STRB     r1,[r4,#0x3c]         ;5500
00004c  2000              MOVS     r0,#0                 ;5502
00004e  bd70              POP      {r4-r6,pc}
;;;5504   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchro_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchro_IT PROC
;;;5513     */
;;;5514   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;5515                                                   TIM_SlaveConfigTypeDef *sSlaveConfig)
;;;5516   {
000002  4604              MOV      r4,r0
;;;5517     /* Check the parameters */
;;;5518     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;5519     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;5520     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;5521   
;;;5522     __HAL_LOCK(htim);
000004  f894003c          LDRB     r0,[r4,#0x3c]
000008  2801              CMP      r0,#1
00000a  d00f              BEQ      |L93.44|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;5523   
;;;5524     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f884003d          STRB     r0,[r4,#0x3d]
;;;5525   
;;;5526     if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00001e  2100              MOVS     r1,#0
000020  b130              CBZ      r0,|L93.48|
;;;5527     {
;;;5528       htim->State = HAL_TIM_STATE_READY;
000022  343c              ADDS     r4,r4,#0x3c
000024  7065              STRB     r5,[r4,#1]
;;;5529       __HAL_UNLOCK(htim);
000026  7021              STRB     r1,[r4,#0]
;;;5530       return HAL_ERROR;
000028  2001              MOVS     r0,#1
;;;5531     }
;;;5532   
;;;5533     /* Enable Trigger Interrupt */
;;;5534     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;5535   
;;;5536     /* Disable Trigger DMA request */
;;;5537     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;5538   
;;;5539     htim->State = HAL_TIM_STATE_READY;
;;;5540   
;;;5541     __HAL_UNLOCK(htim);
;;;5542   
;;;5543     return HAL_OK;
;;;5544   }
00002a  bd70              POP      {r4-r6,pc}
                  |L93.44|
00002c  2002              MOVS     r0,#2                 ;5522
00002e  bd70              POP      {r4-r6,pc}
                  |L93.48|
000030  6820              LDR      r0,[r4,#0]            ;5534
000032  68c2              LDR      r2,[r0,#0xc]          ;5534
000034  f0420240          ORR      r2,r2,#0x40           ;5534
000038  60c2              STR      r2,[r0,#0xc]          ;5534
00003a  6820              LDR      r0,[r4,#0]            ;5537
00003c  68c2              LDR      r2,[r0,#0xc]          ;5537
00003e  f4224280          BIC      r2,r2,#0x4000         ;5537
000042  60c2              STR      r2,[r0,#0xc]          ;5537
000044  f884503d          STRB     r5,[r4,#0x3d]         ;5539
000048  f884103c          STRB     r1,[r4,#0x3c]         ;5541
00004c  2000              MOVS     r0,#0                 ;5543
00004e  bd70              POP      {r4-r6,pc}
;;;5545   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;5745     */
;;;5746   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5747   {
;;;5748     /* Prevent unused argument(s) compilation warning */
;;;5749     UNUSED(htim);
;;;5750   
;;;5751     /* NOTE : This function should not be modified, when the callback is needed,
;;;5752               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;5753      */
;;;5754   }
;;;5755   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerHalfCpltCallback PROC
;;;5760     */
;;;5761   __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;5762   {
;;;5763     /* Prevent unused argument(s) compilation warning */
;;;5764     UNUSED(htim);
;;;5765   
;;;5766     /* NOTE : This function should not be modified, when the callback is needed,
;;;5767               the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
;;;5768      */
;;;5769   }
;;;5770   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;6740     */
;;;6741   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;6742   {
;;;6743     uint32_t tmpcr1;
;;;6744     tmpcr1 = TIMx->CR1;
000004  6802              LDR      r2,[r0,#0]
;;;6745   
;;;6746     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;6747     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000006  4d26              LDR      r5,|L96.160|
000008  f8df8098          LDR      r8,|L96.164|
00000c  f8df9098          LDR      r9,|L96.168|
000010  f8dfa098          LDR      r10,|L96.172|
000014  4b26              LDR      r3,|L96.176|
000016  f04f4b80          MOV      r11,#0x40000000
00001a  42a8              CMP      r0,r5
00001c  d009              BEQ      |L96.50|
00001e  4558              CMP      r0,r11
000020  d007              BEQ      |L96.50|
000022  4540              CMP      r0,r8
000024  d005              BEQ      |L96.50|
000026  4548              CMP      r0,r9
000028  d003              BEQ      |L96.50|
00002a  4550              CMP      r0,r10
00002c  d001              BEQ      |L96.50|
00002e  4298              CMP      r0,r3
000030  d103              BNE      |L96.58|
                  |L96.50|
;;;6748     {
;;;6749       /* Select the Counter Mode */
;;;6750       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000032  f0220470          BIC      r4,r2,#0x70
;;;6751       tmpcr1 |= Structure->CounterMode;
000036  684a              LDR      r2,[r1,#4]
000038  4322              ORRS     r2,r2,r4
                  |L96.58|
;;;6752     }
;;;6753   
;;;6754     if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
00003a  4e1e              LDR      r6,|L96.180|
00003c  4f1e              LDR      r7,|L96.184|
00003e  f8dfc07c          LDR      r12,|L96.188|
000042  42a8              CMP      r0,r5
000044  d00f              BEQ      |L96.102|
000046  4558              CMP      r0,r11
000048  d00d              BEQ      |L96.102|
00004a  4540              CMP      r0,r8
00004c  d00b              BEQ      |L96.102|
00004e  4548              CMP      r0,r9
000050  d009              BEQ      |L96.102|
000052  4550              CMP      r0,r10
000054  d007              BEQ      |L96.102|
000056  4298              CMP      r0,r3
000058  d005              BEQ      |L96.102|
00005a  42b0              CMP      r0,r6
00005c  d003              BEQ      |L96.102|
00005e  42b8              CMP      r0,r7
000060  d001              BEQ      |L96.102|
000062  4560              CMP      r0,r12
000064  d103              BNE      |L96.110|
                  |L96.102|
;;;6755     {
;;;6756       /* Set the clock division */
;;;6757       tmpcr1 &= ~TIM_CR1_CKD;
000066  f4227440          BIC      r4,r2,#0x300
;;;6758       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00006a  68ca              LDR      r2,[r1,#0xc]
00006c  4322              ORRS     r2,r2,r4
                  |L96.110|
;;;6759     }
;;;6760   
;;;6761     /* Set the auto-reload preload */
;;;6762     MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
00006e  694c              LDR      r4,[r1,#0x14]
000070  f0220280          BIC      r2,r2,#0x80
000074  4322              ORRS     r2,r2,r4
;;;6763   
;;;6764     TIMx->CR1 = tmpcr1;
000076  6002              STR      r2,[r0,#0]
;;;6765   
;;;6766     /* Set the Autoreload value */
;;;6767     TIMx->ARR = (uint32_t)Structure->Period ;
000078  688a              LDR      r2,[r1,#8]
00007a  62c2              STR      r2,[r0,#0x2c]
;;;6768   
;;;6769     /* Set the Prescaler value */
;;;6770     TIMx->PSC = Structure->Prescaler;
00007c  680a              LDR      r2,[r1,#0]
00007e  6282              STR      r2,[r0,#0x28]
;;;6771   
;;;6772     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
000080  42a8              CMP      r0,r5
000082  d007              BEQ      |L96.148|
000084  4298              CMP      r0,r3
000086  d005              BEQ      |L96.148|
000088  42b0              CMP      r0,r6
00008a  d003              BEQ      |L96.148|
00008c  42b8              CMP      r0,r7
00008e  d001              BEQ      |L96.148|
000090  4560              CMP      r0,r12
000092  d101              BNE      |L96.152|
                  |L96.148|
;;;6773     {
;;;6774       /* Set the Repetition Counter value */
;;;6775       TIMx->RCR = Structure->RepetitionCounter;
000094  6909              LDR      r1,[r1,#0x10]
000096  6301              STR      r1,[r0,#0x30]
                  |L96.152|
;;;6776     }
;;;6777   
;;;6778     /* Generate an update event to reload the Prescaler
;;;6779        and the repetition counter (only for advanced timer) value immediately */
;;;6780     TIMx->EGR = TIM_EGR_UG;
000098  2101              MOVS     r1,#1
00009a  6141              STR      r1,[r0,#0x14]
;;;6781   }
00009c  e8bd8ff0          POP      {r4-r11,pc}
;;;6782   
                          ENDP

                  |L96.160|
                          DCD      0x40012c00
                  |L96.164|
                          DCD      0x40000400
                  |L96.168|
                          DCD      0x40000800
                  |L96.172|
                          DCD      0x40000c00
                  |L96.176|
                          DCD      0x40013400
                  |L96.180|
                          DCD      0x40014000
                  |L96.184|
                          DCD      0x40014400
                  |L96.188|
                          DCD      0x40014800

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;7637     */
;;;7638   void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b510              PUSH     {r4,lr}
;;;7639   {
;;;7640     uint32_t tmp;
;;;7641   
;;;7642     /* Check the parameters */
;;;7643     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;7644     assert_param(IS_TIM_CHANNELS(Channel));
;;;7645   
;;;7646     tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
000002  f001011f          AND      r1,r1,#0x1f
000006  2301              MOVS     r3,#1
000008  408b              LSLS     r3,r3,r1
;;;7647   
;;;7648     /* Reset the CCxE Bit */
;;;7649     TIMx->CCER &= ~tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  6204              STR      r4,[r0,#0x20]
;;;7650   
;;;7651     /* Set or reset the CCxE Bit */
;;;7652     TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
000010  6a03              LDR      r3,[r0,#0x20]
000012  408a              LSLS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  6203              STR      r3,[r0,#0x20]
;;;7653   }
000018  bd10              POP      {r4,pc}
;;;7654   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;6563     */
;;;6564   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6565   {
;;;6566     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;6567   
;;;6568     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
;;;6569     {
;;;6570       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000004  2101              MOVS     r1,#1
000006  6a62              LDR      r2,[r4,#0x24]         ;6568
000008  4282              CMP      r2,r0                 ;6568
00000a  d107              BNE      |L98.28|
00000c  7721              STRB     r1,[r4,#0x1c]
;;;6571   
;;;6572       if (hdma->Init.Mode == DMA_NORMAL)
00000e  69c0              LDR      r0,[r0,#0x1c]
000010  bb38              CBNZ     r0,|L98.98|
;;;6573       {
;;;6574         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000012  f884103e          STRB     r1,[r4,#0x3e]
;;;6575         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000016  f8841044          STRB     r1,[r4,#0x44]
00001a  e022              B        |L98.98|
                  |L98.28|
;;;6576       }
;;;6577     }
;;;6578     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
00001c  6aa2              LDR      r2,[r4,#0x28]
00001e  4282              CMP      r2,r0
000020  d108              BNE      |L98.52|
;;;6579     {
;;;6580       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000022  2202              MOVS     r2,#2
000024  7722              STRB     r2,[r4,#0x1c]
;;;6581   
;;;6582       if (hdma->Init.Mode == DMA_NORMAL)
000026  69c0              LDR      r0,[r0,#0x1c]
000028  b9d8              CBNZ     r0,|L98.98|
;;;6583       {
;;;6584         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00002a  f884103f          STRB     r1,[r4,#0x3f]
;;;6585         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00002e  f8841045          STRB     r1,[r4,#0x45]
000032  e016              B        |L98.98|
                  |L98.52|
;;;6586       }
;;;6587     }
;;;6588     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000034  6ae2              LDR      r2,[r4,#0x2c]
000036  4282              CMP      r2,r0
000038  d108              BNE      |L98.76|
;;;6589     {
;;;6590       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00003a  2204              MOVS     r2,#4
00003c  7722              STRB     r2,[r4,#0x1c]
;;;6591   
;;;6592       if (hdma->Init.Mode == DMA_NORMAL)
00003e  69c0              LDR      r0,[r0,#0x1c]
000040  b978              CBNZ     r0,|L98.98|
;;;6593       {
;;;6594         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
000042  f8841040          STRB     r1,[r4,#0x40]
;;;6595         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
000046  f8841046          STRB     r1,[r4,#0x46]
00004a  e00a              B        |L98.98|
                  |L98.76|
;;;6596       }
;;;6597     }
;;;6598     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
00004c  6b22              LDR      r2,[r4,#0x30]
00004e  4282              CMP      r2,r0
000050  d107              BNE      |L98.98|
;;;6599     {
;;;6600       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000052  2208              MOVS     r2,#8
000054  7722              STRB     r2,[r4,#0x1c]
;;;6601   
;;;6602       if (hdma->Init.Mode == DMA_NORMAL)
000056  69c0              LDR      r0,[r0,#0x1c]
000058  b918              CBNZ     r0,|L98.98|
;;;6603       {
;;;6604         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
00005a  f8841041          STRB     r1,[r4,#0x41]
;;;6605         TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
00005e  f8841047          STRB     r1,[r4,#0x47]
                  |L98.98|
;;;6606       }
;;;6607     }
;;;6608     else
;;;6609     {
;;;6610       /* nothing to do */
;;;6611     }
;;;6612   
;;;6613   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6614     htim->IC_CaptureCallback(htim);
;;;6615   #else
;;;6616     HAL_TIM_IC_CaptureCallback(htim);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;6617   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6618   
;;;6619     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000068  2000              MOVS     r0,#0
00006a  7720              STRB     r0,[r4,#0x1c]
;;;6620   }
00006c  bd10              POP      {r4,pc}
;;;6621   
                          ENDP


                          AREA ||i.TIM_DMACaptureHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureHalfCplt PROC
;;;6626     */
;;;6627   void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6628   {
;;;6629     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;6630   
;;;6631     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000004  6a61              LDR      r1,[r4,#0x24]
000006  4281              CMP      r1,r0
000008  d102              BNE      |L99.16|
;;;6632     {
;;;6633       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000a  2001              MOVS     r0,#1
00000c  7720              STRB     r0,[r4,#0x1c]
00000e  e010              B        |L99.50|
                  |L99.16|
;;;6634     }
;;;6635     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000010  6aa1              LDR      r1,[r4,#0x28]
000012  4281              CMP      r1,r0
000014  d102              BNE      |L99.28|
;;;6636     {
;;;6637       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  2002              MOVS     r0,#2
000018  7720              STRB     r0,[r4,#0x1c]
00001a  e00a              B        |L99.50|
                  |L99.28|
;;;6638     }
;;;6639     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001c  6ae1              LDR      r1,[r4,#0x2c]
00001e  4281              CMP      r1,r0
000020  d102              BNE      |L99.40|
;;;6640     {
;;;6641       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  2004              MOVS     r0,#4
000024  7720              STRB     r0,[r4,#0x1c]
000026  e004              B        |L99.50|
                  |L99.40|
;;;6642     }
;;;6643     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L99.50|
;;;6644     {
;;;6645       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
000030  7720              STRB     r0,[r4,#0x1c]
                  |L99.50|
;;;6646     }
;;;6647     else
;;;6648     {
;;;6649       /* nothing to do */
;;;6650     }
;;;6651   
;;;6652   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6653     htim->IC_CaptureHalfCpltCallback(htim);
;;;6654   #else
;;;6655     HAL_TIM_IC_CaptureHalfCpltCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_IC_CaptureHalfCpltCallback
;;;6656   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6657   
;;;6658     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  7720              STRB     r0,[r4,#0x1c]
;;;6659   }
00003c  bd10              POP      {r4,pc}
;;;6660   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;6465     */
;;;6466   static void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6467   {
;;;6468     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;6469   
;;;6470     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
;;;6471     {
;;;6472       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000004  2101              MOVS     r1,#1
000006  6a62              LDR      r2,[r4,#0x24]         ;6470
000008  4282              CMP      r2,r0                 ;6470
00000a  d105              BNE      |L100.24|
00000c  7721              STRB     r1,[r4,#0x1c]
;;;6473   
;;;6474       if (hdma->Init.Mode == DMA_NORMAL)
00000e  69c0              LDR      r0,[r0,#0x1c]
000010  b9f8              CBNZ     r0,|L100.82|
;;;6475       {
;;;6476         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
000012  f884103e          STRB     r1,[r4,#0x3e]
000016  e01c              B        |L100.82|
                  |L100.24|
;;;6477       }
;;;6478     }
;;;6479     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa2              LDR      r2,[r4,#0x28]
00001a  4282              CMP      r2,r0
00001c  d106              BNE      |L100.44|
;;;6480     {
;;;6481       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2202              MOVS     r2,#2
000020  7722              STRB     r2,[r4,#0x1c]
;;;6482   
;;;6483       if (hdma->Init.Mode == DMA_NORMAL)
000022  69c0              LDR      r0,[r0,#0x1c]
000024  b9a8              CBNZ     r0,|L100.82|
;;;6484       {
;;;6485         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
000026  f884103f          STRB     r1,[r4,#0x3f]
00002a  e012              B        |L100.82|
                  |L100.44|
;;;6486       }
;;;6487     }
;;;6488     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00002c  6ae2              LDR      r2,[r4,#0x2c]
00002e  4282              CMP      r2,r0
000030  d106              BNE      |L100.64|
;;;6489     {
;;;6490       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000032  2204              MOVS     r2,#4
000034  7722              STRB     r2,[r4,#0x1c]
;;;6491   
;;;6492       if (hdma->Init.Mode == DMA_NORMAL)
000036  69c0              LDR      r0,[r0,#0x1c]
000038  b958              CBNZ     r0,|L100.82|
;;;6493       {
;;;6494         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
00003a  f8841040          STRB     r1,[r4,#0x40]
00003e  e008              B        |L100.82|
                  |L100.64|
;;;6495       }
;;;6496     }
;;;6497     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000040  6b22              LDR      r2,[r4,#0x30]
000042  4282              CMP      r2,r0
000044  d105              BNE      |L100.82|
;;;6498     {
;;;6499       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000046  2208              MOVS     r2,#8
000048  7722              STRB     r2,[r4,#0x1c]
;;;6500   
;;;6501       if (hdma->Init.Mode == DMA_NORMAL)
00004a  69c0              LDR      r0,[r0,#0x1c]
00004c  b908              CBNZ     r0,|L100.82|
;;;6502       {
;;;6503         TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
00004e  f8841041          STRB     r1,[r4,#0x41]
                  |L100.82|
;;;6504       }
;;;6505     }
;;;6506     else
;;;6507     {
;;;6508       /* nothing to do */
;;;6509     }
;;;6510   
;;;6511   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6512     htim->PWM_PulseFinishedCallback(htim);
;;;6513   #else
;;;6514     HAL_TIM_PWM_PulseFinishedCallback(htim);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;6515   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6516   
;;;6517     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000058  2000              MOVS     r0,#0
00005a  7720              STRB     r0,[r4,#0x1c]
;;;6518   }
00005c  bd10              POP      {r4,pc}
;;;6519   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseHalfCplt PROC
;;;6524     */
;;;6525   void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6526   {
;;;6527     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;6528   
;;;6529     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000004  6a61              LDR      r1,[r4,#0x24]
000006  4281              CMP      r1,r0
000008  d102              BNE      |L101.16|
;;;6530     {
;;;6531       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000a  2001              MOVS     r0,#1
00000c  7720              STRB     r0,[r4,#0x1c]
00000e  e010              B        |L101.50|
                  |L101.16|
;;;6532     }
;;;6533     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000010  6aa1              LDR      r1,[r4,#0x28]
000012  4281              CMP      r1,r0
000014  d102              BNE      |L101.28|
;;;6534     {
;;;6535       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  2002              MOVS     r0,#2
000018  7720              STRB     r0,[r4,#0x1c]
00001a  e00a              B        |L101.50|
                  |L101.28|
;;;6536     }
;;;6537     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001c  6ae1              LDR      r1,[r4,#0x2c]
00001e  4281              CMP      r1,r0
000020  d102              BNE      |L101.40|
;;;6538     {
;;;6539       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  2004              MOVS     r0,#4
000024  7720              STRB     r0,[r4,#0x1c]
000026  e004              B        |L101.50|
                  |L101.40|
;;;6540     }
;;;6541     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
00002c  d101              BNE      |L101.50|
;;;6542     {
;;;6543       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002e  2008              MOVS     r0,#8
000030  7720              STRB     r0,[r4,#0x1c]
                  |L101.50|
;;;6544     }
;;;6545     else
;;;6546     {
;;;6547       /* nothing to do */
;;;6548     }
;;;6549   
;;;6550   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6551     htim->PWM_PulseFinishedHalfCpltCallback(htim);
;;;6552   #else
;;;6553     HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedHalfCpltCallback
;;;6554   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6555   
;;;6556     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000038  2000              MOVS     r0,#0
00003a  7720              STRB     r0,[r4,#0x1c]
;;;6557   }
00003c  bd10              POP      {r4,pc}
;;;6558   
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;6422     */
;;;6423   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6424   {
;;;6425     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a84              LDR      r4,[r0,#0x28]
;;;6426   
;;;6427     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
;;;6428     {
;;;6429       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000004  2101              MOVS     r1,#1
000006  6a62              LDR      r2,[r4,#0x24]         ;6427
000008  4282              CMP      r2,r0                 ;6427
00000a  d103              BNE      |L102.20|
00000c  7721              STRB     r1,[r4,#0x1c]
;;;6430       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
00000e  f884103e          STRB     r1,[r4,#0x3e]
000012  e019              B        |L102.72|
                  |L102.20|
;;;6431     }
;;;6432     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000014  6aa2              LDR      r2,[r4,#0x28]
000016  4282              CMP      r2,r0
000018  d104              BNE      |L102.36|
;;;6433     {
;;;6434       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001a  2002              MOVS     r0,#2
00001c  7720              STRB     r0,[r4,#0x1c]
;;;6435       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
00001e  f884103f          STRB     r1,[r4,#0x3f]
000022  e011              B        |L102.72|
                  |L102.36|
;;;6436     }
;;;6437     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae2              LDR      r2,[r4,#0x2c]
000026  4282              CMP      r2,r0
000028  d104              BNE      |L102.52|
;;;6438     {
;;;6439       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
;;;6440       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
00002e  f8841040          STRB     r1,[r4,#0x40]
000032  e009              B        |L102.72|
                  |L102.52|
;;;6441     }
;;;6442     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000034  6b22              LDR      r2,[r4,#0x30]
000036  4282              CMP      r2,r0
000038  d104              BNE      |L102.68|
;;;6443     {
;;;6444       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00003a  2008              MOVS     r0,#8
00003c  7720              STRB     r0,[r4,#0x1c]
;;;6445       TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
00003e  f8841041          STRB     r1,[r4,#0x41]
000042  e001              B        |L102.72|
                  |L102.68|
;;;6446     }
;;;6447     else
;;;6448     {
;;;6449       htim->State = HAL_TIM_STATE_READY;
000044  f884103d          STRB     r1,[r4,#0x3d]
                  |L102.72|
;;;6450     }
;;;6451   
;;;6452   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6453     htim->ErrorCallback(htim);
;;;6454   #else
;;;6455     HAL_TIM_ErrorCallback(htim);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;6456   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6457   
;;;6458     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00004e  2000              MOVS     r0,#0
000050  7720              STRB     r0,[r4,#0x1c]
;;;6459   }
000052  bd10              POP      {r4,pc}
;;;6460   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;6665     */
;;;6666   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6667   {
;;;6668     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;6669   
;;;6670     if (htim->hdma[TIM_DMA_ID_UPDATE]->Init.Mode == DMA_NORMAL)
000004  6a01              LDR      r1,[r0,#0x20]
000006  69c9              LDR      r1,[r1,#0x1c]
000008  2900              CMP      r1,#0
00000a  d102              BNE      |L103.18|
;;;6671     {
;;;6672       htim->State = HAL_TIM_STATE_READY;
00000c  2101              MOVS     r1,#1
00000e  f880103d          STRB     r1,[r0,#0x3d]
                  |L103.18|
;;;6673     }
;;;6674   
;;;6675   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6676     htim->PeriodElapsedCallback(htim);
;;;6677   #else
;;;6678     HAL_TIM_PeriodElapsedCallback(htim);
000012  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;6679   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6680   }
000016  bd10              POP      {r4,pc}
;;;6681   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedHalfCplt PROC
;;;6686     */
;;;6687   static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6688   {
;;;6689     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;6690   
;;;6691   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6692     htim->PeriodElapsedHalfCpltCallback(htim);
;;;6693   #else
;;;6694     HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
000004  f7fffffe          BL       HAL_TIM_PeriodElapsedHalfCpltCallback
;;;6695   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6696   }
000008  bd10              POP      {r4,pc}
;;;6697   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;6702     */
;;;6703   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6704   {
;;;6705     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;6706   
;;;6707     if (htim->hdma[TIM_DMA_ID_TRIGGER]->Init.Mode == DMA_NORMAL)
000004  6b81              LDR      r1,[r0,#0x38]
000006  69c9              LDR      r1,[r1,#0x1c]
000008  2900              CMP      r1,#0
00000a  d102              BNE      |L105.18|
;;;6708     {
;;;6709       htim->State = HAL_TIM_STATE_READY;
00000c  2101              MOVS     r1,#1
00000e  f880103d          STRB     r1,[r0,#0x3d]
                  |L105.18|
;;;6710     }
;;;6711   
;;;6712   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6713     htim->TriggerCallback(htim);
;;;6714   #else
;;;6715     HAL_TIM_TriggerCallback(htim);
000012  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;6716   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6717   }
000016  bd10              POP      {r4,pc}
;;;6718   
                          ENDP


                          AREA ||i.TIM_DMATriggerHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerHalfCplt PROC
;;;6723     */
;;;6724   static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6725   {
;;;6726     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;6727   
;;;6728   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;6729     htim->TriggerHalfCpltCallback(htim);
;;;6730   #else
;;;6731     HAL_TIM_TriggerHalfCpltCallback(htim);
000004  f7fffffe          BL       HAL_TIM_TriggerHalfCpltCallback
;;;6732   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;6733   }
000008  bd10              POP      {r4,pc}
;;;6734   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;7605     */
;;;7606   void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;7607                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;7608   {
;;;7609     uint32_t tmpsmcr;
;;;7610   
;;;7611     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
;;;7612   
;;;7613     /* Reset the ETR Bits */
;;;7614     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000004  f424447f          BIC      r4,r4,#0xff00
;;;7615   
;;;7616     /* Set the Prescaler, the Filter value and the Polarity */
;;;7617     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
000008  ea422203          ORR      r2,r2,r3,LSL #8
00000c  430a              ORRS     r2,r2,r1
00000e  4322              ORRS     r2,r2,r4
;;;7618   
;;;7619     /* Write to TIMx SMCR */
;;;7620     TIMx->SMCR = tmpsmcr;
000010  6082              STR      r2,[r0,#8]
;;;7621   }
000012  bd10              POP      {r4,pc}
;;;7622   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;7575     */
;;;7576   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
000000  6882              LDR      r2,[r0,#8]
;;;7577   {
;;;7578     uint32_t tmpsmcr;
;;;7579   
;;;7580     /* Get the TIMx SMCR register value */
;;;7581     tmpsmcr = TIMx->SMCR;
;;;7582     /* Reset the TS Bits */
;;;7583     tmpsmcr &= ~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;7584     /* Set the Input Trigger source and the slave mode*/
;;;7585     tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
000006  430a              ORRS     r2,r2,r1
000008  f0420107          ORR      r1,r2,#7
;;;7586     /* Write to TIMx SMCR */
;;;7587     TIMx->SMCR = tmpsmcr;
00000c  6081              STR      r1,[r0,#8]
;;;7588   }
00000e  4770              BX       lr
;;;7589   /**
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;6788     */
;;;6789   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6790   {
;;;6791     uint32_t tmpccmrx;
;;;6792     uint32_t tmpccer;
;;;6793     uint32_t tmpcr2;
;;;6794   
;;;6795     /* Disable the Channel 1: Reset the CC1E Bit */
;;;6796     TIMx->CCER &= ~TIM_CCER_CC1E;
000004  6a02              LDR      r2,[r0,#0x20]
000006  f0220201          BIC      r2,r2,#1
00000a  6202              STR      r2,[r0,#0x20]
;;;6797   
;;;6798     /* Get the TIMx CCER register value */
;;;6799     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;6800     /* Get the TIMx CR2 register value */
;;;6801     tmpcr2 =  TIMx->CR2;
00000e  6842              LDR      r2,[r0,#4]
;;;6802   
;;;6803     /* Get the TIMx CCMR1 register value */
;;;6804     tmpccmrx = TIMx->CCMR1;
000010  6983              LDR      r3,[r0,#0x18]
;;;6805   
;;;6806     /* Reset the Output Compare Mode Bits */
;;;6807     tmpccmrx &= ~TIM_CCMR1_OC1M;
000012  4c1d              LDR      r4,|L109.136|
000014  4023              ANDS     r3,r3,r4
;;;6808     tmpccmrx &= ~TIM_CCMR1_CC1S;
000016  f0230303          BIC      r3,r3,#3
;;;6809     /* Select the Output Compare Mode */
;;;6810     tmpccmrx |= OC_Config->OCMode;
00001a  680c              LDR      r4,[r1,#0]
00001c  431c              ORRS     r4,r4,r3
;;;6811   
;;;6812     /* Reset the Output Polarity level */
;;;6813     tmpccer &= ~TIM_CCER_CC1P;
00001e  f0250502          BIC      r5,r5,#2
;;;6814     /* Set the Output Compare Polarity */
;;;6815     tmpccer |= OC_Config->OCPolarity;
000022  688b              LDR      r3,[r1,#8]
000024  432b              ORRS     r3,r3,r5
;;;6816   
;;;6817     if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
000026  4e19              LDR      r6,|L109.140|
000028  4f19              LDR      r7,|L109.144|
00002a  f8dfc068          LDR      r12,|L109.148|
00002e  f8df8068          LDR      r8,|L109.152|
000032  f8df9068          LDR      r9,|L109.156|
000036  42b0              CMP      r0,r6
000038  d007              BEQ      |L109.74|
00003a  42b8              CMP      r0,r7
00003c  d005              BEQ      |L109.74|
00003e  4560              CMP      r0,r12
000040  d003              BEQ      |L109.74|
000042  4540              CMP      r0,r8
000044  d001              BEQ      |L109.74|
000046  4548              CMP      r0,r9
000048  d105              BNE      |L109.86|
                  |L109.74|
;;;6818     {
;;;6819       /* Check parameters */
;;;6820       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;6821   
;;;6822       /* Reset the Output N Polarity level */
;;;6823       tmpccer &= ~TIM_CCER_CC1NP;
00004a  f0230308          BIC      r3,r3,#8
;;;6824       /* Set the Output N Polarity */
;;;6825       tmpccer |= OC_Config->OCNPolarity;
00004e  68cd              LDR      r5,[r1,#0xc]
000050  431d              ORRS     r5,r5,r3
;;;6826       /* Reset the Output N State */
;;;6827       tmpccer &= ~TIM_CCER_CC1NE;
000052  f0250304          BIC      r3,r5,#4
                  |L109.86|
;;;6828     }
;;;6829   
;;;6830     if (IS_TIM_BREAK_INSTANCE(TIMx))
000056  42b0              CMP      r0,r6
000058  d007              BEQ      |L109.106|
00005a  42b8              CMP      r0,r7
00005c  d005              BEQ      |L109.106|
00005e  4560              CMP      r0,r12
000060  d003              BEQ      |L109.106|
000062  4540              CMP      r0,r8
000064  d001              BEQ      |L109.106|
000066  4548              CMP      r0,r9
000068  d107              BNE      |L109.122|
                  |L109.106|
;;;6831     {
;;;6832       /* Check parameters */
;;;6833       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;6834       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;6835   
;;;6836       /* Reset the Output Compare and Output Compare N IDLE State */
;;;6837       tmpcr2 &= ~TIM_CR2_OIS1;
00006a  f4227280          BIC      r2,r2,#0x100
;;;6838       tmpcr2 &= ~TIM_CR2_OIS1N;
00006e  f4227200          BIC      r2,r2,#0x200
;;;6839       /* Set the Output Idle state */
;;;6840       tmpcr2 |= OC_Config->OCIdleState;
000072  694d              LDR      r5,[r1,#0x14]
000074  4315              ORRS     r5,r5,r2
;;;6841       /* Set the Output N Idle state */
;;;6842       tmpcr2 |= OC_Config->OCNIdleState;
000076  698a              LDR      r2,[r1,#0x18]
000078  432a              ORRS     r2,r2,r5
                  |L109.122|
;;;6843     }
;;;6844   
;;;6845     /* Write to TIMx CR2 */
;;;6846     TIMx->CR2 = tmpcr2;
00007a  6042              STR      r2,[r0,#4]
;;;6847   
;;;6848     /* Write to TIMx CCMR1 */
;;;6849     TIMx->CCMR1 = tmpccmrx;
00007c  6184              STR      r4,[r0,#0x18]
;;;6850   
;;;6851     /* Set the Capture Compare Register value */
;;;6852     TIMx->CCR1 = OC_Config->Pulse;
00007e  6849              LDR      r1,[r1,#4]
000080  6341              STR      r1,[r0,#0x34]
;;;6853   
;;;6854     /* Write to TIMx CCER */
;;;6855     TIMx->CCER = tmpccer;
000082  6203              STR      r3,[r0,#0x20]
;;;6856   }
000084  e8bd83f0          POP      {r4-r9,pc}
;;;6857   
                          ENDP

                  |L109.136|
                          DCD      0xfffeff8f
                  |L109.140|
                          DCD      0x40012c00
                  |L109.144|
                          DCD      0x40013400
                  |L109.148|
                          DCD      0x40014000
                  |L109.152|
                          DCD      0x40014400
                  |L109.156|
                          DCD      0x40014800

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;6863     */
;;;6864   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;6865   {
;;;6866     uint32_t tmpccmrx;
;;;6867     uint32_t tmpccer;
;;;6868     uint32_t tmpcr2;
;;;6869   
;;;6870     /* Disable the Channel 2: Reset the CC2E Bit */
;;;6871     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;6872   
;;;6873     /* Get the TIMx CCER register value */
;;;6874     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;6875     /* Get the TIMx CR2 register value */
;;;6876     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;6877   
;;;6878     /* Get the TIMx CCMR1 register value */
;;;6879     tmpccmrx = TIMx->CCMR1;
00000e  6983              LDR      r3,[r0,#0x18]
;;;6880   
;;;6881     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;6882     tmpccmrx &= ~TIM_CCMR1_OC2M;
000010  4d1a              LDR      r5,|L110.124|
000012  402b              ANDS     r3,r3,r5
;;;6883     tmpccmrx &= ~TIM_CCMR1_CC2S;
000014  f4237340          BIC      r3,r3,#0x300
;;;6884   
;;;6885     /* Select the Output Compare Mode */
;;;6886     tmpccmrx |= (OC_Config->OCMode << 8U);
000018  680d              LDR      r5,[r1,#0]
00001a  ea432505          ORR      r5,r3,r5,LSL #8
;;;6887   
;;;6888     /* Reset the Output Polarity level */
;;;6889     tmpccer &= ~TIM_CCER_CC2P;
00001e  f0240320          BIC      r3,r4,#0x20
;;;6890     /* Set the Output Compare Polarity */
;;;6891     tmpccer |= (OC_Config->OCPolarity << 4U);
000022  688c              LDR      r4,[r1,#8]
000024  ea431304          ORR      r3,r3,r4,LSL #4
;;;6892   
;;;6893     if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
000028  4c15              LDR      r4,|L110.128|
00002a  4e16              LDR      r6,|L110.132|
00002c  42a0              CMP      r0,r4
00002e  d001              BEQ      |L110.52|
000030  42b0              CMP      r0,r6
000032  d106              BNE      |L110.66|
                  |L110.52|
;;;6894     {
;;;6895       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;6896   
;;;6897       /* Reset the Output N Polarity level */
;;;6898       tmpccer &= ~TIM_CCER_CC2NP;
000034  f0230380          BIC      r3,r3,#0x80
;;;6899       /* Set the Output N Polarity */
;;;6900       tmpccer |= (OC_Config->OCNPolarity << 4U);
000038  68cf              LDR      r7,[r1,#0xc]
00003a  ea431307          ORR      r3,r3,r7,LSL #4
;;;6901       /* Reset the Output N State */
;;;6902       tmpccer &= ~TIM_CCER_CC2NE;
00003e  f0230340          BIC      r3,r3,#0x40
                  |L110.66|
;;;6903   
;;;6904     }
;;;6905   
;;;6906     if (IS_TIM_BREAK_INSTANCE(TIMx))
000042  42a0              CMP      r0,r4
000044  d00a              BEQ      |L110.92|
000046  42b0              CMP      r0,r6
000048  d008              BEQ      |L110.92|
00004a  4c0f              LDR      r4,|L110.136|
00004c  42a0              CMP      r0,r4
00004e  d005              BEQ      |L110.92|
000050  4c0e              LDR      r4,|L110.140|
000052  42a0              CMP      r0,r4
000054  d002              BEQ      |L110.92|
000056  4c0e              LDR      r4,|L110.144|
000058  42a0              CMP      r0,r4
00005a  d109              BNE      |L110.112|
                  |L110.92|
;;;6907     {
;;;6908       /* Check parameters */
;;;6909       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;6910       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;6911   
;;;6912       /* Reset the Output Compare and Output Compare N IDLE State */
;;;6913       tmpcr2 &= ~TIM_CR2_OIS2;
00005c  f4226280          BIC      r2,r2,#0x400
;;;6914       tmpcr2 &= ~TIM_CR2_OIS2N;
000060  f4226200          BIC      r2,r2,#0x800
;;;6915       /* Set the Output Idle state */
;;;6916       tmpcr2 |= (OC_Config->OCIdleState << 2U);
000064  694c              LDR      r4,[r1,#0x14]
000066  ea420284          ORR      r2,r2,r4,LSL #2
;;;6917       /* Set the Output N Idle state */
;;;6918       tmpcr2 |= (OC_Config->OCNIdleState << 2U);
00006a  698c              LDR      r4,[r1,#0x18]
00006c  ea420284          ORR      r2,r2,r4,LSL #2
                  |L110.112|
;;;6919     }
;;;6920   
;;;6921     /* Write to TIMx CR2 */
;;;6922     TIMx->CR2 = tmpcr2;
000070  6042              STR      r2,[r0,#4]
;;;6923   
;;;6924     /* Write to TIMx CCMR1 */
;;;6925     TIMx->CCMR1 = tmpccmrx;
000072  6185              STR      r5,[r0,#0x18]
;;;6926   
;;;6927     /* Set the Capture Compare Register value */
;;;6928     TIMx->CCR2 = OC_Config->Pulse;
000074  6849              LDR      r1,[r1,#4]
000076  6381              STR      r1,[r0,#0x38]
;;;6929   
;;;6930     /* Write to TIMx CCER */
;;;6931     TIMx->CCER = tmpccer;
000078  6203              STR      r3,[r0,#0x20]
;;;6932   }
00007a  bdf0              POP      {r4-r7,pc}
;;;6933   
                          ENDP

                  |L110.124|
                          DCD      0xfeff8fff
                  |L110.128|
                          DCD      0x40012c00
                  |L110.132|
                          DCD      0x40013400
                  |L110.136|
                          DCD      0x40014000
                  |L110.140|
                          DCD      0x40014400
                  |L110.144|
                          DCD      0x40014800

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;6939     */
;;;6940   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;6941   {
;;;6942     uint32_t tmpccmrx;
;;;6943     uint32_t tmpccer;
;;;6944     uint32_t tmpcr2;
;;;6945   
;;;6946     /* Disable the Channel 3: Reset the CC2E Bit */
;;;6947     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  6202              STR      r2,[r0,#0x20]
;;;6948   
;;;6949     /* Get the TIMx CCER register value */
;;;6950     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;6951     /* Get the TIMx CR2 register value */
;;;6952     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;6953   
;;;6954     /* Get the TIMx CCMR2 register value */
;;;6955     tmpccmrx = TIMx->CCMR2;
00000e  69c3              LDR      r3,[r0,#0x1c]
;;;6956   
;;;6957     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;6958     tmpccmrx &= ~TIM_CCMR2_OC3M;
000010  4d1a              LDR      r5,|L111.124|
000012  402b              ANDS     r3,r3,r5
;;;6959     tmpccmrx &= ~TIM_CCMR2_CC3S;
000014  f0230303          BIC      r3,r3,#3
;;;6960     /* Select the Output Compare Mode */
;;;6961     tmpccmrx |= OC_Config->OCMode;
000018  680d              LDR      r5,[r1,#0]
00001a  431d              ORRS     r5,r5,r3
;;;6962   
;;;6963     /* Reset the Output Polarity level */
;;;6964     tmpccer &= ~TIM_CCER_CC3P;
00001c  f4247300          BIC      r3,r4,#0x200
;;;6965     /* Set the Output Compare Polarity */
;;;6966     tmpccer |= (OC_Config->OCPolarity << 8U);
000020  688c              LDR      r4,[r1,#8]
000022  ea432304          ORR      r3,r3,r4,LSL #8
;;;6967   
;;;6968     if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
000026  4c16              LDR      r4,|L111.128|
000028  4e16              LDR      r6,|L111.132|
00002a  42a0              CMP      r0,r4
00002c  d001              BEQ      |L111.50|
00002e  42b0              CMP      r0,r6
000030  d106              BNE      |L111.64|
                  |L111.50|
;;;6969     {
;;;6970       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;6971   
;;;6972       /* Reset the Output N Polarity level */
;;;6973       tmpccer &= ~TIM_CCER_CC3NP;
000032  f4236300          BIC      r3,r3,#0x800
;;;6974       /* Set the Output N Polarity */
;;;6975       tmpccer |= (OC_Config->OCNPolarity << 8U);
000036  68cf              LDR      r7,[r1,#0xc]
000038  ea432307          ORR      r3,r3,r7,LSL #8
;;;6976       /* Reset the Output N State */
;;;6977       tmpccer &= ~TIM_CCER_CC3NE;
00003c  f4236380          BIC      r3,r3,#0x400
                  |L111.64|
;;;6978     }
;;;6979   
;;;6980     if (IS_TIM_BREAK_INSTANCE(TIMx))
000040  42a0              CMP      r0,r4
000042  d00a              BEQ      |L111.90|
000044  42b0              CMP      r0,r6
000046  d008              BEQ      |L111.90|
000048  4c0f              LDR      r4,|L111.136|
00004a  42a0              CMP      r0,r4
00004c  d005              BEQ      |L111.90|
00004e  4c0f              LDR      r4,|L111.140|
000050  42a0              CMP      r0,r4
000052  d002              BEQ      |L111.90|
000054  4c0e              LDR      r4,|L111.144|
000056  42a0              CMP      r0,r4
000058  d109              BNE      |L111.110|
                  |L111.90|
;;;6981     {
;;;6982       /* Check parameters */
;;;6983       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;6984       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;6985   
;;;6986       /* Reset the Output Compare and Output Compare N IDLE State */
;;;6987       tmpcr2 &= ~TIM_CR2_OIS3;
00005a  f4225280          BIC      r2,r2,#0x1000
;;;6988       tmpcr2 &= ~TIM_CR2_OIS3N;
00005e  f4225200          BIC      r2,r2,#0x2000
;;;6989       /* Set the Output Idle state */
;;;6990       tmpcr2 |= (OC_Config->OCIdleState << 4U);
000062  694c              LDR      r4,[r1,#0x14]
000064  ea421204          ORR      r2,r2,r4,LSL #4
;;;6991       /* Set the Output N Idle state */
;;;6992       tmpcr2 |= (OC_Config->OCNIdleState << 4U);
000068  698c              LDR      r4,[r1,#0x18]
00006a  ea421204          ORR      r2,r2,r4,LSL #4
                  |L111.110|
;;;6993     }
;;;6994   
;;;6995     /* Write to TIMx CR2 */
;;;6996     TIMx->CR2 = tmpcr2;
00006e  6042              STR      r2,[r0,#4]
;;;6997   
;;;6998     /* Write to TIMx CCMR2 */
;;;6999     TIMx->CCMR2 = tmpccmrx;
000070  61c5              STR      r5,[r0,#0x1c]
;;;7000   
;;;7001     /* Set the Capture Compare Register value */
;;;7002     TIMx->CCR3 = OC_Config->Pulse;
000072  6849              LDR      r1,[r1,#4]
000074  63c1              STR      r1,[r0,#0x3c]
;;;7003   
;;;7004     /* Write to TIMx CCER */
;;;7005     TIMx->CCER = tmpccer;
000076  6203              STR      r3,[r0,#0x20]
;;;7006   }
000078  bdf0              POP      {r4-r7,pc}
;;;7007   
                          ENDP

00007a  0000              DCW      0x0000
                  |L111.124|
                          DCD      0xfffeff8f
                  |L111.128|
                          DCD      0x40012c00
                  |L111.132|
                          DCD      0x40013400
                  |L111.136|
                          DCD      0x40014000
                  |L111.140|
                          DCD      0x40014400
                  |L111.144|
                          DCD      0x40014800

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;7013     */
;;;7014   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;7015   {
;;;7016     uint32_t tmpccmrx;
;;;7017     uint32_t tmpccer;
;;;7018     uint32_t tmpcr2;
;;;7019   
;;;7020     /* Disable the Channel 4: Reset the CC4E Bit */
;;;7021     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  6202              STR      r2,[r0,#0x20]
;;;7022   
;;;7023     /* Get the TIMx CCER register value */
;;;7024     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;7025     /* Get the TIMx CR2 register value */
;;;7026     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;7027   
;;;7028     /* Get the TIMx CCMR2 register value */
;;;7029     tmpccmrx = TIMx->CCMR2;
00000e  69c3              LDR      r3,[r0,#0x1c]
;;;7030   
;;;7031     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;7032     tmpccmrx &= ~TIM_CCMR2_OC4M;
000010  4d12              LDR      r5,|L112.92|
000012  402b              ANDS     r3,r3,r5
;;;7033     tmpccmrx &= ~TIM_CCMR2_CC4S;
000014  f4237340          BIC      r3,r3,#0x300
;;;7034   
;;;7035     /* Select the Output Compare Mode */
;;;7036     tmpccmrx |= (OC_Config->OCMode << 8U);
000018  680d              LDR      r5,[r1,#0]
00001a  ea432305          ORR      r3,r3,r5,LSL #8
;;;7037   
;;;7038     /* Reset the Output Polarity level */
;;;7039     tmpccer &= ~TIM_CCER_CC4P;
00001e  f4245400          BIC      r4,r4,#0x2000
;;;7040     /* Set the Output Compare Polarity */
;;;7041     tmpccer |= (OC_Config->OCPolarity << 12U);
000022  688d              LDR      r5,[r1,#8]
000024  ea443405          ORR      r4,r4,r5,LSL #12
;;;7042   
;;;7043     if (IS_TIM_BREAK_INSTANCE(TIMx))
000028  4d0d              LDR      r5,|L112.96|
00002a  42a8              CMP      r0,r5
00002c  d00b              BEQ      |L112.70|
00002e  4d0d              LDR      r5,|L112.100|
000030  42a8              CMP      r0,r5
000032  d008              BEQ      |L112.70|
000034  4d0c              LDR      r5,|L112.104|
000036  42a8              CMP      r0,r5
000038  d005              BEQ      |L112.70|
00003a  4d0c              LDR      r5,|L112.108|
00003c  42a8              CMP      r0,r5
00003e  d002              BEQ      |L112.70|
000040  4d0b              LDR      r5,|L112.112|
000042  42a8              CMP      r0,r5
000044  d104              BNE      |L112.80|
                  |L112.70|
;;;7044     {
;;;7045       /* Check parameters */
;;;7046       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;7047   
;;;7048       /* Reset the Output Compare IDLE State */
;;;7049       tmpcr2 &= ~TIM_CR2_OIS4;
000046  f4224280          BIC      r2,r2,#0x4000
;;;7050   
;;;7051       /* Set the Output Idle state */
;;;7052       tmpcr2 |= (OC_Config->OCIdleState << 6U);
00004a  694d              LDR      r5,[r1,#0x14]
00004c  ea421285          ORR      r2,r2,r5,LSL #6
                  |L112.80|
;;;7053     }
;;;7054   
;;;7055     /* Write to TIMx CR2 */
;;;7056     TIMx->CR2 = tmpcr2;
000050  6042              STR      r2,[r0,#4]
;;;7057   
;;;7058     /* Write to TIMx CCMR2 */
;;;7059     TIMx->CCMR2 = tmpccmrx;
000052  61c3              STR      r3,[r0,#0x1c]
;;;7060   
;;;7061     /* Set the Capture Compare Register value */
;;;7062     TIMx->CCR4 = OC_Config->Pulse;
000054  6849              LDR      r1,[r1,#4]
000056  6401              STR      r1,[r0,#0x40]
;;;7063   
;;;7064     /* Write to TIMx CCER */
;;;7065     TIMx->CCER = tmpccer;
000058  6204              STR      r4,[r0,#0x20]
;;;7066   }
00005a  bd30              POP      {r4,r5,pc}
;;;7067   
                          ENDP

                  |L112.92|
                          DCD      0xfeff8fff
                  |L112.96|
                          DCD      0x40012c00
                  |L112.100|
                          DCD      0x40013400
                  |L112.104|
                          DCD      0x40014000
                  |L112.108|
                          DCD      0x40014400
                  |L112.112|
                          DCD      0x40014800

                          AREA ||i.TIM_OC5_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC5_SetConfig PROC
;;;7073     */
;;;7074   static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
000000  b530              PUSH     {r4,r5,lr}
;;;7075                                 TIM_OC_InitTypeDef *OC_Config)
;;;7076   {
;;;7077     uint32_t tmpccmrx;
;;;7078     uint32_t tmpccer;
;;;7079     uint32_t tmpcr2;
;;;7080   
;;;7081     /* Disable the output: Reset the CCxE Bit */
;;;7082     TIMx->CCER &= ~TIM_CCER_CC5E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4223280          BIC      r2,r2,#0x10000
000008  6202              STR      r2,[r0,#0x20]
;;;7083   
;;;7084     /* Get the TIMx CCER register value */
;;;7085     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;7086     /* Get the TIMx CR2 register value */
;;;7087     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;7088     /* Get the TIMx CCMR1 register value */
;;;7089     tmpccmrx = TIMx->CCMR3;
00000e  6d43              LDR      r3,[r0,#0x54]
;;;7090   
;;;7091     /* Reset the Output Compare Mode Bits */
;;;7092     tmpccmrx &= ~(TIM_CCMR3_OC5M);
000010  4d11              LDR      r5,|L113.88|
000012  402b              ANDS     r3,r3,r5
;;;7093     /* Select the Output Compare Mode */
;;;7094     tmpccmrx |= OC_Config->OCMode;
000014  680d              LDR      r5,[r1,#0]
000016  431d              ORRS     r5,r5,r3
;;;7095   
;;;7096     /* Reset the Output Polarity level */
;;;7097     tmpccer &= ~TIM_CCER_CC5P;
000018  f4243300          BIC      r3,r4,#0x20000
;;;7098     /* Set the Output Compare Polarity */
;;;7099     tmpccer |= (OC_Config->OCPolarity << 16U);
00001c  890c              LDRH     r4,[r1,#8]
00001e  ea434304          ORR      r3,r3,r4,LSL #16
;;;7100   
;;;7101     if (IS_TIM_BREAK_INSTANCE(TIMx))
000022  4c0e              LDR      r4,|L113.92|
000024  42a0              CMP      r0,r4
000026  d00b              BEQ      |L113.64|
000028  4c0d              LDR      r4,|L113.96|
00002a  42a0              CMP      r0,r4
00002c  d008              BEQ      |L113.64|
00002e  4c0d              LDR      r4,|L113.100|
000030  42a0              CMP      r0,r4
000032  d005              BEQ      |L113.64|
000034  4c0c              LDR      r4,|L113.104|
000036  42a0              CMP      r0,r4
000038  d002              BEQ      |L113.64|
00003a  4c0c              LDR      r4,|L113.108|
00003c  42a0              CMP      r0,r4
00003e  d104              BNE      |L113.74|
                  |L113.64|
;;;7102     {
;;;7103       /* Reset the Output Compare IDLE State */
;;;7104       tmpcr2 &= ~TIM_CR2_OIS5;
000040  f4223280          BIC      r2,r2,#0x10000
;;;7105       /* Set the Output Idle state */
;;;7106       tmpcr2 |= (OC_Config->OCIdleState << 8U);
000044  694c              LDR      r4,[r1,#0x14]
000046  ea422204          ORR      r2,r2,r4,LSL #8
                  |L113.74|
;;;7107     }
;;;7108     /* Write to TIMx CR2 */
;;;7109     TIMx->CR2 = tmpcr2;
00004a  6042              STR      r2,[r0,#4]
;;;7110   
;;;7111     /* Write to TIMx CCMR3 */
;;;7112     TIMx->CCMR3 = tmpccmrx;
00004c  6545              STR      r5,[r0,#0x54]
;;;7113   
;;;7114     /* Set the Capture Compare Register value */
;;;7115     TIMx->CCR5 = OC_Config->Pulse;
00004e  6849              LDR      r1,[r1,#4]
000050  6581              STR      r1,[r0,#0x58]
;;;7116   
;;;7117     /* Write to TIMx CCER */
;;;7118     TIMx->CCER = tmpccer;
000052  6203              STR      r3,[r0,#0x20]
;;;7119   }
000054  bd30              POP      {r4,r5,pc}
;;;7120   
                          ENDP

000056  0000              DCW      0x0000
                  |L113.88|
                          DCD      0xfffeff8f
                  |L113.92|
                          DCD      0x40012c00
                  |L113.96|
                          DCD      0x40013400
                  |L113.100|
                          DCD      0x40014000
                  |L113.104|
                          DCD      0x40014400
                  |L113.108|
                          DCD      0x40014800

                          AREA ||i.TIM_OC6_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC6_SetConfig PROC
;;;7126     */
;;;7127   static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
000000  b530              PUSH     {r4,r5,lr}
;;;7128                                 TIM_OC_InitTypeDef *OC_Config)
;;;7129   {
;;;7130     uint32_t tmpccmrx;
;;;7131     uint32_t tmpccer;
;;;7132     uint32_t tmpcr2;
;;;7133   
;;;7134     /* Disable the output: Reset the CCxE Bit */
;;;7135     TIMx->CCER &= ~TIM_CCER_CC6E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4221280          BIC      r2,r2,#0x100000
000008  6202              STR      r2,[r0,#0x20]
;;;7136   
;;;7137     /* Get the TIMx CCER register value */
;;;7138     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;7139     /* Get the TIMx CR2 register value */
;;;7140     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;7141     /* Get the TIMx CCMR1 register value */
;;;7142     tmpccmrx = TIMx->CCMR3;
00000e  6d43              LDR      r3,[r0,#0x54]
;;;7143   
;;;7144     /* Reset the Output Compare Mode Bits */
;;;7145     tmpccmrx &= ~(TIM_CCMR3_OC6M);
000010  4d11              LDR      r5,|L114.88|
000012  402b              ANDS     r3,r3,r5
;;;7146     /* Select the Output Compare Mode */
;;;7147     tmpccmrx |= (OC_Config->OCMode << 8U);
000014  680d              LDR      r5,[r1,#0]
000016  ea432305          ORR      r3,r3,r5,LSL #8
;;;7148   
;;;7149     /* Reset the Output Polarity level */
;;;7150     tmpccer &= (uint32_t)~TIM_CCER_CC6P;
00001a  f4241400          BIC      r4,r4,#0x200000
;;;7151     /* Set the Output Compare Polarity */
;;;7152     tmpccer |= (OC_Config->OCPolarity << 20U);
00001e  890d              LDRH     r5,[r1,#8]
000020  ea445405          ORR      r4,r4,r5,LSL #20
;;;7153   
;;;7154     if (IS_TIM_BREAK_INSTANCE(TIMx))
000024  4d0d              LDR      r5,|L114.92|
000026  42a8              CMP      r0,r5
000028  d00b              BEQ      |L114.66|
00002a  4d0d              LDR      r5,|L114.96|
00002c  42a8              CMP      r0,r5
00002e  d008              BEQ      |L114.66|
000030  4d0c              LDR      r5,|L114.100|
000032  42a8              CMP      r0,r5
000034  d005              BEQ      |L114.66|
000036  4d0c              LDR      r5,|L114.104|
000038  42a8              CMP      r0,r5
00003a  d002              BEQ      |L114.66|
00003c  4d0b              LDR      r5,|L114.108|
00003e  42a8              CMP      r0,r5
000040  d104              BNE      |L114.76|
                  |L114.66|
;;;7155     {
;;;7156       /* Reset the Output Compare IDLE State */
;;;7157       tmpcr2 &= ~TIM_CR2_OIS6;
000042  f4222280          BIC      r2,r2,#0x40000
;;;7158       /* Set the Output Idle state */
;;;7159       tmpcr2 |= (OC_Config->OCIdleState << 10U);
000046  694d              LDR      r5,[r1,#0x14]
000048  ea422285          ORR      r2,r2,r5,LSL #10
                  |L114.76|
;;;7160     }
;;;7161   
;;;7162     /* Write to TIMx CR2 */
;;;7163     TIMx->CR2 = tmpcr2;
00004c  6042              STR      r2,[r0,#4]
;;;7164   
;;;7165     /* Write to TIMx CCMR3 */
;;;7166     TIMx->CCMR3 = tmpccmrx;
00004e  6543              STR      r3,[r0,#0x54]
;;;7167   
;;;7168     /* Set the Capture Compare Register value */
;;;7169     TIMx->CCR6 = OC_Config->Pulse;
000050  6849              LDR      r1,[r1,#4]
000052  65c1              STR      r1,[r0,#0x5c]
;;;7170   
;;;7171     /* Write to TIMx CCER */
;;;7172     TIMx->CCER = tmpccer;
000054  6204              STR      r4,[r0,#0x20]
;;;7173   }
000056  bd30              POP      {r4,r5,pc}
;;;7174   
                          ENDP

                  |L114.88|
                          DCD      0xfeff8fff
                  |L114.92|
                          DCD      0x40012c00
                  |L114.96|
                          DCD      0x40013400
                  |L114.100|
                          DCD      0x40014000
                  |L114.104|
                          DCD      0x40014400
                  |L114.108|
                          DCD      0x40014800

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_SlaveTimer_SetConfig PROC
;;;7180     */
;;;7181   static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  b510              PUSH     {r4,lr}
;;;7182                                                     TIM_SlaveConfigTypeDef *sSlaveConfig)
;;;7183   {
;;;7184     uint32_t tmpsmcr;
;;;7185     uint32_t tmpccmr1;
;;;7186     uint32_t tmpccer;
;;;7187   
;;;7188     /* Get the TIMx SMCR register value */
;;;7189     tmpsmcr = htim->Instance->SMCR;
000002  6802              LDR      r2,[r0,#0]
000004  6893              LDR      r3,[r2,#8]
;;;7190   
;;;7191     /* Reset the Trigger Selection Bits */
;;;7192     tmpsmcr &= ~TIM_SMCR_TS;
000006  f0230470          BIC      r4,r3,#0x70
;;;7193     /* Set the Input Trigger source */
;;;7194     tmpsmcr |= sSlaveConfig->InputTrigger;
00000a  684b              LDR      r3,[r1,#4]
00000c  4323              ORRS     r3,r3,r4
;;;7195   
;;;7196     /* Reset the slave mode Bits */
;;;7197     tmpsmcr &= ~TIM_SMCR_SMS;
00000e  4c1e              LDR      r4,|L115.136|
000010  4023              ANDS     r3,r3,r4
;;;7198     /* Set the slave mode */
;;;7199     tmpsmcr |= sSlaveConfig->SlaveMode;
000012  680c              LDR      r4,[r1,#0]
000014  431c              ORRS     r4,r4,r3
;;;7200   
;;;7201     /* Write to TIMx SMCR */
;;;7202     htim->Instance->SMCR = tmpsmcr;
000016  6094              STR      r4,[r2,#8]
;;;7203   
;;;7204     /* Configure the trigger prescaler, filter, and polarity */
;;;7205     switch (sSlaveConfig->InputTrigger)
000018  684a              LDR      r2,[r1,#4]
00001a  f0120f0f          TST      r2,#0xf
00001e  d130              BNE      |L115.130|
000020  1112              ASRS     r2,r2,#4
000022  2a08              CMP      r2,#8
000024  d22d              BCS      |L115.130|
000026  e8dff002          TBB      [pc,r2]
00002a  2c2c              DCB      0x2c,0x2c
00002c  2c2c0b21          DCB      0x2c,0x2c,0x0b,0x21
000030  2704              DCB      0x27,0x04
;;;7206     {
;;;7207       case TIM_TS_ETRF:
;;;7208       {
;;;7209         /* Check the parameters */
;;;7210         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;7211         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;7212         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;7213         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;7214         /* Configure the ETR Trigger source */
;;;7215         TIM_ETR_SetConfig(htim->Instance,
000032  690b              LDR      r3,[r1,#0x10]
000034  e9d12102          LDRD     r2,r1,[r1,#8]
000038  6800              LDR      r0,[r0,#0]
00003a  f7fffffe          BL       TIM_ETR_SetConfig
;;;7216                           sSlaveConfig->TriggerPrescaler,
;;;7217                           sSlaveConfig->TriggerPolarity,
;;;7218                           sSlaveConfig->TriggerFilter);
;;;7219         break;
00003e  e020              B        |L115.130|
;;;7220       }
;;;7221   
;;;7222       case TIM_TS_TI1F_ED:
;;;7223       {
;;;7224         /* Check the parameters */
;;;7225         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;7226         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;7227   
;;;7228         if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
000040  680a              LDR      r2,[r1,#0]
000042  2a05              CMP      r2,#5
000044  d010              BEQ      |L115.104|
;;;7229         {
;;;7230           return HAL_ERROR;
;;;7231         }
;;;7232   
;;;7233         /* Disable the Channel 1: Reset the CC1E Bit */
;;;7234         tmpccer = htim->Instance->CCER;
000046  6802              LDR      r2,[r0,#0]
000048  6a13              LDR      r3,[r2,#0x20]
;;;7235         htim->Instance->CCER &= ~TIM_CCER_CC1E;
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  f0240401          BIC      r4,r4,#1
000050  6214              STR      r4,[r2,#0x20]
;;;7236         tmpccmr1 = htim->Instance->CCMR1;
000052  6802              LDR      r2,[r0,#0]
000054  6994              LDR      r4,[r2,#0x18]
;;;7237   
;;;7238         /* Set the filter */
;;;7239         tmpccmr1 &= ~TIM_CCMR1_IC1F;
000056  f02404f0          BIC      r4,r4,#0xf0
;;;7240         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
00005a  6909              LDR      r1,[r1,#0x10]
00005c  ea441101          ORR      r1,r4,r1,LSL #4
;;;7241   
;;;7242         /* Write to TIMx CCMR1 and CCER registers */
;;;7243         htim->Instance->CCMR1 = tmpccmr1;
000060  6191              STR      r1,[r2,#0x18]
;;;7244         htim->Instance->CCER = tmpccer;
000062  6800              LDR      r0,[r0,#0]
000064  6203              STR      r3,[r0,#0x20]
;;;7245         break;
000066  e00c              B        |L115.130|
                  |L115.104|
000068  2001              MOVS     r0,#1                 ;7230
;;;7246       }
;;;7247   
;;;7248       case TIM_TS_TI1FP1:
;;;7249       {
;;;7250         /* Check the parameters */
;;;7251         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;7252         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;7253         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;7254   
;;;7255         /* Configure TI1 Filter and Polarity */
;;;7256         TIM_TI1_ConfigInputStage(htim->Instance,
;;;7257                                  sSlaveConfig->TriggerPolarity,
;;;7258                                  sSlaveConfig->TriggerFilter);
;;;7259         break;
;;;7260       }
;;;7261   
;;;7262       case TIM_TS_TI2FP2:
;;;7263       {
;;;7264         /* Check the parameters */
;;;7265         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;7266         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;7267         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;7268   
;;;7269         /* Configure TI2 Filter and Polarity */
;;;7270         TIM_TI2_ConfigInputStage(htim->Instance,
;;;7271                                  sSlaveConfig->TriggerPolarity,
;;;7272                                  sSlaveConfig->TriggerFilter);
;;;7273         break;
;;;7274       }
;;;7275   
;;;7276       case TIM_TS_ITR0:
;;;7277       case TIM_TS_ITR1:
;;;7278       case TIM_TS_ITR2:
;;;7279       case TIM_TS_ITR3:
;;;7280         {
;;;7281           /* Check the parameter */
;;;7282           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;7283           break;
;;;7284         }
;;;7285   
;;;7286       default:
;;;7287         break;
;;;7288     }
;;;7289     return HAL_OK;
;;;7290   }
00006a  bd10              POP      {r4,pc}
00006c  690a              LDR      r2,[r1,#0x10]         ;7256
00006e  6889              LDR      r1,[r1,#8]            ;7256
000070  6800              LDR      r0,[r0,#0]            ;7256
000072  f7fffffe          BL       TIM_TI1_ConfigInputStage
000076  e004              B        |L115.130|
000078  690a              LDR      r2,[r1,#0x10]         ;7270
00007a  6889              LDR      r1,[r1,#8]            ;7270
00007c  6800              LDR      r0,[r0,#0]            ;7270
00007e  f7fffffe          BL       TIM_TI2_ConfigInputStage
                  |L115.130|
000082  2000              MOVS     r0,#0                 ;7289
000084  bd10              POP      {r4,pc}
;;;7291   
                          ENDP

000086  0000              DCW      0x0000
                  |L115.136|
                          DCD      0xfffefff8

                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;7358     */
;;;7359   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;7360   {
;;;7361     uint32_t tmpccmr1;
;;;7362     uint32_t tmpccer;
;;;7363   
;;;7364     /* Disable the Channel 1: Reset the CC1E Bit */
;;;7365     tmpccer = TIMx->CCER;
000002  6a03              LDR      r3,[r0,#0x20]
;;;7366     TIMx->CCER &= ~TIM_CCER_CC1E;
000004  6a04              LDR      r4,[r0,#0x20]
000006  f0240401          BIC      r4,r4,#1
00000a  6204              STR      r4,[r0,#0x20]
;;;7367     tmpccmr1 = TIMx->CCMR1;
00000c  6984              LDR      r4,[r0,#0x18]
;;;7368   
;;;7369     /* Set the filter */
;;;7370     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00000e  f02404f0          BIC      r4,r4,#0xf0
;;;7371     tmpccmr1 |= (TIM_ICFilter << 4U);
000012  ea441402          ORR      r4,r4,r2,LSL #4
;;;7372   
;;;7373     /* Select the Polarity and set the CC1E Bit */
;;;7374     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000016  f023020a          BIC      r2,r3,#0xa
;;;7375     tmpccer |= TIM_ICPolarity;
00001a  430a              ORRS     r2,r2,r1
;;;7376   
;;;7377     /* Write to TIMx CCMR1 and CCER registers */
;;;7378     TIMx->CCMR1 = tmpccmr1;
00001c  6184              STR      r4,[r0,#0x18]
;;;7379     TIMx->CCER = tmpccer;
00001e  6202              STR      r2,[r0,#0x20]
;;;7380   }
000020  bd10              POP      {r4,pc}
;;;7381   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;7311     */
;;;7312   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;7313                          uint32_t TIM_ICFilter)
;;;7314   {
;;;7315     uint32_t tmpccmr1;
;;;7316     uint32_t tmpccer;
;;;7317   
;;;7318     /* Disable the Channel 1: Reset the CC1E Bit */
;;;7319     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  6204              STR      r4,[r0,#0x20]
;;;7320     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;7321     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;7322   
;;;7323     /* Select the Input */
;;;7324     if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
00000e  4e14              LDR      r6,|L117.96|
000010  42b0              CMP      r0,r6
000012  d011              BEQ      |L117.56|
000014  f1b04f80          CMP      r0,#0x40000000
000018  d00e              BEQ      |L117.56|
00001a  4e12              LDR      r6,|L117.100|
00001c  42b0              CMP      r0,r6
00001e  d00b              BEQ      |L117.56|
000020  4e11              LDR      r6,|L117.104|
000022  42b0              CMP      r0,r6
000024  d008              BEQ      |L117.56|
000026  4e11              LDR      r6,|L117.108|
000028  42b0              CMP      r0,r6
00002a  d005              BEQ      |L117.56|
00002c  4e10              LDR      r6,|L117.112|
00002e  42b0              CMP      r0,r6
000030  d002              BEQ      |L117.56|
000032  4e10              LDR      r6,|L117.116|
000034  42b0              CMP      r0,r6
000036  d103              BNE      |L117.64|
                  |L117.56|
;;;7325     {
;;;7326       tmpccmr1 &= ~TIM_CCMR1_CC1S;
000038  f0240403          BIC      r4,r4,#3
;;;7327       tmpccmr1 |= TIM_ICSelection;
00003c  4314              ORRS     r4,r4,r2
00003e  e001              B        |L117.68|
                  |L117.64|
;;;7328     }
;;;7329     else
;;;7330     {
;;;7331       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000040  f0440401          ORR      r4,r4,#1
                  |L117.68|
;;;7332     }
;;;7333   
;;;7334     /* Set the filter */
;;;7335     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000044  f02404f0          BIC      r4,r4,#0xf0
;;;7336     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
000048  071a              LSLS     r2,r3,#28
00004a  ea446212          ORR      r2,r4,r2,LSR #24
;;;7337   
;;;7338     /* Select the Polarity and set the CC1E Bit */
;;;7339     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00004e  f025030a          BIC      r3,r5,#0xa
;;;7340     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
000052  f001010a          AND      r1,r1,#0xa
000056  4319              ORRS     r1,r1,r3
;;;7341   
;;;7342     /* Write to TIMx CCMR1 and CCER registers */
;;;7343     TIMx->CCMR1 = tmpccmr1;
000058  6182              STR      r2,[r0,#0x18]
;;;7344     TIMx->CCER = tmpccer;
00005a  6201              STR      r1,[r0,#0x20]
;;;7345   }
00005c  bd70              POP      {r4-r6,pc}
;;;7346   
                          ENDP

00005e  0000              DCW      0x0000
                  |L117.96|
                          DCD      0x40012c00
                  |L117.100|
                          DCD      0x40000400
                  |L117.104|
                          DCD      0x40000800
                  |L117.108|
                          DCD      0x40000c00
                  |L117.112|
                          DCD      0x40013400
                  |L117.116|
                          DCD      0x40014000

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;7441     */
;;;7442   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;7443   {
;;;7444     uint32_t tmpccmr1;
;;;7445     uint32_t tmpccer;
;;;7446   
;;;7447     /* Disable the Channel 2: Reset the CC2E Bit */
;;;7448     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a03              LDR      r3,[r0,#0x20]
000004  f0230310          BIC      r3,r3,#0x10
000008  6203              STR      r3,[r0,#0x20]
;;;7449     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;7450     tmpccer = TIMx->CCER;
00000c  6a03              LDR      r3,[r0,#0x20]
;;;7451   
;;;7452     /* Set the filter */
;;;7453     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00000e  f4244470          BIC      r4,r4,#0xf000
;;;7454     tmpccmr1 |= (TIM_ICFilter << 12U);
000012  ea443202          ORR      r2,r4,r2,LSL #12
;;;7455   
;;;7456     /* Select the Polarity and set the CC2E Bit */
;;;7457     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000016  f02303a0          BIC      r3,r3,#0xa0
;;;7458     tmpccer |= (TIM_ICPolarity << 4U);
00001a  ea431101          ORR      r1,r3,r1,LSL #4
;;;7459   
;;;7460     /* Write to TIMx CCMR1 and CCER registers */
;;;7461     TIMx->CCMR1 = tmpccmr1 ;
00001e  6182              STR      r2,[r0,#0x18]
;;;7462     TIMx->CCER = tmpccer;
000020  6201              STR      r1,[r0,#0x20]
;;;7463   }
000022  bd10              POP      {r4,pc}
;;;7464   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;7401     */
;;;7402   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;7403                                 uint32_t TIM_ICFilter)
;;;7404   {
;;;7405     uint32_t tmpccmr1;
;;;7406     uint32_t tmpccer;
;;;7407   
;;;7408     /* Disable the Channel 2: Reset the CC2E Bit */
;;;7409     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  6204              STR      r4,[r0,#0x20]
;;;7410     tmpccmr1 = TIMx->CCMR1;
00000a  6985              LDR      r5,[r0,#0x18]
;;;7411     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;7412   
;;;7413     /* Select the Input */
;;;7414     tmpccmr1 &= ~TIM_CCMR1_CC2S;
00000e  f4257540          BIC      r5,r5,#0x300
;;;7415     tmpccmr1 |= (TIM_ICSelection << 8U);
000012  ea452202          ORR      r2,r5,r2,LSL #8
;;;7416   
;;;7417     /* Set the filter */
;;;7418     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4224570          BIC      r5,r2,#0xf000
;;;7419     tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
00001a  f64f72ff          MOV      r2,#0xffff
00001e  ea023203          AND      r2,r2,r3,LSL #12
000022  432a              ORRS     r2,r2,r5
;;;7420   
;;;7421     /* Select the Polarity and set the CC2E Bit */
;;;7422     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000024  f02403a0          BIC      r3,r4,#0xa0
;;;7423     tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000028  24a0              MOVS     r4,#0xa0
00002a  ea041101          AND      r1,r4,r1,LSL #4
00002e  4319              ORRS     r1,r1,r3
;;;7424   
;;;7425     /* Write to TIMx CCMR1 and CCER registers */
;;;7426     TIMx->CCMR1 = tmpccmr1 ;
000030  6182              STR      r2,[r0,#0x18]
;;;7427     TIMx->CCER = tmpccer;
000032  6201              STR      r1,[r0,#0x20]
;;;7428   }
000034  bd30              POP      {r4,r5,pc}
;;;7429   
                          ENDP


                          AREA ||i.TIM_TI3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI3_SetConfig PROC
;;;7484     */
;;;7485   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;7486                                 uint32_t TIM_ICFilter)
;;;7487   {
;;;7488     uint32_t tmpccmr2;
;;;7489     uint32_t tmpccer;
;;;7490   
;;;7491     /* Disable the Channel 3: Reset the CC3E Bit */
;;;7492     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f4247480          BIC      r4,r4,#0x100
000008  6204              STR      r4,[r0,#0x20]
;;;7493     tmpccmr2 = TIMx->CCMR2;
00000a  69c4              LDR      r4,[r0,#0x1c]
;;;7494     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;7495   
;;;7496     /* Select the Input */
;;;7497     tmpccmr2 &= ~TIM_CCMR2_CC3S;
00000e  f0240403          BIC      r4,r4,#3
;;;7498     tmpccmr2 |= TIM_ICSelection;
000012  4314              ORRS     r4,r4,r2
;;;7499   
;;;7500     /* Set the filter */
;;;7501     tmpccmr2 &= ~TIM_CCMR2_IC3F;
000014  f02404f0          BIC      r4,r4,#0xf0
;;;7502     tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
000018  071a              LSLS     r2,r3,#28
00001a  ea446212          ORR      r2,r4,r2,LSR #24
;;;7503   
;;;7504     /* Select the Polarity and set the CC3E Bit */
;;;7505     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
00001e  f4256320          BIC      r3,r5,#0xa00
;;;7506     tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
000022  f44f6420          MOV      r4,#0xa00
000026  ea042101          AND      r1,r4,r1,LSL #8
00002a  4319              ORRS     r1,r1,r3
;;;7507   
;;;7508     /* Write to TIMx CCMR2 and CCER registers */
;;;7509     TIMx->CCMR2 = tmpccmr2;
00002c  61c2              STR      r2,[r0,#0x1c]
;;;7510     TIMx->CCER = tmpccer;
00002e  6201              STR      r1,[r0,#0x20]
;;;7511   }
000030  bd30              POP      {r4,r5,pc}
;;;7512   
                          ENDP


                          AREA ||i.TIM_TI4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI4_SetConfig PROC
;;;7532     */
;;;7533   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;7534                                 uint32_t TIM_ICFilter)
;;;7535   {
;;;7536     uint32_t tmpccmr2;
;;;7537     uint32_t tmpccer;
;;;7538   
;;;7539     /* Disable the Channel 4: Reset the CC4E Bit */
;;;7540     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f4245480          BIC      r4,r4,#0x1000
000008  6204              STR      r4,[r0,#0x20]
;;;7541     tmpccmr2 = TIMx->CCMR2;
00000a  69c5              LDR      r5,[r0,#0x1c]
;;;7542     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;7543   
;;;7544     /* Select the Input */
;;;7545     tmpccmr2 &= ~TIM_CCMR2_CC4S;
00000e  f4257540          BIC      r5,r5,#0x300
;;;7546     tmpccmr2 |= (TIM_ICSelection << 8U);
000012  ea452202          ORR      r2,r5,r2,LSL #8
;;;7547   
;;;7548     /* Set the filter */
;;;7549     tmpccmr2 &= ~TIM_CCMR2_IC4F;
000016  f4224570          BIC      r5,r2,#0xf000
;;;7550     tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
00001a  f64f72ff          MOV      r2,#0xffff
00001e  ea023203          AND      r2,r2,r3,LSL #12
000022  432a              ORRS     r2,r2,r5
;;;7551   
;;;7552     /* Select the Polarity and set the CC4E Bit */
;;;7553     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
000024  f4244320          BIC      r3,r4,#0xa000
;;;7554     tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
000028  f44f4420          MOV      r4,#0xa000
00002c  ea043101          AND      r1,r4,r1,LSL #12
000030  4319              ORRS     r1,r1,r3
;;;7555   
;;;7556     /* Write to TIMx CCMR2 and CCER registers */
;;;7557     TIMx->CCMR2 = tmpccmr2;
000032  61c2              STR      r2,[r0,#0x1c]
;;;7558     TIMx->CCER = tmpccer ;
000034  6201              STR      r1,[r0,#0x20]
;;;7559   }
000036  bd30              POP      {r4,r5,pc}
;;;7560   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_tim_c_a9d95b52____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_tim_c_a9d95b52____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_tim_c_a9d95b52____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_tim_c_a9d95b52____RRX|
#line 694
|__asm___19_stm32l4xx_hal_tim_c_a9d95b52____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
