; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_cortex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_cortex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_cortex.c]
                          THUMB

                          AREA ||i.HAL_MPU_ConfigRegion||, CODE, READONLY, ALIGN=2

                  HAL_MPU_ConfigRegion PROC
;;;461      */
;;;462    void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
000000  4a14              LDR      r2,|L1.84|
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
;;;466      assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
;;;467    
;;;468      /* Set the Region number */
;;;469      MPU->RNR = MPU_Init->Number;
000002  7841              LDRB     r1,[r0,#1]
000004  6011              STR      r1,[r2,#0]
;;;470    
;;;471      if ((MPU_Init->Enable) != RESET)
000006  7803              LDRB     r3,[r0,#0]
;;;472      {
;;;473        /* Check the parameters */
;;;474        assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
;;;475        assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
;;;476        assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
;;;477        assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
;;;478        assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
;;;479        assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
;;;480        assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
;;;481        assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
;;;482    
;;;483        MPU->RBAR = MPU_Init->BaseAddress;
000008  1d11              ADDS     r1,r2,#4
;;;484        MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
00000a  1d0a              ADDS     r2,r1,#4
00000c  2b00              CMP      r3,#0                 ;471
00000e  d01c              BEQ      |L1.74|
000010  6843              LDR      r3,[r0,#4]            ;483
000012  600b              STR      r3,[r1,#0]            ;483
000014  7b01              LDRB     r1,[r0,#0xc]
000016  7ac3              LDRB     r3,[r0,#0xb]
000018  0709              LSLS     r1,r1,#28
00001a  ea416103          ORR      r1,r1,r3,LSL #24
00001e  7a83              LDRB     r3,[r0,#0xa]
000020  ea4141c3          ORR      r1,r1,r3,LSL #19
000024  7b43              LDRB     r3,[r0,#0xd]
000026  ea414183          ORR      r1,r1,r3,LSL #18
00002a  7b83              LDRB     r3,[r0,#0xe]
00002c  ea414143          ORR      r1,r1,r3,LSL #17
000030  7bc3              LDRB     r3,[r0,#0xf]
000032  ea414103          ORR      r1,r1,r3,LSL #16
000036  7a43              LDRB     r3,[r0,#9]
000038  ea412103          ORR      r1,r1,r3,LSL #8
00003c  7a03              LDRB     r3,[r0,#8]
00003e  7800              LDRB     r0,[r0,#0]
000040  ea410143          ORR      r1,r1,r3,LSL #1
000044  4301              ORRS     r1,r1,r0
000046  6011              STR      r1,[r2,#0]
;;;485                    ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
;;;486                    ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
;;;487                    ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
;;;488                    ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
;;;489                    ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
;;;490                    ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
;;;491                    ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
;;;492                    ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
;;;493      }
;;;494      else
;;;495      {
;;;496        MPU->RBAR = 0x00;
;;;497        MPU->RASR = 0x00;
;;;498      }
;;;499    }
000048  4770              BX       lr
                  |L1.74|
00004a  2000              MOVS     r0,#0                 ;496
00004c  6008              STR      r0,[r1,#0]            ;496
00004e  6010              STR      r0,[r2,#0]            ;497
000050  4770              BX       lr
;;;500    #endif /* __MPU_PRESENT */
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      0xe000ed98

                          AREA ||i.HAL_MPU_Disable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Disable PROC
;;;445      */
;;;446    void HAL_MPU_Disable(void)
000000  f3bf8f5f          DMB      
;;;447    {
;;;448      /* Make sure outstanding transfers are done */
;;;449      __DMB();
;;;450    
;;;451      /* Disable the MPU and clear the control register*/
;;;452      MPU->CTRL  = 0;
000004  4901              LDR      r1,|L2.12|
000006  2000              MOVS     r0,#0
000008  6008              STR      r0,[r1,#0]
;;;453    }
00000a  4770              BX       lr
;;;454    
                          ENDP

                  |L2.12|
                          DCD      0xe000ed94

                          AREA ||i.HAL_MPU_Enable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Enable PROC
;;;430      */
;;;431    void HAL_MPU_Enable(uint32_t MPU_Control)
000000  4904              LDR      r1,|L3.20|
;;;432    {
;;;433      /* Enable the MPU */
;;;434      MPU->CTRL = (MPU_Control | MPU_CTRL_ENABLE_Msk);
000002  f0400001          ORR      r0,r0,#1
000006  6008              STR      r0,[r1,#0]
;;;435    
;;;436      /* Ensure MPU setting take effects */
;;;437      __DSB();
000008  f3bf8f4f          DSB      
;;;438      __ISB();
00000c  f3bf8f6f          ISB      
;;;439    }
000010  4770              BX       lr
;;;440    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0xe000ed94

                          AREA ||i.HAL_NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_ClearPendingIRQ PROC
;;;353      */
;;;354    void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;355    {
000002  db09              BLT      |L4.24|
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01280          STR      r1,[r0,#0x280]
                  |L4.24|
;;;356      /* Check the parameters */
;;;357      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;358      
;;;359      /* Clear pending interrupt */
;;;360      NVIC_ClearPendingIRQ(IRQn);
;;;361    }
000018  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.HAL_NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_DisableIRQ PROC
;;;223      */
;;;224    void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;225    {
000002  db0d              BLT      |L5.32|
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01180          STR      r1,[r0,#0x180]
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L5.32|
;;;226      /* Check the parameters */
;;;227      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;228      
;;;229      /* Disable interrupt */
;;;230      NVIC_DisableIRQ(IRQn);
;;;231    }
000020  4770              BX       lr
;;;232    
                          ENDP


                          AREA ||i.HAL_NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_EnableIRQ PROC
;;;207      */
;;;208    void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;209    {
000002  db09              BLT      |L6.24|
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L6.24|
;;;210      /* Check the parameters */
;;;211      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;212      
;;;213      /* Enable interrupt */
;;;214      NVIC_EnableIRQ(IRQn);
;;;215    }
000018  4770              BX       lr
;;;216    
                          ENDP


                          AREA ||i.HAL_NVIC_GetActive||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetActive PROC
;;;370      */
;;;371    uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;372    {
000002  db0f              BLT      |L7.36|
000004  0941              LSRS     r1,r0,#5
000006  0089              LSLS     r1,r1,#2
000008  f10121e0          ADD      r1,r1,#0xe000e000
00000c  f8d11300          LDR      r1,[r1,#0x300]
000010  f000021f          AND      r2,r0,#0x1f
000014  2001              MOVS     r0,#1
000016  4090              LSLS     r0,r0,r2
000018  4201              TST      r1,r0
00001a  d001              BEQ      |L7.32|
00001c  2001              MOVS     r0,#1
;;;373      /* Return 1 if active else 0 */
;;;374      return NVIC_GetActive(IRQn);
;;;375    }
00001e  4770              BX       lr
                  |L7.32|
000020  2000              MOVS     r0,#0
000022  4770              BX       lr
                  |L7.36|
000024  2000              MOVS     r0,#0
000026  4770              BX       lr
;;;376    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPendingIRQ PROC
;;;337      */
;;;338    uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;339    {
000002  db0f              BLT      |L8.36|
000004  0941              LSRS     r1,r0,#5
000006  0089              LSLS     r1,r1,#2
000008  f10121e0          ADD      r1,r1,#0xe000e000
00000c  f8d11200          LDR      r1,[r1,#0x200]
000010  f000021f          AND      r2,r0,#0x1f
000014  2001              MOVS     r0,#1
000016  4090              LSLS     r0,r0,r2
000018  4201              TST      r1,r0
00001a  d001              BEQ      |L8.32|
00001c  2001              MOVS     r0,#1
;;;340      /* Check the parameters */
;;;341      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;342      
;;;343      /* Return 1 if pending else 0 */
;;;344      return NVIC_GetPendingIRQ(IRQn);
;;;345    }
00001e  4770              BX       lr
                  |L8.32|
000020  2000              MOVS     r0,#0
000022  4770              BX       lr
                  |L8.36|
000024  2000              MOVS     r0,#0
000026  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriority||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPriority PROC
;;;304      */
;;;305    void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
000000  b5f0              PUSH     {r4-r7,lr}
000002  2800              CMP      r0,#0
;;;306    {
000004  db05              BLT      |L9.18|
000006  f10020e0          ADD      r0,r0,#0xe000e000
00000a  f8900400          LDRB     r0,[r0,#0x400]
00000e  0904              LSRS     r4,r0,#4
000010  e006              B        |L9.32|
                  |L9.18|
000012  f000000f          AND      r0,r0,#0xf
000016  f10020e0          ADD      r0,r0,#0xe000e000
00001a  f8900d14          LDRB     r0,[r0,#0xd14]
00001e  0904              LSRS     r4,r0,#4
                  |L9.32|
000020  f0010007          AND      r0,r1,#7
000024  f1c00107          RSB      r1,r0,#7
000028  2904              CMP      r1,#4
00002a  d900              BLS      |L9.46|
00002c  2104              MOVS     r1,#4
                  |L9.46|
00002e  1d05              ADDS     r5,r0,#4
000030  2d07              CMP      r5,#7
000032  d201              BCS      |L9.56|
000034  2000              MOVS     r0,#0
000036  e000              B        |L9.58|
                  |L9.56|
000038  1ec0              SUBS     r0,r0,#3
                  |L9.58|
00003a  2701              MOVS     r7,#1
00003c  fa24f600          LSR      r6,r4,r0
000040  fa07f501          LSL      r5,r7,r1
000044  1e6d              SUBS     r5,r5,#1
000046  402e              ANDS     r6,r6,r5
000048  6016              STR      r6,[r2,#0]
00004a  fa07f500          LSL      r5,r7,r0
00004e  1e6d              SUBS     r5,r5,#1
000050  4025              ANDS     r5,r5,r4
000052  601d              STR      r5,[r3,#0]
;;;307      /* Check the parameters */
;;;308      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;309     /* Get priority for Cortex-M system or device specific interrupts */
;;;310      NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
;;;311    }
000054  bdf0              POP      {r4-r7,pc}
;;;312    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPriorityGrouping PROC
;;;277      */
;;;278    uint32_t HAL_NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L10.12|
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;279    {
;;;280      /* Get the PRIGROUP[10:8] field value */
;;;281      return NVIC_GetPriorityGrouping();
;;;282    }
000008  4770              BX       lr
;;;283    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_SetPendingIRQ PROC
;;;319      */
;;;320    void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;321    {
000002  db09              BLT      |L11.24|
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01200          STR      r1,[r0,#0x200]
                  |L11.24|
;;;322      /* Check the parameters */
;;;323      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;324      
;;;325      /* Set interrupt pending */
;;;326      NVIC_SetPendingIRQ(IRQn);
;;;327    }
000018  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriority PROC
;;;185      */
;;;186    void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
000000  b4f0              PUSH     {r4-r7}
;;;187    {
000002  460d              MOV      r5,r1
000004  4b0d              LDR      r3,|L12.60|
000006  681b              LDR      r3,[r3,#0]
000008  f3c32302          UBFX     r3,r3,#8,#3
00000c  f1c30407          RSB      r4,r3,#7
000010  2c04              CMP      r4,#4
000012  d900              BLS      |L12.22|
000014  2404              MOVS     r4,#4
                  |L12.22|
000016  1d19              ADDS     r1,r3,#4
000018  2907              CMP      r1,#7
00001a  d201              BCS      |L12.32|
00001c  2300              MOVS     r3,#0
00001e  e000              B        |L12.34|
                  |L12.32|
000020  1edb              SUBS     r3,r3,#3
                  |L12.34|
000022  2601              MOVS     r6,#1
000024  fa06f104          LSL      r1,r6,r4
000028  1e49              SUBS     r1,r1,#1
00002a  4029              ANDS     r1,r1,r5
00002c  4099              LSLS     r1,r1,r3
00002e  409e              LSLS     r6,r6,r3
000030  1e76              SUBS     r6,r6,#1
000032  4016              ANDS     r6,r6,r2
000034  4331              ORRS     r1,r1,r6
;;;188      uint32_t prioritygroup = 0x00;
;;;189    
;;;190      /* Check the parameters */
;;;191      assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
;;;192      assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
;;;193    
;;;194      prioritygroup = NVIC_GetPriorityGrouping();
;;;195    
;;;196      NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
000036  bcf0              POP      {r4-r7}
000038  f7ffbffe          B.W      __NVIC_SetPriority
;;;197    }
;;;198    
                          ENDP

                  |L12.60|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriorityGrouping PROC
;;;163      */
;;;164    void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
000000  f0000107          AND      r1,r0,#7
000004  4a05              LDR      r2,|L13.28|
000006  6810              LDR      r0,[r2,#0]
000008  f64f03ff          MOV      r3,#0xf8ff
00000c  4018              ANDS     r0,r0,r3
00000e  ea402001          ORR      r0,r0,r1,LSL #8
000012  4903              LDR      r1,|L13.32|
000014  4308              ORRS     r0,r0,r1
000016  6010              STR      r0,[r2,#0]
;;;165    {
;;;166      /* Check the parameters */
;;;167      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;168    
;;;169      /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
;;;170      NVIC_SetPriorityGrouping(PriorityGroup);
;;;171    }
000018  4770              BX       lr
;;;172    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0xe000ed0c
                  |L13.32|
                          DCD      0x05fa0000

                          AREA ||i.HAL_NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SystemReset PROC
;;;236      */
;;;237    void HAL_NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
000004  4805              LDR      r0,|L14.28|
000006  6801              LDR      r1,[r0,#0]
000008  4a05              LDR      r2,|L14.32|
00000a  f40161e0          AND      r1,r1,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
000012  f3bf8f4f          DSB      
                  |L14.22|
000016  bf00              NOP      
000018  e7fd              B        |L14.22|
;;;238    {
;;;239      /* System Reset */
;;;240      NVIC_SystemReset();
;;;241    }
;;;242    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0xe000ed0c
                  |L14.32|
                          DCD      0x05fa0004

                          AREA ||i.HAL_SYSTICK_CLKSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_CLKSourceConfig PROC
;;;384      */
;;;385    void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;386    {
;;;387      /* Check the parameters */
;;;388      assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
;;;389      if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
000004  2804              CMP      r0,#4
000006  d004              BEQ      |L15.18|
;;;390      {
;;;391        SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
;;;392      }
;;;393      else
;;;394      {
;;;395        SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
000008  6908              LDR      r0,[r1,#0x10]
00000a  f0200004          BIC      r0,r0,#4
00000e  6108              STR      r0,[r1,#0x10]
;;;396      }
;;;397    }
000010  4770              BX       lr
                  |L15.18|
000012  6908              LDR      r0,[r1,#0x10]         ;391
000014  f0400004          ORR      r0,r0,#4              ;391
000018  6108              STR      r0,[r1,#0x10]         ;391
00001a  4770              BX       lr
;;;398    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Callback PROC
;;;411      */
;;;412    __weak void HAL_SYSTICK_Callback(void)
000000  4770              BX       lr
;;;413    {
;;;414      /* NOTE : This function should not be modified, when the callback is needed,
;;;415                the HAL_SYSTICK_Callback could be implemented in the user file
;;;416       */
;;;417    }
;;;418    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Config||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Config PROC
;;;249      */
;;;250    uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
000000  b510              PUSH     {r4,lr}
000002  1e40              SUBS     r0,r0,#1
000004  f1b07f80          CMP      r0,#0x1000000
;;;251    {
000008  d301              BCC      |L17.14|
00000a  2001              MOVS     r0,#1
;;;252       return SysTick_Config(TicksNumb);
;;;253    }
00000c  bd10              POP      {r4,pc}
                  |L17.14|
00000e  f04f24e0          MOV      r4,#0xe000e000
000012  6160              STR      r0,[r4,#0x14]
000014  210f              MOVS     r1,#0xf
000016  1760              ASRS     r0,r4,#29
000018  f7fffffe          BL       __NVIC_SetPriority
00001c  2000              MOVS     r0,#0
00001e  61a0              STR      r0,[r4,#0x18]
000020  2007              MOVS     r0,#7
000022  6120              STR      r0,[r4,#0x10]
000024  2000              MOVS     r0,#0
000026  bd10              POP      {r4,pc}
;;;254    /**
                          ENDP


                          AREA ||i.HAL_SYSTICK_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_IRQHandler PROC
;;;402      */
;;;403    void HAL_SYSTICK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;404    {
;;;405      HAL_SYSTICK_Callback();
000002  f7fffffe          BL       HAL_SYSTICK_Callback
;;;406    }
000006  bd10              POP      {r4,pc}
;;;407    
                          ENDP


                          AREA ||i.__NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  __NVIC_SetPriority PROC
;;;1808    */
;;;1809   __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;1810   {
;;;1811     if ((int32_t)(IRQn) >= 0)
;;;1812     {
;;;1813       NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000002  0e09              LSRS     r1,r1,#24
000004  2800              CMP      r0,#0                 ;1811
000006  db04              BLT      |L19.18|
000008  f10020e0          ADD      r0,r0,#0xe000e000
00000c  f8801400          STRB     r1,[r0,#0x400]
;;;1814     }
;;;1815     else
;;;1816     {
;;;1817       SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1818     }
;;;1819   }
000010  4770              BX       lr
                  |L19.18|
000012  f000000f          AND      r0,r0,#0xf            ;1817
000016  f10020e0          ADD      r0,r0,#0xe000e000     ;1817
00001a  f8801d14          STRB     r1,[r0,#0xd14]        ;1817
00001e  4770              BX       lr
;;;1820   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../../../Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_cortex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REVSH|
#line 507
|__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____RRX|
#line 694
|__asm___22_stm32l4xx_hal_cortex_c_2992dbc0____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
