; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\apiirmonitoring.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\apiirmonitoring.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\API\ApiIRMonitoring.c]
                          THUMB

                          AREA ||i.IRM_Balance_formula||, CODE, READONLY, ALIGN=2

                  IRM_Balance_formula PROC
;;;161    
;;;162    static uint16_t  IRM_Balance_formula(IRMonitoring_Data_t data, IRMonitoring_Resistor_t *res_out){
000000  b40f              PUSH     {r0-r3}
000002  990a              LDR      r1,[sp,#0x28]
;;;163    	
;;;164    	ra = ((float)IRM_RA)*1.0f;
000004  4820              LDR      r0,|L1.136|
000006  ed9f0a1f          VLDR     s0,|L1.132|
00000a  ed800a05          VSTR     s0,[r0,#0x14]
;;;165    	rb = ((float)IRM_RB)*1.0f;
00000e  ed800a06          VSTR     s0,[r0,#0x18]
;;;166    	rc = ((float)IRM_RC)*1.0f;
000012  eddf0a1e          VLDR     s1,|L1.140|
000016  edc00a07          VSTR     s1,[r0,#0x1c]
;;;167    	
;;;168    	temp_rp = (((data.Vn / data.Vn_l) * (data.Vp_l / data.Vp))-1.0f)*ra;
00001a  ed9d1a04          VLDR     s2,[sp,#0x10]
00001e  eddd0a07          VLDR     s1,[sp,#0x1c]
000022  eddd1a05          VLDR     s3,[sp,#0x14]
000026  eec12a20          VDIV.F32 s5,s2,s1
00002a  ed9d1a08          VLDR     s2,[sp,#0x20]
00002e  ee813a21          VDIV.F32 s6,s2,s3
000032  eef71a00          VMOV.F32 s3,#1.00000000
000036  eeb02a61          VMOV.F32 s4,s3
00003a  ee122a83          VNMLS.F32 s4,s5,s6
00003e  ee220a00          VMUL.F32 s0,s4,s0
000042  ed800a03          VSTR     s0,[r0,#0xc]
;;;169    	temp_rn = 1.0f/(((data.Vp_l / data.Vn_l)*(1.0f/temp_rp))-(1.0f/(rb + rc)));
000046  eec12a20          VDIV.F32 s5,s2,s1
00004a  ed9f2a11          VLDR     s4,|L1.144|
00004e  eec10a80          VDIV.F32 s1,s3,s0
000052  ee122aa0          VNMLS.F32 s4,s5,s1
000056  eec10a82          VDIV.F32 s1,s3,s4
00005a  edc00a04          VSTR     s1,[r0,#0x10]
;;;170    	
;;;171    	res_out->Rp_kohm = (uint16_t)(temp_rp / 1000.0f);
00005e  ed9f1a0d          VLDR     s2,|L1.148|
000062  eec01a01          VDIV.F32 s3,s0,s2
000066  eebc0ae1          VCVT.U32.F32 s0,s3
00006a  ee100a10          VMOV     r0,s0
00006e  8008              STRH     r0,[r1,#0]
;;;172    	res_out->Rn_kohm = (uint16_t)(temp_rn / 1000.0f);
000070  ee800a81          VDIV.F32 s0,s1,s2
000074  eebc0ac0          VCVT.U32.F32 s0,s0
000078  ee100a10          VMOV     r0,s0
00007c  8048              STRH     r0,[r1,#2]
;;;173    	
;;;174    	return 0;
00007e  2000              MOVS     r0,#0
;;;175    }
000080  b004              ADD      sp,sp,#0x10
000082  4770              BX       lr
;;;176    
                          ENDP

                  |L1.132|
000084  49435000          DCFS     0x49435000 ; 800000
                  |L1.136|
                          DCD      ||.data||
                  |L1.140|
00008c  45098000          DCFS     0x45098000 ; 2200
                  |L1.144|
000090  35a74fe3          DCFS     0x35a74fe3 ; 1.2465719692045241e-06
                  |L1.148|
000094  447a0000          DCFS     0x447a0000 ; 1000

                          AREA ||i.IRM_Unbalance_formula||, CODE, READONLY, ALIGN=2

                  IRM_Unbalance_formula PROC
;;;176    
;;;177    static uint16_t  IRM_Unbalance_formula(IRMonitoring_Data_t data, IRMonitoring_Resistor_t *res_out){
000000  b40f              PUSH     {r0-r3}
000002  990a              LDR      r1,[sp,#0x28]
;;;178    	
;;;179    	ra = ((float)IRM_RA)*1.0f;
000004  4832              LDR      r0,|L2.208|
000006  ed9f0a31          VLDR     s0,|L2.204|
00000a  ed800a05          VSTR     s0,[r0,#0x14]
;;;180    	rb = ((float)IRM_RB)*1.0f;
00000e  ed800a06          VSTR     s0,[r0,#0x18]
;;;181    	rc = ((float)IRM_RC)*1.0f;
000012  ed9f0a30          VLDR     s0,|L2.212|
000016  ed800a07          VSTR     s0,[r0,#0x1c]
;;;182    	rd = ((float)IRM_RD)*1.0f;
00001a  ed9f0a2f          VLDR     s0,|L2.216|
00001e  ed800a08          VSTR     s0,[r0,#0x20]
;;;183    
;;;184    	temp_a = ((data.Vp_l / data.Vp) * (data.Vn / data.Vn_l))-1.0f;
000022  ed9d0a08          VLDR     s0,[sp,#0x20]
000026  ed9d3a05          VLDR     s6,[sp,#0x14]
00002a  ed9d1a04          VLDR     s2,[sp,#0x10]
00002e  eddd0a07          VLDR     s1,[sp,#0x1c]
000032  eec01a03          VDIV.F32 s3,s0,s6
000036  eef73a00          VMOV.F32 s7,#1.00000000
00003a  eef02a63          VMOV.F32 s5,s7
00003e  ee812a20          VDIV.F32 s4,s2,s1
000042  ee512a82          VNMLS.F32 s5,s3,s4
000046  edc02a09          VSTR     s5,[r0,#0x24]
;;;185    	
;;;186    	temp_c = 1.0f/(rb+ rc + rd);
00004a  eddf1a24          VLDR     s3,|L2.220|
00004e  edc01a0b          VSTR     s3,[r0,#0x2c]
;;;187      Ra_l = (ra * rd + (rd *( rb+ rc)) + (( rb+ rc) * ra)) / (rb+ rc);  
000052  ed9f2a23          VLDR     s4,|L2.224|
000056  ed802a0d          VSTR     s4,[r0,#0x34]
;;;188    	Rb_l = (ra * rd + (rd *( rb + rc)) + ((rb+ rc) * ra)) / (ra);
00005a  ed9f2a22          VLDR     s4,|L2.228|
00005e  ed802a0e          VSTR     s4,[r0,#0x38]
;;;189    	temp_b = temp_c + (data.Vp_l/ data.Vn_l) * (1.0f/Ra_l - (data.Vn/data.Vp * (1.0f/Rb_l)));
000062  ee812a03          VDIV.F32 s4,s2,s6
000066  ed9f4a20          VLDR     s8,|L2.232|
00006a  ed9f1a20          VLDR     s2,|L2.236|
00006e  eec04a20          VDIV.F32 s9,s0,s1
000072  ee024a41          VMLS.F32 s8,s4,s2
000076  eeb02a61          VMOV.F32 s4,s3
00007a  ee042a84          VMLA.F32 s4,s9,s8
00007e  ed802a0a          VSTR     s4,[r0,#0x28]
;;;190    	
;;;191    	temp_rn = temp_a/temp_b;	
000082  ee821a82          VDIV.F32 s2,s5,s4
000086  ed801a04          VSTR     s2,[r0,#0x10]
;;;192    	
;;;193    	temp_d = 1.0f/(rb + rc + rd);
00008a  edc01a0c          VSTR     s3,[r0,#0x30]
;;;194      temp_rp = 1.0f/((data.Vn_l/data.Vp_l)*(temp_d + (1.0f/temp_rn)));
00008e  ee802a80          VDIV.F32 s4,s1,s0
000092  ee830a81          VDIV.F32 s0,s7,s2
000096  ee300a21          VADD.F32 s0,s0,s3
00009a  ee620a00          VMUL.F32 s1,s4,s0
00009e  ee830aa0          VDIV.F32 s0,s7,s1
0000a2  ed800a03          VSTR     s0,[r0,#0xc]
;;;195    	
;;;196    	res_out->Rp_kohm = (uint16_t)(temp_rp / 1000.0f);
0000a6  eddf0a12          VLDR     s1,|L2.240|
0000aa  eec01a20          VDIV.F32 s3,s0,s1
0000ae  eebc0ae1          VCVT.U32.F32 s0,s3
0000b2  ee100a10          VMOV     r0,s0
0000b6  8008              STRH     r0,[r1,#0]
;;;197    	res_out->Rn_kohm = (uint16_t)(temp_rn / 1000.0f);
0000b8  ee810a20          VDIV.F32 s0,s2,s1
0000bc  eebc0ac0          VCVT.U32.F32 s0,s0
0000c0  ee100a10          VMOV     r0,s0
0000c4  8048              STRH     r0,[r1,#2]
;;;198    	
;;;199    	return 0;
0000c6  2000              MOVS     r0,#0
;;;200    }
0000c8  b004              ADD      sp,sp,#0x10
0000ca  4770              BX       lr
;;;201    
                          ENDP

                  |L2.204|
0000cc  49435000          DCFS     0x49435000 ; 800000
                  |L2.208|
                          DCD      ||.data||
                  |L2.212|
0000d4  45098000          DCFS     0x45098000 ; 2200
                  |L2.216|
0000d8  48f42400          DCFS     0x48f42400 ; 500000
                  |L2.220|
0000dc  354e23d4          DCFS     0x354e23d4 ; 7.6793116932094563e-07
                  |L2.224|
0000e0  49db8f26          DCFS     0x49db8f26 ; 1798628.75
                  |L2.228|
0000e4  49dc29b8          DCFS     0x49dc29b8 ; 1803575
                  |L2.232|
0000e8  35153e98          DCFS     0x35153e98 ; 5.5597911341465078e-07
                  |L2.236|
0000ec  3514d5d0          DCFS     0x3514d5d0 ; 5.5445434554712847e-07
                  |L2.240|
0000f0  447a0000          DCFS     0x447a0000 ; 1000

                          AREA ||i.IRMonitoringMeasure_Steps||, CODE, READONLY, ALIGN=2

                  IRMonitoringMeasure_Steps PROC
;;;201    
;;;202    static IRMonitoring_step_ret_type IRMonitoringMeasure_Steps(IRMonitoring_steps_enum steps)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;203    {
000004  ed2d8b02          VPUSH    {d8}
000008  b089              SUB      sp,sp,#0x24
;;;204    	static uint16_t sub_step_count = 0;
;;;205    	static IRMonitoring_event_read_cb_type read_fun_res;
;;;206    	static IRMonitoring_steps_enum n_next_step;
;;;207    	
;;;208        switch(steps){
;;;209    			case IRM_S1:
;;;210    		      IRMonitoring_CtrlSW(IRM_SW_ON, IRM_SW_OFF , IRM_SW_OFF);
;;;211    			    irm_sub_step = 0;
;;;212    			    irm_mes_step = IRM_IO_WAITTING;
;;;213    			    n_next_step =IRM_S2;
;;;214    		      break;
;;;215    			case IRM_S2:
;;;216    				  if(irm_data_ready_f == 1){
;;;217    						  irm_data_ready_f = 0;
;;;218    						
;;;219    				      irm_data.Vo_stack = irm_adc_data;
00000a  4cb2              LDR      r4,|L3.724|
;;;220    			        irm_data.V_stack  = (irm_data.Vo_stack * IRM_K1);
;;;221    			
;;;222                  //If callback function exist then execution this.
;;;223    	            if((irm_event_cb.irm_outdata != NULL) && (irm_vstack_f==1)){	
;;;224    								
;;;225    								  irm_vstack_f = 0;
;;;226    					      
;;;227      								//Test 
;;;228    							    #ifdef IRM_TEST_OUT_VSTACK
;;;229    							    irm_data.V_stack = 1000.0f;
;;;230    							    #endif   
;;;231    								
;;;232    							    irm_res_out.V_stack = irm_data.V_stack;
00000c  f8dfb2bc          LDR      r11,|L3.716|
;;;233    	                irm_event_cb.irm_outdata(&irm_res_out, IRM_EVENT_GET_VSTACK);
;;;234    							    IRMonitoring_StateReset();
;;;235    						      return(IRM_STEP_OUT_VSTACK_VAL);
;;;236                  }   			
;;;237    				   }
;;;238    
;;;239    		      IRMonitoring_CtrlSW(IRM_SW_ON, IRM_SW_OFF , IRM_SW_ON);
;;;240    			    irm_sub_step = 0;
;;;241    			    irm_mes_step = IRM_IO_WAITTING;
;;;242    			    n_next_step =IRM_S3;
;;;243    		      break;
;;;244    			case IRM_S3:
;;;245    				  if(irm_data_ready_f == 1){
;;;246    						 irm_data_ready_f = 0;
;;;247    						
;;;248    						 irm_data.Vo_n = irm_adc_data;
;;;249    						 irm_data.Vn   = (irm_data.Vo_n * IRM_K2);  					
;;;250    					}
;;;251    			
;;;252              irm_data.Vp = (irm_data.V_stack - irm_data.Vn);  
;;;253    			    irm_sub_step = 0;
;;;254    			    irm_mes_step = IRM_S4;    											
;;;255    		      break;
;;;256    			case IRM_S4:			
;;;257    			    if(((fabs(irm_data.Vp - irm_data.Vn))/irm_data.V_stack) < IRM_KTHD){
;;;258    					    irm_sub_step = 1;
;;;259    					    irm_mes_step = IRM_S5;
;;;260    					}else{
;;;261    					    irm_sub_step = 1;
;;;262    					    irm_mes_step = IRM_S6;
;;;263    					}
;;;264    					
;;;265    					#ifdef IRM_TEST_S5 
;;;266    					irm_mes_step = IRM_S5;
;;;267    					#endif 
;;;268    					
;;;269    					#ifdef IRM_TEST_S6 
;;;270    					irm_mes_step = IRM_S6;
;;;271    					#endif 
;;;272    					
;;;273    		      break;
;;;274    			case IRM_S5:      //Balance resistor detection 
;;;275    		      switch(irm_sub_step){
;;;276    						case 1:
;;;277    							  IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_OFF, IRM_SW_ON);
;;;278    			          irm_mes_step = IRM_IO_WAITTING;
;;;279    			          n_next_step =IRM_S5;
;;;280                    irm_sub_step++;						
;;;281    						    break;
;;;282    						case 2:
;;;283    				        if(irm_data_ready_f == 1){
;;;284    						        irm_data_ready_f = 0;
;;;285    						        irm_data.Vo_n_l = irm_adc_data;
;;;286    						        irm_data.Vn_l   = (irm_data.Vo_n_l * IRM_K2);  								
;;;287    								}	
;;;288    						
;;;289    							  irm_data.Vp_l = (irm_data.V_stack - irm_data.Vn_l);  
;;;290    			          irm_sub_step++;    											
;;;291    						    break;
;;;292    						case 3:
;;;293    						    IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_OFF ,IRM_SW_OFF);	
;;;294    										
;;;295    			          //Test balance formula IRM use
;;;296    					      //----------------
;;;297    					      #ifdef IRM_TEST_S5
;;;298    	              irm_data.V_stack = 1000;
;;;299    	              irm_data.Vn   = 500.60f;
;;;300                    irm_data.Vn_l = 25.37606553f;
;;;301    					      irm_data.Vp   = 499.40f; 
;;;302    	              irm_data.Vp_l = 974.62f;
;;;303    					      #endif
;;;304    					      //----------------					
;;;305    						
;;;306    							  // balance formula
;;;307    						    IRM_Balance_formula(irm_data, &irm_res_out);
000010  f1040110          ADD      r1,r4,#0x10
000014  f1ab0540          SUB      r5,r11,#0x40          ;211
000018  9108              STR      r1,[sp,#0x20]         ;216
00001a  eddf0aad          VLDR     s1,|L3.720|
00001e  ed950a0f          VLDR     s0,[r5,#0x3c]         ;219
;;;308    						
;;;309    						    //If callback function exist then execution this.
;;;310    	              if(irm_event_cb.irm_outdata != NULL){
;;;311    	                  irm_event_cb.irm_outdata(&irm_res_out, IRM_EVENT_BALANCE);
;;;312                    } 						
;;;313    						
;;;314    						    irm_mes_step = IRM_FINISH;
;;;315    						    break;						
;;;316    					}         
;;;317    		      break;
;;;318    			case IRM_S6:      //Unbalance resistor detection 
;;;319    		      switch(irm_sub_step){
;;;320    						case 1:
;;;321    							  IRMonitoring_CtrlSW(IRM_SW_ON, IRM_SW_ON , IRM_SW_OFF);
;;;322    			          irm_mes_step = IRM_IO_WAITTING;
;;;323    			          n_next_step =IRM_S6;
;;;324                    irm_sub_step++;							     
;;;325    				        break;
;;;326    						case 2:
;;;327    				        if(irm_data_ready_f == 1){
;;;328    						        irm_data_ready_f = 0;
;;;329    										irm_data.Vo_en = irm_adc_data;
;;;330    						        irm_data.Vn   =(irm_data.Vo_en*((IRM_K2*(1+IRM_RD/IRM_RA))+(IRM_RD/IRM_RC)))-((IRM_RD/IRM_RA)*irm_data.V_stack);
;;;331    								}							
;;;332    						
;;;333    						    irm_data.Vp = (irm_data.V_stack - irm_data.Vn);  	
;;;334    						    irm_sub_step++;			
;;;335    				        break;
;;;336    						case 3:
;;;337    							  IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_ON , IRM_SW_OFF);
;;;338    			          irm_mes_step = IRM_IO_WAITTING;
;;;339    			          n_next_step =IRM_S6;
;;;340                    irm_sub_step++;
;;;341    				        break;
;;;342    						case 4:
;;;343    								if(irm_data_ready_f == 1){
;;;344    						        irm_data_ready_f = 0;	
;;;345    						        irm_data.Vo_n_l = irm_adc_data;
;;;346    						        irm_data.Vn_l   = (irm_data.Vo_n_l * IRM_K3);   
;;;347    								}
;;;348    
;;;349    							  irm_data.Vp_l = (irm_data.V_stack - irm_data.Vn_l);  
;;;350    						    irm_sub_step++;
;;;351    				        break;
;;;352    						case 5:
;;;353    						    IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_OFF ,IRM_SW_OFF);		
;;;354    
;;;355    			          //Test Unbalance formula IRM use
;;;356    					      //----------------
;;;357    					      #ifdef IRM_TEST_S6
;;;358    	              irm_data.V_stack = 1000.0f;
;;;359    	              irm_data.Vn   = 476.5691798f;
;;;360                    irm_data.Vn_l = 53.81882327f;
;;;361    					      irm_data.Vp   = 523.43f; 
;;;362    	              irm_data.Vp_l = 946.18f;
;;;363    					      #endif
;;;364    					      //----------------							
;;;365    						
;;;366    						    //Unbalance formula
;;;367    						    IRM_Unbalance_formula(irm_data, &irm_res_out); 
;;;368    		
;;;369    						    //If callback function exist then execution this.
;;;370    	              if(irm_event_cb.irm_outdata != NULL){
;;;371    	                  irm_event_cb.irm_outdata(&irm_res_out, IRM_EVENT_UNBALANCE);
;;;372                    } 						
;;;373    								
;;;374        						irm_mes_step = IRM_FINISH;
;;;375    				        break;						
;;;376    					}							
;;;377    		      break;	
;;;378    		  case IRM_IO_WAITTING:
;;;379    				  ++sub_step_count;
000022  896a              LDRH     r2,[r5,#0xa]
000024  2706              MOVS     r7,#6                 ;203
000026  1c52              ADDS     r2,r2,#1
000028  ee201a20          VMUL.F32 s2,s0,s1              ;249
00002c  fa1ffc82          UXTH     r12,r2
000030  2303              MOVS     r3,#3                 ;203
000032  7929              LDRB     r1,[r5,#4]            ;216
000034  2600              MOVS     r6,#0
000036  786a              LDRB     r2,[r5,#1]            ;211
000038  edd40a01          VLDR     s1,[r4,#4]            ;219
00003c  f04f0905          MOV      r9,#5                 ;203
000040  f04f0a01          MOV      r10,#1                ;203
000044  f1040828          ADD      r8,r4,#0x28           ;223
000048  2809              CMP      r0,#9                 ;208
00004a  d20f              BCS      |L3.108|
00004c  e8dff000          TBB      [pc,r0]               ;208
000050  050f3848          DCB      0x05,0x0f,0x38,0x48
000054  73adf9f8          DCB      0x73,0xad,0xf9,0xf8
000058  f700              DCB      0xf7,0x00
00005a  2200              MOVS     r2,#0                 ;210
00005c  4611              MOV      r1,r2                 ;210
00005e  2001              MOVS     r0,#1                 ;210
000060  f7fffffe          BL       IRMonitoring_CtrlSW
000064  706e              STRB     r6,[r5,#1]            ;211
000066  702f              STRB     r7,[r5,#0]            ;212
000068  f885a006          STRB     r10,[r5,#6]           ;213
                  |L3.108|
00006c  e12b              B        |L3.710|
00006e  2901              CMP      r1,#1                 ;216
000070  d10e              BNE      |L3.144|
000072  712e              STRB     r6,[r5,#4]            ;217
000074  ed840a00          VSTR     s0,[r4,#0]            ;219
000078  eddf0a97          VLDR     s1,|L3.728|
00007c  ee200a20          VMUL.F32 s0,s0,s1              ;220
000080  ed840a01          VSTR     s0,[r4,#4]            ;220
000084  f8d82018          LDR      r2,[r8,#0x18]         ;223  ; irm_event_cb
000088  b112              CBZ      r2,|L3.144|
00008a  78e8              LDRB     r0,[r5,#3]            ;223  ; irm_vstack_f
00008c  2801              CMP      r0,#1                 ;223
00008e  d009              BEQ      |L3.164|
                  |L3.144|
000090  2201              MOVS     r2,#1                 ;239
000092  2100              MOVS     r1,#0                 ;239
000094  4610              MOV      r0,r2                 ;239
000096  f7fffffe          BL       IRMonitoring_CtrlSW
00009a  706e              STRB     r6,[r5,#1]            ;240
00009c  702f              STRB     r7,[r5,#0]            ;241
00009e  2002              MOVS     r0,#2                 ;242
0000a0  71a8              STRB     r0,[r5,#6]            ;242
0000a2  e110              B        |L3.710|
                  |L3.164|
0000a4  70ee              STRB     r6,[r5,#3]            ;225
0000a6  ed8b0a01          VSTR     s0,[r11,#4]           ;232
0000aa  2102              MOVS     r1,#2                 ;233
0000ac  4887              LDR      r0,|L3.716|
0000ae  4790              BLX      r2                    ;233
0000b0  f7fffffe          BL       IRMonitoring_StateReset
0000b4  2003              MOVS     r0,#3                 ;235
                  |L3.182|
;;;380    			    if(sub_step_count >= irm_data.sw_delay_ms){
;;;381    						  sub_step_count = 0;
;;;382    					    irm_mes_step = IRM_DEVICE_WAITTING;   
;;;383    					}
;;;384    			    break;
;;;385    			case IRM_DEVICE_WAITTING:
;;;386              ++sub_step_count;
;;;387    					if(sub_step_count>IRM_READ_TIMEOUT){
;;;388    					    sub_step_count = 0;
;;;389                  return(IRM_STEP_READ_TIMEOUT);
;;;390    					}			
;;;391    					
;;;392    				  if(irm_event_cb.TriggerData_cb !=NULL){
;;;393    	           read_fun_res = irm_event_cb.TriggerData_cb();
;;;394    					   
;;;395    					   if(read_fun_res == IRM_OK){ 
;;;396    							   sub_step_count = 0;
;;;397    						     irm_mes_step = IRM_DATAREADY_WAITTING;   
;;;398    						 }
;;;399    		      }
;;;400    			    break;
;;;401    			case IRM_DATAREADY_WAITTING:
;;;402              ++sub_step_count;
;;;403    					if(sub_step_count>IRM_DATA_READY_TIMEOUT){
;;;404    					    sub_step_count = 0;
;;;405                  return(IRM_STEP_DATA_READY_TIMEOUT);
;;;406    					}			
;;;407    					
;;;408    				  if(irm_data_ready_f == 1){
;;;409    						  sub_step_count = 0;
;;;410    						  irm_mes_step = n_next_step;   
;;;411    		      }			
;;;412    			    break;
;;;413    			case IRM_FINISH:		
;;;414              break;						
;;;415    		}
;;;416    	  //-------------------------------------------------
;;;417    		
;;;418    		return(IRM_STEP_OK);
;;;419    }
0000b6  b009              ADD      sp,sp,#0x24
0000b8  ecbd8b02          VPOP     {d8}
0000bc  e8bd8ff0          POP      {r4-r11,pc}
0000c0  2901              CMP      r1,#1                 ;245
0000c2  d104              BNE      |L3.206|
0000c4  712e              STRB     r6,[r5,#4]            ;246
0000c6  ed840a02          VSTR     s0,[r4,#8]            ;248
0000ca  ed841a04          VSTR     s2,[r4,#0x10]         ;249
                  |L3.206|
0000ce  ed940a04          VLDR     s0,[r4,#0x10]         ;252
0000d2  ee300ac0          VSUB.F32 s0,s1,s0              ;252
0000d6  ed840a05          VSTR     s0,[r4,#0x14]         ;252
0000da  706e              STRB     r6,[r5,#1]            ;253
0000dc  702b              STRB     r3,[r5,#0]            ;254
0000de  e0f2              B        |L3.710|
0000e0  ee100a90          VMOV     r0,s1                 ;257
0000e4  f7fffffe          BL       __aeabi_f2d
0000e8  ed940a05          VLDR     s0,[r4,#0x14]         ;257
0000ec  edd40a04          VLDR     s1,[r4,#0x10]         ;257
0000f0  ec410b18          VMOV     d8,r0,r1              ;257
0000f4  ee300a60          VSUB.F32 s0,s0,s1              ;257
0000f8  ee100a10          VMOV     r0,s0                 ;257
0000fc  f7fffffe          BL       __aeabi_f2d
000100  ec410b10          VMOV     d0,r0,r1              ;257
000104  f7fffffe          BL       __hardfp_fabs
000108  ec532b18          VMOV     r2,r3,d8              ;257
00010c  ec510b10          VMOV     r0,r1,d0              ;257
000110  f7fffffe          BL       __aeabi_ddiv
000114  ed9f1b71          VLDR     d1,|L3.732|
000118  ec532b11          VMOV     r2,r3,d1              ;257
00011c  f7fffffe          BL       __aeabi_cdcmple
000120  d204              BCS      |L3.300|
000122  f885a001          STRB     r10,[r5,#1]           ;258
000126  2004              MOVS     r0,#4                 ;259
000128  7028              STRB     r0,[r5,#0]            ;259
00012a  e0cc              B        |L3.710|
                  |L3.300|
00012c  f885a001          STRB     r10,[r5,#1]           ;261
000130  f8859000          STRB     r9,[r5,#0]            ;262
000134  e0c7              B        |L3.710|
000136  2a01              CMP      r2,#1                 ;275
000138  d004              BEQ      |L3.324|
00013a  2a02              CMP      r2,#2                 ;275
00013c  d00e              BEQ      |L3.348|
00013e  2a03              CMP      r2,#3                 ;275
000140  d10b              BNE      |L3.346|
000142  e01a              B        |L3.378|
                  |L3.324|
000144  2100              MOVS     r1,#0                 ;277
000146  2201              MOVS     r2,#1                 ;277
000148  4608              MOV      r0,r1                 ;277
00014a  f7fffffe          BL       IRMonitoring_CtrlSW
00014e  702f              STRB     r7,[r5,#0]            ;278
000150  2004              MOVS     r0,#4                 ;279
000152  71a8              STRB     r0,[r5,#6]            ;279
000154  7868              LDRB     r0,[r5,#1]            ;280  ; irm_sub_step
000156  1c40              ADDS     r0,r0,#1              ;280
000158  7068              STRB     r0,[r5,#1]            ;280
                  |L3.346|
00015a  e0b4              B        |L3.710|
                  |L3.348|
00015c  2901              CMP      r1,#1                 ;283
00015e  d104              BNE      |L3.362|
000160  712e              STRB     r6,[r5,#4]            ;284
000162  ed840a06          VSTR     s0,[r4,#0x18]         ;285
000166  ed841a07          VSTR     s2,[r4,#0x1c]         ;286
                  |L3.362|
00016a  ed940a07          VLDR     s0,[r4,#0x1c]         ;289
00016e  ee300ac0          VSUB.F32 s0,s1,s0              ;289
000172  ed840a08          VSTR     s0,[r4,#0x20]         ;289
000176  706b              STRB     r3,[r5,#1]            ;290
000178  e0a5              B        |L3.710|
                  |L3.378|
00017a  2200              MOVS     r2,#0                 ;293
00017c  4611              MOV      r1,r2                 ;293
00017e  4610              MOV      r0,r2                 ;293
000180  f7fffffe          BL       IRMonitoring_CtrlSW
000184  2218              MOVS     r2,#0x18              ;307
000186  f8cdb018          STR      r11,[sp,#0x18]        ;307
00018a  4668              MOV      r0,sp                 ;307
00018c  9908              LDR      r1,[sp,#0x20]         ;307
00018e  f7fffffe          BL       __aeabi_memcpy4
000192  cc0f              LDM      r4!,{r0-r3}           ;307
000194  f7fffffe          BL       IRM_Balance_formula
000198  f8d82018          LDR      r2,[r8,#0x18]         ;310  ; irm_event_cb
00019c  b112              CBZ      r2,|L3.420|
00019e  2100              MOVS     r1,#0                 ;311
0001a0  484a              LDR      r0,|L3.716|
0001a2  4790              BLX      r2                    ;311
                  |L3.420|
0001a4  2009              MOVS     r0,#9                 ;314
0001a6  7028              STRB     r0,[r5,#0]            ;314
0001a8  e08d              B        |L3.710|
0001aa  2a06              CMP      r2,#6                 ;319
0001ac  d20f              BCS      |L3.462|
0001ae  e8dff002          TBB      [pc,r2]               ;319
0001b2  8a03              DCB      0x8a,0x03
0001b4  0f263249          DCB      0x0f,0x26,0x32,0x49
0001b8  2101              MOVS     r1,#1                 ;321
0001ba  2200              MOVS     r2,#0                 ;321
0001bc  4608              MOV      r0,r1                 ;321
0001be  f7fffffe          BL       IRMonitoring_CtrlSW
0001c2  702f              STRB     r7,[r5,#0]            ;322
0001c4  f8859006          STRB     r9,[r5,#6]            ;323
0001c8  7868              LDRB     r0,[r5,#1]            ;324  ; irm_sub_step
0001ca  1c40              ADDS     r0,r0,#1              ;324
0001cc  7068              STRB     r0,[r5,#1]            ;324
                  |L3.462|
0001ce  e07a              B        |L3.710|
0001d0  2901              CMP      r1,#1                 ;327
0001d2  d10c              BNE      |L3.494|
0001d4  712e              STRB     r6,[r5,#4]            ;328
0001d6  ed840a03          VSTR     s0,[r4,#0xc]          ;329
0001da  ed9f1a42          VLDR     s2,|L3.740|
0001de  ee200a01          VMUL.F32 s0,s0,s2              ;330
0001e2  eeb61a04          VMOV.F32 s2,#0.62500000        ;330
0001e6  ee000ac1          VMLS.F32 s0,s1,s2              ;330
0001ea  ed840a04          VSTR     s0,[r4,#0x10]         ;330
                  |L3.494|
0001ee  ed940a04          VLDR     s0,[r4,#0x10]         ;333
0001f2  ee300ac0          VSUB.F32 s0,s1,s0              ;333
0001f6  ed840a05          VSTR     s0,[r4,#0x14]         ;333
0001fa  706b              STRB     r3,[r5,#1]            ;334
0001fc  e063              B        |L3.710|
0001fe  2200              MOVS     r2,#0                 ;337
000200  2101              MOVS     r1,#1                 ;337
000202  4610              MOV      r0,r2                 ;337
000204  f7fffffe          BL       IRMonitoring_CtrlSW
000208  702f              STRB     r7,[r5,#0]            ;338
00020a  f8859006          STRB     r9,[r5,#6]            ;339
00020e  7868              LDRB     r0,[r5,#1]            ;340  ; irm_sub_step
000210  1c40              ADDS     r0,r0,#1              ;340
000212  7068              STRB     r0,[r5,#1]            ;340
000214  e057              B        |L3.710|
000216  2901              CMP      r1,#1                 ;343
000218  d108              BNE      |L3.556|
00021a  712e              STRB     r6,[r5,#4]            ;344
00021c  ed840a06          VSTR     s0,[r4,#0x18]         ;345
000220  ed9f1a31          VLDR     s2,|L3.744|
000224  ee200a01          VMUL.F32 s0,s0,s2              ;346
000228  ed840a07          VSTR     s0,[r4,#0x1c]         ;346
                  |L3.556|
00022c  ed940a07          VLDR     s0,[r4,#0x1c]         ;349
000230  ee300ac0          VSUB.F32 s0,s1,s0              ;349
000234  ed840a08          VSTR     s0,[r4,#0x20]         ;349
000238  f8859001          STRB     r9,[r5,#1]            ;350
00023c  e043              B        |L3.710|
00023e  e035              B        |L3.684|
000240  e021              B        |L3.646|
000242  e017              B        |L3.628|
000244  2200              MOVS     r2,#0                 ;353
000246  4611              MOV      r1,r2                 ;353
000248  4610              MOV      r0,r2                 ;353
00024a  f7fffffe          BL       IRMonitoring_CtrlSW
00024e  2218              MOVS     r2,#0x18              ;367
000250  f8cdb018          STR      r11,[sp,#0x18]        ;367
000254  4668              MOV      r0,sp                 ;367
000256  9908              LDR      r1,[sp,#0x20]         ;367
000258  f7fffffe          BL       __aeabi_memcpy4
00025c  cc0f              LDM      r4!,{r0-r3}           ;367
00025e  f7fffffe          BL       IRM_Unbalance_formula
000262  f8d82018          LDR      r2,[r8,#0x18]         ;370  ; irm_event_cb
000266  b112              CBZ      r2,|L3.622|
000268  2101              MOVS     r1,#1                 ;371
00026a  4818              LDR      r0,|L3.716|
00026c  4790              BLX      r2                    ;371
                  |L3.622|
00026e  2009              MOVS     r0,#9                 ;374
000270  7028              STRB     r0,[r5,#0]            ;374
000272  e028              B        |L3.710|
                  |L3.628|
000274  f8a5c00a          STRH     r12,[r5,#0xa]         ;379
000278  8ce0              LDRH     r0,[r4,#0x26]         ;380  ; irm_data
00027a  4560              CMP      r0,r12                ;380
00027c  d823              BHI      |L3.710|
00027e  816e              STRH     r6,[r5,#0xa]          ;381
000280  2007              MOVS     r0,#7                 ;382
000282  7028              STRB     r0,[r5,#0]            ;382
000284  e01f              B        |L3.710|
                  |L3.646|
000286  f8a5c00a          STRH     r12,[r5,#0xa]         ;386
00028a  f1bc0f0a          CMP      r12,#0xa              ;387
00028e  d902              BLS      |L3.662|
000290  816e              STRH     r6,[r5,#0xa]          ;388
000292  2001              MOVS     r0,#1                 ;389
000294  e70f              B        |L3.182|
                  |L3.662|
000296  f8d80014          LDR      r0,[r8,#0x14]         ;392  ; irm_event_cb
00029a  b1a0              CBZ      r0,|L3.710|
00029c  4780              BLX      r0                    ;393
00029e  7168              STRB     r0,[r5,#5]            ;393
0002a0  2801              CMP      r0,#1                 ;395
0002a2  d110              BNE      |L3.710|
0002a4  816e              STRH     r6,[r5,#0xa]          ;396
0002a6  2008              MOVS     r0,#8                 ;397
0002a8  7028              STRB     r0,[r5,#0]            ;397
0002aa  e00c              B        |L3.710|
                  |L3.684|
0002ac  f8a5c00a          STRH     r12,[r5,#0xa]         ;402
0002b0  f1bc0f05          CMP      r12,#5                ;403
0002b4  d902              BLS      |L3.700|
0002b6  816e              STRH     r6,[r5,#0xa]          ;404
0002b8  2002              MOVS     r0,#2                 ;405
0002ba  e6fc              B        |L3.182|
                  |L3.700|
0002bc  2901              CMP      r1,#1                 ;408
0002be  d102              BNE      |L3.710|
0002c0  816e              STRH     r6,[r5,#0xa]          ;409
0002c2  79a8              LDRB     r0,[r5,#6]            ;410  ; n_next_step
0002c4  7028              STRB     r0,[r5,#0]            ;410
                  |L3.710|
0002c6  2000              MOVS     r0,#0                 ;418
0002c8  e6f5              B        |L3.182|
;;;420    static void IRMonitoring_StateReset(void){
                          ENDP

0002ca  0000              DCW      0x0000
                  |L3.716|
                          DCD      ||.data||+0x40
                  |L3.720|
0002d0  43b65174          DCFS     0x43b65174 ; 364.6363525390625
                  |L3.724|
                          DCD      ||.bss||
                  |L3.728|
0002d8  44361174          DCFS     0x44361174 ; 728.272705078125
                  |L3.732|
0002dc  00000000          DCFD     0x3ff0000000000000 ; 1
0002e0  3ff00000
                  |L3.740|
0002e4  444cf3a2          DCFS     0x444cf3a2 ; 819.8067626953125
                  |L3.744|
0002e8  4413fa2f          DCFS     0x4413fa2f ; 591.90911865234375

                          AREA ||i.IRMonitoringSwTimerHandler||, CODE, READONLY, ALIGN=2

                  IRMonitoringSwTimerHandler PROC
;;;427    
;;;428    static void IRMonitoringSwTimerHandler(__far void *dest, uint16_t evt, void *vDataPtr)
000000  b570              PUSH     {r4-r6,lr}
;;;429    {
;;;430    	static IRMonitoring_step_ret_type res;
;;;431    	
;;;432    	#if 1
;;;433    	GPIOD->ODR ^= GPIO_PIN_13;
000002  481d              LDR      r0,|L4.120|
000004  6802              LDR      r2,[r0,#0]
000006  f4825200          EOR      r2,r2,#0x2000
00000a  6002              STR      r2,[r0,#0]
;;;434    	#endif 
;;;435    	
;;;436    	if(evt == LIB_SW_TIMER_EVT_SW_1MS)
00000c  2500              MOVS     r5,#0
;;;437    	{
;;;438          if(irm_flag ==1){
00000e  4c1b              LDR      r4,|L4.124|
000010  290a              CMP      r1,#0xa               ;436
000012  d014              BEQ      |L4.62|
;;;439              res =IRMonitoringMeasure_Steps(irm_mes_step);
;;;440          
;;;441    				  if((res == IRM_STEP_READ_TIMEOUT) || (res == IRM_STEP_DATA_READY_TIMEOUT)){
;;;442    					    IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_OFF, IRM_SW_OFF);
;;;443    						  irm_count = 0;
;;;444    			        irm_flag =0;            //end IR measure
;;;445    			        irm_mes_step=IRM_S1;    //reset step to start S1
;;;446    					}
;;;447    				
;;;448     				  if(irm_mes_step == IRM_FINISH){
;;;449    						  IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_OFF, IRM_SW_OFF);
;;;450    					    irm_flag = 0;
;;;451    					}
;;;452          }
;;;453    	}
;;;454    	else if(evt == LIB_SW_TIMER_EVT_SW_10MS_5)
000014  2905              CMP      r1,#5
000016  d111              BNE      |L4.60|
;;;455    	{	
;;;456    		irm_count++;
000018  8920              LDRH     r0,[r4,#8]  ; irm_count
00001a  1c40              ADDS     r0,r0,#1
00001c  b281              UXTH     r1,r0
00001e  8121              STRH     r1,[r4,#8]
;;;457    		if(irm_count >= irm_data.exe_interval_s*100)
000020  4817              LDR      r0,|L4.128|
000022  f8900024          LDRB     r0,[r0,#0x24]  ; irm_data
000026  eb0002c0          ADD      r2,r0,r0,LSL #3
00002a  eb021000          ADD      r0,r2,r0,LSL #4
00002e  ebb10f80          CMP      r1,r0,LSL #2
000032  d303              BCC      |L4.60|
;;;458    		{
;;;459    		    irm_count = 0;
000034  8125              STRH     r5,[r4,#8]
;;;460    			  irm_flag =1;            //start IR measure
000036  2001              MOVS     r0,#1
000038  70a0              STRB     r0,[r4,#2]
;;;461    			  irm_mes_step=IRM_S1;    //reset step to start S1
00003a  7025              STRB     r5,[r4,#0]
                  |L4.60|
;;;462    		}
;;;463    	}
;;;464    }
00003c  bd70              POP      {r4-r6,pc}
                  |L4.62|
00003e  78a0              LDRB     r0,[r4,#2]            ;438  ; irm_flag
000040  2801              CMP      r0,#1                 ;438
000042  d1fb              BNE      |L4.60|
000044  7820              LDRB     r0,[r4,#0]            ;439  ; irm_mes_step
000046  f7fffffe          BL       IRMonitoringMeasure_Steps
00004a  71e0              STRB     r0,[r4,#7]            ;439
00004c  2801              CMP      r0,#1                 ;441
00004e  d001              BEQ      |L4.84|
000050  2802              CMP      r0,#2                 ;441
000052  d107              BNE      |L4.100|
                  |L4.84|
000054  2200              MOVS     r2,#0                 ;442
000056  4611              MOV      r1,r2                 ;442
000058  4610              MOV      r0,r2                 ;442
00005a  f7fffffe          BL       IRMonitoring_CtrlSW
00005e  8125              STRH     r5,[r4,#8]            ;443
000060  70a5              STRB     r5,[r4,#2]            ;444
000062  7025              STRB     r5,[r4,#0]            ;445
                  |L4.100|
000064  7820              LDRB     r0,[r4,#0]            ;448  ; irm_mes_step
000066  2809              CMP      r0,#9                 ;448
000068  d1e8              BNE      |L4.60|
00006a  2200              MOVS     r2,#0                 ;449
00006c  4611              MOV      r1,r2                 ;449
00006e  4610              MOV      r0,r2                 ;449
000070  f7fffffe          BL       IRMonitoring_CtrlSW
000074  70a5              STRB     r5,[r4,#2]            ;450
000076  bd70              POP      {r4-r6,pc}
;;;465    
                          ENDP

                  |L4.120|
                          DCD      0x48000c14
                  |L4.124|
                          DCD      ||.data||
                  |L4.128|
                          DCD      ||.bss||

                          AREA ||i.IRMonitoring_CtrlSW||, CODE, READONLY, ALIGN=2

                  IRMonitoring_CtrlSW PROC
;;;133    
;;;134    static void IRMonitoring_CtrlSW(IRMonitoring_SW_enum sw1, IRMonitoring_SW_enum sw2, IRMonitoring_SW_enum sw3){
000000  b570              PUSH     {r4-r6,lr}
000002  460e              MOV      r6,r1
000004  4615              MOV      r5,r2
;;;135        
;;;136    	  if(irm_event_cb.SW_gpio_crtl_cb[0]!=NULL){
000006  4c11              LDR      r4,|L5.76|
000008  6863              LDR      r3,[r4,#4]  ; irm_event_cb
00000a  2b00              CMP      r3,#0
00000c  d003              BEQ      |L5.22|
;;;137    	      if(sw1 == IRM_SW_ON){
00000e  2801              CMP      r0,#1
000010  d010              BEQ      |L5.52|
;;;138    	          irm_event_cb.SW_gpio_crtl_cb[0](IRM_SW_ON);
;;;139    	      }else{
;;;140    		        irm_event_cb.SW_gpio_crtl_cb[0](IRM_SW_OFF);
000012  2000              MOVS     r0,#0
000014  4798              BLX      r3
                  |L5.22|
;;;141    		    }
;;;142    	  }
;;;143    
;;;144    	  if(irm_event_cb.SW_gpio_crtl_cb[1]!=NULL){
000016  68a3              LDR      r3,[r4,#8]  ; irm_event_cb
000018  b11b              CBZ      r3,|L5.34|
;;;145    	      if(sw2 == IRM_SW_ON){
00001a  2e01              CMP      r6,#1
00001c  d00d              BEQ      |L5.58|
;;;146    	          irm_event_cb.SW_gpio_crtl_cb[1](IRM_SW_ON);
;;;147    	      }else{
;;;148    		        irm_event_cb.SW_gpio_crtl_cb[1](IRM_SW_OFF);
00001e  2000              MOVS     r0,#0
000020  4798              BLX      r3
                  |L5.34|
;;;149    		    }
;;;150    	  }
;;;151    
;;;152    	  if(irm_event_cb.SW_gpio_crtl_cb[2]!=NULL){
000022  68e1              LDR      r1,[r4,#0xc]  ; irm_event_cb
000024  2900              CMP      r1,#0
000026  d00f              BEQ      |L5.72|
;;;153    	      if(sw3 == IRM_SW_ON){
000028  2d01              CMP      r5,#1
00002a  d009              BEQ      |L5.64|
;;;154    	          irm_event_cb.SW_gpio_crtl_cb[2](IRM_SW_ON);
;;;155    	      }else{
;;;156    		        irm_event_cb.SW_gpio_crtl_cb[2](IRM_SW_OFF);
00002c  e8bd4070          POP      {r4-r6,lr}
000030  2000              MOVS     r0,#0
000032  4708              BX       r1
                  |L5.52|
000034  2001              MOVS     r0,#1                 ;138
000036  4798              BLX      r3                    ;138
000038  e7ed              B        |L5.22|
                  |L5.58|
00003a  2001              MOVS     r0,#1                 ;146
00003c  4798              BLX      r3                    ;146
00003e  e7f0              B        |L5.34|
                  |L5.64|
000040  e8bd4070          POP      {r4-r6,lr}            ;154
000044  2001              MOVS     r0,#1                 ;154
000046  4708              BX       r1                    ;154
                  |L5.72|
;;;157    		    }
;;;158    	  }		
;;;159    
;;;160    }
000048  bd70              POP      {r4-r6,pc}
;;;161    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      ||.bss||+0x28

                          AREA ||i.IRMonitoring_Init||, CODE, READONLY, ALIGN=2

                  IRMonitoring_Init PROC
;;;77     }
;;;78     static uint8_t IRMonitoring_Init(uint8_t exe_interval_s, uint16_t sw_delay_ms, apiIRMonitoring_cb_t callbackfunc)
000000  b40f              PUSH     {r0-r3}
;;;79     {
000002  b510              PUSH     {r4,lr}
;;;80     		//IRM Paparmeter
;;;81     		irm_data.exe_interval_s  = exe_interval_s;
000004  4a20              LDR      r2,|L6.136|
000006  f8820024          STRB     r0,[r2,#0x24]
;;;82     		irm_data.sw_delay_ms     = sw_delay_ms;
00000a  84d1              STRH     r1,[r2,#0x26]
;;;83     	 
;;;84         if(callbackfunc.DataReady_cb==NULL){
00000c  980b              LDR      r0,[sp,#0x2c]
00000e  2800              CMP      r0,#0
000010  d02d              BEQ      |L6.110|
;;;85     		  return(0);
;;;86     		}	
;;;87     	
;;;88         if(callbackfunc.TriggerData_cb==NULL){
000012  9809              LDR      r0,[sp,#0x24]
000014  b368              CBZ      r0,|L6.114|
;;;89     		   return(0);
;;;90     		}else{
;;;91     		   irm_event_cb.TriggerData_cb = callbackfunc.TriggerData_cb;
000016  f1020428          ADD      r4,r2,#0x28
00001a  9809              LDR      r0,[sp,#0x24]
00001c  6160              STR      r0,[r4,#0x14]  ; irm_event_cb
00001e  9808              LDR      r0,[sp,#0x20]
000020  b348              CBZ      r0,|L6.118|
;;;92     		}			
;;;93     		
;;;94     	  if(callbackfunc.GetVoltDeviceInit_cb==NULL){
;;;95     	      return(0);
;;;96     	  }else{
;;;97     		    irm_event_cb.GetVoltDeviceInit_cb = callbackfunc.GetVoltDeviceInit_cb;
000022  9808              LDR      r0,[sp,#0x20]
000024  6120              STR      r0,[r4,#0x10]  ; irm_event_cb
;;;98     			   irm_event_cb.GetVoltDeviceInit_cb ();
000026  4780              BLX      r0
000028  980a              LDR      r0,[sp,#0x28]
00002a  b330              CBZ      r0,|L6.122|
;;;99     		}	
;;;100    			
;;;101        if(callbackfunc.irm_outdata==NULL){
;;;102            return(0);
;;;103    		}else{   
;;;104    		    irm_event_cb.irm_outdata = callbackfunc.irm_outdata;
00002c  980a              LDR      r0,[sp,#0x28]
00002e  61a0              STR      r0,[r4,#0x18]  ; irm_event_cb
000030  9804              LDR      r0,[sp,#0x10]
000032  b320              CBZ      r0,|L6.126|
;;;105    		}
;;;106        
;;;107        if(callbackfunc.SW_gpioinit_cb==NULL){
;;;108            return(0);
;;;109    		}else{   
;;;110    		    irm_event_cb.SW_gpioinit_cb  = callbackfunc.SW_gpioinit_cb;
000034  9804              LDR      r0,[sp,#0x10]
000036  6020              STR      r0,[r4,#0]  ; irm_event_cb
;;;111    		}
;;;112    
;;;113        for(int i=0; i<3 ; i++){		
000038  2000              MOVS     r0,#0
00003a  aa04              ADD      r2,sp,#0x10           ;84
                  |L6.60|
;;;114            if(callbackfunc.SW_gpio_crtl_cb[i]==NULL){
00003c  eb020180          ADD      r1,r2,r0,LSL #2
000040  6849              LDR      r1,[r1,#4]
000042  b1f1              CBZ      r1,|L6.130|
;;;115                return(0);
;;;116    		    }else{   
;;;117    		        irm_event_cb.SW_gpio_crtl_cb[i] = callbackfunc.SW_gpio_crtl_cb[i];
000044  eb040380          ADD      r3,r4,r0,LSL #2
000048  6059              STR      r1,[r3,#4]
00004a  1c40              ADDS     r0,r0,#1              ;113
00004c  2803              CMP      r0,#3                 ;113
00004e  dbf5              BLT      |L6.60|
;;;118    		    }
;;;119    	  }
;;;120    	
;;;121        //GPIO Init Callback function
;;;122    	  if(irm_event_cb.SW_gpioinit_cb!=NULL){
000050  6820              LDR      r0,[r4,#0]  ; irm_event_cb
000052  b100              CBZ      r0,|L6.86|
;;;123    		    irm_event_cb.SW_gpioinit_cb();
000054  4780              BLX      r0
                  |L6.86|
;;;124    		}
;;;125    		
;;;126    		// GPIO SW Init------------------------------------
;;;127    		IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_OFF ,IRM_SW_OFF);
000056  2200              MOVS     r2,#0
000058  4611              MOV      r1,r2
00005a  4610              MOV      r0,r2
00005c  f7fffffe          BL       IRMonitoring_CtrlSW
;;;128    		
;;;129    		callbackfunc.DataReady_cb(getIRMonitoringVoValue_cb);
000060  990b              LDR      r1,[sp,#0x2c]
000062  480a              LDR      r0,|L6.140|
000064  4788              BLX      r1
;;;130    		
;;;131        return(1);	
000066  2001              MOVS     r0,#1
                  |L6.104|
;;;132    }
000068  bc10              POP      {r4}
00006a  f85dfb14          LDR      pc,[sp],#0x14
                  |L6.110|
00006e  2000              MOVS     r0,#0                 ;85
000070  e7fa              B        |L6.104|
                  |L6.114|
000072  2000              MOVS     r0,#0                 ;89
000074  e7f8              B        |L6.104|
                  |L6.118|
000076  2000              MOVS     r0,#0                 ;95
000078  e7f6              B        |L6.104|
                  |L6.122|
00007a  2000              MOVS     r0,#0                 ;102
00007c  e7f4              B        |L6.104|
                  |L6.126|
00007e  2000              MOVS     r0,#0                 ;108
000080  e7f2              B        |L6.104|
                  |L6.130|
000082  2000              MOVS     r0,#0                 ;115
000084  e7f0              B        |L6.104|
;;;133    
                          ENDP

000086  0000              DCW      0x0000
                  |L6.136|
                          DCD      ||.bss||
                  |L6.140|
                          DCD      getIRMonitoringVoValue_cb

                          AREA ||i.IRMonitoring_StateReset||, CODE, READONLY, ALIGN=2

                  IRMonitoring_StateReset PROC
;;;419    }
;;;420    static void IRMonitoring_StateReset(void){
000000  4805              LDR      r0,|L7.24|
;;;421       irm_sub_step = 0;
000002  2100              MOVS     r1,#0
000004  7041              STRB     r1,[r0,#1]
;;;422       irm_mes_step = IRM_S1;  
000006  7001              STRB     r1,[r0,#0]
;;;423       irm_count = 0;
000008  8101              STRH     r1,[r0,#8]
;;;424       irm_flag = 0;   	
00000a  7081              STRB     r1,[r0,#2]
;;;425    	 IRMonitoring_CtrlSW(IRM_SW_OFF, IRM_SW_OFF ,IRM_SW_OFF); 
00000c  2200              MOVS     r2,#0
00000e  4611              MOV      r1,r2
000010  4610              MOV      r0,r2
000012  f7ffbffe          B.W      IRMonitoring_CtrlSW
;;;426    }
;;;427    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      ||.data||

                          AREA ||i.apiIRMonitoringGetResistor||, CODE, READONLY, ALIGN=2

                  apiIRMonitoringGetResistor PROC
;;;466    /* Public function prototypes -----------------------------------------------*/
;;;467    IRMonitoring_Resistor_t apiIRMonitoringGetResistor(void)
000000  4902              LDR      r1,|L8.12|
;;;468    {
;;;469        return irm_res_out;
000002  6c4a              LDR      r2,[r1,#0x44]  ; irm_res_out
000004  6c09              LDR      r1,[r1,#0x40]  ; irm_res_out
000006  c006              STM      r0!,{r1,r2}
;;;470    }
000008  4770              BX       lr
;;;471    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      ||.data||

                          AREA ||i.apiIRMonitoringGetVstack||, CODE, READONLY, ALIGN=2

                  apiIRMonitoringGetVstack PROC
;;;482    
;;;483    void apiIRMonitoringGetVstack(void){
000000  4802              LDR      r0,|L9.12|
;;;484        irm_vstack_f = 1;
000002  2101              MOVS     r1,#1
000004  70c1              STRB     r1,[r0,#3]
;;;485    	  irm_flag = 1;
000006  7081              STRB     r1,[r0,#2]
;;;486    }
000008  4770              BX       lr
;;;487    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      ||.data||

                          AREA ||i.apiIRMonitoringOpen||, CODE, READONLY, ALIGN=2

                  apiIRMonitoringOpen PROC
;;;471    
;;;472    uint8_t apiIRMonitoringOpen(uint8_t exe_interval_s, uint16_t sw_delay_ms, apiIRMonitoring_cb_t callbackfunc)
000000  b40f              PUSH     {r0-r3}
;;;473    {
000002  b530              PUSH     {r4,r5,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;474      uint8_t res;
;;;475    		
;;;476    	res = IRMonitoring_Init( exe_interval_s, sw_delay_ms, callbackfunc);
00000a  2218              MOVS     r2,#0x18
00000c  a90e              ADD      r1,sp,#0x38
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
000014  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       IRMonitoring_Init
000020  4604              MOV      r4,r0
;;;477    	
;;;478    	LibSwTimerOpen(IRMonitoringSwTimerHandler, 0);
000022  2100              MOVS     r1,#0
000024  4803              LDR      r0,|L10.52|
000026  f7fffffe          BL       LibSwTimerOpen
;;;479    
;;;480    	return(res);
;;;481    }
00002a  b007              ADD      sp,sp,#0x1c
00002c  4620              MOV      r0,r4                 ;480
00002e  bc30              POP      {r4,r5}
000030  f85dfb14          LDR      pc,[sp],#0x14
;;;482    
                          ENDP

                  |L10.52|
                          DCD      IRMonitoringSwTimerHandler

                          AREA ||i.getIRMonitoringVoValue_cb||, CODE, READONLY, ALIGN=2

                  getIRMonitoringVoValue_cb PROC
;;;72     /* Private function prototypes -----------------------------------------------*/
;;;73     static void getIRMonitoringVoValue_cb(float *read_volt_data)
000000  ed900a00          VLDR     s0,[r0,#0]
;;;74     {
;;;75     	  irm_adc_data = *read_volt_data;  //Get Voltage data
000004  4802              LDR      r0,|L11.16|
000006  ed800a0f          VSTR     s0,[r0,#0x3c]
;;;76     	  irm_data_ready_f = 1;	           //Setting data ready falg
00000a  2101              MOVS     r1,#1
00000c  7101              STRB     r1,[r0,#4]
;;;77     }
00000e  4770              BX       lr
;;;78     static uint8_t IRMonitoring_Init(uint8_t exe_interval_s, uint16_t sw_delay_ms, apiIRMonitoring_cb_t callbackfunc)
                          ENDP

                  |L11.16|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  irm_data
                          %        40
                  irm_event_cb
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  irm_mes_step
000000  00                DCB      0x00
                  irm_sub_step
000001  00                DCB      0x00
                  irm_flag
000002  01                DCB      0x01
                  irm_vstack_f
000003  00                DCB      0x00
                  irm_data_ready_f
000004  00                DCB      0x00
                  read_fun_res
000005  00                DCB      0x00
                  n_next_step
000006  00                DCB      0x00
                  ||res||
000007  00                DCB      0x00
                  irm_count
000008  0000              DCW      0x0000
                  sub_step_count
00000a  0000              DCW      0x0000
                  temp_rp
                          DCD      0x00000000
                  temp_rn
                          DCD      0x00000000
                  ||ra||
                          DCD      0x00000000
                  ||rb||
                          DCD      0x00000000
                  ||rc||
                          DCD      0x00000000
                  ||rd||
                          DCD      0x00000000
                  temp_a
                          DCD      0x00000000
                  temp_b
                          DCD      0x00000000
                  temp_c
                          DCD      0x00000000
                  temp_d
                          DCD      0x00000000
                  Ra_l
                          DCD      0x00000000
                  Rb_l
                          DCD      0x00000000
                  irm_adc_data
                          DCD      0x00000000
                  irm_res_out
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\API\\ApiIRMonitoring.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_ApiIRMonitoring_c_a7dd20f6____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___17_ApiIRMonitoring_c_a7dd20f6____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_ApiIRMonitoring_c_a7dd20f6____REVSH|
#line 507
|__asm___17_ApiIRMonitoring_c_a7dd20f6____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_ApiIRMonitoring_c_a7dd20f6____RRX|
#line 694
|__asm___17_ApiIRMonitoring_c_a7dd20f6____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
