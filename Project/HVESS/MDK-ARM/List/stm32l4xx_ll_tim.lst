L 1 "..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_ll_tim.c"
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_tim.c
N  * @author  MCD Application Team
N  * @brief   TIM LL module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 0L
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32l4xx_ll_tim.h"
S#include "stm32l4xx_ll_bus.h"
S
S#ifdef  USE_FULL_ASSERT
S#include "stm32_assert.h"
S#else
S#define assert_param(expr) ((void)0U)
S#endif /* USE_FULL_ASSERT */
S
S/** @addtogroup STM32L4xx_LL_Driver
S  * @{
S  */
S
S#if defined (TIM1) || defined (TIM8) || defined (TIM2) || defined (TIM3) ||  defined (TIM4) || defined (TIM5) || defined (TIM15) || defined (TIM16) || defined (TIM17) || defined (TIM6) || defined (TIM7)
S
S/** @addtogroup TIM_LL
S  * @{
S  */
S
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/* Private macros ------------------------------------------------------------*/
S/** @addtogroup TIM_LL_Private_Macros
S  * @{
S  */
S#define IS_LL_TIM_COUNTERMODE(__VALUE__) (((__VALUE__) == LL_TIM_COUNTERMODE_UP) \
S                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_DOWN) \
S                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP) \
S                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_DOWN) \
S                                          || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP_DOWN))
X#define IS_LL_TIM_COUNTERMODE(__VALUE__) (((__VALUE__) == LL_TIM_COUNTERMODE_UP)                                           || ((__VALUE__) == LL_TIM_COUNTERMODE_DOWN)                                           || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP)                                           || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_DOWN)                                           || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP_DOWN))
S
S#define IS_LL_TIM_CLOCKDIVISION(__VALUE__) (((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV1) \
S                                            || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV2) \
S                                            || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV4))
X#define IS_LL_TIM_CLOCKDIVISION(__VALUE__) (((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV1)                                             || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV2)                                             || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV4))
S
S#define IS_LL_TIM_OCMODE(__VALUE__) (((__VALUE__) == LL_TIM_OCMODE_FROZEN) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_ACTIVE) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_INACTIVE) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_TOGGLE) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_FORCED_INACTIVE) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_FORCED_ACTIVE) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_PWM1) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_PWM2) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM1) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM2) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM1) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM2) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM1) \
S                                     || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM2))
X#define IS_LL_TIM_OCMODE(__VALUE__) (((__VALUE__) == LL_TIM_OCMODE_FROZEN)                                      || ((__VALUE__) == LL_TIM_OCMODE_ACTIVE)                                      || ((__VALUE__) == LL_TIM_OCMODE_INACTIVE)                                      || ((__VALUE__) == LL_TIM_OCMODE_TOGGLE)                                      || ((__VALUE__) == LL_TIM_OCMODE_FORCED_INACTIVE)                                      || ((__VALUE__) == LL_TIM_OCMODE_FORCED_ACTIVE)                                      || ((__VALUE__) == LL_TIM_OCMODE_PWM1)                                      || ((__VALUE__) == LL_TIM_OCMODE_PWM2)                                      || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM1)                                      || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM2)                                      || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM1)                                      || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM2)                                      || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM1)                                      || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM2))
S
S#define IS_LL_TIM_OCSTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCSTATE_DISABLE) \
S                                      || ((__VALUE__) == LL_TIM_OCSTATE_ENABLE))
X#define IS_LL_TIM_OCSTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCSTATE_DISABLE)                                       || ((__VALUE__) == LL_TIM_OCSTATE_ENABLE))
S
S#define IS_LL_TIM_OCPOLARITY(__VALUE__) (((__VALUE__) == LL_TIM_OCPOLARITY_HIGH) \
S                                         || ((__VALUE__) == LL_TIM_OCPOLARITY_LOW))
X#define IS_LL_TIM_OCPOLARITY(__VALUE__) (((__VALUE__) == LL_TIM_OCPOLARITY_HIGH)                                          || ((__VALUE__) == LL_TIM_OCPOLARITY_LOW))
S
S#define IS_LL_TIM_OCIDLESTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCIDLESTATE_LOW) \
S                                          || ((__VALUE__) == LL_TIM_OCIDLESTATE_HIGH))
X#define IS_LL_TIM_OCIDLESTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCIDLESTATE_LOW)                                           || ((__VALUE__) == LL_TIM_OCIDLESTATE_HIGH))
S
S#define IS_LL_TIM_ACTIVEINPUT(__VALUE__) (((__VALUE__) == LL_TIM_ACTIVEINPUT_DIRECTTI) \
S                                          || ((__VALUE__) == LL_TIM_ACTIVEINPUT_INDIRECTTI) \
S                                          || ((__VALUE__) == LL_TIM_ACTIVEINPUT_TRC))
X#define IS_LL_TIM_ACTIVEINPUT(__VALUE__) (((__VALUE__) == LL_TIM_ACTIVEINPUT_DIRECTTI)                                           || ((__VALUE__) == LL_TIM_ACTIVEINPUT_INDIRECTTI)                                           || ((__VALUE__) == LL_TIM_ACTIVEINPUT_TRC))
S
S#define IS_LL_TIM_ICPSC(__VALUE__) (((__VALUE__) == LL_TIM_ICPSC_DIV1) \
S                                    || ((__VALUE__) == LL_TIM_ICPSC_DIV2) \
S                                    || ((__VALUE__) == LL_TIM_ICPSC_DIV4) \
S                                    || ((__VALUE__) == LL_TIM_ICPSC_DIV8))
X#define IS_LL_TIM_ICPSC(__VALUE__) (((__VALUE__) == LL_TIM_ICPSC_DIV1)                                     || ((__VALUE__) == LL_TIM_ICPSC_DIV2)                                     || ((__VALUE__) == LL_TIM_ICPSC_DIV4)                                     || ((__VALUE__) == LL_TIM_ICPSC_DIV8))
S
S#define IS_LL_TIM_IC_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_IC_FILTER_FDIV1) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N2) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N4) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N8) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N6) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N8) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N6) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N8) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N6) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N8) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N5) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N6) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N8) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N5) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N6) \
S                                        || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N8))
X#define IS_LL_TIM_IC_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_IC_FILTER_FDIV1)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N2)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N4)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N8)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N6)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N8)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N6)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N8)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N6)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N8)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N5)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N6)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N8)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N5)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N6)                                         || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N8))
S
S#define IS_LL_TIM_IC_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \
S                                          || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING) \
S                                          || ((__VALUE__) == LL_TIM_IC_POLARITY_BOTHEDGE))
X#define IS_LL_TIM_IC_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING)                                           || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING)                                           || ((__VALUE__) == LL_TIM_IC_POLARITY_BOTHEDGE))
S
S#define IS_LL_TIM_ENCODERMODE(__VALUE__) (((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI1) \
S                                          || ((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI2) \
S                                          || ((__VALUE__) == LL_TIM_ENCODERMODE_X4_TI12))
X#define IS_LL_TIM_ENCODERMODE(__VALUE__) (((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI1)                                           || ((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI2)                                           || ((__VALUE__) == LL_TIM_ENCODERMODE_X4_TI12))
S
S#define IS_LL_TIM_IC_POLARITY_ENCODER(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \
S                                                  || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING))
X#define IS_LL_TIM_IC_POLARITY_ENCODER(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING)                                                   || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING))
S
S#define IS_LL_TIM_OSSR_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSR_DISABLE) \
S                                         || ((__VALUE__) == LL_TIM_OSSR_ENABLE))
X#define IS_LL_TIM_OSSR_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSR_DISABLE)                                          || ((__VALUE__) == LL_TIM_OSSR_ENABLE))
S
S#define IS_LL_TIM_OSSI_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSI_DISABLE) \
S                                         || ((__VALUE__) == LL_TIM_OSSI_ENABLE))
X#define IS_LL_TIM_OSSI_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSI_DISABLE)                                          || ((__VALUE__) == LL_TIM_OSSI_ENABLE))
S
S#define IS_LL_TIM_LOCK_LEVEL(__VALUE__) (((__VALUE__) == LL_TIM_LOCKLEVEL_OFF) \
S                                         || ((__VALUE__) == LL_TIM_LOCKLEVEL_1)   \
S                                         || ((__VALUE__) == LL_TIM_LOCKLEVEL_2)   \
S                                         || ((__VALUE__) == LL_TIM_LOCKLEVEL_3))
X#define IS_LL_TIM_LOCK_LEVEL(__VALUE__) (((__VALUE__) == LL_TIM_LOCKLEVEL_OFF)                                          || ((__VALUE__) == LL_TIM_LOCKLEVEL_1)                                            || ((__VALUE__) == LL_TIM_LOCKLEVEL_2)                                            || ((__VALUE__) == LL_TIM_LOCKLEVEL_3))
S
S#define IS_LL_TIM_BREAK_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_DISABLE) \
S                                          || ((__VALUE__) == LL_TIM_BREAK_ENABLE))
X#define IS_LL_TIM_BREAK_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_DISABLE)                                           || ((__VALUE__) == LL_TIM_BREAK_ENABLE))
S
S#define IS_LL_TIM_BREAK_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_POLARITY_LOW) \
S                                             || ((__VALUE__) == LL_TIM_BREAK_POLARITY_HIGH))
X#define IS_LL_TIM_BREAK_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_POLARITY_LOW)                                              || ((__VALUE__) == LL_TIM_BREAK_POLARITY_HIGH))
S
S#define IS_LL_TIM_BREAK_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1)     \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N2)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N4)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N8)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N6)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N8)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N6)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N8)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N6)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N8)  \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N5) \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N6) \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N8) \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N5) \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N6) \
S                                           || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N8))
X#define IS_LL_TIM_BREAK_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1)                                                || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N2)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N4)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N8)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N6)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N8)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N6)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N8)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N6)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N8)                                             || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N5)                                            || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N6)                                            || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N8)                                            || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N5)                                            || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N6)                                            || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N8))
S
S#define IS_LL_TIM_BREAK2_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_DISABLE) \
S                                           || ((__VALUE__) == LL_TIM_BREAK2_ENABLE))
X#define IS_LL_TIM_BREAK2_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_DISABLE)                                            || ((__VALUE__) == LL_TIM_BREAK2_ENABLE))
S
S#define IS_LL_TIM_BREAK2_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_POLARITY_LOW) \
S                                              || ((__VALUE__) == LL_TIM_BREAK2_POLARITY_HIGH))
X#define IS_LL_TIM_BREAK2_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_POLARITY_LOW)                                               || ((__VALUE__) == LL_TIM_BREAK2_POLARITY_HIGH))
S
S#define IS_LL_TIM_BREAK2_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1)    \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N2)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N4)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N8)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N6)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N8)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N6)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N8)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N6)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N8)  \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N5) \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N6) \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N8) \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N5) \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N6) \
S                                            || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N8))
X#define IS_LL_TIM_BREAK2_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1)                                                || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N2)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N4)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N8)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N6)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N8)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N6)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N8)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N6)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N8)                                              || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N5)                                             || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N6)                                             || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N8)                                             || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N5)                                             || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N6)                                             || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N8))
S
S#define IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(__VALUE__) (((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_DISABLE) \
S                                                     || ((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_ENABLE))
X#define IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(__VALUE__) (((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_DISABLE)                                                      || ((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_ENABLE))
S/**
S  * @}
S  */
S
S
S/* Private function prototypes -----------------------------------------------*/
S/** @defgroup TIM_LL_Private_Functions TIM Private Functions
S  * @{
S  */
Sstatic ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
Sstatic ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
Sstatic ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
Sstatic ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
Sstatic ErrorStatus OC5Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
Sstatic ErrorStatus OC6Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
Sstatic ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
Sstatic ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
Sstatic ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
Sstatic ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
S/**
S  * @}
S  */
S
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup TIM_LL_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup TIM_LL_EF_Init
S  * @{
S  */
S
S/**
S  * @brief  Set TIMx registers to their reset values.
S  * @param  TIMx Timer instance
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: invalid TIMx instance
S  */
SErrorStatus LL_TIM_DeInit(TIM_TypeDef *TIMx)
S{
S  ErrorStatus result = SUCCESS;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_INSTANCE(TIMx));
S
S  if (TIMx == TIM1)
S  {
S    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM1);
S    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM1);
S  }
S  else if (TIMx == TIM2)
S  {
S    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM2);
S    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM2);
S  }
S#if defined(TIM3)
S  else if (TIMx == TIM3)
S  {
S    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM3);
S    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM3);
S  }
S#endif
S#if defined(TIM4)
S  else if (TIMx == TIM4)
S  {
S    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM4);
S    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM4);
S  }
S#endif
S#if defined(TIM5)
S  else if (TIMx == TIM5)
S  {
S    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM5);
S    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM5);
S  }
S#endif
S  else if (TIMx == TIM6)
S  {
S    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM6);
S    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM6);
S  }
S#if defined (TIM7)
S  else if (TIMx == TIM7)
S  {
S    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM7);
S    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM7);
S  }
S#endif
S#if defined(TIM8)
S  else if (TIMx == TIM8)
S  {
S    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM8);
S    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM8);
S  }
S#endif
S  else if (TIMx == TIM15)
S  {
S    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM15);
S    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM15);
S  }
S  else if (TIMx == TIM16)
S  {
S    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM16);
S    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM16);
S  }
S#if defined(TIM17)
S  else if (TIMx == TIM17)
S  {
S    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM17);
S    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM17);
S  }
S#endif
S  else
S  {
S    result = ERROR;
S  }
S
S  return result;
S}
S
S/**
S  * @brief  Set the fields of the time base unit configuration data structure
S  *         to their default values.
S  * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure (time base unit configuration data structure)
S  * @retval None
S  */
Svoid LL_TIM_StructInit(LL_TIM_InitTypeDef *TIM_InitStruct)
S{
S  /* Set the default configuration */
S  TIM_InitStruct->Prescaler         = (uint16_t)0x0000;
S  TIM_InitStruct->CounterMode       = LL_TIM_COUNTERMODE_UP;
S  TIM_InitStruct->Autoreload        = 0xFFFFFFFFU;
S  TIM_InitStruct->ClockDivision     = LL_TIM_CLOCKDIVISION_DIV1;
S  TIM_InitStruct->RepetitionCounter = 0x00000000U;
S}
S
S/**
S  * @brief  Configure the TIMx time base unit.
S  * @param  TIMx Timer Instance
S  * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure (TIMx time base unit configuration data structure)
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
SErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct)
S{
S  uint32_t tmpcr1;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
S  assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
S
S  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
S
S  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
S  {
S    /* Select the Counter Mode */
S    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
S  }
S
S  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
S  {
S    /* Set the clock division */
S    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
S  }
S
S  /* Write to TIMx CR1 */
S  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
S
S  /* Set the Autoreload value */
S  LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
S
S  /* Set the Prescaler value */
S  LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
S
S  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
S  {
S    /* Set the Repetition Counter value */
S    LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
S  }
S
S  /* Generate an update event to reload the Prescaler
S     and the repetition counter value (if applicable) immediately */
S  LL_TIM_GenerateEvent_UPDATE(TIMx);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Set the fields of the TIMx output channel configuration data
S  *         structure to their default values.
S  * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure (the output channel configuration data structure)
S  * @retval None
S  */
Svoid LL_TIM_OC_StructInit(LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
S{
S  /* Set the default configuration */
S  TIM_OC_InitStruct->OCMode       = LL_TIM_OCMODE_FROZEN;
S  TIM_OC_InitStruct->OCState      = LL_TIM_OCSTATE_DISABLE;
S  TIM_OC_InitStruct->OCNState     = LL_TIM_OCSTATE_DISABLE;
S  TIM_OC_InitStruct->CompareValue = 0x00000000U;
S  TIM_OC_InitStruct->OCPolarity   = LL_TIM_OCPOLARITY_HIGH;
S  TIM_OC_InitStruct->OCNPolarity  = LL_TIM_OCPOLARITY_HIGH;
S  TIM_OC_InitStruct->OCIdleState  = LL_TIM_OCIDLESTATE_LOW;
S  TIM_OC_InitStruct->OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
S}
S
S/**
S  * @brief  Configure the TIMx output channel.
S  * @param  TIMx Timer Instance
S  * @param  Channel This parameter can be one of the following values:
S  *         @arg @ref LL_TIM_CHANNEL_CH1
S  *         @arg @ref LL_TIM_CHANNEL_CH2
S  *         @arg @ref LL_TIM_CHANNEL_CH3
S  *         @arg @ref LL_TIM_CHANNEL_CH4
S  *         @arg @ref LL_TIM_CHANNEL_CH5
S  *         @arg @ref LL_TIM_CHANNEL_CH6
S  * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure (TIMx output channel configuration data structure)
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx output channel is initialized
S  *          - ERROR: TIMx output channel is not initialized
S  */
SErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
S{
S  ErrorStatus result = ERROR;
S
S  switch (Channel)
S  {
S    case LL_TIM_CHANNEL_CH1:
S      result = OC1Config(TIMx, TIM_OC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH2:
S      result = OC2Config(TIMx, TIM_OC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH3:
S      result = OC3Config(TIMx, TIM_OC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH4:
S      result = OC4Config(TIMx, TIM_OC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH5:
S      result = OC5Config(TIMx, TIM_OC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH6:
S      result = OC6Config(TIMx, TIM_OC_InitStruct);
S      break;
S    default:
S      break;
S  }
S
S  return result;
S}
S
S/**
S  * @brief  Set the fields of the TIMx input channel configuration data
S  *         structure to their default values.
S  * @param  TIM_ICInitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (the input channel configuration data structure)
S  * @retval None
S  */
Svoid LL_TIM_IC_StructInit(LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
S{
S  /* Set the default configuration */
S  TIM_ICInitStruct->ICPolarity    = LL_TIM_IC_POLARITY_RISING;
S  TIM_ICInitStruct->ICActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
S  TIM_ICInitStruct->ICPrescaler   = LL_TIM_ICPSC_DIV1;
S  TIM_ICInitStruct->ICFilter      = LL_TIM_IC_FILTER_FDIV1;
S}
S
S/**
S  * @brief  Configure the TIMx input channel.
S  * @param  TIMx Timer Instance
S  * @param  Channel This parameter can be one of the following values:
S  *         @arg @ref LL_TIM_CHANNEL_CH1
S  *         @arg @ref LL_TIM_CHANNEL_CH2
S  *         @arg @ref LL_TIM_CHANNEL_CH3
S  *         @arg @ref LL_TIM_CHANNEL_CH4
S  * @param  TIM_IC_InitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (TIMx input channel configuration data structure)
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx output channel is initialized
S  *          - ERROR: TIMx output channel is not initialized
S  */
SErrorStatus LL_TIM_IC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_IC_InitTypeDef *TIM_IC_InitStruct)
S{
S  ErrorStatus result = ERROR;
S
S  switch (Channel)
S  {
S    case LL_TIM_CHANNEL_CH1:
S      result = IC1Config(TIMx, TIM_IC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH2:
S      result = IC2Config(TIMx, TIM_IC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH3:
S      result = IC3Config(TIMx, TIM_IC_InitStruct);
S      break;
S    case LL_TIM_CHANNEL_CH4:
S      result = IC4Config(TIMx, TIM_IC_InitStruct);
S      break;
S    default:
S      break;
S  }
S
S  return result;
S}
S
S/**
S  * @brief  Fills each TIM_EncoderInitStruct field with its default value
S  * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (encoder interface configuration data structure)
S  * @retval None
S  */
Svoid LL_TIM_ENCODER_StructInit(LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
S{
S  /* Set the default configuration */
S  TIM_EncoderInitStruct->EncoderMode    = LL_TIM_ENCODERMODE_X2_TI1;
S  TIM_EncoderInitStruct->IC1Polarity    = LL_TIM_IC_POLARITY_RISING;
S  TIM_EncoderInitStruct->IC1ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
S  TIM_EncoderInitStruct->IC1Prescaler   = LL_TIM_ICPSC_DIV1;
S  TIM_EncoderInitStruct->IC1Filter      = LL_TIM_IC_FILTER_FDIV1;
S  TIM_EncoderInitStruct->IC2Polarity    = LL_TIM_IC_POLARITY_RISING;
S  TIM_EncoderInitStruct->IC2ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
S  TIM_EncoderInitStruct->IC2Prescaler   = LL_TIM_ICPSC_DIV1;
S  TIM_EncoderInitStruct->IC2Filter      = LL_TIM_IC_FILTER_FDIV1;
S}
S
S/**
S  * @brief  Configure the encoder interface of the timer instance.
S  * @param  TIMx Timer Instance
S  * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (TIMx encoder interface configuration data structure)
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
SErrorStatus LL_TIM_ENCODER_Init(TIM_TypeDef *TIMx, LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
S{
S  uint32_t tmpccmr1;
S  uint32_t tmpccer;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_ENCODERMODE(TIM_EncoderInitStruct->EncoderMode));
S  assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC1Polarity));
S  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC1ActiveInput));
S  assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC1Prescaler));
S  assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC1Filter));
S  assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC2Polarity));
S  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC2ActiveInput));
S  assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC2Prescaler));
S  assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC2Filter));
S
S  /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
S  TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
S
S  /* Get the TIMx CCMR1 register value */
S  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
S
S  /* Get the TIMx CCER register value */
S  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Configure TI1 */
S  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
S  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1ActiveInput >> 16U);
S  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Filter >> 16U);
S  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Prescaler >> 16U);
S
S  /* Configure TI2 */
S  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC2S | TIM_CCMR1_IC2F  | TIM_CCMR1_IC2PSC);
S  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2ActiveInput >> 8U);
S  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Filter >> 8U);
S  tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Prescaler >> 8U);
S
S  /* Set TI1 and TI2 polarity and enable TI1 and TI2 */
S  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
S  tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC1Polarity);
S  tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC2Polarity << 4U);
S  tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
S
S  /* Set encoder mode */
S  LL_TIM_SetEncoderMode(TIMx, TIM_EncoderInitStruct->EncoderMode);
S
S  /* Write to TIMx CCMR1 */
S  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Set the fields of the TIMx Hall sensor interface configuration data
S  *         structure to their default values.
S  * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (HALL sensor interface configuration data structure)
S  * @retval None
S  */
Svoid LL_TIM_HALLSENSOR_StructInit(LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
S{
S  /* Set the default configuration */
S  TIM_HallSensorInitStruct->IC1Polarity       = LL_TIM_IC_POLARITY_RISING;
S  TIM_HallSensorInitStruct->IC1Prescaler      = LL_TIM_ICPSC_DIV1;
S  TIM_HallSensorInitStruct->IC1Filter         = LL_TIM_IC_FILTER_FDIV1;
S  TIM_HallSensorInitStruct->CommutationDelay  = 0U;
S}
S
S/**
S  * @brief  Configure the Hall sensor interface of the timer instance.
S  * @note TIMx CH1, CH2 and CH3 inputs connected through a XOR
S  *       to the TI1 input channel
S  * @note TIMx slave mode controller is configured in reset mode.
S          Selected internal trigger is TI1F_ED.
S  * @note Channel 1 is configured as input, IC1 is mapped on TRC.
S  * @note Captured value stored in TIMx_CCR1 correspond to the time elapsed
S  *       between 2 changes on the inputs. It gives information about motor speed.
S  * @note Channel 2 is configured in output PWM 2 mode.
S  * @note Compare value stored in TIMx_CCR2 corresponds to the commutation delay.
S  * @note OC2REF is selected as trigger output on TRGO.
S  * @note LL_TIM_IC_POLARITY_BOTHEDGE must not be used for TI1 when it is used
S  *       when TIMx operates in Hall sensor interface mode.
S  * @param  TIMx Timer Instance
S  * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (TIMx HALL sensor interface configuration data structure)
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
SErrorStatus LL_TIM_HALLSENSOR_Init(TIM_TypeDef *TIMx, LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
S{
S  uint32_t tmpcr2;
S  uint32_t tmpccmr1;
S  uint32_t tmpccer;
S  uint32_t tmpsmcr;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_HallSensorInitStruct->IC1Polarity));
S  assert_param(IS_LL_TIM_ICPSC(TIM_HallSensorInitStruct->IC1Prescaler));
S  assert_param(IS_LL_TIM_IC_FILTER(TIM_HallSensorInitStruct->IC1Filter));
S
S  /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
S  TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
S
S  /* Get the TIMx CR2 register value */
S  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
S
S  /* Get the TIMx CCMR1 register value */
S  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
S
S  /* Get the TIMx CCER register value */
S  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Get the TIMx SMCR register value */
S  tmpsmcr = LL_TIM_ReadReg(TIMx, SMCR);
S
S  /* Connect TIMx_CH1, CH2 and CH3 pins to the TI1 input */
S  tmpcr2 |= TIM_CR2_TI1S;
S
S  /* OC2REF signal is used as trigger output (TRGO) */
S  tmpcr2 |= LL_TIM_TRGO_OC2REF;
S
S  /* Configure the slave mode controller */
S  tmpsmcr &= (uint32_t)~(TIM_SMCR_TS | TIM_SMCR_SMS);
S  tmpsmcr |= LL_TIM_TS_TI1F_ED;
S  tmpsmcr |= LL_TIM_SLAVEMODE_RESET;
S
S  /* Configure input channel 1 */
S  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
S  tmpccmr1 |= (uint32_t)(LL_TIM_ACTIVEINPUT_TRC >> 16U);
S  tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Filter >> 16U);
S  tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Prescaler >> 16U);
S
S  /* Configure input channel 2 */
S  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_OC2M | TIM_CCMR1_OC2FE  | TIM_CCMR1_OC2PE  | TIM_CCMR1_OC2CE);
S  tmpccmr1 |= (uint32_t)(LL_TIM_OCMODE_PWM2 << 8U);
S
S  /* Set Channel 1 polarity and enable Channel 1 and Channel2 */
S  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
S  tmpccer |= (uint32_t)(TIM_HallSensorInitStruct->IC1Polarity);
S  tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
S
S  /* Write to TIMx CR2 */
S  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
S
S  /* Write to TIMx SMCR */
S  LL_TIM_WriteReg(TIMx, SMCR, tmpsmcr);
S
S  /* Write to TIMx CCMR1 */
S  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  /* Write to TIMx CCR2 */
S  LL_TIM_OC_SetCompareCH2(TIMx, TIM_HallSensorInitStruct->CommutationDelay);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Set the fields of the Break and Dead Time configuration data structure
S  *         to their default values.
S  * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration data structure)
S  * @retval None
S  */
Svoid LL_TIM_BDTR_StructInit(LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
S{
S  /* Set the default configuration */
S  TIM_BDTRInitStruct->OSSRState       = LL_TIM_OSSR_DISABLE;
S  TIM_BDTRInitStruct->OSSIState       = LL_TIM_OSSI_DISABLE;
S  TIM_BDTRInitStruct->LockLevel       = LL_TIM_LOCKLEVEL_OFF;
S  TIM_BDTRInitStruct->DeadTime        = (uint8_t)0x00;
S  TIM_BDTRInitStruct->BreakState      = LL_TIM_BREAK_DISABLE;
S  TIM_BDTRInitStruct->BreakPolarity   = LL_TIM_BREAK_POLARITY_LOW;
S  TIM_BDTRInitStruct->BreakFilter     = LL_TIM_BREAK_FILTER_FDIV1;
S  TIM_BDTRInitStruct->Break2State     = LL_TIM_BREAK2_DISABLE;
S  TIM_BDTRInitStruct->Break2Polarity  = LL_TIM_BREAK2_POLARITY_LOW;
S  TIM_BDTRInitStruct->Break2Filter    = LL_TIM_BREAK2_FILTER_FDIV1;
S  TIM_BDTRInitStruct->AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
S}
S
S/**
S  * @brief  Configure the Break and Dead Time feature of the timer instance.
S  * @note As the bits BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR
S  *  and DTG[7:0] can be write-locked depending on the LOCK configuration, it
S  *  can be necessary to configure all of them during the first write access to
S  *  the TIMx_BDTR register.
S  * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
S  *       a timer instance provides a break input.
S  * @note Macro IS_TIM_BKIN2_INSTANCE(TIMx) can be used to check whether or not
S  *       a timer instance provides a second break input.
S  * @param  TIMx Timer Instance
S  * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration data structure)
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: Break and Dead Time is initialized
S  *          - ERROR: not applicable
S  */
SErrorStatus LL_TIM_BDTR_Init(TIM_TypeDef *TIMx, LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
S{
S  uint32_t tmpbdtr = 0;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_BREAK_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));
S  assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));
S  assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));
S  assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));
S  assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));
S  assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));
S
S  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
S  the OSSI State, the dead time value and the Automatic Output Enable Bit */
S
S  /* Set the BDTR bits */
S  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
S  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
S  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
S  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
S  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
S  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
S  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
S  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
S  if (IS_TIM_ADVANCED_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_BREAK_FILTER(TIM_BDTRInitStruct->BreakFilter));
S    MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, TIM_BDTRInitStruct->BreakFilter);
S  }
S
S  if (IS_TIM_BKIN2_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_BREAK2_STATE(TIM_BDTRInitStruct->Break2State));
S    assert_param(IS_LL_TIM_BREAK2_POLARITY(TIM_BDTRInitStruct->Break2Polarity));
S    assert_param(IS_LL_TIM_BREAK2_FILTER(TIM_BDTRInitStruct->Break2Filter));
S
S    /* Set the BREAK2 input related BDTR bit-fields */
S    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (TIM_BDTRInitStruct->Break2Filter));
S    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, TIM_BDTRInitStruct->Break2State);
S    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, TIM_BDTRInitStruct->Break2Polarity);
S  }
S
S  /* Set TIMx_BDTR */
S  LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
S
S  return SUCCESS;
S}
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/** @addtogroup TIM_LL_Private_Functions TIM Private Functions
S  *  @brief   Private functions
S  * @{
S  */
S/**
S  * @brief  Configure the TIMx output channel 1.
S  * @param  TIMx Timer Instance
S  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 1 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
S{
S  uint32_t tmpccmr1;
S  uint32_t tmpccer;
S  uint32_t tmpcr2;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
S
S  /* Disable the Channel 1: Reset the CC1E Bit */
S  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
S
S  /* Get the TIMx CCER register value */
S  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Get the TIMx CR2 register value */
S  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
S
S  /* Get the TIMx CCMR1 register value */
S  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
S
S  /* Reset Capture/Compare selection Bits */
S  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
S
S  /* Set the Output Compare Mode */
S  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
S
S  /* Set the Output Compare Polarity */
S  MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
S
S  /* Set the Output State */
S  MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
S
S  if (IS_TIM_BREAK_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
S
S    /* Set the complementary output Polarity */
S    MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
S
S    /* Set the complementary output State */
S    MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
S
S    /* Set the Output Idle state */
S    MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
S
S    /* Set the complementary output Idle state */
S    MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
S  }
S
S  /* Write to TIMx CR2 */
S  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
S
S  /* Write to TIMx CCMR1 */
S  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
S
S  /* Set the Capture Compare Register value */
S  LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx output channel 2.
S  * @param  TIMx Timer Instance
S  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
S{
S  uint32_t tmpccmr1;
S  uint32_t tmpccer;
S  uint32_t tmpcr2;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_CC2_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
S
S  /* Disable the Channel 2: Reset the CC2E Bit */
S  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
S
S  /* Get the TIMx CCER register value */
S  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Get the TIMx CR2 register value */
S  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
S
S  /* Get the TIMx CCMR1 register value */
S  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
S
S  /* Reset Capture/Compare selection Bits */
S  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
S
S  /* Select the Output Compare Mode */
S  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
S
S  /* Set the Output Compare Polarity */
S  MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
S
S  /* Set the Output State */
S  MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
S
S  if (IS_TIM_BREAK_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
S
S    /* Set the complementary output Polarity */
S    MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
S
S    /* Set the complementary output State */
S    MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
S
S    /* Set the Output Idle state */
S    MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
S
S    /* Set the complementary output Idle state */
S    MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
S  }
S
S  /* Write to TIMx CR2 */
S  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
S
S  /* Write to TIMx CCMR1 */
S  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
S
S  /* Set the Capture Compare Register value */
S  LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx output channel 3.
S  * @param  TIMx Timer Instance
S  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
S{
S  uint32_t tmpccmr2;
S  uint32_t tmpccer;
S  uint32_t tmpcr2;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_CC3_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
S
S  /* Disable the Channel 3: Reset the CC3E Bit */
S  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
S
S  /* Get the TIMx CCER register value */
S  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Get the TIMx CR2 register value */
S  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
S
S  /* Get the TIMx CCMR2 register value */
S  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
S
S  /* Reset Capture/Compare selection Bits */
S  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
S
S  /* Select the Output Compare Mode */
S  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
S
S  /* Set the Output Compare Polarity */
S  MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
S
S  /* Set the Output State */
S  MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
S
S  if (IS_TIM_BREAK_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
S
S    /* Set the complementary output Polarity */
S    MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
S
S    /* Set the complementary output State */
S    MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
S
S    /* Set the Output Idle state */
S    MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
S
S    /* Set the complementary output Idle state */
S    MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
S  }
S
S  /* Write to TIMx CR2 */
S  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
S
S  /* Write to TIMx CCMR2 */
S  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
S
S  /* Set the Capture Compare Register value */
S  LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx output channel 4.
S  * @param  TIMx Timer Instance
S  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
S{
S  uint32_t tmpccmr2;
S  uint32_t tmpccer;
S  uint32_t tmpcr2;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_CC4_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
S
S  /* Disable the Channel 4: Reset the CC4E Bit */
S  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
S
S  /* Get the TIMx CCER register value */
S  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Get the TIMx CR2 register value */
S  tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
S
S  /* Get the TIMx CCMR2 register value */
S  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
S
S  /* Reset Capture/Compare selection Bits */
S  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
S
S  /* Select the Output Compare Mode */
S  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
S
S  /* Set the Output Compare Polarity */
S  MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
S
S  /* Set the Output State */
S  MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
S
S  if (IS_TIM_BREAK_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
S
S    /* Set the Output Idle state */
S    MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
S  }
S
S  /* Write to TIMx CR2 */
S  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
S
S  /* Write to TIMx CCMR2 */
S  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
S
S  /* Set the Capture Compare Register value */
S  LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx output channel 5.
S  * @param  TIMx Timer Instance
S  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 5 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus OC5Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
S{
S  uint32_t tmpccmr3;
S  uint32_t tmpccer;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_CC5_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
S
S  /* Disable the Channel 5: Reset the CC5E Bit */
S  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC5E);
S
S  /* Get the TIMx CCER register value */
S  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Get the TIMx CCMR3 register value */
S  tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
S
S  /* Select the Output Compare Mode */
S  MODIFY_REG(tmpccmr3, TIM_CCMR3_OC5M, TIM_OCInitStruct->OCMode);
S
S  /* Set the Output Compare Polarity */
S  MODIFY_REG(tmpccer, TIM_CCER_CC5P, TIM_OCInitStruct->OCPolarity << 16U);
S
S  /* Set the Output State */
S  MODIFY_REG(tmpccer, TIM_CCER_CC5E, TIM_OCInitStruct->OCState << 16U);
S
S  if (IS_TIM_BREAK_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
S
S    /* Set the Output Idle state */
S    MODIFY_REG(TIMx->CR2, TIM_CR2_OIS5, TIM_OCInitStruct->OCIdleState << 8U);
S
S  }
S
S  /* Write to TIMx CCMR3 */
S  LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
S
S  /* Set the Capture Compare Register value */
S  LL_TIM_OC_SetCompareCH5(TIMx, TIM_OCInitStruct->CompareValue);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx output channel 6.
S  * @param  TIMx Timer Instance
S  * @param  TIM_OCInitStruct pointer to the the TIMx output channel 6 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus OC6Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
S{
S  uint32_t tmpccmr3;
S  uint32_t tmpccer;
S
S  /* Check the parameters */
S  assert_param(IS_TIM_CC6_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
S  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
S  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
S
S  /* Disable the Channel 5: Reset the CC6E Bit */
S  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC6E);
S
S  /* Get the TIMx CCER register value */
S  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
S
S  /* Get the TIMx CCMR3 register value */
S  tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
S
S  /* Select the Output Compare Mode */
S  MODIFY_REG(tmpccmr3, TIM_CCMR3_OC6M, TIM_OCInitStruct->OCMode << 8U);
S
S  /* Set the Output Compare Polarity */
S  MODIFY_REG(tmpccer, TIM_CCER_CC6P, TIM_OCInitStruct->OCPolarity << 20U);
S
S  /* Set the Output State */
S  MODIFY_REG(tmpccer, TIM_CCER_CC6E, TIM_OCInitStruct->OCState << 20U);
S
S  if (IS_TIM_BREAK_INSTANCE(TIMx))
S  {
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
S    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
S
S    /* Set the Output Idle state */
S    MODIFY_REG(TIMx->CR2, TIM_CR2_OIS6, TIM_OCInitStruct->OCIdleState << 10U);
S  }
S
S  /* Write to TIMx CCMR3 */
S  LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
S
S  /* Set the Capture Compare Register value */
S  LL_TIM_OC_SetCompareCH6(TIMx, TIM_OCInitStruct->CompareValue);
S
S  /* Write to TIMx CCER */
S  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx input channel 1.
S  * @param  TIMx Timer Instance
S  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 1 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
S{
S  /* Check the parameters */
S  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
S  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
S  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
S  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
S
S  /* Disable the Channel 1: Reset the CC1E Bit */
S  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
S
S  /* Select the Input and set the filter and the prescaler value */
S  MODIFY_REG(TIMx->CCMR1,
S             (TIM_CCMR1_CC1S | TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC),
S             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
S
S  /* Select the Polarity and set the CC1E Bit */
S  MODIFY_REG(TIMx->CCER,
S             (TIM_CCER_CC1P | TIM_CCER_CC1NP),
S             (TIM_ICInitStruct->ICPolarity | TIM_CCER_CC1E));
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx input channel 2.
S  * @param  TIMx Timer Instance
S  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 2 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
S{
S  /* Check the parameters */
S  assert_param(IS_TIM_CC2_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
S  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
S  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
S  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
S
S  /* Disable the Channel 2: Reset the CC2E Bit */
S  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
S
S  /* Select the Input and set the filter and the prescaler value */
S  MODIFY_REG(TIMx->CCMR1,
S             (TIM_CCMR1_CC2S | TIM_CCMR1_IC2F | TIM_CCMR1_IC2PSC),
S             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
S
S  /* Select the Polarity and set the CC2E Bit */
S  MODIFY_REG(TIMx->CCER,
S             (TIM_CCER_CC2P | TIM_CCER_CC2NP),
S             ((TIM_ICInitStruct->ICPolarity << 4U) | TIM_CCER_CC2E));
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx input channel 3.
S  * @param  TIMx Timer Instance
S  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 3 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
S{
S  /* Check the parameters */
S  assert_param(IS_TIM_CC3_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
S  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
S  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
S  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
S
S  /* Disable the Channel 3: Reset the CC3E Bit */
S  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
S
S  /* Select the Input and set the filter and the prescaler value */
S  MODIFY_REG(TIMx->CCMR2,
S             (TIM_CCMR2_CC3S | TIM_CCMR2_IC3F | TIM_CCMR2_IC3PSC),
S             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
S
S  /* Select the Polarity and set the CC3E Bit */
S  MODIFY_REG(TIMx->CCER,
S             (TIM_CCER_CC3P | TIM_CCER_CC3NP),
S             ((TIM_ICInitStruct->ICPolarity << 8U) | TIM_CCER_CC3E));
S
S  return SUCCESS;
S}
S
S/**
S  * @brief  Configure the TIMx input channel 4.
S  * @param  TIMx Timer Instance
S  * @param  TIM_ICInitStruct pointer to the the TIMx input channel 4 configuration data structure
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: TIMx registers are de-initialized
S  *          - ERROR: not applicable
S  */
Sstatic ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
S{
S  /* Check the parameters */
S  assert_param(IS_TIM_CC4_INSTANCE(TIMx));
S  assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
S  assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
S  assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
S  assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
S
S  /* Disable the Channel 4: Reset the CC4E Bit */
S  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
S
S  /* Select the Input and set the filter and the prescaler value */
S  MODIFY_REG(TIMx->CCMR2,
S             (TIM_CCMR2_CC4S | TIM_CCMR2_IC4F | TIM_CCMR2_IC4PSC),
S             (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
S
S  /* Select the Polarity and set the CC2E Bit */
S  MODIFY_REG(TIMx->CCER,
S             (TIM_CCER_CC4P | TIM_CCER_CC4NP),
S             ((TIM_ICInitStruct->ICPolarity << 12U) | TIM_CCER_CC4E));
S
S  return SUCCESS;
S}
S
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S#endif /* TIM1 || TIM8 || TIM2 || TIM3 ||  TIM4 || TIM5 || TIM15 || TIM16 || TIM17 || TIM6 || TIM7 */
S
S/**
S  * @}
S  */
S
N#endif /* USE_FULL_LL_DRIVER */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
