; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_spi.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_spi.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_spi.c]
                          THUMB

                          AREA ||i.HAL_SPI_Abort||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort PROC
;;;2313     */
;;;2314   HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;2315   {
000004  4604              MOV      r4,r0
;;;2316     HAL_StatusTypeDef errorcode;
;;;2317     __IO uint32_t count;
;;;2318     __IO uint32_t resetcount;
;;;2319   
;;;2320     /* Initialized local variable  */
;;;2321     errorcode = HAL_OK;
000006  2500              MOVS     r5,#0
;;;2322     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000008  4857              LDR      r0,|L1.360|
00000a  f64551c0          MOV      r1,#0x5dc0
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  fbb0f0f1          UDIV     r0,r0,r1
000014  2164              MOVS     r1,#0x64
000016  4348              MULS     r0,r1,r0
000018  9001              STR      r0,[sp,#4]
;;;2323     count = resetcount;
00001a  9801              LDR      r0,[sp,#4]
00001c  9002              STR      r0,[sp,#8]
;;;2324   
;;;2325     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2326     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
00001e  6820              LDR      r0,[r4,#0]
000020  6841              LDR      r1,[r0,#4]
000022  f0210120          BIC      r1,r1,#0x20
000026  6041              STR      r1,[r0,#4]
;;;2327   
;;;2328     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;2329     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
000028  6821              LDR      r1,[r4,#0]
00002a  6848              LDR      r0,[r1,#4]
00002c  0600              LSLS     r0,r0,#24
00002e  d50d              BPL      |L1.76|
;;;2330     {
;;;2331       hspi->TxISR = SPI_AbortTx_ISR;
000030  484e              LDR      r0,|L1.364|
000032  6520              STR      r0,[r4,#0x50]
                  |L1.52|
;;;2332       /* Wait HAL_SPI_STATE_ABORT state */
;;;2333       do
;;;2334       {
;;;2335         if (count == 0U)
000034  9802              LDR      r0,[sp,#8]
000036  2800              CMP      r0,#0
000038  d07e              BEQ      |L1.312|
;;;2336         {
;;;2337           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2338           break;
;;;2339         }
;;;2340         count--;
00003a  9802              LDR      r0,[sp,#8]
00003c  1e40              SUBS     r0,r0,#1
00003e  9002              STR      r0,[sp,#8]
;;;2341       } while (hspi->State != HAL_SPI_STATE_ABORT);
000040  f894005d          LDRB     r0,[r4,#0x5d]
000044  2807              CMP      r0,#7
000046  d1f5              BNE      |L1.52|
                  |L1.72|
;;;2342       /* Reset Timeout Counter */
;;;2343       count = resetcount;
000048  9801              LDR      r0,[sp,#4]
00004a  9002              STR      r0,[sp,#8]
                  |L1.76|
;;;2344     }
;;;2345   
;;;2346     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
00004c  6848              LDR      r0,[r1,#4]
00004e  0640              LSLS     r0,r0,#25
000050  d50d              BPL      |L1.110|
;;;2347     {
;;;2348       hspi->RxISR = SPI_AbortRx_ISR;
000052  4847              LDR      r0,|L1.368|
000054  64e0              STR      r0,[r4,#0x4c]
                  |L1.86|
;;;2349       /* Wait HAL_SPI_STATE_ABORT state */
;;;2350       do
;;;2351       {
;;;2352         if (count == 0U)
000056  9802              LDR      r0,[sp,#8]
000058  2800              CMP      r0,#0
00005a  d07e              BEQ      |L1.346|
;;;2353         {
;;;2354           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2355           break;
;;;2356         }
;;;2357         count--;
00005c  9802              LDR      r0,[sp,#8]
00005e  1e40              SUBS     r0,r0,#1
000060  9002              STR      r0,[sp,#8]
;;;2358       } while (hspi->State != HAL_SPI_STATE_ABORT);
000062  f894005d          LDRB     r0,[r4,#0x5d]
000066  2807              CMP      r0,#7
000068  d1f5              BNE      |L1.86|
                  |L1.106|
;;;2359       /* Reset Timeout Counter */
;;;2360       count = resetcount;
00006a  9801              LDR      r0,[sp,#4]
00006c  9002              STR      r0,[sp,#8]
                  |L1.110|
;;;2361     }
;;;2362   
;;;2363     /* Disable the SPI DMA Tx request if enabled */
;;;2364     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
00006e  6848              LDR      r0,[r1,#4]
;;;2365     {
;;;2366       /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2367       if (hspi->hdmatx != NULL)
;;;2368       {
;;;2369         /* Set the SPI DMA Abort callback :
;;;2370         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2371         hspi->hdmatx->XferAbortCallback = NULL;
;;;2372   
;;;2373         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2374         if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
;;;2375         {
;;;2376           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
;;;2377         }
;;;2378   
;;;2379         /* Disable Tx DMA Request */
;;;2380         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
;;;2381   
;;;2382         if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
;;;2383         {
;;;2384           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
;;;2385         }
;;;2386   
;;;2387         /* Disable SPI Peripheral */
;;;2388         __HAL_SPI_DISABLE(hspi);
;;;2389   
;;;2390         /* Empty the FRLVL fifo */
;;;2391         if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000070  f44f68c0          MOV      r8,#0x600
000074  0780              LSLS     r0,r0,#30             ;2364
000076  f04f0640          MOV      r6,#0x40              ;2376
00007a  f04f0700          MOV      r7,#0                 ;2376
00007e  d525              BPL      |L1.204|
000080  6d60              LDR      r0,[r4,#0x54]         ;2367
000082  b318              CBZ      r0,|L1.204|
000084  6387              STR      r7,[r0,#0x38]         ;2371
000086  6d60              LDR      r0,[r4,#0x54]         ;2374
000088  f7fffffe          BL       HAL_DMA_Abort
00008c  b100              CBZ      r0,|L1.144|
00008e  6626              STR      r6,[r4,#0x60]         ;2376
                  |L1.144|
000090  6820              LDR      r0,[r4,#0]            ;2380
000092  6841              LDR      r1,[r0,#4]            ;2380
000094  f0210102          BIC      r1,r1,#2              ;2380
000098  6041              STR      r1,[r0,#4]            ;2380
00009a  f7fffffe          BL       HAL_GetTick
00009e  4602              MOV      r2,r0                 ;2382
0000a0  2164              MOVS     r1,#0x64              ;2382
0000a2  4620              MOV      r0,r4                 ;2382
0000a4  f7fffffe          BL       SPI_EndRxTxTransaction
0000a8  b100              CBZ      r0,|L1.172|
0000aa  6626              STR      r6,[r4,#0x60]         ;2384
                  |L1.172|
0000ac  6820              LDR      r0,[r4,#0]            ;2388
0000ae  6801              LDR      r1,[r0,#0]            ;2388
0000b0  f0210140          BIC      r1,r1,#0x40           ;2388
0000b4  6001              STR      r1,[r0,#0]            ;2388
0000b6  f7fffffe          BL       HAL_GetTick
0000ba  9000              STR      r0,[sp,#0]
0000bc  2364              MOVS     r3,#0x64
0000be  2200              MOVS     r2,#0
0000c0  4641              MOV      r1,r8
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
0000c8  b100              CBZ      r0,|L1.204|
;;;2392         {
;;;2393           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000ca  6626              STR      r6,[r4,#0x60]
                  |L1.204|
;;;2394         }
;;;2395       }
;;;2396     }
;;;2397   
;;;2398     /* Disable the SPI DMA Rx request if enabled */
;;;2399     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000cc  6820              LDR      r0,[r4,#0]
0000ce  6840              LDR      r0,[r0,#4]
0000d0  07c0              LSLS     r0,r0,#31
0000d2  d027              BEQ      |L1.292|
;;;2400     {
;;;2401       /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2402       if (hspi->hdmarx != NULL)
0000d4  6da0              LDR      r0,[r4,#0x58]
0000d6  b328              CBZ      r0,|L1.292|
;;;2403       {
;;;2404         /* Set the SPI DMA Abort callback :
;;;2405         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2406         hspi->hdmarx->XferAbortCallback = NULL;
0000d8  6387              STR      r7,[r0,#0x38]
;;;2407   
;;;2408         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2409         if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
0000da  6da0              LDR      r0,[r4,#0x58]
0000dc  f7fffffe          BL       HAL_DMA_Abort
0000e0  b100              CBZ      r0,|L1.228|
;;;2410         {
;;;2411           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000e2  6626              STR      r6,[r4,#0x60]
                  |L1.228|
;;;2412         }
;;;2413   
;;;2414         /* Disable peripheral */
;;;2415         __HAL_SPI_DISABLE(hspi);
0000e4  6820              LDR      r0,[r4,#0]
0000e6  6801              LDR      r1,[r0,#0]
0000e8  f0210140          BIC      r1,r1,#0x40
0000ec  6001              STR      r1,[r0,#0]
;;;2416   
;;;2417         /* Control the BSY flag */
;;;2418         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
0000ee  f7fffffe          BL       HAL_GetTick
0000f2  9000              STR      r0,[sp,#0]
0000f4  2364              MOVS     r3,#0x64
0000f6  2200              MOVS     r2,#0
0000f8  2180              MOVS     r1,#0x80
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000100  b100              CBZ      r0,|L1.260|
;;;2419         {
;;;2420           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000102  6626              STR      r6,[r4,#0x60]
                  |L1.260|
;;;2421         }
;;;2422   
;;;2423         /* Empty the FRLVL fifo */
;;;2424         if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000104  f7fffffe          BL       HAL_GetTick
000108  9000              STR      r0,[sp,#0]
00010a  2364              MOVS     r3,#0x64
00010c  2200              MOVS     r2,#0
00010e  4641              MOV      r1,r8
000110  4620              MOV      r0,r4
000112  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
000116  b100              CBZ      r0,|L1.282|
;;;2425         {
;;;2426           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000118  6626              STR      r6,[r4,#0x60]
                  |L1.282|
;;;2427         }
;;;2428   
;;;2429         /* Disable Rx DMA Request */
;;;2430         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
00011a  6820              LDR      r0,[r4,#0]
00011c  6841              LDR      r1,[r0,#4]
00011e  f0210101          BIC      r1,r1,#1
000122  6041              STR      r1,[r0,#4]
                  |L1.292|
;;;2431       }
;;;2432     }
;;;2433     /* Reset Tx and Rx transfer counters */
;;;2434     hspi->RxXferCount = 0U;
000124  f8a47046          STRH     r7,[r4,#0x46]
;;;2435     hspi->TxXferCount = 0U;
000128  87e7              STRH     r7,[r4,#0x3e]
;;;2436   
;;;2437     /* Check error during Abort procedure */
;;;2438     if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
00012a  6e20              LDR      r0,[r4,#0x60]
00012c  2840              CMP      r0,#0x40
00012e  d019              BEQ      |L1.356|
;;;2439     {
;;;2440       /* return HAL_Error in case of error during Abort procedure */
;;;2441       errorcode = HAL_ERROR;
;;;2442     }
;;;2443     else
;;;2444     {
;;;2445       /* Reset errorCode */
;;;2446       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000130  6627              STR      r7,[r4,#0x60]
                  |L1.306|
;;;2447     }
;;;2448   
;;;2449     /* Clear the Error flags in the SR register */
;;;2450     __HAL_SPI_CLEAR_OVRFLAG(hspi);
000132  6820              LDR      r0,[r4,#0]
000134  68c1              LDR      r1,[r0,#0xc]
000136  e001              B        |L1.316|
                  |L1.312|
000138  e00a              B        |L1.336|
00013a  e00e              B        |L1.346|
                  |L1.316|
00013c  6881              LDR      r1,[r0,#8]
00013e  9100              STR      r1,[sp,#0]
;;;2451     __HAL_SPI_CLEAR_FREFLAG(hspi);
000140  6880              LDR      r0,[r0,#8]
000142  9000              STR      r0,[sp,#0]
;;;2452   
;;;2453     /* Restore hspi->state to ready */
;;;2454     hspi->State = HAL_SPI_STATE_READY;
000144  2001              MOVS     r0,#1
000146  f884005d          STRB     r0,[r4,#0x5d]
;;;2455   
;;;2456     return errorcode;
00014a  4628              MOV      r0,r5
;;;2457   }
00014c  e8bd83fe          POP      {r1-r9,pc}
                  |L1.336|
000150  6e20              LDR      r0,[r4,#0x60]         ;2337
000152  f0400040          ORR      r0,r0,#0x40           ;2337
000156  6620              STR      r0,[r4,#0x60]         ;2337
000158  e776              B        |L1.72|
                  |L1.346|
00015a  6e20              LDR      r0,[r4,#0x60]         ;2354
00015c  f0400040          ORR      r0,r0,#0x40           ;2354
000160  6620              STR      r0,[r4,#0x60]         ;2354
000162  e782              B        |L1.106|
                  |L1.356|
000164  2501              MOVS     r5,#1                 ;2441
000166  e7e4              B        |L1.306|
;;;2458   
                          ENDP

                  |L1.360|
                          DCD      SystemCoreClock
                  |L1.364|
                          DCD      SPI_AbortTx_ISR
                  |L1.368|
                          DCD      SPI_AbortRx_ISR

                          AREA ||i.HAL_SPI_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_AbortCpltCallback PROC
;;;2935     */
;;;2936   __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2937   {
;;;2938     /* Prevent unused argument(s) compilation warning */
;;;2939     UNUSED(hspi);
;;;2940   
;;;2941     /* NOTE : This function should not be modified, when the callback is needed,
;;;2942               the HAL_SPI_AbortCpltCallback can be implemented in the user file.
;;;2943      */
;;;2944   }
;;;2945   
                          ENDP


                          AREA ||i.HAL_SPI_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort_IT PROC
;;;2473     */
;;;2474   HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;2475   {
000004  4604              MOV      r4,r0
;;;2476     HAL_StatusTypeDef errorcode;
;;;2477     uint32_t abortcplt ;
;;;2478     __IO uint32_t count;
;;;2479     __IO uint32_t resetcount;
;;;2480   
;;;2481     /* Initialized local variable  */
;;;2482     errorcode = HAL_OK;
000006  2600              MOVS     r6,#0
;;;2483     abortcplt = 1U;
000008  2501              MOVS     r5,#1
;;;2484     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
00000a  4844              LDR      r0,|L3.284|
00000c  f64551c0          MOV      r1,#0x5dc0
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;2485     count = resetcount;
00001c  9801              LDR      r0,[sp,#4]
00001e  9002              STR      r0,[sp,#8]
;;;2486   
;;;2487     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2488     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000020  6820              LDR      r0,[r4,#0]
000022  6841              LDR      r1,[r0,#4]
000024  f0210120          BIC      r1,r1,#0x20
000028  6041              STR      r1,[r0,#4]
;;;2489   
;;;2490     /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
;;;2491     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
00002a  6821              LDR      r1,[r4,#0]
00002c  6848              LDR      r0,[r1,#4]
00002e  0600              LSLS     r0,r0,#24
000030  d50c              BPL      |L3.76|
;;;2492     {
;;;2493       hspi->TxISR = SPI_AbortTx_ISR;
000032  483b              LDR      r0,|L3.288|
000034  6520              STR      r0,[r4,#0x50]
                  |L3.54|
;;;2494       /* Wait HAL_SPI_STATE_ABORT state */
;;;2495       do
;;;2496       {
;;;2497         if (count == 0U)
000036  9802              LDR      r0,[sp,#8]
000038  b308              CBZ      r0,|L3.126|
;;;2498         {
;;;2499           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2500           break;
;;;2501         }
;;;2502         count--;
00003a  9802              LDR      r0,[sp,#8]
00003c  1e40              SUBS     r0,r0,#1
00003e  9002              STR      r0,[sp,#8]
;;;2503       } while (hspi->State != HAL_SPI_STATE_ABORT);
000040  f894005d          LDRB     r0,[r4,#0x5d]
000044  2807              CMP      r0,#7
000046  d1f6              BNE      |L3.54|
                  |L3.72|
;;;2504       /* Reset Timeout Counter */
;;;2505       count = resetcount;
000048  9801              LDR      r0,[sp,#4]
00004a  9002              STR      r0,[sp,#8]
                  |L3.76|
;;;2506     }
;;;2507   
;;;2508     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
00004c  6848              LDR      r0,[r1,#4]
00004e  0640              LSLS     r0,r0,#25
000050  d50c              BPL      |L3.108|
;;;2509     {
;;;2510       hspi->RxISR = SPI_AbortRx_ISR;
000052  4834              LDR      r0,|L3.292|
000054  64e0              STR      r0,[r4,#0x4c]
                  |L3.86|
;;;2511       /* Wait HAL_SPI_STATE_ABORT state */
;;;2512       do
;;;2513       {
;;;2514         if (count == 0U)
000056  9802              LDR      r0,[sp,#8]
000058  b1b0              CBZ      r0,|L3.136|
;;;2515         {
;;;2516           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2517           break;
;;;2518         }
;;;2519         count--;
00005a  9802              LDR      r0,[sp,#8]
00005c  1e40              SUBS     r0,r0,#1
00005e  9002              STR      r0,[sp,#8]
;;;2520       } while (hspi->State != HAL_SPI_STATE_ABORT);
000060  f894005d          LDRB     r0,[r4,#0x5d]
000064  2807              CMP      r0,#7
000066  d1f6              BNE      |L3.86|
                  |L3.104|
;;;2521       /* Reset Timeout Counter */
;;;2522       count = resetcount;
000068  9801              LDR      r0,[sp,#4]
00006a  9002              STR      r0,[sp,#8]
                  |L3.108|
;;;2523     }
;;;2524   
;;;2525     /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
;;;2526        before any call to DMA Abort functions */
;;;2527     /* DMA Tx Handle is valid */
;;;2528     if (hspi->hdmatx != NULL)
00006c  6d60              LDR      r0,[r4,#0x54]
00006e  2700              MOVS     r7,#0
000070  b180              CBZ      r0,|L3.148|
;;;2529     {
;;;2530       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2531          Otherwise, set it to NULL */
;;;2532       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
000072  6849              LDR      r1,[r1,#4]
000074  0789              LSLS     r1,r1,#30
000076  d50c              BPL      |L3.146|
;;;2533       {
;;;2534         hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
000078  492b              LDR      r1,|L3.296|
00007a  6381              STR      r1,[r0,#0x38]
00007c  e00a              B        |L3.148|
                  |L3.126|
00007e  6e20              LDR      r0,[r4,#0x60]         ;2499
000080  f0400040          ORR      r0,r0,#0x40           ;2499
000084  6620              STR      r0,[r4,#0x60]         ;2499
000086  e7df              B        |L3.72|
                  |L3.136|
000088  6e20              LDR      r0,[r4,#0x60]         ;2516
00008a  f0400040          ORR      r0,r0,#0x40           ;2516
00008e  6620              STR      r0,[r4,#0x60]         ;2516
000090  e7ea              B        |L3.104|
                  |L3.146|
;;;2535       }
;;;2536       else
;;;2537       {
;;;2538         hspi->hdmatx->XferAbortCallback = NULL;
000092  6387              STR      r7,[r0,#0x38]
                  |L3.148|
;;;2539       }
;;;2540     }
;;;2541     /* DMA Rx Handle is valid */
;;;2542     if (hspi->hdmarx != NULL)
000094  6da0              LDR      r0,[r4,#0x58]
000096  b138              CBZ      r0,|L3.168|
;;;2543     {
;;;2544       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2545          Otherwise, set it to NULL */
;;;2546       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
000098  6821              LDR      r1,[r4,#0]
00009a  6849              LDR      r1,[r1,#4]
00009c  07c9              LSLS     r1,r1,#31
00009e  d002              BEQ      |L3.166|
;;;2547       {
;;;2548         hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
0000a0  4922              LDR      r1,|L3.300|
0000a2  6381              STR      r1,[r0,#0x38]
0000a4  e000              B        |L3.168|
                  |L3.166|
;;;2549       }
;;;2550       else
;;;2551       {
;;;2552         hspi->hdmarx->XferAbortCallback = NULL;
0000a6  6387              STR      r7,[r0,#0x38]
                  |L3.168|
;;;2553       }
;;;2554     }
;;;2555   
;;;2556     /* Disable the SPI DMA Tx request if enabled */
;;;2557     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6840              LDR      r0,[r0,#4]
;;;2558     {
;;;2559       /* Abort the SPI DMA Tx Stream/Channel */
;;;2560       if (hspi->hdmatx != NULL)
;;;2561       {
;;;2562         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2563         if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
;;;2564         {
;;;2565           hspi->hdmatx->XferAbortCallback = NULL;
;;;2566           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000ac  f04f0840          MOV      r8,#0x40
0000b0  0780              LSLS     r0,r0,#30             ;2557
0000b2  d50a              BPL      |L3.202|
0000b4  6d60              LDR      r0,[r4,#0x54]         ;2560
0000b6  b140              CBZ      r0,|L3.202|
0000b8  f7fffffe          BL       HAL_DMA_Abort_IT
0000bc  b120              CBZ      r0,|L3.200|
0000be  6d60              LDR      r0,[r4,#0x54]         ;2565
0000c0  6387              STR      r7,[r0,#0x38]         ;2565
0000c2  f8c48060          STR      r8,[r4,#0x60]
0000c6  e000              B        |L3.202|
                  |L3.200|
;;;2567         }
;;;2568         else
;;;2569         {
;;;2570           abortcplt = 0U;
0000c8  2500              MOVS     r5,#0
                  |L3.202|
;;;2571         }
;;;2572       }
;;;2573     }
;;;2574     /* Disable the SPI DMA Rx request if enabled */
;;;2575     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6840              LDR      r0,[r0,#4]
0000ce  07c0              LSLS     r0,r0,#31
0000d0  d00a              BEQ      |L3.232|
;;;2576     {
;;;2577       /* Abort the SPI DMA Rx Stream/Channel */
;;;2578       if (hspi->hdmarx != NULL)
0000d2  6da0              LDR      r0,[r4,#0x58]
0000d4  b140              CBZ      r0,|L3.232|
;;;2579       {
;;;2580         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2581         if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
0000d6  f7fffffe          BL       HAL_DMA_Abort_IT
0000da  b120              CBZ      r0,|L3.230|
;;;2582         {
;;;2583           hspi->hdmarx->XferAbortCallback = NULL;
0000dc  6da0              LDR      r0,[r4,#0x58]
0000de  6387              STR      r7,[r0,#0x38]
;;;2584           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000e0  f8c48060          STR      r8,[r4,#0x60]
0000e4  e000              B        |L3.232|
                  |L3.230|
;;;2585         }
;;;2586         else
;;;2587         {
;;;2588           abortcplt = 0U;
0000e6  2500              MOVS     r5,#0
                  |L3.232|
;;;2589         }
;;;2590       }
;;;2591     }
;;;2592   
;;;2593     if (abortcplt == 1U)
0000e8  2d01              CMP      r5,#1
0000ea  d112              BNE      |L3.274|
;;;2594     {
;;;2595       /* Reset Tx and Rx transfer counters */
;;;2596       hspi->RxXferCount = 0U;
0000ec  f8a47046          STRH     r7,[r4,#0x46]
;;;2597       hspi->TxXferCount = 0U;
0000f0  87e7              STRH     r7,[r4,#0x3e]
;;;2598   
;;;2599       /* Check error during Abort procedure */
;;;2600       if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
0000f2  6e20              LDR      r0,[r4,#0x60]
0000f4  2840              CMP      r0,#0x40
0000f6  d00f              BEQ      |L3.280|
;;;2601       {
;;;2602         /* return HAL_Error in case of error during Abort procedure */
;;;2603         errorcode = HAL_ERROR;
;;;2604       }
;;;2605       else
;;;2606       {
;;;2607         /* Reset errorCode */
;;;2608         hspi->ErrorCode = HAL_SPI_ERROR_NONE;
0000f8  6627              STR      r7,[r4,#0x60]
                  |L3.250|
;;;2609       }
;;;2610   
;;;2611       /* Clear the Error flags in the SR register */
;;;2612       __HAL_SPI_CLEAR_OVRFLAG(hspi);
0000fa  6820              LDR      r0,[r4,#0]
0000fc  68c1              LDR      r1,[r0,#0xc]
0000fe  6881              LDR      r1,[r0,#8]
000100  9100              STR      r1,[sp,#0]
;;;2613       __HAL_SPI_CLEAR_FREFLAG(hspi);
000102  6880              LDR      r0,[r0,#8]
000104  9000              STR      r0,[sp,#0]
;;;2614   
;;;2615       /* Restore hspi->State to Ready */
;;;2616       hspi->State = HAL_SPI_STATE_READY;
000106  2001              MOVS     r0,#1
000108  f884005d          STRB     r0,[r4,#0x5d]
;;;2617   
;;;2618       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2619   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2620       hspi->AbortCpltCallback(hspi);
;;;2621   #else
;;;2622       HAL_SPI_AbortCpltCallback(hspi);
00010c  4620              MOV      r0,r4
00010e  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L3.274|
;;;2623   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2624     }
;;;2625   
;;;2626     return errorcode;
000112  4630              MOV      r0,r6
;;;2627   }
000114  e8bd83fe          POP      {r1-r9,pc}
                  |L3.280|
000118  2601              MOVS     r6,#1                 ;2603
00011a  e7ee              B        |L3.250|
;;;2628   
                          ENDP

                  |L3.284|
                          DCD      SystemCoreClock
                  |L3.288|
                          DCD      SPI_AbortTx_ISR
                  |L3.292|
                          DCD      SPI_AbortRx_ISR
                  |L3.296|
                          DCD      SPI_DMATxAbortCallback
                  |L3.300|
                          DCD      SPI_DMARxAbortCallback

                          AREA ||i.HAL_SPI_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAPause PROC
;;;2634     */
;;;2635   HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
000000  f890105c          LDRB     r1,[r0,#0x5c]
;;;2636   {
;;;2637     /* Process Locked */
;;;2638     __HAL_LOCK(hspi);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L4.34|
000008  2101              MOVS     r1,#1
00000a  f880105c          STRB     r1,[r0,#0x5c]
;;;2639   
;;;2640     /* Disable the SPI DMA Tx & Rx requests */
;;;2641     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00000e  6801              LDR      r1,[r0,#0]
000010  684a              LDR      r2,[r1,#4]
000012  f0220203          BIC      r2,r2,#3
000016  604a              STR      r2,[r1,#4]
;;;2642   
;;;2643     /* Process Unlocked */
;;;2644     __HAL_UNLOCK(hspi);
000018  2100              MOVS     r1,#0
00001a  f880105c          STRB     r1,[r0,#0x5c]
;;;2645   
;;;2646     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;2647   }
000020  4770              BX       lr
                  |L4.34|
000022  2002              MOVS     r0,#2                 ;2638
000024  4770              BX       lr
;;;2648   
                          ENDP


                          AREA ||i.HAL_SPI_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAResume PROC
;;;2654     */
;;;2655   HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
000000  f890105c          LDRB     r1,[r0,#0x5c]
;;;2656   {
;;;2657     /* Process Locked */
;;;2658     __HAL_LOCK(hspi);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L5.34|
000008  2101              MOVS     r1,#1
00000a  f880105c          STRB     r1,[r0,#0x5c]
;;;2659   
;;;2660     /* Enable the SPI DMA Tx & Rx requests */
;;;2661     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00000e  6801              LDR      r1,[r0,#0]
000010  684a              LDR      r2,[r1,#4]
000012  f0420203          ORR      r2,r2,#3
000016  604a              STR      r2,[r1,#4]
;;;2662   
;;;2663     /* Process Unlocked */
;;;2664     __HAL_UNLOCK(hspi);
000018  2100              MOVS     r1,#0
00001a  f880105c          STRB     r1,[r0,#0x5c]
;;;2665   
;;;2666     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;2667   }
000020  4770              BX       lr
                  |L5.34|
000022  2002              MOVS     r0,#2                 ;2658
000024  4770              BX       lr
;;;2668   
                          ENDP


                          AREA ||i.HAL_SPI_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAStop PROC
;;;2674     */
;;;2675   HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
000000  b570              PUSH     {r4-r6,lr}
;;;2676   {
000002  4604              MOV      r4,r0
;;;2677     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2678     /* The Lock is not implemented on this API to allow the user application
;;;2679        to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
;;;2680        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;2681        and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
;;;2682        */
;;;2683   
;;;2684     /* Abort the SPI DMA tx Stream/Channel  */
;;;2685     if (hspi->hdmatx != NULL)
000006  6d60              LDR      r0,[r4,#0x54]
000008  2800              CMP      r0,#0
00000a  d007              BEQ      |L6.28|
;;;2686     {
;;;2687       if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
00000c  f7fffffe          BL       HAL_DMA_Abort
000010  b120              CBZ      r0,|L6.28|
;;;2688       {
;;;2689         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6e20              LDR      r0,[r4,#0x60]
000014  f0400010          ORR      r0,r0,#0x10
000018  6620              STR      r0,[r4,#0x60]
;;;2690         errorcode = HAL_ERROR;
00001a  2501              MOVS     r5,#1
                  |L6.28|
;;;2691       }
;;;2692     }
;;;2693     /* Abort the SPI DMA rx Stream/Channel  */
;;;2694     if (hspi->hdmarx != NULL)
00001c  6da0              LDR      r0,[r4,#0x58]
00001e  b138              CBZ      r0,|L6.48|
;;;2695     {
;;;2696       if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
000020  f7fffffe          BL       HAL_DMA_Abort
000024  b120              CBZ      r0,|L6.48|
;;;2697       {
;;;2698         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000026  6e20              LDR      r0,[r4,#0x60]
000028  f0400010          ORR      r0,r0,#0x10
00002c  6620              STR      r0,[r4,#0x60]
;;;2699         errorcode = HAL_ERROR;
00002e  2501              MOVS     r5,#1
                  |L6.48|
;;;2700       }
;;;2701     }
;;;2702   
;;;2703     /* Disable the SPI DMA Tx & Rx requests */
;;;2704     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000030  6820              LDR      r0,[r4,#0]
000032  6841              LDR      r1,[r0,#4]
000034  f0210103          BIC      r1,r1,#3
000038  6041              STR      r1,[r0,#4]
;;;2705     hspi->State = HAL_SPI_STATE_READY;
00003a  2001              MOVS     r0,#1
00003c  f884005d          STRB     r0,[r4,#0x5d]
;;;2706     return errorcode;
000040  4628              MOV      r0,r5
;;;2707   }
000042  bd70              POP      {r4-r6,pc}
;;;2708   
                          ENDP


                          AREA ||i.HAL_SPI_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DeInit PROC
;;;490      */
;;;491    HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;492    {
000002  4604              MOV      r4,r0
;;;493      /* Check the SPI handle allocation */
;;;494      if (hspi == NULL)
000004  2c00              CMP      r4,#0
000006  d010              BEQ      |L7.42|
;;;495      {
;;;496        return HAL_ERROR;
;;;497      }
;;;498    
;;;499      /* Check SPI Instance parameter */
;;;500      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;501    
;;;502      hspi->State = HAL_SPI_STATE_BUSY;
000008  2002              MOVS     r0,#2
00000a  f884005d          STRB     r0,[r4,#0x5d]
;;;503    
;;;504      /* Disable the SPI Peripheral Clock */
;;;505      __HAL_SPI_DISABLE(hspi);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0210140          BIC      r1,r1,#0x40
000016  6001              STR      r1,[r0,#0]
;;;506    
;;;507    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;508      if (hspi->MspDeInitCallback == NULL)
;;;509      {
;;;510        hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
;;;511      }
;;;512    
;;;513      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;514      hspi->MspDeInitCallback(hspi);
;;;515    #else
;;;516      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;517      HAL_SPI_MspDeInit(hspi);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_SPI_MspDeInit
;;;518    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;519    
;;;520      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  345c              ADDS     r4,r4,#0x5c
000022  6060              STR      r0,[r4,#4]
;;;521      hspi->State = HAL_SPI_STATE_RESET;
000024  7060              STRB     r0,[r4,#1]
;;;522    
;;;523      /* Release Lock */
;;;524      __HAL_UNLOCK(hspi);
000026  7020              STRB     r0,[r4,#0]
;;;525    
;;;526      return HAL_OK;
;;;527    }
000028  bd10              POP      {r4,pc}
                  |L7.42|
00002a  2001              MOVS     r0,#1                 ;496
00002c  bd10              POP      {r4,pc}
;;;528    
                          ENDP


                          AREA ||i.HAL_SPI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_ErrorCallback PROC
;;;2917     */
;;;2918   __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2919   {
;;;2920     /* Prevent unused argument(s) compilation warning */
;;;2921     UNUSED(hspi);
;;;2922   
;;;2923     /* NOTE : This function should not be modified, when the callback is needed,
;;;2924               the HAL_SPI_ErrorCallback should be implemented in the user file
;;;2925      */
;;;2926     /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
;;;2927               and user can use HAL_SPI_GetError() API to check the latest error occurred
;;;2928      */
;;;2929   }
;;;2930   
                          ENDP


                          AREA ||i.HAL_SPI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetError PROC
;;;2982     */
;;;2983   uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
000000  6e00              LDR      r0,[r0,#0x60]
;;;2984   {
;;;2985     /* Return SPI ErrorCode */
;;;2986     return hspi->ErrorCode;
;;;2987   }
000002  4770              BX       lr
;;;2988   
                          ENDP


                          AREA ||i.HAL_SPI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetState PROC
;;;2970     */
;;;2971   HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
000000  f890005d          LDRB     r0,[r0,#0x5d]
;;;2972   {
;;;2973     /* Return SPI handle state */
;;;2974     return hspi->State;
;;;2975   }
000004  4770              BX       lr
;;;2976   
                          ENDP


                          AREA ||i.HAL_SPI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SPI_IRQHandler PROC
;;;2714     */
;;;2715   void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;2716   {
000002  4604              MOV      r4,r0
;;;2717     uint32_t itsource = hspi->Instance->CR2;
000004  6820              LDR      r0,[r4,#0]
000006  6842              LDR      r2,[r0,#4]
;;;2718     uint32_t itflag   = hspi->Instance->SR;
000008  6881              LDR      r1,[r0,#8]
;;;2719   
;;;2720     /* SPI in mode Receiver ----------------------------------------------------*/
;;;2721     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
00000a  43c9              MVNS     r1,r1
00000c  064b              LSLS     r3,r1,#25
00000e  d50a              BPL      |L11.38|
;;;2722         (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
000010  07cb              LSLS     r3,r1,#31
000012  d108              BNE      |L11.38|
000014  43d3              MVNS     r3,r2
000016  065b              LSLS     r3,r3,#25
000018  d405              BMI      |L11.38|
;;;2723     {
;;;2724       hspi->RxISR(hspi);
00001a  6ce1              LDR      r1,[r4,#0x4c]
00001c  b001              ADD      sp,sp,#4
00001e  4620              MOV      r0,r4
000020  e8bd4030          POP      {r4,r5,lr}
000024  4708              BX       r1
                  |L11.38|
;;;2725       return;
;;;2726     }
;;;2727   
;;;2728     /* SPI in mode Transmitter -------------------------------------------------*/
;;;2729     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
000026  078b              LSLS     r3,r1,#30
000028  d408              BMI      |L11.60|
00002a  43d3              MVNS     r3,r2
00002c  061b              LSLS     r3,r3,#24
00002e  d405              BMI      |L11.60|
;;;2730     {
;;;2731       hspi->TxISR(hspi);
000030  6d21              LDR      r1,[r4,#0x50]
000032  b001              ADD      sp,sp,#4
000034  4620              MOV      r0,r4
000036  e8bd4030          POP      {r4,r5,lr}
00003a  4708              BX       r1
                  |L11.60|
;;;2732       return;
;;;2733     }
;;;2734   
;;;2735     /* SPI in Error Treatment --------------------------------------------------*/
;;;2736     if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
00003c  068b              LSLS     r3,r1,#26
00003e  d503              BPL      |L11.72|
000040  064b              LSLS     r3,r1,#25
000042  d501              BPL      |L11.72|
;;;2737          || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
000044  05cb              LSLS     r3,r1,#23
000046  d451              BMI      |L11.236|
                  |L11.72|
000048  43d3              MVNS     r3,r2
00004a  069b              LSLS     r3,r3,#26
00004c  d44e              BMI      |L11.236|
;;;2738     {
;;;2739       /* SPI Overrun error interrupt occurred ----------------------------------*/
;;;2740       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
00004e  064b              LSLS     r3,r1,#25
000050  d40a              BMI      |L11.104|
;;;2741       {
;;;2742         if (hspi->State != HAL_SPI_STATE_BUSY_TX)
000052  f894305d          LDRB     r3,[r4,#0x5d]
000056  2b03              CMP      r3,#3
000058  d049              BEQ      |L11.238|
;;;2743         {
;;;2744           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
00005a  6e23              LDR      r3,[r4,#0x60]
00005c  f0430304          ORR      r3,r3,#4
000060  6623              STR      r3,[r4,#0x60]
;;;2745           __HAL_SPI_CLEAR_OVRFLAG(hspi);
000062  68c3              LDR      r3,[r0,#0xc]
000064  6883              LDR      r3,[r0,#8]
000066  9300              STR      r3,[sp,#0]
                  |L11.104|
;;;2746         }
;;;2747         else
;;;2748         {
;;;2749           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2750           return;
;;;2751         }
;;;2752       }
;;;2753   
;;;2754       /* SPI Mode Fault error interrupt occurred -------------------------------*/
;;;2755       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
000068  068b              LSLS     r3,r1,#26
00006a  d409              BMI      |L11.128|
;;;2756       {
;;;2757         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
00006c  6e23              LDR      r3,[r4,#0x60]
00006e  f0430301          ORR      r3,r3,#1
000072  6623              STR      r3,[r4,#0x60]
;;;2758         __HAL_SPI_CLEAR_MODFFLAG(hspi);
000074  6883              LDR      r3,[r0,#8]
000076  9300              STR      r3,[sp,#0]
000078  6803              LDR      r3,[r0,#0]
00007a  f0230340          BIC      r3,r3,#0x40
00007e  6003              STR      r3,[r0,#0]
                  |L11.128|
;;;2759       }
;;;2760   
;;;2761       /* SPI Frame error interrupt occurred ------------------------------------*/
;;;2762       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
000080  05c8              LSLS     r0,r1,#23
000082  d406              BMI      |L11.146|
;;;2763       {
;;;2764         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
000084  6e20              LDR      r0,[r4,#0x60]
000086  f0400008          ORR      r0,r0,#8
00008a  6620              STR      r0,[r4,#0x60]
;;;2765         __HAL_SPI_CLEAR_FREFLAG(hspi);
00008c  6820              LDR      r0,[r4,#0]
00008e  6880              LDR      r0,[r0,#8]
000090  9000              STR      r0,[sp,#0]
                  |L11.146|
;;;2766       }
;;;2767   
;;;2768       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000092  6e20              LDR      r0,[r4,#0x60]
000094  2800              CMP      r0,#0
000096  d029              BEQ      |L11.236|
;;;2769       {
;;;2770         /* Disable all interrupts */
;;;2771         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
000098  6820              LDR      r0,[r4,#0]
00009a  6841              LDR      r1,[r0,#4]
00009c  f02101e0          BIC      r1,r1,#0xe0
0000a0  6041              STR      r1,[r0,#4]
;;;2772   
;;;2773         hspi->State = HAL_SPI_STATE_READY;
0000a2  2001              MOVS     r0,#1
0000a4  f884005d          STRB     r0,[r4,#0x5d]
;;;2774         /* Disable the SPI DMA requests if enabled */
;;;2775         if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
0000a8  0790              LSLS     r0,r2,#30
0000aa  d401              BMI      |L11.176|
0000ac  07d0              LSLS     r0,r2,#31
0000ae  d022              BEQ      |L11.246|
                  |L11.176|
;;;2776         {
;;;2777           CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6841              LDR      r1,[r0,#4]
0000b4  f0210103          BIC      r1,r1,#3
0000b8  6041              STR      r1,[r0,#4]
;;;2778   
;;;2779           /* Abort the SPI DMA Rx channel */
;;;2780           if (hspi->hdmarx != NULL)
;;;2781           {
;;;2782             /* Set the SPI DMA Abort callback :
;;;2783             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2784             hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
0000ba  4d11              LDR      r5,|L11.256|
0000bc  6da0              LDR      r0,[r4,#0x58]         ;2780
0000be  b140              CBZ      r0,|L11.210|
0000c0  6385              STR      r5,[r0,#0x38]
;;;2785             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
0000c2  6da0              LDR      r0,[r4,#0x58]
0000c4  f7fffffe          BL       HAL_DMA_Abort_IT
0000c8  b118              CBZ      r0,|L11.210|
;;;2786             {
;;;2787               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
0000ca  6e20              LDR      r0,[r4,#0x60]
0000cc  f0400040          ORR      r0,r0,#0x40
0000d0  6620              STR      r0,[r4,#0x60]
                  |L11.210|
;;;2788             }
;;;2789           }
;;;2790           /* Abort the SPI DMA Tx channel */
;;;2791           if (hspi->hdmatx != NULL)
0000d2  6d60              LDR      r0,[r4,#0x54]
0000d4  2800              CMP      r0,#0
0000d6  d009              BEQ      |L11.236|
;;;2792           {
;;;2793             /* Set the SPI DMA Abort callback :
;;;2794             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2795             hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
0000d8  6385              STR      r5,[r0,#0x38]
;;;2796             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
0000da  6d60              LDR      r0,[r4,#0x54]
0000dc  f7fffffe          BL       HAL_DMA_Abort_IT
0000e0  2800              CMP      r0,#0
0000e2  d003              BEQ      |L11.236|
;;;2797             {
;;;2798               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
0000e4  6e20              LDR      r0,[r4,#0x60]
0000e6  f0400040          ORR      r0,r0,#0x40
0000ea  6620              STR      r0,[r4,#0x60]
                  |L11.236|
;;;2799             }
;;;2800           }
;;;2801         }
;;;2802         else
;;;2803         {
;;;2804           /* Call user error callback */
;;;2805   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2806           hspi->ErrorCallback(hspi);
;;;2807   #else
;;;2808           HAL_SPI_ErrorCallback(hspi);
;;;2809   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2810         }
;;;2811       }
;;;2812       return;
;;;2813     }
;;;2814   }
0000ec  bd38              POP      {r3-r5,pc}
                  |L11.238|
0000ee  68c1              LDR      r1,[r0,#0xc]          ;2749
0000f0  6880              LDR      r0,[r0,#8]            ;2749
0000f2  9000              STR      r0,[sp,#0]            ;2749
0000f4  bd38              POP      {r3-r5,pc}
                  |L11.246|
0000f6  4620              MOV      r0,r4                 ;2808
0000f8  f7fffffe          BL       HAL_SPI_ErrorCallback
0000fc  bd38              POP      {r3-r5,pc}
;;;2815   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L11.256|
                          DCD      SPI_DMAAbortOnError

                          AREA ||i.HAL_SPI_Init||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Init PROC
;;;315      */
;;;316    HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;317    {
000004  4604              MOV      r4,r0
;;;318      uint32_t frxth;
;;;319    
;;;320      /* Check the SPI handle allocation */
;;;321      if (hspi == NULL)
000006  2c00              CMP      r4,#0
000008  d00a              BEQ      |L12.32|
;;;322      {
;;;323        return HAL_ERROR;
;;;324      }
;;;325    
;;;326      /* Check the parameters */
;;;327      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;328      assert_param(IS_SPI_MODE(hspi->Init.Mode));
;;;329      assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
;;;330      assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
;;;331      assert_param(IS_SPI_NSS(hspi->Init.NSS));
;;;332      assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
;;;333      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;334      assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
;;;335      assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
;;;336      if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
00000a  6a60              LDR      r0,[r4,#0x24]
00000c  2500              MOVS     r5,#0
00000e  b150              CBZ      r0,|L12.38|
;;;337      {
;;;338        assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
;;;339        assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
;;;340    
;;;341        if (hspi->Init.Mode == SPI_MODE_MASTER)
;;;342        {
;;;343          assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;344        }
;;;345        else
;;;346        {
;;;347          /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
;;;348          hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
;;;349        }
;;;350      }
;;;351      else
;;;352      {
;;;353        assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;354    
;;;355        /* Force polarity and phase to TI protocaol requirements */
;;;356        hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
000010  6125              STR      r5,[r4,#0x10]
;;;357        hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
000012  6165              STR      r5,[r4,#0x14]
                  |L12.20|
;;;358      }
;;;359    #if (USE_SPI_CRC != 0U)
;;;360      assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
;;;361      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000014  f44f5600          MOV      r6,#0x2000
;;;362      {
;;;363        assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
;;;364        assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
;;;365      }
;;;366    #else
;;;367      hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
;;;368    #endif /* USE_SPI_CRC */
;;;369    
;;;370      if (hspi->State == HAL_SPI_STATE_RESET)
000018  f894005d          LDRB     r0,[r4,#0x5d]
00001c  b148              CBZ      r0,|L12.50|
00001e  e00d              B        |L12.60|
                  |L12.32|
000020  2001              MOVS     r0,#1                 ;323
                  |L12.34|
;;;371      {
;;;372        /* Allocate lock resource and initialize it */
;;;373        hspi->Lock = HAL_UNLOCKED;
;;;374    
;;;375    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;376        /* Init the SPI Callback settings */
;;;377        hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
;;;378        hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
;;;379        hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
;;;380        hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
;;;381        hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
;;;382        hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
;;;383        hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;384        hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;385    
;;;386        if (hspi->MspInitCallback == NULL)
;;;387        {
;;;388          hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
;;;389        }
;;;390    
;;;391        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;392        hspi->MspInitCallback(hspi);
;;;393    #else
;;;394        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;395        HAL_SPI_MspInit(hspi);
;;;396    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;397      }
;;;398    
;;;399      hspi->State = HAL_SPI_STATE_BUSY;
;;;400    
;;;401      /* Disable the selected SPI peripheral */
;;;402      __HAL_SPI_DISABLE(hspi);
;;;403    
;;;404      /* Align by default the rs fifo threshold on the data size */
;;;405      if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;406      {
;;;407        frxth = SPI_RXFIFO_THRESHOLD_HF;
;;;408      }
;;;409      else
;;;410      {
;;;411        frxth = SPI_RXFIFO_THRESHOLD_QF;
;;;412      }
;;;413    
;;;414      /* CRC calculation is valid only for 16Bit and 8 Bit */
;;;415      if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
;;;416      {
;;;417        /* CRC must be disabled */
;;;418        hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
;;;419      }
;;;420    
;;;421      /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
;;;422      /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
;;;423      Communication speed, First bit and CRC calculation state */
;;;424      WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
;;;425                                      (hspi->Init.Direction & (SPI_CR1_RXONLY | SPI_CR1_BIDIMODE)) |
;;;426                                      (hspi->Init.CLKPolarity & SPI_CR1_CPOL) |
;;;427                                      (hspi->Init.CLKPhase & SPI_CR1_CPHA) |
;;;428                                      (hspi->Init.NSS & SPI_CR1_SSM) |
;;;429                                      (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
;;;430                                      (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
;;;431                                      (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));
;;;432    #if (USE_SPI_CRC != 0U)
;;;433      /*---------------------------- SPIx CRCL Configuration -------------------*/
;;;434      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;435      {
;;;436        /* Align the CRC Length on the data size */
;;;437        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
;;;438        {
;;;439          /* CRC Length aligned on the data size : value set by default */
;;;440          if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;441          {
;;;442            hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
;;;443          }
;;;444          else
;;;445          {
;;;446            hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
;;;447          }
;;;448        }
;;;449    
;;;450        /* Configure : CRC Length */
;;;451        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
;;;452        {
;;;453          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCL);
;;;454        }
;;;455      }
;;;456    #endif /* USE_SPI_CRC */
;;;457    
;;;458      /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
;;;459      WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
;;;460                                      (hspi->Init.TIMode & SPI_CR2_FRF) |
;;;461                                      (hspi->Init.NSSPMode & SPI_CR2_NSSP) |
;;;462                                      (hspi->Init.DataSize & SPI_CR2_DS_Msk) |
;;;463                                      (frxth & SPI_CR2_FRXTH)));
;;;464    
;;;465    #if (USE_SPI_CRC != 0U)
;;;466      /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
;;;467      /* Configure : CRC Polynomial */
;;;468      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;469      {
;;;470        WRITE_REG(hspi->Instance->CRCPR, (hspi->Init.CRCPolynomial & SPI_CRCPR_CRCPOLY_Msk));
;;;471      }
;;;472    #endif /* USE_SPI_CRC */
;;;473    
;;;474    #if defined(SPI_I2SCFGR_I2SMOD)
;;;475      /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
;;;476      CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
;;;477    #endif /* SPI_I2SCFGR_I2SMOD */
;;;478    
;;;479      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;480      hspi->State     = HAL_SPI_STATE_READY;
;;;481    
;;;482      return HAL_OK;
;;;483    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L12.38|
000026  6860              LDR      r0,[r4,#4]            ;341
000028  f5b07f82          CMP      r0,#0x104             ;341
00002c  d0f2              BEQ      |L12.20|
00002e  61e5              STR      r5,[r4,#0x1c]         ;348
000030  e7f0              B        |L12.20|
                  |L12.50|
000032  f884505c          STRB     r5,[r4,#0x5c]         ;373
000036  4620              MOV      r0,r4                 ;395
000038  f7fffffe          BL       HAL_SPI_MspInit
                  |L12.60|
00003c  2302              MOVS     r3,#2                 ;399
00003e  f884305d          STRB     r3,[r4,#0x5d]         ;399
000042  6820              LDR      r0,[r4,#0]            ;402
000044  6801              LDR      r1,[r0,#0]            ;402
000046  f0210140          BIC      r1,r1,#0x40           ;402
00004a  6001              STR      r1,[r0,#0]            ;402
00004c  68e1              LDR      r1,[r4,#0xc]          ;405
00004e  f44f62e0          MOV      r2,#0x700             ;405
000052  4291              CMP      r1,r2                 ;405
000054  d901              BLS      |L12.90|
000056  2000              MOVS     r0,#0                 ;407
000058  e001              B        |L12.94|
                  |L12.90|
00005a  f44f5080          MOV      r0,#0x1000            ;411
                  |L12.94|
00005e  f5b16f70          CMP      r1,#0xf00             ;415
000062  d002              BEQ      |L12.106|
000064  4291              CMP      r1,r2                 ;415
000066  d000              BEQ      |L12.106|
000068  62a5              STR      r5,[r4,#0x28]         ;418
                  |L12.106|
00006a  88a1              LDRH     r1,[r4,#4]            ;424
00006c  8927              LDRH     r7,[r4,#8]            ;424
00006e  f4017182          AND      r1,r1,#0x104          ;424
000072  f4074704          AND      r7,r7,#0x8400         ;424
000076  4339              ORRS     r1,r1,r7              ;424
000078  7c27              LDRB     r7,[r4,#0x10]         ;424
00007a  f0070702          AND      r7,r7,#2              ;424
00007e  4339              ORRS     r1,r1,r7              ;424
000080  7d27              LDRB     r7,[r4,#0x14]         ;424
000082  f0070701          AND      r7,r7,#1              ;424
000086  4339              ORRS     r1,r1,r7              ;424
000088  8b27              LDRH     r7,[r4,#0x18]         ;424
00008a  f4077700          AND      r7,r7,#0x200          ;424
00008e  4339              ORRS     r1,r1,r7              ;424
000090  7f27              LDRB     r7,[r4,#0x1c]         ;424
000092  f0070738          AND      r7,r7,#0x38           ;424
000096  4339              ORRS     r1,r1,r7              ;424
000098  f8947020          LDRB     r7,[r4,#0x20]         ;424
00009c  f0070780          AND      r7,r7,#0x80           ;424
0000a0  4339              ORRS     r1,r1,r7              ;424
0000a2  8d27              LDRH     r7,[r4,#0x28]         ;424
0000a4  f4075700          AND      r7,r7,#0x2000         ;424
0000a8  4339              ORRS     r1,r1,r7              ;424
0000aa  6827              LDR      r7,[r4,#0]            ;424
0000ac  6039              STR      r1,[r7,#0]            ;424
0000ae  6aa1              LDR      r1,[r4,#0x28]         ;434
0000b0  2701              MOVS     r7,#1                 ;323
0000b2  42b1              CMP      r1,r6                 ;434
0000b4  d10f              BNE      |L12.214|
0000b6  6b21              LDR      r1,[r4,#0x30]         ;437
0000b8  b929              CBNZ     r1,|L12.198|
0000ba  68e1              LDR      r1,[r4,#0xc]          ;440
0000bc  4291              CMP      r1,r2                 ;440
0000be  d901              BLS      |L12.196|
0000c0  6323              STR      r3,[r4,#0x30]         ;442
0000c2  e000              B        |L12.198|
                  |L12.196|
0000c4  6327              STR      r7,[r4,#0x30]         ;446
                  |L12.198|
0000c6  6b21              LDR      r1,[r4,#0x30]         ;451
0000c8  2902              CMP      r1,#2                 ;451
0000ca  d104              BNE      |L12.214|
0000cc  6821              LDR      r1,[r4,#0]            ;453
0000ce  680a              LDR      r2,[r1,#0]            ;453
0000d0  f4426200          ORR      r2,r2,#0x800          ;453
0000d4  600a              STR      r2,[r1,#0]            ;453
                  |L12.214|
0000d6  69a1              LDR      r1,[r4,#0x18]         ;459
0000d8  2204              MOVS     r2,#4                 ;459
0000da  ea024111          AND      r1,r2,r1,LSR #16      ;459
0000de  f8942024          LDRB     r2,[r4,#0x24]         ;459
0000e2  f4005080          AND      r0,r0,#0x1000         ;459
0000e6  f0020210          AND      r2,r2,#0x10           ;459
0000ea  4311              ORRS     r1,r1,r2              ;459
0000ec  f8942034          LDRB     r2,[r4,#0x34]         ;459
0000f0  f0020208          AND      r2,r2,#8              ;459
0000f4  4311              ORRS     r1,r1,r2              ;459
0000f6  89a2              LDRH     r2,[r4,#0xc]          ;459
0000f8  f4026270          AND      r2,r2,#0xf00          ;459
0000fc  4311              ORRS     r1,r1,r2              ;459
0000fe  4301              ORRS     r1,r1,r0              ;459
000100  6820              LDR      r0,[r4,#0]            ;459
000102  6041              STR      r1,[r0,#4]            ;459
000104  6aa0              LDR      r0,[r4,#0x28]         ;468
000106  42b0              CMP      r0,r6                 ;468
000108  d103              BNE      |L12.274|
00010a  8da0              LDRH     r0,[r4,#0x2c]         ;470
00010c  6821              LDR      r1,[r4,#0]            ;470
00010e  b280              UXTH     r0,r0                 ;470
000110  6108              STR      r0,[r1,#0x10]         ;470
                  |L12.274|
000112  6625              STR      r5,[r4,#0x60]         ;479
000114  f884705d          STRB     r7,[r4,#0x5d]         ;480
000118  2000              MOVS     r0,#0                 ;482
00011a  e782              B        |L12.34|
;;;484    
                          ENDP


                          AREA ||i.HAL_SPI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspDeInit PROC
;;;550      */
;;;551    __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;552    {
;;;553      /* Prevent unused argument(s) compilation warning */
;;;554      UNUSED(hspi);
;;;555    
;;;556      /* NOTE : This function should not be modified, when the callback is needed,
;;;557                the HAL_SPI_MspDeInit should be implemented in the user file
;;;558       */
;;;559    }
;;;560    
                          ENDP


                          AREA ||i.HAL_SPI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspInit PROC
;;;534      */
;;;535    __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;536    {
;;;537      /* Prevent unused argument(s) compilation warning */
;;;538      UNUSED(hspi);
;;;539    
;;;540      /* NOTE : This function should not be modified, when the callback is needed,
;;;541                the HAL_SPI_MspInit should be implemented in the user file
;;;542       */
;;;543    }
;;;544    
                          ENDP


                          AREA ||i.HAL_SPI_Receive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Receive PROC
;;;1007     */
;;;1008   HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1009   {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
;;;1010   #if (USE_SPI_CRC != 0U)
;;;1011     __IO uint32_t tmpreg = 0U;
00000c  f04f0800          MOV      r8,#0
000010  f8cd8004          STR      r8,[sp,#4]
;;;1012   #endif /* USE_SPI_CRC */
;;;1013     uint32_t tickstart;
;;;1014     HAL_StatusTypeDef errorcode = HAL_OK;
000014  2600              MOVS     r6,#0
;;;1015   
;;;1016     if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
000016  6860              LDR      r0,[r4,#4]
;;;1017     {
;;;1018       hspi->State = HAL_SPI_STATE_BUSY_RX;
000018  f04f0b04          MOV      r11,#4
00001c  f5b07f82          CMP      r0,#0x104             ;1016
000020  d101              BNE      |L15.38|
000022  68a0              LDR      r0,[r4,#8]            ;1016
000024  b178              CBZ      r0,|L15.70|
                  |L15.38|
;;;1019       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1020       return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
;;;1021     }
;;;1022   
;;;1023     /* Process Locked */
;;;1024     __HAL_LOCK(hspi);
000026  f894005c          LDRB     r0,[r4,#0x5c]
00002a  2801              CMP      r0,#1
00002c  d016              BEQ      |L15.92|
00002e  2001              MOVS     r0,#1
000030  f884005c          STRB     r0,[r4,#0x5c]
;;;1025   
;;;1026     /* Init tickstart for timeout management*/
;;;1027     tickstart = HAL_GetTick();
000034  f7fffffe          BL       HAL_GetTick
000038  4607              MOV      r7,r0
;;;1028   
;;;1029     if (hspi->State != HAL_SPI_STATE_READY)
00003a  f894005d          LDRB     r0,[r4,#0x5d]
00003e  2801              CMP      r0,#1
000040  d00e              BEQ      |L15.96|
;;;1030     {
;;;1031       errorcode = HAL_BUSY;
000042  2602              MOVS     r6,#2
;;;1032       goto error;
000044  e107              B        |L15.598|
                  |L15.70|
000046  f884b05d          STRB     r11,[r4,#0x5d]        ;1018
00004a  464b              MOV      r3,r9                 ;1020
00004c  4652              MOV      r2,r10                ;1020
00004e  4651              MOV      r1,r10                ;1020
000050  4620              MOV      r0,r4                 ;1020
000052  9500              STR      r5,[sp,#0]            ;1020
000054  f7fffffe          BL       HAL_SPI_TransmitReceive
                  |L15.88|
;;;1033     }
;;;1034   
;;;1035     if ((pData == NULL) || (Size == 0U))
;;;1036     {
;;;1037       errorcode = HAL_ERROR;
;;;1038       goto error;
;;;1039     }
;;;1040   
;;;1041     /* Set the transaction information */
;;;1042     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1043     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1044     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1045     hspi->RxXferSize  = Size;
;;;1046     hspi->RxXferCount = Size;
;;;1047   
;;;1048     /*Init field not used in handle to zero */
;;;1049     hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1050     hspi->TxXferSize  = 0U;
;;;1051     hspi->TxXferCount = 0U;
;;;1052     hspi->RxISR       = NULL;
;;;1053     hspi->TxISR       = NULL;
;;;1054   
;;;1055   #if (USE_SPI_CRC != 0U)
;;;1056     /* Reset CRC Calculation */
;;;1057     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1058     {
;;;1059       SPI_RESET_CRC(hspi);
;;;1060       /* this is done to handle the CRCNEXT before the latest data */
;;;1061       hspi->RxXferCount--;
;;;1062     }
;;;1063   #endif /* USE_SPI_CRC */
;;;1064   
;;;1065     /* Set the Rx Fifo threshold */
;;;1066     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1067     {
;;;1068       /* Set RX Fifo threshold according the reception data length: 16bit */
;;;1069       CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1070     }
;;;1071     else
;;;1072     {
;;;1073       /* Set RX Fifo threshold according the reception data length: 8bit */
;;;1074       SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1075     }
;;;1076   
;;;1077     /* Configure communication direction: 1Line */
;;;1078     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1079     {
;;;1080       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1081       __HAL_SPI_DISABLE(hspi);
;;;1082       SPI_1LINE_RX(hspi);
;;;1083     }
;;;1084   
;;;1085     /* Check if the SPI is already enabled */
;;;1086     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1087     {
;;;1088       /* Enable SPI peripheral */
;;;1089       __HAL_SPI_ENABLE(hspi);
;;;1090     }
;;;1091   
;;;1092     /* Receive data in 8 Bit mode */
;;;1093     if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
;;;1094     {
;;;1095       /* Transfer loop */
;;;1096       while (hspi->RxXferCount > 0U)
;;;1097       {
;;;1098         /* Check the RXNE flag */
;;;1099         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1100         {
;;;1101           /* read the received data */
;;;1102           (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1103           hspi->pRxBuffPtr += sizeof(uint8_t);
;;;1104           hspi->RxXferCount--;
;;;1105         }
;;;1106         else
;;;1107         {
;;;1108           /* Timeout management */
;;;1109           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1110           {
;;;1111             errorcode = HAL_TIMEOUT;
;;;1112             goto error;
;;;1113           }
;;;1114         }
;;;1115       }
;;;1116     }
;;;1117     else
;;;1118     {
;;;1119       /* Transfer loop */
;;;1120       while (hspi->RxXferCount > 0U)
;;;1121       {
;;;1122         /* Check the RXNE flag */
;;;1123         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1124         {
;;;1125           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1126           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1127           hspi->RxXferCount--;
;;;1128         }
;;;1129         else
;;;1130         {
;;;1131           /* Timeout management */
;;;1132           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1133           {
;;;1134             errorcode = HAL_TIMEOUT;
;;;1135             goto error;
;;;1136           }
;;;1137         }
;;;1138       }
;;;1139     }
;;;1140   
;;;1141   #if (USE_SPI_CRC != 0U)
;;;1142     /* Handle the CRC Transmission */
;;;1143     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1144     {
;;;1145       /* freeze the CRC before the latest data */
;;;1146       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1147   
;;;1148       /* Read the latest data */
;;;1149       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1150       {
;;;1151         /* the latest data has not been received */
;;;1152         errorcode = HAL_TIMEOUT;
;;;1153         goto error;
;;;1154       }
;;;1155   
;;;1156       /* Receive last data in 16 Bit mode */
;;;1157       if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1158       {
;;;1159         *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1160       }
;;;1161       /* Receive last data in 8 Bit mode */
;;;1162       else
;;;1163       {
;;;1164         (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1165       }
;;;1166   
;;;1167       /* Wait the CRC data */
;;;1168       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1169       {
;;;1170         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1171         errorcode = HAL_TIMEOUT;
;;;1172         goto error;
;;;1173       }
;;;1174   
;;;1175       /* Read CRC to Flush DR and RXNE flag */
;;;1176       if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1177       {
;;;1178         /* Read 16bit CRC */
;;;1179         tmpreg = READ_REG(hspi->Instance->DR);
;;;1180         /* To avoid GCC warning */
;;;1181         UNUSED(tmpreg);
;;;1182       }
;;;1183       else
;;;1184       {
;;;1185         /* Read 8bit CRC */
;;;1186         tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
;;;1187         /* To avoid GCC warning */
;;;1188         UNUSED(tmpreg);
;;;1189   
;;;1190         if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
;;;1191         {
;;;1192           if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1193           {
;;;1194             /* Error on the CRC reception */
;;;1195             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1196             errorcode = HAL_TIMEOUT;
;;;1197             goto error;
;;;1198           }
;;;1199           /* Read 8bit CRC again in case of 16bit CRC in 8bit Data mode */
;;;1200           tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
;;;1201           /* To avoid GCC warning */
;;;1202           UNUSED(tmpreg);
;;;1203         }
;;;1204       }
;;;1205     }
;;;1206   #endif /* USE_SPI_CRC */
;;;1207   
;;;1208     /* Check the end of the transaction */
;;;1209     if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1210     {
;;;1211       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1212     }
;;;1213   
;;;1214   #if (USE_SPI_CRC != 0U)
;;;1215     /* Check if CRC error occurred */
;;;1216     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;1217     {
;;;1218       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1219       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1220     }
;;;1221   #endif /* USE_SPI_CRC */
;;;1222   
;;;1223     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;1224     {
;;;1225       errorcode = HAL_ERROR;
;;;1226     }
;;;1227   
;;;1228   error :
;;;1229     hspi->State = HAL_SPI_STATE_READY;
;;;1230     __HAL_UNLOCK(hspi);
;;;1231     return errorcode;
;;;1232   }
000058  e8bd9ffc          POP      {r2-r12,pc}
                  |L15.92|
00005c  2002              MOVS     r0,#2                 ;1024
00005e  e7fb              B        |L15.88|
                  |L15.96|
000060  f1ba0f00          CMP      r10,#0                ;1035
000064  d035              BEQ      |L15.210|
000066  f1b90f00          CMP      r9,#0                 ;1035
00006a  d032              BEQ      |L15.210|
00006c  f884b05d          STRB     r11,[r4,#0x5d]        ;1042
000070  f8c48060          STR      r8,[r4,#0x60]         ;1043
000074  f8c4a040          STR      r10,[r4,#0x40]        ;1044
000078  f8a49044          STRH     r9,[r4,#0x44]         ;1045
00007c  f8a49046          STRH     r9,[r4,#0x46]         ;1046
000080  f8c48038          STR      r8,[r4,#0x38]         ;1049
000084  f8a4803c          STRH     r8,[r4,#0x3c]         ;1050
000088  f8a4803e          STRH     r8,[r4,#0x3e]         ;1051
00008c  f8c4804c          STR      r8,[r4,#0x4c]         ;1052
000090  f8c48050          STR      r8,[r4,#0x50]         ;1053
000094  6aa0              LDR      r0,[r4,#0x28]         ;1057
000096  f44f5a00          MOV      r10,#0x2000           ;1057
00009a  4550              CMP      r0,r10                ;1057
00009c  d10e              BNE      |L15.188|
00009e  6820              LDR      r0,[r4,#0]            ;1059
0000a0  6801              LDR      r1,[r0,#0]            ;1059
0000a2  f4215100          BIC      r1,r1,#0x2000         ;1059
0000a6  6001              STR      r1,[r0,#0]            ;1059
0000a8  6820              LDR      r0,[r4,#0]            ;1059
0000aa  6801              LDR      r1,[r0,#0]            ;1059
0000ac  f4415100          ORR      r1,r1,#0x2000         ;1059
0000b0  6001              STR      r1,[r0,#0]            ;1059
0000b2  f8b40046          LDRH     r0,[r4,#0x46]         ;1061
0000b6  1e40              SUBS     r0,r0,#1              ;1061
0000b8  f8a40046          STRH     r0,[r4,#0x46]         ;1061
                  |L15.188|
0000bc  68e0              LDR      r0,[r4,#0xc]          ;1066
0000be  f44f69e0          MOV      r9,#0x700             ;1066
0000c2  4548              CMP      r0,r9                 ;1066
0000c4  d907              BLS      |L15.214|
0000c6  6820              LDR      r0,[r4,#0]            ;1069
0000c8  6841              LDR      r1,[r0,#4]            ;1069
0000ca  f4215180          BIC      r1,r1,#0x1000         ;1069
0000ce  6041              STR      r1,[r0,#4]            ;1069
0000d0  e006              B        |L15.224|
                  |L15.210|
0000d2  2601              MOVS     r6,#1                 ;1037
0000d4  e0bf              B        |L15.598|
                  |L15.214|
0000d6  6820              LDR      r0,[r4,#0]            ;1074
0000d8  6841              LDR      r1,[r0,#4]            ;1074
0000da  f4415180          ORR      r1,r1,#0x1000         ;1074
0000de  6041              STR      r1,[r0,#4]            ;1074
                  |L15.224|
0000e0  68a0              LDR      r0,[r4,#8]            ;1078
0000e2  f5b04f00          CMP      r0,#0x8000            ;1078
0000e6  d109              BNE      |L15.252|
0000e8  6820              LDR      r0,[r4,#0]            ;1081
0000ea  6801              LDR      r1,[r0,#0]            ;1081
0000ec  f0210140          BIC      r1,r1,#0x40           ;1081
0000f0  6001              STR      r1,[r0,#0]            ;1081
0000f2  6820              LDR      r0,[r4,#0]            ;1082
0000f4  6801              LDR      r1,[r0,#0]            ;1082
0000f6  f4214180          BIC      r1,r1,#0x4000         ;1082
0000fa  6001              STR      r1,[r0,#0]            ;1082
                  |L15.252|
0000fc  6820              LDR      r0,[r4,#0]            ;1086
0000fe  6801              LDR      r1,[r0,#0]            ;1086
000100  0649              LSLS     r1,r1,#25             ;1086
000102  d403              BMI      |L15.268|
000104  6801              LDR      r1,[r0,#0]            ;1089
000106  f0410140          ORR      r1,r1,#0x40           ;1089
00010a  6001              STR      r1,[r0,#0]            ;1089
                  |L15.268|
00010c  68e0              LDR      r0,[r4,#0xc]          ;1093
00010e  4548              CMP      r0,r9                 ;1093
000110  d918              BLS      |L15.324|
000112  e036              B        |L15.386|
                  |L15.276|
000114  6820              LDR      r0,[r4,#0]            ;1099
000116  6881              LDR      r1,[r0,#8]            ;1099
000118  07c9              LSLS     r1,r1,#31             ;1099
00011a  d00b              BEQ      |L15.308|
00011c  7b00              LDRB     r0,[r0,#0xc]          ;1102
00011e  6c21              LDR      r1,[r4,#0x40]         ;1102
000120  7008              STRB     r0,[r1,#0]            ;1102
000122  6c20              LDR      r0,[r4,#0x40]         ;1103
000124  1c40              ADDS     r0,r0,#1              ;1103
000126  6420              STR      r0,[r4,#0x40]         ;1103
000128  f8b40046          LDRH     r0,[r4,#0x46]         ;1104
00012c  1e40              SUBS     r0,r0,#1              ;1104
00012e  f8a40046          STRH     r0,[r4,#0x46]         ;1104
000132  e007              B        |L15.324|
                  |L15.308|
000134  f7fffffe          BL       HAL_GetTick
000138  1bc0              SUBS     r0,r0,r7              ;1109
00013a  42a8              CMP      r0,r5                 ;1109
00013c  d301              BCC      |L15.322|
00013e  1c68              ADDS     r0,r5,#1              ;1109
000140  d105              BNE      |L15.334|
                  |L15.322|
000142  b125              CBZ      r5,|L15.334|
                  |L15.324|
000144  f8b40046          LDRH     r0,[r4,#0x46]         ;1096
000148  2800              CMP      r0,#0                 ;1096
00014a  d1e3              BNE      |L15.276|
00014c  e01d              B        |L15.394|
                  |L15.334|
00014e  2603              MOVS     r6,#3                 ;1111
000150  e081              B        |L15.598|
                  |L15.338|
000152  6820              LDR      r0,[r4,#0]            ;1123
000154  6881              LDR      r1,[r0,#8]            ;1123
000156  07c9              LSLS     r1,r1,#31             ;1123
000158  d00b              BEQ      |L15.370|
00015a  68c0              LDR      r0,[r0,#0xc]          ;1125
00015c  6c21              LDR      r1,[r4,#0x40]         ;1125
00015e  8008              STRH     r0,[r1,#0]            ;1125
000160  6c20              LDR      r0,[r4,#0x40]         ;1126
000162  1c80              ADDS     r0,r0,#2              ;1126
000164  6420              STR      r0,[r4,#0x40]         ;1126
000166  f8b40046          LDRH     r0,[r4,#0x46]         ;1127
00016a  1e40              SUBS     r0,r0,#1              ;1127
00016c  f8a40046          STRH     r0,[r4,#0x46]         ;1127
000170  e007              B        |L15.386|
                  |L15.370|
000172  f7fffffe          BL       HAL_GetTick
000176  1bc0              SUBS     r0,r0,r7              ;1132
000178  42a8              CMP      r0,r5                 ;1132
00017a  d301              BCC      |L15.384|
00017c  1c68              ADDS     r0,r5,#1              ;1132
00017e  d116              BNE      |L15.430|
                  |L15.384|
000180  b1ad              CBZ      r5,|L15.430|
                  |L15.386|
000182  f8b40046          LDRH     r0,[r4,#0x46]         ;1120
000186  2800              CMP      r0,#0                 ;1120
000188  d1e3              BNE      |L15.338|
                  |L15.394|
00018a  6aa0              LDR      r0,[r4,#0x28]         ;1143
00018c  4550              CMP      r0,r10                ;1143
00018e  d14c              BNE      |L15.554|
000190  6820              LDR      r0,[r4,#0]            ;1146
000192  6801              LDR      r1,[r0,#0]            ;1146
000194  f4415180          ORR      r1,r1,#0x1000         ;1146
000198  6001              STR      r1,[r0,#0]            ;1146
00019a  2201              MOVS     r2,#1                 ;1149
00019c  462b              MOV      r3,r5                 ;1149
00019e  4611              MOV      r1,r2                 ;1149
0001a0  4620              MOV      r0,r4                 ;1149
0001a2  9700              STR      r7,[sp,#0]            ;1149
0001a4  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
0001a8  b118              CBZ      r0,|L15.434|
0001aa  2603              MOVS     r6,#3                 ;1152
0001ac  e053              B        |L15.598|
                  |L15.430|
0001ae  2603              MOVS     r6,#3                 ;1134
0001b0  e051              B        |L15.598|
                  |L15.434|
0001b2  68e0              LDR      r0,[r4,#0xc]          ;1157
0001b4  4548              CMP      r0,r9                 ;1157
0001b6  d904              BLS      |L15.450|
0001b8  6820              LDR      r0,[r4,#0]            ;1159
0001ba  68c0              LDR      r0,[r0,#0xc]          ;1159
0001bc  6c21              LDR      r1,[r4,#0x40]         ;1159
0001be  8008              STRH     r0,[r1,#0]            ;1159
0001c0  e003              B        |L15.458|
                  |L15.450|
0001c2  6820              LDR      r0,[r4,#0]            ;1164
0001c4  7b00              LDRB     r0,[r0,#0xc]          ;1164
0001c6  6c21              LDR      r1,[r4,#0x40]         ;1164
0001c8  7008              STRB     r0,[r1,#0]            ;1164
                  |L15.458|
0001ca  2201              MOVS     r2,#1                 ;1168
0001cc  462b              MOV      r3,r5                 ;1168
0001ce  4611              MOV      r1,r2                 ;1168
0001d0  4620              MOV      r0,r4                 ;1168
0001d2  9700              STR      r7,[sp,#0]            ;1168
0001d4  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
0001d8  b128              CBZ      r0,|L15.486|
0001da  6e20              LDR      r0,[r4,#0x60]         ;1170
0001dc  f0400002          ORR      r0,r0,#2              ;1170
0001e0  6620              STR      r0,[r4,#0x60]         ;1170
0001e2  2603              MOVS     r6,#3                 ;1171
0001e4  e037              B        |L15.598|
                  |L15.486|
0001e6  68e0              LDR      r0,[r4,#0xc]          ;1176
0001e8  f5b06f70          CMP      r0,#0xf00             ;1176
0001ec  d008              BEQ      |L15.512|
0001ee  6821              LDR      r1,[r4,#0]            ;1186
0001f0  7b09              LDRB     r1,[r1,#0xc]          ;1186
0001f2  9101              STR      r1,[sp,#4]            ;1186
0001f4  4548              CMP      r0,r9                 ;1190
0001f6  d118              BNE      |L15.554|
0001f8  6b20              LDR      r0,[r4,#0x30]         ;1190
0001fa  2802              CMP      r0,#2                 ;1190
0001fc  d004              BEQ      |L15.520|
0001fe  e014              B        |L15.554|
                  |L15.512|
000200  6820              LDR      r0,[r4,#0]            ;1179
000202  68c0              LDR      r0,[r0,#0xc]          ;1179
000204  9001              STR      r0,[sp,#4]            ;1179
000206  e010              B        |L15.554|
                  |L15.520|
000208  2201              MOVS     r2,#1                 ;1192
00020a  462b              MOV      r3,r5                 ;1192
00020c  4611              MOV      r1,r2                 ;1192
00020e  4620              MOV      r0,r4                 ;1192
000210  9700              STR      r7,[sp,#0]            ;1192
000212  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000216  b128              CBZ      r0,|L15.548|
000218  6e20              LDR      r0,[r4,#0x60]         ;1195
00021a  f0400002          ORR      r0,r0,#2              ;1195
00021e  6620              STR      r0,[r4,#0x60]         ;1195
000220  2603              MOVS     r6,#3                 ;1196
000222  e018              B        |L15.598|
                  |L15.548|
000224  6820              LDR      r0,[r4,#0]            ;1200
000226  7b00              LDRB     r0,[r0,#0xc]          ;1200
000228  9001              STR      r0,[sp,#4]            ;1200
                  |L15.554|
00022a  463a              MOV      r2,r7                 ;1209
00022c  4629              MOV      r1,r5                 ;1209
00022e  4620              MOV      r0,r4                 ;1209
000230  f7fffffe          BL       SPI_EndRxTransaction
000234  b108              CBZ      r0,|L15.570|
000236  2020              MOVS     r0,#0x20              ;1211
000238  6620              STR      r0,[r4,#0x60]         ;1211
                  |L15.570|
00023a  6820              LDR      r0,[r4,#0]            ;1216
00023c  6881              LDR      r1,[r0,#8]            ;1216
00023e  06c9              LSLS     r1,r1,#27             ;1216
000240  d506              BPL      |L15.592|
000242  6e21              LDR      r1,[r4,#0x60]         ;1218
000244  f0410102          ORR      r1,r1,#2              ;1218
000248  6621              STR      r1,[r4,#0x60]         ;1218
00024a  f64f71ef          MOV      r1,#0xffef            ;1219
00024e  6081              STR      r1,[r0,#8]            ;1219
                  |L15.592|
000250  6e20              LDR      r0,[r4,#0x60]         ;1223
000252  b100              CBZ      r0,|L15.598|
000254  2601              MOVS     r6,#1                 ;1225
                  |L15.598|
000256  2001              MOVS     r0,#1                 ;1229
000258  f884005d          STRB     r0,[r4,#0x5d]         ;1229
00025c  f884805c          STRB     r8,[r4,#0x5c]         ;1230
000260  4630              MOV      r0,r6                 ;1231
000262  e6f9              B        |L15.88|
;;;1233   
                          ENDP


                          AREA ||i.HAL_SPI_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_DMA PROC
;;;1976     */
;;;1977   HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1978   {
000004  4604              MOV      r4,r0
;;;1979     HAL_StatusTypeDef errorcode = HAL_OK;
000006  2500              MOVS     r5,#0
;;;1980   
;;;1981     /* Check rx dma handle */
;;;1982     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;1983   
;;;1984     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
000008  68a0              LDR      r0,[r4,#8]
;;;1985     {
;;;1986       hspi->State = HAL_SPI_STATE_BUSY_RX;
00000a  2304              MOVS     r3,#4
00000c  2800              CMP      r0,#0                 ;1984
00000e  d103              BNE      |L16.24|
000010  6866              LDR      r6,[r4,#4]            ;1984
000012  f5b67f82          CMP      r6,#0x104             ;1984
000016  d00e              BEQ      |L16.54|
                  |L16.24|
;;;1987   
;;;1988       /* Check tx dma handle */
;;;1989       assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1990   
;;;1991       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1992       return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
;;;1993     }
;;;1994   
;;;1995     /* Process Locked */
;;;1996     __HAL_LOCK(hspi);
000018  f894605c          LDRB     r6,[r4,#0x5c]
00001c  2e01              CMP      r6,#1
00001e  d013              BEQ      |L16.72|
000020  2701              MOVS     r7,#1
000022  f884705c          STRB     r7,[r4,#0x5c]
;;;1997   
;;;1998     if (hspi->State != HAL_SPI_STATE_READY)
000026  f894c05d          LDRB     r12,[r4,#0x5d]
00002a  2600              MOVS     r6,#0
00002c  f1bc0f01          CMP      r12,#1
000030  d00d              BEQ      |L16.78|
;;;1999     {
;;;2000       errorcode = HAL_BUSY;
000032  2502              MOVS     r5,#2
;;;2001       goto error;
000034  e09d              B        |L16.370|
                  |L16.54|
000036  f884305d          STRB     r3,[r4,#0x5d]         ;1986
00003a  4620              MOV      r0,r4                 ;1992
00003c  e8bd41f0          POP      {r4-r8,lr}            ;1992
000040  4613              MOV      r3,r2                 ;1992
000042  460a              MOV      r2,r1                 ;1992
000044  f7ffbffe          B.W      HAL_SPI_TransmitReceive_DMA
                  |L16.72|
000048  2002              MOVS     r0,#2                 ;1996
                  |L16.74|
;;;2002     }
;;;2003   
;;;2004     if ((pData == NULL) || (Size == 0U))
;;;2005     {
;;;2006       errorcode = HAL_ERROR;
;;;2007       goto error;
;;;2008     }
;;;2009   
;;;2010     /* Set the transaction information */
;;;2011     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;2012     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;2013     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;2014     hspi->RxXferSize  = Size;
;;;2015     hspi->RxXferCount = Size;
;;;2016   
;;;2017     /*Init field not used in handle to zero */
;;;2018     hspi->RxISR       = NULL;
;;;2019     hspi->TxISR       = NULL;
;;;2020     hspi->TxXferSize  = 0U;
;;;2021     hspi->TxXferCount = 0U;
;;;2022   
;;;2023     /* Configure communication direction : 1Line */
;;;2024     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;2025     {
;;;2026       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;2027       __HAL_SPI_DISABLE(hspi);
;;;2028       SPI_1LINE_RX(hspi);
;;;2029     }
;;;2030   
;;;2031   #if (USE_SPI_CRC != 0U)
;;;2032     /* Reset CRC Calculation */
;;;2033     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2034     {
;;;2035       SPI_RESET_CRC(hspi);
;;;2036     }
;;;2037   #endif /* USE_SPI_CRC */
;;;2038   
;;;2039   
;;;2040     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
;;;2041     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;2042     {
;;;2043       /* Set RX Fifo threshold according the reception data length: 16bit */
;;;2044       CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;2045     }
;;;2046     else
;;;2047     {
;;;2048       /* Set RX Fifo threshold according the reception data length: 8bit */
;;;2049       SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;2050   
;;;2051       if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
;;;2052       {
;;;2053         /* Set RX Fifo threshold according the reception data length: 16bit */
;;;2054         CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;2055   
;;;2056         if ((hspi->RxXferCount & 0x1U) == 0x0U)
;;;2057         {
;;;2058           CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
;;;2059           hspi->RxXferCount = hspi->RxXferCount >> 1U;
;;;2060         }
;;;2061         else
;;;2062         {
;;;2063           SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
;;;2064           hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
;;;2065         }
;;;2066       }
;;;2067     }
;;;2068   
;;;2069     /* Set the SPI RxDMA Half transfer complete callback */
;;;2070     hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;2071   
;;;2072     /* Set the SPI Rx DMA transfer complete callback */
;;;2073     hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
;;;2074   
;;;2075     /* Set the DMA error callback */
;;;2076     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;2077   
;;;2078     /* Set the DMA AbortCpltCallback */
;;;2079     hspi->hdmarx->XferAbortCallback = NULL;
;;;2080   
;;;2081     /* Enable the Rx DMA Stream/Channel  */
;;;2082     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;2083                                    hspi->RxXferCount))
;;;2084     {
;;;2085       /* Update SPI error code */
;;;2086       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;2087       errorcode = HAL_ERROR;
;;;2088   
;;;2089       hspi->State = HAL_SPI_STATE_READY;
;;;2090       goto error;
;;;2091     }
;;;2092   
;;;2093     /* Check if the SPI is already enabled */
;;;2094     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;2095     {
;;;2096       /* Enable SPI peripheral */
;;;2097       __HAL_SPI_ENABLE(hspi);
;;;2098     }
;;;2099   
;;;2100     /* Enable the SPI Error Interrupt Bit */
;;;2101     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;2102   
;;;2103     /* Enable Rx DMA Request */
;;;2104     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;2105   
;;;2106   error:
;;;2107     /* Process Unlocked */
;;;2108     __HAL_UNLOCK(hspi);
;;;2109     return errorcode;
;;;2110   }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.78|
00004e  b181              CBZ      r1,|L16.114|
000050  b17a              CBZ      r2,|L16.114|
000052  f884305d          STRB     r3,[r4,#0x5d]         ;2011
000056  6626              STR      r6,[r4,#0x60]         ;2012
000058  6421              STR      r1,[r4,#0x40]         ;2013
00005a  f8a42044          STRH     r2,[r4,#0x44]         ;2014
00005e  f8a42046          STRH     r2,[r4,#0x46]         ;2015
000062  64e6              STR      r6,[r4,#0x4c]         ;2018
000064  6526              STR      r6,[r4,#0x50]         ;2019
000066  87a6              STRH     r6,[r4,#0x3c]         ;2020
000068  87e6              STRH     r6,[r4,#0x3e]         ;2021
00006a  f5b04f00          CMP      r0,#0x8000            ;2024
00006e  d002              BEQ      |L16.118|
000070  e00b              B        |L16.138|
                  |L16.114|
000072  2501              MOVS     r5,#1                 ;2006
000074  e07d              B        |L16.370|
                  |L16.118|
000076  6820              LDR      r0,[r4,#0]            ;2027
000078  6801              LDR      r1,[r0,#0]            ;2027
00007a  f0210140          BIC      r1,r1,#0x40           ;2027
00007e  6001              STR      r1,[r0,#0]            ;2027
000080  6820              LDR      r0,[r4,#0]            ;2028
000082  6801              LDR      r1,[r0,#0]            ;2028
000084  f4214180          BIC      r1,r1,#0x4000         ;2028
000088  6001              STR      r1,[r0,#0]            ;2028
                  |L16.138|
00008a  6aa0              LDR      r0,[r4,#0x28]         ;2033
00008c  f5b05f00          CMP      r0,#0x2000            ;2033
000090  d109              BNE      |L16.166|
000092  6820              LDR      r0,[r4,#0]            ;2035
000094  6801              LDR      r1,[r0,#0]            ;2035
000096  f4215100          BIC      r1,r1,#0x2000         ;2035
00009a  6001              STR      r1,[r0,#0]            ;2035
00009c  6820              LDR      r0,[r4,#0]            ;2035
00009e  6801              LDR      r1,[r0,#0]            ;2035
0000a0  f4415100          ORR      r1,r1,#0x2000         ;2035
0000a4  6001              STR      r1,[r0,#0]            ;2035
                  |L16.166|
0000a6  6820              LDR      r0,[r4,#0]            ;2040
0000a8  6841              LDR      r1,[r0,#4]            ;2040
0000aa  f4215100          BIC      r1,r1,#0x2000         ;2040
0000ae  6041              STR      r1,[r0,#4]            ;2040
0000b0  68e0              LDR      r0,[r4,#0xc]          ;2041
0000b2  f5b06fe0          CMP      r0,#0x700             ;2041
0000b6  d905              BLS      |L16.196|
0000b8  6820              LDR      r0,[r4,#0]            ;2044
0000ba  6841              LDR      r1,[r0,#4]            ;2044
0000bc  f4215180          BIC      r1,r1,#0x1000         ;2044
0000c0  6041              STR      r1,[r0,#4]            ;2044
0000c2  e01d              B        |L16.256|
                  |L16.196|
0000c4  6820              LDR      r0,[r4,#0]            ;2049
0000c6  6841              LDR      r1,[r0,#4]            ;2049
0000c8  f4415180          ORR      r1,r1,#0x1000         ;2049
0000cc  6041              STR      r1,[r0,#4]            ;2049
0000ce  6da0              LDR      r0,[r4,#0x58]         ;2051
0000d0  6980              LDR      r0,[r0,#0x18]         ;2051
0000d2  f5b06f80          CMP      r0,#0x400             ;2051
0000d6  d113              BNE      |L16.256|
0000d8  6820              LDR      r0,[r4,#0]            ;2054
0000da  6841              LDR      r1,[r0,#4]            ;2054
0000dc  f4215180          BIC      r1,r1,#0x1000         ;2054
0000e0  6041              STR      r1,[r0,#4]            ;2054
0000e2  f8b40046          LDRH     r0,[r4,#0x46]         ;2056
0000e6  07c0              LSLS     r0,r0,#31             ;2056
0000e8  d026              BEQ      |L16.312|
0000ea  6820              LDR      r0,[r4,#0]            ;2063
0000ec  6841              LDR      r1,[r0,#4]            ;2063
0000ee  f4415100          ORR      r1,r1,#0x2000         ;2063
0000f2  6041              STR      r1,[r0,#4]            ;2063
0000f4  f8b40046          LDRH     r0,[r4,#0x46]         ;2064
0000f8  eb070050          ADD      r0,r7,r0,LSR #1       ;2064
0000fc  f8a40046          STRH     r0,[r4,#0x46]         ;2064
                  |L16.256|
000100  6da1              LDR      r1,[r4,#0x58]         ;2070
000102  481e              LDR      r0,|L16.380|
000104  6308              STR      r0,[r1,#0x30]         ;2070
000106  6da1              LDR      r1,[r4,#0x58]         ;2073
000108  481d              LDR      r0,|L16.384|
00010a  62c8              STR      r0,[r1,#0x2c]         ;2073
00010c  6da1              LDR      r1,[r4,#0x58]         ;2076
00010e  481d              LDR      r0,|L16.388|
000110  6348              STR      r0,[r1,#0x34]         ;2076
000112  6da0              LDR      r0,[r4,#0x58]         ;2079
000114  6386              STR      r6,[r0,#0x38]         ;2079
000116  f8b43046          LDRH     r3,[r4,#0x46]         ;2082
00011a  6821              LDR      r1,[r4,#0]            ;2082
00011c  6c22              LDR      r2,[r4,#0x40]         ;2082
00011e  310c              ADDS     r1,r1,#0xc            ;2082
000120  6da0              LDR      r0,[r4,#0x58]         ;2082
000122  f7fffffe          BL       HAL_DMA_Start_IT
000126  b190              CBZ      r0,|L16.334|
000128  6e20              LDR      r0,[r4,#0x60]         ;2086
00012a  f0400010          ORR      r0,r0,#0x10           ;2086
00012e  6620              STR      r0,[r4,#0x60]         ;2086
000130  2501              MOVS     r5,#1                 ;2087
000132  f884705d          STRB     r7,[r4,#0x5d]         ;2089
000136  e01c              B        |L16.370|
                  |L16.312|
000138  6820              LDR      r0,[r4,#0]            ;2058
00013a  6841              LDR      r1,[r0,#4]            ;2058
00013c  f4215100          BIC      r1,r1,#0x2000         ;2058
000140  6041              STR      r1,[r0,#4]            ;2058
000142  f8b40046          LDRH     r0,[r4,#0x46]         ;2059
000146  0840              LSRS     r0,r0,#1              ;2059
000148  f8a40046          STRH     r0,[r4,#0x46]         ;2059
00014c  e7d8              B        |L16.256|
                  |L16.334|
00014e  6820              LDR      r0,[r4,#0]            ;2094
000150  6801              LDR      r1,[r0,#0]            ;2094
000152  0649              LSLS     r1,r1,#25             ;2094
000154  d403              BMI      |L16.350|
000156  6801              LDR      r1,[r0,#0]            ;2097
000158  f0410140          ORR      r1,r1,#0x40           ;2097
00015c  6001              STR      r1,[r0,#0]            ;2097
                  |L16.350|
00015e  6820              LDR      r0,[r4,#0]            ;2101
000160  6841              LDR      r1,[r0,#4]            ;2101
000162  f0410120          ORR      r1,r1,#0x20           ;2101
000166  6041              STR      r1,[r0,#4]            ;2101
000168  6820              LDR      r0,[r4,#0]            ;2104
00016a  6841              LDR      r1,[r0,#4]            ;2104
00016c  f0410101          ORR      r1,r1,#1              ;2104
000170  6041              STR      r1,[r0,#4]            ;2104
                  |L16.370|
000172  f884605c          STRB     r6,[r4,#0x5c]         ;2108
000176  4628              MOV      r0,r5                 ;2109
000178  e767              B        |L16.74|
;;;2111   
                          ENDP

00017a  0000              DCW      0x0000
                  |L16.380|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L16.384|
                          DCD      SPI_DMAReceiveCplt
                  |L16.388|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_IT PROC
;;;1635     */
;;;1636   HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b4f0              PUSH     {r4-r7}
;;;1637   {
;;;1638     HAL_StatusTypeDef errorcode = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1639   
;;;1640     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
000004  6884              LDR      r4,[r0,#8]
;;;1641     {
;;;1642       hspi->State = HAL_SPI_STATE_BUSY_RX;
000006  2604              MOVS     r6,#4
000008  2c00              CMP      r4,#0                 ;1640
00000a  d103              BNE      |L17.20|
00000c  6844              LDR      r4,[r0,#4]            ;1640
00000e  f5b47f82          CMP      r4,#0x104             ;1640
000012  d00d              BEQ      |L17.48|
                  |L17.20|
;;;1643       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1644       return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
;;;1645     }
;;;1646   
;;;1647     /* Process Locked */
;;;1648     __HAL_LOCK(hspi);
000014  f890405c          LDRB     r4,[r0,#0x5c]
000018  2c01              CMP      r4,#1
00001a  d010              BEQ      |L17.62|
00001c  2501              MOVS     r5,#1
00001e  f880505c          STRB     r5,[r0,#0x5c]
;;;1649   
;;;1650     if (hspi->State != HAL_SPI_STATE_READY)
000022  f890705d          LDRB     r7,[r0,#0x5d]
000026  2400              MOVS     r4,#0
000028  2f01              CMP      r7,#1
00002a  d00b              BEQ      |L17.68|
;;;1651     {
;;;1652       errorcode = HAL_BUSY;
00002c  2302              MOVS     r3,#2
;;;1653       goto error;
00002e  e04d              B        |L17.204|
                  |L17.48|
000030  f880605d          STRB     r6,[r0,#0x5d]         ;1642
000034  bcf0              POP      {r4-r7}               ;1644
000036  4613              MOV      r3,r2                 ;1644
000038  460a              MOV      r2,r1                 ;1644
00003a  f7ffbffe          B.W      HAL_SPI_TransmitReceive_IT
                  |L17.62|
00003e  2002              MOVS     r0,#2                 ;1648
                  |L17.64|
;;;1654     }
;;;1655   
;;;1656     if ((pData == NULL) || (Size == 0U))
;;;1657     {
;;;1658       errorcode = HAL_ERROR;
;;;1659       goto error;
;;;1660     }
;;;1661   
;;;1662     /* Set the transaction information */
;;;1663     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1664     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1665     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1666     hspi->RxXferSize  = Size;
;;;1667     hspi->RxXferCount = Size;
;;;1668   
;;;1669     /* Init field not used in handle to zero */
;;;1670     hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1671     hspi->TxXferSize  = 0U;
;;;1672     hspi->TxXferCount = 0U;
;;;1673     hspi->TxISR       = NULL;
;;;1674   
;;;1675     /* Check the data size to adapt Rx threshold and the set the function for IT treatment */
;;;1676     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1677     {
;;;1678       /* Set RX Fifo threshold according the reception data length: 16 bit */
;;;1679       CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1680       hspi->RxISR = SPI_RxISR_16BIT;
;;;1681     }
;;;1682     else
;;;1683     {
;;;1684       /* Set RX Fifo threshold according the reception data length: 8 bit */
;;;1685       SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1686       hspi->RxISR = SPI_RxISR_8BIT;
;;;1687     }
;;;1688   
;;;1689     /* Configure communication direction : 1Line */
;;;1690     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1691     {
;;;1692       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1693       __HAL_SPI_DISABLE(hspi);
;;;1694       SPI_1LINE_RX(hspi);
;;;1695     }
;;;1696   
;;;1697   #if (USE_SPI_CRC != 0U)
;;;1698     /* Reset CRC Calculation */
;;;1699     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1700     {
;;;1701       hspi->CRCSize = 1U;
;;;1702       if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
;;;1703       {
;;;1704         hspi->CRCSize = 2U;
;;;1705       }
;;;1706       SPI_RESET_CRC(hspi);
;;;1707     }
;;;1708     else
;;;1709     {
;;;1710       hspi->CRCSize = 0U;
;;;1711     }
;;;1712   #endif /* USE_SPI_CRC */
;;;1713   
;;;1714     /* Enable TXE and ERR interrupt */
;;;1715     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
;;;1716   
;;;1717     /* Note : The SPI must be enabled after unlocking current process
;;;1718               to avoid the risk of SPI interrupt handle execution before current
;;;1719               process unlock */
;;;1720   
;;;1721     /* Check if the SPI is already enabled */
;;;1722     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1723     {
;;;1724       /* Enable SPI peripheral */
;;;1725       __HAL_SPI_ENABLE(hspi);
;;;1726     }
;;;1727   
;;;1728   error :
;;;1729     /* Process Unlocked */
;;;1730     __HAL_UNLOCK(hspi);
;;;1731     return errorcode;
;;;1732   }
000040  bcf0              POP      {r4-r7}
000042  4770              BX       lr
                  |L17.68|
000044  b1c9              CBZ      r1,|L17.122|
000046  b1c2              CBZ      r2,|L17.122|
000048  f880605d          STRB     r6,[r0,#0x5d]         ;1663
00004c  6604              STR      r4,[r0,#0x60]         ;1664
00004e  6401              STR      r1,[r0,#0x40]         ;1665
000050  f8a02044          STRH     r2,[r0,#0x44]         ;1666
000054  f8a02046          STRH     r2,[r0,#0x46]         ;1667
000058  6384              STR      r4,[r0,#0x38]         ;1670
00005a  8784              STRH     r4,[r0,#0x3c]         ;1671
00005c  87c4              STRH     r4,[r0,#0x3e]         ;1672
00005e  6504              STR      r4,[r0,#0x50]         ;1673
000060  68c1              LDR      r1,[r0,#0xc]          ;1676
000062  f44f62e0          MOV      r2,#0x700             ;1676
000066  4291              CMP      r1,r2                 ;1676
000068  d909              BLS      |L17.126|
00006a  6801              LDR      r1,[r0,#0]            ;1679
00006c  684e              LDR      r6,[r1,#4]            ;1679
00006e  f4265680          BIC      r6,r6,#0x1000         ;1679
000072  604e              STR      r6,[r1,#4]            ;1679
000074  4921              LDR      r1,|L17.252|
000076  64c1              STR      r1,[r0,#0x4c]         ;1680
000078  e008              B        |L17.140|
                  |L17.122|
00007a  2301              MOVS     r3,#1                 ;1658
00007c  e026              B        |L17.204|
                  |L17.126|
00007e  6801              LDR      r1,[r0,#0]            ;1685
000080  684e              LDR      r6,[r1,#4]            ;1685
000082  f4465680          ORR      r6,r6,#0x1000         ;1685
000086  604e              STR      r6,[r1,#4]            ;1685
000088  491d              LDR      r1,|L17.256|
00008a  64c1              STR      r1,[r0,#0x4c]         ;1686
                  |L17.140|
00008c  6881              LDR      r1,[r0,#8]            ;1690
00008e  f5b14f00          CMP      r1,#0x8000            ;1690
000092  d109              BNE      |L17.168|
000094  6801              LDR      r1,[r0,#0]            ;1693
000096  680e              LDR      r6,[r1,#0]            ;1693
000098  f0260640          BIC      r6,r6,#0x40           ;1693
00009c  600e              STR      r6,[r1,#0]            ;1693
00009e  6801              LDR      r1,[r0,#0]            ;1694
0000a0  680e              LDR      r6,[r1,#0]            ;1694
0000a2  f4264680          BIC      r6,r6,#0x4000         ;1694
0000a6  600e              STR      r6,[r1,#0]            ;1694
                  |L17.168|
0000a8  6a81              LDR      r1,[r0,#0x28]         ;1699
0000aa  f5b15f00          CMP      r1,#0x2000            ;1699
0000ae  d011              BEQ      |L17.212|
0000b0  6484              STR      r4,[r0,#0x48]         ;1710
                  |L17.178|
0000b2  6801              LDR      r1,[r0,#0]            ;1715
0000b4  684a              LDR      r2,[r1,#4]            ;1715
0000b6  f0420260          ORR      r2,r2,#0x60           ;1715
0000ba  604a              STR      r2,[r1,#4]            ;1715
0000bc  6801              LDR      r1,[r0,#0]            ;1722
0000be  680a              LDR      r2,[r1,#0]            ;1722
0000c0  0652              LSLS     r2,r2,#25             ;1722
0000c2  d403              BMI      |L17.204|
0000c4  680a              LDR      r2,[r1,#0]            ;1725
0000c6  f0420240          ORR      r2,r2,#0x40           ;1725
0000ca  600a              STR      r2,[r1,#0]            ;1725
                  |L17.204|
0000cc  f880405c          STRB     r4,[r0,#0x5c]         ;1730
0000d0  4618              MOV      r0,r3                 ;1731
0000d2  e7b5              B        |L17.64|
                  |L17.212|
0000d4  6485              STR      r5,[r0,#0x48]         ;1701
0000d6  68c1              LDR      r1,[r0,#0xc]          ;1702
0000d8  4291              CMP      r1,r2                 ;1702
0000da  d803              BHI      |L17.228|
0000dc  6b01              LDR      r1,[r0,#0x30]         ;1702
0000de  2902              CMP      r1,#2                 ;1702
0000e0  d100              BNE      |L17.228|
0000e2  6481              STR      r1,[r0,#0x48]         ;1704
                  |L17.228|
0000e4  6801              LDR      r1,[r0,#0]            ;1706
0000e6  680a              LDR      r2,[r1,#0]            ;1706
0000e8  f4225200          BIC      r2,r2,#0x2000         ;1706
0000ec  600a              STR      r2,[r1,#0]            ;1706
0000ee  6801              LDR      r1,[r0,#0]            ;1706
0000f0  680a              LDR      r2,[r1,#0]            ;1706
0000f2  f4425200          ORR      r2,r2,#0x2000         ;1706
0000f6  600a              STR      r2,[r1,#0]            ;1706
0000f8  e7db              B        |L17.178|
;;;1733   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L17.252|
                          DCD      SPI_RxISR_16BIT
                  |L17.256|
                          DCD      SPI_RxISR_8BIT

                          AREA ||i.HAL_SPI_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxCpltCallback PROC
;;;2837     */
;;;2838   __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2839   {
;;;2840     /* Prevent unused argument(s) compilation warning */
;;;2841     UNUSED(hspi);
;;;2842   
;;;2843     /* NOTE : This function should not be modified, when the callback is needed,
;;;2844               the HAL_SPI_RxCpltCallback should be implemented in the user file
;;;2845      */
;;;2846   }
;;;2847   
                          ENDP


                          AREA ||i.HAL_SPI_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxHalfCpltCallback PROC
;;;2885     */
;;;2886   __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2887   {
;;;2888     /* Prevent unused argument(s) compilation warning */
;;;2889     UNUSED(hspi);
;;;2890   
;;;2891     /* NOTE : This function should not be modified, when the callback is needed,
;;;2892               the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
;;;2893      */
;;;2894   }
;;;2895   
                          ENDP


                          AREA ||i.HAL_SPI_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Transmit PROC
;;;822      */
;;;823    HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;824    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
00000a  461d              MOV      r5,r3
;;;825      uint32_t tickstart;
;;;826      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  2600              MOVS     r6,#0
;;;827      uint16_t initial_TxXferCount;
;;;828    
;;;829      /* Check Direction parameter */
;;;830      assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;831    
;;;832      /* Process Locked */
;;;833      __HAL_LOCK(hspi);
00000e  f894005c          LDRB     r0,[r4,#0x5c]
000012  2801              CMP      r0,#1
000014  d00d              BEQ      |L20.50|
000016  f04f0901          MOV      r9,#1
00001a  f884905c          STRB     r9,[r4,#0x5c]
;;;834    
;;;835      /* Init tickstart for timeout management*/
;;;836      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4607              MOV      r7,r0
;;;837      initial_TxXferCount = Size;
;;;838    
;;;839      if (hspi->State != HAL_SPI_STATE_READY)
000024  f894005d          LDRB     r0,[r4,#0x5d]
000028  46b0              MOV      r8,r6
00002a  2801              CMP      r0,#1
00002c  d004              BEQ      |L20.56|
;;;840      {
;;;841        errorcode = HAL_BUSY;
00002e  2602              MOVS     r6,#2
;;;842        goto error;
000030  e0d5              B        |L20.478|
                  |L20.50|
000032  2002              MOVS     r0,#2                 ;833
                  |L20.52|
;;;843      }
;;;844    
;;;845      if ((pData == NULL) || (Size == 0U))
;;;846      {
;;;847        errorcode = HAL_ERROR;
;;;848        goto error;
;;;849      }
;;;850    
;;;851      /* Set the transaction information */
;;;852      hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;853      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;854      hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;855      hspi->TxXferSize  = Size;
;;;856      hspi->TxXferCount = Size;
;;;857    
;;;858      /*Init field not used in handle to zero */
;;;859      hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;860      hspi->RxXferSize  = 0U;
;;;861      hspi->RxXferCount = 0U;
;;;862      hspi->TxISR       = NULL;
;;;863      hspi->RxISR       = NULL;
;;;864    
;;;865      /* Configure communication direction : 1Line */
;;;866      if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;867      {
;;;868        /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;869        __HAL_SPI_DISABLE(hspi);
;;;870        SPI_1LINE_TX(hspi);
;;;871      }
;;;872    
;;;873    #if (USE_SPI_CRC != 0U)
;;;874      /* Reset CRC Calculation */
;;;875      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;876      {
;;;877        SPI_RESET_CRC(hspi);
;;;878      }
;;;879    #endif /* USE_SPI_CRC */
;;;880    
;;;881      /* Check if the SPI is already enabled */
;;;882      if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;883      {
;;;884        /* Enable SPI peripheral */
;;;885        __HAL_SPI_ENABLE(hspi);
;;;886      }
;;;887    
;;;888      /* Transmit data in 16 Bit mode */
;;;889      if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;890      {
;;;891        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;892        {
;;;893          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;894          hspi->pTxBuffPtr += sizeof(uint16_t);
;;;895          hspi->TxXferCount--;
;;;896        }
;;;897        /* Transmit data in 16 Bit mode */
;;;898        while (hspi->TxXferCount > 0U)
;;;899        {
;;;900          /* Wait until TXE flag is set to send data */
;;;901          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;902          {
;;;903            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;904            hspi->pTxBuffPtr += sizeof(uint16_t);
;;;905            hspi->TxXferCount--;
;;;906          }
;;;907          else
;;;908          {
;;;909            /* Timeout management */
;;;910            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;911            {
;;;912              errorcode = HAL_TIMEOUT;
;;;913              goto error;
;;;914            }
;;;915          }
;;;916        }
;;;917      }
;;;918      /* Transmit data in 8 Bit mode */
;;;919      else
;;;920      {
;;;921        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;922        {
;;;923          if (hspi->TxXferCount > 1U)
;;;924          {
;;;925            /* write on the data register in packing mode */
;;;926            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;927            hspi->pTxBuffPtr += sizeof(uint16_t);
;;;928            hspi->TxXferCount -= 2U;
;;;929          }
;;;930          else
;;;931          {
;;;932            *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;933            hspi->pTxBuffPtr ++;
;;;934            hspi->TxXferCount--;
;;;935          }
;;;936        }
;;;937        while (hspi->TxXferCount > 0U)
;;;938        {
;;;939          /* Wait until TXE flag is set to send data */
;;;940          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;941          {
;;;942            if (hspi->TxXferCount > 1U)
;;;943            {
;;;944              /* write on the data register in packing mode */
;;;945              hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;946              hspi->pTxBuffPtr += sizeof(uint16_t);
;;;947              hspi->TxXferCount -= 2U;
;;;948            }
;;;949            else
;;;950            {
;;;951              *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;952              hspi->pTxBuffPtr++;
;;;953              hspi->TxXferCount--;
;;;954            }
;;;955          }
;;;956          else
;;;957          {
;;;958            /* Timeout management */
;;;959            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;960            {
;;;961              errorcode = HAL_TIMEOUT;
;;;962              goto error;
;;;963            }
;;;964          }
;;;965        }
;;;966      }
;;;967    #if (USE_SPI_CRC != 0U)
;;;968      /* Enable CRC Transmission */
;;;969      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;970      {
;;;971        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;972      }
;;;973    #endif /* USE_SPI_CRC */
;;;974    
;;;975      /* Check the end of the transaction */
;;;976      if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;977      {
;;;978        hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;979      }
;;;980    
;;;981      /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;982      if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;983      {
;;;984        __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;985      }
;;;986    
;;;987      if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;988      {
;;;989        errorcode = HAL_ERROR;
;;;990      }
;;;991    
;;;992    error:
;;;993      hspi->State = HAL_SPI_STATE_READY;
;;;994      /* Process Unlocked */
;;;995      __HAL_UNLOCK(hspi);
;;;996      return errorcode;
;;;997    }
000034  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.56|
000038  f1ba0f00          CMP      r10,#0                ;845
00003c  d01c              BEQ      |L20.120|
00003e  ea5f000b          MOVS     r0,r11                ;845
000042  d019              BEQ      |L20.120|
000044  2003              MOVS     r0,#3                 ;852
000046  f884005d          STRB     r0,[r4,#0x5d]         ;852
00004a  f8c48060          STR      r8,[r4,#0x60]         ;853
00004e  f8c4a038          STR      r10,[r4,#0x38]        ;854
000052  f8a4b03c          STRH     r11,[r4,#0x3c]        ;855
000056  f8a4b03e          STRH     r11,[r4,#0x3e]        ;856
00005a  f8c48040          STR      r8,[r4,#0x40]         ;859
00005e  f8a48044          STRH     r8,[r4,#0x44]         ;860
000062  f8a48046          STRH     r8,[r4,#0x46]         ;861
000066  f8c48050          STR      r8,[r4,#0x50]         ;862
00006a  f8c4804c          STR      r8,[r4,#0x4c]         ;863
00006e  68a0              LDR      r0,[r4,#8]            ;866
000070  f5b04f00          CMP      r0,#0x8000            ;866
000074  d002              BEQ      |L20.124|
000076  e00b              B        |L20.144|
                  |L20.120|
000078  2601              MOVS     r6,#1                 ;847
00007a  e0b0              B        |L20.478|
                  |L20.124|
00007c  6820              LDR      r0,[r4,#0]            ;869
00007e  6801              LDR      r1,[r0,#0]            ;869
000080  f0210140          BIC      r1,r1,#0x40           ;869
000084  6001              STR      r1,[r0,#0]            ;869
000086  6820              LDR      r0,[r4,#0]            ;870
000088  6801              LDR      r1,[r0,#0]            ;870
00008a  f4414180          ORR      r1,r1,#0x4000         ;870
00008e  6001              STR      r1,[r0,#0]            ;870
                  |L20.144|
000090  6aa0              LDR      r0,[r4,#0x28]         ;875
000092  f44f5a00          MOV      r10,#0x2000           ;875
000096  4550              CMP      r0,r10                ;875
000098  d109              BNE      |L20.174|
00009a  6820              LDR      r0,[r4,#0]            ;877
00009c  6801              LDR      r1,[r0,#0]            ;877
00009e  f4215100          BIC      r1,r1,#0x2000         ;877
0000a2  6001              STR      r1,[r0,#0]            ;877
0000a4  6820              LDR      r0,[r4,#0]            ;877
0000a6  6801              LDR      r1,[r0,#0]            ;877
0000a8  f4415100          ORR      r1,r1,#0x2000         ;877
0000ac  6001              STR      r1,[r0,#0]            ;877
                  |L20.174|
0000ae  6820              LDR      r0,[r4,#0]            ;882
0000b0  6801              LDR      r1,[r0,#0]            ;882
0000b2  0649              LSLS     r1,r1,#25             ;882
0000b4  d403              BMI      |L20.190|
0000b6  6801              LDR      r1,[r0,#0]            ;885
0000b8  f0410140          ORR      r1,r1,#0x40           ;885
0000bc  6001              STR      r1,[r0,#0]            ;885
                  |L20.190|
0000be  68e0              LDR      r0,[r4,#0xc]          ;889
0000c0  f5b06fe0          CMP      r0,#0x700             ;889
0000c4  d92b              BLS      |L20.286|
0000c6  6860              LDR      r0,[r4,#4]            ;891
0000c8  b110              CBZ      r0,|L20.208|
0000ca  f1bb0f01          CMP      r11,#1                ;891
0000ce  d120              BNE      |L20.274|
                  |L20.208|
0000d0  6ba0              LDR      r0,[r4,#0x38]         ;893
0000d2  6821              LDR      r1,[r4,#0]            ;893
0000d4  8800              LDRH     r0,[r0,#0]            ;893
0000d6  60c8              STR      r0,[r1,#0xc]          ;893
0000d8  6ba0              LDR      r0,[r4,#0x38]         ;894
0000da  1c80              ADDS     r0,r0,#2              ;894
0000dc  63a0              STR      r0,[r4,#0x38]         ;894
0000de  8fe0              LDRH     r0,[r4,#0x3e]         ;895
0000e0  1e40              SUBS     r0,r0,#1              ;895
0000e2  87e0              STRH     r0,[r4,#0x3e]         ;895
0000e4  e015              B        |L20.274|
                  |L20.230|
0000e6  6820              LDR      r0,[r4,#0]            ;901
0000e8  6881              LDR      r1,[r0,#8]            ;901
0000ea  0789              LSLS     r1,r1,#30             ;901
0000ec  d509              BPL      |L20.258|
0000ee  6ba1              LDR      r1,[r4,#0x38]         ;903
0000f0  8809              LDRH     r1,[r1,#0]            ;903
0000f2  60c1              STR      r1,[r0,#0xc]          ;903
0000f4  6ba0              LDR      r0,[r4,#0x38]         ;904
0000f6  1c80              ADDS     r0,r0,#2              ;904
0000f8  63a0              STR      r0,[r4,#0x38]         ;904
0000fa  8fe0              LDRH     r0,[r4,#0x3e]         ;905
0000fc  1e40              SUBS     r0,r0,#1              ;905
0000fe  87e0              STRH     r0,[r4,#0x3e]         ;905
000100  e007              B        |L20.274|
                  |L20.258|
000102  f7fffffe          BL       HAL_GetTick
000106  1bc0              SUBS     r0,r0,r7              ;910
000108  42a8              CMP      r0,r5                 ;910
00010a  d301              BCC      |L20.272|
00010c  1c68              ADDS     r0,r5,#1              ;910
00010e  d104              BNE      |L20.282|
                  |L20.272|
000110  b11d              CBZ      r5,|L20.282|
                  |L20.274|
000112  8fe0              LDRH     r0,[r4,#0x3e]         ;898
000114  2800              CMP      r0,#0                 ;898
000116  d1e6              BNE      |L20.230|
000118  e045              B        |L20.422|
                  |L20.282|
00011a  2603              MOVS     r6,#3                 ;912
00011c  e05f              B        |L20.478|
                  |L20.286|
00011e  6860              LDR      r0,[r4,#4]            ;921
000120  b110              CBZ      r0,|L20.296|
000122  f1bb0f01          CMP      r11,#1                ;921
000126  d13b              BNE      |L20.416|
                  |L20.296|
000128  8fe0              LDRH     r0,[r4,#0x3e]         ;923
00012a  2801              CMP      r0,#1                 ;923
00012c  d90a              BLS      |L20.324|
00012e  6ba0              LDR      r0,[r4,#0x38]         ;926
000130  6821              LDR      r1,[r4,#0]            ;926
000132  8800              LDRH     r0,[r0,#0]            ;926
000134  60c8              STR      r0,[r1,#0xc]          ;926
000136  6ba0              LDR      r0,[r4,#0x38]         ;927
000138  1c80              ADDS     r0,r0,#2              ;927
00013a  63a0              STR      r0,[r4,#0x38]         ;927
00013c  8fe0              LDRH     r0,[r4,#0x3e]         ;928
00013e  1e80              SUBS     r0,r0,#2              ;928
000140  87e0              STRH     r0,[r4,#0x3e]         ;928
000142  e02d              B        |L20.416|
                  |L20.324|
000144  6ba0              LDR      r0,[r4,#0x38]         ;932
000146  6821              LDR      r1,[r4,#0]            ;932
000148  7800              LDRB     r0,[r0,#0]            ;932
00014a  7308              STRB     r0,[r1,#0xc]          ;932
00014c  6ba0              LDR      r0,[r4,#0x38]         ;933
00014e  1c40              ADDS     r0,r0,#1              ;933
000150  63a0              STR      r0,[r4,#0x38]         ;933
000152  8fe0              LDRH     r0,[r4,#0x3e]         ;934
000154  1e40              SUBS     r0,r0,#1              ;934
000156  87e0              STRH     r0,[r4,#0x3e]         ;934
000158  e022              B        |L20.416|
                  |L20.346|
00015a  6820              LDR      r0,[r4,#0]            ;940
00015c  6881              LDR      r1,[r0,#8]            ;940
00015e  0789              LSLS     r1,r1,#30             ;940
000160  d516              BPL      |L20.400|
000162  8fe1              LDRH     r1,[r4,#0x3e]         ;942
000164  2901              CMP      r1,#1                 ;942
000166  d909              BLS      |L20.380|
000168  6ba1              LDR      r1,[r4,#0x38]         ;945
00016a  8809              LDRH     r1,[r1,#0]            ;945
00016c  60c1              STR      r1,[r0,#0xc]          ;945
00016e  6ba0              LDR      r0,[r4,#0x38]         ;946
000170  1c80              ADDS     r0,r0,#2              ;946
000172  63a0              STR      r0,[r4,#0x38]         ;946
000174  8fe0              LDRH     r0,[r4,#0x3e]         ;947
000176  1e80              SUBS     r0,r0,#2              ;947
000178  87e0              STRH     r0,[r4,#0x3e]         ;947
00017a  e011              B        |L20.416|
                  |L20.380|
00017c  6ba1              LDR      r1,[r4,#0x38]         ;951
00017e  7809              LDRB     r1,[r1,#0]            ;951
000180  7301              STRB     r1,[r0,#0xc]          ;951
000182  6ba0              LDR      r0,[r4,#0x38]         ;952
000184  1c40              ADDS     r0,r0,#1              ;952
000186  63a0              STR      r0,[r4,#0x38]         ;952
000188  8fe0              LDRH     r0,[r4,#0x3e]         ;953
00018a  1e40              SUBS     r0,r0,#1              ;953
00018c  87e0              STRH     r0,[r4,#0x3e]         ;953
00018e  e007              B        |L20.416|
                  |L20.400|
000190  f7fffffe          BL       HAL_GetTick
000194  1bc0              SUBS     r0,r0,r7              ;959
000196  42a8              CMP      r0,r5                 ;959
000198  d301              BCC      |L20.414|
00019a  1c68              ADDS     r0,r5,#1              ;959
00019c  d116              BNE      |L20.460|
                  |L20.414|
00019e  b1ad              CBZ      r5,|L20.460|
                  |L20.416|
0001a0  8fe0              LDRH     r0,[r4,#0x3e]         ;937
0001a2  2800              CMP      r0,#0                 ;937
0001a4  d1d9              BNE      |L20.346|
                  |L20.422|
0001a6  6aa0              LDR      r0,[r4,#0x28]         ;969
0001a8  4550              CMP      r0,r10                ;969
0001aa  d104              BNE      |L20.438|
0001ac  6820              LDR      r0,[r4,#0]            ;971
0001ae  6801              LDR      r1,[r0,#0]            ;971
0001b0  f4415180          ORR      r1,r1,#0x1000         ;971
0001b4  6001              STR      r1,[r0,#0]            ;971
                  |L20.438|
0001b6  463a              MOV      r2,r7                 ;976
0001b8  4629              MOV      r1,r5                 ;976
0001ba  4620              MOV      r0,r4                 ;976
0001bc  f7fffffe          BL       SPI_EndRxTxTransaction
0001c0  b108              CBZ      r0,|L20.454|
0001c2  2020              MOVS     r0,#0x20              ;978
0001c4  6620              STR      r0,[r4,#0x60]         ;978
                  |L20.454|
0001c6  68a0              LDR      r0,[r4,#8]            ;982
0001c8  b110              CBZ      r0,|L20.464|
0001ca  e005              B        |L20.472|
                  |L20.460|
0001cc  2603              MOVS     r6,#3                 ;961
0001ce  e006              B        |L20.478|
                  |L20.464|
0001d0  6820              LDR      r0,[r4,#0]            ;984
0001d2  68c1              LDR      r1,[r0,#0xc]          ;984
0001d4  6880              LDR      r0,[r0,#8]            ;984
0001d6  9000              STR      r0,[sp,#0]            ;984
                  |L20.472|
0001d8  6e20              LDR      r0,[r4,#0x60]         ;987
0001da  b100              CBZ      r0,|L20.478|
0001dc  2601              MOVS     r6,#1                 ;989
                  |L20.478|
0001de  f884905d          STRB     r9,[r4,#0x5d]         ;993
0001e2  f884805c          STRB     r8,[r4,#0x5c]         ;995
0001e6  4630              MOV      r0,r6                 ;996
0001e8  e724              B        |L20.52|
;;;998    
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TransmitReceive PROC
;;;1243     */
;;;1244   HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1245                                             uint32_t Timeout)
;;;1246   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  9e10              LDR      r6,[sp,#0x40]
00000a  4698              MOV      r8,r3
;;;1247   #if (USE_SPI_CRC != 0U)
;;;1248     __IO uint32_t tmpreg = 0U;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;1249   #endif /* USE_SPI_CRC */
;;;1250     uint16_t             initial_TxXferCount;
;;;1251     uint16_t             initial_RxXferCount;
;;;1252     uint32_t             tmp_mode;
;;;1253     HAL_SPI_StateTypeDef tmp_state;
;;;1254     uint32_t             tickstart;
;;;1255   #if (USE_SPI_CRC != 0U)
;;;1256     uint32_t             spi_cr1;
;;;1257     uint32_t             spi_cr2;
;;;1258   #endif /* USE_SPI_CRC */
;;;1259   
;;;1260     /* Variable used to alternate Rx and Tx during transfer */
;;;1261     uint32_t             txallowed = 1U;
000010  2501              MOVS     r5,#1
;;;1262     HAL_StatusTypeDef    errorcode = HAL_OK;
000012  2700              MOVS     r7,#0
;;;1263   
;;;1264     /* Check Direction parameter */
;;;1265     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1266   
;;;1267     /* Process Locked */
;;;1268     __HAL_LOCK(hspi);
000014  f894005c          LDRB     r0,[r4,#0x5c]
000018  2801              CMP      r0,#1
00001a  d014              BEQ      |L21.70|
00001c  2001              MOVS     r0,#1
00001e  f884005c          STRB     r0,[r4,#0x5c]
;;;1269   
;;;1270     /* Init tickstart for timeout management*/
;;;1271     tickstart = HAL_GetTick();
000022  f7fffffe          BL       HAL_GetTick
000026  4681              MOV      r9,r0
;;;1272   
;;;1273     /* Init temporary variables */
;;;1274     tmp_state           = hspi->State;
000028  f894205d          LDRB     r2,[r4,#0x5d]
;;;1275     tmp_mode            = hspi->Init.Mode;
00002c  6863              LDR      r3,[r4,#4]
;;;1276     initial_TxXferCount = Size;
;;;1277     initial_RxXferCount = Size;
00002e  4641              MOV      r1,r8
;;;1278   #if (USE_SPI_CRC != 0U)
;;;1279     spi_cr1             = READ_REG(hspi->Instance->CR1);
000030  6820              LDR      r0,[r4,#0]
000032  f8d0a000          LDR      r10,[r0,#0]
;;;1280     spi_cr2             = READ_REG(hspi->Instance->CR2);
000036  f8d0b004          LDR      r11,[r0,#4]
;;;1281   #endif /* USE_SPI_CRC */
;;;1282   
;;;1283     if (!((tmp_state == HAL_SPI_STATE_READY) || \
00003a  2a01              CMP      r2,#1
00003c  d00d              BEQ      |L21.90|
00003e  f5b37f82          CMP      r3,#0x104
000042  d108              BNE      |L21.86|
000044  e003              B        |L21.78|
                  |L21.70|
000046  2002              MOVS     r0,#2                 ;1268
                  |L21.72|
;;;1284           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1285     {
;;;1286       errorcode = HAL_BUSY;
;;;1287       goto error;
;;;1288     }
;;;1289   
;;;1290     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1291     {
;;;1292       errorcode = HAL_ERROR;
;;;1293       goto error;
;;;1294     }
;;;1295   
;;;1296     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1297     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1298     {
;;;1299       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1300     }
;;;1301   
;;;1302     /* Set the transaction information */
;;;1303     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1304     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1305     hspi->RxXferCount = Size;
;;;1306     hspi->RxXferSize  = Size;
;;;1307     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1308     hspi->TxXferCount = Size;
;;;1309     hspi->TxXferSize  = Size;
;;;1310   
;;;1311     /*Init field not used in handle to zero */
;;;1312     hspi->RxISR       = NULL;
;;;1313     hspi->TxISR       = NULL;
;;;1314   
;;;1315   #if (USE_SPI_CRC != 0U)
;;;1316     /* Reset CRC Calculation */
;;;1317     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1318     {
;;;1319       SPI_RESET_CRC(hspi);
;;;1320     }
;;;1321   #endif /* USE_SPI_CRC */
;;;1322   
;;;1323     /* Set the Rx Fifo threshold */
;;;1324     if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
;;;1325     {
;;;1326       /* Set fiforxthreshold according the reception data length: 16bit */
;;;1327       CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1328     }
;;;1329     else
;;;1330     {
;;;1331       /* Set fiforxthreshold according the reception data length: 8bit */
;;;1332       SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1333     }
;;;1334   
;;;1335     /* Check if the SPI is already enabled */
;;;1336     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1337     {
;;;1338       /* Enable SPI peripheral */
;;;1339       __HAL_SPI_ENABLE(hspi);
;;;1340     }
;;;1341   
;;;1342     /* Transmit and Receive data in 16 Bit mode */
;;;1343     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1344     {
;;;1345       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1346       {
;;;1347         hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1348         hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1349         hspi->TxXferCount--;
;;;1350       }
;;;1351       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1352       {
;;;1353         /* Check TXE flag */
;;;1354         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1355         {
;;;1356           hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1357           hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1358           hspi->TxXferCount--;
;;;1359           /* Next Data is a reception (Rx). Tx not allowed */
;;;1360           txallowed = 0U;
;;;1361   
;;;1362   #if (USE_SPI_CRC != 0U)
;;;1363           /* Enable CRC Transmission */
;;;1364           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1365           {
;;;1366             /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
;;;1367             if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
;;;1368             {
;;;1369               SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
;;;1370             }
;;;1371             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1372           }
;;;1373   #endif /* USE_SPI_CRC */
;;;1374         }
;;;1375   
;;;1376         /* Check RXNE flag */
;;;1377         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1378         {
;;;1379           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1380           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1381           hspi->RxXferCount--;
;;;1382           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1383           txallowed = 1U;
;;;1384         }
;;;1385         if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
;;;1386         {
;;;1387           errorcode = HAL_TIMEOUT;
;;;1388           goto error;
;;;1389         }
;;;1390       }
;;;1391     }
;;;1392     /* Transmit and Receive data in 8 Bit mode */
;;;1393     else
;;;1394     {
;;;1395       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1396       {
;;;1397         if (hspi->TxXferCount > 1U)
;;;1398         {
;;;1399           hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1400           hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1401           hspi->TxXferCount -= 2U;
;;;1402         }
;;;1403         else
;;;1404         {
;;;1405           *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
;;;1406           hspi->pTxBuffPtr++;
;;;1407           hspi->TxXferCount--;
;;;1408         }
;;;1409       }
;;;1410       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1411       {
;;;1412         /* Check TXE flag */
;;;1413         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1414         {
;;;1415           if (hspi->TxXferCount > 1U)
;;;1416           {
;;;1417             hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1418             hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1419             hspi->TxXferCount -= 2U;
;;;1420           }
;;;1421           else
;;;1422           {
;;;1423             *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
;;;1424             hspi->pTxBuffPtr++;
;;;1425             hspi->TxXferCount--;
;;;1426           }
;;;1427           /* Next Data is a reception (Rx). Tx not allowed */
;;;1428           txallowed = 0U;
;;;1429   
;;;1430   #if (USE_SPI_CRC != 0U)
;;;1431           /* Enable CRC Transmission */
;;;1432           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1433           {
;;;1434             /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
;;;1435             if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
;;;1436             {
;;;1437               SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
;;;1438             }
;;;1439             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1440           }
;;;1441   #endif /* USE_SPI_CRC */
;;;1442         }
;;;1443   
;;;1444         /* Wait until RXNE flag is reset */
;;;1445         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1446         {
;;;1447           if (hspi->RxXferCount > 1U)
;;;1448           {
;;;1449             *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1450             hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1451             hspi->RxXferCount -= 2U;
;;;1452             if (hspi->RxXferCount <= 1U)
;;;1453             {
;;;1454               /* Set RX Fifo threshold before to switch on 8 bit data size */
;;;1455               SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1456             }
;;;1457           }
;;;1458           else
;;;1459           {
;;;1460             (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1461             hspi->pRxBuffPtr++;
;;;1462             hspi->RxXferCount--;
;;;1463           }
;;;1464           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1465           txallowed = 1U;
;;;1466         }
;;;1467         if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
;;;1468         {
;;;1469           errorcode = HAL_TIMEOUT;
;;;1470           goto error;
;;;1471         }
;;;1472       }
;;;1473     }
;;;1474   
;;;1475   #if (USE_SPI_CRC != 0U)
;;;1476     /* Read CRC from DR to close CRC calculation process */
;;;1477     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1478     {
;;;1479       /* Wait until TXE flag */
;;;1480       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1481       {
;;;1482         /* Error on the CRC reception */
;;;1483         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1484         errorcode = HAL_TIMEOUT;
;;;1485         goto error;
;;;1486       }
;;;1487       /* Read CRC */
;;;1488       if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1489       {
;;;1490         /* Read 16bit CRC */
;;;1491         tmpreg = READ_REG(hspi->Instance->DR);
;;;1492         /* To avoid GCC warning */
;;;1493         UNUSED(tmpreg);
;;;1494       }
;;;1495       else
;;;1496       {
;;;1497         /* Read 8bit CRC */
;;;1498         tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
;;;1499         /* To avoid GCC warning */
;;;1500         UNUSED(tmpreg);
;;;1501   
;;;1502         if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
;;;1503         {
;;;1504           if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1505           {
;;;1506             /* Error on the CRC reception */
;;;1507             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1508             errorcode = HAL_TIMEOUT;
;;;1509             goto error;
;;;1510           }
;;;1511           /* Read 8bit CRC again in case of 16bit CRC in 8bit Data mode */
;;;1512           tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
;;;1513           /* To avoid GCC warning */
;;;1514           UNUSED(tmpreg);
;;;1515         }
;;;1516       }
;;;1517     }
;;;1518   
;;;1519     /* Check if CRC error occurred */
;;;1520     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;1521     {
;;;1522       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1523       /* Clear CRC Flag */
;;;1524       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1525   
;;;1526       errorcode = HAL_ERROR;
;;;1527     }
;;;1528   #endif /* USE_SPI_CRC */
;;;1529   
;;;1530     /* Check the end of the transaction */
;;;1531     if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1532     {
;;;1533       errorcode = HAL_ERROR;
;;;1534       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1535     }
;;;1536   
;;;1537   error :
;;;1538     hspi->State = HAL_SPI_STATE_READY;
;;;1539     __HAL_UNLOCK(hspi);
;;;1540     return errorcode;
;;;1541   }
000048  b007              ADD      sp,sp,#0x1c
00004a  e8bd8ff0          POP      {r4-r11,pc}
                  |L21.78|
00004e  68a3              LDR      r3,[r4,#8]            ;1283
000050  b90b              CBNZ     r3,|L21.86|
000052  2a04              CMP      r2,#4                 ;1283
000054  d001              BEQ      |L21.90|
                  |L21.86|
000056  2702              MOVS     r7,#2                 ;1286
000058  e17c              B        |L21.852|
                  |L21.90|
00005a  9a04              LDR      r2,[sp,#0x10]         ;1290
00005c  b3b2              CBZ      r2,|L21.204|
00005e  9a05              LDR      r2,[sp,#0x14]         ;1290
000060  b3a2              CBZ      r2,|L21.204|
000062  f1b80f00          CMP      r8,#0                 ;1290
000066  d032              BEQ      |L21.206|
000068  f894205d          LDRB     r2,[r4,#0x5d]         ;1297
00006c  2a04              CMP      r2,#4                 ;1297
00006e  d002              BEQ      |L21.118|
000070  2205              MOVS     r2,#5                 ;1299
000072  f884205d          STRB     r2,[r4,#0x5d]         ;1299
                  |L21.118|
000076  2200              MOVS     r2,#0                 ;1303
000078  6622              STR      r2,[r4,#0x60]         ;1303
00007a  9b05              LDR      r3,[sp,#0x14]         ;1304
00007c  6423              STR      r3,[r4,#0x40]         ;1304
00007e  f8a48046          STRH     r8,[r4,#0x46]         ;1305
000082  f8a48044          STRH     r8,[r4,#0x44]         ;1306
000086  9b04              LDR      r3,[sp,#0x10]         ;1307
000088  63a3              STR      r3,[r4,#0x38]         ;1307
00008a  f8a4803e          STRH     r8,[r4,#0x3e]         ;1308
00008e  f8a4803c          STRH     r8,[r4,#0x3c]         ;1309
000092  64e2              STR      r2,[r4,#0x4c]         ;1312
000094  6522              STR      r2,[r4,#0x50]         ;1313
000096  6aa2              LDR      r2,[r4,#0x28]         ;1317
000098  f44f5800          MOV      r8,#0x2000            ;1317
00009c  4542              CMP      r2,r8                 ;1317
00009e  d108              BNE      |L21.178|
0000a0  6802              LDR      r2,[r0,#0]            ;1319
0000a2  f4225200          BIC      r2,r2,#0x2000         ;1319
0000a6  6002              STR      r2,[r0,#0]            ;1319
0000a8  6820              LDR      r0,[r4,#0]            ;1319
0000aa  6802              LDR      r2,[r0,#0]            ;1319
0000ac  f4425200          ORR      r2,r2,#0x2000         ;1319
0000b0  6002              STR      r2,[r0,#0]            ;1319
                  |L21.178|
0000b2  68e0              LDR      r0,[r4,#0xc]          ;1324
0000b4  f44f62e0          MOV      r2,#0x700             ;1324
0000b8  4290              CMP      r0,r2                 ;1324
0000ba  d801              BHI      |L21.192|
0000bc  2901              CMP      r1,#1                 ;1324
0000be  d908              BLS      |L21.210|
                  |L21.192|
0000c0  6820              LDR      r0,[r4,#0]            ;1327
0000c2  6843              LDR      r3,[r0,#4]            ;1327
0000c4  f4235380          BIC      r3,r3,#0x1000         ;1327
0000c8  6043              STR      r3,[r0,#4]            ;1327
0000ca  e007              B        |L21.220|
                  |L21.204|
0000cc  e7ff              B        |L21.206|
                  |L21.206|
0000ce  2701              MOVS     r7,#1                 ;1292
0000d0  e140              B        |L21.852|
                  |L21.210|
0000d2  6820              LDR      r0,[r4,#0]            ;1332
0000d4  6843              LDR      r3,[r0,#4]            ;1332
0000d6  f4435380          ORR      r3,r3,#0x1000         ;1332
0000da  6043              STR      r3,[r0,#4]            ;1332
                  |L21.220|
0000dc  6820              LDR      r0,[r4,#0]            ;1336
0000de  6803              LDR      r3,[r0,#0]            ;1336
0000e0  065b              LSLS     r3,r3,#25             ;1336
0000e2  d403              BMI      |L21.236|
0000e4  6803              LDR      r3,[r0,#0]            ;1339
0000e6  f0430340          ORR      r3,r3,#0x40           ;1339
0000ea  6003              STR      r3,[r0,#0]            ;1339
                  |L21.236|
0000ec  68e0              LDR      r0,[r4,#0xc]          ;1343
0000ee  4290              CMP      r0,r2                 ;1343
0000f0  d95a              BLS      |L21.424|
0000f2  6860              LDR      r0,[r4,#4]            ;1345
0000f4  b108              CBZ      r0,|L21.250|
0000f6  2901              CMP      r1,#1                 ;1345
0000f8  d14e              BNE      |L21.408|
                  |L21.250|
0000fa  6ba0              LDR      r0,[r4,#0x38]         ;1347
0000fc  6821              LDR      r1,[r4,#0]            ;1347
0000fe  8800              LDRH     r0,[r0,#0]            ;1347
000100  60c8              STR      r0,[r1,#0xc]          ;1347
000102  6ba0              LDR      r0,[r4,#0x38]         ;1348
000104  1c80              ADDS     r0,r0,#2              ;1348
000106  63a0              STR      r0,[r4,#0x38]         ;1348
000108  8fe0              LDRH     r0,[r4,#0x3e]         ;1349
00010a  1e40              SUBS     r0,r0,#1              ;1349
00010c  87e0              STRH     r0,[r4,#0x3e]         ;1349
00010e  e043              B        |L21.408|
                  |L21.272|
000110  6820              LDR      r0,[r4,#0]            ;1354
000112  6881              LDR      r1,[r0,#8]            ;1354
000114  0789              LSLS     r1,r1,#30             ;1354
000116  d522              BPL      |L21.350|
000118  8fe1              LDRH     r1,[r4,#0x3e]         ;1354
00011a  b301              CBZ      r1,|L21.350|
00011c  2d01              CMP      r5,#1                 ;1354
00011e  d11e              BNE      |L21.350|
000120  6ba1              LDR      r1,[r4,#0x38]         ;1356
000122  8809              LDRH     r1,[r1,#0]            ;1356
000124  60c1              STR      r1,[r0,#0xc]          ;1356
000126  6ba0              LDR      r0,[r4,#0x38]         ;1357
000128  1c80              ADDS     r0,r0,#2              ;1357
00012a  63a0              STR      r0,[r4,#0x38]         ;1357
00012c  8fe0              LDRH     r0,[r4,#0x3e]         ;1358
00012e  1e40              SUBS     r0,r0,#1              ;1358
000130  87e0              STRH     r0,[r4,#0x3e]         ;1358
000132  2500              MOVS     r5,#0                 ;1360
000134  8fe0              LDRH     r0,[r4,#0x3e]         ;1364
000136  b990              CBNZ     r0,|L21.350|
000138  6aa0              LDR      r0,[r4,#0x28]         ;1364
00013a  4540              CMP      r0,r8                 ;1364
00013c  d10f              BNE      |L21.350|
00013e  ea5f704a          LSLS     r0,r10,#29            ;1367
000142  d407              BMI      |L21.340|
000144  ea5f700b          LSLS     r0,r11,#28            ;1367
000148  d504              BPL      |L21.340|
00014a  6820              LDR      r0,[r4,#0]            ;1369
00014c  6801              LDR      r1,[r0,#0]            ;1369
00014e  f4417100          ORR      r1,r1,#0x200          ;1369
000152  6001              STR      r1,[r0,#0]            ;1369
                  |L21.340|
000154  6820              LDR      r0,[r4,#0]            ;1371
000156  6801              LDR      r1,[r0,#0]            ;1371
000158  f4415180          ORR      r1,r1,#0x1000         ;1371
00015c  6001              STR      r1,[r0,#0]            ;1371
                  |L21.350|
00015e  6820              LDR      r0,[r4,#0]            ;1377
000160  6881              LDR      r1,[r0,#8]            ;1377
000162  07c9              LSLS     r1,r1,#31             ;1377
000164  d00e              BEQ      |L21.388|
000166  f8b41046          LDRH     r1,[r4,#0x46]         ;1377
00016a  b159              CBZ      r1,|L21.388|
00016c  68c0              LDR      r0,[r0,#0xc]          ;1379
00016e  6c21              LDR      r1,[r4,#0x40]         ;1379
000170  8008              STRH     r0,[r1,#0]            ;1379
000172  6c20              LDR      r0,[r4,#0x40]         ;1380
000174  1c80              ADDS     r0,r0,#2              ;1380
000176  6420              STR      r0,[r4,#0x40]         ;1380
000178  f8b40046          LDRH     r0,[r4,#0x46]         ;1381
00017c  1e40              SUBS     r0,r0,#1              ;1381
00017e  f8a40046          STRH     r0,[r4,#0x46]         ;1381
000182  2501              MOVS     r5,#1                 ;1383
                  |L21.388|
000184  f7fffffe          BL       HAL_GetTick
000188  eba00009          SUB      r0,r0,r9              ;1385
00018c  42b0              CMP      r0,r6                 ;1385
00018e  d303              BCC      |L21.408|
000190  1c70              ADDS     r0,r6,#1              ;1385
000192  d001              BEQ      |L21.408|
000194  2703              MOVS     r7,#3                 ;1387
000196  e0dd              B        |L21.852|
                  |L21.408|
000198  8fe0              LDRH     r0,[r4,#0x3e]         ;1351
00019a  2800              CMP      r0,#0                 ;1351
00019c  d1b8              BNE      |L21.272|
00019e  f8b40046          LDRH     r0,[r4,#0x46]         ;1351
0001a2  2800              CMP      r0,#0                 ;1351
0001a4  d1b4              BNE      |L21.272|
0001a6  e08b              B        |L21.704|
                  |L21.424|
0001a8  6860              LDR      r0,[r4,#4]            ;1395
0001aa  b108              CBZ      r0,|L21.432|
0001ac  2901              CMP      r1,#1                 ;1395
0001ae  d10c              BNE      |L21.458|
                  |L21.432|
0001b0  8fe0              LDRH     r0,[r4,#0x3e]         ;1397
0001b2  2801              CMP      r0,#1                 ;1397
0001b4  d90a              BLS      |L21.460|
0001b6  6ba0              LDR      r0,[r4,#0x38]         ;1399
0001b8  6821              LDR      r1,[r4,#0]            ;1399
0001ba  8800              LDRH     r0,[r0,#0]            ;1399
0001bc  60c8              STR      r0,[r1,#0xc]          ;1399
0001be  6ba0              LDR      r0,[r4,#0x38]         ;1400
0001c0  1c80              ADDS     r0,r0,#2              ;1400
0001c2  63a0              STR      r0,[r4,#0x38]         ;1400
0001c4  8fe0              LDRH     r0,[r4,#0x3e]         ;1401
0001c6  1e80              SUBS     r0,r0,#2              ;1401
0001c8  87e0              STRH     r0,[r4,#0x3e]         ;1401
                  |L21.458|
0001ca  e072              B        |L21.690|
                  |L21.460|
0001cc  6ba0              LDR      r0,[r4,#0x38]         ;1405
0001ce  6821              LDR      r1,[r4,#0]            ;1405
0001d0  7800              LDRB     r0,[r0,#0]            ;1405
0001d2  7308              STRB     r0,[r1,#0xc]          ;1405
0001d4  6ba0              LDR      r0,[r4,#0x38]         ;1406
0001d6  1c40              ADDS     r0,r0,#1              ;1406
0001d8  63a0              STR      r0,[r4,#0x38]         ;1406
0001da  8fe0              LDRH     r0,[r4,#0x3e]         ;1407
0001dc  1e40              SUBS     r0,r0,#1              ;1407
0001de  87e0              STRH     r0,[r4,#0x3e]         ;1407
0001e0  e067              B        |L21.690|
                  |L21.482|
0001e2  6820              LDR      r0,[r4,#0]            ;1413
0001e4  6881              LDR      r1,[r0,#8]            ;1413
0001e6  0789              LSLS     r1,r1,#30             ;1413
0001e8  d52f              BPL      |L21.586|
0001ea  8fe1              LDRH     r1,[r4,#0x3e]         ;1413
0001ec  b369              CBZ      r1,|L21.586|
0001ee  2d01              CMP      r5,#1                 ;1413
0001f0  d12b              BNE      |L21.586|
0001f2  8fe1              LDRH     r1,[r4,#0x3e]         ;1415
0001f4  2901              CMP      r1,#1                 ;1415
0001f6  d909              BLS      |L21.524|
0001f8  6ba1              LDR      r1,[r4,#0x38]         ;1417
0001fa  8809              LDRH     r1,[r1,#0]            ;1417
0001fc  60c1              STR      r1,[r0,#0xc]          ;1417
0001fe  6ba0              LDR      r0,[r4,#0x38]         ;1418
000200  1c80              ADDS     r0,r0,#2              ;1418
000202  63a0              STR      r0,[r4,#0x38]         ;1418
000204  8fe0              LDRH     r0,[r4,#0x3e]         ;1419
000206  1e80              SUBS     r0,r0,#2              ;1419
000208  87e0              STRH     r0,[r4,#0x3e]         ;1419
00020a  e008              B        |L21.542|
                  |L21.524|
00020c  6ba1              LDR      r1,[r4,#0x38]         ;1423
00020e  7809              LDRB     r1,[r1,#0]            ;1423
000210  7301              STRB     r1,[r0,#0xc]          ;1423
000212  6ba0              LDR      r0,[r4,#0x38]         ;1424
000214  1c40              ADDS     r0,r0,#1              ;1424
000216  63a0              STR      r0,[r4,#0x38]         ;1424
000218  8fe0              LDRH     r0,[r4,#0x3e]         ;1425
00021a  1e40              SUBS     r0,r0,#1              ;1425
00021c  87e0              STRH     r0,[r4,#0x3e]         ;1425
                  |L21.542|
00021e  2500              MOVS     r5,#0                 ;1428
000220  8fe0              LDRH     r0,[r4,#0x3e]         ;1432
000222  b990              CBNZ     r0,|L21.586|
000224  6aa0              LDR      r0,[r4,#0x28]         ;1432
000226  4540              CMP      r0,r8                 ;1432
000228  d10f              BNE      |L21.586|
00022a  ea5f704a          LSLS     r0,r10,#29            ;1435
00022e  d407              BMI      |L21.576|
000230  ea5f700b          LSLS     r0,r11,#28            ;1435
000234  d504              BPL      |L21.576|
000236  6820              LDR      r0,[r4,#0]            ;1437
000238  6801              LDR      r1,[r0,#0]            ;1437
00023a  f4417100          ORR      r1,r1,#0x200          ;1437
00023e  6001              STR      r1,[r0,#0]            ;1437
                  |L21.576|
000240  6820              LDR      r0,[r4,#0]            ;1439
000242  6801              LDR      r1,[r0,#0]            ;1439
000244  f4415180          ORR      r1,r1,#0x1000         ;1439
000248  6001              STR      r1,[r0,#0]            ;1439
                  |L21.586|
00024a  6820              LDR      r0,[r4,#0]            ;1445
00024c  6881              LDR      r1,[r0,#8]            ;1445
00024e  07c9              LSLS     r1,r1,#31             ;1445
000250  d026              BEQ      |L21.672|
000252  f8b41046          LDRH     r1,[r4,#0x46]         ;1445
000256  b319              CBZ      r1,|L21.672|
000258  f8b41046          LDRH     r1,[r4,#0x46]         ;1447
00025c  2901              CMP      r1,#1                 ;1447
00025e  d913              BLS      |L21.648|
000260  68c0              LDR      r0,[r0,#0xc]          ;1449
000262  f8541f40          LDR      r1,[r4,#0x40]!        ;1449
000266  8008              STRH     r0,[r1,#0]            ;1449
000268  6820              LDR      r0,[r4,#0]            ;1450
00026a  1c80              ADDS     r0,r0,#2              ;1450
00026c  6020              STR      r0,[r4,#0]            ;1450
00026e  88e0              LDRH     r0,[r4,#6]            ;1451
000270  1e80              SUBS     r0,r0,#2              ;1451
000272  80e0              STRH     r0,[r4,#6]            ;1451
000274  88e0              LDRH     r0,[r4,#6]            ;1452
000276  3c40              SUBS     r4,r4,#0x40           ;1452
000278  2801              CMP      r0,#1                 ;1452
00027a  d810              BHI      |L21.670|
00027c  6820              LDR      r0,[r4,#0]            ;1455
00027e  6841              LDR      r1,[r0,#4]            ;1455
000280  f4415180          ORR      r1,r1,#0x1000         ;1455
000284  6041              STR      r1,[r0,#4]            ;1455
000286  e00a              B        |L21.670|
                  |L21.648|
000288  7b00              LDRB     r0,[r0,#0xc]          ;1460
00028a  6c21              LDR      r1,[r4,#0x40]         ;1460
00028c  7008              STRB     r0,[r1,#0]            ;1460
00028e  6c20              LDR      r0,[r4,#0x40]         ;1461
000290  1c40              ADDS     r0,r0,#1              ;1461
000292  6420              STR      r0,[r4,#0x40]         ;1461
000294  f8b40046          LDRH     r0,[r4,#0x46]         ;1462
000298  1e40              SUBS     r0,r0,#1              ;1462
00029a  f8a40046          STRH     r0,[r4,#0x46]         ;1462
                  |L21.670|
00029e  2501              MOVS     r5,#1                 ;1465
                  |L21.672|
0002a0  f7fffffe          BL       HAL_GetTick
0002a4  eba00009          SUB      r0,r0,r9              ;1467
0002a8  42b0              CMP      r0,r6                 ;1467
0002aa  d301              BCC      |L21.688|
0002ac  1c70              ADDS     r0,r6,#1              ;1467
0002ae  d119              BNE      |L21.740|
                  |L21.688|
0002b0  b1c6              CBZ      r6,|L21.740|
                  |L21.690|
0002b2  8fe0              LDRH     r0,[r4,#0x3e]         ;1410
0002b4  2800              CMP      r0,#0                 ;1410
0002b6  d194              BNE      |L21.482|
0002b8  f8b40046          LDRH     r0,[r4,#0x46]         ;1410
0002bc  2800              CMP      r0,#0                 ;1410
0002be  d190              BNE      |L21.482|
                  |L21.704|
0002c0  6aa0              LDR      r0,[r4,#0x28]         ;1477
0002c2  4540              CMP      r0,r8                 ;1477
0002c4  d131              BNE      |L21.810|
0002c6  2201              MOVS     r2,#1                 ;1480
0002c8  4633              MOV      r3,r6                 ;1480
0002ca  4611              MOV      r1,r2                 ;1480
0002cc  4620              MOV      r0,r4                 ;1480
0002ce  f8cd9000          STR      r9,[sp,#0]            ;1480
0002d2  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
0002d6  b138              CBZ      r0,|L21.744|
0002d8  6e20              LDR      r0,[r4,#0x60]         ;1483
0002da  f0400002          ORR      r0,r0,#2              ;1483
0002de  6620              STR      r0,[r4,#0x60]         ;1483
0002e0  2703              MOVS     r7,#3                 ;1484
0002e2  e037              B        |L21.852|
                  |L21.740|
0002e4  2703              MOVS     r7,#3                 ;1469
0002e6  e035              B        |L21.852|
                  |L21.744|
0002e8  68e0              LDR      r0,[r4,#0xc]          ;1488
0002ea  f5b06f70          CMP      r0,#0xf00             ;1488
0002ee  d006              BEQ      |L21.766|
0002f0  6820              LDR      r0,[r4,#0]            ;1498
0002f2  7b00              LDRB     r0,[r0,#0xc]          ;1498
0002f4  9002              STR      r0,[sp,#8]            ;1498
0002f6  6b20              LDR      r0,[r4,#0x30]         ;1502
0002f8  2802              CMP      r0,#2                 ;1502
0002fa  d004              BEQ      |L21.774|
0002fc  e015              B        |L21.810|
                  |L21.766|
0002fe  6820              LDR      r0,[r4,#0]            ;1491
000300  68c0              LDR      r0,[r0,#0xc]          ;1491
000302  9002              STR      r0,[sp,#8]            ;1491
000304  e011              B        |L21.810|
                  |L21.774|
000306  2201              MOVS     r2,#1                 ;1504
000308  4633              MOV      r3,r6                 ;1504
00030a  4611              MOV      r1,r2                 ;1504
00030c  4620              MOV      r0,r4                 ;1504
00030e  f8cd9000          STR      r9,[sp,#0]            ;1504
000312  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000316  b128              CBZ      r0,|L21.804|
000318  6e20              LDR      r0,[r4,#0x60]         ;1507
00031a  f0400002          ORR      r0,r0,#2              ;1507
00031e  6620              STR      r0,[r4,#0x60]         ;1507
000320  2703              MOVS     r7,#3                 ;1508
000322  e017              B        |L21.852|
                  |L21.804|
000324  6820              LDR      r0,[r4,#0]            ;1512
000326  7b00              LDRB     r0,[r0,#0xc]          ;1512
000328  9002              STR      r0,[sp,#8]            ;1512
                  |L21.810|
00032a  6820              LDR      r0,[r4,#0]            ;1520
00032c  6881              LDR      r1,[r0,#8]            ;1520
00032e  06c9              LSLS     r1,r1,#27             ;1520
000330  d507              BPL      |L21.834|
000332  6e21              LDR      r1,[r4,#0x60]         ;1522
000334  f0410102          ORR      r1,r1,#2              ;1522
000338  6621              STR      r1,[r4,#0x60]         ;1522
00033a  f64f71ef          MOV      r1,#0xffef            ;1524
00033e  6081              STR      r1,[r0,#8]            ;1524
000340  2701              MOVS     r7,#1                 ;1526
                  |L21.834|
000342  464a              MOV      r2,r9                 ;1531
000344  4631              MOV      r1,r6                 ;1531
000346  4620              MOV      r0,r4                 ;1531
000348  f7fffffe          BL       SPI_EndRxTxTransaction
00034c  b110              CBZ      r0,|L21.852|
00034e  2701              MOVS     r7,#1                 ;1533
000350  2020              MOVS     r0,#0x20              ;1534
000352  6620              STR      r0,[r4,#0x60]         ;1534
                  |L21.852|
000354  2001              MOVS     r0,#1                 ;1538
000356  345c              ADDS     r4,r4,#0x5c           ;1538
000358  7060              STRB     r0,[r4,#1]            ;1538
00035a  2000              MOVS     r0,#0                 ;1539
00035c  7020              STRB     r0,[r4,#0]            ;1539
00035e  4638              MOV      r0,r7                 ;1540
000360  e672              B        |L21.72|
;;;1542   
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_DMA PROC
;;;2121     */
;;;2122   HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2123                                                 uint16_t Size)
;;;2124   {
000004  4604              MOV      r4,r0
;;;2125     uint32_t             tmp_mode;
;;;2126     HAL_SPI_StateTypeDef tmp_state;
;;;2127     HAL_StatusTypeDef errorcode = HAL_OK;
000006  2500              MOVS     r5,#0
;;;2128   
;;;2129     /* Check rx & tx dma handles */
;;;2130     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;2131     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;2132   
;;;2133     /* Check Direction parameter */
;;;2134     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;2135   
;;;2136     /* Process locked */
;;;2137     __HAL_LOCK(hspi);
000008  f894005c          LDRB     r0,[r4,#0x5c]
00000c  2801              CMP      r0,#1
00000e  d00d              BEQ      |L22.44|
000010  2601              MOVS     r6,#1
000012  f884605c          STRB     r6,[r4,#0x5c]
;;;2138   
;;;2139     /* Init temporary variables */
;;;2140     tmp_state           = hspi->State;
000016  f894005d          LDRB     r0,[r4,#0x5d]
;;;2141     tmp_mode            = hspi->Init.Mode;
00001a  f8d4c004          LDR      r12,[r4,#4]
;;;2142   
;;;2143     if (!((tmp_state == HAL_SPI_STATE_READY) ||
00001e  2700              MOVS     r7,#0
000020  2801              CMP      r0,#1
000022  d00f              BEQ      |L22.68|
000024  f5bc7f82          CMP      r12,#0x104
000028  d10a              BNE      |L22.64|
00002a  e002              B        |L22.50|
                  |L22.44|
00002c  2002              MOVS     r0,#2                 ;2137
                  |L22.46|
;;;2144           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;2145     {
;;;2146       errorcode = HAL_BUSY;
;;;2147       goto error;
;;;2148     }
;;;2149   
;;;2150     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;2151     {
;;;2152       errorcode = HAL_ERROR;
;;;2153       goto error;
;;;2154     }
;;;2155   
;;;2156     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;2157     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;2158     {
;;;2159       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;2160     }
;;;2161   
;;;2162     /* Set the transaction information */
;;;2163     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;2164     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;2165     hspi->TxXferSize  = Size;
;;;2166     hspi->TxXferCount = Size;
;;;2167     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;2168     hspi->RxXferSize  = Size;
;;;2169     hspi->RxXferCount = Size;
;;;2170   
;;;2171     /* Init field not used in handle to zero */
;;;2172     hspi->RxISR       = NULL;
;;;2173     hspi->TxISR       = NULL;
;;;2174   
;;;2175   #if (USE_SPI_CRC != 0U)
;;;2176     /* Reset CRC Calculation */
;;;2177     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2178     {
;;;2179       SPI_RESET_CRC(hspi);
;;;2180     }
;;;2181   #endif /* USE_SPI_CRC */
;;;2182   
;;;2183     /* Reset the threshold bit */
;;;2184     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
;;;2185   
;;;2186     /* The packing mode management is enabled by the DMA settings according the spi data size */
;;;2187     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;2188     {
;;;2189       /* Set fiforxthreshold according the reception data length: 16bit */
;;;2190       CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;2191     }
;;;2192     else
;;;2193     {
;;;2194       /* Set RX Fifo threshold according the reception data length: 8bit */
;;;2195       SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;2196   
;;;2197       if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
;;;2198       {
;;;2199         if ((hspi->TxXferSize & 0x1U) == 0x0U)
;;;2200         {
;;;2201           CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
;;;2202           hspi->TxXferCount = hspi->TxXferCount >> 1U;
;;;2203         }
;;;2204         else
;;;2205         {
;;;2206           SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
;;;2207           hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
;;;2208         }
;;;2209       }
;;;2210   
;;;2211       if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
;;;2212       {
;;;2213         /* Set RX Fifo threshold according the reception data length: 16bit */
;;;2214         CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;2215   
;;;2216         if ((hspi->RxXferCount & 0x1U) == 0x0U)
;;;2217         {
;;;2218           CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
;;;2219           hspi->RxXferCount = hspi->RxXferCount >> 1U;
;;;2220         }
;;;2221         else
;;;2222         {
;;;2223           SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
;;;2224           hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
;;;2225         }
;;;2226       }
;;;2227     }
;;;2228   
;;;2229     /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
;;;2230     if (hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;2231     {
;;;2232       /* Set the SPI Rx DMA Half transfer complete callback */
;;;2233       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;2234       hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
;;;2235     }
;;;2236     else
;;;2237     {
;;;2238       /* Set the SPI Tx/Rx DMA Half transfer complete callback */
;;;2239       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
;;;2240       hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
;;;2241     }
;;;2242   
;;;2243     /* Set the DMA error callback */
;;;2244     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;2245   
;;;2246     /* Set the DMA AbortCpltCallback */
;;;2247     hspi->hdmarx->XferAbortCallback = NULL;
;;;2248   
;;;2249     /* Enable the Rx DMA Stream/Channel  */
;;;2250     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;2251                                    hspi->RxXferCount))
;;;2252     {
;;;2253       /* Update SPI error code */
;;;2254       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;2255       errorcode = HAL_ERROR;
;;;2256   
;;;2257       hspi->State = HAL_SPI_STATE_READY;
;;;2258       goto error;
;;;2259     }
;;;2260   
;;;2261     /* Enable Rx DMA Request */
;;;2262     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;2263   
;;;2264     /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
;;;2265     is performed in DMA reception complete callback  */
;;;2266     hspi->hdmatx->XferHalfCpltCallback = NULL;
;;;2267     hspi->hdmatx->XferCpltCallback     = NULL;
;;;2268     hspi->hdmatx->XferErrorCallback    = NULL;
;;;2269     hspi->hdmatx->XferAbortCallback    = NULL;
;;;2270   
;;;2271     /* Enable the Tx DMA Stream/Channel  */
;;;2272     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;2273                                    hspi->TxXferCount))
;;;2274     {
;;;2275       /* Update SPI error code */
;;;2276       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;2277       errorcode = HAL_ERROR;
;;;2278   
;;;2279       hspi->State = HAL_SPI_STATE_READY;
;;;2280       goto error;
;;;2281     }
;;;2282   
;;;2283     /* Check if the SPI is already enabled */
;;;2284     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;2285     {
;;;2286       /* Enable SPI peripheral */
;;;2287       __HAL_SPI_ENABLE(hspi);
;;;2288     }
;;;2289     /* Enable the SPI Error Interrupt Bit */
;;;2290     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;2291   
;;;2292     /* Enable Tx DMA Request */
;;;2293     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;2294   
;;;2295   error :
;;;2296     /* Process Unlocked */
;;;2297     __HAL_UNLOCK(hspi);
;;;2298     return errorcode;
;;;2299   }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L22.50|
000032  f8d4c008          LDR      r12,[r4,#8]           ;2143
000036  f1bc0f00          CMP      r12,#0                ;2143
00003a  d101              BNE      |L22.64|
00003c  2804              CMP      r0,#4                 ;2143
00003e  d001              BEQ      |L22.68|
                  |L22.64|
000040  2502              MOVS     r5,#2                 ;2146
000042  e0ce              B        |L22.482|
                  |L22.68|
000044  b1c1              CBZ      r1,|L22.120|
000046  b1ba              CBZ      r2,|L22.120|
000048  b1b3              CBZ      r3,|L22.120|
00004a  f894005d          LDRB     r0,[r4,#0x5d]         ;2157
00004e  2804              CMP      r0,#4                 ;2157
000050  d002              BEQ      |L22.88|
000052  2005              MOVS     r0,#5                 ;2159
000054  f884005d          STRB     r0,[r4,#0x5d]         ;2159
                  |L22.88|
000058  6627              STR      r7,[r4,#0x60]         ;2163
00005a  63a1              STR      r1,[r4,#0x38]         ;2164
00005c  87a3              STRH     r3,[r4,#0x3c]         ;2165
00005e  87e3              STRH     r3,[r4,#0x3e]         ;2166
000060  6422              STR      r2,[r4,#0x40]         ;2167
000062  f8a43044          STRH     r3,[r4,#0x44]         ;2168
000066  f8a43046          STRH     r3,[r4,#0x46]         ;2169
00006a  64e7              STR      r7,[r4,#0x4c]         ;2172
00006c  6527              STR      r7,[r4,#0x50]         ;2173
00006e  6aa0              LDR      r0,[r4,#0x28]         ;2177
000070  f5b05f00          CMP      r0,#0x2000            ;2177
000074  d002              BEQ      |L22.124|
000076  e00b              B        |L22.144|
                  |L22.120|
000078  2501              MOVS     r5,#1                 ;2152
00007a  e0b2              B        |L22.482|
                  |L22.124|
00007c  6820              LDR      r0,[r4,#0]            ;2179
00007e  6801              LDR      r1,[r0,#0]            ;2179
000080  f4215100          BIC      r1,r1,#0x2000         ;2179
000084  6001              STR      r1,[r0,#0]            ;2179
000086  6820              LDR      r0,[r4,#0]            ;2179
000088  6801              LDR      r1,[r0,#0]            ;2179
00008a  f4415100          ORR      r1,r1,#0x2000         ;2179
00008e  6001              STR      r1,[r0,#0]            ;2179
                  |L22.144|
000090  6820              LDR      r0,[r4,#0]            ;2184
000092  6841              LDR      r1,[r0,#4]            ;2184
000094  f42141c0          BIC      r1,r1,#0x6000         ;2184
000098  6041              STR      r1,[r0,#4]            ;2184
00009a  68e0              LDR      r0,[r4,#0xc]          ;2187
00009c  f5b06fe0          CMP      r0,#0x700             ;2187
0000a0  d905              BLS      |L22.174|
0000a2  6820              LDR      r0,[r4,#0]            ;2190
0000a4  6841              LDR      r1,[r0,#4]            ;2190
0000a6  f4215180          BIC      r1,r1,#0x1000         ;2190
0000aa  6041              STR      r1,[r0,#4]            ;2190
0000ac  e02f              B        |L22.270|
                  |L22.174|
0000ae  6820              LDR      r0,[r4,#0]            ;2195
0000b0  6841              LDR      r1,[r0,#4]            ;2195
0000b2  f4415180          ORR      r1,r1,#0x1000         ;2195
0000b6  6041              STR      r1,[r0,#4]            ;2195
0000b8  6d60              LDR      r0,[r4,#0x54]         ;2197
0000ba  f44f6180          MOV      r1,#0x400             ;2197
0000be  6980              LDR      r0,[r0,#0x18]         ;2197
0000c0  4288              CMP      r0,r1                 ;2197
0000c2  d10c              BNE      |L22.222|
0000c4  f894003c          LDRB     r0,[r4,#0x3c]         ;2199
0000c8  07c0              LSLS     r0,r0,#31             ;2199
0000ca  d040              BEQ      |L22.334|
0000cc  6820              LDR      r0,[r4,#0]            ;2206
0000ce  6842              LDR      r2,[r0,#4]            ;2206
0000d0  f4424280          ORR      r2,r2,#0x4000         ;2206
0000d4  6042              STR      r2,[r0,#4]            ;2206
0000d6  8fe0              LDRH     r0,[r4,#0x3e]         ;2207
0000d8  eb060050          ADD      r0,r6,r0,LSR #1       ;2207
0000dc  87e0              STRH     r0,[r4,#0x3e]         ;2207
                  |L22.222|
0000de  6da0              LDR      r0,[r4,#0x58]         ;2211
0000e0  6980              LDR      r0,[r0,#0x18]         ;2211
0000e2  4288              CMP      r0,r1                 ;2211
0000e4  d113              BNE      |L22.270|
0000e6  6820              LDR      r0,[r4,#0]            ;2214
0000e8  6841              LDR      r1,[r0,#4]            ;2214
0000ea  f4215180          BIC      r1,r1,#0x1000         ;2214
0000ee  6041              STR      r1,[r0,#4]            ;2214
0000f0  f8b40046          LDRH     r0,[r4,#0x46]         ;2216
0000f4  07c0              LSLS     r0,r0,#31             ;2216
0000f6  d033              BEQ      |L22.352|
0000f8  6820              LDR      r0,[r4,#0]            ;2223
0000fa  6841              LDR      r1,[r0,#4]            ;2223
0000fc  f4415100          ORR      r1,r1,#0x2000         ;2223
000100  6041              STR      r1,[r0,#4]            ;2223
000102  f8b40046          LDRH     r0,[r4,#0x46]         ;2224
000106  eb060050          ADD      r0,r6,r0,LSR #1       ;2224
00010a  f8a40046          STRH     r0,[r4,#0x46]         ;2224
                  |L22.270|
00010e  f894005d          LDRB     r0,[r4,#0x5d]         ;2230
000112  2804              CMP      r0,#4                 ;2230
000114  d02f              BEQ      |L22.374|
000116  6da1              LDR      r1,[r4,#0x58]         ;2239
000118  4834              LDR      r0,|L22.492|
00011a  6308              STR      r0,[r1,#0x30]         ;2239
00011c  6da1              LDR      r1,[r4,#0x58]         ;2240
00011e  4834              LDR      r0,|L22.496|
000120  62c8              STR      r0,[r1,#0x2c]         ;2240
                  |L22.290|
000122  6da1              LDR      r1,[r4,#0x58]         ;2244
000124  4833              LDR      r0,|L22.500|
000126  6348              STR      r0,[r1,#0x34]         ;2244
000128  6da0              LDR      r0,[r4,#0x58]         ;2247
00012a  6387              STR      r7,[r0,#0x38]         ;2247
00012c  f8b43046          LDRH     r3,[r4,#0x46]         ;2250
000130  6821              LDR      r1,[r4,#0]            ;2250
000132  6c22              LDR      r2,[r4,#0x40]         ;2250
000134  310c              ADDS     r1,r1,#0xc            ;2250
000136  6da0              LDR      r0,[r4,#0x58]         ;2250
000138  f7fffffe          BL       HAL_DMA_Start_IT
00013c  b310              CBZ      r0,|L22.388|
00013e  6e20              LDR      r0,[r4,#0x60]         ;2254
000140  f0400010          ORR      r0,r0,#0x10           ;2254
000144  6620              STR      r0,[r4,#0x60]         ;2254
000146  2501              MOVS     r5,#1                 ;2255
000148  f884605d          STRB     r6,[r4,#0x5d]         ;2257
00014c  e049              B        |L22.482|
                  |L22.334|
00014e  6820              LDR      r0,[r4,#0]            ;2201
000150  6842              LDR      r2,[r0,#4]            ;2201
000152  f4224280          BIC      r2,r2,#0x4000         ;2201
000156  6042              STR      r2,[r0,#4]            ;2201
000158  8fe0              LDRH     r0,[r4,#0x3e]         ;2202
00015a  0840              LSRS     r0,r0,#1              ;2202
00015c  87e0              STRH     r0,[r4,#0x3e]         ;2202
00015e  e7be              B        |L22.222|
                  |L22.352|
000160  6820              LDR      r0,[r4,#0]            ;2218
000162  6841              LDR      r1,[r0,#4]            ;2218
000164  f4215100          BIC      r1,r1,#0x2000         ;2218
000168  6041              STR      r1,[r0,#4]            ;2218
00016a  f8b40046          LDRH     r0,[r4,#0x46]         ;2219
00016e  0840              LSRS     r0,r0,#1              ;2219
000170  f8a40046          STRH     r0,[r4,#0x46]         ;2219
000174  e7cb              B        |L22.270|
                  |L22.374|
000176  6da1              LDR      r1,[r4,#0x58]         ;2233
000178  481f              LDR      r0,|L22.504|
00017a  6308              STR      r0,[r1,#0x30]         ;2233
00017c  6da1              LDR      r1,[r4,#0x58]         ;2234
00017e  481f              LDR      r0,|L22.508|
000180  62c8              STR      r0,[r1,#0x2c]         ;2234
000182  e7ce              B        |L22.290|
                  |L22.388|
000184  6820              LDR      r0,[r4,#0]            ;2262
000186  6841              LDR      r1,[r0,#4]            ;2262
000188  f0410101          ORR      r1,r1,#1              ;2262
00018c  6041              STR      r1,[r0,#4]            ;2262
00018e  6d60              LDR      r0,[r4,#0x54]         ;2266
000190  6307              STR      r7,[r0,#0x30]         ;2266
000192  6d60              LDR      r0,[r4,#0x54]         ;2267
000194  62c7              STR      r7,[r0,#0x2c]         ;2267
000196  6d60              LDR      r0,[r4,#0x54]         ;2268
000198  6347              STR      r7,[r0,#0x34]         ;2268
00019a  6d60              LDR      r0,[r4,#0x54]         ;2269
00019c  6387              STR      r7,[r0,#0x38]         ;2269
00019e  8fe3              LDRH     r3,[r4,#0x3e]         ;2272
0001a0  6822              LDR      r2,[r4,#0]            ;2272
0001a2  6ba1              LDR      r1,[r4,#0x38]         ;2272
0001a4  320c              ADDS     r2,r2,#0xc            ;2272
0001a6  6d60              LDR      r0,[r4,#0x54]         ;2272
0001a8  f7fffffe          BL       HAL_DMA_Start_IT
0001ac  b138              CBZ      r0,|L22.446|
0001ae  6e20              LDR      r0,[r4,#0x60]         ;2276
0001b0  f0400010          ORR      r0,r0,#0x10           ;2276
0001b4  6620              STR      r0,[r4,#0x60]         ;2276
0001b6  2501              MOVS     r5,#1                 ;2277
0001b8  f884605d          STRB     r6,[r4,#0x5d]         ;2279
0001bc  e011              B        |L22.482|
                  |L22.446|
0001be  6820              LDR      r0,[r4,#0]            ;2284
0001c0  6801              LDR      r1,[r0,#0]            ;2284
0001c2  0649              LSLS     r1,r1,#25             ;2284
0001c4  d403              BMI      |L22.462|
0001c6  6801              LDR      r1,[r0,#0]            ;2287
0001c8  f0410140          ORR      r1,r1,#0x40           ;2287
0001cc  6001              STR      r1,[r0,#0]            ;2287
                  |L22.462|
0001ce  6820              LDR      r0,[r4,#0]            ;2290
0001d0  6841              LDR      r1,[r0,#4]            ;2290
0001d2  f0410120          ORR      r1,r1,#0x20           ;2290
0001d6  6041              STR      r1,[r0,#4]            ;2290
0001d8  6820              LDR      r0,[r4,#0]            ;2293
0001da  6841              LDR      r1,[r0,#4]            ;2293
0001dc  f0410102          ORR      r1,r1,#2              ;2293
0001e0  6041              STR      r1,[r0,#4]            ;2293
                  |L22.482|
0001e2  f884705c          STRB     r7,[r4,#0x5c]         ;2297
0001e6  4628              MOV      r0,r5                 ;2298
0001e8  e721              B        |L22.46|
;;;2300   
                          ENDP

0001ea  0000              DCW      0x0000
                  |L22.492|
                          DCD      SPI_DMAHalfTransmitReceiveCplt
                  |L22.496|
                          DCD      SPI_DMATransmitReceiveCplt
                  |L22.500|
                          DCD      SPI_DMAError
                  |L22.504|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L22.508|
                          DCD      SPI_DMAReceiveCplt

                          AREA ||i.HAL_SPI_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_IT PROC
;;;1742     */
;;;1743   HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1744   {
;;;1745     uint32_t             tmp_mode;
;;;1746     HAL_SPI_StateTypeDef tmp_state;
;;;1747     HAL_StatusTypeDef    errorcode = HAL_OK;
000002  2400              MOVS     r4,#0
;;;1748   
;;;1749     /* Check Direction parameter */
;;;1750     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1751   
;;;1752     /* Process locked */
;;;1753     __HAL_LOCK(hspi);
000004  f890505c          LDRB     r5,[r0,#0x5c]
000008  2d01              CMP      r5,#1
00000a  d00d              BEQ      |L23.40|
00000c  f04f0c01          MOV      r12,#1
000010  f880c05c          STRB     r12,[r0,#0x5c]
;;;1754   
;;;1755     /* Init temporary variables */
;;;1756     tmp_state           = hspi->State;
000014  f890505d          LDRB     r5,[r0,#0x5d]
;;;1757     tmp_mode            = hspi->Init.Mode;
000018  6847              LDR      r7,[r0,#4]
;;;1758   
;;;1759     if (!((tmp_state == HAL_SPI_STATE_READY) || \
00001a  2600              MOVS     r6,#0
00001c  2d01              CMP      r5,#1
00001e  d00b              BEQ      |L23.56|
000020  f5b77f82          CMP      r7,#0x104
000024  d106              BNE      |L23.52|
000026  e001              B        |L23.44|
                  |L23.40|
000028  2002              MOVS     r0,#2                 ;1753
;;;1760           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1761     {
;;;1762       errorcode = HAL_BUSY;
;;;1763       goto error;
;;;1764     }
;;;1765   
;;;1766     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1767     {
;;;1768       errorcode = HAL_ERROR;
;;;1769       goto error;
;;;1770     }
;;;1771   
;;;1772     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1773     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1774     {
;;;1775       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1776     }
;;;1777   
;;;1778     /* Set the transaction information */
;;;1779     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1780     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1781     hspi->TxXferSize  = Size;
;;;1782     hspi->TxXferCount = Size;
;;;1783     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1784     hspi->RxXferSize  = Size;
;;;1785     hspi->RxXferCount = Size;
;;;1786   
;;;1787     /* Set the function for IT treatment */
;;;1788     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1789     {
;;;1790       hspi->RxISR     = SPI_2linesRxISR_16BIT;
;;;1791       hspi->TxISR     = SPI_2linesTxISR_16BIT;
;;;1792     }
;;;1793     else
;;;1794     {
;;;1795       hspi->RxISR     = SPI_2linesRxISR_8BIT;
;;;1796       hspi->TxISR     = SPI_2linesTxISR_8BIT;
;;;1797     }
;;;1798   
;;;1799   #if (USE_SPI_CRC != 0U)
;;;1800     /* Reset CRC Calculation */
;;;1801     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1802     {
;;;1803       hspi->CRCSize = 1U;
;;;1804       if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
;;;1805       {
;;;1806         hspi->CRCSize = 2U;
;;;1807       }
;;;1808       SPI_RESET_CRC(hspi);
;;;1809     }
;;;1810     else
;;;1811     {
;;;1812       hspi->CRCSize = 0U;
;;;1813     }
;;;1814   #endif /* USE_SPI_CRC */
;;;1815   
;;;1816     /* Check if packing mode is enabled and if there is more than 2 data to receive */
;;;1817     if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (Size >= 2U))
;;;1818     {
;;;1819       /* Set RX Fifo threshold according the reception data length: 16 bit */
;;;1820       CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1821     }
;;;1822     else
;;;1823     {
;;;1824       /* Set RX Fifo threshold according the reception data length: 8 bit */
;;;1825       SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;1826     }
;;;1827   
;;;1828     /* Enable TXE, RXNE and ERR interrupt */
;;;1829     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;1830   
;;;1831     /* Check if the SPI is already enabled */
;;;1832     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1833     {
;;;1834       /* Enable SPI peripheral */
;;;1835       __HAL_SPI_ENABLE(hspi);
;;;1836     }
;;;1837   
;;;1838   error :
;;;1839     /* Process Unlocked */
;;;1840     __HAL_UNLOCK(hspi);
;;;1841     return errorcode;
;;;1842   }
00002a  bdf0              POP      {r4-r7,pc}
                  |L23.44|
00002c  6887              LDR      r7,[r0,#8]            ;1759
00002e  b90f              CBNZ     r7,|L23.52|
000030  2d04              CMP      r5,#4                 ;1759
000032  d001              BEQ      |L23.56|
                  |L23.52|
000034  2402              MOVS     r4,#2                 ;1762
000036  e057              B        |L23.232|
                  |L23.56|
000038  b1d9              CBZ      r1,|L23.114|
00003a  b1d2              CBZ      r2,|L23.114|
00003c  b1cb              CBZ      r3,|L23.114|
00003e  f890505d          LDRB     r5,[r0,#0x5d]         ;1773
000042  2d04              CMP      r5,#4                 ;1773
000044  d002              BEQ      |L23.76|
000046  2505              MOVS     r5,#5                 ;1775
000048  f880505d          STRB     r5,[r0,#0x5d]         ;1775
                  |L23.76|
00004c  6606              STR      r6,[r0,#0x60]         ;1779
00004e  6381              STR      r1,[r0,#0x38]         ;1780
000050  8783              STRH     r3,[r0,#0x3c]         ;1781
000052  87c3              STRH     r3,[r0,#0x3e]         ;1782
000054  6402              STR      r2,[r0,#0x40]         ;1783
000056  f8a03044          STRH     r3,[r0,#0x44]         ;1784
00005a  f8a03046          STRH     r3,[r0,#0x46]         ;1785
00005e  68c1              LDR      r1,[r0,#0xc]          ;1788
000060  f44f62e0          MOV      r2,#0x700             ;1788
000064  4291              CMP      r1,r2                 ;1788
000066  d906              BLS      |L23.118|
000068  4d21              LDR      r5,|L23.240|
00006a  64c5              STR      r5,[r0,#0x4c]         ;1790
00006c  4d21              LDR      r5,|L23.244|
00006e  6505              STR      r5,[r0,#0x50]         ;1791
000070  e005              B        |L23.126|
                  |L23.114|
000072  2401              MOVS     r4,#1                 ;1768
000074  e038              B        |L23.232|
                  |L23.118|
000076  4d20              LDR      r5,|L23.248|
000078  64c5              STR      r5,[r0,#0x4c]         ;1795
00007a  4d20              LDR      r5,|L23.252|
00007c  6505              STR      r5,[r0,#0x50]         ;1796
                  |L23.126|
00007e  6a85              LDR      r5,[r0,#0x28]         ;1801
000080  f5b55f00          CMP      r5,#0x2000            ;1801
000084  d00b              BEQ      |L23.158|
000086  6486              STR      r6,[r0,#0x48]         ;1812
                  |L23.136|
000088  68c1              LDR      r1,[r0,#0xc]          ;1817
00008a  4291              CMP      r1,r2                 ;1817
00008c  d801              BHI      |L23.146|
00008e  2b02              CMP      r3,#2                 ;1817
000090  d318              BCC      |L23.196|
                  |L23.146|
000092  6801              LDR      r1,[r0,#0]            ;1820
000094  684a              LDR      r2,[r1,#4]            ;1820
000096  f4225280          BIC      r2,r2,#0x1000         ;1820
00009a  604a              STR      r2,[r1,#4]            ;1820
00009c  e017              B        |L23.206|
                  |L23.158|
00009e  f8c0c048          STR      r12,[r0,#0x48]        ;1803
0000a2  4291              CMP      r1,r2                 ;1804
0000a4  d803              BHI      |L23.174|
0000a6  6b01              LDR      r1,[r0,#0x30]         ;1804
0000a8  2902              CMP      r1,#2                 ;1804
0000aa  d100              BNE      |L23.174|
0000ac  6481              STR      r1,[r0,#0x48]         ;1806
                  |L23.174|
0000ae  6801              LDR      r1,[r0,#0]            ;1808
0000b0  680d              LDR      r5,[r1,#0]            ;1808
0000b2  f4255500          BIC      r5,r5,#0x2000         ;1808
0000b6  600d              STR      r5,[r1,#0]            ;1808
0000b8  6801              LDR      r1,[r0,#0]            ;1808
0000ba  680d              LDR      r5,[r1,#0]            ;1808
0000bc  f4455500          ORR      r5,r5,#0x2000         ;1808
0000c0  600d              STR      r5,[r1,#0]            ;1808
0000c2  e7e1              B        |L23.136|
                  |L23.196|
0000c4  6801              LDR      r1,[r0,#0]            ;1825
0000c6  684a              LDR      r2,[r1,#4]            ;1825
0000c8  f4425280          ORR      r2,r2,#0x1000         ;1825
0000cc  604a              STR      r2,[r1,#4]            ;1825
                  |L23.206|
0000ce  6801              LDR      r1,[r0,#0]            ;1829
0000d0  684a              LDR      r2,[r1,#4]            ;1829
0000d2  f04202e0          ORR      r2,r2,#0xe0           ;1829
0000d6  604a              STR      r2,[r1,#4]            ;1829
0000d8  6801              LDR      r1,[r0,#0]            ;1832
0000da  680a              LDR      r2,[r1,#0]            ;1832
0000dc  0652              LSLS     r2,r2,#25             ;1832
0000de  d403              BMI      |L23.232|
0000e0  680a              LDR      r2,[r1,#0]            ;1835
0000e2  f0420240          ORR      r2,r2,#0x40           ;1835
0000e6  600a              STR      r2,[r1,#0]            ;1835
                  |L23.232|
0000e8  f880605c          STRB     r6,[r0,#0x5c]         ;1840
0000ec  4620              MOV      r0,r4                 ;1841
0000ee  bdf0              POP      {r4-r7,pc}
;;;1843   
                          ENDP

                  |L23.240|
                          DCD      SPI_2linesRxISR_16BIT
                  |L23.244|
                          DCD      SPI_2linesTxISR_16BIT
                  |L23.248|
                          DCD      SPI_2linesRxISR_8BIT
                  |L23.252|
                          DCD      SPI_2linesTxISR_8BIT

                          AREA ||i.HAL_SPI_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_DMA PROC
;;;1851     */
;;;1852   HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1853   {
000004  4604              MOV      r4,r0
;;;1854     HAL_StatusTypeDef errorcode = HAL_OK;
000006  2500              MOVS     r5,#0
;;;1855   
;;;1856     /* Check tx dma handle */
;;;1857     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1858   
;;;1859     /* Check Direction parameter */
;;;1860     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1861   
;;;1862     /* Process Locked */
;;;1863     __HAL_LOCK(hspi);
000008  f894005c          LDRB     r0,[r4,#0x5c]
00000c  2801              CMP      r0,#1
00000e  d009              BEQ      |L24.36|
000010  2701              MOVS     r7,#1
000012  f884705c          STRB     r7,[r4,#0x5c]
;;;1864   
;;;1865     if (hspi->State != HAL_SPI_STATE_READY)
000016  f894005d          LDRB     r0,[r4,#0x5d]
00001a  2600              MOVS     r6,#0
00001c  2801              CMP      r0,#1
00001e  d004              BEQ      |L24.42|
;;;1866     {
;;;1867       errorcode = HAL_BUSY;
000020  2502              MOVS     r5,#2
;;;1868       goto error;
000022  e081              B        |L24.296|
                  |L24.36|
000024  2002              MOVS     r0,#2                 ;1863
                  |L24.38|
;;;1869     }
;;;1870   
;;;1871     if ((pData == NULL) || (Size == 0U))
;;;1872     {
;;;1873       errorcode = HAL_ERROR;
;;;1874       goto error;
;;;1875     }
;;;1876   
;;;1877     /* Set the transaction information */
;;;1878     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1879     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1880     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1881     hspi->TxXferSize  = Size;
;;;1882     hspi->TxXferCount = Size;
;;;1883   
;;;1884     /* Init field not used in handle to zero */
;;;1885     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1886     hspi->TxISR       = NULL;
;;;1887     hspi->RxISR       = NULL;
;;;1888     hspi->RxXferSize  = 0U;
;;;1889     hspi->RxXferCount = 0U;
;;;1890   
;;;1891     /* Configure communication direction : 1Line */
;;;1892     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1893     {
;;;1894       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1895       __HAL_SPI_DISABLE(hspi);
;;;1896       SPI_1LINE_TX(hspi);
;;;1897     }
;;;1898   
;;;1899   #if (USE_SPI_CRC != 0U)
;;;1900     /* Reset CRC Calculation */
;;;1901     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1902     {
;;;1903       SPI_RESET_CRC(hspi);
;;;1904     }
;;;1905   #endif /* USE_SPI_CRC */
;;;1906   
;;;1907     /* Set the SPI TxDMA Half transfer complete callback */
;;;1908     hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
;;;1909   
;;;1910     /* Set the SPI TxDMA transfer complete callback */
;;;1911     hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
;;;1912   
;;;1913     /* Set the DMA error callback */
;;;1914     hspi->hdmatx->XferErrorCallback = SPI_DMAError;
;;;1915   
;;;1916     /* Set the DMA AbortCpltCallback */
;;;1917     hspi->hdmatx->XferAbortCallback = NULL;
;;;1918   
;;;1919     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
;;;1920     /* Packing mode is enabled only if the DMA setting is HALWORD */
;;;1921     if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
;;;1922     {
;;;1923       /* Check the even/odd of the data size + crc if enabled */
;;;1924       if ((hspi->TxXferCount & 0x1U) == 0U)
;;;1925       {
;;;1926         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
;;;1927         hspi->TxXferCount = (hspi->TxXferCount >> 1U);
;;;1928       }
;;;1929       else
;;;1930       {
;;;1931         SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
;;;1932         hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
;;;1933       }
;;;1934     }
;;;1935   
;;;1936     /* Enable the Tx DMA Stream/Channel */
;;;1937     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;1938                                    hspi->TxXferCount))
;;;1939     {
;;;1940       /* Update SPI error code */
;;;1941       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1942       errorcode = HAL_ERROR;
;;;1943   
;;;1944       hspi->State = HAL_SPI_STATE_READY;
;;;1945       goto error;
;;;1946     }
;;;1947   
;;;1948     /* Check if the SPI is already enabled */
;;;1949     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1950     {
;;;1951       /* Enable SPI peripheral */
;;;1952       __HAL_SPI_ENABLE(hspi);
;;;1953     }
;;;1954   
;;;1955     /* Enable the SPI Error Interrupt Bit */
;;;1956     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1957   
;;;1958     /* Enable Tx DMA Request */
;;;1959     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1960   
;;;1961   error :
;;;1962     /* Process Unlocked */
;;;1963     __HAL_UNLOCK(hspi);
;;;1964     return errorcode;
;;;1965   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L24.42|
00002a  b199              CBZ      r1,|L24.84|
00002c  b192              CBZ      r2,|L24.84|
00002e  2003              MOVS     r0,#3                 ;1878
000030  f884005d          STRB     r0,[r4,#0x5d]         ;1878
000034  6626              STR      r6,[r4,#0x60]         ;1879
000036  63a1              STR      r1,[r4,#0x38]         ;1880
000038  87a2              STRH     r2,[r4,#0x3c]         ;1881
00003a  87e2              STRH     r2,[r4,#0x3e]         ;1882
00003c  6426              STR      r6,[r4,#0x40]         ;1885
00003e  6526              STR      r6,[r4,#0x50]         ;1886
000040  64e6              STR      r6,[r4,#0x4c]         ;1887
000042  f8a46044          STRH     r6,[r4,#0x44]         ;1888
000046  f8a46046          STRH     r6,[r4,#0x46]         ;1889
00004a  68a0              LDR      r0,[r4,#8]            ;1892
00004c  f5b04f00          CMP      r0,#0x8000            ;1892
000050  d002              BEQ      |L24.88|
000052  e00b              B        |L24.108|
                  |L24.84|
000054  2501              MOVS     r5,#1                 ;1873
000056  e067              B        |L24.296|
                  |L24.88|
000058  6820              LDR      r0,[r4,#0]            ;1895
00005a  6801              LDR      r1,[r0,#0]            ;1895
00005c  f0210140          BIC      r1,r1,#0x40           ;1895
000060  6001              STR      r1,[r0,#0]            ;1895
000062  6820              LDR      r0,[r4,#0]            ;1896
000064  6801              LDR      r1,[r0,#0]            ;1896
000066  f4414180          ORR      r1,r1,#0x4000         ;1896
00006a  6001              STR      r1,[r0,#0]            ;1896
                  |L24.108|
00006c  6aa0              LDR      r0,[r4,#0x28]         ;1901
00006e  f5b05f00          CMP      r0,#0x2000            ;1901
000072  d109              BNE      |L24.136|
000074  6820              LDR      r0,[r4,#0]            ;1903
000076  6801              LDR      r1,[r0,#0]            ;1903
000078  f4215100          BIC      r1,r1,#0x2000         ;1903
00007c  6001              STR      r1,[r0,#0]            ;1903
00007e  6820              LDR      r0,[r4,#0]            ;1903
000080  6801              LDR      r1,[r0,#0]            ;1903
000082  f4415100          ORR      r1,r1,#0x2000         ;1903
000086  6001              STR      r1,[r0,#0]            ;1903
                  |L24.136|
000088  6d61              LDR      r1,[r4,#0x54]         ;1908
00008a  4829              LDR      r0,|L24.304|
00008c  6308              STR      r0,[r1,#0x30]         ;1908
00008e  6d61              LDR      r1,[r4,#0x54]         ;1911
000090  4828              LDR      r0,|L24.308|
000092  62c8              STR      r0,[r1,#0x2c]         ;1911
000094  6d61              LDR      r1,[r4,#0x54]         ;1914
000096  4828              LDR      r0,|L24.312|
000098  6348              STR      r0,[r1,#0x34]         ;1914
00009a  6d60              LDR      r0,[r4,#0x54]         ;1917
00009c  6386              STR      r6,[r0,#0x38]         ;1917
00009e  6820              LDR      r0,[r4,#0]            ;1919
0000a0  6841              LDR      r1,[r0,#4]            ;1919
0000a2  f4214180          BIC      r1,r1,#0x4000         ;1919
0000a6  6041              STR      r1,[r0,#4]            ;1919
0000a8  68e0              LDR      r0,[r4,#0xc]          ;1921
0000aa  f5b06fe0          CMP      r0,#0x700             ;1921
0000ae  d810              BHI      |L24.210|
0000b0  6d60              LDR      r0,[r4,#0x54]         ;1921
0000b2  6980              LDR      r0,[r0,#0x18]         ;1921
0000b4  f5b06f80          CMP      r0,#0x400             ;1921
0000b8  d10b              BNE      |L24.210|
0000ba  8fe0              LDRH     r0,[r4,#0x3e]         ;1924
0000bc  07c0              LSLS     r0,r0,#31             ;1924
0000be  d018              BEQ      |L24.242|
0000c0  6820              LDR      r0,[r4,#0]            ;1931
0000c2  6841              LDR      r1,[r0,#4]            ;1931
0000c4  f4414180          ORR      r1,r1,#0x4000         ;1931
0000c8  6041              STR      r1,[r0,#4]            ;1931
0000ca  8fe0              LDRH     r0,[r4,#0x3e]         ;1932
0000cc  eb070050          ADD      r0,r7,r0,LSR #1       ;1932
0000d0  87e0              STRH     r0,[r4,#0x3e]         ;1932
                  |L24.210|
0000d2  8fe3              LDRH     r3,[r4,#0x3e]         ;1937
0000d4  6822              LDR      r2,[r4,#0]            ;1937
0000d6  6ba1              LDR      r1,[r4,#0x38]         ;1937
0000d8  320c              ADDS     r2,r2,#0xc            ;1937
0000da  6d60              LDR      r0,[r4,#0x54]         ;1937
0000dc  f7fffffe          BL       HAL_DMA_Start_IT
0000e0  b180              CBZ      r0,|L24.260|
0000e2  6e20              LDR      r0,[r4,#0x60]         ;1941
0000e4  f0400010          ORR      r0,r0,#0x10           ;1941
0000e8  6620              STR      r0,[r4,#0x60]         ;1941
0000ea  2501              MOVS     r5,#1                 ;1942
0000ec  f884705d          STRB     r7,[r4,#0x5d]         ;1944
0000f0  e01a              B        |L24.296|
                  |L24.242|
0000f2  6820              LDR      r0,[r4,#0]            ;1926
0000f4  6841              LDR      r1,[r0,#4]            ;1926
0000f6  f4214180          BIC      r1,r1,#0x4000         ;1926
0000fa  6041              STR      r1,[r0,#4]            ;1926
0000fc  8fe0              LDRH     r0,[r4,#0x3e]         ;1927
0000fe  0840              LSRS     r0,r0,#1              ;1927
000100  87e0              STRH     r0,[r4,#0x3e]         ;1927
000102  e7e6              B        |L24.210|
                  |L24.260|
000104  6820              LDR      r0,[r4,#0]            ;1949
000106  6801              LDR      r1,[r0,#0]            ;1949
000108  0649              LSLS     r1,r1,#25             ;1949
00010a  d403              BMI      |L24.276|
00010c  6801              LDR      r1,[r0,#0]            ;1952
00010e  f0410140          ORR      r1,r1,#0x40           ;1952
000112  6001              STR      r1,[r0,#0]            ;1952
                  |L24.276|
000114  6820              LDR      r0,[r4,#0]            ;1956
000116  6841              LDR      r1,[r0,#4]            ;1956
000118  f0410120          ORR      r1,r1,#0x20           ;1956
00011c  6041              STR      r1,[r0,#4]            ;1956
00011e  6820              LDR      r0,[r4,#0]            ;1959
000120  6841              LDR      r1,[r0,#4]            ;1959
000122  f0410102          ORR      r1,r1,#2              ;1959
000126  6041              STR      r1,[r0,#4]            ;1959
                  |L24.296|
000128  f884605c          STRB     r6,[r4,#0x5c]         ;1963
00012c  4628              MOV      r0,r5                 ;1964
00012e  e77a              B        |L24.38|
;;;1966   
                          ENDP

                  |L24.304|
                          DCD      SPI_DMAHalfTransmitCplt
                  |L24.308|
                          DCD      SPI_DMATransmitCplt
                  |L24.312|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_IT PROC
;;;1550     */
;;;1551   HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;1552   {
;;;1553     HAL_StatusTypeDef errorcode = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1554   
;;;1555     /* Check Direction parameter */
;;;1556     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1557   
;;;1558     /* Process Locked */
;;;1559     __HAL_LOCK(hspi);
000004  f890405c          LDRB     r4,[r0,#0x5c]
000008  2c01              CMP      r4,#1
00000a  d00b              BEQ      |L25.36|
00000c  2401              MOVS     r4,#1
00000e  f880405c          STRB     r4,[r0,#0x5c]
;;;1560   
;;;1561     if ((pData == NULL) || (Size == 0U))
000012  2400              MOVS     r4,#0
000014  b141              CBZ      r1,|L25.40|
000016  b13a              CBZ      r2,|L25.40|
;;;1562     {
;;;1563       errorcode = HAL_ERROR;
;;;1564       goto error;
;;;1565     }
;;;1566   
;;;1567     if (hspi->State != HAL_SPI_STATE_READY)
000018  f890505d          LDRB     r5,[r0,#0x5d]
00001c  2d01              CMP      r5,#1
00001e  d005              BEQ      |L25.44|
;;;1568     {
;;;1569       errorcode = HAL_BUSY;
000020  2302              MOVS     r3,#2
;;;1570       goto error;
000022  e042              B        |L25.170|
                  |L25.36|
000024  2002              MOVS     r0,#2                 ;1559
;;;1571     }
;;;1572   
;;;1573     /* Set the transaction information */
;;;1574     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1575     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1576     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1577     hspi->TxXferSize  = Size;
;;;1578     hspi->TxXferCount = Size;
;;;1579   
;;;1580     /* Init field not used in handle to zero */
;;;1581     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1582     hspi->RxXferSize  = 0U;
;;;1583     hspi->RxXferCount = 0U;
;;;1584     hspi->RxISR       = NULL;
;;;1585   
;;;1586     /* Set the function for IT treatment */
;;;1587     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1588     {
;;;1589       hspi->TxISR = SPI_TxISR_16BIT;
;;;1590     }
;;;1591     else
;;;1592     {
;;;1593       hspi->TxISR = SPI_TxISR_8BIT;
;;;1594     }
;;;1595   
;;;1596     /* Configure communication direction : 1Line */
;;;1597     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1598     {
;;;1599       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1600       __HAL_SPI_DISABLE(hspi);
;;;1601       SPI_1LINE_TX(hspi);
;;;1602     }
;;;1603   
;;;1604   #if (USE_SPI_CRC != 0U)
;;;1605     /* Reset CRC Calculation */
;;;1606     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1607     {
;;;1608       SPI_RESET_CRC(hspi);
;;;1609     }
;;;1610   #endif /* USE_SPI_CRC */
;;;1611   
;;;1612     /* Enable TXE and ERR interrupt */
;;;1613     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
;;;1614   
;;;1615   
;;;1616     /* Check if the SPI is already enabled */
;;;1617     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1618     {
;;;1619       /* Enable SPI peripheral */
;;;1620       __HAL_SPI_ENABLE(hspi);
;;;1621     }
;;;1622   
;;;1623   error :
;;;1624     __HAL_UNLOCK(hspi);
;;;1625     return errorcode;
;;;1626   }
000026  bd30              POP      {r4,r5,pc}
                  |L25.40|
000028  2301              MOVS     r3,#1                 ;1563
00002a  e03e              B        |L25.170|
                  |L25.44|
00002c  2503              MOVS     r5,#3                 ;1574
00002e  f880505d          STRB     r5,[r0,#0x5d]         ;1574
000032  6604              STR      r4,[r0,#0x60]         ;1575
000034  6381              STR      r1,[r0,#0x38]         ;1576
000036  8782              STRH     r2,[r0,#0x3c]         ;1577
000038  87c2              STRH     r2,[r0,#0x3e]         ;1578
00003a  6404              STR      r4,[r0,#0x40]         ;1581
00003c  f8a04044          STRH     r4,[r0,#0x44]         ;1582
000040  f8a04046          STRH     r4,[r0,#0x46]         ;1583
000044  64c4              STR      r4,[r0,#0x4c]         ;1584
000046  68c1              LDR      r1,[r0,#0xc]          ;1587
000048  f5b16fe0          CMP      r1,#0x700             ;1587
00004c  d902              BLS      |L25.84|
00004e  4919              LDR      r1,|L25.180|
000050  6501              STR      r1,[r0,#0x50]         ;1589
000052  e001              B        |L25.88|
                  |L25.84|
000054  4918              LDR      r1,|L25.184|
000056  6501              STR      r1,[r0,#0x50]         ;1593
                  |L25.88|
000058  6881              LDR      r1,[r0,#8]            ;1597
00005a  f5b14f00          CMP      r1,#0x8000            ;1597
00005e  d109              BNE      |L25.116|
000060  6801              LDR      r1,[r0,#0]            ;1600
000062  680a              LDR      r2,[r1,#0]            ;1600
000064  f0220240          BIC      r2,r2,#0x40           ;1600
000068  600a              STR      r2,[r1,#0]            ;1600
00006a  6801              LDR      r1,[r0,#0]            ;1601
00006c  680a              LDR      r2,[r1,#0]            ;1601
00006e  f4424280          ORR      r2,r2,#0x4000         ;1601
000072  600a              STR      r2,[r1,#0]            ;1601
                  |L25.116|
000074  6a81              LDR      r1,[r0,#0x28]         ;1606
000076  f5b15f00          CMP      r1,#0x2000            ;1606
00007a  d109              BNE      |L25.144|
00007c  6801              LDR      r1,[r0,#0]            ;1608
00007e  680a              LDR      r2,[r1,#0]            ;1608
000080  f4225200          BIC      r2,r2,#0x2000         ;1608
000084  600a              STR      r2,[r1,#0]            ;1608
000086  6801              LDR      r1,[r0,#0]            ;1608
000088  680a              LDR      r2,[r1,#0]            ;1608
00008a  f4425200          ORR      r2,r2,#0x2000         ;1608
00008e  600a              STR      r2,[r1,#0]            ;1608
                  |L25.144|
000090  6801              LDR      r1,[r0,#0]            ;1613
000092  684a              LDR      r2,[r1,#4]            ;1613
000094  f04202a0          ORR      r2,r2,#0xa0           ;1613
000098  604a              STR      r2,[r1,#4]            ;1613
00009a  6801              LDR      r1,[r0,#0]            ;1617
00009c  680a              LDR      r2,[r1,#0]            ;1617
00009e  0652              LSLS     r2,r2,#25             ;1617
0000a0  d403              BMI      |L25.170|
0000a2  680a              LDR      r2,[r1,#0]            ;1620
0000a4  f0420240          ORR      r2,r2,#0x40           ;1620
0000a8  600a              STR      r2,[r1,#0]            ;1620
                  |L25.170|
0000aa  f880405c          STRB     r4,[r0,#0x5c]         ;1624
0000ae  4618              MOV      r0,r3                 ;1625
0000b0  bd30              POP      {r4,r5,pc}
;;;1627   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L25.180|
                          DCD      SPI_TxISR_16BIT
                  |L25.184|
                          DCD      SPI_TxISR_8BIT

                          AREA ||i.HAL_SPI_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxCpltCallback PROC
;;;2821     */
;;;2822   __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2823   {
;;;2824     /* Prevent unused argument(s) compilation warning */
;;;2825     UNUSED(hspi);
;;;2826   
;;;2827     /* NOTE : This function should not be modified, when the callback is needed,
;;;2828               the HAL_SPI_TxCpltCallback should be implemented in the user file
;;;2829      */
;;;2830   }
;;;2831   
                          ENDP


                          AREA ||i.HAL_SPI_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxHalfCpltCallback PROC
;;;2869     */
;;;2870   __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2871   {
;;;2872     /* Prevent unused argument(s) compilation warning */
;;;2873     UNUSED(hspi);
;;;2874   
;;;2875     /* NOTE : This function should not be modified, when the callback is needed,
;;;2876               the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
;;;2877      */
;;;2878   }
;;;2879   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxCpltCallback PROC
;;;2853     */
;;;2854   __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2855   {
;;;2856     /* Prevent unused argument(s) compilation warning */
;;;2857     UNUSED(hspi);
;;;2858   
;;;2859     /* NOTE : This function should not be modified, when the callback is needed,
;;;2860               the HAL_SPI_TxRxCpltCallback should be implemented in the user file
;;;2861      */
;;;2862   }
;;;2863   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxHalfCpltCallback PROC
;;;2901     */
;;;2902   __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2903   {
;;;2904     /* Prevent unused argument(s) compilation warning */
;;;2905     UNUSED(hspi);
;;;2906   
;;;2907     /* NOTE : This function should not be modified, when the callback is needed,
;;;2908               the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
;;;2909      */
;;;2910   }
;;;2911   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_16BIT||, CODE, READONLY, ALIGN=2

                  SPI_2linesRxISR_16BIT PROC
;;;3632     */
;;;3633   static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3634   {
;;;3635     /* Receive data in 16 Bit mode */
;;;3636     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000002  68c9              LDR      r1,[r1,#0xc]
000004  6c02              LDR      r2,[r0,#0x40]
000006  8011              STRH     r1,[r2,#0]
;;;3637     hspi->pRxBuffPtr += sizeof(uint16_t);
000008  6c01              LDR      r1,[r0,#0x40]
00000a  1c89              ADDS     r1,r1,#2
00000c  6401              STR      r1,[r0,#0x40]
;;;3638     hspi->RxXferCount--;
00000e  f8b01046          LDRH     r1,[r0,#0x46]
000012  1e49              SUBS     r1,r1,#1
000014  f8a01046          STRH     r1,[r0,#0x46]
;;;3639   
;;;3640     if (hspi->RxXferCount == 0U)
000018  f8b01046          LDRH     r1,[r0,#0x46]
00001c  2900              CMP      r1,#0
00001e  d10f              BNE      |L30.64|
;;;3641     {
;;;3642   #if (USE_SPI_CRC != 0U)
;;;3643       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000020  6a81              LDR      r1,[r0,#0x28]
000022  f5b15f00          CMP      r1,#0x2000
000026  d009              BEQ      |L30.60|
;;;3644       {
;;;3645         hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
;;;3646         return;
;;;3647       }
;;;3648   #endif /* USE_SPI_CRC */
;;;3649   
;;;3650       /* Disable RXNE interrupt */
;;;3651       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
000028  6801              LDR      r1,[r0,#0]
00002a  684a              LDR      r2,[r1,#4]
00002c  f0220240          BIC      r2,r2,#0x40
000030  604a              STR      r2,[r1,#4]
;;;3652   
;;;3653       if (hspi->TxXferCount == 0U)
000032  8fc1              LDRH     r1,[r0,#0x3e]
000034  2900              CMP      r1,#0
000036  d103              BNE      |L30.64|
;;;3654       {
;;;3655         SPI_CloseRxTx_ISR(hspi);
000038  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L30.60|
00003c  4901              LDR      r1,|L30.68|
00003e  64c1              STR      r1,[r0,#0x4c]         ;3645
                  |L30.64|
;;;3656       }
;;;3657     }
;;;3658   }
000040  4770              BX       lr
;;;3659   
                          ENDP

000042  0000              DCW      0x0000
                  |L30.68|
                          DCD      SPI_2linesRxISR_16BITCRC

                          AREA ||i.SPI_2linesRxISR_16BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_16BITCRC PROC
;;;3666     */
;;;3667   static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3668   {
;;;3669     __IO uint32_t tmpreg = 0U;
;;;3670   
;;;3671     /* Read 16bit CRC to flush Data Register */
;;;3672     tmpreg = READ_REG(hspi->Instance->DR);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  9201              STR      r2,[sp,#4]
;;;3673     /* To avoid GCC warning */
;;;3674     UNUSED(tmpreg);  
;;;3675   
;;;3676     /* Disable RXNE interrupt */
;;;3677     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
000008  684a              LDR      r2,[r1,#4]
00000a  f0220240          BIC      r2,r2,#0x40
00000e  604a              STR      r2,[r1,#4]
;;;3678   
;;;3679     SPI_CloseRxTx_ISR(hspi);
000010  b002              ADD      sp,sp,#8
000012  f7ffbffe          B.W      SPI_CloseRxTx_ISR
;;;3680   }
;;;3681   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_2linesRxISR_8BIT||, CODE, READONLY, ALIGN=2

                  SPI_2linesRxISR_8BIT PROC
;;;3503     */
;;;3504   static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  f8b03046          LDRH     r3,[r0,#0x46]
;;;3505   {
;;;3506     /* Receive data in packing mode */
;;;3507     if (hspi->RxXferCount > 1U)
000004  6802              LDR      r2,[r0,#0]
000006  6c01              LDR      r1,[r0,#0x40]
000008  2b01              CMP      r3,#1
00000a  d912              BLS      |L32.50|
;;;3508     {
;;;3509       *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
00000c  68d2              LDR      r2,[r2,#0xc]
00000e  800a              STRH     r2,[r1,#0]
;;;3510       hspi->pRxBuffPtr += sizeof(uint16_t);
000010  f8501f40          LDR      r1,[r0,#0x40]!
000014  1c89              ADDS     r1,r1,#2
000016  6001              STR      r1,[r0,#0]
;;;3511       hspi->RxXferCount -= 2U;
000018  88c1              LDRH     r1,[r0,#6]
00001a  1e89              SUBS     r1,r1,#2
00001c  80c1              STRH     r1,[r0,#6]
;;;3512       if (hspi->RxXferCount == 1U)
00001e  88c1              LDRH     r1,[r0,#6]
000020  3840              SUBS     r0,r0,#0x40
000022  2901              CMP      r1,#1
000024  d10f              BNE      |L32.70|
;;;3513       {
;;;3514         /* Set RX Fifo threshold according the reception data length: 8bit */
;;;3515         SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
000026  6801              LDR      r1,[r0,#0]
000028  684a              LDR      r2,[r1,#4]
00002a  f4425280          ORR      r2,r2,#0x1000
00002e  604a              STR      r2,[r1,#4]
000030  e009              B        |L32.70|
                  |L32.50|
;;;3516       }
;;;3517     }
;;;3518     /* Receive data in 8 Bit mode */
;;;3519     else
;;;3520     {
;;;3521       *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
000032  7b12              LDRB     r2,[r2,#0xc]
000034  700a              STRB     r2,[r1,#0]
;;;3522       hspi->pRxBuffPtr++;
000036  6c01              LDR      r1,[r0,#0x40]
000038  1c49              ADDS     r1,r1,#1
00003a  6401              STR      r1,[r0,#0x40]
;;;3523       hspi->RxXferCount--;
00003c  f8b01046          LDRH     r1,[r0,#0x46]
000040  1e49              SUBS     r1,r1,#1
000042  f8a01046          STRH     r1,[r0,#0x46]
                  |L32.70|
;;;3524     }
;;;3525   
;;;3526     /* Check end of the reception */
;;;3527     if (hspi->RxXferCount == 0U)
000046  f8b01046          LDRH     r1,[r0,#0x46]
00004a  2900              CMP      r1,#0
00004c  d114              BNE      |L32.120|
;;;3528     {
;;;3529   #if (USE_SPI_CRC != 0U)
;;;3530       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00004e  6a81              LDR      r1,[r0,#0x28]
000050  f5b15f00          CMP      r1,#0x2000
000054  d009              BEQ      |L32.106|
;;;3531       {
;;;3532         SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
;;;3533         hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
;;;3534         return;
;;;3535       }
;;;3536   #endif /* USE_SPI_CRC */
;;;3537   
;;;3538       /* Disable RXNE  and ERR interrupt */
;;;3539       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000056  6801              LDR      r1,[r0,#0]
000058  684a              LDR      r2,[r1,#4]
00005a  f0220260          BIC      r2,r2,#0x60
00005e  604a              STR      r2,[r1,#4]
;;;3540   
;;;3541       if (hspi->TxXferCount == 0U)
000060  8fc1              LDRH     r1,[r0,#0x3e]
000062  2900              CMP      r1,#0
000064  d108              BNE      |L32.120|
;;;3542       {
;;;3543         SPI_CloseRxTx_ISR(hspi);
000066  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L32.106|
00006a  6801              LDR      r1,[r0,#0]            ;3532
00006c  684a              LDR      r2,[r1,#4]            ;3532
00006e  f4425280          ORR      r2,r2,#0x1000         ;3532
000072  604a              STR      r2,[r1,#4]            ;3532
000074  4901              LDR      r1,|L32.124|
000076  64c1              STR      r1,[r0,#0x4c]         ;3533
                  |L32.120|
;;;3544       }
;;;3545     }
;;;3546   }
000078  4770              BX       lr
;;;3547   
                          ENDP

00007a  0000              DCW      0x0000
                  |L32.124|
                          DCD      SPI_2linesRxISR_8BITCRC

                          AREA ||i.SPI_2linesRxISR_8BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_8BITCRC PROC
;;;3554     */
;;;3555   static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3556   {
;;;3557     __IO uint32_t tmpreg = 0U;
;;;3558   
;;;3559     /* Read 8bit CRC to flush Data Register */
;;;3560     tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
000002  6801              LDR      r1,[r0,#0]
000004  7b0a              LDRB     r2,[r1,#0xc]
000006  9201              STR      r2,[sp,#4]
;;;3561     /* To avoid GCC warning */
;;;3562     UNUSED(tmpreg);
;;;3563   
;;;3564     hspi->CRCSize--;
000008  6c82              LDR      r2,[r0,#0x48]
00000a  1e52              SUBS     r2,r2,#1
00000c  6482              STR      r2,[r0,#0x48]
;;;3565   
;;;3566     /* Check end of the reception */
;;;3567     if (hspi->CRCSize == 0U)
00000e  2a00              CMP      r2,#0
000010  d109              BNE      |L33.38|
;;;3568     {
;;;3569       /* Disable RXNE and ERR interrupt */
;;;3570       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000012  684a              LDR      r2,[r1,#4]
000014  f0220260          BIC      r2,r2,#0x60
000018  604a              STR      r2,[r1,#4]
;;;3571   
;;;3572       if (hspi->TxXferCount == 0U)
00001a  8fc1              LDRH     r1,[r0,#0x3e]
00001c  2900              CMP      r1,#0
00001e  d102              BNE      |L33.38|
;;;3573       {
;;;3574         SPI_CloseRxTx_ISR(hspi);
000020  b002              ADD      sp,sp,#8
000022  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L33.38|
;;;3575       }
;;;3576     }
;;;3577   }
000026  b002              ADD      sp,sp,#8
000028  4770              BX       lr
;;;3578   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_2linesTxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_16BIT PROC
;;;3688     */
;;;3689   static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b81              LDR      r1,[r0,#0x38]
;;;3690   {
;;;3691     /* Transmit data in 16 Bit mode */
;;;3692     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  8809              LDRH     r1,[r1,#0]
000006  60d1              STR      r1,[r2,#0xc]
;;;3693     hspi->pTxBuffPtr += sizeof(uint16_t);
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c89              ADDS     r1,r1,#2
00000c  6381              STR      r1,[r0,#0x38]
;;;3694     hspi->TxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;3695   
;;;3696     /* Enable CRC Transmission */
;;;3697     if (hspi->TxXferCount == 0U)
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  2900              CMP      r1,#0
000018  d118              BNE      |L34.76|
;;;3698     {
;;;3699   #if (USE_SPI_CRC != 0U)
;;;3700       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d00a              BEQ      |L34.56|
;;;3701       {
;;;3702         /* Set CRC Next Bit to send CRC */
;;;3703         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3704         /* Disable TXE interrupt */
;;;3705         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3706         return;
;;;3707       }
;;;3708   #endif /* USE_SPI_CRC */
;;;3709   
;;;3710       /* Disable TXE interrupt */
;;;3711       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
000022  6801              LDR      r1,[r0,#0]
000024  684a              LDR      r2,[r1,#4]
000026  f0220280          BIC      r2,r2,#0x80
00002a  604a              STR      r2,[r1,#4]
;;;3712   
;;;3713       if (hspi->RxXferCount == 0U)
00002c  f8b01046          LDRH     r1,[r0,#0x46]
000030  2900              CMP      r1,#0
000032  d10b              BNE      |L34.76|
;;;3714       {
;;;3715         SPI_CloseRxTx_ISR(hspi);
000034  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L34.56|
000038  6801              LDR      r1,[r0,#0]            ;3703
00003a  680a              LDR      r2,[r1,#0]            ;3703
00003c  f4425280          ORR      r2,r2,#0x1000         ;3703
000040  600a              STR      r2,[r1,#0]            ;3703
000042  6800              LDR      r0,[r0,#0]            ;3705
000044  6841              LDR      r1,[r0,#4]            ;3705
000046  f0210180          BIC      r1,r1,#0x80           ;3705
00004a  6041              STR      r1,[r0,#4]            ;3705
                  |L34.76|
;;;3716       }
;;;3717     }
;;;3718   }
00004c  4770              BX       lr
;;;3719   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_8BIT PROC
;;;3585     */
;;;3586   static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  8fc3              LDRH     r3,[r0,#0x3e]
;;;3587   {
;;;3588     /* Transmit data in packing Bit mode */
;;;3589     if (hspi->TxXferCount >= 2U)
000002  6802              LDR      r2,[r0,#0]
000004  6b81              LDR      r1,[r0,#0x38]
000006  2b02              CMP      r3,#2
000008  d308              BCC      |L35.28|
;;;3590     {
;;;3591       hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
00000a  8809              LDRH     r1,[r1,#0]
00000c  60d1              STR      r1,[r2,#0xc]
;;;3592       hspi->pTxBuffPtr += sizeof(uint16_t);
00000e  6b81              LDR      r1,[r0,#0x38]
000010  1c89              ADDS     r1,r1,#2
000012  6381              STR      r1,[r0,#0x38]
;;;3593       hspi->TxXferCount -= 2U;
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  1e89              SUBS     r1,r1,#2
000018  87c1              STRH     r1,[r0,#0x3e]
00001a  e007              B        |L35.44|
                  |L35.28|
;;;3594     }
;;;3595     /* Transmit data in 8 Bit mode */
;;;3596     else
;;;3597     {
;;;3598       *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
00001c  7809              LDRB     r1,[r1,#0]
00001e  7311              STRB     r1,[r2,#0xc]
;;;3599       hspi->pTxBuffPtr++;
000020  6b81              LDR      r1,[r0,#0x38]
000022  1c49              ADDS     r1,r1,#1
000024  6381              STR      r1,[r0,#0x38]
;;;3600       hspi->TxXferCount--;
000026  8fc1              LDRH     r1,[r0,#0x3e]
000028  1e49              SUBS     r1,r1,#1
00002a  87c1              STRH     r1,[r0,#0x3e]
                  |L35.44|
;;;3601     }
;;;3602   
;;;3603     /* Check the end of the transmission */
;;;3604     if (hspi->TxXferCount == 0U)
00002c  8fc1              LDRH     r1,[r0,#0x3e]
00002e  2900              CMP      r1,#0
000030  d118              BNE      |L35.100|
;;;3605     {
;;;3606   #if (USE_SPI_CRC != 0U)
;;;3607       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000032  6a81              LDR      r1,[r0,#0x28]
000034  f5b15f00          CMP      r1,#0x2000
000038  d00a              BEQ      |L35.80|
;;;3608       {
;;;3609         /* Set CRC Next Bit to send CRC */
;;;3610         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3611         /* Disable TXE interrupt */
;;;3612         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3613         return;
;;;3614       }
;;;3615   #endif /* USE_SPI_CRC */
;;;3616   
;;;3617       /* Disable TXE interrupt */
;;;3618       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
00003a  6801              LDR      r1,[r0,#0]
00003c  684a              LDR      r2,[r1,#4]
00003e  f0220280          BIC      r2,r2,#0x80
000042  604a              STR      r2,[r1,#4]
;;;3619   
;;;3620       if (hspi->RxXferCount == 0U)
000044  f8b01046          LDRH     r1,[r0,#0x46]
000048  2900              CMP      r1,#0
00004a  d10b              BNE      |L35.100|
;;;3621       {
;;;3622         SPI_CloseRxTx_ISR(hspi);
00004c  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L35.80|
000050  6801              LDR      r1,[r0,#0]            ;3610
000052  680a              LDR      r2,[r1,#0]            ;3610
000054  f4425280          ORR      r2,r2,#0x1000         ;3610
000058  600a              STR      r2,[r1,#0]            ;3610
00005a  6800              LDR      r0,[r0,#0]            ;3612
00005c  6841              LDR      r1,[r0,#4]            ;3612
00005e  f0210180          BIC      r1,r1,#0x80           ;3612
000062  6041              STR      r1,[r0,#4]            ;3612
                  |L35.100|
;;;3623       }
;;;3624     }
;;;3625   }
000064  4770              BX       lr
;;;3626   
                          ENDP


                          AREA ||i.SPI_AbortRx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_AbortRx_ISR PROC
;;;4290     */
;;;4291   static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;4292   {
000002  4604              MOV      r4,r0
;;;4293     __IO uint32_t count;
;;;4294   
;;;4295     /* Disable SPI Peripheral */
;;;4296     __HAL_SPI_DISABLE(hspi);
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f0210140          BIC      r1,r1,#0x40
00000c  6001              STR      r1,[r0,#0]
;;;4297   
;;;4298     count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
00000e  481c              LDR      r0,|L36.128|
000010  f64551c0          MOV      r1,#0x5dc0
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  fbb0f0f1          UDIV     r0,r0,r1
00001a  2164              MOVS     r1,#0x64
00001c  4348              MULS     r0,r1,r0
00001e  9001              STR      r0,[sp,#4]
;;;4299   
;;;4300     /* Disable RXNEIE interrupt */
;;;4301     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXNEIE));
000020  6820              LDR      r0,[r4,#0]
000022  6841              LDR      r1,[r0,#4]
000024  f0210140          BIC      r1,r1,#0x40
000028  6041              STR      r1,[r0,#4]
                  |L36.42|
;;;4302   
;;;4303     /* Check RXNEIE is disabled */
;;;4304     do
;;;4305     {
;;;4306       if (count == 0U)
00002a  9801              LDR      r0,[sp,#4]
00002c  b310              CBZ      r0,|L36.116|
;;;4307       {
;;;4308         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;4309         break;
;;;4310       }
;;;4311       count--;
00002e  9801              LDR      r0,[sp,#4]
000030  1e40              SUBS     r0,r0,#1
000032  9001              STR      r0,[sp,#4]
;;;4312     } while (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE));
000034  6820              LDR      r0,[r4,#0]
000036  6840              LDR      r0,[r0,#4]
000038  0640              LSLS     r0,r0,#25
00003a  d4f6              BMI      |L36.42|
                  |L36.60|
;;;4313   
;;;4314     /* Control the BSY flag */
;;;4315     if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
00003c  f7fffffe          BL       HAL_GetTick
000040  9000              STR      r0,[sp,#0]
000042  2364              MOVS     r3,#0x64
000044  2200              MOVS     r2,#0
000046  2180              MOVS     r1,#0x80
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
;;;4316     {
;;;4317       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
00004e  2540              MOVS     r5,#0x40
000050  b100              CBZ      r0,|L36.84|
000052  6625              STR      r5,[r4,#0x60]
                  |L36.84|
;;;4318     }
;;;4319   
;;;4320     /* Empty the FRLVL fifo */
;;;4321     if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000054  f7fffffe          BL       HAL_GetTick
000058  9000              STR      r0,[sp,#0]
00005a  2364              MOVS     r3,#0x64
00005c  2200              MOVS     r2,#0
00005e  f44f61c0          MOV      r1,#0x600
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
000068  b100              CBZ      r0,|L36.108|
;;;4322     {
;;;4323       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
00006a  6625              STR      r5,[r4,#0x60]
                  |L36.108|
;;;4324     }
;;;4325   
;;;4326     hspi->State = HAL_SPI_STATE_ABORT;
00006c  2007              MOVS     r0,#7
00006e  f884005d          STRB     r0,[r4,#0x5d]
;;;4327   }
000072  bd7c              POP      {r2-r6,pc}
                  |L36.116|
000074  6e20              LDR      r0,[r4,#0x60]         ;4308
000076  f0400040          ORR      r0,r0,#0x40           ;4308
00007a  6620              STR      r0,[r4,#0x60]         ;4308
00007c  e7de              B        |L36.60|
;;;4328   
                          ENDP

00007e  0000              DCW      0x0000
                  |L36.128|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_AbortTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_AbortTx_ISR PROC
;;;4334     */
;;;4335   static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;4336   {
000002  4604              MOV      r4,r0
;;;4337     __IO uint32_t count;
;;;4338   
;;;4339     count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  4834              LDR      r0,|L37.216|
000006  f64551c0          MOV      r1,#0x5dc0
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  2164              MOVS     r1,#0x64
000012  4348              MULS     r0,r1,r0
000014  9001              STR      r0,[sp,#4]
;;;4340   
;;;4341     /* Disable TXEIE interrupt */
;;;4342     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
000016  6820              LDR      r0,[r4,#0]
000018  6841              LDR      r1,[r0,#4]
00001a  f0210180          BIC      r1,r1,#0x80
00001e  6041              STR      r1,[r0,#4]
                  |L37.32|
;;;4343   
;;;4344     /* Check TXEIE is disabled */
;;;4345     do
;;;4346     {
;;;4347       if (count == 0U)
000020  9801              LDR      r0,[sp,#4]
000022  2800              CMP      r0,#0
000024  d04d              BEQ      |L37.194|
;;;4348       {
;;;4349         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;4350         break;
;;;4351       }
;;;4352       count--;
000026  9801              LDR      r0,[sp,#4]
000028  1e40              SUBS     r0,r0,#1
00002a  9001              STR      r0,[sp,#4]
;;;4353     } while (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE));
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  0600              LSLS     r0,r0,#24
000032  d4f5              BMI      |L37.32|
                  |L37.52|
;;;4354   
;;;4355     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000034  f7fffffe          BL       HAL_GetTick
000038  4602              MOV      r2,r0
00003a  2164              MOVS     r1,#0x64
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       SPI_EndRxTxTransaction
;;;4356     {
;;;4357       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000042  2540              MOVS     r5,#0x40
000044  b100              CBZ      r0,|L37.72|
000046  6625              STR      r5,[r4,#0x60]
                  |L37.72|
;;;4358     }
;;;4359   
;;;4360     /* Disable SPI Peripheral */
;;;4361     __HAL_SPI_DISABLE(hspi);
000048  6820              LDR      r0,[r4,#0]
00004a  6801              LDR      r1,[r0,#0]
00004c  f0210140          BIC      r1,r1,#0x40
000050  6001              STR      r1,[r0,#0]
;;;4362   
;;;4363     /* Empty the FRLVL fifo */
;;;4364     if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000052  f7fffffe          BL       HAL_GetTick
000056  f44f66c0          MOV      r6,#0x600
00005a  9000              STR      r0,[sp,#0]
00005c  2364              MOVS     r3,#0x64
00005e  2200              MOVS     r2,#0
000060  4631              MOV      r1,r6
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
000068  b100              CBZ      r0,|L37.108|
;;;4365     {
;;;4366       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
00006a  6625              STR      r5,[r4,#0x60]
                  |L37.108|
;;;4367     }
;;;4368   
;;;4369     /* Check case of Full-Duplex Mode and disable directly RXNEIE interrupt */
;;;4370     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
00006c  6820              LDR      r0,[r4,#0]
00006e  6841              LDR      r1,[r0,#4]
000070  0649              LSLS     r1,r1,#25
000072  d522              BPL      |L37.186|
;;;4371     {
;;;4372       /* Disable RXNEIE interrupt */
;;;4373       CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXNEIE));
000074  6841              LDR      r1,[r0,#4]
000076  f0210140          BIC      r1,r1,#0x40
00007a  6041              STR      r1,[r0,#4]
                  |L37.124|
;;;4374   
;;;4375       /* Check RXNEIE is disabled */
;;;4376       do
;;;4377       {
;;;4378         if (count == 0U)
00007c  9801              LDR      r0,[sp,#4]
00007e  b328              CBZ      r0,|L37.204|
;;;4379         {
;;;4380           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;4381           break;
;;;4382         }
;;;4383         count--;
000080  9801              LDR      r0,[sp,#4]
000082  1e40              SUBS     r0,r0,#1
000084  9001              STR      r0,[sp,#4]
;;;4384       } while (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE));
000086  6820              LDR      r0,[r4,#0]
000088  6840              LDR      r0,[r0,#4]
00008a  0640              LSLS     r0,r0,#25
00008c  d4f6              BMI      |L37.124|
                  |L37.142|
;;;4385   
;;;4386       /* Control the BSY flag */
;;;4387       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
00008e  f7fffffe          BL       HAL_GetTick
000092  9000              STR      r0,[sp,#0]
000094  2364              MOVS     r3,#0x64
000096  2200              MOVS     r2,#0
000098  2180              MOVS     r1,#0x80
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
0000a0  b100              CBZ      r0,|L37.164|
;;;4388       {
;;;4389         hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000a2  6625              STR      r5,[r4,#0x60]
                  |L37.164|
;;;4390       }
;;;4391   
;;;4392       /* Empty the FRLVL fifo */
;;;4393       if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
0000a4  f7fffffe          BL       HAL_GetTick
0000a8  9000              STR      r0,[sp,#0]
0000aa  2364              MOVS     r3,#0x64
0000ac  2200              MOVS     r2,#0
0000ae  4631              MOV      r1,r6
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
0000b6  b100              CBZ      r0,|L37.186|
;;;4394       {
;;;4395         hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000b8  6625              STR      r5,[r4,#0x60]
                  |L37.186|
;;;4396       }
;;;4397     }
;;;4398     hspi->State = HAL_SPI_STATE_ABORT;
0000ba  2007              MOVS     r0,#7
0000bc  f884005d          STRB     r0,[r4,#0x5d]
;;;4399   }
0000c0  bd7c              POP      {r2-r6,pc}
                  |L37.194|
0000c2  6e20              LDR      r0,[r4,#0x60]         ;4349
0000c4  f0400040          ORR      r0,r0,#0x40           ;4349
0000c8  6620              STR      r0,[r4,#0x60]         ;4349
0000ca  e7b3              B        |L37.52|
                  |L37.204|
0000cc  6e20              LDR      r0,[r4,#0x60]         ;4380
0000ce  f0400040          ORR      r0,r0,#0x40           ;4380
0000d2  6620              STR      r0,[r4,#0x60]         ;4380
0000d4  e7db              B        |L37.142|
;;;4400   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L37.216|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_CloseRxTx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseRxTx_ISR PROC
;;;4107     */
;;;4108   static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;4109   {
000002  4604              MOV      r4,r0
;;;4110     uint32_t tickstart;
;;;4111   
;;;4112     /* Init tickstart for timeout management */
;;;4113     tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4602              MOV      r2,r0
;;;4114   
;;;4115     /* Disable ERR interrupt */
;;;4116     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00000a  6820              LDR      r0,[r4,#0]
00000c  6841              LDR      r1,[r0,#4]
00000e  f0210120          BIC      r1,r1,#0x20
000012  6041              STR      r1,[r0,#4]
;;;4117   
;;;4118     /* Check the end of the transaction */
;;;4119     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000014  2164              MOVS     r1,#0x64
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_EndRxTxTransaction
00001c  b118              CBZ      r0,|L38.38|
;;;4120     {
;;;4121       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00001e  6e20              LDR      r0,[r4,#0x60]
000020  f0400020          ORR      r0,r0,#0x20
000024  6620              STR      r0,[r4,#0x60]
                  |L38.38|
;;;4122     }
;;;4123   
;;;4124   #if (USE_SPI_CRC != 0U)
;;;4125     /* Check if CRC error occurred */
;;;4126     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
000026  6820              LDR      r0,[r4,#0]
000028  6881              LDR      r1,[r0,#8]
00002a  43c9              MVNS     r1,r1
00002c  06ca              LSLS     r2,r1,#27
;;;4127     {
;;;4128       hspi->State = HAL_SPI_STATE_READY;
00002e  f04f0101          MOV      r1,#1
000032  d40c              BMI      |L38.78|
000034  f884105d          STRB     r1,[r4,#0x5d]
;;;4129       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
000038  6e21              LDR      r1,[r4,#0x60]
00003a  f0410102          ORR      r1,r1,#2
00003e  6621              STR      r1,[r4,#0x60]
;;;4130       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
000040  f64f71ef          MOV      r1,#0xffef
000044  6081              STR      r1,[r0,#8]
;;;4131       /* Call user error callback */
;;;4132   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4133       hspi->ErrorCallback(hspi);
;;;4134   #else
;;;4135       HAL_SPI_ErrorCallback(hspi);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;4136   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4137     }
;;;4138     else
;;;4139     {
;;;4140   #endif /* USE_SPI_CRC */
;;;4141       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
;;;4142       {
;;;4143         if (hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;4144         {
;;;4145           hspi->State = HAL_SPI_STATE_READY;
;;;4146           /* Call user Rx complete callback */
;;;4147   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4148           hspi->RxCpltCallback(hspi);
;;;4149   #else
;;;4150           HAL_SPI_RxCpltCallback(hspi);
;;;4151   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4152         }
;;;4153         else
;;;4154         {
;;;4155           hspi->State = HAL_SPI_STATE_READY;
;;;4156           /* Call user TxRx complete callback */
;;;4157   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4158           hspi->TxRxCpltCallback(hspi);
;;;4159   #else
;;;4160           HAL_SPI_TxRxCpltCallback(hspi);
;;;4161   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4162         }
;;;4163       }
;;;4164       else
;;;4165       {
;;;4166         hspi->State = HAL_SPI_STATE_READY;
;;;4167         /* Call user error callback */
;;;4168   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4169         hspi->ErrorCallback(hspi);
;;;4170   #else
;;;4171         HAL_SPI_ErrorCallback(hspi);
;;;4172   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4173       }
;;;4174   #if (USE_SPI_CRC != 0U)
;;;4175     }
;;;4176   #endif /* USE_SPI_CRC */
;;;4177   }
00004c  bd10              POP      {r4,pc}
                  |L38.78|
00004e  6e20              LDR      r0,[r4,#0x60]         ;4141
000050  b128              CBZ      r0,|L38.94|
000052  f884105d          STRB     r1,[r4,#0x5d]         ;4166
000056  4620              MOV      r0,r4                 ;4171
000058  f7fffffe          BL       HAL_SPI_ErrorCallback
00005c  bd10              POP      {r4,pc}
                  |L38.94|
00005e  f894005d          LDRB     r0,[r4,#0x5d]         ;4143
000062  2804              CMP      r0,#4                 ;4143
000064  d005              BEQ      |L38.114|
000066  f884105d          STRB     r1,[r4,#0x5d]         ;4155
00006a  4620              MOV      r0,r4                 ;4160
00006c  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
000070  bd10              POP      {r4,pc}
                  |L38.114|
000072  f884105d          STRB     r1,[r4,#0x5d]         ;4145
000076  4620              MOV      r0,r4                 ;4150
000078  f7fffffe          BL       HAL_SPI_RxCpltCallback
00007c  bd10              POP      {r4,pc}
;;;4178   
                          ENDP


                          AREA ||i.SPI_CloseRx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseRx_ISR PROC
;;;4184     */
;;;4185   static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;4186   {
000002  4604              MOV      r4,r0
;;;4187     /* Disable RXNE and ERR interrupt */
;;;4188     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6841              LDR      r1,[r0,#4]
000008  f0210160          BIC      r1,r1,#0x60
00000c  6041              STR      r1,[r0,#4]
;;;4189   
;;;4190     /* Check the end of the transaction */
;;;4191     if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
00000e  f7fffffe          BL       HAL_GetTick
000012  4602              MOV      r2,r0
000014  2164              MOVS     r1,#0x64
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_EndRxTransaction
00001c  b118              CBZ      r0,|L39.38|
;;;4192     {
;;;4193       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00001e  6e20              LDR      r0,[r4,#0x60]
000020  f0400020          ORR      r0,r0,#0x20
000024  6620              STR      r0,[r4,#0x60]
                  |L39.38|
;;;4194     }
;;;4195     hspi->State = HAL_SPI_STATE_READY;
000026  2001              MOVS     r0,#1
000028  f884005d          STRB     r0,[r4,#0x5d]
;;;4196   
;;;4197   #if (USE_SPI_CRC != 0U)
;;;4198     /* Check if CRC error occurred */
;;;4199     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
00002c  6820              LDR      r0,[r4,#0]
00002e  6881              LDR      r1,[r0,#8]
000030  43c9              MVNS     r1,r1
000032  06c9              LSLS     r1,r1,#27
000034  d40a              BMI      |L39.76|
;;;4200     {
;;;4201       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
000036  6e21              LDR      r1,[r4,#0x60]
000038  f0410102          ORR      r1,r1,#2
00003c  6621              STR      r1,[r4,#0x60]
;;;4202       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
00003e  f64f71ef          MOV      r1,#0xffef
000042  6081              STR      r1,[r0,#8]
;;;4203       /* Call user error callback */
;;;4204   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4205       hspi->ErrorCallback(hspi);
;;;4206   #else
;;;4207       HAL_SPI_ErrorCallback(hspi);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;4208   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4209     }
;;;4210     else
;;;4211     {
;;;4212   #endif /* USE_SPI_CRC */
;;;4213       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
;;;4214       {
;;;4215         /* Call user Rx complete callback */
;;;4216   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4217         hspi->RxCpltCallback(hspi);
;;;4218   #else
;;;4219         HAL_SPI_RxCpltCallback(hspi);
;;;4220   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4221       }
;;;4222       else
;;;4223       {
;;;4224         /* Call user error callback */
;;;4225   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4226         hspi->ErrorCallback(hspi);
;;;4227   #else
;;;4228         HAL_SPI_ErrorCallback(hspi);
;;;4229   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4230       }
;;;4231   #if (USE_SPI_CRC != 0U)
;;;4232     }
;;;4233   #endif /* USE_SPI_CRC */
;;;4234   }
00004a  bd10              POP      {r4,pc}
                  |L39.76|
00004c  6e20              LDR      r0,[r4,#0x60]         ;4213
00004e  b118              CBZ      r0,|L39.88|
000050  4620              MOV      r0,r4                 ;4228
000052  f7fffffe          BL       HAL_SPI_ErrorCallback
000056  bd10              POP      {r4,pc}
                  |L39.88|
000058  4620              MOV      r0,r4                 ;4219
00005a  f7fffffe          BL       HAL_SPI_RxCpltCallback
00005e  bd10              POP      {r4,pc}
;;;4235   
                          ENDP


                          AREA ||i.SPI_CloseTx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseTx_ISR PROC
;;;4241     */
;;;4242   static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;4243   {
000002  4604              MOV      r4,r0
;;;4244     uint32_t tickstart;
;;;4245   
;;;4246     /* Init tickstart for timeout management*/
;;;4247     tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4602              MOV      r2,r0
;;;4248   
;;;4249     /* Disable TXE and ERR interrupt */
;;;4250     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
00000a  6820              LDR      r0,[r4,#0]
00000c  6841              LDR      r1,[r0,#4]
00000e  f02101a0          BIC      r1,r1,#0xa0
000012  6041              STR      r1,[r0,#4]
;;;4251   
;;;4252     /* Check the end of the transaction */
;;;4253     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000014  2164              MOVS     r1,#0x64
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_EndRxTxTransaction
00001c  b118              CBZ      r0,|L40.38|
;;;4254     {
;;;4255       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00001e  6e20              LDR      r0,[r4,#0x60]
000020  f0400020          ORR      r0,r0,#0x20
000024  6620              STR      r0,[r4,#0x60]
                  |L40.38|
;;;4256     }
;;;4257   
;;;4258     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;4259     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000026  68a0              LDR      r0,[r4,#8]
000028  b918              CBNZ     r0,|L40.50|
;;;4260     {
;;;4261       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  6880              LDR      r0,[r0,#8]
000030  9000              STR      r0,[sp,#0]
                  |L40.50|
;;;4262     }
;;;4263   
;;;4264     hspi->State = HAL_SPI_STATE_READY;
000032  2001              MOVS     r0,#1
000034  f884005d          STRB     r0,[r4,#0x5d]
;;;4265     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000038  6e20              LDR      r0,[r4,#0x60]
00003a  b118              CBZ      r0,|L40.68|
;;;4266     {
;;;4267       /* Call user error callback */
;;;4268   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4269       hspi->ErrorCallback(hspi);
;;;4270   #else
;;;4271       HAL_SPI_ErrorCallback(hspi);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;4272   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4273     }
;;;4274     else
;;;4275     {
;;;4276       /* Call user Rx complete callback */
;;;4277   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;4278       hspi->TxCpltCallback(hspi);
;;;4279   #else
;;;4280       HAL_SPI_TxCpltCallback(hspi);
;;;4281   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;4282     }
;;;4283   }
000042  bd38              POP      {r3-r5,pc}
                  |L40.68|
000044  4620              MOV      r0,r4                 ;4280
000046  f7fffffe          BL       HAL_SPI_TxCpltCallback
00004a  bd38              POP      {r3-r5,pc}
;;;4284   
                          ENDP


                          AREA ||i.SPI_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  SPI_DMAAbortOnError PROC
;;;3350     */
;;;3351   static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3352   {
;;;3353     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a80              LDR      r0,[r0,#0x28]
;;;3354     hspi->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a01046          STRH     r1,[r0,#0x46]
;;;3355     hspi->TxXferCount = 0U;
00000a  87c1              STRH     r1,[r0,#0x3e]
;;;3356   
;;;3357     /* Call user error callback */
;;;3358   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3359     hspi->ErrorCallback(hspi);
;;;3360   #else
;;;3361     HAL_SPI_ErrorCallback(hspi);
00000c  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3362   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3363   }
000010  bd10              POP      {r4,pc}
;;;3364   
                          ENDP


                          AREA ||i.SPI_DMAError||, CODE, READONLY, ALIGN=1

                  SPI_DMAError PROC
;;;3327     */
;;;3328   static void SPI_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3329   {
;;;3330     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a80              LDR      r0,[r0,#0x28]
;;;3331   
;;;3332     /* Stop the disable DMA transfer on SPI side */
;;;3333     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000004  6801              LDR      r1,[r0,#0]
000006  684a              LDR      r2,[r1,#4]
000008  f0220203          BIC      r2,r2,#3
00000c  604a              STR      r2,[r1,#4]
;;;3334   
;;;3335     SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
00000e  6e01              LDR      r1,[r0,#0x60]
000010  f0410110          ORR      r1,r1,#0x10
000014  6601              STR      r1,[r0,#0x60]
;;;3336     hspi->State = HAL_SPI_STATE_READY;
000016  2101              MOVS     r1,#1
000018  f880105d          STRB     r1,[r0,#0x5d]
;;;3337     /* Call user error callback */
;;;3338   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3339     hspi->ErrorCallback(hspi);
;;;3340   #else
;;;3341     HAL_SPI_ErrorCallback(hspi);
00001c  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3342   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3343   }
000020  bd10              POP      {r4,pc}
;;;3344   
                          ENDP


                          AREA ||i.SPI_DMAHalfReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfReceiveCplt PROC
;;;3291     */
;;;3292   static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3293   {
;;;3294     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a80              LDR      r0,[r0,#0x28]
;;;3295   
;;;3296     /* Call user Rx half complete callback */
;;;3297   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3298     hspi->RxHalfCpltCallback(hspi);
;;;3299   #else
;;;3300     HAL_SPI_RxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_RxHalfCpltCallback
;;;3301   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3302   }
000008  bd10              POP      {r4,pc}
;;;3303   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitCplt PROC
;;;3273     */
;;;3274   static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3275   {
;;;3276     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a80              LDR      r0,[r0,#0x28]
;;;3277   
;;;3278     /* Call user Tx half complete callback */
;;;3279   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3280     hspi->TxHalfCpltCallback(hspi);
;;;3281   #else
;;;3282     HAL_SPI_TxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_TxHalfCpltCallback
;;;3283   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3284   }
000008  bd10              POP      {r4,pc}
;;;3285   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitReceiveCplt PROC
;;;3309     */
;;;3310   static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3311   {
;;;3312     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a80              LDR      r0,[r0,#0x28]
;;;3313   
;;;3314     /* Call user TxRx half complete callback */
;;;3315   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3316     hspi->TxRxHalfCpltCallback(hspi);
;;;3317   #else
;;;3318     HAL_SPI_TxRxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_TxRxHalfCpltCallback
;;;3319   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3320   }
000008  bd10              POP      {r4,pc}
;;;3321   
                          ENDP


                          AREA ||i.SPI_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAReceiveCplt PROC
;;;3064     */
;;;3065   static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3066   {
000004  4606              MOV      r6,r0
;;;3067     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000006  6ab4              LDR      r4,[r6,#0x28]
;;;3068     uint32_t tickstart;
;;;3069   #if (USE_SPI_CRC != 0U)
;;;3070     __IO uint32_t tmpreg = 0U;
000008  2700              MOVS     r7,#0
00000a  9701              STR      r7,[sp,#4]
;;;3071   #endif /* USE_SPI_CRC */
;;;3072   
;;;3073     /* Init tickstart for timeout management*/
;;;3074     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;3075   
;;;3076     /* DMA Normal Mode */
;;;3077     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
000012  6830              LDR      r0,[r6,#0]
000014  6800              LDR      r0,[r0,#0]
000016  0680              LSLS     r0,r0,#26
000018  d461              BMI      |L46.222|
;;;3078     {
;;;3079       /* Disable ERR interrupt */
;;;3080       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6841              LDR      r1,[r0,#4]
00001e  f0210120          BIC      r1,r1,#0x20
000022  6041              STR      r1,[r0,#4]
;;;3081   
;;;3082   #if (USE_SPI_CRC != 0U)
;;;3083       /* CRC handling */
;;;3084       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000024  6aa0              LDR      r0,[r4,#0x28]
000026  f5b05f00          CMP      r0,#0x2000
00002a  d128              BNE      |L46.126|
;;;3085       {
;;;3086         /* Wait until RXNE flag */
;;;3087         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00002c  2201              MOVS     r2,#1
00002e  2364              MOVS     r3,#0x64
000030  4611              MOV      r1,r2
000032  4620              MOV      r0,r4
000034  9500              STR      r5,[sp,#0]
000036  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00003a  b118              CBZ      r0,|L46.68|
;;;3088         {
;;;3089           /* Error on the CRC reception */
;;;3090           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00003c  6e20              LDR      r0,[r4,#0x60]
00003e  f0400002          ORR      r0,r0,#2
000042  6620              STR      r0,[r4,#0x60]
                  |L46.68|
;;;3091         }
;;;3092         /* Read CRC */
;;;3093         if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
000044  68e0              LDR      r0,[r4,#0xc]
000046  f5b06fe0          CMP      r0,#0x700
00004a  d903              BLS      |L46.84|
;;;3094         {
;;;3095           /* Read 16bit CRC */
;;;3096           tmpreg = READ_REG(hspi->Instance->DR);
00004c  6820              LDR      r0,[r4,#0]
00004e  68c0              LDR      r0,[r0,#0xc]
000050  9001              STR      r0,[sp,#4]
;;;3097           /* To avoid GCC warning */
;;;3098           UNUSED(tmpreg);
000052  e014              B        |L46.126|
                  |L46.84|
;;;3099         }
;;;3100         else
;;;3101         {
;;;3102           /* Read 8bit CRC */
;;;3103           tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
000054  6820              LDR      r0,[r4,#0]
000056  7b00              LDRB     r0,[r0,#0xc]
000058  9001              STR      r0,[sp,#4]
;;;3104           /* To avoid GCC warning */
;;;3105           UNUSED(tmpreg);
;;;3106   
;;;3107           if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
00005a  6b20              LDR      r0,[r4,#0x30]
00005c  2802              CMP      r0,#2
00005e  d10e              BNE      |L46.126|
;;;3108           {
;;;3109             if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000060  2201              MOVS     r2,#1
000062  2364              MOVS     r3,#0x64
000064  4611              MOV      r1,r2
000066  4620              MOV      r0,r4
000068  9500              STR      r5,[sp,#0]
00006a  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00006e  b118              CBZ      r0,|L46.120|
;;;3110             {
;;;3111               /* Error on the CRC reception */
;;;3112               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
000070  6e20              LDR      r0,[r4,#0x60]
000072  f0400002          ORR      r0,r0,#2
000076  6620              STR      r0,[r4,#0x60]
                  |L46.120|
;;;3113             }
;;;3114             /* Read 8bit CRC again in case of 16bit CRC in 8bit Data mode */
;;;3115             tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
000078  6820              LDR      r0,[r4,#0]
00007a  7b00              LDRB     r0,[r0,#0xc]
00007c  9001              STR      r0,[sp,#4]
                  |L46.126|
;;;3116             /* To avoid GCC warning */
;;;3117             UNUSED(tmpreg);
;;;3118           }
;;;3119         }
;;;3120       }
;;;3121   #endif /* USE_SPI_CRC */
;;;3122   
;;;3123       /* Check if we are in Master RX 2 line mode */
;;;3124       if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00007e  68a0              LDR      r0,[r4,#8]
000080  b918              CBNZ     r0,|L46.138|
000082  6860              LDR      r0,[r4,#4]
000084  f5b07f82          CMP      r0,#0x104
000088  d023              BEQ      |L46.210|
                  |L46.138|
;;;3125       {
;;;3126         /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
;;;3127         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;3128       }
;;;3129       else
;;;3130       {
;;;3131         /* Normal case */
;;;3132         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
00008a  6820              LDR      r0,[r4,#0]
00008c  6841              LDR      r1,[r0,#4]
00008e  f0210101          BIC      r1,r1,#1
000092  6041              STR      r1,[r0,#4]
                  |L46.148|
;;;3133       }
;;;3134   
;;;3135       /* Check the end of the transaction */
;;;3136       if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000094  462a              MOV      r2,r5
000096  2164              MOVS     r1,#0x64
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       SPI_EndRxTransaction
00009e  b108              CBZ      r0,|L46.164|
;;;3137       {
;;;3138         hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
0000a0  2020              MOVS     r0,#0x20
0000a2  6620              STR      r0,[r4,#0x60]
                  |L46.164|
;;;3139       }
;;;3140   
;;;3141       hspi->RxXferCount = 0U;
0000a4  f8a47046          STRH     r7,[r4,#0x46]
;;;3142       hspi->State = HAL_SPI_STATE_READY;
0000a8  2001              MOVS     r0,#1
0000aa  f884005d          STRB     r0,[r4,#0x5d]
;;;3143   
;;;3144   #if (USE_SPI_CRC != 0U)
;;;3145       /* Check if CRC error occurred */
;;;3146       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
0000ae  6820              LDR      r0,[r4,#0]
0000b0  6881              LDR      r1,[r0,#8]
0000b2  06c9              LSLS     r1,r1,#27
0000b4  d506              BPL      |L46.196|
;;;3147       {
;;;3148         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
0000b6  6e21              LDR      r1,[r4,#0x60]
0000b8  f0410102          ORR      r1,r1,#2
0000bc  6621              STR      r1,[r4,#0x60]
;;;3149         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
0000be  f64f71ef          MOV      r1,#0xffef
0000c2  6081              STR      r1,[r0,#8]
                  |L46.196|
;;;3150       }
;;;3151   #endif /* USE_SPI_CRC */
;;;3152   
;;;3153       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
0000c4  6e20              LDR      r0,[r4,#0x60]
0000c6  b150              CBZ      r0,|L46.222|
;;;3154       {
;;;3155         /* Call user error callback */
;;;3156   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3157         hspi->ErrorCallback(hspi);
;;;3158   #else
;;;3159         HAL_SPI_ErrorCallback(hspi);
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L46.206|
;;;3160   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3161         return;
;;;3162       }
;;;3163     }
;;;3164     /* Call user Rx complete callback */
;;;3165   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3166     hspi->RxCpltCallback(hspi);
;;;3167   #else
;;;3168     HAL_SPI_RxCpltCallback(hspi);
;;;3169   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3170   }
0000ce  e8bd81fc          POP      {r2-r8,pc}
                  |L46.210|
0000d2  6820              LDR      r0,[r4,#0]            ;3127
0000d4  6841              LDR      r1,[r0,#4]            ;3127
0000d6  f0210103          BIC      r1,r1,#3              ;3127
0000da  6041              STR      r1,[r0,#4]            ;3127
0000dc  e7da              B        |L46.148|
                  |L46.222|
0000de  4620              MOV      r0,r4                 ;3168
0000e0  f7fffffe          BL       HAL_SPI_RxCpltCallback
0000e4  e7f3              B        |L46.206|
;;;3171   
                          ENDP


                          AREA ||i.SPI_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  SPI_DMARxAbortCallback PROC
;;;3438     */
;;;3439   static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3440   {
;;;3441     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a84              LDR      r4,[r0,#0x28]
;;;3442   
;;;3443     /* Disable SPI Peripheral */
;;;3444     __HAL_SPI_DISABLE(hspi);
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f0210140          BIC      r1,r1,#0x40
00000c  6001              STR      r1,[r0,#0]
;;;3445   
;;;3446     hspi->hdmarx->XferAbortCallback = NULL;
00000e  6da0              LDR      r0,[r4,#0x58]
000010  2500              MOVS     r5,#0
000012  6385              STR      r5,[r0,#0x38]
;;;3447   
;;;3448     /* Disable Rx DMA Request */
;;;3449     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000014  6820              LDR      r0,[r4,#0]
000016  6841              LDR      r1,[r0,#4]
000018  f0210101          BIC      r1,r1,#1
00001c  6041              STR      r1,[r0,#4]
;;;3450   
;;;3451     /* Control the BSY flag */
;;;3452     if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
00001e  f7fffffe          BL       HAL_GetTick
000022  9000              STR      r0,[sp,#0]
000024  2364              MOVS     r3,#0x64
000026  2200              MOVS     r2,#0
000028  2180              MOVS     r1,#0x80
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
;;;3453     {
;;;3454       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000030  2640              MOVS     r6,#0x40
000032  b100              CBZ      r0,|L47.54|
000034  6626              STR      r6,[r4,#0x60]
                  |L47.54|
;;;3455     }
;;;3456   
;;;3457     /* Empty the FRLVL fifo */
;;;3458     if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000036  f7fffffe          BL       HAL_GetTick
00003a  9000              STR      r0,[sp,#0]
00003c  2364              MOVS     r3,#0x64
00003e  2200              MOVS     r2,#0
000040  f44f61c0          MOV      r1,#0x600
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
00004a  b100              CBZ      r0,|L47.78|
;;;3459     {
;;;3460       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
00004c  6626              STR      r6,[r4,#0x60]
                  |L47.78|
;;;3461     }
;;;3462   
;;;3463     /* Check if an Abort process is still ongoing */
;;;3464     if (hspi->hdmatx != NULL)
00004e  6d60              LDR      r0,[r4,#0x54]
000050  b110              CBZ      r0,|L47.88|
;;;3465     {
;;;3466       if (hspi->hdmatx->XferAbortCallback != NULL)
000052  6b80              LDR      r0,[r0,#0x38]
000054  2800              CMP      r0,#0
000056  d112              BNE      |L47.126|
                  |L47.88|
;;;3467       {
;;;3468         return;
;;;3469       }
;;;3470     }
;;;3471   
;;;3472     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3473     hspi->RxXferCount = 0U;
000058  f8a45046          STRH     r5,[r4,#0x46]
;;;3474     hspi->TxXferCount = 0U;
00005c  87e5              STRH     r5,[r4,#0x3e]
;;;3475   
;;;3476     /* Check no error during Abort procedure */
;;;3477     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
00005e  6e20              LDR      r0,[r4,#0x60]
000060  2840              CMP      r0,#0x40
000062  d000              BEQ      |L47.102|
;;;3478     {
;;;3479       /* Reset errorCode */
;;;3480       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000064  6625              STR      r5,[r4,#0x60]
                  |L47.102|
;;;3481     }
;;;3482   
;;;3483     /* Clear the Error flags in the SR register */
;;;3484     __HAL_SPI_CLEAR_OVRFLAG(hspi);
000066  6820              LDR      r0,[r4,#0]
000068  68c1              LDR      r1,[r0,#0xc]
00006a  6881              LDR      r1,[r0,#8]
00006c  9100              STR      r1,[sp,#0]
;;;3485     __HAL_SPI_CLEAR_FREFLAG(hspi);
00006e  6880              LDR      r0,[r0,#8]
000070  9000              STR      r0,[sp,#0]
;;;3486   
;;;3487     /* Restore hspi->State to Ready */
;;;3488     hspi->State  = HAL_SPI_STATE_READY;
000072  2001              MOVS     r0,#1
000074  f884005d          STRB     r0,[r4,#0x5d]
;;;3489   
;;;3490     /* Call user Abort complete callback */
;;;3491   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3492     hspi->AbortCpltCallback(hspi);
;;;3493   #else
;;;3494     HAL_SPI_AbortCpltCallback(hspi);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L47.126|
;;;3495   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3496   }
00007e  bdf8              POP      {r3-r7,pc}
;;;3497   
                          ENDP


                          AREA ||i.SPI_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitCplt PROC
;;;3007     */
;;;3008   static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b538              PUSH     {r3-r5,lr}
;;;3009   {
000002  4605              MOV      r5,r0
;;;3010     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6aac              LDR      r4,[r5,#0x28]
;;;3011     uint32_t tickstart;
;;;3012   
;;;3013     /* Init tickstart for timeout management*/
;;;3014     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4602              MOV      r2,r0
;;;3015   
;;;3016     /* DMA Normal Mode */
;;;3017     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  0680              LSLS     r0,r0,#26
000012  d423              BMI      |L48.92|
;;;3018     {
;;;3019       /* Disable ERR interrupt */
;;;3020       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000014  6820              LDR      r0,[r4,#0]
000016  6841              LDR      r1,[r0,#4]
000018  f0210120          BIC      r1,r1,#0x20
00001c  6041              STR      r1,[r0,#4]
;;;3021   
;;;3022       /* Disable Tx DMA Request */
;;;3023       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
00001e  6820              LDR      r0,[r4,#0]
000020  6841              LDR      r1,[r0,#4]
000022  f0210102          BIC      r1,r1,#2
000026  6041              STR      r1,[r0,#4]
;;;3024   
;;;3025       /* Check the end of the transaction */
;;;3026       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000028  2164              MOVS     r1,#0x64
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_EndRxTxTransaction
000030  b118              CBZ      r0,|L48.58|
;;;3027       {
;;;3028         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000032  6e20              LDR      r0,[r4,#0x60]
000034  f0400020          ORR      r0,r0,#0x20
000038  6620              STR      r0,[r4,#0x60]
                  |L48.58|
;;;3029       }
;;;3030   
;;;3031       /* Clear overrun flag in 2 Lines communication mode because received data is not read */
;;;3032       if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
00003a  68a0              LDR      r0,[r4,#8]
00003c  2100              MOVS     r1,#0
00003e  b918              CBNZ     r0,|L48.72|
;;;3033       {
;;;3034         __HAL_SPI_CLEAR_OVRFLAG(hspi);
000040  6820              LDR      r0,[r4,#0]
000042  68c2              LDR      r2,[r0,#0xc]
000044  6880              LDR      r0,[r0,#8]
000046  9000              STR      r0,[sp,#0]
                  |L48.72|
;;;3035       }
;;;3036   
;;;3037       hspi->TxXferCount = 0U;
000048  87e1              STRH     r1,[r4,#0x3e]
;;;3038       hspi->State = HAL_SPI_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f884005d          STRB     r0,[r4,#0x5d]
;;;3039   
;;;3040       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000050  6e20              LDR      r0,[r4,#0x60]
000052  b118              CBZ      r0,|L48.92|
;;;3041       {
;;;3042         /* Call user error callback */
;;;3043   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3044         hspi->ErrorCallback(hspi);
;;;3045   #else
;;;3046         HAL_SPI_ErrorCallback(hspi);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3047   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3048         return;
;;;3049       }
;;;3050     }
;;;3051     /* Call user Tx complete callback */
;;;3052   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3053     hspi->TxCpltCallback(hspi);
;;;3054   #else
;;;3055     HAL_SPI_TxCpltCallback(hspi);
;;;3056   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3057   }
00005a  bd38              POP      {r3-r5,pc}
                  |L48.92|
00005c  4620              MOV      r0,r4                 ;3055
00005e  f7fffffe          BL       HAL_SPI_TxCpltCallback
000062  bd38              POP      {r3-r5,pc}
;;;3058   
                          ENDP


                          AREA ||i.SPI_DMATransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitReceiveCplt PROC
;;;3177     */
;;;3178   static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3179   {
000004  4606              MOV      r6,r0
;;;3180     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000006  6ab4              LDR      r4,[r6,#0x28]
;;;3181     uint32_t tickstart;
;;;3182   #if (USE_SPI_CRC != 0U)
;;;3183     __IO uint32_t tmpreg = 0U;
000008  2700              MOVS     r7,#0
00000a  9701              STR      r7,[sp,#4]
;;;3184   #endif /* USE_SPI_CRC */
;;;3185   
;;;3186     /* Init tickstart for timeout management*/
;;;3187     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;3188   
;;;3189     /* DMA Normal Mode */
;;;3190     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
000012  6830              LDR      r0,[r6,#0]
000014  6800              LDR      r0,[r0,#0]
000016  0680              LSLS     r0,r0,#26
000018  d457              BMI      |L49.202|
;;;3191     {
;;;3192       /* Disable ERR interrupt */
;;;3193       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6841              LDR      r1,[r0,#4]
00001e  f0210120          BIC      r1,r1,#0x20
000022  6041              STR      r1,[r0,#4]
;;;3194   
;;;3195   #if (USE_SPI_CRC != 0U)
;;;3196       /* CRC handling */
;;;3197       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000024  6aa0              LDR      r0,[r4,#0x28]
000026  f5b05f00          CMP      r0,#0x2000
00002a  d117              BNE      |L49.92|
;;;3198       {
;;;3199         if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
00002c  68e0              LDR      r0,[r4,#0xc]
;;;3200         {
;;;3201           if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT,
00002e  f44f61c0          MOV      r1,#0x600
000032  f5b06fe0          CMP      r0,#0x700             ;3199
000036  d102              BNE      |L49.62|
000038  6b20              LDR      r0,[r4,#0x30]         ;3199
00003a  2801              CMP      r0,#1                 ;3199
00003c  d035              BEQ      |L49.170|
                  |L49.62|
;;;3202                                             tickstart) != HAL_OK)
;;;3203           {
;;;3204             /* Error on the CRC reception */
;;;3205             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3206           }
;;;3207           /* Read CRC to Flush DR and RXNE flag */
;;;3208           tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
;;;3209           /* To avoid GCC warning */
;;;3210           UNUSED(tmpreg);
;;;3211         }
;;;3212         else
;;;3213         {
;;;3214           if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00003e  2364              MOVS     r3,#0x64
000040  f44f6280          MOV      r2,#0x400
000044  4620              MOV      r0,r4
000046  9500              STR      r5,[sp,#0]
000048  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
00004c  b118              CBZ      r0,|L49.86|
;;;3215           {
;;;3216             /* Error on the CRC reception */
;;;3217             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00004e  6e20              LDR      r0,[r4,#0x60]
000050  f0400002          ORR      r0,r0,#2
000054  6620              STR      r0,[r4,#0x60]
                  |L49.86|
;;;3218           }
;;;3219           /* Read CRC to Flush DR and RXNE flag */
;;;3220           tmpreg = READ_REG(hspi->Instance->DR);
000056  6820              LDR      r0,[r4,#0]
000058  68c0              LDR      r0,[r0,#0xc]
00005a  9001              STR      r0,[sp,#4]
                  |L49.92|
;;;3221           /* To avoid GCC warning */
;;;3222           UNUSED(tmpreg);
;;;3223         }
;;;3224       }
;;;3225   #endif /* USE_SPI_CRC */
;;;3226   
;;;3227       /* Check the end of the transaction */
;;;3228       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00005c  462a              MOV      r2,r5
00005e  2164              MOVS     r1,#0x64
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       SPI_EndRxTxTransaction
000066  b118              CBZ      r0,|L49.112|
;;;3229       {
;;;3230         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000068  6e20              LDR      r0,[r4,#0x60]
00006a  f0400020          ORR      r0,r0,#0x20
00006e  6620              STR      r0,[r4,#0x60]
                  |L49.112|
;;;3231       }
;;;3232   
;;;3233       /* Disable Rx/Tx DMA Request */
;;;3234       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000070  6820              LDR      r0,[r4,#0]
000072  6841              LDR      r1,[r0,#4]
000074  f0210103          BIC      r1,r1,#3
000078  6041              STR      r1,[r0,#4]
;;;3235   
;;;3236       hspi->TxXferCount = 0U;
00007a  87e7              STRH     r7,[r4,#0x3e]
;;;3237       hspi->RxXferCount = 0U;
00007c  f8a47046          STRH     r7,[r4,#0x46]
;;;3238       hspi->State = HAL_SPI_STATE_READY;
000080  2001              MOVS     r0,#1
000082  f884005d          STRB     r0,[r4,#0x5d]
;;;3239   
;;;3240   #if (USE_SPI_CRC != 0U)
;;;3241       /* Check if CRC error occurred */
;;;3242       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
000086  6820              LDR      r0,[r4,#0]
000088  6881              LDR      r1,[r0,#8]
00008a  06c9              LSLS     r1,r1,#27
00008c  d506              BPL      |L49.156|
;;;3243       {
;;;3244         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00008e  6e21              LDR      r1,[r4,#0x60]
000090  f0410102          ORR      r1,r1,#2
000094  6621              STR      r1,[r4,#0x60]
;;;3245         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
000096  f64f71ef          MOV      r1,#0xffef
00009a  6081              STR      r1,[r0,#8]
                  |L49.156|
;;;3246       }
;;;3247   #endif /* USE_SPI_CRC */
;;;3248   
;;;3249       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
00009c  6e20              LDR      r0,[r4,#0x60]
00009e  b1a0              CBZ      r0,|L49.202|
;;;3250       {
;;;3251         /* Call user error callback */
;;;3252   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3253         hspi->ErrorCallback(hspi);
;;;3254   #else
;;;3255         HAL_SPI_ErrorCallback(hspi);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L49.166|
;;;3256   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3257         return;
;;;3258       }
;;;3259     }
;;;3260     /* Call user TxRx complete callback */
;;;3261   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3262     hspi->TxRxCpltCallback(hspi);
;;;3263   #else
;;;3264     HAL_SPI_TxRxCpltCallback(hspi);
;;;3265   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3266   }
0000a6  e8bd81fc          POP      {r2-r8,pc}
                  |L49.170|
0000aa  2364              MOVS     r3,#0x64              ;3201
0000ac  f44f7200          MOV      r2,#0x200             ;3201
0000b0  4620              MOV      r0,r4                 ;3201
0000b2  9500              STR      r5,[sp,#0]            ;3201
0000b4  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
0000b8  b118              CBZ      r0,|L49.194|
0000ba  6e20              LDR      r0,[r4,#0x60]         ;3205
0000bc  f0400002          ORR      r0,r0,#2              ;3205
0000c0  6620              STR      r0,[r4,#0x60]         ;3205
                  |L49.194|
0000c2  6820              LDR      r0,[r4,#0]            ;3208
0000c4  7b00              LDRB     r0,[r0,#0xc]          ;3208
0000c6  9001              STR      r0,[sp,#4]            ;3208
0000c8  e7c8              B        |L49.92|
                  |L49.202|
0000ca  4620              MOV      r0,r4                 ;3264
0000cc  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
0000d0  e7e9              B        |L49.166|
;;;3267   
                          ENDP


                          AREA ||i.SPI_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  SPI_DMATxAbortCallback PROC
;;;3372     */
;;;3373   static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3374   {
;;;3375     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a84              LDR      r4,[r0,#0x28]
;;;3376   
;;;3377     hspi->hdmatx->XferAbortCallback = NULL;
000004  2500              MOVS     r5,#0
000006  6d60              LDR      r0,[r4,#0x54]
000008  6385              STR      r5,[r0,#0x38]
;;;3378   
;;;3379     /* Disable Tx DMA Request */
;;;3380     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
00000a  6820              LDR      r0,[r4,#0]
00000c  6841              LDR      r1,[r0,#4]
00000e  f0210102          BIC      r1,r1,#2
000012  6041              STR      r1,[r0,#4]
;;;3381   
;;;3382     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000014  f7fffffe          BL       HAL_GetTick
000018  4602              MOV      r2,r0
00001a  2164              MOVS     r1,#0x64
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_EndRxTxTransaction
;;;3383     {
;;;3384       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000022  2640              MOVS     r6,#0x40
000024  b100              CBZ      r0,|L50.40|
000026  6626              STR      r6,[r4,#0x60]
                  |L50.40|
;;;3385     }
;;;3386   
;;;3387     /* Disable SPI Peripheral */
;;;3388     __HAL_SPI_DISABLE(hspi);
000028  6820              LDR      r0,[r4,#0]
00002a  6801              LDR      r1,[r0,#0]
00002c  f0210140          BIC      r1,r1,#0x40
000030  6001              STR      r1,[r0,#0]
;;;3389   
;;;3390     /* Empty the FRLVL fifo */
;;;3391     if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000032  f7fffffe          BL       HAL_GetTick
000036  9000              STR      r0,[sp,#0]
000038  2364              MOVS     r3,#0x64
00003a  2200              MOVS     r2,#0
00003c  f44f61c0          MOV      r1,#0x600
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
000046  b100              CBZ      r0,|L50.74|
;;;3392     {
;;;3393       hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000048  6626              STR      r6,[r4,#0x60]
                  |L50.74|
;;;3394     }
;;;3395   
;;;3396     /* Check if an Abort process is still ongoing */
;;;3397     if (hspi->hdmarx != NULL)
00004a  6da0              LDR      r0,[r4,#0x58]
00004c  b110              CBZ      r0,|L50.84|
;;;3398     {
;;;3399       if (hspi->hdmarx->XferAbortCallback != NULL)
00004e  6b80              LDR      r0,[r0,#0x38]
000050  2800              CMP      r0,#0
000052  d112              BNE      |L50.122|
                  |L50.84|
;;;3400       {
;;;3401         return;
;;;3402       }
;;;3403     }
;;;3404   
;;;3405     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3406     hspi->RxXferCount = 0U;
000054  f8a45046          STRH     r5,[r4,#0x46]
;;;3407     hspi->TxXferCount = 0U;
000058  87e5              STRH     r5,[r4,#0x3e]
;;;3408   
;;;3409     /* Check no error during Abort procedure */
;;;3410     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
00005a  6e20              LDR      r0,[r4,#0x60]
00005c  2840              CMP      r0,#0x40
00005e  d000              BEQ      |L50.98|
;;;3411     {
;;;3412       /* Reset errorCode */
;;;3413       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000060  6625              STR      r5,[r4,#0x60]
                  |L50.98|
;;;3414     }
;;;3415   
;;;3416     /* Clear the Error flags in the SR register */
;;;3417     __HAL_SPI_CLEAR_OVRFLAG(hspi);
000062  6820              LDR      r0,[r4,#0]
000064  68c1              LDR      r1,[r0,#0xc]
000066  6881              LDR      r1,[r0,#8]
000068  9100              STR      r1,[sp,#0]
;;;3418     __HAL_SPI_CLEAR_FREFLAG(hspi);
00006a  6880              LDR      r0,[r0,#8]
00006c  9000              STR      r0,[sp,#0]
;;;3419   
;;;3420     /* Restore hspi->State to Ready */
;;;3421     hspi->State  = HAL_SPI_STATE_READY;
00006e  2001              MOVS     r0,#1
000070  f884005d          STRB     r0,[r4,#0x5d]
;;;3422   
;;;3423     /* Call user Abort complete callback */
;;;3424   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3425     hspi->AbortCpltCallback(hspi);
;;;3426   #else
;;;3427     HAL_SPI_AbortCpltCallback(hspi);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L50.122|
;;;3428   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3429   }
00007a  bdf8              POP      {r3-r7,pc}
;;;3430   
                          ENDP


                          AREA ||i.SPI_EndRxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTransaction PROC
;;;4039     */
;;;4040   static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4041   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;4042     if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
00000a  f44f4600          MOV      r6,#0x8000
00000e  6860              LDR      r0,[r4,#4]
000010  f44f7982          MOV      r9,#0x104
;;;4043                                                  || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
000014  1177              ASRS     r7,r6,#5
000016  4548              CMP      r0,r9                 ;4042
000018  d109              BNE      |L51.46|
00001a  68a0              LDR      r0,[r4,#8]            ;4042
00001c  42b0              CMP      r0,r6                 ;4042
00001e  d001              BEQ      |L51.36|
000020  42b8              CMP      r0,r7
000022  d104              BNE      |L51.46|
                  |L51.36|
;;;4044     {
;;;4045       /* Disable SPI peripheral */
;;;4046       __HAL_SPI_DISABLE(hspi);
000024  6820              LDR      r0,[r4,#0]
000026  6801              LDR      r1,[r0,#0]
000028  f0210140          BIC      r1,r1,#0x40
00002c  6001              STR      r1,[r0,#0]
                  |L51.46|
;;;4047     }
;;;4048   
;;;4049     /* Control the BSY flag */
;;;4050     if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
00002e  4643              MOV      r3,r8
000030  2200              MOVS     r2,#0
000032  2180              MOVS     r1,#0x80
000034  4620              MOV      r0,r4
000036  9500              STR      r5,[sp,#0]
000038  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00003c  b130              CBZ      r0,|L51.76|
;;;4051     {
;;;4052       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00003e  6e20              LDR      r0,[r4,#0x60]
000040  f0400020          ORR      r0,r0,#0x20
000044  6620              STR      r0,[r4,#0x60]
;;;4053       return HAL_TIMEOUT;
000046  2003              MOVS     r0,#3
                  |L51.72|
;;;4054     }
;;;4055   
;;;4056     if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;4057                                                  || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
;;;4058     {
;;;4059       /* Empty the FRLVL fifo */
;;;4060       if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
;;;4061       {
;;;4062         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;4063         return HAL_TIMEOUT;
;;;4064       }
;;;4065     }
;;;4066     return HAL_OK;
;;;4067   }
000048  e8bd83f8          POP      {r3-r9,pc}
                  |L51.76|
00004c  6860              LDR      r0,[r4,#4]            ;4056
00004e  4548              CMP      r0,r9                 ;4056
000050  d113              BNE      |L51.122|
000052  68a0              LDR      r0,[r4,#8]            ;4056
000054  42b0              CMP      r0,r6                 ;4056
000056  d001              BEQ      |L51.92|
000058  42b8              CMP      r0,r7                 ;4057
00005a  d10e              BNE      |L51.122|
                  |L51.92|
00005c  4643              MOV      r3,r8                 ;4060
00005e  2200              MOVS     r2,#0                 ;4060
000060  f44f61c0          MOV      r1,#0x600             ;4060
000064  4620              MOV      r0,r4                 ;4060
000066  9500              STR      r5,[sp,#0]            ;4060
000068  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
00006c  b128              CBZ      r0,|L51.122|
00006e  6e20              LDR      r0,[r4,#0x60]         ;4062
000070  f0400020          ORR      r0,r0,#0x20           ;4062
000074  6620              STR      r0,[r4,#0x60]         ;4062
000076  2003              MOVS     r0,#3                 ;4063
000078  e7e6              B        |L51.72|
                  |L51.122|
00007a  2000              MOVS     r0,#0                 ;4066
00007c  e7e4              B        |L51.72|
;;;4068   
                          ENDP


                          AREA ||i.SPI_EndRxTxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTxTransaction PROC
;;;4075     */
;;;4076   static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;4077   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;4078     /* Control if the TX fifo is empty */
;;;4079     if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
000008  4633              MOV      r3,r6
00000a  2200              MOVS     r2,#0
00000c  f44f51c0          MOV      r1,#0x1800
000010  4620              MOV      r0,r4
000012  9500              STR      r5,[sp,#0]
000014  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
000018  b128              CBZ      r0,|L52.38|
;;;4080     {
;;;4081       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00001a  6e20              LDR      r0,[r4,#0x60]
00001c  f0400020          ORR      r0,r0,#0x20
000020  6620              STR      r0,[r4,#0x60]
;;;4082       return HAL_TIMEOUT;
000022  2003              MOVS     r0,#3
;;;4083     }
;;;4084   
;;;4085     /* Control the BSY flag */
;;;4086     if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
;;;4087     {
;;;4088       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;4089       return HAL_TIMEOUT;
;;;4090     }
;;;4091   
;;;4092     /* Control if the RX fifo is empty */
;;;4093     if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
;;;4094     {
;;;4095       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;4096       return HAL_TIMEOUT;
;;;4097     }
;;;4098   
;;;4099     return HAL_OK;
;;;4100   }
000024  bdf8              POP      {r3-r7,pc}
                  |L52.38|
000026  4633              MOV      r3,r6                 ;4086
000028  2200              MOVS     r2,#0                 ;4086
00002a  2180              MOVS     r1,#0x80              ;4086
00002c  4620              MOV      r0,r4                 ;4086
00002e  9500              STR      r5,[sp,#0]            ;4086
000030  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000034  b128              CBZ      r0,|L52.66|
000036  6e20              LDR      r0,[r4,#0x60]         ;4088
000038  f0400020          ORR      r0,r0,#0x20           ;4088
00003c  6620              STR      r0,[r4,#0x60]         ;4088
00003e  2003              MOVS     r0,#3                 ;4089
000040  bdf8              POP      {r3-r7,pc}
                  |L52.66|
000042  4633              MOV      r3,r6                 ;4093
000044  2200              MOVS     r2,#0                 ;4093
000046  f44f61c0          MOV      r1,#0x600             ;4093
00004a  4620              MOV      r0,r4                 ;4093
00004c  9500              STR      r5,[sp,#0]            ;4093
00004e  f7fffffe          BL       SPI_WaitFifoStateUntilTimeout
000052  b128              CBZ      r0,|L52.96|
000054  6e20              LDR      r0,[r4,#0x60]         ;4095
000056  f0400020          ORR      r0,r0,#0x20           ;4095
00005a  6620              STR      r0,[r4,#0x60]         ;4095
00005c  2003              MOVS     r0,#3                 ;4096
00005e  bdf8              POP      {r3-r7,pc}
                  |L52.96|
000060  2000              MOVS     r0,#0                 ;4099
000062  bdf8              POP      {r3-r7,pc}
;;;4101   
                          ENDP


                          AREA ||i.SPI_RxISR_16BIT||, CODE, READONLY, ALIGN=2

                  SPI_RxISR_16BIT PROC
;;;3806     */
;;;3807   static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3808   {
;;;3809     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000002  68c9              LDR      r1,[r1,#0xc]
000004  6c02              LDR      r2,[r0,#0x40]
000006  8011              STRH     r1,[r2,#0]
;;;3810     hspi->pRxBuffPtr += sizeof(uint16_t);
000008  6c01              LDR      r1,[r0,#0x40]
00000a  1c89              ADDS     r1,r1,#2
00000c  6401              STR      r1,[r0,#0x40]
;;;3811     hspi->RxXferCount--;
00000e  f8b01046          LDRH     r1,[r0,#0x46]
000012  1e49              SUBS     r1,r1,#1
000014  f8a01046          STRH     r1,[r0,#0x46]
;;;3812   
;;;3813   #if (USE_SPI_CRC != 0U)
;;;3814     /* Enable CRC Transmission */
;;;3815     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
000018  f8b01046          LDRH     r1,[r0,#0x46]
00001c  f44f5300          MOV      r3,#0x2000
000020  2901              CMP      r1,#1
000022  d107              BNE      |L53.52|
000024  6a81              LDR      r1,[r0,#0x28]
000026  4299              CMP      r1,r3
000028  d104              BNE      |L53.52|
;;;3816     {
;;;3817       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
00002a  6801              LDR      r1,[r0,#0]
00002c  680a              LDR      r2,[r1,#0]
00002e  f4425280          ORR      r2,r2,#0x1000
000032  600a              STR      r2,[r1,#0]
                  |L53.52|
;;;3818     }
;;;3819   #endif /* USE_SPI_CRC */
;;;3820   
;;;3821     if (hspi->RxXferCount == 0U)
000034  f8b01046          LDRH     r1,[r0,#0x46]
000038  2900              CMP      r1,#0
00003a  d104              BNE      |L53.70|
;;;3822     {
;;;3823   #if (USE_SPI_CRC != 0U)
;;;3824       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00003c  6a81              LDR      r1,[r0,#0x28]
00003e  4299              CMP      r1,r3
000040  d102              BNE      |L53.72|
;;;3825       {
;;;3826         hspi->RxISR = SPI_RxISR_16BITCRC;
000042  4902              LDR      r1,|L53.76|
000044  64c1              STR      r1,[r0,#0x4c]
                  |L53.70|
;;;3827         return;
;;;3828       }
;;;3829   #endif /* USE_SPI_CRC */
;;;3830       SPI_CloseRx_ISR(hspi);
;;;3831     }
;;;3832   }
000046  4770              BX       lr
                  |L53.72|
000048  f7ffbffe          B.W      SPI_CloseRx_ISR
;;;3833   
                          ENDP

                  |L53.76|
                          DCD      SPI_RxISR_16BITCRC

                          AREA ||i.SPI_RxISR_16BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_16BITCRC PROC
;;;3784     */
;;;3785   static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3786   {
;;;3787     __IO uint32_t tmpreg = 0U;
;;;3788   
;;;3789     /* Read 16bit CRC to flush Data Register */
;;;3790     tmpreg = READ_REG(hspi->Instance->DR);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  9201              STR      r2,[sp,#4]
;;;3791     /* To avoid GCC warning */
;;;3792     UNUSED(tmpreg);
;;;3793   
;;;3794     /* Disable RXNE and ERR interrupt */
;;;3795     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000008  684a              LDR      r2,[r1,#4]
00000a  f0220260          BIC      r2,r2,#0x60
00000e  604a              STR      r2,[r1,#4]
;;;3796   
;;;3797     SPI_CloseRx_ISR(hspi);
000010  b002              ADD      sp,sp,#8
000012  f7ffbffe          B.W      SPI_CloseRx_ISR
;;;3798   }
;;;3799   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_RxISR_8BIT||, CODE, READONLY, ALIGN=2

                  SPI_RxISR_8BIT PROC
;;;3750     */
;;;3751   static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3752   {
;;;3753     *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
000002  7b09              LDRB     r1,[r1,#0xc]
000004  6c02              LDR      r2,[r0,#0x40]
000006  7011              STRB     r1,[r2,#0]
;;;3754     hspi->pRxBuffPtr++;
000008  6c01              LDR      r1,[r0,#0x40]
00000a  1c49              ADDS     r1,r1,#1
00000c  6401              STR      r1,[r0,#0x40]
;;;3755     hspi->RxXferCount--;
00000e  f8b01046          LDRH     r1,[r0,#0x46]
000012  1e49              SUBS     r1,r1,#1
000014  f8a01046          STRH     r1,[r0,#0x46]
;;;3756   
;;;3757   #if (USE_SPI_CRC != 0U)
;;;3758     /* Enable CRC Transmission */
;;;3759     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
000018  f8b01046          LDRH     r1,[r0,#0x46]
00001c  f44f5300          MOV      r3,#0x2000
000020  2901              CMP      r1,#1
000022  d107              BNE      |L55.52|
000024  6a81              LDR      r1,[r0,#0x28]
000026  4299              CMP      r1,r3
000028  d104              BNE      |L55.52|
;;;3760     {
;;;3761       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
00002a  6801              LDR      r1,[r0,#0]
00002c  680a              LDR      r2,[r1,#0]
00002e  f4425280          ORR      r2,r2,#0x1000
000032  600a              STR      r2,[r1,#0]
                  |L55.52|
;;;3762     }
;;;3763   #endif /* USE_SPI_CRC */
;;;3764   
;;;3765     if (hspi->RxXferCount == 0U)
000034  f8b01046          LDRH     r1,[r0,#0x46]
000038  2900              CMP      r1,#0
00003a  d104              BNE      |L55.70|
;;;3766     {
;;;3767   #if (USE_SPI_CRC != 0U)
;;;3768       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00003c  6a81              LDR      r1,[r0,#0x28]
00003e  4299              CMP      r1,r3
000040  d102              BNE      |L55.72|
;;;3769       {
;;;3770         hspi->RxISR =  SPI_RxISR_8BITCRC;
000042  4902              LDR      r1,|L55.76|
000044  64c1              STR      r1,[r0,#0x4c]
                  |L55.70|
;;;3771         return;
;;;3772       }
;;;3773   #endif /* USE_SPI_CRC */
;;;3774       SPI_CloseRx_ISR(hspi);
;;;3775     }
;;;3776   }
000046  4770              BX       lr
                  |L55.72|
000048  f7ffbffe          B.W      SPI_CloseRx_ISR
;;;3777   
                          ENDP

                  |L55.76|
                          DCD      SPI_RxISR_8BITCRC

                          AREA ||i.SPI_RxISR_8BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_8BITCRC PROC
;;;3726     */
;;;3727   static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3728   {
;;;3729     __IO uint32_t tmpreg = 0U;
;;;3730   
;;;3731     /* Read 8bit CRC to flush Data Register */
;;;3732     tmpreg = READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
000002  6801              LDR      r1,[r0,#0]
000004  7b09              LDRB     r1,[r1,#0xc]
000006  9101              STR      r1,[sp,#4]
;;;3733     /* To avoid GCC warning */
;;;3734     UNUSED(tmpreg);
;;;3735   
;;;3736     hspi->CRCSize--;
000008  6c81              LDR      r1,[r0,#0x48]
00000a  1e49              SUBS     r1,r1,#1
00000c  6481              STR      r1,[r0,#0x48]
;;;3737   
;;;3738     if (hspi->CRCSize == 0U)
00000e  2900              CMP      r1,#0
000010  d102              BNE      |L56.24|
;;;3739     {
;;;3740       SPI_CloseRx_ISR(hspi);
000012  b002              ADD      sp,sp,#8
000014  f7ffbffe          B.W      SPI_CloseRx_ISR
                  |L56.24|
;;;3741     }
;;;3742   }
000018  b002              ADD      sp,sp,#8
00001a  4770              BX       lr
;;;3743   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_16BIT PROC
;;;3864     */
;;;3865   static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b81              LDR      r1,[r0,#0x38]
;;;3866   {
;;;3867     /* Transmit data in 16 Bit mode */
;;;3868     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  8809              LDRH     r1,[r1,#0]
000006  60d1              STR      r1,[r2,#0xc]
;;;3869     hspi->pTxBuffPtr += sizeof(uint16_t);
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c89              ADDS     r1,r1,#2
00000c  6381              STR      r1,[r0,#0x38]
;;;3870     hspi->TxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;3871   
;;;3872     if (hspi->TxXferCount == 0U)
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  2900              CMP      r1,#0
000018  d10a              BNE      |L57.48|
;;;3873     {
;;;3874   #if (USE_SPI_CRC != 0U)
;;;3875       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d104              BNE      |L57.44|
;;;3876       {
;;;3877         /* Enable CRC Transmission */
;;;3878         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000022  6801              LDR      r1,[r0,#0]
000024  680a              LDR      r2,[r1,#0]
000026  f4425280          ORR      r2,r2,#0x1000
00002a  600a              STR      r2,[r1,#0]
                  |L57.44|
;;;3879       }
;;;3880   #endif /* USE_SPI_CRC */
;;;3881       SPI_CloseTx_ISR(hspi);
00002c  f7ffbffe          B.W      SPI_CloseTx_ISR
                  |L57.48|
;;;3882     }
;;;3883   }
000030  4770              BX       lr
;;;3884   
                          ENDP


                          AREA ||i.SPI_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_8BIT PROC
;;;3839     */
;;;3840   static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b81              LDR      r1,[r0,#0x38]
;;;3841   {
;;;3842     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  7809              LDRB     r1,[r1,#0]
000006  7311              STRB     r1,[r2,#0xc]
;;;3843     hspi->pTxBuffPtr++;
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c49              ADDS     r1,r1,#1
00000c  6381              STR      r1,[r0,#0x38]
;;;3844     hspi->TxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;3845   
;;;3846     if (hspi->TxXferCount == 0U)
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  2900              CMP      r1,#0
000018  d10a              BNE      |L58.48|
;;;3847     {
;;;3848   #if (USE_SPI_CRC != 0U)
;;;3849       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d104              BNE      |L58.44|
;;;3850       {
;;;3851         /* Enable CRC Transmission */
;;;3852         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000022  6801              LDR      r1,[r0,#0]
000024  680a              LDR      r2,[r1,#0]
000026  f4425280          ORR      r2,r2,#0x1000
00002a  600a              STR      r2,[r1,#0]
                  |L58.44|
;;;3853       }
;;;3854   #endif /* USE_SPI_CRC */
;;;3855       SPI_CloseTx_ISR(hspi);
00002c  f7ffbffe          B.W      SPI_CloseTx_ISR
                  |L58.48|
;;;3856     }
;;;3857   }
000030  4770              BX       lr
;;;3858   
                          ENDP


                          AREA ||i.SPI_WaitFifoStateUntilTimeout||, CODE, READONLY, ALIGN=2

                  SPI_WaitFifoStateUntilTimeout PROC
;;;3963     */
;;;3964   static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3965                                                          uint32_t Timeout, uint32_t Tickstart)
;;;3966   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;3967     __IO uint32_t tmpreg;
;;;3968     __IO uint32_t count;
;;;3969     uint32_t tmp_timeout;
;;;3970     uint32_t tmp_tickstart;
;;;3971   
;;;3972     /* Adjust Timeout value  in case of end of transfer */
;;;3973     tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
00000e  f7fffffe          BL       HAL_GetTick
000012  1b40              SUBS     r0,r0,r5
000014  eba80500          SUB      r5,r8,r0
;;;3974     tmp_tickstart = HAL_GetTick();
000018  f7fffffe          BL       HAL_GetTick
00001c  4681              MOV      r9,r0
;;;3975   
;;;3976     /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
;;;3977     count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
00001e  482a              LDR      r0,|L59.200|
000020  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000022  ebc000c0          RSB      r0,r0,r0,LSL #3
000026  eb000080          ADD      r0,r0,r0,LSL #2
00002a  0d00              LSRS     r0,r0,#20
00002c  4368              MULS     r0,r5,r0
00002e  9000              STR      r0,[sp,#0]
;;;3978   
;;;3979     while ((hspi->Instance->SR & Fifo) != State)
;;;3980     {
;;;3981       if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
000030  f44f6ac0          MOV      r10,#0x600
000034  e040              B        |L59.184|
                  |L59.54|
000036  4556              CMP      r6,r10
000038  d102              BNE      |L59.64|
00003a  b90f              CBNZ     r7,|L59.64|
;;;3982       {
;;;3983         /* Flush Data Register by a blank read */
;;;3984         tmpreg = READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
00003c  7b00              LDRB     r0,[r0,#0xc]
00003e  9001              STR      r0,[sp,#4]
                  |L59.64|
;;;3985         /* To avoid GCC warning */
;;;3986         UNUSED(tmpreg);
;;;3987       }
;;;3988   
;;;3989       if (Timeout != HAL_MAX_DELAY)
000040  f1b83fff          CMP      r8,#0xffffffff
000044  d038              BEQ      |L59.184|
;;;3990       {
;;;3991         if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
000046  f7fffffe          BL       HAL_GetTick
00004a  eba00009          SUB      r0,r0,r9
00004e  42a8              CMP      r0,r5
000050  d203              BCS      |L59.90|
000052  b115              CBZ      r5,|L59.90|
;;;3992         {
;;;3993           /* Disable the SPI and reset the CRC: the CRC value should be cleared
;;;3994              on both master and slave sides in order to resynchronize the master
;;;3995              and slave for their respective CRC calculation */
;;;3996   
;;;3997           /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
;;;3998           __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;3999   
;;;4000           if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;4001                                                        || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
;;;4002           {
;;;4003             /* Disable SPI peripheral */
;;;4004             __HAL_SPI_DISABLE(hspi);
;;;4005           }
;;;4006   
;;;4007           /* Reset CRC Calculation */
;;;4008           if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;4009           {
;;;4010             SPI_RESET_CRC(hspi);
;;;4011           }
;;;4012   
;;;4013           hspi->State = HAL_SPI_STATE_READY;
;;;4014   
;;;4015           /* Process Unlocked */
;;;4016           __HAL_UNLOCK(hspi);
;;;4017   
;;;4018           return HAL_TIMEOUT;
;;;4019         }
;;;4020         /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
;;;4021         if(count == 0U)
000054  9800              LDR      r0,[sp,#0]
000056  b358              CBZ      r0,|L59.176|
000058  e02b              B        |L59.178|
                  |L59.90|
00005a  6820              LDR      r0,[r4,#0]            ;3998
00005c  6841              LDR      r1,[r0,#4]            ;3998
00005e  f02101e0          BIC      r1,r1,#0xe0           ;3998
000062  6041              STR      r1,[r0,#4]            ;3998
000064  6860              LDR      r0,[r4,#4]            ;4000
000066  f5b07f82          CMP      r0,#0x104             ;4000
00006a  d10b              BNE      |L59.132|
00006c  68a0              LDR      r0,[r4,#8]            ;4000
00006e  f5b04f00          CMP      r0,#0x8000            ;4000
000072  d002              BEQ      |L59.122|
000074  f5b06f80          CMP      r0,#0x400             ;4001
000078  d104              BNE      |L59.132|
                  |L59.122|
00007a  6820              LDR      r0,[r4,#0]            ;4004
00007c  6801              LDR      r1,[r0,#0]            ;4004
00007e  f0210140          BIC      r1,r1,#0x40           ;4004
000082  6001              STR      r1,[r0,#0]            ;4004
                  |L59.132|
000084  6aa0              LDR      r0,[r4,#0x28]         ;4008
000086  f5b05f00          CMP      r0,#0x2000            ;4008
00008a  d109              BNE      |L59.160|
00008c  6820              LDR      r0,[r4,#0]            ;4010
00008e  6801              LDR      r1,[r0,#0]            ;4010
000090  f4215100          BIC      r1,r1,#0x2000         ;4010
000094  6001              STR      r1,[r0,#0]            ;4010
000096  6820              LDR      r0,[r4,#0]            ;4010
000098  6801              LDR      r1,[r0,#0]            ;4010
00009a  f4415100          ORR      r1,r1,#0x2000         ;4010
00009e  6001              STR      r1,[r0,#0]            ;4010
                  |L59.160|
0000a0  2001              MOVS     r0,#1                 ;4013
0000a2  345c              ADDS     r4,r4,#0x5c           ;4013
0000a4  7060              STRB     r0,[r4,#1]            ;4013
0000a6  2000              MOVS     r0,#0                 ;4016
0000a8  7020              STRB     r0,[r4,#0]            ;4016
0000aa  2003              MOVS     r0,#3                 ;4018
                  |L59.172|
;;;4022         {
;;;4023           tmp_timeout = 0U;
;;;4024         }      
;;;4025         count--;
;;;4026       }
;;;4027     }
;;;4028   
;;;4029     return HAL_OK;
;;;4030   }
0000ac  e8bd87fc          POP      {r2-r10,pc}
                  |L59.176|
0000b0  2500              MOVS     r5,#0                 ;4023
                  |L59.178|
0000b2  9800              LDR      r0,[sp,#0]            ;4025
0000b4  1e40              SUBS     r0,r0,#1              ;4025
0000b6  9000              STR      r0,[sp,#0]            ;4025
                  |L59.184|
0000b8  6820              LDR      r0,[r4,#0]            ;3979
0000ba  6881              LDR      r1,[r0,#8]            ;3979
0000bc  4031              ANDS     r1,r1,r6              ;3979
0000be  42b9              CMP      r1,r7                 ;3979
0000c0  d1b9              BNE      |L59.54|
0000c2  2000              MOVS     r0,#0                 ;4029
0000c4  e7f2              B        |L59.172|
;;;4031   
                          ENDP

0000c6  0000              DCW      0x0000
                  |L59.200|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_WaitFlagStateUntilTimeout||, CODE, READONLY, ALIGN=2

                  SPI_WaitFlagStateUntilTimeout PROC
;;;3894     */
;;;3895   static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3896                                                          uint32_t Timeout, uint32_t Tickstart)
;;;3897   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
00000c  9d08              LDR      r5,[sp,#0x20]
;;;3898     __IO uint32_t count;
;;;3899     uint32_t tmp_timeout;
;;;3900     uint32_t tmp_tickstart;
;;;3901   
;;;3902     /* Adjust Timeout value  in case of end of transfer */
;;;3903     tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
00000e  f7fffffe          BL       HAL_GetTick
000012  1b40              SUBS     r0,r0,r5
000014  1a35              SUBS     r5,r6,r0
;;;3904     tmp_tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4680              MOV      r8,r0
;;;3905   
;;;3906     /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
;;;3907     count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
00001c  4826              LDR      r0,|L60.184|
00001e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000020  f3c030cb          UBFX     r0,r0,#15,#12
000024  4368              MULS     r0,r5,r0
000026  9000              STR      r0,[sp,#0]
;;;3908   
;;;3909     while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
000028  e03a              B        |L60.160|
                  |L60.42|
;;;3910     {
;;;3911       if (Timeout != HAL_MAX_DELAY)
00002a  1c70              ADDS     r0,r6,#1
00002c  d038              BEQ      |L60.160|
;;;3912       {
;;;3913         if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
00002e  f7fffffe          BL       HAL_GetTick
000032  eba00008          SUB      r0,r0,r8
000036  42a8              CMP      r0,r5
000038  d203              BCS      |L60.66|
00003a  b115              CBZ      r5,|L60.66|
;;;3914         {
;;;3915           /* Disable the SPI and reset the CRC: the CRC value should be cleared
;;;3916              on both master and slave sides in order to resynchronize the master
;;;3917              and slave for their respective CRC calculation */
;;;3918   
;;;3919           /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
;;;3920           __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;3921   
;;;3922           if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;3923                                                        || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
;;;3924           {
;;;3925             /* Disable SPI peripheral */
;;;3926             __HAL_SPI_DISABLE(hspi);
;;;3927           }
;;;3928   
;;;3929           /* Reset CRC Calculation */
;;;3930           if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3931           {
;;;3932             SPI_RESET_CRC(hspi);
;;;3933           }
;;;3934   
;;;3935           hspi->State = HAL_SPI_STATE_READY;
;;;3936   
;;;3937           /* Process Unlocked */
;;;3938           __HAL_UNLOCK(hspi);
;;;3939   
;;;3940           return HAL_TIMEOUT;
;;;3941         }
;;;3942         /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
;;;3943         if(count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b358              CBZ      r0,|L60.152|
000040  e02b              B        |L60.154|
                  |L60.66|
000042  6820              LDR      r0,[r4,#0]            ;3920
000044  6841              LDR      r1,[r0,#4]            ;3920
000046  f02101e0          BIC      r1,r1,#0xe0           ;3920
00004a  6041              STR      r1,[r0,#4]            ;3920
00004c  6860              LDR      r0,[r4,#4]            ;3922
00004e  f5b07f82          CMP      r0,#0x104             ;3922
000052  d10b              BNE      |L60.108|
000054  68a0              LDR      r0,[r4,#8]            ;3922
000056  f5b04f00          CMP      r0,#0x8000            ;3922
00005a  d002              BEQ      |L60.98|
00005c  f5b06f80          CMP      r0,#0x400             ;3923
000060  d104              BNE      |L60.108|
                  |L60.98|
000062  6820              LDR      r0,[r4,#0]            ;3926
000064  6801              LDR      r1,[r0,#0]            ;3926
000066  f0210140          BIC      r1,r1,#0x40           ;3926
00006a  6001              STR      r1,[r0,#0]            ;3926
                  |L60.108|
00006c  6aa0              LDR      r0,[r4,#0x28]         ;3930
00006e  f5b05f00          CMP      r0,#0x2000            ;3930
000072  d109              BNE      |L60.136|
000074  6820              LDR      r0,[r4,#0]            ;3932
000076  6801              LDR      r1,[r0,#0]            ;3932
000078  f4215100          BIC      r1,r1,#0x2000         ;3932
00007c  6001              STR      r1,[r0,#0]            ;3932
00007e  6820              LDR      r0,[r4,#0]            ;3932
000080  6801              LDR      r1,[r0,#0]            ;3932
000082  f4415100          ORR      r1,r1,#0x2000         ;3932
000086  6001              STR      r1,[r0,#0]            ;3932
                  |L60.136|
000088  2001              MOVS     r0,#1                 ;3935
00008a  345c              ADDS     r4,r4,#0x5c           ;3935
00008c  7060              STRB     r0,[r4,#1]            ;3935
00008e  2000              MOVS     r0,#0                 ;3938
000090  7020              STRB     r0,[r4,#0]            ;3938
000092  2003              MOVS     r0,#3                 ;3940
                  |L60.148|
;;;3944         {
;;;3945           tmp_timeout = 0U;
;;;3946         }
;;;3947         count--;
;;;3948       }
;;;3949     }
;;;3950   
;;;3951     return HAL_OK;
;;;3952   }
000094  e8bd83f8          POP      {r3-r9,pc}
                  |L60.152|
000098  2500              MOVS     r5,#0                 ;3945
                  |L60.154|
00009a  9800              LDR      r0,[sp,#0]            ;3947
00009c  1e40              SUBS     r0,r0,#1              ;3947
00009e  9000              STR      r0,[sp,#0]            ;3947
                  |L60.160|
0000a0  6820              LDR      r0,[r4,#0]            ;3909
0000a2  6880              LDR      r0,[r0,#8]            ;3909
0000a4  ea370000          BICS     r0,r7,r0              ;3909
0000a8  d004              BEQ      |L60.180|
0000aa  2000              MOVS     r0,#0                 ;3909
                  |L60.172|
0000ac  4548              CMP      r0,r9                 ;3909
0000ae  d1bc              BNE      |L60.42|
0000b0  2000              MOVS     r0,#0                 ;3951
0000b2  e7ef              B        |L60.148|
                  |L60.180|
0000b4  2001              MOVS     r0,#1                 ;3909
0000b6  e7f9              B        |L60.172|
;;;3953   
                          ENDP

                  |L60.184|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_spi_c_5e7b22bd____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_spi_c_5e7b22bd____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_spi_c_5e7b22bd____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_spi_c_5e7b22bd____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_spi_c_5e7b22bd____RRX|
#line 694
|__asm___19_stm32l4xx_hal_spi_c_5e7b22bd____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
