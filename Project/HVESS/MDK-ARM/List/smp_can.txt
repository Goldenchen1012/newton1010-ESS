; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\smp_can.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\smp_can.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\SMP\smp_can.c]
                          THUMB

                          AREA ||i.CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  CAN1_RX0_IRQHandler PROC
;;;596    
;;;597    void BSP_CAN0_RX_IRQHandler(void)
000000  4801              LDR      r0,|L1.8|
;;;598    {
;;;599    	#if 0
;;;600      GPIOD->ODR ^= GPIO_PIN_15;
;;;601      #endif
;;;602    	
;;;603    	HAL_CAN_IRQHandler(&smp_can0_handle);
000002  f7ffbffe          B.W      HAL_CAN_IRQHandler
;;;604    	
;;;605    }
;;;606    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||.bss||

                          AREA ||i.CAN1_TX_IRQHandler||, CODE, READONLY, ALIGN=2

                  CAN1_TX_IRQHandler PROC
;;;587    
;;;588    void BSP_CAN0_TX_IRQHandler(void)
000000  4801              LDR      r0,|L2.8|
;;;589    {
;;;590    	#if 0
;;;591      GPIOD->ODR ^= GPIO_PIN_14;
;;;592      #endif
;;;593    	
;;;594    	HAL_CAN_IRQHandler(&smp_can0_handle);
000002  f7ffbffe          B.W      HAL_CAN_IRQHandler
;;;595    }
;;;596    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.bss||

                          AREA ||i.CAN2_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  CAN2_RX0_IRQHandler PROC
;;;615    
;;;616    void BSP_CAN1_RX_IRQHandler(void)
000000  4801              LDR      r0,|L3.8|
;;;617    {
;;;618    	#if 0
;;;619      GPIOD->ODR ^= GPIO_PIN_15;
;;;620      #endif
;;;621    	
;;;622    	HAL_CAN_IRQHandler(&smp_can1_handle);
000002  f7ffbffe          B.W      HAL_CAN_IRQHandler
;;;623    	
;;;624    }
;;;625    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.bss||+0x48

                          AREA ||i.CAN2_TX_IRQHandler||, CODE, READONLY, ALIGN=2

                  CAN2_TX_IRQHandler PROC
;;;606    
;;;607    void BSP_CAN1_TX_IRQHandler(void)
000000  4801              LDR      r0,|L4.8|
;;;608    {
;;;609    	#if 0
;;;610      GPIOD->ODR ^= GPIO_PIN_14;
;;;611      #endif
;;;612    	
;;;613    	HAL_CAN_IRQHandler(&smp_can1_handle);
000002  f7ffbffe          B.W      HAL_CAN_IRQHandler
;;;614    }
;;;615    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.bss||+0x48

                          AREA ||i.HAL_CAN_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_CAN_MspInit PROC
;;;497    
;;;498    void HAL_CAN_MspInit(CAN_HandleTypeDef *hcan)
000000  b5f0              PUSH     {r4-r7,lr}
;;;499    {	
000002  b087              SUB      sp,sp,#0x1c
;;;500    	GPIO_InitTypeDef   GPIO_InitStruct;
;;;501    	
;;;502    	if(hcan->Instance == BSP_CAN0)
000004  4a35              LDR      r2,|L5.220|
;;;503    	{
;;;504    		/*##-1- Enable peripherals and GPIO Clocks #################################*/
;;;505    		/* BSP_CAN0 Periph clock enable */
;;;506    		BSP_CAN0_CLK_ENABLE();
000006  6801              LDR      r1,[r0,#0]
000008  4835              LDR      r0,|L5.224|
;;;507    		/* Enable GPIO clock ****************************************/
;;;508    		BSP_CAN0_RX_GPIO_CLK_ENABLE();
;;;509    		BSP_CAN0_TX_GPIO_CLK_ENABLE();
;;;510    		
;;;511    		/*##-2- Configure peripheral GPIO ##########################################*/
;;;512    		/* BSP_CAN0 TX GPIO pin configuration */
;;;513    		GPIO_InitStruct.Pin = BSP_CAN0_TX_PIN;
;;;514    		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00000a  2502              MOVS     r5,#2
;;;515    		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
00000c  2403              MOVS     r4,#3
;;;516    		GPIO_InitStruct.Pull = GPIO_PULLUP;
00000e  2601              MOVS     r6,#1
000010  4291              CMP      r1,r2                 ;502
000012  d120              BNE      |L5.86|
000014  6d81              LDR      r1,[r0,#0x58]         ;506
000016  f0417100          ORR      r1,r1,#0x2000000      ;506
00001a  6581              STR      r1,[r0,#0x58]         ;506
00001c  6d81              LDR      r1,[r0,#0x58]         ;506
00001e  f0017100          AND      r1,r1,#0x2000000      ;506
000022  9101              STR      r1,[sp,#4]            ;506
000024  6cc1              LDR      r1,[r0,#0x4c]         ;508
000026  f0410101          ORR      r1,r1,#1              ;508
00002a  64c1              STR      r1,[r0,#0x4c]         ;508
00002c  6cc1              LDR      r1,[r0,#0x4c]         ;508
00002e  f0010101          AND      r1,r1,#1              ;508
000032  9101              STR      r1,[sp,#4]            ;508
000034  6cc1              LDR      r1,[r0,#0x4c]         ;509
000036  f0410101          ORR      r1,r1,#1              ;509
00003a  64c1              STR      r1,[r0,#0x4c]         ;509
00003c  6cc0              LDR      r0,[r0,#0x4c]         ;509
00003e  f0000001          AND      r0,r0,#1              ;509
000042  9001              STR      r0,[sp,#4]            ;509
000044  9503              STR      r5,[sp,#0xc]          ;514
000046  9405              STR      r4,[sp,#0x14]         ;515
000048  9604              STR      r6,[sp,#0x10]
;;;517    		GPIO_InitStruct.Alternate =  BSP_CAN0_TX_AF;
00004a  2009              MOVS     r0,#9
00004c  9006              STR      r0,[sp,#0x18]
;;;518    		
;;;519    		#if 0
;;;520        HAL_GPIO_Init(BSP_CAN0_TX_GPIO_PORT, &GPIO_InitStruct);
;;;521        #endif
;;;522    		
;;;523    		/* BSP_CAN0 RX GPIO pin configuration */
;;;524    		GPIO_InitStruct.Pin = BSP_CAN0_RX_PIN;
00004e  14d0              ASRS     r0,r2,#19
000050  9002              STR      r0,[sp,#8]
                  |L5.82|
;;;525    		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;526    		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
;;;527    		GPIO_InitStruct.Pull = GPIO_PULLUP;
;;;528    		GPIO_InitStruct.Alternate =  BSP_CAN0_RX_AF;
;;;529    
;;;530        #if 0
;;;531    		HAL_GPIO_Init(BSP_CAN0_RX_GPIO_PORT, &GPIO_InitStruct);
;;;532        #endif
;;;533    		
;;;534    		/*##-3- Configure the NVIC #################################################*/
;;;535    		/* NVIC configuration for CAN1 Reception complete interrupt */
;;;536        #if 0
;;;537        HAL_NVIC_SetPriority(BSP_CAN0_IRQn, 1, 0);
;;;538        HAL_NVIC_EnableIRQ(BSP_CAN0_IRQn);
;;;539        #endif	
;;;540    	}
;;;541    	else if(hcan->Instance == BSP_CAN1)
;;;542    	{
;;;543    		/*##-1- Enable peripherals and GPIO Clocks #################################*/
;;;544    		/* BSP_CAN1 Periph clock enable */
;;;545    		BSP_CAN1_CLK_ENABLE();
;;;546    		/* Enable GPIO clock ****************************************/
;;;547    		BSP_CAN1_RX_GPIO_CLK_ENABLE();
;;;548    		BSP_CAN1_TX_GPIO_CLK_ENABLE();
;;;549    		
;;;550    		/*##-2- Configure peripheral GPIO ##########################################*/
;;;551    		/* BSP_CAN1 TX GPIO pin configuration */
;;;552    		GPIO_InitStruct.Pin = BSP_CAN1_TX_PIN;
;;;553    		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;554    		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
;;;555    		GPIO_InitStruct.Pull = GPIO_PULLUP;
;;;556    		GPIO_InitStruct.Alternate =  BSP_CAN1_TX_AF;
;;;557    		HAL_GPIO_Init(BSP_CAN1_TX_GPIO_PORT, &GPIO_InitStruct);
;;;558    
;;;559    		/* BSP_CAN1 RX GPIO pin configuration */
;;;560    		GPIO_InitStruct.Pin = BSP_CAN1_RX_PIN;
;;;561    		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;562    		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
;;;563    		GPIO_InitStruct.Pull = GPIO_PULLUP;
;;;564    		GPIO_InitStruct.Alternate =  BSP_CAN1_RX_AF;
;;;565    
;;;566    		HAL_GPIO_Init(BSP_CAN1_RX_GPIO_PORT, &GPIO_InitStruct);
;;;567    
;;;568    		/*##-3- Configure the NVIC #################################################*/
;;;569    		/* NVIC configuration for BSP_CAN1 Reception complete interrupt */
;;;570    		HAL_NVIC_SetPriority(BSP_CAN1_RX_IRQn, 1, 0);
;;;571    		HAL_NVIC_EnableIRQ(BSP_CAN1_RX_IRQn); 	
;;;572    
;;;573    		HAL_NVIC_SetPriority(BSP_CAN1_TX_IRQn, 1, 0);
;;;574    		HAL_NVIC_EnableIRQ(BSP_CAN1_TX_IRQn); 	
;;;575    
;;;576        #if 0
;;;577    		GPIOD->ODR ^= GPIO_PIN_15;
;;;578    		CAN2_TX_IRQn                = 86,     /*!< CAN2 TX interrupt                                                 */
;;;579    		CAN2_RX0_IRQn               = 87,     /*!< CAN2 RX0 interrupt                                                */
;;;580    		CAN2_RX1_IRQn               = 88,     /*!< CAN2 RX1 interrupt                                                */
;;;581        #endif
;;;582    
;;;583    	}	
;;;584    	
;;;585    }
000052  b007              ADD      sp,sp,#0x1c
000054  bdf0              POP      {r4-r7,pc}
                  |L5.86|
000056  4a23              LDR      r2,|L5.228|
000058  4291              CMP      r1,r2                 ;541
00005a  d1fa              BNE      |L5.82|
00005c  6d81              LDR      r1,[r0,#0x58]         ;545
00005e  f0416180          ORR      r1,r1,#0x4000000      ;545
000062  6581              STR      r1,[r0,#0x58]         ;545
000064  6d81              LDR      r1,[r0,#0x58]         ;545
000066  f0016180          AND      r1,r1,#0x4000000      ;545
00006a  9101              STR      r1,[sp,#4]            ;545
00006c  6cc1              LDR      r1,[r0,#0x4c]         ;547
00006e  f0410102          ORR      r1,r1,#2              ;547
000072  64c1              STR      r1,[r0,#0x4c]         ;547
000074  6cc1              LDR      r1,[r0,#0x4c]         ;547
000076  f0010102          AND      r1,r1,#2              ;547
00007a  9101              STR      r1,[sp,#4]            ;547
00007c  6cc1              LDR      r1,[r0,#0x4c]         ;548
00007e  f0410102          ORR      r1,r1,#2              ;548
000082  64c1              STR      r1,[r0,#0x4c]         ;548
000084  6cc0              LDR      r0,[r0,#0x4c]         ;548
000086  f0000002          AND      r0,r0,#2              ;548
00008a  9001              STR      r0,[sp,#4]            ;548
00008c  2040              MOVS     r0,#0x40              ;552
00008e  9002              STR      r0,[sp,#8]            ;552
000090  9503              STR      r5,[sp,#0xc]          ;553
000092  9405              STR      r4,[sp,#0x14]         ;554
000094  9604              STR      r6,[sp,#0x10]         ;555
000096  2008              MOVS     r0,#8                 ;556
000098  9006              STR      r0,[sp,#0x18]         ;556
00009a  4f13              LDR      r7,|L5.232|
00009c  a902              ADD      r1,sp,#8              ;557
00009e  4638              MOV      r0,r7                 ;557
0000a0  f7fffffe          BL       HAL_GPIO_Init
0000a4  2020              MOVS     r0,#0x20              ;560
0000a6  9002              STR      r0,[sp,#8]            ;560
0000a8  9503              STR      r5,[sp,#0xc]          ;561
0000aa  9405              STR      r4,[sp,#0x14]         ;562
0000ac  9604              STR      r6,[sp,#0x10]         ;563
0000ae  9406              STR      r4,[sp,#0x18]         ;564
0000b0  a902              ADD      r1,sp,#8              ;566
0000b2  4638              MOV      r0,r7                 ;566
0000b4  f7fffffe          BL       HAL_GPIO_Init
0000b8  2200              MOVS     r2,#0                 ;570
0000ba  2101              MOVS     r1,#1                 ;570
0000bc  2057              MOVS     r0,#0x57              ;570
0000be  f7fffffe          BL       HAL_NVIC_SetPriority
0000c2  2057              MOVS     r0,#0x57              ;571
0000c4  f7fffffe          BL       HAL_NVIC_EnableIRQ
0000c8  2200              MOVS     r2,#0                 ;573
0000ca  2101              MOVS     r1,#1                 ;573
0000cc  2056              MOVS     r0,#0x56              ;573
0000ce  f7fffffe          BL       HAL_NVIC_SetPriority
0000d2  2056              MOVS     r0,#0x56              ;574
0000d4  f7fffffe          BL       HAL_NVIC_EnableIRQ
0000d8  e7bb              B        |L5.82|
;;;586    
                          ENDP

0000da  0000              DCW      0x0000
                  |L5.220|
                          DCD      0x40006400
                  |L5.224|
                          DCD      0x40021000
                  |L5.228|
                          DCD      0x40006800
                  |L5.232|
                          DCD      0x48000400

                          AREA ||i.HAL_CAN_RxFifo0MsgPendingCallback||, CODE, READONLY, ALIGN=2

                  HAL_CAN_RxFifo0MsgPendingCallback PROC
;;;398    
;;;399    void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
000000  b500              PUSH     {lr}
;;;400    {
000002  b08d              SUB      sp,sp,#0x34
;;;401    	uint8_t flag=0;
;;;402    	CAN_RxHeaderTypeDef   RxHeader;
;;;403    	uint8_t               RxData[8];
;;;404    	smp_can_package_t	CanPkg;
;;;405    
;;;406    	
;;;407    	if(hcan->Instance == BSP_CAN0){
000004  4a21              LDR      r2,|L6.140|
000006  6801              LDR      r1,[r0,#0]
000008  4291              CMP      r1,r2
00000a  d037              BEQ      |L6.124|
;;;408    		#if 0
;;;409    		if(smp_fifo_push(&uart0_rx_fifo, (char)uart0_rx_buffer[0]) == SMP_SUCCESS){
;;;410    			flag = 1;
;;;411    		}else{
;;;412    			flag = 0;
;;;413    		}		
;;;414    			
;;;415    		if(HAL_UART_Receive_DMA(huart, uart0_rx_buffer, UART_RX_BUFFER_SIZE) != HAL_OK){
;;;416    			return;
;;;417    		}
;;;418    		
;;;419    		if(flag == 1){
;;;420    			if(uart0_evt_cb)
;;;421    				uart0_evt_cb(UART_DATA_READY);
;;;422    		}else{
;;;423    			if(uart0_evt_cb)
;;;424    				uart0_evt_cb(UART_BUFFER_FULL);
;;;425    		}			
;;;426    		#endif
;;;427    		/* Test debug, but may demage the uart function.
;;;428        gpio_test_p_state = GPIO_ACTIVE_TOGGLE;
;;;429        smp_gpio_set_state(&gpio_test_p, gpio_test_p_state);		
;;;430    		*/
;;;431    		
;;;432    	}else if(hcan->Instance == BSP_CAN1){
00000c  4a20              LDR      r2,|L6.144|
00000e  4291              CMP      r1,r2
000010  d134              BNE      |L6.124|
;;;433    //			GPIOD->ODR ^= GPIO_PIN_15;
;;;434    		/* Get RX message */
;;;435    		if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData) != HAL_OK)
000012  ab04              ADD      r3,sp,#0x10
000014  aa06              ADD      r2,sp,#0x18
000016  2100              MOVS     r1,#0
000018  f7fffffe          BL       HAL_CAN_GetRxMessage
00001c  2800              CMP      r0,#0
00001e  d12d              BNE      |L6.124|
;;;436    		{
;;;437    			/* Reception Error */
;;;438    			//Error_Handler();
;;;439    			return;
;;;440    		}
;;;441    		if(RxHeader.IDE == CAN_ID_STD)
000020  9808              LDR      r0,[sp,#0x20]
000022  b128              CBZ      r0,|L6.48|
;;;442    		{
;;;443    			CanPkg.id = RxHeader.StdId;
;;;444    			CanPkg.id |= CAN_STD_MASK;
;;;445    		}
;;;446    		else
;;;447    		{
;;;448    			CanPkg.id = RxHeader.ExtId;
000024  9807              LDR      r0,[sp,#0x1c]
000026  9000              STR      r0,[sp,#0]
                  |L6.40|
;;;449    		}
;;;450    		if(RxHeader.RTR == CAN_RTR_REMOTE)
000028  9809              LDR      r0,[sp,#0x24]
00002a  2802              CMP      r0,#2
00002c  d007              BEQ      |L6.62|
00002e  e00a              B        |L6.70|
                  |L6.48|
000030  9806              LDR      r0,[sp,#0x18]         ;443
000032  9000              STR      r0,[sp,#0]            ;443
000034  9800              LDR      r0,[sp,#0]            ;444
000036  f0404000          ORR      r0,r0,#0x80000000     ;444
00003a  9000              STR      r0,[sp,#0]            ;444
00003c  e7f4              B        |L6.40|
                  |L6.62|
;;;451    		{
;;;452    			CanPkg.id |= CAN_RTR_MASK;
00003e  9800              LDR      r0,[sp,#0]
000040  f0404080          ORR      r0,r0,#0x40000000
000044  9000              STR      r0,[sp,#0]
                  |L6.70|
;;;453    		}
;;;454    		CanPkg.dlc = RxHeader.DLC;
000046  980a              LDR      r0,[sp,#0x28]
000048  b2c0              UXTB     r0,r0
00004a  f88d0004          STRB     r0,[sp,#4]
;;;455    		if(CanPkg.dlc > 8)
00004e  2808              CMP      r0,#8
000050  d902              BLS      |L6.88|
;;;456    			CanPkg.dlc = 8;
000052  2008              MOVS     r0,#8
000054  f88d0004          STRB     r0,[sp,#4]
                  |L6.88|
;;;457    		memcpy(CanPkg.dat, RxData, CanPkg.dlc);
000058  f89d2004          LDRB     r2,[sp,#4]
00005c  a904              ADD      r1,sp,#0x10
00005e  f10d0005          ADD      r0,sp,#5
000062  f7fffffe          BL       __aeabi_memcpy
;;;458    		
;;;459    		if(smp_can_fifo_push(&can1_rx_fifo, &CanPkg) == SMP_SUCCESS)
000066  4669              MOV      r1,sp
000068  480a              LDR      r0,|L6.148|
00006a  f7fffffe          BL       smp_can_fifo_push
;;;460    		{
;;;461    			if(can1_evt_cb)
00006e  490a              LDR      r1,|L6.152|
000070  b130              CBZ      r0,|L6.128|
;;;462    				can1_evt_cb(CAN_DATA_READY);
;;;463    		}else{
;;;464    			if(can1_evt_cb)
000072  6849              LDR      r1,[r1,#4]  ; can1_evt_cb
000074  2900              CMP      r1,#0
000076  d001              BEQ      |L6.124|
;;;465    				can1_evt_cb(CAN_BUFFER_FULL);
000078  2001              MOVS     r0,#1
00007a  4788              BLX      r1
                  |L6.124|
;;;466    		}		
;;;467      
;;;468    		#if	0
;;;469    		if(smp_fifo_push(&uart1_rx_fifo, (char)uart1_rx_buffer[0]) == SMP_SUCCESS){
;;;470    			flag = 1;
;;;471    		}else{
;;;472    			flag = 0;
;;;473    		}		
;;;474    			
;;;475    		if(HAL_UART_Receive_DMA(huart, uart1_rx_buffer, UART3_RX_BUFFER_SIZE) != HAL_OK){
;;;476    			return;
;;;477    		}
;;;478    		
;;;479    		if(flag == 1){
;;;480    			if(uart1_evt_cb)
;;;481    				uart1_evt_cb(UART_DATA_READY);
;;;482    		}else{
;;;483    			if(uart1_evt_cb)
;;;484    				uart1_evt_cb(UART_BUFFER_FULL);
;;;485    		}			
;;;486    		#endif
;;;487    		/* Test debug, but may demage the uart function.
;;;488        gpio_test_p_state = GPIO_ACTIVE_TOGGLE;
;;;489        smp_gpio_set_state(&gpio_test_p, gpio_test_p_state);		
;;;490    		*/	
;;;491    	}		
;;;492    
;;;493    }
00007c  b00d              ADD      sp,sp,#0x34
00007e  bd00              POP      {pc}
                  |L6.128|
000080  6849              LDR      r1,[r1,#4]            ;461  ; can1_evt_cb
000082  2900              CMP      r1,#0                 ;461
000084  d0fa              BEQ      |L6.124|
000086  2000              MOVS     r0,#0                 ;462
000088  4788              BLX      r1                    ;462
00008a  e7f7              B        |L6.124|
;;;494    
                          ENDP

                  |L6.140|
                          DCD      0x40006400
                  |L6.144|
                          DCD      0x40006800
                  |L6.148|
                          DCD      ||.bss||+0x70
                  |L6.152|
                          DCD      ||.data||

                          AREA ||i.HAL_CAN_TxMailbox0CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox0CompleteCallback PROC
;;;393    }
;;;394    void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
000000  f7ffbffe          B.W      PutCanDataToMailBox
;;;395    {
;;;396    	PutCanDataToMailBox(hcan);
;;;397    }
;;;398    
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox1CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox1CompleteCallback PROC
;;;389    }
;;;390    void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
000000  f7ffbffe          B.W      PutCanDataToMailBox
;;;391    {
;;;392    	PutCanDataToMailBox(hcan);
;;;393    }
;;;394    void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox2CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox2CompleteCallback PROC
;;;385    
;;;386    void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
000000  f7ffbffe          B.W      PutCanDataToMailBox
;;;387    {
;;;388    	PutCanDataToMailBox(hcan);
;;;389    }
;;;390    void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
                          ENDP


                          AREA ||i.PutCanDataToMailBox||, CODE, READONLY, ALIGN=2

                  PutCanDataToMailBox PROC
;;;311    //void HAL_CAN_TxMailbox1AbortCallback
;;;312    void PutCanDataToMailBox(CAN_HandleTypeDef *hcan)
000000  b500              PUSH     {lr}
;;;313    {	
000002  b08b              SUB      sp,sp,#0x2c
;;;314    	uint16_t size = 0, i =0;
;;;315    	uint32_t              TxMailbox;
;;;316    	CAN_TxHeaderTypeDef   TxHeader;
;;;317    	smp_can_package_t		CanPkg;
;;;318    	uint8_t	buf[10];
;;;319    
;;;320    
;;;321    	if(hcan->Instance == BSP_CAN0){
000004  4a19              LDR      r2,|L10.108|
000006  6801              LDR      r1,[r0,#0]
000008  4291              CMP      r1,r2
00000a  d02d              BEQ      |L10.104|
;;;322    		#if	0
;;;323    		if(smp_fifo_get_size(&uart0_tx_fifo,&size)==SMP_SUCCESS){
;;;324    			if(size>UART_TX_BUFFER_SIZE)
;;;325    				size = UART_TX_BUFFER_SIZE;
;;;326    			// This operation should be almost always successful, since we've
;;;327    			// just added a byte to FIFO, but if some bigger delay occurred
;;;328    			// (some heavy interrupt handler routine has been executed) since
;;;329    			// that time, FIFO might be empty already.
;;;330    			for(i=0;i<size;i++){
;;;331    				smp_fifo_pop(&uart0_tx_fifo, (char *)&uart0_tx_buffer[i]);
;;;332    			}
;;;333    			HAL_UART_Transmit_DMA(&smp_uart0_handle, &uart0_tx_buffer[0], size);
;;;334    		}else{
;;;335    			if(uart0_evt_cb)
;;;336    				uart0_evt_cb(UART_TX_EMPTY);
;;;337    		}
;;;338    		#endif
;;;339    	}else if(hcan->Instance == BSP_CAN1){
00000c  4a18              LDR      r2,|L10.112|
00000e  4291              CMP      r1,r2
000010  d12a              BNE      |L10.104|
;;;340    		
;;;341    		//if()	//check empty mailbox
;;;342          	if(HAL_CAN_GetTxMailboxesFreeLevel(hcan) != 0)
000012  f7fffffe          BL       HAL_CAN_GetTxMailboxesFreeLevel
000016  2800              CMP      r0,#0
000018  d026              BEQ      |L10.104|
;;;343            {
;;;344    //        	GPIOD->ODR ^= GPIO_PIN_14;
;;;345           		if(smp_can_fifo_pop(&can1_tx_fifo, &CanPkg) == SMP_SUCCESS)
00001a  4669              MOV      r1,sp
00001c  4815              LDR      r0,|L10.116|
00001e  f7fffffe          BL       smp_can_fifo_pop
000022  2800              CMP      r0,#0
000024  d120              BNE      |L10.104|
;;;346           		{
;;;347           			if(CanPkg.id & CAN_STD_MASK)
000026  9800              LDR      r0,[sp,#0]
000028  2100              MOVS     r1,#0
00002a  2800              CMP      r0,#0
00002c  da04              BGE      |L10.56|
;;;348           			{
;;;349    					TxHeader.StdId = (CanPkg.id & CAN_ID_MASK);
00002e  f0204260          BIC      r2,r0,#0xe0000000
000032  9204              STR      r2,[sp,#0x10]
;;;350    					TxHeader.IDE = CAN_ID_STD;
000034  9106              STR      r1,[sp,#0x18]
000036  e004              B        |L10.66|
                  |L10.56|
;;;351    				}
;;;352    				else
;;;353    				{
;;;354    					TxHeader.ExtId = (CanPkg.id & CAN_ID_MASK);
000038  f0204260          BIC      r2,r0,#0xe0000000
00003c  9205              STR      r2,[sp,#0x14]
;;;355    					TxHeader.IDE = CAN_ID_EXT;
00003e  2204              MOVS     r2,#4
000040  9206              STR      r2,[sp,#0x18]
                  |L10.66|
;;;356    				}
;;;357    				if(CanPkg.id & CAN_RTR_MASK)
000042  0040              LSLS     r0,r0,#1
000044  d502              BPL      |L10.76|
;;;358    					TxHeader.RTR = CAN_RTR_REMOTE;
000046  2002              MOVS     r0,#2
000048  9007              STR      r0,[sp,#0x1c]
00004a  e000              B        |L10.78|
                  |L10.76|
;;;359    				else
;;;360    					TxHeader.RTR = CAN_RTR_DATA;
00004c  9107              STR      r1,[sp,#0x1c]
                  |L10.78|
;;;361      					TxHeader.DLC = CanPkg.dlc;
00004e  f89d0004          LDRB     r0,[sp,#4]
000052  9008              STR      r0,[sp,#0x20]
;;;362    				TxHeader.TransmitGlobalTime = DISABLE;
000054  f88d1024          STRB     r1,[sp,#0x24]
;;;363    				HAL_CAN_AddTxMessage(&smp_can1_handle, &TxHeader, CanPkg.dat, &TxMailbox);
000058  4806              LDR      r0,|L10.116|
00005a  ab0a              ADD      r3,sp,#0x28
00005c  f10d0205          ADD      r2,sp,#5
000060  a904              ADD      r1,sp,#0x10
000062  3838              SUBS     r0,r0,#0x38
000064  f7fffffe          BL       HAL_CAN_AddTxMessage
                  |L10.104|
;;;364          		}
;;;365      		}	
;;;366    		#if	0
;;;367    		if(smp_fifo_get_size(&uart1_tx_fifo,&size)==SMP_SUCCESS){
;;;368    			if(size>UART3_TX_BUFFER_SIZE)
;;;369    				size = UART3_TX_BUFFER_SIZE;
;;;370    			// This operation should be almost always successful, since we've
;;;371    			// just added a byte to FIFO, but if some bigger delay occurred
;;;372    			// (some heavy interrupt handler routine has been executed) since
;;;373    			// that time, FIFO might be empty already.
;;;374    			for(i=0;i<size;i++){
;;;375    				smp_fifo_pop(&uart1_tx_fifo, (char *)&uart1_tx_buffer[i]);
;;;376    			}
;;;377    			HAL_UART_Transmit_DMA(&smp_uart1_handle, &uart1_tx_buffer[0], size);
;;;378    		}else{
;;;379    			if(uart1_evt_cb)
;;;380    				uart1_evt_cb(UART_TX_EMPTY);
;;;381    		}
;;;382    		#endif
;;;383    	}
;;;384    }
000068  b00b              ADD      sp,sp,#0x2c
00006a  bd00              POP      {pc}
;;;385    
                          ENDP

                  |L10.108|
                          DCD      0x40006400
                  |L10.112|
                          DCD      0x40006800
                  |L10.116|
                          DCD      ||.bss||+0x80

                          AREA ||i.can_fifo_init||, CODE, READONLY, ALIGN=1

                  can_fifo_init PROC
;;;57     
;;;58     int8_t can_fifo_init(smp_can_fifo_t * p_fifo, smp_can_package_t * p_buf, uint16_t buf_size)
000000  2900              CMP      r1,#0
;;;59     {
000002  d007              BEQ      |L11.20|
;;;60         // Check buffer for null pointer.
;;;61         if (p_buf == NULL){
;;;62             return SMP_ERROR_NULL;
;;;63         }
;;;64     
;;;65         p_fifo->buffer_addr   = (smp_can_package_t *)p_buf;
000004  6001              STR      r1,[r0,#0]
;;;66         p_fifo->buffer_size 	= buf_size - 1;
000006  1e52              SUBS     r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;67         p_fifo->in      			= 0;
00000a  2100              MOVS     r1,#0
00000c  6081              STR      r1,[r0,#8]
;;;68         p_fifo->out     			= 0;
00000e  60c1              STR      r1,[r0,#0xc]
;;;69     
;;;70         return SMP_SUCCESS;
000010  2000              MOVS     r0,#0
;;;71     }
000012  4770              BX       lr
                  |L11.20|
000014  f06f000a          MVN      r0,#0xa               ;62
000018  4770              BX       lr
;;;72     
                          ENDP


                          AREA ||i.smp_can_deinit||, CODE, READONLY, ALIGN=1

                  smp_can_deinit PROC
;;;200    
;;;201    int8_t smp_can_deinit(smp_can_t *p_uart)
000000  7800              LDRB     r0,[r0,#0]
;;;202    {
;;;203    	if(p_uart->num == __CAN0){
;;;204    		#if	0
;;;205    		if(smp_can0_handle.Instance != 0){
;;;206    			  		if ((&smp_can1_handle) != HAL_OK)
;;;207    
;;;208    			if(HAL_CAN_DeInit(&smp_uart0_handle) != HAL_OK)
;;;209    				return SMP_ERROR_NOT_FOUND;
;;;210    			smp_can0_handle.Instance = 0;
;;;211    		}
;;;212    		#endif
;;;213    	}else if(p_uart->num == __CAN1){
;;;214    		#if	0
;;;215    		if(smp_uart1_handle.Instance != 0){
;;;216    			if(HAL_UART_DeInit(&smp_uart1_handle) != HAL_OK)
;;;217    				return SMP_ERROR_NOT_FOUND;
;;;218    			smp_uart1_handle.Instance = 0;
;;;219    		}
;;;220    		#endif
;;;221    	}		
;;;222    	return SMP_SUCCESS;
000002  2000              MOVS     r0,#0
;;;223    }
000004  4770              BX       lr
;;;224    
                          ENDP


                          AREA ||i.smp_can_get||, CODE, READONLY, ALIGN=2

                  smp_can_get PROC
;;;296    
;;;297    int8_t smp_can_get(smp_can_t *p_can, smp_can_package_t *pCanDat)
000000  7802              LDRB     r2,[r0,#0]
;;;298    {
;;;299    	int8_t bdata;
;;;300    	if(p_can->num == __CAN0){
000002  2a00              CMP      r2,#0
000004  d004              BEQ      |L13.16|
;;;301    	    bdata = smp_can_fifo_pop(&can0_rx_fifo, pCanDat);
;;;302    	}else if(p_can->num == __CAN1){
000006  2a01              CMP      r2,#1
000008  d106              BNE      |L13.24|
;;;303    	    bdata = smp_can_fifo_pop(&can1_rx_fifo, pCanDat);
00000a  4804              LDR      r0,|L13.28|
00000c  f7ffbffe          B.W      smp_can_fifo_pop
                  |L13.16|
000010  4802              LDR      r0,|L13.28|
000012  3848              SUBS     r0,r0,#0x48           ;301
000014  f7ffbffe          B.W      smp_can_fifo_pop
                  |L13.24|
;;;304    	}
;;;305    	
;;;306    	return(bdata);
;;;307    }
000018  4770              BX       lr
;;;308    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      ||.bss||+0x70

                          AREA ||i.smp_can_init||, CODE, READONLY, ALIGN=2

                  smp_can_init PROC
;;;72     
;;;73     int8_t smp_can_init(smp_can_t *p_can, smp_can_event_t smp_can_event_handler)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;74     {
000004  b08b              SUB      sp,sp,#0x2c
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;75     	CAN_FilterTypeDef  	sFilterConfig;
;;;76     
;;;77     	if(p_can->num == __CAN0){
00000a  7820              LDRB     r0,[r4,#0]
;;;78     		//__CAN1_CLK_ENABLE();
;;;79     		
;;;80      		smp_can0_handle.Instance = BSP_CAN0;
;;;81     
;;;82     		smp_can0_handle.Init.TimeTriggeredMode = DISABLE;
;;;83     		smp_can0_handle.Init.AutoBusOff = DISABLE;
;;;84     		smp_can0_handle.Init.AutoWakeUp = DISABLE;
;;;85     		smp_can0_handle.Init.AutoRetransmission = DISABLE;
;;;86       		smp_can0_handle.Init.ReceiveFifoLocked = DISABLE;
;;;87       		smp_can0_handle.Init.TransmitFifoPriority = ENABLE;
;;;88       		smp_can0_handle.Init.Mode = CAN_MODE_NORMAL;
;;;89       		smp_can0_handle.Init.SyncJumpWidth = CAN_SJW_1TQ;
;;;90       		smp_can0_handle.Init.TimeSeg1 = CAN_BS1_4TQ;
;;;91       		smp_can0_handle.Init.TimeSeg2 = CAN_BS2_5TQ;
;;;92       		smp_can0_handle.Init.Prescaler = 16;
00000c  2310              MOVS     r3,#0x10
;;;93     
;;;94       		if (HAL_CAN_Init(&smp_can0_handle) != HAL_OK)
;;;95       		{
;;;96         		/* Initialization Error */
;;;97         		return -1;//SMP_ERROR_NOT_FOUND;//Error_Handler();
;;;98       		}
;;;99       
;;;100    		/*##-2- Configure the CAN Filter ###########################################*/
;;;101      		sFilterConfig.FilterBank = 0;
;;;102      		sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
;;;103      		sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
;;;104      		sFilterConfig.FilterIdHigh = 0x0000;
;;;105      		sFilterConfig.FilterIdLow = 0x0000;
;;;106      		sFilterConfig.FilterMaskIdHigh = 0x0000;
;;;107      		sFilterConfig.FilterMaskIdLow = 0x0000;
;;;108      		sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
;;;109      		sFilterConfig.FilterActivation = ENABLE;
;;;110      		sFilterConfig.SlaveStartFilterBank = 14;
;;;111    
;;;112      		if (HAL_CAN_ConfigFilter(&smp_can0_handle, &sFilterConfig) != HAL_OK)
;;;113      		{
;;;114        		/* Filter configuration Error */
;;;115        		return -2;//SMP_ERROR_NOT_FOUND;//Error_Handler();
;;;116      		}
;;;117    
;;;118      		/*##-3- Start the CAN peripheral ###########################################*/
;;;119      		if (HAL_CAN_Start(&smp_can0_handle) != HAL_OK)
;;;120      		{
;;;121        		/* Start Error */
;;;122        		//Error_Handler();
;;;123        		return -3;//SMP_ERROR_NOT_FOUND;
;;;124      		}
;;;125      		
;;;126    		can0_evt_cb = smp_can_event_handler;
00000e  f8df9140          LDR      r9,|L14.336|
000012  2600              MOVS     r6,#0
000014  2701              MOVS     r7,#1                 ;87
000016  f44f3140          MOV      r1,#0x30000           ;90
00001a  f44f0280          MOV      r2,#0x400000          ;91
00001e  f04f3aff          MOV      r10,#0xffffffff       ;97
000022  f04f080e          MOV      r8,#0xe               ;110
000026  f06f0b01          MVN      r11,#1                ;115
00002a  2800              CMP      r0,#0                 ;77
00002c  d005              BEQ      |L14.58|
;;;127    		// Configure buffer RX buffer.
;;;128    		can_fifo_init(&can0_rx_fifo, p_can->buffers.rx_buf, p_can->buffers.rx_buf_size);
;;;129    		// Configure buffer TX buffer.
;;;130    		can_fifo_init(&can0_tx_fifo, p_can->buffers.tx_buf, p_can->buffers.tx_buf_size);
;;;131    
;;;132    
;;;133    	}else	if(p_can->num == __CAN1){
00002e  2801              CMP      r0,#1
000030  d042              BEQ      |L14.184|
;;;134    		  smp_can1_handle.Instance = BSP_CAN1;
;;;135    
;;;136    		  smp_can1_handle.Init.TimeTriggeredMode = DISABLE;
;;;137    		  smp_can1_handle.Init.AutoBusOff = DISABLE;
;;;138    		  smp_can1_handle.Init.AutoWakeUp = DISABLE;
;;;139    		  smp_can1_handle.Init.AutoRetransmission = DISABLE;
;;;140      		smp_can1_handle.Init.ReceiveFifoLocked = DISABLE;
;;;141      		smp_can1_handle.Init.TransmitFifoPriority = ENABLE;
;;;142      		smp_can1_handle.Init.Mode = CAN_MODE_NORMAL;
;;;143      		smp_can1_handle.Init.SyncJumpWidth = CAN_SJW_1TQ;
;;;144      		smp_can1_handle.Init.TimeSeg1 = CAN_BS1_4TQ;
;;;145      		smp_can1_handle.Init.TimeSeg2 = CAN_BS2_5TQ;
;;;146      		smp_can1_handle.Init.Prescaler = 16;
;;;147    
;;;148      		if (HAL_CAN_Init(&smp_can1_handle) != HAL_OK)
;;;149      		{
;;;150        		/* Initialization Error */
;;;151        		return SMP_ERROR_NOT_FOUND;//Error_Handler();
;;;152      		}
;;;153      
;;;154    		/*##-2- Configure the CAN Filter ###########################################*/
;;;155      		sFilterConfig.FilterBank = 14;
;;;156      		sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
;;;157      		sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
;;;158      		sFilterConfig.FilterIdHigh = 0x0000;
;;;159      		sFilterConfig.FilterIdLow = 0x0000;
;;;160      		sFilterConfig.FilterMaskIdHigh = 0x0000;
;;;161      		sFilterConfig.FilterMaskIdLow = 0x0000;
;;;162      		sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
;;;163      		sFilterConfig.FilterActivation = ENABLE;
;;;164      		sFilterConfig.SlaveStartFilterBank = 14;
;;;165    
;;;166      		if (HAL_CAN_ConfigFilter(&smp_can1_handle, &sFilterConfig) != HAL_OK)
;;;167      		{
;;;168        		/* Filter configuration Error */
;;;169        		return SMP_ERROR_NOT_FOUND;//Error_Handler();
;;;170      		}
;;;171    
;;;172      		/*##-3- Start the CAN peripheral ###########################################*/
;;;173      		if (HAL_CAN_Start(&smp_can1_handle) != HAL_OK)
;;;174      		{
;;;175        		/* Start Error */
;;;176        		//Error_Handler();
;;;177        		return SMP_ERROR_NOT_FOUND;
;;;178      		}	
;;;179    		/*##-4- Activate CAN RX notification #######################################*/
;;;180    		if (HAL_CAN_ActivateNotification(&smp_can1_handle,
;;;181    				(CAN_IT_RX_FIFO0_MSG_PENDING |
;;;182    				  CAN_IT_TX_MAILBOX_EMPTY
;;;183    				)) != HAL_OK)
;;;184    		{
;;;185    			/* Notification Error */
;;;186    			//Error_Handler();
;;;187    			return SMP_ERROR_NOT_FOUND;
;;;188    		}  
;;;189    		can1_evt_cb = smp_can_event_handler;
;;;190    		// Configure buffer RX buffer.
;;;191    		can_fifo_init(&can1_rx_fifo, p_can->buffers.rx_buf, p_can->buffers.rx_buf_size);
;;;192    		// Configure buffer TX buffer.
;;;193    		can_fifo_init(&can1_tx_fifo, p_can->buffers.tx_buf, p_can->buffers.tx_buf_size);
;;;194    
;;;195    	 }else{
;;;196    		return SMP_ERROR_NOT_SUPPORTED;
000032  4658              MOV      r0,r11
                  |L14.52|
;;;197    	 }		
;;;198    	 return SMP_SUCCESS;
;;;199    }
000034  b00b              ADD      sp,sp,#0x2c
000036  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.58|
00003a  4847              LDR      r0,|L14.344|
00003c  f8dfc114          LDR      r12,|L14.340|
000040  f8c0c000          STR      r12,[r0,#0]           ;80  ; smp_can0_handle
000044  7606              STRB     r6,[r0,#0x18]         ;82
000046  7646              STRB     r6,[r0,#0x19]         ;83
000048  7686              STRB     r6,[r0,#0x1a]         ;84
00004a  76c6              STRB     r6,[r0,#0x1b]         ;85
00004c  7706              STRB     r6,[r0,#0x1c]         ;86
00004e  7747              STRB     r7,[r0,#0x1d]         ;87
000050  6086              STR      r6,[r0,#8]            ;88  ; smp_can0_handle
000052  60c6              STR      r6,[r0,#0xc]          ;89  ; smp_can0_handle
000054  6101              STR      r1,[r0,#0x10]         ;90  ; smp_can0_handle
000056  6142              STR      r2,[r0,#0x14]         ;91  ; smp_can0_handle
000058  6043              STR      r3,[r0,#4]            ;92  ; smp_can0_handle
00005a  f7fffffe          BL       HAL_CAN_Init
00005e  b108              CBZ      r0,|L14.100|
000060  4650              MOV      r0,r10                ;97
000062  e7e7              B        |L14.52|
                  |L14.100|
000064  9606              STR      r6,[sp,#0x18]         ;101
000066  9607              STR      r6,[sp,#0x1c]         ;102
000068  9708              STR      r7,[sp,#0x20]         ;103
00006a  9601              STR      r6,[sp,#4]            ;104
00006c  9602              STR      r6,[sp,#8]            ;105
00006e  9603              STR      r6,[sp,#0xc]          ;106
000070  9604              STR      r6,[sp,#0x10]         ;107
000072  9605              STR      r6,[sp,#0x14]         ;108
000074  9709              STR      r7,[sp,#0x24]         ;109
000076  f8cd8028          STR      r8,[sp,#0x28]         ;110
00007a  a901              ADD      r1,sp,#4              ;112
00007c  4836              LDR      r0,|L14.344|
00007e  f7fffffe          BL       HAL_CAN_ConfigFilter
000082  b108              CBZ      r0,|L14.136|
000084  4658              MOV      r0,r11                ;115
000086  e7d5              B        |L14.52|
                  |L14.136|
000088  4833              LDR      r0,|L14.344|
00008a  f7fffffe          BL       HAL_CAN_Start
00008e  b110              CBZ      r0,|L14.150|
000090  f06f0002          MVN      r0,#2                 ;123
000094  e7ce              B        |L14.52|
                  |L14.150|
000096  f8c95000          STR      r5,[r9,#0]            ;126  ; can0_evt_cb
00009a  89a0              LDRH     r0,[r4,#0xc]          ;128
00009c  68a1              LDR      r1,[r4,#8]            ;128
00009e  b282              UXTH     r2,r0                 ;128
0000a0  482d              LDR      r0,|L14.344|
0000a2  3028              ADDS     r0,r0,#0x28           ;128
0000a4  f7fffffe          BL       can_fifo_init
0000a8  8aa0              LDRH     r0,[r4,#0x14]         ;130
0000aa  6921              LDR      r1,[r4,#0x10]         ;130
0000ac  b282              UXTH     r2,r0                 ;130
0000ae  482a              LDR      r0,|L14.344|
0000b0  3038              ADDS     r0,r0,#0x38           ;130
0000b2  f7fffffe          BL       can_fifo_init
0000b6  e048              B        |L14.330|
                  |L14.184|
0000b8  4827              LDR      r0,|L14.344|
0000ba  f8dfc0a0          LDR      r12,|L14.348|
0000be  3048              ADDS     r0,r0,#0x48           ;134
0000c0  f8c0c000          STR      r12,[r0,#0]           ;134  ; smp_can1_handle
0000c4  7606              STRB     r6,[r0,#0x18]         ;136
0000c6  7646              STRB     r6,[r0,#0x19]         ;137
0000c8  7686              STRB     r6,[r0,#0x1a]         ;138
0000ca  76c6              STRB     r6,[r0,#0x1b]         ;139
0000cc  7706              STRB     r6,[r0,#0x1c]         ;140
0000ce  7747              STRB     r7,[r0,#0x1d]         ;141
0000d0  6086              STR      r6,[r0,#8]            ;142  ; smp_can1_handle
0000d2  60c6              STR      r6,[r0,#0xc]          ;143  ; smp_can1_handle
0000d4  6101              STR      r1,[r0,#0x10]         ;144  ; smp_can1_handle
0000d6  6142              STR      r2,[r0,#0x14]         ;145  ; smp_can1_handle
0000d8  6043              STR      r3,[r0,#4]            ;146  ; smp_can1_handle
0000da  f7fffffe          BL       HAL_CAN_Init
0000de  b108              CBZ      r0,|L14.228|
0000e0  4650              MOV      r0,r10                ;151
0000e2  e7a7              B        |L14.52|
                  |L14.228|
0000e4  f8cd8018          STR      r8,[sp,#0x18]         ;155
0000e8  9607              STR      r6,[sp,#0x1c]         ;156
0000ea  9708              STR      r7,[sp,#0x20]         ;157
0000ec  9601              STR      r6,[sp,#4]            ;158
0000ee  9602              STR      r6,[sp,#8]            ;159
0000f0  9603              STR      r6,[sp,#0xc]          ;160
0000f2  9604              STR      r6,[sp,#0x10]         ;161
0000f4  9605              STR      r6,[sp,#0x14]         ;162
0000f6  9709              STR      r7,[sp,#0x24]         ;163
0000f8  f8cd8028          STR      r8,[sp,#0x28]         ;164
0000fc  4816              LDR      r0,|L14.344|
0000fe  a901              ADD      r1,sp,#4              ;166
000100  3048              ADDS     r0,r0,#0x48           ;166
000102  f7fffffe          BL       HAL_CAN_ConfigFilter
000106  b108              CBZ      r0,|L14.268|
000108  4650              MOV      r0,r10                ;169
00010a  e793              B        |L14.52|
                  |L14.268|
00010c  4812              LDR      r0,|L14.344|
00010e  3048              ADDS     r0,r0,#0x48           ;173
000110  f7fffffe          BL       HAL_CAN_Start
000114  b108              CBZ      r0,|L14.282|
000116  4650              MOV      r0,r10                ;177
000118  e78c              B        |L14.52|
                  |L14.282|
00011a  480f              LDR      r0,|L14.344|
00011c  2103              MOVS     r1,#3                 ;180
00011e  3048              ADDS     r0,r0,#0x48           ;180
000120  f7fffffe          BL       HAL_CAN_ActivateNotification
000124  b108              CBZ      r0,|L14.298|
000126  4650              MOV      r0,r10                ;187
000128  e784              B        |L14.52|
                  |L14.298|
00012a  f8c95004          STR      r5,[r9,#4]            ;189  ; can1_evt_cb
00012e  89a0              LDRH     r0,[r4,#0xc]          ;191
000130  68a1              LDR      r1,[r4,#8]            ;191
000132  b282              UXTH     r2,r0                 ;191
000134  4808              LDR      r0,|L14.344|
000136  3070              ADDS     r0,r0,#0x70           ;191
000138  f7fffffe          BL       can_fifo_init
00013c  8aa0              LDRH     r0,[r4,#0x14]         ;193
00013e  6921              LDR      r1,[r4,#0x10]         ;193
000140  b282              UXTH     r2,r0                 ;193
000142  4805              LDR      r0,|L14.344|
000144  3080              ADDS     r0,r0,#0x80           ;193
000146  f7fffffe          BL       can_fifo_init
                  |L14.330|
00014a  2000              MOVS     r0,#0                 ;198
00014c  e772              B        |L14.52|
;;;200    
                          ENDP

00014e  0000              DCW      0x0000
                  |L14.336|
                          DCD      ||.data||
                  |L14.340|
                          DCD      0x40006400
                  |L14.344|
                          DCD      ||.bss||
                  |L14.348|
                          DCD      0x40006800

                          AREA ||i.smp_can_put||, CODE, READONLY, ALIGN=2

                  smp_can_put PROC
;;;224    
;;;225    int8_t smp_can_put(smp_can_t *p_can, smp_can_package_t *pCanDat)
000000  b500              PUSH     {lr}
;;;226    {
000002  b08b              SUB      sp,sp,#0x2c
;;;227    	uint16_t size = 0, i =0;
;;;228    	uint32_t              TxMailbox;
;;;229    	CAN_TxHeaderTypeDef   TxHeader;
;;;230    	smp_can_package_t		CanPkg;
;;;231    	uint8_t	buf[10];
;;;232    
;;;233    	
;;;234    	if(p_can->num == __CAN0){
000004  7800              LDRB     r0,[r0,#0]
000006  2800              CMP      r0,#0
000008  d033              BEQ      |L15.114|
;;;235    		#if	0
;;;236            if (smp_fifo_push(&uart0_tx_fifo, byte) == SMP_SUCCESS){
;;;237            // The new byte has been added to FIFO. It will be picked up from there
;;;238            // (in 'uart_event_handler') when all preceding bytes are transmitted.
;;;239            // But if UART is not transmitting anything at the moment, we must start
;;;240            // a new transmission here.
;;;241                if((smp_uart0_handle.gState == HAL_UART_STATE_READY)||(smp_uart0_handle.gState == HAL_UART_STATE_BUSY_RX)){
;;;242    				        if(smp_fifo_get_size(&uart0_tx_fifo,&size)==SMP_SUCCESS){
;;;243                        if(size>UART_TX_BUFFER_SIZE)	size = UART_TX_BUFFER_SIZE;
;;;244    						        // This operation should be almost always successful, since we've
;;;245    						        // just added a byte to FIFO, but if some bigger delay occurred
;;;246    						        // (some heavy interrupt handler routine has been executed) since
;;;247    						       // that time, FIFO might be empty already.
;;;248    						        for(i=0;i<size;i++){	
;;;249    							          smp_fifo_pop(&uart0_tx_fifo, (char *)&uart0_tx_buffer[i]);
;;;250    						        }
;;;251    						        HAL_UART_Transmit_DMA(&smp_uart0_handle, &uart0_tx_buffer[0], size);
;;;252    			         }
;;;253               }
;;;254    	     }
;;;255    	     #endif
;;;256    	}else if(p_can->num == __CAN1){		
00000a  2801              CMP      r0,#1
00000c  d003              BEQ      |L15.22|
;;;257            smp_can_fifo_push(&can1_tx_fifo, pCanDat);// == SMP_SUCCESS)
;;;258    //			 if (smp_can_fifo_push(&can1_tx_fifo, pCanDat) == SMP_SUCCESS)
;;;259    		if(1)
;;;260            {
;;;261            	//if()	//check empty mailbox
;;;262            	if(HAL_CAN_GetTxMailboxesFreeLevel(&smp_can1_handle) != 0)
;;;263            	{
;;;264    //				GPIOD->ODR |= GPIO_PIN_13;
;;;265           			if(smp_can_fifo_pop(&can1_tx_fifo, &CanPkg) == SMP_SUCCESS)
;;;266           			{
;;;267           				if(CanPkg.id & CAN_STD_MASK)
;;;268           				{
;;;269    						TxHeader.StdId = (CanPkg.id & CAN_ID_MASK);
;;;270    						TxHeader.IDE = CAN_ID_STD;
;;;271    					}
;;;272    					else
;;;273    					{
;;;274    						TxHeader.ExtId = (CanPkg.id & CAN_ID_MASK);
;;;275    						TxHeader.IDE = CAN_ID_EXT;
;;;276    					}
;;;277    					if(CanPkg.id & CAN_RTR_MASK)
;;;278    						TxHeader.RTR = CAN_RTR_REMOTE;
;;;279    					else
;;;280    						TxHeader.RTR = CAN_RTR_DATA;
;;;281      					TxHeader.DLC = CanPkg.dlc;
;;;282    					TxHeader.TransmitGlobalTime = DISABLE;
;;;283    					HAL_CAN_AddTxMessage(&smp_can1_handle, &TxHeader, CanPkg.dat, &TxMailbox);
;;;284          			}
;;;285    //				GPIOD->ODR &= ~GPIO_PIN_13;
;;;286    
;;;287      			}	
;;;288    	   	}
;;;289    	}else{
;;;290    		return SMP_ERROR_FULL;
00000e  f06f0012          MVN      r0,#0x12
                  |L15.18|
;;;291    	}
;;;292    	
;;;293    	return SMP_SUCCESS;
;;;294    }
000012  b00b              ADD      sp,sp,#0x2c
000014  bd00              POP      {pc}
                  |L15.22|
000016  4818              LDR      r0,|L15.120|
000018  f7fffffe          BL       smp_can_fifo_push
00001c  4816              LDR      r0,|L15.120|
00001e  3838              SUBS     r0,r0,#0x38           ;262
000020  f7fffffe          BL       HAL_CAN_GetTxMailboxesFreeLevel
000024  b328              CBZ      r0,|L15.114|
000026  4669              MOV      r1,sp                 ;265
000028  4813              LDR      r0,|L15.120|
00002a  f7fffffe          BL       smp_can_fifo_pop
00002e  bb00              CBNZ     r0,|L15.114|
000030  9800              LDR      r0,[sp,#0]            ;267
000032  2100              MOVS     r1,#0                 ;267
000034  2800              CMP      r0,#0                 ;267
000036  da04              BGE      |L15.66|
000038  f0204260          BIC      r2,r0,#0xe0000000     ;269
00003c  9204              STR      r2,[sp,#0x10]         ;269
00003e  9106              STR      r1,[sp,#0x18]         ;270
000040  e004              B        |L15.76|
                  |L15.66|
000042  f0204260          BIC      r2,r0,#0xe0000000     ;274
000046  9205              STR      r2,[sp,#0x14]         ;274
000048  2204              MOVS     r2,#4                 ;275
00004a  9206              STR      r2,[sp,#0x18]         ;275
                  |L15.76|
00004c  0040              LSLS     r0,r0,#1              ;277
00004e  d502              BPL      |L15.86|
000050  2002              MOVS     r0,#2                 ;278
000052  9007              STR      r0,[sp,#0x1c]         ;278
000054  e000              B        |L15.88|
                  |L15.86|
000056  9107              STR      r1,[sp,#0x1c]         ;280
                  |L15.88|
000058  f89d0004          LDRB     r0,[sp,#4]            ;281
00005c  9008              STR      r0,[sp,#0x20]         ;281
00005e  f88d1024          STRB     r1,[sp,#0x24]         ;282
000062  4805              LDR      r0,|L15.120|
000064  ab0a              ADD      r3,sp,#0x28           ;283
000066  f10d0205          ADD      r2,sp,#5              ;283
00006a  a904              ADD      r1,sp,#0x10           ;283
00006c  3838              SUBS     r0,r0,#0x38           ;283
00006e  f7fffffe          BL       HAL_CAN_AddTxMessage
                  |L15.114|
000072  2000              MOVS     r0,#0                 ;293
000074  e7cd              B        |L15.18|
;;;295    
                          ENDP

000076  0000              DCW      0x0000
                  |L15.120|
                          DCD      ||.bss||+0x80

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  smp_can0_handle
                          %        40
                  can0_rx_fifo
                          %        16
                  can0_tx_fifo
                          %        16
                  smp_can1_handle
                          %        40
                  can1_rx_fifo
                          %        16
                  can1_tx_fifo
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  can0_evt_cb
                          DCD      0x00000000
                  can1_evt_cb
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\SMP\\smp_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_smp_can_c_1c6e7ba1____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___9_smp_can_c_1c6e7ba1____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_smp_can_c_1c6e7ba1____REVSH|
#line 507
|__asm___9_smp_can_c_1c6e7ba1____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_smp_can_c_1c6e7ba1____RRX|
#line 694
|__asm___9_smp_can_c_1c6e7ba1____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
