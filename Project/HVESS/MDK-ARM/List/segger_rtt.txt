; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\segger_rtt.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\segger_rtt.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\RTT\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_AllocDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocDownBuffer PROC
;;;1549   */
;;;1550   int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1551     int BufferIndex;
;;;1552     volatile SEGGER_RTT_CB* pRTTCB;
;;;1553   
;;;1554     INIT();
00000c  4816              LDR      r0,|L1.104|
00000e  7800              LDRB     r0,[r0,#0]
000010  2800              CMP      r0,#0
000012  d101              BNE      |L1.24|
000014  f7fffffe          BL       _DoInit
                  |L1.24|
;;;1555     SEGGER_RTT_LOCK();
000018  f3ef8111          MRS      r1,BASEPRI
00001c  2020              MOVS     r0,#0x20
00001e  f3808811          MSR      BASEPRI,r0
;;;1556     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000022  4c11              LDR      r4,|L1.104|
;;;1557     BufferIndex = 0;
000024  2000              MOVS     r0,#0
                  |L1.38|
;;;1558     do {
;;;1559       if (pRTTCB->aDown[BufferIndex].pBuffer == NULL) {
000026  eb000240          ADD      r2,r0,r0,LSL #1
00002a  eb0402c2          ADD      r2,r4,r2,LSL #3
00002e  6e52              LDR      r2,[r2,#0x64]
000030  b11a              CBZ      r2,|L1.58|
;;;1560         break;
;;;1561       }
;;;1562       BufferIndex++;
000032  1c40              ADDS     r0,r0,#1
;;;1563     } while (BufferIndex < pRTTCB->MaxNumDownBuffers);
000034  6962              LDR      r2,[r4,#0x14]
000036  4282              CMP      r2,r0
000038  dcf5              BGT      |L1.38|
                  |L1.58|
;;;1564     if (BufferIndex < pRTTCB->MaxNumDownBuffers) {
00003a  6962              LDR      r2,[r4,#0x14]
00003c  4282              CMP      r2,r0
00003e  dd0c              BLE      |L1.90|
;;;1565       pRTTCB->aDown[BufferIndex].sName        = sName;
000040  eb000240          ADD      r2,r0,r0,LSL #1
000044  eb0404c2          ADD      r4,r4,r2,LSL #3
000048  f8c48060          STR      r8,[r4,#0x60]
;;;1566       pRTTCB->aDown[BufferIndex].pBuffer      = (char*)pBuffer;
00004c  6665              STR      r5,[r4,#0x64]
;;;1567       pRTTCB->aDown[BufferIndex].SizeOfBuffer = BufferSize;
00004e  66a6              STR      r6,[r4,#0x68]
;;;1568       pRTTCB->aDown[BufferIndex].RdOff        = 0u;
000050  2200              MOVS     r2,#0
000052  6722              STR      r2,[r4,#0x70]
;;;1569       pRTTCB->aDown[BufferIndex].WrOff        = 0u;
000054  66e2              STR      r2,[r4,#0x6c]
;;;1570       pRTTCB->aDown[BufferIndex].Flags        = Flags;
000056  6767              STR      r7,[r4,#0x74]
000058  e001              B        |L1.94|
                  |L1.90|
;;;1571       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1572     } else {
;;;1573       BufferIndex = -1;
00005a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.94|
;;;1574     }
;;;1575     SEGGER_RTT_UNLOCK();
00005e  b2c9              UXTB     r1,r1
000060  f3818811          MSR      BASEPRI,r1
;;;1576     return BufferIndex;
;;;1577   }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;1578   
                          ENDP

                  |L1.104|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_AllocUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocUpBuffer PROC
;;;1597   */
;;;1598   int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1599     int BufferIndex;
;;;1600     volatile SEGGER_RTT_CB* pRTTCB;
;;;1601   
;;;1602     INIT();
00000c  4816              LDR      r0,|L2.104|
00000e  7800              LDRB     r0,[r0,#0]
000010  2800              CMP      r0,#0
000012  d101              BNE      |L2.24|
000014  f7fffffe          BL       _DoInit
                  |L2.24|
;;;1603     SEGGER_RTT_LOCK();
000018  f3ef8111          MRS      r1,BASEPRI
00001c  2020              MOVS     r0,#0x20
00001e  f3808811          MSR      BASEPRI,r0
;;;1604     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000022  4c11              LDR      r4,|L2.104|
;;;1605     BufferIndex = 0;
000024  2000              MOVS     r0,#0
                  |L2.38|
;;;1606     do {
;;;1607       if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
000026  eb000240          ADD      r2,r0,r0,LSL #1
00002a  eb0402c2          ADD      r2,r4,r2,LSL #3
00002e  69d2              LDR      r2,[r2,#0x1c]
000030  b11a              CBZ      r2,|L2.58|
;;;1608         break;
;;;1609       }
;;;1610       BufferIndex++;
000032  1c40              ADDS     r0,r0,#1
;;;1611     } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
000034  6922              LDR      r2,[r4,#0x10]
000036  4282              CMP      r2,r0
000038  dcf5              BGT      |L2.38|
                  |L2.58|
;;;1612     if (BufferIndex < pRTTCB->MaxNumUpBuffers) {
00003a  6922              LDR      r2,[r4,#0x10]
00003c  4282              CMP      r2,r0
00003e  dd0c              BLE      |L2.90|
;;;1613       pRTTCB->aUp[BufferIndex].sName        = sName;
000040  eb000240          ADD      r2,r0,r0,LSL #1
000044  eb0404c2          ADD      r4,r4,r2,LSL #3
000048  f8c48018          STR      r8,[r4,#0x18]
;;;1614       pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
00004c  61e5              STR      r5,[r4,#0x1c]
;;;1615       pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
00004e  6226              STR      r6,[r4,#0x20]
;;;1616       pRTTCB->aUp[BufferIndex].RdOff        = 0u;
000050  2200              MOVS     r2,#0
000052  62a2              STR      r2,[r4,#0x28]
;;;1617       pRTTCB->aUp[BufferIndex].WrOff        = 0u;
000054  6262              STR      r2,[r4,#0x24]
;;;1618       pRTTCB->aUp[BufferIndex].Flags        = Flags;
000056  62e7              STR      r7,[r4,#0x2c]
000058  e001              B        |L2.94|
                  |L2.90|
;;;1619       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1620     } else {
;;;1621       BufferIndex = -1;
00005a  f04f30ff          MOV      r0,#0xffffffff
                  |L2.94|
;;;1622     }
;;;1623     SEGGER_RTT_UNLOCK();
00005e  b2c9              UXTB     r1,r1
000060  f3818811          MSR      BASEPRI,r1
;;;1624     return BufferIndex;
;;;1625   }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;1626   
                          ENDP

                  |L2.104|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;1702   */
;;;1703   int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  f8dd9020          LDR      r9,[sp,#0x20]
00000a  460e              MOV      r6,r1
00000c  4617              MOV      r7,r2
00000e  4698              MOV      r8,r3
;;;1704     int r;
;;;1705     volatile SEGGER_RTT_CB* pRTTCB;
;;;1706     volatile SEGGER_RTT_BUFFER_DOWN* pDown;
;;;1707   
;;;1708     INIT();
000010  4812              LDR      r0,|L3.92|
000012  7800              LDRB     r0,[r0,#0]
000014  2800              CMP      r0,#0
000016  d101              BNE      |L3.28|
000018  f7fffffe          BL       _DoInit
                  |L3.28|
;;;1709     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
00001c  490f              LDR      r1,|L3.92|
;;;1710     if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
00001e  2d03              CMP      r5,#3
000020  d219              BCS      |L3.86|
;;;1711       SEGGER_RTT_LOCK();
000022  f3ef8011          MRS      r0,BASEPRI
000026  2220              MOVS     r2,#0x20
000028  f3828811          MSR      BASEPRI,r2
;;;1712       pDown = &pRTTCB->aDown[BufferIndex];
00002c  eb050245          ADD      r2,r5,r5,LSL #1
000030  eb0104c2          ADD      r4,r1,r2,LSL #3
000034  3460              ADDS     r4,r4,#0x60
;;;1713       if (BufferIndex) {
000036  b135              CBZ      r5,|L3.70|
;;;1714         pDown->sName        = sName;
000038  6026              STR      r6,[r4,#0]
;;;1715         pDown->pBuffer      = (char*)pBuffer;
00003a  6067              STR      r7,[r4,#4]
;;;1716         pDown->SizeOfBuffer = BufferSize;
00003c  f8c48008          STR      r8,[r4,#8]
;;;1717         pDown->RdOff        = 0u;
000040  2100              MOVS     r1,#0
000042  6121              STR      r1,[r4,#0x10]
;;;1718         pDown->WrOff        = 0u;
000044  60e1              STR      r1,[r4,#0xc]
                  |L3.70|
;;;1719       }
;;;1720       pDown->Flags          = Flags;
000046  f8c49014          STR      r9,[r4,#0x14]
;;;1721       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1722       SEGGER_RTT_UNLOCK();
00004a  b2c0              UXTB     r0,r0
00004c  f3808811          MSR      BASEPRI,r0
;;;1723       r =  0;
000050  2000              MOVS     r0,#0
                  |L3.82|
;;;1724     } else {
;;;1725       r = -1;
;;;1726     }
;;;1727     return r;
;;;1728   }
000052  e8bd87f0          POP      {r4-r10,pc}
                  |L3.86|
000056  f04f30ff          MOV      r0,#0xffffffff        ;1725
00005a  e7fa              B        |L3.82|
;;;1729   
                          ENDP

                  |L3.92|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;1651   */
;;;1652   int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  f8dd9020          LDR      r9,[sp,#0x20]
00000a  460e              MOV      r6,r1
00000c  4617              MOV      r7,r2
00000e  4698              MOV      r8,r3
;;;1653     int r;
;;;1654     volatile SEGGER_RTT_CB* pRTTCB;
;;;1655     volatile SEGGER_RTT_BUFFER_UP* pUp;
;;;1656   
;;;1657     INIT();
000010  4812              LDR      r0,|L4.92|
000012  7800              LDRB     r0,[r0,#0]
000014  2800              CMP      r0,#0
000016  d101              BNE      |L4.28|
000018  f7fffffe          BL       _DoInit
                  |L4.28|
;;;1658     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
00001c  490f              LDR      r1,|L4.92|
;;;1659     if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
00001e  2d03              CMP      r5,#3
000020  d219              BCS      |L4.86|
;;;1660       SEGGER_RTT_LOCK();
000022  f3ef8011          MRS      r0,BASEPRI
000026  2220              MOVS     r2,#0x20
000028  f3828811          MSR      BASEPRI,r2
;;;1661       pUp = &pRTTCB->aUp[BufferIndex];
00002c  eb050245          ADD      r2,r5,r5,LSL #1
000030  eb0104c2          ADD      r4,r1,r2,LSL #3
000034  3418              ADDS     r4,r4,#0x18
;;;1662       if (BufferIndex) {
000036  b135              CBZ      r5,|L4.70|
;;;1663         pUp->sName        = sName;
000038  6026              STR      r6,[r4,#0]
;;;1664         pUp->pBuffer      = (char*)pBuffer;
00003a  6067              STR      r7,[r4,#4]
;;;1665         pUp->SizeOfBuffer = BufferSize;
00003c  f8c48008          STR      r8,[r4,#8]
;;;1666         pUp->RdOff        = 0u;
000040  2100              MOVS     r1,#0
000042  6121              STR      r1,[r4,#0x10]
;;;1667         pUp->WrOff        = 0u;
000044  60e1              STR      r1,[r4,#0xc]
                  |L4.70|
;;;1668       }
;;;1669       pUp->Flags          = Flags;
000046  f8c49014          STR      r9,[r4,#0x14]
;;;1670       SEGGER_RTT_UNLOCK();
00004a  b2c0              UXTB     r0,r0
00004c  f3808811          MSR      BASEPRI,r0
;;;1671       r =  0;
000050  2000              MOVS     r0,#0
                  |L4.82|
;;;1672     } else {
;;;1673       r = -1;
;;;1674     }
;;;1675     return r;
;;;1676   }
000052  e8bd87f0          POP      {r4-r10,pc}
                  |L4.86|
000056  f04f30ff          MOV      r0,#0xffffffff        ;1673
00005a  e7fa              B        |L4.82|
;;;1677   
                          ENDP

                  |L4.92|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_GetAvailWriteSpace||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_GetAvailWriteSpace PROC
;;;2036   */
;;;2037   unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex) {
000000  4903              LDR      r1,|L5.16|
;;;2038     SEGGER_RTT_BUFFER_UP* pRing;
;;;2039   
;;;2040     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000002  eb000040          ADD      r0,r0,r0,LSL #1
000006  eb0100c0          ADD      r0,r1,r0,LSL #3
00000a  3018              ADDS     r0,r0,#0x18
;;;2041     return _GetAvailWriteSpace(pRing);
00000c  f7ffbffe          B.W      _GetAvailWriteSpace
;;;2042   }
;;;2043   
                          ENDP

                  |L5.16|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_GetBytesInBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_GetBytesInBuffer PROC
;;;2057   */
;;;2058   unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
000000  4907              LDR      r1,|L6.32|
;;;2059     unsigned RdOff;
;;;2060     unsigned WrOff;
;;;2061     unsigned r;
;;;2062     volatile SEGGER_RTT_CB* pRTTCB;
;;;2063     //
;;;2064     // Avoid warnings regarding volatile access order.  It's not a problem
;;;2065     // in this case, but dampen compiler enthusiasm.
;;;2066     //
;;;2067     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
;;;2068     RdOff = pRTTCB->aUp[BufferIndex].RdOff;
000002  eb000040          ADD      r0,r0,r0,LSL #1
000006  eb0102c0          ADD      r2,r1,r0,LSL #3
00000a  6a90              LDR      r0,[r2,#0x28]
;;;2069     WrOff = pRTTCB->aUp[BufferIndex].WrOff;
00000c  6a51              LDR      r1,[r2,#0x24]
;;;2070     if (RdOff <= WrOff) {
00000e  4288              CMP      r0,r1
000010  d801              BHI      |L6.22|
;;;2071       r = WrOff - RdOff;
000012  1a08              SUBS     r0,r1,r0
;;;2072     } else {
;;;2073       r = pRTTCB->aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
;;;2074     }
;;;2075     return r;
;;;2076   }
000014  4770              BX       lr
                  |L6.22|
000016  6a12              LDR      r2,[r2,#0x20]         ;2073
000018  1a08              SUBS     r0,r1,r0              ;2073
00001a  1a10              SUBS     r0,r2,r0              ;2073
00001c  4770              BX       lr
;;;2077   
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;1421   */
;;;1422   int SEGGER_RTT_GetKey(void) {
000000  b508              PUSH     {r3,lr}
;;;1423     char c;
;;;1424     int r;
;;;1425   
;;;1426     r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
;;;1427     if (r == 1) {
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L7.22|
;;;1428       r = (int)(unsigned char)c;
;;;1429     } else {
;;;1430       r = -1;
000010  f04f30ff          MOV      r0,#0xffffffff
;;;1431     }
;;;1432     return r;
;;;1433   }
000014  bd08              POP      {r3,pc}
                  |L7.22|
000016  f89d0000          LDRB     r0,[sp,#0]            ;1428
00001a  bd08              POP      {r3,pc}
;;;1434   
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;1500   */
;;;1501   unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  4904              LDR      r1,|L8.20|
;;;1502     SEGGER_RTT_BUFFER_DOWN* pRing;
;;;1503     unsigned                v;
;;;1504   
;;;1505     pRing = (SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000002  eb000040          ADD      r0,r0,r0,LSL #1
000006  eb0100c0          ADD      r0,r1,r0,LSL #3
;;;1506     v = pRing->WrOff;
00000a  6ec1              LDR      r1,[r0,#0x6c]
;;;1507     return v - pRing->RdOff;
00000c  6f00              LDR      r0,[r0,#0x70]
00000e  1a08              SUBS     r0,r1,r0
;;;1508   }
000010  4770              BX       lr
;;;1509   
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_HasDataUp||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasDataUp PROC
;;;1521   */
;;;1522   unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
000000  4904              LDR      r1,|L9.20|
;;;1523     SEGGER_RTT_BUFFER_UP* pRing;
;;;1524     unsigned                v;
;;;1525   
;;;1526     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000002  eb000040          ADD      r0,r0,r0,LSL #1
000006  eb0100c0          ADD      r0,r1,r0,LSL #3
;;;1527     v = pRing->RdOff;
00000a  6a81              LDR      r1,[r0,#0x28]
;;;1528     return pRing->WrOff - v;
00000c  6a40              LDR      r0,[r0,#0x24]
00000e  1a40              SUBS     r0,r0,r1
;;;1529   }
000010  4770              BX       lr
;;;1530   
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;1472   */
;;;1473   int SEGGER_RTT_HasKey(void) {
000000  b510              PUSH     {r4,lr}
;;;1474     SEGGER_RTT_BUFFER_DOWN* pRing;
;;;1475     unsigned RdOff;
;;;1476     int r;
;;;1477   
;;;1478     INIT();
000002  4807              LDR      r0,|L10.32|
000004  7800              LDRB     r0,[r0,#0]
000006  2800              CMP      r0,#0
000008  d101              BNE      |L10.14|
00000a  f7fffffe          BL       _DoInit
                  |L10.14|
;;;1479     pRing = (SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
00000e  4804              LDR      r0,|L10.32|
;;;1480     RdOff = pRing->RdOff;
000010  6f01              LDR      r1,[r0,#0x70]
;;;1481     if (RdOff != pRing->WrOff) {
000012  6ec0              LDR      r0,[r0,#0x6c]
000014  4288              CMP      r0,r1
000016  d001              BEQ      |L10.28|
;;;1482       r = 1;
000018  2001              MOVS     r0,#1
;;;1483     } else {
;;;1484       r = 0;
;;;1485     }
;;;1486     return r;
;;;1487   }
00001a  bd10              POP      {r4,pc}
                  |L10.28|
00001c  2000              MOVS     r0,#0                 ;1484
00001e  bd10              POP      {r4,pc}
;;;1488   
                          ENDP

                  |L10.32|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Init PROC
;;;1878   */
;;;1879   void SEGGER_RTT_Init (void) {
000000  f7ffbffe          B.W      _DoInit
;;;1880     _DoInit();
;;;1881   }
;;;1882   
                          ENDP


                          AREA ||i.SEGGER_RTT_PutChar||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutChar PROC
;;;1358   
;;;1359   unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1360     SEGGER_RTT_BUFFER_UP* pRing;
;;;1361     unsigned              WrOff;
;;;1362     unsigned              Status;
;;;1363     volatile char*        pDst;
;;;1364     //
;;;1365     // Prepare
;;;1366     //
;;;1367     INIT();
000006  4916              LDR      r1,|L12.96|
000008  7808              LDRB     r0,[r1,#0]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L12.18|
00000e  f7fffffe          BL       _DoInit
                  |L12.18|
;;;1368     SEGGER_RTT_LOCK();
000012  f3ef8111          MRS      r1,BASEPRI
000016  2020              MOVS     r0,#0x20
000018  f3808811          MSR      BASEPRI,r0
;;;1369     //
;;;1370     // Get "to-host" ring buffer.
;;;1371     //
;;;1372     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
00001c  4a10              LDR      r2,|L12.96|
00001e  eb040044          ADD      r0,r4,r4,LSL #1
000022  eb0200c0          ADD      r0,r2,r0,LSL #3
000026  3018              ADDS     r0,r0,#0x18
;;;1373     //
;;;1374     // Get write position and handle wrap-around if necessary
;;;1375     //
;;;1376     WrOff = pRing->WrOff + 1;
000028  68c2              LDR      r2,[r0,#0xc]
00002a  4614              MOV      r4,r2
00002c  1c52              ADDS     r2,r2,#1
;;;1377     if (WrOff == pRing->SizeOfBuffer) {
00002e  6883              LDR      r3,[r0,#8]
000030  4293              CMP      r3,r2
000032  d100              BNE      |L12.54|
;;;1378       WrOff = 0;
000034  2200              MOVS     r2,#0
                  |L12.54|
;;;1379     }
;;;1380     //
;;;1381     // Wait for free space if mode is set to blocking
;;;1382     //
;;;1383     if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
000036  6943              LDR      r3,[r0,#0x14]
000038  2b02              CMP      r3,#2
00003a  d102              BNE      |L12.66|
                  |L12.60|
;;;1384       while (WrOff == pRing->RdOff) {
00003c  6903              LDR      r3,[r0,#0x10]
00003e  4293              CMP      r3,r2
000040  d0fc              BEQ      |L12.60|
                  |L12.66|
;;;1385         ;
;;;1386       }
;;;1387     }
;;;1388     //
;;;1389     // Output byte if free space is available
;;;1390     //
;;;1391     if (WrOff != pRing->RdOff) {
000042  6903              LDR      r3,[r0,#0x10]
000044  4293              CMP      r3,r2
000046  d005              BEQ      |L12.84|
;;;1392       pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
000048  6843              LDR      r3,[r0,#4]
00004a  4423              ADD      r3,r3,r4
;;;1393       *pDst = c;
00004c  701d              STRB     r5,[r3,#0]
;;;1394       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1395       pRing->WrOff = WrOff;
00004e  60c2              STR      r2,[r0,#0xc]
;;;1396       Status = 1;
000050  2001              MOVS     r0,#1
000052  e000              B        |L12.86|
                  |L12.84|
;;;1397     } else {
;;;1398       Status = 0;
000054  2000              MOVS     r0,#0
                  |L12.86|
;;;1399     }
;;;1400     //
;;;1401     // Finish up.
;;;1402     //
;;;1403     SEGGER_RTT_UNLOCK();
000056  b2c9              UXTB     r1,r1
000058  f3818811          MSR      BASEPRI,r1
;;;1404     return Status;
;;;1405   }
00005c  bd70              POP      {r4-r6,pc}
;;;1406   
                          ENDP

00005e  0000              DCW      0x0000
                  |L12.96|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_PutCharSkip||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkip PROC
;;;1299   
;;;1300   unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1301     SEGGER_RTT_BUFFER_UP* pRing;
;;;1302     unsigned              WrOff;
;;;1303     unsigned              Status;
;;;1304     volatile char*        pDst;
;;;1305     //
;;;1306     // Prepare
;;;1307     //
;;;1308     INIT();
000006  4913              LDR      r1,|L13.84|
000008  7808              LDRB     r0,[r1,#0]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L13.18|
00000e  f7fffffe          BL       _DoInit
                  |L13.18|
;;;1309     SEGGER_RTT_LOCK();
000012  f3ef8311          MRS      r3,BASEPRI
000016  2020              MOVS     r0,#0x20
000018  f3808811          MSR      BASEPRI,r0
;;;1310     //
;;;1311     // Get "to-host" ring buffer.
;;;1312     //
;;;1313     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
00001c  490d              LDR      r1,|L13.84|
00001e  eb040044          ADD      r0,r4,r4,LSL #1
000022  eb0100c0          ADD      r0,r1,r0,LSL #3
000026  3018              ADDS     r0,r0,#0x18
;;;1314     //
;;;1315     // Get write position and handle wrap-around if necessary
;;;1316     //
;;;1317     WrOff = pRing->WrOff + 1;
000028  68c2              LDR      r2,[r0,#0xc]
00002a  4611              MOV      r1,r2
00002c  1c52              ADDS     r2,r2,#1
;;;1318     if (WrOff == pRing->SizeOfBuffer) {
00002e  6884              LDR      r4,[r0,#8]
000030  4294              CMP      r4,r2
000032  d100              BNE      |L13.54|
;;;1319       WrOff = 0;
000034  2200              MOVS     r2,#0
                  |L13.54|
;;;1320     }
;;;1321     //
;;;1322     // Output byte if free space is available
;;;1323     //
;;;1324     if (WrOff != pRing->RdOff) {
000036  6904              LDR      r4,[r0,#0x10]
000038  4294              CMP      r4,r2
00003a  d005              BEQ      |L13.72|
;;;1325       pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
00003c  6844              LDR      r4,[r0,#4]
00003e  440c              ADD      r4,r4,r1
;;;1326       *pDst = c;
000040  7025              STRB     r5,[r4,#0]
;;;1327       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1328       pRing->WrOff = WrOff;
000042  60c2              STR      r2,[r0,#0xc]
;;;1329       Status = 1;
000044  2001              MOVS     r0,#1
000046  e000              B        |L13.74|
                  |L13.72|
;;;1330     } else {
;;;1331       Status = 0;
000048  2000              MOVS     r0,#0
                  |L13.74|
;;;1332     }
;;;1333     //
;;;1334     // Finish up.
;;;1335     //
;;;1336     SEGGER_RTT_UNLOCK();
00004a  b2d9              UXTB     r1,r3
00004c  f3818811          MSR      BASEPRI,r1
;;;1337     //
;;;1338     return Status;
;;;1339   }
000050  bd70              POP      {r4-r6,pc}
;;;1340   
                          ENDP

000052  0000              DCW      0x0000
                  |L13.84|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_PutCharSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkipNoLock PROC
;;;1249   
;;;1250   unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
000000  b510              PUSH     {r4,lr}
;;;1251     SEGGER_RTT_BUFFER_UP* pRing;
;;;1252     unsigned              WrOff;
;;;1253     unsigned              Status;
;;;1254     volatile char*        pDst;
;;;1255     //
;;;1256     // Get "to-host" ring buffer.
;;;1257     //
;;;1258     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000002  4a0c              LDR      r2,|L14.52|
000004  eb000040          ADD      r0,r0,r0,LSL #1
000008  eb0200c0          ADD      r0,r2,r0,LSL #3
00000c  3018              ADDS     r0,r0,#0x18
;;;1259     //
;;;1260     // Get write position and handle wrap-around if necessary
;;;1261     //
;;;1262     WrOff = pRing->WrOff + 1;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  4613              MOV      r3,r2
000012  1c52              ADDS     r2,r2,#1
;;;1263     if (WrOff == pRing->SizeOfBuffer) {
000014  6884              LDR      r4,[r0,#8]
000016  4294              CMP      r4,r2
000018  d100              BNE      |L14.28|
;;;1264       WrOff = 0;
00001a  2200              MOVS     r2,#0
                  |L14.28|
;;;1265     }
;;;1266     //
;;;1267     // Output byte if free space is available
;;;1268     //
;;;1269     if (WrOff != pRing->RdOff) {
00001c  6904              LDR      r4,[r0,#0x10]
00001e  4294              CMP      r4,r2
000020  d005              BEQ      |L14.46|
;;;1270       pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
000022  6844              LDR      r4,[r0,#4]
000024  4423              ADD      r3,r3,r4
;;;1271       *pDst = c;
000026  7019              STRB     r1,[r3,#0]
;;;1272       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1273       pRing->WrOff = WrOff;
000028  60c2              STR      r2,[r0,#0xc]
;;;1274       Status = 1;
00002a  2001              MOVS     r0,#1
;;;1275     } else {
;;;1276       Status = 0;
;;;1277     }
;;;1278     //
;;;1279     return Status;
;;;1280   }
00002c  bd10              POP      {r4,pc}
                  |L14.46|
00002e  2000              MOVS     r0,#0                 ;1276
000030  bd10              POP      {r4,pc}
;;;1281   
                          ENDP

000032  0000              DCW      0x0000
                  |L14.52|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;779    */
;;;780    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  b510              PUSH     {r4,lr}
;;;781      unsigned NumBytesRead;
;;;782    
;;;783      SEGGER_RTT_LOCK();
000002  f3ef8411          MRS      r4,BASEPRI
000006  2320              MOVS     r3,#0x20
000008  f3838811          MSR      BASEPRI,r3
;;;784      //
;;;785      // Call the non-locking read function
;;;786      //
;;;787      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
00000c  f7fffffe          BL       SEGGER_RTT_ReadNoLock
;;;788      //
;;;789      // Finish up.
;;;790      //
;;;791      SEGGER_RTT_UNLOCK();
000010  b2e1              UXTB     r1,r4
000012  f3818811          MSR      BASEPRI,r1
;;;792      //
;;;793      return NumBytesRead;
;;;794    }
000016  bd10              POP      {r4,pc}
;;;795    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;650    */
;;;651    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;652      unsigned                NumBytesRem;
;;;653      unsigned                NumBytesRead;
;;;654      unsigned                RdOff;
;;;655      unsigned                WrOff;
;;;656      unsigned char*          pBuffer;
;;;657      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;658      volatile char*          pSrc;
;;;659      //
;;;660      INIT();
00000a  4a1b              LDR      r2,|L16.120|
00000c  7811              LDRB     r1,[r2,#0]
00000e  2900              CMP      r1,#0
000010  d101              BNE      |L16.22|
000012  f7fffffe          BL       _DoInit
                  |L16.22|
;;;661      pRing = (SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000016  4918              LDR      r1,|L16.120|
000018  eb040044          ADD      r0,r4,r4,LSL #1
00001c  eb0105c0          ADD      r5,r1,r0,LSL #3
000020  3560              ADDS     r5,r5,#0x60
;;;662      pBuffer = (unsigned char*)pData;
;;;663      RdOff = pRing->RdOff;
000022  692c              LDR      r4,[r5,#0x10]
;;;664      WrOff = pRing->WrOff;
000024  f8d5900c          LDR      r9,[r5,#0xc]
;;;665      NumBytesRead = 0u;
000028  2700              MOVS     r7,#0
;;;666      //
;;;667      // Read from current read position to wrap-around of buffer, first
;;;668      //
;;;669      if (RdOff > WrOff) {
00002a  454c              CMP      r4,r9
00002c  d911              BLS      |L16.82|
;;;670        NumBytesRem = pRing->SizeOfBuffer - RdOff;
00002e  68a8              LDR      r0,[r5,#8]
000030  1b07              SUBS     r7,r0,r4
;;;671        NumBytesRem = MIN(NumBytesRem, BufferSize);
000032  42b7              CMP      r7,r6
000034  d300              BCC      |L16.56|
000036  4637              MOV      r7,r6
                  |L16.56|
;;;672        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
000038  6868              LDR      r0,[r5,#4]
00003a  1901              ADDS     r1,r0,r4
;;;673    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;674        NumBytesRead += NumBytesRem;
;;;675        BufferSize   -= NumBytesRem;
;;;676        RdOff        += NumBytesRem;
;;;677        while (NumBytesRem--) {
;;;678          *pBuffer++ = *pSrc++;
;;;679        };
;;;680    #else
;;;681        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
00003c  463a              MOV      r2,r7
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       __aeabi_memcpy
;;;682        NumBytesRead += NumBytesRem;
;;;683        pBuffer      += NumBytesRem;
000044  44b8              ADD      r8,r8,r7
;;;684        BufferSize   -= NumBytesRem;
000046  1bf6              SUBS     r6,r6,r7
;;;685        RdOff        += NumBytesRem;
000048  443c              ADD      r4,r4,r7
;;;686    #endif
;;;687        //
;;;688        // Handle wrap-around of buffer
;;;689        //
;;;690        if (RdOff == pRing->SizeOfBuffer) {
00004a  68a8              LDR      r0,[r5,#8]
00004c  42a0              CMP      r0,r4
00004e  d100              BNE      |L16.82|
;;;691          RdOff = 0u;
000050  2400              MOVS     r4,#0
                  |L16.82|
;;;692        }
;;;693      }
;;;694      //
;;;695      // Read remaining items of buffer
;;;696      //
;;;697      NumBytesRem = WrOff - RdOff;
000052  eba90004          SUB      r0,r9,r4
;;;698      NumBytesRem = MIN(NumBytesRem, BufferSize);
000056  42b0              CMP      r0,r6
000058  d200              BCS      |L16.92|
00005a  4606              MOV      r6,r0
                  |L16.92|
;;;699      if (NumBytesRem > 0u) {
00005c  b13e              CBZ      r6,|L16.110|
;;;700        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
00005e  6868              LDR      r0,[r5,#4]
000060  1901              ADDS     r1,r0,r4
;;;701    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;702        NumBytesRead += NumBytesRem;
;;;703        BufferSize   -= NumBytesRem;
;;;704        RdOff        += NumBytesRem;
;;;705        while (NumBytesRem--) {
;;;706          *pBuffer++ = *pSrc++;
;;;707        };
;;;708    #else
;;;709        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
000062  4632              MOV      r2,r6
000064  4640              MOV      r0,r8
000066  f7fffffe          BL       __aeabi_memcpy
;;;710        NumBytesRead += NumBytesRem;
00006a  4437              ADD      r7,r7,r6
;;;711        pBuffer      += NumBytesRem;
;;;712        BufferSize   -= NumBytesRem;
;;;713        RdOff        += NumBytesRem;
00006c  4434              ADD      r4,r4,r6
                  |L16.110|
;;;714    #endif
;;;715      }
;;;716      if (NumBytesRead) {
00006e  b107              CBZ      r7,|L16.114|
;;;717        pRing->RdOff = RdOff;
000070  612c              STR      r4,[r5,#0x10]
                  |L16.114|
;;;718      }
;;;719      //
;;;720      return NumBytesRead;
000072  4638              MOV      r0,r7
;;;721    }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;722    
                          ENDP

                  |L16.120|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_ReadUpBuffer||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_ReadUpBuffer PROC
;;;747    */
;;;748    unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  b510              PUSH     {r4,lr}
;;;749      unsigned NumBytesRead;
;;;750    
;;;751      SEGGER_RTT_LOCK();
000002  f3ef8411          MRS      r4,BASEPRI
000006  2320              MOVS     r3,#0x20
000008  f3838811          MSR      BASEPRI,r3
;;;752      //
;;;753      // Call the non-locking read function
;;;754      //
;;;755      NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
00000c  f7fffffe          BL       SEGGER_RTT_ReadUpBufferNoLock
;;;756      //
;;;757      // Finish up.
;;;758      //
;;;759      SEGGER_RTT_UNLOCK();
000010  b2e1              UXTB     r1,r4
000012  f3818811          MSR      BASEPRI,r1
;;;760      //
;;;761      return NumBytesRead;
;;;762    }
000016  bd10              POP      {r4,pc}
;;;763    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadUpBufferNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadUpBufferNoLock PROC
;;;558    */
;;;559    unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;560      unsigned                NumBytesRem;
;;;561      unsigned                NumBytesRead;
;;;562      unsigned                RdOff;
;;;563      unsigned                WrOff;
;;;564      unsigned char*          pBuffer;
;;;565      SEGGER_RTT_BUFFER_UP*   pRing;
;;;566      volatile char*          pSrc;
;;;567    
;;;568      INIT();
00000a  4a1b              LDR      r2,|L18.120|
00000c  7811              LDRB     r1,[r2,#0]
00000e  2900              CMP      r1,#0
000010  d101              BNE      |L18.22|
000012  f7fffffe          BL       _DoInit
                  |L18.22|
;;;569      pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000016  4918              LDR      r1,|L18.120|
000018  eb040044          ADD      r0,r4,r4,LSL #1
00001c  eb0105c0          ADD      r5,r1,r0,LSL #3
000020  3518              ADDS     r5,r5,#0x18
;;;570      pBuffer = (unsigned char*)pData;
;;;571      RdOff = pRing->RdOff;
000022  692c              LDR      r4,[r5,#0x10]
;;;572      WrOff = pRing->WrOff;
000024  f8d5900c          LDR      r9,[r5,#0xc]
;;;573      NumBytesRead = 0u;
000028  2700              MOVS     r7,#0
;;;574      //
;;;575      // Read from current read position to wrap-around of buffer, first
;;;576      //
;;;577      if (RdOff > WrOff) {
00002a  454c              CMP      r4,r9
00002c  d911              BLS      |L18.82|
;;;578        NumBytesRem = pRing->SizeOfBuffer - RdOff;
00002e  68a8              LDR      r0,[r5,#8]
000030  1b07              SUBS     r7,r0,r4
;;;579        NumBytesRem = MIN(NumBytesRem, BufferSize);
000032  42b7              CMP      r7,r6
000034  d300              BCC      |L18.56|
000036  4637              MOV      r7,r6
                  |L18.56|
;;;580        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
000038  6868              LDR      r0,[r5,#4]
00003a  1901              ADDS     r1,r0,r4
;;;581    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;582        NumBytesRead += NumBytesRem;
;;;583        BufferSize   -= NumBytesRem;
;;;584        RdOff        += NumBytesRem;
;;;585        while (NumBytesRem--) {
;;;586          *pBuffer++ = *pSrc++;
;;;587        };
;;;588    #else
;;;589        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
00003c  463a              MOV      r2,r7
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       __aeabi_memcpy
;;;590        NumBytesRead += NumBytesRem;
;;;591        pBuffer      += NumBytesRem;
000044  44b8              ADD      r8,r8,r7
;;;592        BufferSize   -= NumBytesRem;
000046  1bf6              SUBS     r6,r6,r7
;;;593        RdOff        += NumBytesRem;
000048  443c              ADD      r4,r4,r7
;;;594    #endif
;;;595        //
;;;596        // Handle wrap-around of buffer
;;;597        //
;;;598        if (RdOff == pRing->SizeOfBuffer) {
00004a  68a8              LDR      r0,[r5,#8]
00004c  42a0              CMP      r0,r4
00004e  d100              BNE      |L18.82|
;;;599          RdOff = 0u;
000050  2400              MOVS     r4,#0
                  |L18.82|
;;;600        }
;;;601      }
;;;602      //
;;;603      // Read remaining items of buffer
;;;604      //
;;;605      NumBytesRem = WrOff - RdOff;
000052  eba90004          SUB      r0,r9,r4
;;;606      NumBytesRem = MIN(NumBytesRem, BufferSize);
000056  42b0              CMP      r0,r6
000058  d200              BCS      |L18.92|
00005a  4606              MOV      r6,r0
                  |L18.92|
;;;607      if (NumBytesRem > 0u) {
00005c  b13e              CBZ      r6,|L18.110|
;;;608        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
00005e  6868              LDR      r0,[r5,#4]
000060  1901              ADDS     r1,r0,r4
;;;609    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;610        NumBytesRead += NumBytesRem;
;;;611        BufferSize   -= NumBytesRem;
;;;612        RdOff        += NumBytesRem;
;;;613        while (NumBytesRem--) {
;;;614          *pBuffer++ = *pSrc++;
;;;615        };
;;;616    #else
;;;617        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
000062  4632              MOV      r2,r6
000064  4640              MOV      r0,r8
000066  f7fffffe          BL       __aeabi_memcpy
;;;618        NumBytesRead += NumBytesRem;
00006a  4437              ADD      r7,r7,r6
;;;619        pBuffer      += NumBytesRem;
;;;620        BufferSize   -= NumBytesRem;
;;;621        RdOff        += NumBytesRem;
00006c  4434              ADD      r4,r4,r6
                  |L18.110|
;;;622    #endif
;;;623      }
;;;624      //
;;;625      // Update read offset of buffer
;;;626      //
;;;627      if (NumBytesRead) {
00006e  b107              CBZ      r7,|L18.114|
;;;628        pRing->RdOff = RdOff;
000070  612c              STR      r4,[r5,#0x10]
                  |L18.114|
;;;629      }
;;;630      //
;;;631      return NumBytesRead;
000072  4638              MOV      r0,r7
;;;632    }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;633    
                          ENDP

                  |L18.120|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_SetFlagsDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsDownBuffer PROC
;;;1850   */
;;;1851   int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1852     int r;
;;;1853     volatile SEGGER_RTT_CB* pRTTCB;
;;;1854     volatile SEGGER_RTT_BUFFER_DOWN* pDown;
;;;1855   
;;;1856     INIT();
000006  480d              LDR      r0,|L19.60|
000008  7800              LDRB     r0,[r0,#0]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L19.18|
00000e  f7fffffe          BL       _DoInit
                  |L19.18|
;;;1857     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000012  480a              LDR      r0,|L19.60|
;;;1858     if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
000014  2c03              CMP      r4,#3
000016  d20e              BCS      |L19.54|
;;;1859       SEGGER_RTT_LOCK();
000018  f3ef8211          MRS      r2,BASEPRI
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
;;;1860       pDown = &pRTTCB->aDown[BufferIndex];
000022  eb040144          ADD      r1,r4,r4,LSL #1
000026  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;1861       pDown->Flags = Flags;
00002a  6745              STR      r5,[r0,#0x74]
;;;1862       SEGGER_RTT_UNLOCK();
00002c  b2d0              UXTB     r0,r2
00002e  f3808811          MSR      BASEPRI,r0
;;;1863       r =  0;
000032  2000              MOVS     r0,#0
;;;1864     } else {
;;;1865       r = -1;
;;;1866     }
;;;1867     return r;
;;;1868   }
000034  bd70              POP      {r4-r6,pc}
                  |L19.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;1865
00003a  bd70              POP      {r4-r6,pc}
;;;1869   
                          ENDP

                  |L19.60|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_SetFlagsUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsUpBuffer PROC
;;;1815   */
;;;1816   int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1817     int r;
;;;1818     volatile SEGGER_RTT_CB* pRTTCB;
;;;1819     volatile SEGGER_RTT_BUFFER_UP* pUp;
;;;1820   
;;;1821     INIT();
000006  480d              LDR      r0,|L20.60|
000008  7800              LDRB     r0,[r0,#0]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L20.18|
00000e  f7fffffe          BL       _DoInit
                  |L20.18|
;;;1822     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000012  480a              LDR      r0,|L20.60|
;;;1823     if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
000014  2c03              CMP      r4,#3
000016  d20e              BCS      |L20.54|
;;;1824       SEGGER_RTT_LOCK();
000018  f3ef8211          MRS      r2,BASEPRI
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
;;;1825       pUp = &pRTTCB->aUp[BufferIndex];
000022  eb040144          ADD      r1,r4,r4,LSL #1
000026  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;1826       pUp->Flags = Flags;
00002a  62c5              STR      r5,[r0,#0x2c]
;;;1827       SEGGER_RTT_UNLOCK();
00002c  b2d0              UXTB     r0,r2
00002e  f3808811          MSR      BASEPRI,r0
;;;1828       r =  0;
000032  2000              MOVS     r0,#0
;;;1829     } else {
;;;1830       r = -1;
;;;1831     }
;;;1832     return r;
;;;1833   }
000034  bd70              POP      {r4-r6,pc}
                  |L20.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;1830
00003a  bd70              POP      {r4-r6,pc}
;;;1834   
                          ENDP

                  |L20.60|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;1780   */
;;;1781   int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1782     int r;
;;;1783     volatile SEGGER_RTT_CB* pRTTCB;
;;;1784     volatile SEGGER_RTT_BUFFER_DOWN* pDown;
;;;1785   
;;;1786     INIT();
000006  480d              LDR      r0,|L21.60|
000008  7800              LDRB     r0,[r0,#0]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L21.18|
00000e  f7fffffe          BL       _DoInit
                  |L21.18|
;;;1787     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000012  480a              LDR      r0,|L21.60|
;;;1788     if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
000014  2c03              CMP      r4,#3
000016  d20e              BCS      |L21.54|
;;;1789       SEGGER_RTT_LOCK();
000018  f3ef8211          MRS      r2,BASEPRI
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
;;;1790       pDown = &pRTTCB->aDown[BufferIndex];
000022  eb040144          ADD      r1,r4,r4,LSL #1
000026  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;1791       pDown->sName = sName;
00002a  6605              STR      r5,[r0,#0x60]
;;;1792       SEGGER_RTT_UNLOCK();
00002c  b2d0              UXTB     r0,r2
00002e  f3808811          MSR      BASEPRI,r0
;;;1793       r =  0;
000032  2000              MOVS     r0,#0
;;;1794     } else {
;;;1795       r = -1;
;;;1796     }
;;;1797     return r;
;;;1798   }
000034  bd70              POP      {r4-r6,pc}
                  |L21.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;1795
00003a  bd70              POP      {r4-r6,pc}
;;;1799   
                          ENDP

                  |L21.60|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;1745   */
;;;1746   int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1747     int r;
;;;1748     volatile SEGGER_RTT_CB* pRTTCB;
;;;1749     volatile SEGGER_RTT_BUFFER_UP* pUp;
;;;1750   
;;;1751     INIT();
000006  480d              LDR      r0,|L22.60|
000008  7800              LDRB     r0,[r0,#0]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L22.18|
00000e  f7fffffe          BL       _DoInit
                  |L22.18|
;;;1752     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000012  480a              LDR      r0,|L22.60|
;;;1753     if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
000014  2c03              CMP      r4,#3
000016  d20e              BCS      |L22.54|
;;;1754       SEGGER_RTT_LOCK();
000018  f3ef8211          MRS      r2,BASEPRI
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
;;;1755       pUp = &pRTTCB->aUp[BufferIndex];
000022  eb040144          ADD      r1,r4,r4,LSL #1
000026  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;1756       pUp->sName = sName;
00002a  6185              STR      r5,[r0,#0x18]
;;;1757       SEGGER_RTT_UNLOCK();
00002c  b2d0              UXTB     r0,r2
00002e  f3808811          MSR      BASEPRI,r0
;;;1758       r =  0;
000032  2000              MOVS     r0,#0
;;;1759     } else {
;;;1760       r = -1;
;;;1761     }
;;;1762     return r;
;;;1763   }
000034  bd70              POP      {r4-r6,pc}
                  |L22.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;1760
00003a  bd70              POP      {r4-r6,pc}
;;;1764   
                          ENDP

                  |L22.60|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;1899   */
;;;1900   int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
;;;1901     unsigned char         ac[2];
;;;1902     SEGGER_RTT_BUFFER_UP* pRing;
;;;1903     unsigned Avail;
;;;1904     int r;
;;;1905   
;;;1906     INIT();
000006  4820              LDR      r0,|L23.136|
000008  7800              LDRB     r0,[r0,#0]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L23.18|
00000e  f7fffffe          BL       _DoInit
                  |L23.18|
;;;1907     r = 0;
000012  2500              MOVS     r5,#0
;;;1908     ac[0] = 0xFFu;
000014  20ff              MOVS     r0,#0xff
000016  f88d0000          STRB     r0,[sp,#0]
;;;1909     if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
;;;1910       ac[1] = _aTerminalId[TerminalId];
;;;1911       pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
;;;1912       SEGGER_RTT_LOCK();                     // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
;;;1913       if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
;;;1914         _ActiveTerminal = TerminalId;
;;;1915         _WriteBlocking(pRing, (const char*)ac, 2u);
;;;1916       } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;1917         Avail = _GetAvailWriteSpace(pRing);
;;;1918         if (Avail >= 2) {
;;;1919           _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
;;;1920           _WriteNoCheck(pRing, (const char*)ac, 2u);
;;;1921         } else {
;;;1922           r = -1;
00001a  f04f38ff          MOV      r8,#0xffffffff
00001e  2c10              CMP      r4,#0x10              ;1909
000020  d22d              BCS      |L23.126|
000022  481a              LDR      r0,|L23.140|
000024  5d00              LDRB     r0,[r0,r4]            ;1910
000026  f88d0001          STRB     r0,[sp,#1]            ;1910
00002a  4e17              LDR      r6,|L23.136|
00002c  3618              ADDS     r6,r6,#0x18           ;1911
00002e  f3ef8711          MRS      r7,BASEPRI            ;1912
000032  2020              MOVS     r0,#0x20              ;1912
000034  f3808811          MSR      BASEPRI,r0            ;1912
000038  7d30              LDRB     r0,[r6,#0x14]         ;1913
00003a  f8df9050          LDR      r9,|L23.140|
00003e  f0000003          AND      r0,r0,#3              ;1913
000042  f1a90901          SUB      r9,r9,#1              ;1914
000046  2802              CMP      r0,#2                 ;1913
000048  d00c              BEQ      |L23.100|
00004a  4630              MOV      r0,r6                 ;1917
00004c  f7fffffe          BL       _GetAvailWriteSpace
000050  2802              CMP      r0,#2                 ;1918
000052  d30f              BCC      |L23.116|
000054  f8894000          STRB     r4,[r9,#0]            ;1919
000058  2202              MOVS     r2,#2                 ;1920
00005a  4669              MOV      r1,sp                 ;1920
00005c  4630              MOV      r0,r6                 ;1920
00005e  f7fffffe          BL       _WriteNoCheck
000062  e008              B        |L23.118|
                  |L23.100|
000064  f8894000          STRB     r4,[r9,#0]            ;1914
000068  2202              MOVS     r2,#2                 ;1915
00006a  4669              MOV      r1,sp                 ;1915
00006c  4630              MOV      r0,r6                 ;1915
00006e  f7fffffe          BL       _WriteBlocking
000072  e000              B        |L23.118|
                  |L23.116|
000074  4645              MOV      r5,r8
                  |L23.118|
;;;1923         }
;;;1924       }
;;;1925       SEGGER_RTT_UNLOCK();
000076  b2f8              UXTB     r0,r7
000078  f3808811          MSR      BASEPRI,r0
00007c  e000              B        |L23.128|
                  |L23.126|
;;;1926     } else {
;;;1927       r = -1;
00007e  4645              MOV      r5,r8
                  |L23.128|
;;;1928     }
;;;1929     return r;
000080  4628              MOV      r0,r5
;;;1930   }
000082  e8bd83f8          POP      {r3-r9,pc}
;;;1931   
                          ENDP

000086  0000              DCW      0x0000
                  |L23.136|
                          DCD      ||.bss||
                  |L23.140|
                          DCD      ||.data||+0x1

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1948   */
;;;1949   int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
;;;1950     int                   Status;
;;;1951     unsigned              FragLen;
;;;1952     unsigned              Avail;
;;;1953     SEGGER_RTT_BUFFER_UP* pRing;
;;;1954     //
;;;1955     INIT();
000008  4834              LDR      r0,|L24.220|
00000a  7800              LDRB     r0,[r0,#0]
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L24.20|
000010  f7fffffe          BL       _DoInit
                  |L24.20|
;;;1956     //
;;;1957     // Validate terminal ID.
;;;1958     //
;;;1959     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
;;;1960       //
;;;1961       // Get "to-host" ring buffer.
;;;1962       //
;;;1963       pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
;;;1964       //
;;;1965       // Need to be able to change terminal, write data, change back.
;;;1966       // Compute the fixed and variable sizes.
;;;1967       //
;;;1968       FragLen = STRLEN(s);
;;;1969       //
;;;1970       // How we output depends upon the mode...
;;;1971       //
;;;1972       SEGGER_RTT_LOCK();
;;;1973       Avail = _GetAvailWriteSpace(pRing);
;;;1974       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
;;;1975       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1976         //
;;;1977         // If we are in skip mode and there is no space for the whole
;;;1978         // of this output, don't bother switching terminals at all.
;;;1979         //
;;;1980         if (Avail < (FragLen + 4u)) {
;;;1981           Status = 0;
;;;1982         } else {
;;;1983           _PostTerminalSwitch(pRing, TerminalId);
;;;1984           Status = (int)_WriteBlocking(pRing, s, FragLen);
;;;1985           _PostTerminalSwitch(pRing, _ActiveTerminal);
;;;1986         }
;;;1987         break;
;;;1988       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1989         //
;;;1990         // If we are in trim mode and there is not enough space for everything,
;;;1991         // trim the output but always include the terminal switch.  If no room
;;;1992         // for terminal switch, skip that totally.
;;;1993         //
;;;1994         if (Avail < 4u) {
;;;1995           Status = -1;
000014  f04f36ff          MOV      r6,#0xffffffff
000018  f1ba0f10          CMP      r10,#0x10             ;1959
00001c  d25a              BCS      |L24.212|
00001e  f8df80bc          LDR      r8,|L24.220|
000022  f1080818          ADD      r8,r8,#0x18           ;1963
000026  4658              MOV      r0,r11                ;1968
000028  f7fffffe          BL       strlen
00002c  4605              MOV      r5,r0                 ;1968
00002e  f3ef8911          MRS      r9,BASEPRI            ;1972
000032  2020              MOVS     r0,#0x20              ;1972
000034  f3808811          MSR      BASEPRI,r0            ;1972
000038  4640              MOV      r0,r8                 ;1973
00003a  f7fffffe          BL       _GetAvailWriteSpace
00003e  4604              MOV      r4,r0                 ;1973
000040  f8980014          LDRB     r0,[r8,#0x14]         ;1974
000044  4f26              LDR      r7,|L24.224|
000046  f0100003          ANDS     r0,r0,#3              ;1974
00004a  d009              BEQ      |L24.96|
00004c  2801              CMP      r0,#1                 ;1974
00004e  d01b              BEQ      |L24.136|
000050  2802              CMP      r0,#2                 ;1974
000052  d030              BEQ      |L24.182|
;;;1996         } else {
;;;1997           _PostTerminalSwitch(pRing, TerminalId);
;;;1998           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
;;;1999           _PostTerminalSwitch(pRing, _ActiveTerminal);
;;;2000         }
;;;2001         break;
;;;2002       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;2003         //
;;;2004         // If we are in blocking mode, output everything.
;;;2005         //
;;;2006         _PostTerminalSwitch(pRing, TerminalId);
;;;2007         Status = (int)_WriteBlocking(pRing, s, FragLen);
;;;2008         _PostTerminalSwitch(pRing, _ActiveTerminal);
;;;2009         break;
;;;2010       default:
;;;2011         Status = -1;
000054  4634              MOV      r4,r6
                  |L24.86|
;;;2012         break;
;;;2013       }
;;;2014       //
;;;2015       // Finish up.
;;;2016       //
;;;2017       SEGGER_RTT_UNLOCK();
000056  f00900ff          AND      r0,r9,#0xff
00005a  f3808811          MSR      BASEPRI,r0
00005e  e03a              B        |L24.214|
                  |L24.96|
000060  1d28              ADDS     r0,r5,#4              ;1980
000062  4284              CMP      r4,r0                 ;1980
000064  d201              BCS      |L24.106|
000066  2400              MOVS     r4,#0                 ;1981
000068  e7f5              B        |L24.86|
                  |L24.106|
00006a  4651              MOV      r1,r10                ;1983
00006c  4640              MOV      r0,r8                 ;1983
00006e  f7fffffe          BL       _PostTerminalSwitch
000072  462a              MOV      r2,r5                 ;1984
000074  4659              MOV      r1,r11                ;1984
000076  4640              MOV      r0,r8                 ;1984
000078  f7fffffe          BL       _WriteBlocking
00007c  4604              MOV      r4,r0                 ;1984
00007e  7839              LDRB     r1,[r7,#0]            ;1985  ; _ActiveTerminal
000080  4640              MOV      r0,r8                 ;1985
000082  f7fffffe          BL       _PostTerminalSwitch
000086  e7e6              B        |L24.86|
                  |L24.136|
000088  2c04              CMP      r4,#4                 ;1994
00008a  d201              BCS      |L24.144|
00008c  4634              MOV      r4,r6                 ;1995
00008e  e7e2              B        |L24.86|
                  |L24.144|
000090  4651              MOV      r1,r10                ;1997
000092  4640              MOV      r0,r8                 ;1997
000094  f7fffffe          BL       _PostTerminalSwitch
000098  1f20              SUBS     r0,r4,#4              ;1998
00009a  4285              CMP      r5,r0                 ;1998
00009c  d300              BCC      |L24.160|
00009e  1f25              SUBS     r5,r4,#4              ;1998
                  |L24.160|
0000a0  462a              MOV      r2,r5                 ;1998
0000a2  4659              MOV      r1,r11                ;1998
0000a4  4640              MOV      r0,r8                 ;1998
0000a6  f7fffffe          BL       _WriteBlocking
0000aa  4604              MOV      r4,r0                 ;1998
0000ac  7839              LDRB     r1,[r7,#0]            ;1999  ; _ActiveTerminal
0000ae  4640              MOV      r0,r8                 ;1999
0000b0  f7fffffe          BL       _PostTerminalSwitch
0000b4  e7cf              B        |L24.86|
                  |L24.182|
0000b6  4651              MOV      r1,r10                ;2006
0000b8  4640              MOV      r0,r8                 ;2006
0000ba  f7fffffe          BL       _PostTerminalSwitch
0000be  462a              MOV      r2,r5                 ;2007
0000c0  4659              MOV      r1,r11                ;2007
0000c2  4640              MOV      r0,r8                 ;2007
0000c4  f7fffffe          BL       _WriteBlocking
0000c8  4604              MOV      r4,r0                 ;2007
0000ca  7839              LDRB     r1,[r7,#0]            ;2008  ; _ActiveTerminal
0000cc  4640              MOV      r0,r8                 ;2008
0000ce  f7fffffe          BL       _PostTerminalSwitch
0000d2  e7c0              B        |L24.86|
                  |L24.212|
;;;2018     } else {
;;;2019       Status = -1;
0000d4  4634              MOV      r4,r6
                  |L24.214|
;;;2020     }
;;;2021     return Status;
0000d6  4620              MOV      r0,r4
;;;2022   }
0000d8  e8bd9ff0          POP      {r4-r12,pc}
;;;2023   
                          ENDP

                  |L24.220|
                          DCD      ||.bss||
                  |L24.224|
                          DCD      ||.data||

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;1449   */
;;;1450   int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
                  |L25.2|
;;;1451     int r;
;;;1452   
;;;1453     do {
;;;1454       r = SEGGER_RTT_GetKey();
000002  f7fffffe          BL       SEGGER_RTT_GetKey
;;;1455     } while (r < 0);
000006  2800              CMP      r0,#0
000008  dbfb              BLT      |L25.2|
;;;1456     return r;
;;;1457   }
00000a  bd10              POP      {r4,pc}
;;;1458   
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;1189   */
;;;1190   unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1191     unsigned Status;
;;;1192   
;;;1193     INIT();
00000a  4b0a              LDR      r3,|L26.52|
00000c  7818              LDRB     r0,[r3,#0]
00000e  2800              CMP      r0,#0
000010  d101              BNE      |L26.22|
000012  f7fffffe          BL       _DoInit
                  |L26.22|
;;;1194     SEGGER_RTT_LOCK();
000016  f3ef8411          MRS      r4,BASEPRI
00001a  2020              MOVS     r0,#0x20
00001c  f3808811          MSR      BASEPRI,r0
;;;1195     Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
000020  463a              MOV      r2,r7
000022  4631              MOV      r1,r6
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       SEGGER_RTT_WriteNoLock
;;;1196     SEGGER_RTT_UNLOCK();
00002a  b2e1              UXTB     r1,r4
00002c  f3818811          MSR      BASEPRI,r1
;;;1197     return Status;
;;;1198   }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;1199   
                          ENDP

                  |L26.52|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_WriteDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteDownBuffer PROC
;;;1160   */
;;;1161   unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1162     unsigned Status;
;;;1163   
;;;1164     INIT();
00000a  4b0a              LDR      r3,|L27.52|
00000c  7818              LDRB     r0,[r3,#0]
00000e  2800              CMP      r0,#0
000010  d101              BNE      |L27.22|
000012  f7fffffe          BL       _DoInit
                  |L27.22|
;;;1165     SEGGER_RTT_LOCK();
000016  f3ef8411          MRS      r4,BASEPRI
00001a  2020              MOVS     r0,#0x20
00001c  f3808811          MSR      BASEPRI,r0
;;;1166     Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
000020  463a              MOV      r2,r7
000022  4631              MOV      r1,r6
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       SEGGER_RTT_WriteDownBufferNoLock
;;;1167     SEGGER_RTT_UNLOCK();
00002a  b2e1              UXTB     r1,r4
00002c  f3818811          MSR      BASEPRI,r1
;;;1168     return Status;
;;;1169   }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;1170   
                          ENDP

                  |L27.52|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_WriteDownBufferNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteDownBufferNoLock PROC
;;;1009   */
;;;1010   unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b570              PUSH     {r4-r6,lr}
000002  460e              MOV      r6,r1
000004  4614              MOV      r4,r2
;;;1011     unsigned                Status;
;;;1012     unsigned                Avail;
;;;1013     const char*             pData;
;;;1014     SEGGER_RTT_BUFFER_UP*   pRing;
;;;1015     //
;;;1016     // Get "to-target" ring buffer.
;;;1017     // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
;;;1018     //
;;;1019     pData = (const char *)pBuffer;
;;;1020     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000006  4918              LDR      r1,|L28.104|
000008  eb000040          ADD      r0,r0,r0,LSL #1
00000c  eb0105c0          ADD      r5,r1,r0,LSL #3
000010  3560              ADDS     r5,r5,#0x60
;;;1021     //
;;;1022     // How we output depends upon the mode...
;;;1023     //
;;;1024     switch (pRing->Flags) {
000012  6968              LDR      r0,[r5,#0x14]
000014  2800              CMP      r0,#0
000016  d006              BEQ      |L28.38|
000018  2801              CMP      r0,#1
00001a  d011              BEQ      |L28.64|
00001c  2802              CMP      r0,#2
00001e  d01b              BEQ      |L28.88|
;;;1025     case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1026       //
;;;1027       // If we are in skip mode and there is no space for the whole
;;;1028       // of this output, don't bother.
;;;1029       //
;;;1030       Avail = _GetAvailWriteSpace(pRing);
;;;1031       if (Avail < NumBytes) {
;;;1032         Status = 0u;
;;;1033       } else {
;;;1034         Status = NumBytes;
;;;1035         _WriteNoCheck(pRing, pData, NumBytes);
;;;1036       }
;;;1037       break;
;;;1038     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1039       //
;;;1040       // If we are in trim mode, trim to what we can output without blocking.
;;;1041       //
;;;1042       Avail = _GetAvailWriteSpace(pRing);
;;;1043       Status = Avail < NumBytes ? Avail : NumBytes;
;;;1044       _WriteNoCheck(pRing, pData, Status);
;;;1045       break;
;;;1046     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1047       //
;;;1048       // If we are in blocking mode, output everything.
;;;1049       //
;;;1050       Status = _WriteBlocking(pRing, pData, NumBytes);
;;;1051       break;
;;;1052     default:
;;;1053       Status = 0u;
000020  2400              MOVS     r4,#0
                  |L28.34|
;;;1054       break;
;;;1055     }
;;;1056     //
;;;1057     // Finish up.
;;;1058     //
;;;1059     return Status;
000022  4620              MOV      r0,r4
;;;1060   }
000024  bd70              POP      {r4-r6,pc}
                  |L28.38|
000026  4628              MOV      r0,r5                 ;1030
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  42a0              CMP      r0,r4                 ;1031
00002e  d201              BCS      |L28.52|
000030  2400              MOVS     r4,#0                 ;1032
000032  e7f6              B        |L28.34|
                  |L28.52|
000034  4622              MOV      r2,r4                 ;1035
000036  4631              MOV      r1,r6                 ;1035
000038  4628              MOV      r0,r5                 ;1035
00003a  f7fffffe          BL       _WriteNoCheck
00003e  e7f0              B        |L28.34|
                  |L28.64|
000040  4628              MOV      r0,r5                 ;1042
000042  f7fffffe          BL       _GetAvailWriteSpace
000046  42a0              CMP      r0,r4                 ;1043
000048  d200              BCS      |L28.76|
00004a  4604              MOV      r4,r0                 ;1043
                  |L28.76|
00004c  4622              MOV      r2,r4                 ;1044
00004e  4631              MOV      r1,r6                 ;1044
000050  4628              MOV      r0,r5                 ;1044
000052  f7fffffe          BL       _WriteNoCheck
000056  e7e4              B        |L28.34|
                  |L28.88|
000058  4622              MOV      r2,r4                 ;1050
00005a  4631              MOV      r1,r6                 ;1050
00005c  4628              MOV      r0,r5                 ;1050
00005e  f7fffffe          BL       _WriteBlocking
000062  4604              MOV      r4,r0                 ;1050
000064  e7dd              B        |L28.34|
;;;1061   
                          ENDP

000066  0000              DCW      0x0000
                  |L28.104|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;1084   */
;;;1085   unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b570              PUSH     {r4-r6,lr}
000002  460e              MOV      r6,r1
000004  4614              MOV      r4,r2
;;;1086     unsigned              Status;
;;;1087     unsigned              Avail;
;;;1088     const char*           pData;
;;;1089     SEGGER_RTT_BUFFER_UP* pRing;
;;;1090     //
;;;1091     // Get "to-host" ring buffer.
;;;1092     //
;;;1093     pData = (const char *)pBuffer;
;;;1094     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000006  4918              LDR      r1,|L29.104|
000008  eb000040          ADD      r0,r0,r0,LSL #1
00000c  eb0105c0          ADD      r5,r1,r0,LSL #3
000010  3518              ADDS     r5,r5,#0x18
;;;1095     //
;;;1096     // How we output depends upon the mode...
;;;1097     //
;;;1098     switch (pRing->Flags) {
000012  6968              LDR      r0,[r5,#0x14]
000014  2800              CMP      r0,#0
000016  d006              BEQ      |L29.38|
000018  2801              CMP      r0,#1
00001a  d011              BEQ      |L29.64|
00001c  2802              CMP      r0,#2
00001e  d01b              BEQ      |L29.88|
;;;1099     case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1100       //
;;;1101       // If we are in skip mode and there is no space for the whole
;;;1102       // of this output, don't bother.
;;;1103       //
;;;1104       Avail = _GetAvailWriteSpace(pRing);
;;;1105       if (Avail < NumBytes) {
;;;1106         Status = 0u;
;;;1107       } else {
;;;1108         Status = NumBytes;
;;;1109         _WriteNoCheck(pRing, pData, NumBytes);
;;;1110       }
;;;1111       break;
;;;1112     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1113       //
;;;1114       // If we are in trim mode, trim to what we can output without blocking.
;;;1115       //
;;;1116       Avail = _GetAvailWriteSpace(pRing);
;;;1117       Status = Avail < NumBytes ? Avail : NumBytes;
;;;1118       _WriteNoCheck(pRing, pData, Status);
;;;1119       break;
;;;1120     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1121       //
;;;1122       // If we are in blocking mode, output everything.
;;;1123       //
;;;1124       Status = _WriteBlocking(pRing, pData, NumBytes);
;;;1125       break;
;;;1126     default:
;;;1127       Status = 0u;
000020  2400              MOVS     r4,#0
                  |L29.34|
;;;1128       break;
;;;1129     }
;;;1130     //
;;;1131     // Finish up.
;;;1132     //
;;;1133     return Status;
000022  4620              MOV      r0,r4
;;;1134   }
000024  bd70              POP      {r4-r6,pc}
                  |L29.38|
000026  4628              MOV      r0,r5                 ;1104
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  42a0              CMP      r0,r4                 ;1105
00002e  d201              BCS      |L29.52|
000030  2400              MOVS     r4,#0                 ;1106
000032  e7f6              B        |L29.34|
                  |L29.52|
000034  4622              MOV      r2,r4                 ;1109
000036  4631              MOV      r1,r6                 ;1109
000038  4628              MOV      r0,r5                 ;1109
00003a  f7fffffe          BL       _WriteNoCheck
00003e  e7f0              B        |L29.34|
                  |L29.64|
000040  4628              MOV      r0,r5                 ;1116
000042  f7fffffe          BL       _GetAvailWriteSpace
000046  42a0              CMP      r0,r4                 ;1117
000048  d200              BCS      |L29.76|
00004a  4604              MOV      r4,r0                 ;1117
                  |L29.76|
00004c  4622              MOV      r2,r4                 ;1118
00004e  4631              MOV      r1,r6                 ;1118
000050  4628              MOV      r0,r5                 ;1118
000052  f7fffffe          BL       _WriteNoCheck
000056  e7e4              B        |L29.34|
                  |L29.88|
000058  4622              MOV      r2,r4                 ;1124
00005a  4631              MOV      r1,r6                 ;1124
00005c  4628              MOV      r0,r5                 ;1124
00005e  f7fffffe          BL       _WriteBlocking
000062  4604              MOV      r4,r0                 ;1124
000064  e7dd              B        |L29.34|
;;;1135   
                          ENDP

000066  0000              DCW      0x0000
                  |L29.104|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;919    #if (RTT_USE_ASM == 0)
;;;920    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4688              MOV      r8,r1
000006  4616              MOV      r6,r2
;;;921      const char*           pData;
;;;922      SEGGER_RTT_BUFFER_UP* pRing;
;;;923      unsigned              Avail;
;;;924      unsigned              RdOff;
;;;925      unsigned              WrOff;
;;;926      unsigned              Rem;
;;;927      volatile char*        pDst;
;;;928      //
;;;929      // Cases:
;;;930      //   1) RdOff <= WrOff => Space until wrap-around is sufficient
;;;931      //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
;;;932      //   3) RdOff <  WrOff => No space in buf
;;;933      //   4) RdOff >  WrOff => Space is sufficient
;;;934      //   5) RdOff >  WrOff => No space in buf
;;;935      //
;;;936      // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
;;;937      //
;;;938      pData = (const char *)pBuffer;
;;;939      pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000008  491a              LDR      r1,|L30.116|
00000a  eb000040          ADD      r0,r0,r0,LSL #1
00000e  eb0104c0          ADD      r4,r1,r0,LSL #3
000012  3418              ADDS     r4,r4,#0x18
;;;940      RdOff = pRing->RdOff;
000014  6920              LDR      r0,[r4,#0x10]
;;;941      WrOff = pRing->WrOff;
000016  68e5              LDR      r5,[r4,#0xc]
;;;942      if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
000018  42a8              CMP      r0,r5
00001a  d824              BHI      |L30.102|
;;;943        Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
00001c  68a1              LDR      r1,[r4,#8]
00001e  1b49              SUBS     r1,r1,r5
000020  460f              MOV      r7,r1
000022  1e49              SUBS     r1,r1,#1
;;;944        if (Avail >= NumBytes) {                            // Case 1)?
000024  42b1              CMP      r1,r6
000026  d30a              BCC      |L30.62|
                  |L30.40|
;;;945    CopyStraight:
;;;946          pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
000028  6860              LDR      r0,[r4,#4]
00002a  4428              ADD      r0,r0,r5
;;;947          memcpy((void*)pDst, pData, NumBytes);
00002c  4632              MOV      r2,r6
00002e  4641              MOV      r1,r8
000030  f7fffffe          BL       __aeabi_memcpy
;;;948          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;949          pRing->WrOff = WrOff + NumBytes;
000034  19a8              ADDS     r0,r5,r6
000036  60e0              STR      r0,[r4,#0xc]
;;;950          return 1;
000038  2001              MOVS     r0,#1
                  |L30.58|
;;;951        }
;;;952        Avail += RdOff;                                     // Space incl. wrap-around
;;;953        if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
;;;954          Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
;;;955          pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
;;;956          memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
;;;957          NumBytes -= Rem;
;;;958          //
;;;959          // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
;;;960          // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
;;;961          // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
;;;962          // Therefore, check if 2nd memcpy is necessary at all
;;;963          //
;;;964          if (NumBytes) {
;;;965            pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
;;;966            memcpy((void*)pDst, pData + Rem, NumBytes);
;;;967          }
;;;968          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;969          pRing->WrOff = NumBytes;
;;;970          return 1;
;;;971        }
;;;972      } else {                                             // Potential case 4)
;;;973        Avail = RdOff - WrOff - 1u;
;;;974        if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
;;;975          goto CopyStraight;
;;;976        }
;;;977      }
;;;978      return 0;     // No space in buffer
;;;979    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L30.62|
00003e  4408              ADD      r0,r0,r1              ;952
000040  42b0              CMP      r0,r6                 ;953
000042  d314              BCC      |L30.110|
000044  6860              LDR      r0,[r4,#4]            ;955
000046  4428              ADD      r0,r0,r5              ;955
000048  463a              MOV      r2,r7                 ;956
00004a  4641              MOV      r1,r8                 ;956
00004c  f7fffffe          BL       __aeabi_memcpy
000050  1bf5              SUBS     r5,r6,r7              ;957
000052  b12d              CBZ      r5,|L30.96|
000054  6860              LDR      r0,[r4,#4]            ;965
000056  eb080107          ADD      r1,r8,r7              ;966
00005a  462a              MOV      r2,r5                 ;966
00005c  f7fffffe          BL       __aeabi_memcpy
                  |L30.96|
000060  60e5              STR      r5,[r4,#0xc]          ;969
000062  2001              MOVS     r0,#1                 ;970
000064  e7e9              B        |L30.58|
                  |L30.102|
000066  1b40              SUBS     r0,r0,r5              ;973
000068  1e40              SUBS     r0,r0,#1              ;973
00006a  42b0              CMP      r0,r6                 ;974
00006c  d2dc              BCS      |L30.40|
                  |L30.110|
00006e  2000              MOVS     r0,#0                 ;978
000070  e7e3              B        |L30.58|
;;;980    #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L30.116|
                          DCD      ||.bss||

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;1219   */
;;;1220   unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1221     unsigned Len;
;;;1222   
;;;1223     Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4602              MOV      r2,r0
;;;1224     return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  e8bd4070          POP      {r4-r6,lr}
000016  f7ffbffe          B.W      SEGGER_RTT_Write
;;;1225   }
;;;1226   
                          ENDP


                          AREA ||i.SEGGER_RTT_WriteWithOverwriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteWithOverwriteNoLock PROC
;;;818    */
;;;819    void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
;;;820      const char*           pData;
;;;821      SEGGER_RTT_BUFFER_UP* pRing;
;;;822      unsigned              Avail;
;;;823      volatile char*        pDst;
;;;824      //
;;;825      // Get "to-host" ring buffer and copy some elements into local variables.
;;;826      //
;;;827      pData = (const char *)pBuffer;
;;;828      pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000008  4924              LDR      r1,|L32.156|
00000a  eb000040          ADD      r0,r0,r0,LSL #1
00000e  eb0104c0          ADD      r4,r1,r0,LSL #3
000012  3418              ADDS     r4,r4,#0x18
;;;829      //
;;;830      // Check if we will overwrite data and need to adjust the RdOff.
;;;831      //
;;;832      if (pRing->WrOff == pRing->RdOff) {
000014  e9d40103          LDRD     r0,r1,[r4,#0xc]
000018  4288              CMP      r0,r1
00001a  d102              BNE      |L32.34|
;;;833        Avail = pRing->SizeOfBuffer - 1u;
00001c  68a0              LDR      r0,[r4,#8]
00001e  1e40              SUBS     r0,r0,#1
000020  e00b              B        |L32.58|
                  |L32.34|
;;;834      } else if ( pRing->WrOff < pRing->RdOff) {
000022  6921              LDR      r1,[r4,#0x10]
000024  4288              CMP      r0,r1
000026  d203              BCS      |L32.48|
;;;835        Avail = pRing->RdOff - pRing->WrOff - 1u;
000028  6921              LDR      r1,[r4,#0x10]
00002a  1a08              SUBS     r0,r1,r0
00002c  1e40              SUBS     r0,r0,#1
00002e  e004              B        |L32.58|
                  |L32.48|
;;;836      } else {
;;;837        Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
000030  6921              LDR      r1,[r4,#0x10]
000032  1a08              SUBS     r0,r1,r0
000034  68a1              LDR      r1,[r4,#8]
000036  1e40              SUBS     r0,r0,#1
000038  4408              ADD      r0,r0,r1
                  |L32.58|
;;;838      }
;;;839      if (NumBytes > Avail) {
00003a  4285              CMP      r5,r0
00003c  d90b              BLS      |L32.86|
;;;840        pRing->RdOff += (NumBytes - Avail);
00003e  6921              LDR      r1,[r4,#0x10]
000040  1a28              SUBS     r0,r5,r0
000042  4408              ADD      r0,r0,r1
000044  6120              STR      r0,[r4,#0x10]
000046  68a0              LDR      r0,[r4,#8]            ;833
;;;841        while (pRing->RdOff >= pRing->SizeOfBuffer) {
000048  e002              B        |L32.80|
                  |L32.74|
;;;842          pRing->RdOff -= pRing->SizeOfBuffer;
00004a  6921              LDR      r1,[r4,#0x10]
00004c  1a09              SUBS     r1,r1,r0
00004e  6121              STR      r1,[r4,#0x10]
                  |L32.80|
000050  6921              LDR      r1,[r4,#0x10]         ;841
000052  4281              CMP      r1,r0                 ;841
000054  d2f9              BCS      |L32.74|
                  |L32.86|
;;;843        }
;;;844      }
;;;845      //
;;;846      // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
;;;847      //
;;;848      Avail = pRing->SizeOfBuffer - pRing->WrOff;
000056  e9d40102          LDRD     r0,r1,[r4,#8]
00005a  1a46              SUBS     r6,r0,r1
;;;849      do {
00005c  f04f0800          MOV      r8,#0
                  |L32.96|
;;;850        if (Avail > NumBytes) {
000060  42ae              CMP      r6,r5
000062  d90b              BLS      |L32.124|
;;;851          //
;;;852          // Last round
;;;853          //
;;;854          pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
000064  68e1              LDR      r1,[r4,#0xc]
000066  6860              LDR      r0,[r4,#4]
000068  4408              ADD      r0,r0,r1
;;;855    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;856          Avail = NumBytes;
;;;857          while (NumBytes--) {
;;;858            *pDst++ = *pData++;
;;;859          };
;;;860          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;861          pRing->WrOff += Avail;
;;;862    #else
;;;863          SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
00006a  462a              MOV      r2,r5
00006c  4639              MOV      r1,r7
00006e  f7fffffe          BL       __aeabi_memcpy
;;;864          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;865          pRing->WrOff += NumBytes;
000072  68e0              LDR      r0,[r4,#0xc]
000074  4428              ADD      r0,r0,r5
000076  60e0              STR      r0,[r4,#0xc]
                  |L32.120|
;;;866    #endif
;;;867          break;
;;;868        } else {
;;;869          //
;;;870          //  Wrap-around necessary, write until wrap-around and reset WrOff
;;;871          //
;;;872          pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
;;;873    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;874          NumBytes -= Avail;
;;;875          while (Avail--) {
;;;876            *pDst++ = *pData++;
;;;877          };
;;;878          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;879          pRing->WrOff = 0;
;;;880    #else
;;;881          SEGGER_RTT_MEMCPY((void*)pDst, pData, Avail);
;;;882          pData += Avail;
;;;883          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;884          pRing->WrOff = 0;
;;;885          NumBytes -= Avail;
;;;886    #endif
;;;887          Avail = (pRing->SizeOfBuffer - 1);
;;;888        }
;;;889      } while (NumBytes);
;;;890    }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L32.124|
00007c  68e1              LDR      r1,[r4,#0xc]          ;872
00007e  6860              LDR      r0,[r4,#4]            ;872
000080  4408              ADD      r0,r0,r1              ;872
000082  4632              MOV      r2,r6                 ;881
000084  4639              MOV      r1,r7                 ;881
000086  f7fffffe          BL       __aeabi_memcpy
00008a  4437              ADD      r7,r7,r6              ;882
00008c  f8c4800c          STR      r8,[r4,#0xc]          ;884
000090  1bad              SUBS     r5,r5,r6              ;885
000092  68a6              LDR      r6,[r4,#8]            ;887
000094  1e76              SUBS     r6,r6,#1              ;887
000096  2d00              CMP      r5,#0                 ;887
000098  d1e2              BNE      |L32.96|
00009a  e7ed              B        |L32.120|
;;;891    
                          ENDP

                  |L32.156|
                          DCD      ||.bss||

                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;301    
;;;302    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;303      volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
;;;304      //
;;;305      // Initialize control block
;;;306      //
;;;307      p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
000002  4c12              LDR      r4,|L33.76|
;;;308      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2003              MOVS     r0,#3
000006  6120              STR      r0,[r4,#0x10]
;;;309      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;310      //
;;;311      // Initialize up buffer 0
;;;312      //
;;;313      p->aUp[0].sName         = "Terminal";
00000a  a011              ADR      r0,|L33.80|
00000c  61a0              STR      r0,[r4,#0x18]
;;;314      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  f10400a8          ADD      r0,r4,#0xa8
000012  61e0              STR      r0,[r4,#0x1c]
;;;315      p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
000014  f44f6080          MOV      r0,#0x400
000018  6220              STR      r0,[r4,#0x20]
;;;316      p->aUp[0].RdOff         = 0u;
00001a  2100              MOVS     r1,#0
00001c  62a1              STR      r1,[r4,#0x28]
;;;317      p->aUp[0].WrOff         = 0u;
00001e  6261              STR      r1,[r4,#0x24]
;;;318      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000020  62e1              STR      r1,[r4,#0x2c]
;;;319      //
;;;320      // Initialize down buffer 0
;;;321      //
;;;322      p->aDown[0].sName         = "Terminal";
000022  a00b              ADR      r0,|L33.80|
000024  6620              STR      r0,[r4,#0x60]
;;;323      p->aDown[0].pBuffer       = _acDownBuffer;
000026  f5046095          ADD      r0,r4,#0x4a8
00002a  6660              STR      r0,[r4,#0x64]
;;;324      p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
00002c  2010              MOVS     r0,#0x10
00002e  66a0              STR      r0,[r4,#0x68]
;;;325      p->aDown[0].RdOff         = 0u;
000030  6721              STR      r1,[r4,#0x70]
;;;326      p->aDown[0].WrOff         = 0u;
000032  66e1              STR      r1,[r4,#0x6c]
;;;327      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000034  6761              STR      r1,[r4,#0x74]
;;;328      //
;;;329      // Finish initialization of the control block.
;;;330      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;331      // in initializer memory (usually flash) by J-Link
;;;332      //
;;;333      STRCPY((char*)&p->acID[7], "RTT");
000036  a109              ADR      r1,|L33.92|
000038  1de0              ADDS     r0,r4,#7
00003a  f7fffffe          BL       strcpy
;;;334      RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
;;;335      STRCPY((char*)&p->acID[0], "SEGGER");
00003e  a108              ADR      r1,|L33.96|
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       strcpy
;;;336      RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
;;;337      p->acID[6] = ' ';
000046  2020              MOVS     r0,#0x20
000048  71a0              STRB     r0,[r4,#6]
;;;338      RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
;;;339    }
00004a  bd10              POP      {r4,pc}
;;;340    
                          ENDP

                  |L33.76|
                          DCD      ||.bss||
                  |L33.80|
000050  5465726d          DCB      "Terminal",0
000054  696e616c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L33.92|
00005c  52545400          DCB      "RTT",0
                  |L33.96|
000060  53454747          DCB      "SEGGER",0
000064  455200  
000067  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;511    */
;;;512    static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
000000  6901              LDR      r1,[r0,#0x10]
;;;513      unsigned RdOff;
;;;514      unsigned WrOff;
;;;515      unsigned r;
;;;516      //
;;;517      // Avoid warnings regarding volatile access order.  It's not a problem
;;;518      // in this case, but dampen compiler enthusiasm.
;;;519      //
;;;520      RdOff = pRing->RdOff;
;;;521      WrOff = pRing->WrOff;
000002  68c2              LDR      r2,[r0,#0xc]
;;;522      if (RdOff <= WrOff) {
000004  4291              CMP      r1,r2
000006  d804              BHI      |L34.18|
;;;523        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
000008  6880              LDR      r0,[r0,#8]
00000a  1a80              SUBS     r0,r0,r2
00000c  4408              ADD      r0,r0,r1
00000e  1e40              SUBS     r0,r0,#1
;;;524      } else {
;;;525        r = RdOff - WrOff - 1u;
;;;526      }
;;;527      return r;
;;;528    }
000010  4770              BX       lr
                  |L34.18|
000012  1a88              SUBS     r0,r1,r2              ;525
000014  1e40              SUBS     r0,r0,#1              ;525
000016  4770              BX       lr
;;;529    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;489    */
;;;490    static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
000000  b508              PUSH     {r3,lr}
;;;491      unsigned char ac[2];
;;;492    
;;;493      ac[0] = 0xFFu;
000002  22ff              MOVS     r2,#0xff
000004  f88d2000          STRB     r2,[sp,#0]
;;;494      ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
000008  4a04              LDR      r2,|L35.28|
00000a  5c51              LDRB     r1,[r2,r1]
00000c  f88d1001          STRB     r1,[sp,#1]
;;;495      _WriteBlocking(pRing, (const char*)ac, 2u);
000010  2202              MOVS     r2,#2
000012  4669              MOV      r1,sp
000014  f7fffffe          BL       _WriteBlocking
;;;496    }
000018  bd08              POP      {r3,pc}
;;;497    
                          ENDP

00001a  0000              DCW      0x0000
                  |L35.28|
                          DCD      ||.data||+0x1

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;359    */
;;;360    static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;361      unsigned NumBytesToWrite;
;;;362      unsigned NumBytesWritten;
;;;363      unsigned RdOff;
;;;364      unsigned WrOff;
;;;365      volatile char* pDst;
;;;366      //
;;;367      // Write data to buffer and handle wrap-around if necessary
;;;368      //
;;;369      NumBytesWritten = 0u;
00000a  f04f0800          MOV      r8,#0
;;;370      WrOff = pRing->WrOff;
00000e  68ec              LDR      r4,[r5,#0xc]
                  |L36.16|
;;;371      do {
;;;372        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000010  6928              LDR      r0,[r5,#0x10]
;;;373        if (RdOff > WrOff) {
000012  42a0              CMP      r0,r4
000014  d902              BLS      |L36.28|
;;;374          NumBytesToWrite = RdOff - WrOff - 1u;
000016  1b06              SUBS     r6,r0,r4
000018  1e76              SUBS     r6,r6,#1
00001a  e003              B        |L36.36|
                  |L36.28|
;;;375        } else {
;;;376          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
00001c  68a9              LDR      r1,[r5,#8]
00001e  1a20              SUBS     r0,r4,r0
000020  1a0e              SUBS     r6,r1,r0
000022  1e76              SUBS     r6,r6,#1
                  |L36.36|
;;;377        }
;;;378        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
000024  68a8              LDR      r0,[r5,#8]
000026  1b00              SUBS     r0,r0,r4
000028  42b0              CMP      r0,r6
00002a  d800              BHI      |L36.46|
00002c  4606              MOV      r6,r0
                  |L36.46|
;;;379        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00002e  42be              CMP      r6,r7
000030  d300              BCC      |L36.52|
000032  463e              MOV      r6,r7
                  |L36.52|
;;;380        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
000034  6868              LDR      r0,[r5,#4]
000036  4420              ADD      r0,r0,r4
;;;381    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;382        NumBytesWritten += NumBytesToWrite;
;;;383        NumBytes        -= NumBytesToWrite;
;;;384        WrOff           += NumBytesToWrite;
;;;385        while (NumBytesToWrite--) {
;;;386          *pDst++ = *pBuffer++;
;;;387        };
;;;388    #else
;;;389        SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
000038  4632              MOV      r2,r6
00003a  4649              MOV      r1,r9
00003c  f7fffffe          BL       __aeabi_memcpy
;;;390        NumBytesWritten += NumBytesToWrite;
000040  44b0              ADD      r8,r8,r6
;;;391        pBuffer         += NumBytesToWrite;
000042  44b1              ADD      r9,r9,r6
;;;392        NumBytes        -= NumBytesToWrite;
000044  1bbf              SUBS     r7,r7,r6
;;;393        WrOff           += NumBytesToWrite;
000046  4434              ADD      r4,r4,r6
;;;394    #endif
;;;395        if (WrOff == pRing->SizeOfBuffer) {
000048  68a8              LDR      r0,[r5,#8]
00004a  42a0              CMP      r0,r4
00004c  d100              BNE      |L36.80|
;;;396          WrOff = 0u;
00004e  2400              MOVS     r4,#0
                  |L36.80|
;;;397        }
;;;398        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;399        pRing->WrOff = WrOff;
000050  60ec              STR      r4,[r5,#0xc]
;;;400      } while (NumBytes);
000052  2f00              CMP      r7,#0
000054  d1dc              BNE      |L36.16|
;;;401      return NumBytesWritten;
000056  4640              MOV      r0,r8
;;;402    }
000058  e8bd87f0          POP      {r4-r10,pc}
;;;403    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;421    */
;;;422    static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;423      unsigned NumBytesAtOnce;
;;;424      unsigned WrOff;
;;;425      unsigned Rem;
;;;426      volatile char* pDst;
;;;427    
;;;428      WrOff = pRing->WrOff;
00000a  68e7              LDR      r7,[r4,#0xc]
;;;429      Rem = pRing->SizeOfBuffer - WrOff;
00000c  68a0              LDR      r0,[r4,#8]
00000e  1bc5              SUBS     r5,r0,r7
000010  68e1              LDR      r1,[r4,#0xc]          ;428
;;;430      if (Rem > NumBytes) {
;;;431        //
;;;432        // All data fits before wrap around
;;;433        //
;;;434        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
000012  6860              LDR      r0,[r4,#4]
000014  42b5              CMP      r5,r6                 ;430
000016  4408              ADD      r0,r0,r1
000018  d907              BLS      |L37.42|
;;;435    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;436        WrOff += NumBytes;
;;;437        while (NumBytes--) {
;;;438          *pDst++ = *pData++;
;;;439        };
;;;440        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;441        pRing->WrOff = WrOff;
;;;442    #else
;;;443        SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
00001a  4632              MOV      r2,r6
00001c  4641              MOV      r1,r8
00001e  f7fffffe          BL       __aeabi_memcpy
;;;444        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;445        pRing->WrOff = WrOff + NumBytes;
000022  19b8              ADDS     r0,r7,r6
000024  60e0              STR      r0,[r4,#0xc]
                  |L37.38|
;;;446    #endif
;;;447      } else {
;;;448        //
;;;449        // We reach the end of the buffer, so need to wrap around
;;;450        //
;;;451    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;452        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
;;;453        NumBytesAtOnce = Rem;
;;;454        while (NumBytesAtOnce--) {
;;;455          *pDst++ = *pData++;
;;;456        };
;;;457        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
;;;458        NumBytesAtOnce = NumBytes - Rem;
;;;459        while (NumBytesAtOnce--) {
;;;460          *pDst++ = *pData++;
;;;461        };
;;;462        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;463        pRing->WrOff = NumBytes - Rem;
;;;464    #else
;;;465        NumBytesAtOnce = Rem;
;;;466        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
;;;467        SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
;;;468        NumBytesAtOnce = NumBytes - Rem;
;;;469        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
;;;470        SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
;;;471        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;472        pRing->WrOff = NumBytesAtOnce;
;;;473    #endif
;;;474      }
;;;475    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L37.42|
00002a  462a              MOV      r2,r5                 ;465
00002c  4641              MOV      r1,r8                 ;467
00002e  f7fffffe          BL       __aeabi_memcpy
000032  1b76              SUBS     r6,r6,r5              ;468
000034  6860              LDR      r0,[r4,#4]            ;469
000036  eb080105          ADD      r1,r8,r5              ;470
00003a  4632              MOV      r2,r6                 ;470
00003c  f7fffffe          BL       __aeabi_memcpy
000040  60e6              STR      r6,[r4,#0xc]          ;472
000042  e7f0              B        |L37.38|
;;;476    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _SEGGER_RTT
                          %        168
                  _acUpBuffer
                          %        1024
                  _acDownBuffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  _ActiveTerminal
000000  00                DCB      0x00
                  _aTerminalId
000001  303132            DCB      0x30,0x31,0x32
000004  33343536          DCB      0x33,0x34,0x35,0x36
000008  37383941          DCB      0x37,0x38,0x39,0x41
00000c  42434445          DCB      0x42,0x43,0x44,0x45
000010  46                DCB      0x46
