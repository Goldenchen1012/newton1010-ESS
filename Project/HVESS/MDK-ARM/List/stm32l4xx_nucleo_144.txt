; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_nucleo_144.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_nucleo_144.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ../../../Drivers/BSP/STM32L4xx_Nucleo_144/stm32l4xx_nucleo_144.c]
                          THUMB

                          AREA ||i.ADCx_DeInit||, CODE, READONLY, ALIGN=2

                  ADCx_DeInit PROC
;;;1164     */
;;;1165   static void ADCx_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;1166   {
;;;1167     hnucleo_Adc.Instance   = NUCLEO_ADCx;
000002  4906              LDR      r1,|L1.28|
000004  4804              LDR      r0,|L1.24|
000006  6008              STR      r0,[r1,#0]  ; hnucleo_Adc
;;;1168   
;;;1169     HAL_ADC_DeInit(&hnucleo_Adc);
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       HAL_ADC_DeInit
;;;1170     ADCx_MspDeInit(&hnucleo_Adc);
00000e  e8bd4010          POP      {r4,lr}
000012  4802              LDR      r0,|L1.28|
000014  f7ffbffe          B.W      ADCx_MspDeInit
;;;1171   }
;;;1172   
                          ENDP

                  |L1.24|
                          DCD      0x50040000
                  |L1.28|
                          DCD      ||.bss||+0x64

                          AREA ||i.ADCx_Init||, CODE, READONLY, ALIGN=2

                  ADCx_Init PROC
;;;1126     */
;;;1127   static void ADCx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;1128   {
;;;1129     /* Set ADC instance */
;;;1130     hnucleo_Adc.Instance                   = NUCLEO_ADCx;
000002  4c16              LDR      r4,|L2.92|
000004  4814              LDR      r0,|L2.88|
000006  6020              STR      r0,[r4,#0]  ; hnucleo_Adc
;;;1131   
;;;1132     if (HAL_ADC_GetState(&hnucleo_Adc) == HAL_ADC_STATE_RESET)
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       HAL_ADC_GetState
00000e  2800              CMP      r0,#0
000010  d121              BNE      |L2.86|
;;;1133     {
;;;1134       /* ADC Config */
;;;1135       hnucleo_Adc.Init.ClockPrescaler        = ADC_CLOCK_SYNC_PCLK_DIV4;      /* ADC clock  */
000012  f44f3040          MOV      r0,#0x30000
000016  6060              STR      r0,[r4,#4]  ; hnucleo_Adc
;;;1136       hnucleo_Adc.Init.Resolution            = ADC_RESOLUTION_12B;
000018  2000              MOVS     r0,#0
00001a  60a0              STR      r0,[r4,#8]  ; hnucleo_Adc
;;;1137       hnucleo_Adc.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
00001c  60e0              STR      r0,[r4,#0xc]  ; hnucleo_Adc
;;;1138       hnucleo_Adc.Init.ScanConvMode          = ADC_SCAN_DISABLE;              /* Sequencer disabled (ADC conversion on only 1 channel: channel set on rank 1) */
00001e  6120              STR      r0,[r4,#0x10]  ; hnucleo_Adc
;;;1139       hnucleo_Adc.Init.EOCSelection          = ADC_EOC_SINGLE_CONV;
000020  2104              MOVS     r1,#4
000022  6161              STR      r1,[r4,#0x14]  ; hnucleo_Adc
;;;1140       hnucleo_Adc.Init.LowPowerAutoWait      = DISABLE;
000024  7620              STRB     r0,[r4,#0x18]
;;;1141       hnucleo_Adc.Init.ContinuousConvMode    = DISABLE;                       /* Continuous mode disabled to have only 1 conversion at each conversion trig */
000026  7660              STRB     r0,[r4,#0x19]
;;;1142       hnucleo_Adc.Init.NbrOfConversion       = 1;                             /* Parameter discarded because sequencer is disabled */
000028  2101              MOVS     r1,#1
00002a  61e1              STR      r1,[r4,#0x1c]  ; hnucleo_Adc
;;;1143       hnucleo_Adc.Init.DiscontinuousConvMode = DISABLE;                       /* Parameter discarded because sequencer is disabled */
00002c  f8840020          STRB     r0,[r4,#0x20]
;;;1144       hnucleo_Adc.Init.NbrOfDiscConversion   = 1;                             /* Parameter discarded because sequencer is disabled */
000030  6261              STR      r1,[r4,#0x24]  ; hnucleo_Adc
;;;1145       hnucleo_Adc.Init.ExternalTrigConv      = ADC_SOFTWARE_START;            /* Software start to trig the 1st conversion manually, without external event */
000032  62a0              STR      r0,[r4,#0x28]  ; hnucleo_Adc
;;;1146       hnucleo_Adc.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE; /* Parameter discarded because trig by software start */
000034  62e0              STR      r0,[r4,#0x2c]  ; hnucleo_Adc
;;;1147       hnucleo_Adc.Init.DMAContinuousRequests = DISABLE;
000036  f8840030          STRB     r0,[r4,#0x30]
;;;1148       hnucleo_Adc.Init.Overrun               = ADC_OVR_DATA_OVERWRITTEN;
00003a  0308              LSLS     r0,r1,#12
00003c  6360              STR      r0,[r4,#0x34]  ; hnucleo_Adc
;;;1149   
;;;1150       /* Initialize MSP related to ADC */
;;;1151       ADCx_MspInit(&hnucleo_Adc);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       ADCx_MspInit
;;;1152   
;;;1153       /* Initialize ADC */
;;;1154       HAL_ADC_Init(&hnucleo_Adc);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_ADC_Init
;;;1155   
;;;1156       /* Run ADC calibration */
;;;1157       HAL_ADCEx_Calibration_Start(&hnucleo_Adc, ADC_SINGLE_ENDED);
00004a  4620              MOV      r0,r4
00004c  e8bd4010          POP      {r4,lr}
000050  217f              MOVS     r1,#0x7f
000052  f7ffbffe          B.W      HAL_ADCEx_Calibration_Start
                  |L2.86|
;;;1158     }
;;;1159   }
000056  bd10              POP      {r4,pc}
;;;1160   
                          ENDP

                  |L2.88|
                          DCD      0x50040000
                  |L2.92|
                          DCD      ||.bss||+0x64

                          AREA ||i.ADCx_MspDeInit||, CODE, READONLY, ALIGN=2

                  ADCx_MspDeInit PROC
;;;1106     */
;;;1107   static void ADCx_MspDeInit(ADC_HandleTypeDef *hadc)
000000  4804              LDR      r0,|L3.20|
;;;1108   {
;;;1109     GPIO_InitTypeDef  GPIO_InitStruct;
;;;1110   
;;;1111     /*** DeInit the ADC peripheral ***/
;;;1112     /* Disable ADC clock */
;;;1113     NUCLEO_ADCx_CLK_DISABLE();
000002  6cc1              LDR      r1,[r0,#0x4c]
000004  f4215100          BIC      r1,r1,#0x2000
000008  64c1              STR      r1,[r0,#0x4c]
;;;1114   
;;;1115     /* Configure the selected ADC Channel as analog input */
;;;1116     GPIO_InitStruct.Pin = NUCLEO_ADCx_GPIO_PIN ;
00000a  2102              MOVS     r1,#2
;;;1117     HAL_GPIO_DeInit(NUCLEO_ADCx_GPIO_PORT, GPIO_InitStruct.Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  f7ffbffe          B.W      HAL_GPIO_DeInit
;;;1118   
;;;1119     /* Disable GPIO clock has to be done by the application*/
;;;1120     /* NUCLEO_ADCx_GPIO_CLK_DISABLE(); */
;;;1121   }
;;;1122   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000
                  |L3.24|
                          DCD      0x48000800

                          AREA ||i.ADCx_MspInit||, CODE, READONLY, ALIGN=2

                  ADCx_MspInit PROC
;;;1081     */
;;;1082   static void ADCx_MspInit(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;1083   {
000002  b086              SUB      sp,sp,#0x18
;;;1084     GPIO_InitTypeDef  GPIO_InitStruct;
;;;1085   
;;;1086     /*** Configure the GPIOs ***/
;;;1087     /* Enable GPIO clock */
;;;1088     NUCLEO_ADCx_GPIO_CLK_ENABLE();
000004  4c0e              LDR      r4,|L4.64|
000006  6ce0              LDR      r0,[r4,#0x4c]
000008  f0400004          ORR      r0,r0,#4
00000c  64e0              STR      r0,[r4,#0x4c]
00000e  6ce0              LDR      r0,[r4,#0x4c]
000010  f0000004          AND      r0,r0,#4
000014  9000              STR      r0,[sp,#0]
;;;1089   
;;;1090     /* Configure the selected ADC Channel as analog input */
;;;1091     GPIO_InitStruct.Pin = NUCLEO_ADCx_GPIO_PIN ;
000016  2002              MOVS     r0,#2
000018  9001              STR      r0,[sp,#4]
;;;1092     GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
00001a  2003              MOVS     r0,#3
00001c  9002              STR      r0,[sp,#8]
;;;1093     GPIO_InitStruct.Pull = GPIO_NOPULL;
00001e  2000              MOVS     r0,#0
000020  9003              STR      r0,[sp,#0xc]
;;;1094     HAL_GPIO_Init(NUCLEO_ADCx_GPIO_PORT, &GPIO_InitStruct);
000022  a901              ADD      r1,sp,#4
000024  4807              LDR      r0,|L4.68|
000026  f7fffffe          BL       HAL_GPIO_Init
;;;1095   
;;;1096     /*** Configure the ADC peripheral ***/
;;;1097     /* Enable ADC clock */
;;;1098     NUCLEO_ADCx_CLK_ENABLE();
00002a  6ce0              LDR      r0,[r4,#0x4c]
00002c  f4405000          ORR      r0,r0,#0x2000
000030  64e0              STR      r0,[r4,#0x4c]
000032  6ce0              LDR      r0,[r4,#0x4c]
000034  f4005000          AND      r0,r0,#0x2000
000038  9000              STR      r0,[sp,#0]
;;;1099   }
00003a  b006              ADD      sp,sp,#0x18
00003c  bd10              POP      {r4,pc}
;;;1100   
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      0x40021000
                  |L4.68|
                          DCD      0x48000800

                          AREA ||i.BSP_GetVersion||, CODE, READONLY, ALIGN=2

                  BSP_GetVersion PROC
;;;155      */
;;;156    uint32_t BSP_GetVersion(void)
000000  4800              LDR      r0,|L5.4|
;;;157    {
;;;158      return __STM32L4xx_NUCLEO_144_BSP_VERSION;
;;;159    }
000002  4770              BX       lr
;;;160    
                          ENDP

                  |L5.4|
                          DCD      0x01000800

                          AREA ||i.BSP_JOY_DeInit||, CODE, READONLY, ALIGN=1

                  BSP_JOY_DeInit PROC
;;;355      */
;;;356    void BSP_JOY_DeInit(void)
000000  f7ffbffe          B.W      ADCx_DeInit
;;;357    {
;;;358      ADCx_DeInit();
;;;359    }
;;;360    
                          ENDP


                          AREA ||i.BSP_JOY_GetState||, CODE, READONLY, ALIGN=2

                  BSP_JOY_GetState PROC
;;;372      */
;;;373    JOYState_TypeDef BSP_JOY_GetState(void)
000000  b510              PUSH     {r4,lr}
;;;374    {
;;;375      JOYState_TypeDef state;
;;;376      uint16_t  keyconvertedvalue = 0;
000002  2400              MOVS     r4,#0
;;;377    
;;;378      /* Start the conversion process */
;;;379      HAL_ADC_Start(&hnucleo_Adc);
000004  4818              LDR      r0,|L7.104|
000006  f7fffffe          BL       HAL_ADC_Start
;;;380    
;;;381      /* Wait for the end of conversion */
;;;382      if (HAL_ADC_PollForConversion(&hnucleo_Adc, 10) != HAL_TIMEOUT)
00000a  210a              MOVS     r1,#0xa
00000c  4816              LDR      r0,|L7.104|
00000e  f7fffffe          BL       HAL_ADC_PollForConversion
000012  2803              CMP      r0,#3
000014  d003              BEQ      |L7.30|
;;;383      {
;;;384        /* Get the converted value of regular channel */
;;;385        keyconvertedvalue = HAL_ADC_GetValue(&hnucleo_Adc);
000016  4814              LDR      r0,|L7.104|
000018  f7fffffe          BL       HAL_ADC_GetValue
00001c  b284              UXTH     r4,r0
                  |L7.30|
;;;386      }
;;;387    
;;;388      if ((keyconvertedvalue > 2010) && (keyconvertedvalue < 2090))
00001e  f2a470db          SUB      r0,r4,#0x7db
000022  284f              CMP      r0,#0x4f
000024  d201              BCS      |L7.42|
;;;389      {
;;;390        state = JOY_UP;
000026  2405              MOVS     r4,#5
000028  e018              B        |L7.92|
                  |L7.42|
;;;391      }
;;;392      else if ((keyconvertedvalue > 680) && (keyconvertedvalue < 780))
00002a  f2a420a9          SUB      r0,r4,#0x2a9
00002e  2863              CMP      r0,#0x63
000030  d201              BCS      |L7.54|
;;;393      {
;;;394        state = JOY_RIGHT;
000032  2404              MOVS     r4,#4
000034  e012              B        |L7.92|
                  |L7.54|
;;;395      }
;;;396      else if ((keyconvertedvalue > 1270) && (keyconvertedvalue < 1350))
000036  f2a440f7          SUB      r0,r4,#0x4f7
00003a  284f              CMP      r0,#0x4f
00003c  d201              BCS      |L7.66|
;;;397      {
;;;398        state = JOY_SEL;
00003e  2401              MOVS     r4,#1
000040  e00c              B        |L7.92|
                  |L7.66|
;;;399      }
;;;400      else if ((keyconvertedvalue > 50) && (keyconvertedvalue < 130))
000042  f1a40033          SUB      r0,r4,#0x33
000046  284f              CMP      r0,#0x4f
000048  d201              BCS      |L7.78|
;;;401      {
;;;402        state = JOY_DOWN;
00004a  2402              MOVS     r4,#2
00004c  e006              B        |L7.92|
                  |L7.78|
;;;403      }
;;;404      else if ((keyconvertedvalue > 3680) && (keyconvertedvalue < 3760))
00004e  f6a46461          SUB      r4,r4,#0xe61
000052  2c4f              CMP      r4,#0x4f
000054  d201              BCS      |L7.90|
;;;405      {
;;;406        state = JOY_LEFT;
000056  2403              MOVS     r4,#3
000058  e000              B        |L7.92|
                  |L7.90|
;;;407      }
;;;408      else
;;;409      {
;;;410        state = JOY_NONE;
00005a  2400              MOVS     r4,#0
                  |L7.92|
;;;411      }
;;;412    
;;;413      /* Loop while a key is pressed */
;;;414      if (state != JOY_NONE)
00005c  b114              CBZ      r4,|L7.100|
;;;415      {
;;;416        keyconvertedvalue = HAL_ADC_GetValue(&hnucleo_Adc);
00005e  4802              LDR      r0,|L7.104|
000060  f7fffffe          BL       HAL_ADC_GetValue
                  |L7.100|
;;;417      }
;;;418      /* Return the code of the Joystick key pressed */
;;;419      return state;
000064  4620              MOV      r0,r4
;;;420    }
000066  bd10              POP      {r4,pc}
;;;421    #endif /* HAL_ADC_MODULE_ENABLED */
                          ENDP

                  |L7.104|
                          DCD      ||.bss||+0x64

                          AREA ||i.BSP_JOY_Init||, CODE, READONLY, ALIGN=2

                  BSP_JOY_Init PROC
;;;335      */
;;;336    uint8_t BSP_JOY_Init(void)
000000  b510              PUSH     {r4,lr}
;;;337    {
;;;338      ADCx_Init();
000002  f7fffffe          BL       ADCx_Init
;;;339    
;;;340      /* Select the ADC Channel to be converted */
;;;341      sConfig.Channel      = NUCLEO_ADCx_CHANNEL;
000006  480a              LDR      r0,|L8.48|
000008  4908              LDR      r1,|L8.44|
00000a  6001              STR      r1,[r0,#0]  ; sConfig
;;;342      sConfig.Rank         = ADC_REGULAR_RANK_1;
00000c  2106              MOVS     r1,#6
00000e  6041              STR      r1,[r0,#4]  ; sConfig
;;;343      sConfig.SamplingTime = NUCLEO_ADCx_SAMPLETIME;
000010  2103              MOVS     r1,#3
000012  6081              STR      r1,[r0,#8]  ; sConfig
;;;344      sConfig.SingleDiff   = ADC_SINGLE_ENDED;
000014  217f              MOVS     r1,#0x7f
000016  60c1              STR      r1,[r0,#0xc]  ; sConfig
;;;345      sConfig.OffsetNumber = ADC_OFFSET_NONE;
000018  2104              MOVS     r1,#4
00001a  6101              STR      r1,[r0,#0x10]  ; sConfig
;;;346      sConfig.Offset       = 0;
00001c  2100              MOVS     r1,#0
00001e  6141              STR      r1,[r0,#0x14]  ; sConfig
;;;347    
;;;348      /* Return Joystick initialization status */
;;;349      return (uint8_t)HAL_ADC_ConfigChannel(&hnucleo_Adc, &sConfig);
000020  4601              MOV      r1,r0
000022  e8bd4010          POP      {r4,lr}
000026  3868              SUBS     r0,r0,#0x68
000028  f7ffbffe          B.W      HAL_ADC_ConfigChannel
;;;350    }
;;;351    
                          ENDP

                  |L8.44|
                          DCD      0x08600004
                  |L8.48|
                          DCD      ||.bss||+0xcc

                          AREA ||i.BSP_LED_DeInit||, CODE, READONLY, ALIGN=2

                  BSP_LED_DeInit PROC
;;;200      */
;;;201    void BSP_LED_DeInit(Led_TypeDef Led)
000000  b570              PUSH     {r4-r6,lr}
;;;202    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;203      GPIO_InitTypeDef  GPIO_InitStruct;
;;;204    
;;;205      /* Turn off LED */
;;;206      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
000006  4e09              LDR      r6,|L9.44|
000008  4d09              LDR      r5,|L9.48|
00000a  2200              MOVS     r2,#0
00000c  f8361014          LDRH     r1,[r6,r4,LSL #1]
000010  f8550024          LDR      r0,[r5,r4,LSL #2]
000014  f7fffffe          BL       HAL_GPIO_WritePin
;;;207      /* DeInit the GPIO_LED pin */
;;;208      GPIO_InitStruct.Pin = GPIO_PIN[Led];
000018  f8361014          LDRH     r1,[r6,r4,LSL #1]
00001c  9101              STR      r1,[sp,#4]
;;;209      HAL_GPIO_DeInit(GPIO_PORT[Led], GPIO_InitStruct.Pin);
00001e  f8550024          LDR      r0,[r5,r4,LSL #2]
000022  b006              ADD      sp,sp,#0x18
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      HAL_GPIO_DeInit
;;;210    }
;;;211    
                          ENDP

                  |L9.44|
                          DCD      ||.constdata||+0x4
                  |L9.48|
                          DCD      ||.data||+0x8

                          AREA ||i.BSP_LED_Init||, CODE, READONLY, ALIGN=2

                  BSP_LED_Init PROC
;;;173      */
;;;174    void BSP_LED_Init(Led_TypeDef Led)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;176      GPIO_InitTypeDef  GPIO_InitStruct;
;;;177    
;;;178      /* Enable the GPIO_LED Clock */
;;;179      LEDx_GPIO_CLK_ENABLE(Led);
000006  4816              LDR      r0,|L10.96|
000008  2c00              CMP      r4,#0
00000a  d020              BEQ      |L10.78|
00000c  6cc1              LDR      r1,[r0,#0x4c]
00000e  f0410102          ORR      r1,r1,#2
000012  64c1              STR      r1,[r0,#0x4c]
000014  6cc0              LDR      r0,[r0,#0x4c]
000016  f0000002          AND      r0,r0,#2
00001a  9000              STR      r0,[sp,#0]
                  |L10.28|
;;;180    
;;;181      /* Configure the GPIO_LED pin */
;;;182      GPIO_InitStruct.Pin = GPIO_PIN[Led];
00001c  4d11              LDR      r5,|L10.100|
00001e  f8350014          LDRH     r0,[r5,r4,LSL #1]
000022  9001              STR      r0,[sp,#4]
;;;183      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
000024  2001              MOVS     r0,#1
000026  9002              STR      r0,[sp,#8]
;;;184      GPIO_InitStruct.Pull = GPIO_NOPULL;
000028  2000              MOVS     r0,#0
00002a  9003              STR      r0,[sp,#0xc]
;;;185      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
00002c  2002              MOVS     r0,#2
00002e  9004              STR      r0,[sp,#0x10]
;;;186    
;;;187      HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
000030  4e0d              LDR      r6,|L10.104|
000032  a901              ADD      r1,sp,#4
000034  f8560024          LDR      r0,[r6,r4,LSL #2]
000038  f7fffffe          BL       HAL_GPIO_Init
;;;188      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
00003c  f8351014          LDRH     r1,[r5,r4,LSL #1]
000040  f8560024          LDR      r0,[r6,r4,LSL #2]
000044  2200              MOVS     r2,#0
000046  f7fffffe          BL       HAL_GPIO_WritePin
;;;189    }
00004a  b006              ADD      sp,sp,#0x18
00004c  bd70              POP      {r4-r6,pc}
                  |L10.78|
00004e  6cc1              LDR      r1,[r0,#0x4c]         ;179
000050  f0410104          ORR      r1,r1,#4              ;179
000054  64c1              STR      r1,[r0,#0x4c]         ;179
000056  6cc0              LDR      r0,[r0,#0x4c]         ;179
000058  f0000004          AND      r0,r0,#4              ;179
00005c  9000              STR      r0,[sp,#0]            ;179
00005e  e7dd              B        |L10.28|
;;;190    
                          ENDP

                  |L10.96|
                          DCD      0x40021000
                  |L10.100|
                          DCD      ||.constdata||+0x4
                  |L10.104|
                          DCD      ||.data||+0x8

                          AREA ||i.BSP_LED_Off||, CODE, READONLY, ALIGN=2

                  BSP_LED_Off PROC
;;;234      */
;;;235    void BSP_LED_Off(Led_TypeDef Led)
000000  4904              LDR      r1,|L11.20|
;;;236    {
;;;237      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
000002  4a05              LDR      r2,|L11.24|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  2200              MOVS     r2,#0
00000e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;238    }
;;;239    
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      ||.constdata||+0x4
                  |L11.24|
                          DCD      ||.data||+0x8

                          AREA ||i.BSP_LED_On||, CODE, READONLY, ALIGN=2

                  BSP_LED_On PROC
;;;220      */
;;;221    void BSP_LED_On(Led_TypeDef Led)
000000  4904              LDR      r1,|L12.20|
;;;222    {
;;;223      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET);
000002  4a05              LDR      r2,|L12.24|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  2201              MOVS     r2,#1
00000e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;224    }
;;;225    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      ||.constdata||+0x4
                  |L12.24|
                          DCD      ||.data||+0x8

                          AREA ||i.BSP_LED_Toggle||, CODE, READONLY, ALIGN=2

                  BSP_LED_Toggle PROC
;;;248      */
;;;249    void BSP_LED_Toggle(Led_TypeDef Led)
000000  4903              LDR      r1,|L13.16|
;;;250    {
;;;251      HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
000002  4a04              LDR      r2,|L13.20|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  f7ffbffe          B.W      HAL_GPIO_TogglePin
;;;252    }
;;;253    
                          ENDP

                  |L13.16|
                          DCD      ||.constdata||+0x4
                  |L13.20|
                          DCD      ||.data||+0x8

                          AREA ||i.BSP_PB_DeInit||, CODE, READONLY, ALIGN=2

                  BSP_PB_DeInit PROC
;;;309      */
;;;310    void BSP_PB_DeInit(Button_TypeDef Button)
000000  b510              PUSH     {r4,lr}
;;;311    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;312      GPIO_InitTypeDef GPIO_InitStruct;
;;;313    
;;;314      GPIO_InitStruct.Pin = BUTTON_PIN[Button];
000006  4809              LDR      r0,|L14.44|
000008  f8300014          LDRH     r0,[r0,r4,LSL #1]
00000c  9001              STR      r0,[sp,#4]
;;;315      HAL_NVIC_DisableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
00000e  4807              LDR      r0,|L14.44|
000010  1e80              SUBS     r0,r0,#2
000012  5700              LDRSB    r0,[r0,r4]
000014  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;316      HAL_GPIO_DeInit(BUTTON_PORT[Button], GPIO_InitStruct.Pin);
000018  4805              LDR      r0,|L14.48|
00001a  9901              LDR      r1,[sp,#4]
00001c  f8500024          LDR      r0,[r0,r4,LSL #2]
000020  b006              ADD      sp,sp,#0x18
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      HAL_GPIO_DeInit
;;;317    }
;;;318    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      ||.constdata||+0x2
                  |L14.48|
                          DCD      ||.data||

                          AREA ||i.BSP_PB_GetState||, CODE, READONLY, ALIGN=2

                  BSP_PB_GetState PROC
;;;324      */
;;;325    uint32_t BSP_PB_GetState(Button_TypeDef Button)
000000  4903              LDR      r1,|L15.16|
;;;326    {
;;;327      return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
000002  4a04              LDR      r2,|L15.20|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  f7ffbffe          B.W      HAL_GPIO_ReadPin
;;;328    }
;;;329    
                          ENDP

                  |L15.16|
                          DCD      ||.constdata||+0x2
                  |L15.20|
                          DCD      ||.data||

                          AREA ||i.BSP_PB_Init||, CODE, READONLY, ALIGN=2

                  BSP_PB_Init PROC
;;;272      */
;;;273    void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
000000  b530              PUSH     {r4,r5,lr}
;;;274    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;275      GPIO_InitTypeDef GPIO_InitStruct;
;;;276    
;;;277      /* Enable the BUTTON Clock */
;;;278      BUTTONx_GPIO_CLK_ENABLE(Button);
000006  481a              LDR      r0,|L16.112|
000008  6cc2              LDR      r2,[r0,#0x4c]
00000a  f0420204          ORR      r2,r2,#4
00000e  64c2              STR      r2,[r0,#0x4c]
000010  6cc0              LDR      r0,[r0,#0x4c]
000012  f0000004          AND      r0,r0,#4
000016  9001              STR      r0,[sp,#4]
;;;279    
;;;280      if (ButtonMode == BUTTON_MODE_GPIO)
000018  2200              MOVS     r2,#0
;;;281      {
;;;282        /* Configure Button pin as input */
;;;283        GPIO_InitStruct.Pin = BUTTON_PIN[Button];
00001a  4816              LDR      r0,|L16.116|
;;;284        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
;;;285        GPIO_InitStruct.Pull = GPIO_PULLDOWN;
;;;286        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
;;;287        HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
00001c  4b16              LDR      r3,|L16.120|
00001e  2900              CMP      r1,#0                 ;280
000020  d018              BEQ      |L16.84|
;;;288      }
;;;289      else if (ButtonMode == BUTTON_MODE_EXTI)
000022  2901              CMP      r1,#1
000024  d114              BNE      |L16.80|
;;;290      {
;;;291        /* Configure Button pin as input with External interrupt */
;;;292        GPIO_InitStruct.Pin = BUTTON_PIN[Button];
000026  f8300014          LDRH     r0,[r0,r4,LSL #1]
00002a  9002              STR      r0,[sp,#8]
;;;293        GPIO_InitStruct.Pull = GPIO_NOPULL;
00002c  9204              STR      r2,[sp,#0x10]
;;;294        GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
00002e  4813              LDR      r0,|L16.124|
000030  9003              STR      r0,[sp,#0xc]
;;;295        HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
000032  f8530024          LDR      r0,[r3,r4,LSL #2]
000036  a902              ADD      r1,sp,#8
000038  f7fffffe          BL       HAL_GPIO_Init
;;;296    
;;;297        /* Enable and set Button EXTI Interrupt to the lowest priority */
;;;298        HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
00003c  4d0d              LDR      r5,|L16.116|
00003e  2200              MOVS     r2,#0
000040  1ead              SUBS     r5,r5,#2
000042  210f              MOVS     r1,#0xf
000044  5728              LDRSB    r0,[r5,r4]
000046  f7fffffe          BL       HAL_NVIC_SetPriority
;;;299        HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
00004a  5728              LDRSB    r0,[r5,r4]
00004c  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L16.80|
;;;300      }
;;;301    }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
                  |L16.84|
000054  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;283
000058  9002              STR      r0,[sp,#8]            ;283
00005a  9203              STR      r2,[sp,#0xc]          ;284
00005c  2002              MOVS     r0,#2                 ;285
00005e  9004              STR      r0,[sp,#0x10]         ;285
000060  9005              STR      r0,[sp,#0x14]         ;286
000062  f8530024          LDR      r0,[r3,r4,LSL #2]     ;287
000066  a902              ADD      r1,sp,#8              ;287
000068  f7fffffe          BL       HAL_GPIO_Init
00006c  e7f0              B        |L16.80|
;;;302    
                          ENDP

00006e  0000              DCW      0x0000
                  |L16.112|
                          DCD      0x40021000
                  |L16.116|
                          DCD      ||.constdata||+0x2
                  |L16.120|
                          DCD      ||.data||
                  |L16.124|
                          DCD      0x10210000

                          AREA ||i.BSP_SMPS_DeInit||, CODE, READONLY, ALIGN=2

                  BSP_SMPS_DeInit PROC
;;;442      */
;;;443    uint32_t BSP_SMPS_DeInit(void)
000000  b530              PUSH     {r4,r5,lr}
;;;444    {
000002  b087              SUB      sp,sp,#0x1c
;;;445      GPIO_InitTypeDef GPIO_InitStruct;
;;;446    
;;;447      PWR_AND_CLK_SMPS();
000004  4c1b              LDR      r4,|L17.116|
000006  6da0              LDR      r0,[r4,#0x58]
000008  f0405080          ORR      r0,r0,#0x10000000
00000c  65a0              STR      r0,[r4,#0x58]
00000e  6da0              LDR      r0,[r4,#0x58]
000010  f0005080          AND      r0,r0,#0x10000000
000014  9001              STR      r0,[sp,#4]
000016  f7fffffe          BL       HAL_PWREx_EnableVddIO2
00001a  6ce0              LDR      r0,[r4,#0x4c]
00001c  f0400040          ORR      r0,r0,#0x40
000020  64e0              STR      r0,[r4,#0x4c]
000022  6ce0              LDR      r0,[r4,#0x4c]
000024  f0000040          AND      r0,r0,#0x40
000028  9001              STR      r0,[sp,#4]
;;;448    
;;;449      /* --------------------------------------------------------------------------------------  */
;;;450      /* Added for Deinit if No PIN_SMPS_ENABLE & PIN_SMPS_SWITCH_ENABLE are not disabled before */
;;;451    
;;;452      /* Disable SMPS SWITCH */
;;;453      HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_SWITCH_ENABLE, GPIO_PIN_RESET);
00002a  4d13              LDR      r5,|L17.120|
00002c  f44f5400          MOV      r4,#0x2000
000030  2200              MOVS     r2,#0
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       HAL_GPIO_WritePin
;;;454    
;;;455      HAL_Delay(1);
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       HAL_Delay
;;;456    
;;;457      /* Disable SMPS */
;;;458      HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_ENABLE, GPIO_PIN_RESET);
000040  2200              MOVS     r2,#0
000042  10a1              ASRS     r1,r4,#2
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       HAL_GPIO_WritePin
;;;459    
;;;460      /* --------------------------------------------------------------------------------------  */
;;;461    
;;;462      /* To be updated */
;;;463      /* Set all GPIO in analog state to reduce power consumption, */
;;;464      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
00004a  2201              MOVS     r2,#1
00004c  9203              STR      r2,[sp,#0xc]
;;;465    
;;;466      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
00004e  2200              MOVS     r2,#0
000050  9205              STR      r2,[sp,#0x14]
;;;467      GPIO_InitStruct.Pull = GPIO_NOPULL;
000052  9204              STR      r2,[sp,#0x10]
;;;468    
;;;469      GPIO_InitStruct.Pin = PIN_SMPS_SWITCH_ENABLE;
000054  9402              STR      r4,[sp,#8]
;;;470    
;;;471      /* SWITCH */
;;;472      HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
000056  a902              ADD      r1,sp,#8
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       HAL_GPIO_Init
;;;473    
;;;474      GPIO_InitStruct.Pin = PIN_SMPS_ENABLE | PIN_SMPS_SWITCH_ENABLE;
00005e  f44f5120          MOV      r1,#0x2800
000062  9102              STR      r1,[sp,#8]
;;;475      /* --------- SMPS VOLTAGE RANGE SELECTION ----------------------------------*/
;;;476      /* ######################################################################## */
;;;477      /* GPIO_InitStruct.Pin = PIN_SMPS_ENABLE | PIN_SMPS_SWITCH_ENABLE | PIN_SMPS_V1; */
;;;478    
;;;479      /* ENABLE = OFF */
;;;480      HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
000064  a902              ADD      r1,sp,#8
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       HAL_GPIO_Init
;;;481    
;;;482      return SMPS_OK;
;;;483    }
00006c  b007              ADD      sp,sp,#0x1c
00006e  2000              MOVS     r0,#0                 ;482
000070  bd30              POP      {r4,r5,pc}
;;;484    
                          ENDP

000072  0000              DCW      0x0000
                  |L17.116|
                          DCD      0x40021000
                  |L17.120|
                          DCD      0x48001800

                          AREA ||i.BSP_SMPS_Disable||, CODE, READONLY, ALIGN=2

                  BSP_SMPS_Disable PROC
;;;611      */
;;;612    uint32_t BSP_SMPS_Disable(void)
000000  b538              PUSH     {r3-r5,lr}
;;;613    {
;;;614    
;;;615      PWR_AND_CLK_SMPS();
000002  4c15              LDR      r4,|L18.88|
000004  6da0              LDR      r0,[r4,#0x58]
000006  f0405080          ORR      r0,r0,#0x10000000
00000a  65a0              STR      r0,[r4,#0x58]
00000c  6da0              LDR      r0,[r4,#0x58]
00000e  f0005080          AND      r0,r0,#0x10000000
000012  9000              STR      r0,[sp,#0]
000014  f7fffffe          BL       HAL_PWREx_EnableVddIO2
000018  6ce0              LDR      r0,[r4,#0x4c]
00001a  f0400040          ORR      r0,r0,#0x40
00001e  64e0              STR      r0,[r4,#0x4c]
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  f0000040          AND      r0,r0,#0x40
000026  9000              STR      r0,[sp,#0]
;;;616    
;;;617      /* Check if SWITCH is DISABLE */
;;;618      if (HAL_GPIO_ReadPin(PORT_SMPS, PIN_SMPS_SWITCH_ENABLE) != GPIO_PIN_RESET)
000028  4d0c              LDR      r5,|L18.92|
00002a  f44f5100          MOV      r1,#0x2000
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       HAL_GPIO_ReadPin
000034  b108              CBZ      r0,|L18.58|
;;;619      {
;;;620        /* ERROR AS SWITCH SHOULD BE DISABLED */
;;;621        return SMPS_KO;
000036  2001              MOVS     r0,#1
;;;622      }
;;;623    
;;;624      /* Disable SMPS */
;;;625      HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_ENABLE, GPIO_PIN_RESET);
;;;626    
;;;627      HAL_PWREx_EnableGPIOPullDown(PWR_GPIO_SMPS, PWR_GPIO_ENABLE);
;;;628      HAL_PWREx_EnablePullUpPullDownConfig();
;;;629    
;;;630      /* SMPS DISABLED */
;;;631      return SMPS_OK;
;;;632    }
000038  bd38              POP      {r3-r5,pc}
                  |L18.58|
00003a  f44f6400          MOV      r4,#0x800             ;625
00003e  2200              MOVS     r2,#0                 ;625
000040  4621              MOV      r1,r4                 ;625
000042  4628              MOV      r0,r5                 ;625
000044  f7fffffe          BL       HAL_GPIO_WritePin
000048  4621              MOV      r1,r4                 ;627
00004a  2006              MOVS     r0,#6                 ;627
00004c  f7fffffe          BL       HAL_PWREx_EnableGPIOPullDown
000050  f7fffffe          BL       HAL_PWREx_EnablePullUpPullDownConfig
000054  2000              MOVS     r0,#0                 ;631
000056  bd38              POP      {r3-r5,pc}
;;;633    
                          ENDP

                  |L18.88|
                          DCD      0x40021000
                  |L18.92|
                          DCD      0x48001800

                          AREA ||i.BSP_SMPS_Enable||, CODE, READONLY, ALIGN=2

                  BSP_SMPS_Enable PROC
;;;574      */
;;;575    uint32_t BSP_SMPS_Enable(uint32_t Delay, uint32_t Power_Good_Check)
000000  b5f8              PUSH     {r3-r7,lr}
;;;576    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;577      PWR_AND_CLK_SMPS();
000006  4c17              LDR      r4,|L19.100|
000008  6da0              LDR      r0,[r4,#0x58]
00000a  f0405080          ORR      r0,r0,#0x10000000
00000e  65a0              STR      r0,[r4,#0x58]
000010  6da0              LDR      r0,[r4,#0x58]
000012  f0005080          AND      r0,r0,#0x10000000
000016  9000              STR      r0,[sp,#0]
000018  f7fffffe          BL       HAL_PWREx_EnableVddIO2
00001c  6ce0              LDR      r0,[r4,#0x4c]
00001e  f0400040          ORR      r0,r0,#0x40
000022  64e0              STR      r0,[r4,#0x4c]
000024  6ce0              LDR      r0,[r4,#0x4c]
000026  f0000040          AND      r0,r0,#0x40
00002a  9000              STR      r0,[sp,#0]
;;;578    
;;;579      HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_ENABLE, GPIO_PIN_SET);
00002c  2201              MOVS     r2,#1
00002e  4f0e              LDR      r7,|L19.104|
000030  02d4              LSLS     r4,r2,#11
000032  4621              MOV      r1,r4
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       HAL_GPIO_WritePin
;;;580    
;;;581      HAL_PWREx_EnableGPIOPullUp(PWR_GPIO_SMPS, PWR_GPIO_BIT_11);
00003a  4621              MOV      r1,r4
00003c  2006              MOVS     r0,#6
00003e  f7fffffe          BL       HAL_PWREx_EnableGPIOPullUp
;;;582      HAL_PWREx_EnablePullUpPullDownConfig();
000042  f7fffffe          BL       HAL_PWREx_EnablePullUpPullDownConfig
;;;583    
;;;584      /* Delay upon request */
;;;585      if (Delay != 0)
000046  b115              CBZ      r5,|L19.78|
;;;586      {
;;;587        HAL_Delay(Delay);
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       HAL_Delay
                  |L19.78|
;;;588      }
;;;589    
;;;590      /* CHECK POWER GOOD or NOT */
;;;591      if (Power_Good_Check != 0)
00004e  b12e              CBZ      r6,|L19.92|
;;;592      {
;;;593        if (GPIO_PIN_RESET == (HAL_GPIO_ReadPin(PORT_SMPS, PIN_SMPS_POWERGOOD)))
000050  f44f5180          MOV      r1,#0x1000
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       HAL_GPIO_ReadPin
00005a  b108              CBZ      r0,|L19.96|
                  |L19.92|
;;;594        {
;;;595          /* POWER GOOD KO */
;;;596          return SMPS_KO;
;;;597        }
;;;598      }
;;;599    
;;;600      /* SMPS ENABLED */
;;;601      return SMPS_OK;
00005c  2000              MOVS     r0,#0
;;;602    }
00005e  bdf8              POP      {r3-r7,pc}
                  |L19.96|
000060  2001              MOVS     r0,#1                 ;596
000062  bdf8              POP      {r3-r7,pc}
;;;603    
                          ENDP

                  |L19.100|
                          DCD      0x40021000
                  |L19.104|
                          DCD      0x48001800

                          AREA ||i.BSP_SMPS_Init||, CODE, READONLY, ALIGN=2

                  BSP_SMPS_Init PROC
;;;493      */
;;;494    uint32_t BSP_SMPS_Init(uint32_t VoltageRange)
000000  b570              PUSH     {r4-r6,lr}
;;;495    {
000002  b086              SUB      sp,sp,#0x18
;;;496      PWR_AND_CLK_SMPS();
000004  4c22              LDR      r4,|L20.144|
000006  6da0              LDR      r0,[r4,#0x58]
000008  f0405080          ORR      r0,r0,#0x10000000
00000c  65a0              STR      r0,[r4,#0x58]
00000e  6da0              LDR      r0,[r4,#0x58]
000010  f0005080          AND      r0,r0,#0x10000000
000014  9000              STR      r0,[sp,#0]
000016  f7fffffe          BL       HAL_PWREx_EnableVddIO2
00001a  6ce0              LDR      r0,[r4,#0x4c]
00001c  f0400040          ORR      r0,r0,#0x40
000020  64e0              STR      r0,[r4,#0x4c]
000022  6ce0              LDR      r0,[r4,#0x4c]
000024  f0000040          AND      r0,r0,#0x40
000028  9000              STR      r0,[sp,#0]
;;;497    
;;;498      GPIO_InitTypeDef GPIO_InitStruct;
;;;499    
;;;500      /* Upon wake UP (standby case)                               */
;;;501      /* IF PIN_SMPS_ENABLE was pulled up                          */
;;;502      /* Then maintain PIN_SMPS_ENABLE = high                      */
;;;503      /* Needed to keep ENABLE HIGH                                */
;;;504      if (READ_BIT(PWR->PUCRG, PWR_GPIO_ENABLE))
00002a  481a              LDR      r0,|L20.148|
00002c  6d00              LDR      r0,[r0,#0x50]
;;;505      {
;;;506        HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_ENABLE, GPIO_PIN_SET);
00002e  4e1a              LDR      r6,|L20.152|
000030  0501              LSLS     r1,r0,#20             ;504
000032  d505              BPL      |L20.64|
000034  2201              MOVS     r2,#1
000036  02d1              LSLS     r1,r2,#11
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       HAL_GPIO_WritePin
00003e  e00f              B        |L20.96|
                  |L20.64|
;;;507      }
;;;508      else
;;;509      {
;;;510        HAL_PWREx_EnableGPIOPullDown(PWR_GPIO_SMPS, PWR_GPIO_SWITCH_ENABLE);
000040  f44f5400          MOV      r4,#0x2000
000044  4621              MOV      r1,r4
000046  2006              MOVS     r0,#6
000048  f7fffffe          BL       HAL_PWREx_EnableGPIOPullDown
;;;511        HAL_PWREx_EnablePullUpPullDownConfig();
00004c  f7fffffe          BL       HAL_PWREx_EnablePullUpPullDownConfig
;;;512        /* Level shifter consumes because of missing pull up/down, so pull it up (only one autorized PA13) */
;;;513        HAL_PWREx_EnableGPIOPullUp(PWR_GPIO_A, GPIO_PIN_13); /* SWD/TMS */
000050  4621              MOV      r1,r4
000052  2000              MOVS     r0,#0
000054  f7fffffe          BL       HAL_PWREx_EnableGPIOPullUp
;;;514        HAL_PWREx_EnableGPIOPullUp(PWR_GPIO_B, GPIO_PIN_3); /* SWO */
000058  2108              MOVS     r1,#8
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       HAL_PWREx_EnableGPIOPullUp
                  |L20.96|
;;;515      }
;;;516      /* ------------------------------------------------------------------------ */
;;;517      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
000060  2400              MOVS     r4,#0
000062  9402              STR      r4,[sp,#8]
;;;518      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
000064  9404              STR      r4,[sp,#0x10]
;;;519      GPIO_InitStruct.Pull = GPIO_PULLUP;
000066  2501              MOVS     r5,#1
000068  9503              STR      r5,[sp,#0xc]
;;;520    
;;;521      GPIO_InitStruct.Pin = PIN_SMPS_POWERGOOD;
00006a  0329              LSLS     r1,r5,#12
00006c  9101              STR      r1,[sp,#4]
;;;522    
;;;523      HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
00006e  a901              ADD      r1,sp,#4
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       HAL_GPIO_Init
;;;524    
;;;525      /* ------------------------------------------------------------------------ */
;;;526    
;;;527      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
000076  9502              STR      r5,[sp,#8]
;;;528      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
000078  9404              STR      r4,[sp,#0x10]
;;;529      GPIO_InitStruct.Pull = GPIO_NOPULL;
00007a  9403              STR      r4,[sp,#0xc]
;;;530    
;;;531      GPIO_InitStruct.Pin = PIN_SMPS_ENABLE | PIN_SMPS_SWITCH_ENABLE;
00007c  f44f5120          MOV      r1,#0x2800
000080  9101              STR      r1,[sp,#4]
;;;532      /* --------- ADD SMPS VOLTAGE RANGE SELECTION -----------------------------*/
;;;533      /* - > Applicable to ST1PS02D1QTR on MB1312A/S */
;;;534      /* GPIO_InitStruct.Pin = PIN_SMPS_ENABLE | PIN_SMPS_SWITCH_ENABLE | PIN_SMPS_V1; */
;;;535    
;;;536      HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
000082  a901              ADD      r1,sp,#4
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       HAL_GPIO_Init
;;;537    
;;;538      /* --------- SMPS VOLTAGE RANGE SELECTION ----------------------------------*/
;;;539      /* ######################################################################## */
;;;540      /* - > Not applicable to ADP5301A on MB1312A/S */
;;;541      /* ######################################################################## */
;;;542      /* - > Applicable to ST1PS02D1QTR on MB1312A/S */
;;;543      /* Control to be added */
;;;544    
;;;545      /* ST1PS02D1QTR on MB1312 */
;;;546      /* if (VoltageRange == ST1PS02D1QTR_VOUT_1_25) */
;;;547      /* HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_V1, GPIO_PIN_SET); */
;;;548      /* 1.25V                  */
;;;549      /* D0/D1/D2 = H/L/L       */
;;;550      /* else */
;;;551    
;;;552      /* */
;;;553      /* ST1PS02D1QTR on MB1312 */
;;;554      /* ST1PS02D1QTR_VOUT_1_05 */
;;;555      /* 1.05V                  */
;;;556      /* D0/D1/D2 = L/L/L       */
;;;557      /* HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_V1, GPIO_PIN_RESET); */
;;;558      /* ######################################################################## */
;;;559      return SMPS_OK;
;;;560    }
00008a  b006              ADD      sp,sp,#0x18
00008c  2000              MOVS     r0,#0                 ;559
00008e  bd70              POP      {r4-r6,pc}
;;;561    
                          ENDP

                  |L20.144|
                          DCD      0x40021000
                  |L20.148|
                          DCD      0x40007000
                  |L20.152|
                          DCD      0x48001800

                          AREA ||i.BSP_SMPS_Supply_Disable||, CODE, READONLY, ALIGN=2

                  BSP_SMPS_Supply_Disable PROC
;;;682      */
;;;683    uint32_t BSP_SMPS_Supply_Disable(void)
000000  b538              PUSH     {r3-r5,lr}
;;;684    {
;;;685      PWR_AND_CLK_SMPS();
000002  4c0d              LDR      r4,|L21.56|
000004  6da0              LDR      r0,[r4,#0x58]
000006  f0405080          ORR      r0,r0,#0x10000000
00000a  65a0              STR      r0,[r4,#0x58]
00000c  6da0              LDR      r0,[r4,#0x58]
00000e  f0005080          AND      r0,r0,#0x10000000
000012  9000              STR      r0,[sp,#0]
000014  f7fffffe          BL       HAL_PWREx_EnableVddIO2
000018  6ce0              LDR      r0,[r4,#0x4c]
00001a  f0400040          ORR      r0,r0,#0x40
00001e  64e0              STR      r0,[r4,#0x4c]
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  f0000040          AND      r0,r0,#0x40
000026  9000              STR      r0,[sp,#0]
;;;686    #if defined (FLASH_CFGR_LVEN)
;;;687      /* Configure Flash back to normal settings        */
;;;688      /* NUCLEO BOARD ALLOWS 1.2V supply voltage        */
;;;689      /* Now exiting from SMPS mode                     */
;;;690      /* hence longest timing shall be used             */
;;;691    
;;;692      HAL_FLASHEx_ConfigLVEPin(FLASH_LVE_PIN_CTRL);
;;;693    #endif   
;;;694      /* SMPS SWITCH DISABLED */
;;;695      HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_SWITCH_ENABLE, GPIO_PIN_RESET);
000028  2200              MOVS     r2,#0
00002a  f44f5100          MOV      r1,#0x2000
00002e  4803              LDR      r0,|L21.60|
000030  f7fffffe          BL       HAL_GPIO_WritePin
;;;696    
;;;697      return SMPS_OK;
000034  2000              MOVS     r0,#0
;;;698    }
000036  bd38              POP      {r3-r5,pc}
;;;699    
                          ENDP

                  |L21.56|
                          DCD      0x40021000
                  |L21.60|
                          DCD      0x48001800

                          AREA ||i.BSP_SMPS_Supply_Enable||, CODE, READONLY, ALIGN=2

                  BSP_SMPS_Supply_Enable PROC
;;;646      */
;;;647    uint32_t BSP_SMPS_Supply_Enable(uint32_t Delay, uint32_t Power_Good_Check)
000000  b5f8              PUSH     {r3-r7,lr}
;;;648    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;649      PWR_AND_CLK_SMPS();
000006  4c14              LDR      r4,|L22.88|
000008  6da0              LDR      r0,[r4,#0x58]
00000a  f0405080          ORR      r0,r0,#0x10000000
00000e  65a0              STR      r0,[r4,#0x58]
000010  6da0              LDR      r0,[r4,#0x58]
000012  f0005080          AND      r0,r0,#0x10000000
000016  9000              STR      r0,[sp,#0]
000018  f7fffffe          BL       HAL_PWREx_EnableVddIO2
00001c  6ce0              LDR      r0,[r4,#0x4c]
00001e  f0400040          ORR      r0,r0,#0x40
000022  64e0              STR      r0,[r4,#0x4c]
000024  6ce0              LDR      r0,[r4,#0x4c]
000026  f0000040          AND      r0,r0,#0x40
00002a  9000              STR      r0,[sp,#0]
;;;650    
;;;651      if (Delay != 0)
00002c  b115              CBZ      r5,|L22.52|
;;;652      {
;;;653        HAL_Delay(Delay);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       HAL_Delay
                  |L22.52|
;;;654      }
;;;655      /* CHECK POWER GOOD or NOT */
;;;656      if (Power_Good_Check != 0)
;;;657      {
;;;658        if (GPIO_PIN_RESET == (HAL_GPIO_ReadPin(PORT_SMPS, PIN_SMPS_POWERGOOD)))
000034  4c09              LDR      r4,|L22.92|
000036  b12e              CBZ      r6,|L22.68|
000038  f44f5180          MOV      r1,#0x1000
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_GPIO_ReadPin
000042  b130              CBZ      r0,|L22.82|
                  |L22.68|
;;;659        {
;;;660          /* POWER GOOD KO */
;;;661          return SMPS_KO;
;;;662        }
;;;663      }
;;;664    
;;;665      /* SMPS SWITCH ENABLE */
;;;666      HAL_GPIO_WritePin(PORT_SMPS, PIN_SMPS_SWITCH_ENABLE, GPIO_PIN_SET);
000044  2201              MOVS     r2,#1
000046  0351              LSLS     r1,r2,#13
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_GPIO_WritePin
;;;667    
;;;668    #if defined (FLASH_CFGR_LVEN)
;;;669      /* Configure Flash for lower voltage with SMPS                   */
;;;670      /* NUCLEO BOARD ALLOWS 1.2V supply voltage                       */
;;;671      /* shortest timing works in R2 when SMPS is used                 */
;;;672      HAL_FLASHEx_ConfigLVEPin(FLASH_LVE_PIN_FORCED);
;;;673    #endif  
;;;674      return SMPS_OK;
00004e  2000              MOVS     r0,#0
;;;675    }
000050  bdf8              POP      {r3-r7,pc}
                  |L22.82|
000052  2001              MOVS     r0,#1                 ;661
000054  bdf8              POP      {r3-r7,pc}
;;;676    
                          ENDP

000056  0000              DCW      0x0000
                  |L22.88|
                          DCD      0x40021000
                  |L22.92|
                          DCD      0x48001800

                          AREA ||i.LCD_Delay||, CODE, READONLY, ALIGN=1

                  LCD_Delay PROC
;;;1068     */
;;;1069   void LCD_Delay(uint32_t Delay)
000000  f7ffbffe          B.W      HAL_Delay
;;;1070   {
;;;1071     HAL_Delay(Delay);
;;;1072   }
;;;1073   #endif /* HAL_SPI_MODULE_ENABLED */
                          ENDP


                          AREA ||i.LCD_IO_Init||, CODE, READONLY, ALIGN=2

                  LCD_IO_Init PROC
;;;939      */
;;;940    void LCD_IO_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;941    {
000002  b087              SUB      sp,sp,#0x1c
;;;942      GPIO_InitTypeDef  GPIO_InitStruct;
;;;943    
;;;944      /* LCD_CS_GPIO and LCD_DC_GPIO Periph clock enable */
;;;945      LCD_CS_GPIO_CLK_ENABLE();
000004  4816              LDR      r0,|L24.96|
000006  6cc1              LDR      r1,[r0,#0x4c]
000008  f0410108          ORR      r1,r1,#8
00000c  64c1              STR      r1,[r0,#0x4c]
00000e  6cc1              LDR      r1,[r0,#0x4c]
000010  f0010108          AND      r1,r1,#8
000014  9101              STR      r1,[sp,#4]
;;;946      LCD_DC_GPIO_CLK_ENABLE();
000016  6cc1              LDR      r1,[r0,#0x4c]
000018  f0410120          ORR      r1,r1,#0x20
00001c  64c1              STR      r1,[r0,#0x4c]
00001e  6cc0              LDR      r0,[r0,#0x4c]
000020  f0000020          AND      r0,r0,#0x20
000024  9001              STR      r0,[sp,#4]
;;;947    
;;;948      /* Configure LCD_CS_PIN pin: LCD Card CS pin */
;;;949      GPIO_InitStruct.Pin = LCD_CS_PIN;
000026  f44f4480          MOV      r4,#0x4000
00002a  9402              STR      r4,[sp,#8]
;;;950      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
00002c  2001              MOVS     r0,#1
00002e  9003              STR      r0,[sp,#0xc]
;;;951      GPIO_InitStruct.Pull = GPIO_NOPULL;
000030  2000              MOVS     r0,#0
000032  9004              STR      r0,[sp,#0x10]
;;;952      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000034  2002              MOVS     r0,#2
000036  9005              STR      r0,[sp,#0x14]
;;;953      HAL_GPIO_Init(LCD_CS_GPIO_PORT, &GPIO_InitStruct);
000038  4d0a              LDR      r5,|L24.100|
00003a  a902              ADD      r1,sp,#8
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       HAL_GPIO_Init
;;;954    
;;;955      /* Configure LCD_DC_PIN pin: LCD Card DC pin */
;;;956      GPIO_InitStruct.Pin = LCD_DC_PIN;
000042  10a2              ASRS     r2,r4,#2
000044  9202              STR      r2,[sp,#8]
;;;957      HAL_GPIO_Init(LCD_DC_GPIO_PORT, &GPIO_InitStruct);
000046  a902              ADD      r1,sp,#8
000048  4807              LDR      r0,|L24.104|
00004a  f7fffffe          BL       HAL_GPIO_Init
;;;958    
;;;959      /* LCD chip select high */
;;;960      LCD_CS_HIGH();
00004e  2201              MOVS     r2,#1
000050  4621              MOV      r1,r4
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       HAL_GPIO_WritePin
;;;961    
;;;962      /* LCD SPI Config */
;;;963      SPIx_Init();
000058  f7fffffe          BL       SPIx_Init
;;;964    }
00005c  b007              ADD      sp,sp,#0x1c
00005e  bd30              POP      {r4,r5,pc}
;;;965    
                          ENDP

                  |L24.96|
                          DCD      0x40021000
                  |L24.100|
                          DCD      0x48000c00
                  |L24.104|
                          DCD      0x48001400

                          AREA ||i.LCD_IO_WriteData||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteData PROC
;;;991      */
;;;992    void LCD_IO_WriteData(uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;993    {
000002  4606              MOV      r6,r0
;;;994      /* Reset LCD control line CS */
;;;995      LCD_CS_LOW();
000004  4d0b              LDR      r5,|L25.52|
000006  f44f4480          MOV      r4,#0x4000
00000a  2200              MOVS     r2,#0
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       HAL_GPIO_WritePin
;;;996    
;;;997      /* Set LCD data/command line DC to High */
;;;998      LCD_DC_HIGH();
000014  2201              MOVS     r2,#1
000016  0311              LSLS     r1,r2,#12
000018  4807              LDR      r0,|L25.56|
00001a  f7fffffe          BL       HAL_GPIO_WritePin
;;;999    
;;;1000     /* Send Data */
;;;1001     SPIx_Write(Data);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SPIx_Write
;;;1002   
;;;1003     /* Deselect : Chip Select high */
;;;1004     LCD_CS_HIGH();
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  e8bd4070          POP      {r4-r6,lr}
00002c  2201              MOVS     r2,#1
00002e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;1005   }
;;;1006   
                          ENDP

000032  0000              DCW      0x0000
                  |L25.52|
                          DCD      0x48000c00
                  |L25.56|
                          DCD      0x48001400

                          AREA ||i.LCD_IO_WriteMultipleData||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteMultipleData PROC
;;;1012   */
;;;1013   void LCD_IO_WriteMultipleData(uint8_t *pData, uint32_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1014   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1015     uint32_t counter = 0;
;;;1016     __IO uint32_t data = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1017   
;;;1018     /* Reset LCD control line CS */
;;;1019     LCD_CS_LOW();
00000c  f8df8064          LDR      r8,|L26.116|
000010  f44f4780          MOV      r7,#0x4000
000014  2200              MOVS     r2,#0
000016  4639              MOV      r1,r7
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       HAL_GPIO_WritePin
;;;1020   
;;;1021     /* Set LCD data/command line DC to High */
;;;1022     LCD_DC_HIGH();
00001e  2201              MOVS     r2,#1
000020  0311              LSLS     r1,r2,#12
000022  4815              LDR      r0,|L26.120|
000024  f7fffffe          BL       HAL_GPIO_WritePin
;;;1023   
;;;1024     if (Size == 1)
;;;1025     {
;;;1026       /* Only 1 byte to be sent to LCD - general interface can be used */
;;;1027       /* Send Data */
;;;1028       SPIx_Write(*pData);
;;;1029     }
;;;1030     else
;;;1031     {
;;;1032       /* Several data should be sent in a raw */
;;;1033       /* Direct SPI accesses for optimization */
;;;1034       for (counter = Size; counter != 0; counter--)
;;;1035       {
;;;1036         while (((hnucleo_Spi.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
000028  4e14              LDR      r6,|L26.124|
00002a  2d01              CMP      r5,#1                 ;1024
00002c  d01e              BEQ      |L26.108|
00002e  b17d              CBZ      r5,|L26.80|
                  |L26.48|
000030  6830              LDR      r0,[r6,#0]
                  |L26.50|
000032  6881              LDR      r1,[r0,#8]
000034  0789              LSLS     r1,r1,#30
000036  d5fc              BPL      |L26.50|
;;;1037         {
;;;1038         }
;;;1039         /* Need to invert bytes for LCD*/
;;;1040         *((__IO uint8_t *)&hnucleo_Spi.Instance->DR) = *(pData + 1);
000038  7861              LDRB     r1,[r4,#1]
00003a  7301              STRB     r1,[r0,#0xc]
00003c  6830              LDR      r0,[r6,#0]            ;1036
                  |L26.62|
;;;1041   
;;;1042         while (((hnucleo_Spi.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
00003e  6881              LDR      r1,[r0,#8]
000040  0789              LSLS     r1,r1,#30
000042  d5fc              BPL      |L26.62|
;;;1043         {
;;;1044         }
;;;1045         *((__IO uint8_t *)&hnucleo_Spi.Instance->DR) = *pData;
000044  f8141b02          LDRB     r1,[r4],#2
000048  7301              STRB     r1,[r0,#0xc]
00004a  1ead              SUBS     r5,r5,#2              ;1034
00004c  2d00              CMP      r5,#0                 ;1034
00004e  d1ef              BNE      |L26.48|
                  |L26.80|
000050  6830              LDR      r0,[r6,#0]            ;1036
                  |L26.82|
;;;1046         counter--;
;;;1047         pData += 2;
;;;1048       }
;;;1049   
;;;1050       /* Wait until the bus is ready before releasing Chip select */
;;;1051       while (((hnucleo_Spi.Instance->SR) & SPI_FLAG_BSY) != RESET)
000052  6881              LDR      r1,[r0,#8]
000054  0609              LSLS     r1,r1,#24
000056  d4fc              BMI      |L26.82|
                  |L26.88|
;;;1052       {
;;;1053       }
;;;1054     }
;;;1055   
;;;1056     /* Empty the Rx fifo */
;;;1057     data = *(&hnucleo_Spi.Instance->DR);
000058  6830              LDR      r0,[r6,#0]  ; hnucleo_Spi
00005a  68c0              LDR      r0,[r0,#0xc]
00005c  9000              STR      r0,[sp,#0]
;;;1058     UNUSED(data);
;;;1059   
;;;1060     /* Deselect : Chip Select high */
;;;1061     LCD_CS_HIGH();
00005e  4639              MOV      r1,r7
000060  4640              MOV      r0,r8
000062  e8bd43f8          POP      {r3-r9,lr}
000066  2201              MOVS     r2,#1
000068  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L26.108|
00006c  7820              LDRB     r0,[r4,#0]            ;1028
00006e  f7fffffe          BL       SPIx_Write
000072  e7f1              B        |L26.88|
;;;1062   }
;;;1063   
                          ENDP

                  |L26.116|
                          DCD      0x48000c00
                  |L26.120|
                          DCD      0x48001400
                  |L26.124|
                          DCD      ||.bss||

                          AREA ||i.LCD_IO_WriteReg||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteReg PROC
;;;970      */
;;;971    void LCD_IO_WriteReg(uint8_t LCDReg)
000000  b570              PUSH     {r4-r6,lr}
;;;972    {
000002  4606              MOV      r6,r0
;;;973      /* Reset LCD control line CS */
;;;974      LCD_CS_LOW();
000004  4d0b              LDR      r5,|L27.52|
000006  f44f4480          MOV      r4,#0x4000
00000a  2200              MOVS     r2,#0
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       HAL_GPIO_WritePin
;;;975    
;;;976      /* Set LCD data/command line DC to Low */
;;;977      LCD_DC_LOW();
000014  2200              MOVS     r2,#0
000016  10a1              ASRS     r1,r4,#2
000018  4807              LDR      r0,|L27.56|
00001a  f7fffffe          BL       HAL_GPIO_WritePin
;;;978    
;;;979      /* Send Command */
;;;980      SPIx_Write(LCDReg);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SPIx_Write
;;;981    
;;;982      /* Deselect : Chip Select high */
;;;983      LCD_CS_HIGH();
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  e8bd4070          POP      {r4-r6,lr}
00002c  2201              MOVS     r2,#1
00002e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;984    }
;;;985    
                          ENDP

000032  0000              DCW      0x0000
                  |L27.52|
                          DCD      0x48000c00
                  |L27.56|
                          DCD      0x48001400

                          AREA ||i.SD_IO_CSState||, CODE, READONLY, ALIGN=2

                  SD_IO_CSState PROC
;;;894      */
;;;895    void SD_IO_CSState(uint8_t val)
000000  4b06              LDR      r3,|L28.28|
;;;896    {
;;;897      if (val == 1)
;;;898      {
;;;899        SD_CS_HIGH();
000002  f44f4180          MOV      r1,#0x4000
000006  2801              CMP      r0,#1                 ;897
000008  d003              BEQ      |L28.18|
;;;900      }
;;;901      else
;;;902      {
;;;903        SD_CS_LOW();
00000a  2200              MOVS     r2,#0
00000c  4618              MOV      r0,r3
00000e  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L28.18|
000012  2201              MOVS     r2,#1                 ;899
000014  4618              MOV      r0,r3                 ;899
000016  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;904      }
;;;905    }
;;;906    
                          ENDP

00001a  0000              DCW      0x0000
                  |L28.28|
                          DCD      0x48001400

                          AREA ||i.SD_IO_Init||, CODE, READONLY, ALIGN=2

                  SD_IO_Init PROC
;;;858      */
;;;859    void SD_IO_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;860    {
000002  b087              SUB      sp,sp,#0x1c
;;;861      GPIO_InitTypeDef  GPIO_InitStruct;
;;;862      uint8_t counter;
;;;863    
;;;864      /* SD_CS_GPIO Periph clock enable */
;;;865      SD_CS_GPIO_CLK_ENABLE();
000004  4813              LDR      r0,|L29.84|
000006  6cc1              LDR      r1,[r0,#0x4c]
000008  f0410120          ORR      r1,r1,#0x20
00000c  64c1              STR      r1,[r0,#0x4c]
00000e  6cc0              LDR      r0,[r0,#0x4c]
000010  f0000020          AND      r0,r0,#0x20
000014  9001              STR      r0,[sp,#4]
;;;866    
;;;867      /* Configure SD_CS_PIN pin: SD Card CS pin */
;;;868      GPIO_InitStruct.Pin = SD_CS_PIN;
000016  f44f4480          MOV      r4,#0x4000
00001a  9402              STR      r4,[sp,#8]
;;;869      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
00001c  2001              MOVS     r0,#1
00001e  9003              STR      r0,[sp,#0xc]
;;;870      GPIO_InitStruct.Pull = GPIO_PULLUP;
000020  9004              STR      r0,[sp,#0x10]
;;;871      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000022  2002              MOVS     r0,#2
000024  9005              STR      r0,[sp,#0x14]
;;;872      HAL_GPIO_Init(SD_CS_GPIO_PORT, &GPIO_InitStruct);
000026  4d0c              LDR      r5,|L29.88|
000028  a902              ADD      r1,sp,#8
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       HAL_GPIO_Init
;;;873    
;;;874      /*------------Put SD in SPI mode--------------*/
;;;875      /* SD SPI Config */
;;;876      SPIx_Init();
000030  f7fffffe          BL       SPIx_Init
;;;877    
;;;878      /* SD chip select high */
;;;879      SD_CS_HIGH();
000034  2201              MOVS     r2,#1
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       HAL_GPIO_WritePin
;;;880    
;;;881      /* Send dummy byte 0xFF, 10 times with CS high */
;;;882      /* Rise CS and MOSI for 80 clocks cycles */
;;;883      for (counter = 0; counter <= 9; counter++)
00003e  2400              MOVS     r4,#0
                  |L29.64|
;;;884      {
;;;885        /* Send dummy byte 0xFF */
;;;886        SD_IO_WriteByte(SD_DUMMY_BYTE);
000040  20ff              MOVS     r0,#0xff
000042  f7fffffe          BL       SD_IO_WriteByte
000046  1c64              ADDS     r4,r4,#1              ;883
000048  b2e4              UXTB     r4,r4                 ;883
00004a  2c09              CMP      r4,#9                 ;883
00004c  d9f8              BLS      |L29.64|
;;;887      }
;;;888    }
00004e  b007              ADD      sp,sp,#0x1c
000050  bd30              POP      {r4,r5,pc}
;;;889    
                          ENDP

000052  0000              DCW      0x0000
                  |L29.84|
                          DCD      0x40021000
                  |L29.88|
                          DCD      0x48001400

                          AREA ||i.SD_IO_WriteByte||, CODE, READONLY, ALIGN=1

                  SD_IO_WriteByte PROC
;;;926      */
;;;927    uint8_t SD_IO_WriteByte(uint8_t Data)
000000  b501              PUSH     {r0,lr}
;;;928    {
000002  b082              SUB      sp,sp,#8
;;;929      uint8_t tmp;
;;;930      /* Send the byte */
;;;931      SPIx_WriteReadData(&Data, &tmp, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  a802              ADD      r0,sp,#8
00000a  f7fffffe          BL       SPIx_WriteReadData
;;;932      return tmp;
00000e  f89d0004          LDRB     r0,[sp,#4]
;;;933    }
000012  bd0e              POP      {r1-r3,pc}
;;;934    
                          ENDP


                          AREA ||i.SD_IO_WriteReadData||, CODE, READONLY, ALIGN=1

                  SD_IO_WriteReadData PROC
;;;913      */
;;;914    void SD_IO_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength)
000000  f7ffbffe          B.W      SPIx_WriteReadData
;;;915    {
;;;916    //  /* SD chip select low */
;;;917    //  SD_CS_LOW();
;;;918      /* Send the byte */
;;;919      SPIx_WriteReadData(DataIn, DataOut, DataLength);
;;;920    }
;;;921    
                          ENDP


                          AREA ||i.SPIx_Error||, CODE, READONLY, ALIGN=2

                  SPIx_Error PROC
;;;839      */
;;;840    static void SPIx_Error(void)
000000  b510              PUSH     {r4,lr}
;;;841    {
;;;842      /* De-initialize the SPI communication BUS */
;;;843      HAL_SPI_DeInit(&hnucleo_Spi);
000002  4803              LDR      r0,|L32.16|
000004  f7fffffe          BL       HAL_SPI_DeInit
;;;844    
;;;845      /* Re-Initiaize the SPI communication BUS */
;;;846      SPIx_Init();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      SPIx_Init
;;;847    }
;;;848    
                          ENDP

                  |L32.16|
                          DCD      ||.bss||

                          AREA ||i.SPIx_Init||, CODE, READONLY, ALIGN=2

                  SPIx_Init PROC
;;;763      */
;;;764    static void SPIx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;765    {
;;;766      if (HAL_SPI_GetState(&hnucleo_Spi) == HAL_SPI_STATE_RESET)
000002  4812              LDR      r0,|L33.76|
000004  f7fffffe          BL       HAL_SPI_GetState
000008  2800              CMP      r0,#0
00000a  d11e              BNE      |L33.74|
;;;767      {
;;;768        /* SPI Config */
;;;769        hnucleo_Spi.Instance = NUCLEO_SPIx;
00000c  480f              LDR      r0,|L33.76|
00000e  4910              LDR      r1,|L33.80|
000010  6001              STR      r1,[r0,#0]  ; hnucleo_Spi
;;;770        /* SPI baudrate is set to 9 MHz maximum (APB1/SPI_BaudRatePrescaler = 72/8 = 9 MHz)
;;;771         to verify these constraints:
;;;772            - ST7735 LCD SPI interface max baudrate is 15MHz for write and 6.66MHz for read
;;;773              Since the provided driver doesn't use read capability from LCD, only constraint
;;;774              on write baudrate is considered.
;;;775            - SD card SPI interface max baudrate is 25MHz for write/read
;;;776            - PCLK2 max frequency is 72 MHz
;;;777         */
;;;778        hnucleo_Spi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
000012  2110              MOVS     r1,#0x10
000014  61c1              STR      r1,[r0,#0x1c]  ; hnucleo_Spi
;;;779        hnucleo_Spi.Init.Direction = SPI_DIRECTION_2LINES;
000016  2100              MOVS     r1,#0
000018  6081              STR      r1,[r0,#8]  ; hnucleo_Spi
;;;780        hnucleo_Spi.Init.CLKPhase = SPI_PHASE_2EDGE;
00001a  2201              MOVS     r2,#1
00001c  6142              STR      r2,[r0,#0x14]  ; hnucleo_Spi
;;;781        hnucleo_Spi.Init.CLKPolarity = SPI_POLARITY_HIGH;
00001e  2202              MOVS     r2,#2
000020  6102              STR      r2,[r0,#0x10]  ; hnucleo_Spi
;;;782        hnucleo_Spi.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
000022  6281              STR      r1,[r0,#0x28]  ; hnucleo_Spi
;;;783        hnucleo_Spi.Init.CRCPolynomial = 7;
000024  2207              MOVS     r2,#7
000026  62c2              STR      r2,[r0,#0x2c]  ; hnucleo_Spi
;;;784        hnucleo_Spi.Init.DataSize = SPI_DATASIZE_8BIT;
000028  0212              LSLS     r2,r2,#8
00002a  60c2              STR      r2,[r0,#0xc]  ; hnucleo_Spi
;;;785        hnucleo_Spi.Init.FirstBit = SPI_FIRSTBIT_MSB;
00002c  6201              STR      r1,[r0,#0x20]  ; hnucleo_Spi
;;;786        hnucleo_Spi.Init.NSS = SPI_NSS_SOFT;
00002e  f44f7200          MOV      r2,#0x200
000032  6182              STR      r2,[r0,#0x18]  ; hnucleo_Spi
;;;787        hnucleo_Spi.Init.TIMode = SPI_TIMODE_DISABLE;
000034  6241              STR      r1,[r0,#0x24]  ; hnucleo_Spi
;;;788        hnucleo_Spi.Init.Mode = SPI_MODE_MASTER;
000036  f44f7182          MOV      r1,#0x104
00003a  6041              STR      r1,[r0,#4]  ; hnucleo_Spi
;;;789    
;;;790        SPIx_MspInit(&hnucleo_Spi);
00003c  f7fffffe          BL       SPIx_MspInit
;;;791        HAL_SPI_Init(&hnucleo_Spi);
000040  e8bd4010          POP      {r4,lr}
000044  4801              LDR      r0,|L33.76|
000046  f7ffbffe          B.W      HAL_SPI_Init
                  |L33.74|
;;;792      }
;;;793    }
00004a  bd10              POP      {r4,pc}
;;;794    
                          ENDP

                  |L33.76|
                          DCD      ||.bss||
                  |L33.80|
                          DCD      0x40013000

                          AREA ||i.SPIx_MspInit||, CODE, READONLY, ALIGN=2

                  SPIx_MspInit PROC
;;;726      */
;;;727    static void SPIx_MspInit(SPI_HandleTypeDef *hspi)
000000  b5f0              PUSH     {r4-r7,lr}
;;;728    {
000002  b087              SUB      sp,sp,#0x1c
;;;729      GPIO_InitTypeDef  GPIO_InitStruct;
;;;730    
;;;731      /*** Configure the GPIOs ***/
;;;732      /* Enable GPIO clock */
;;;733      NUCLEO_SPIx_SCK_GPIO_CLK_ENABLE();
000004  4c1c              LDR      r4,|L34.120|
000006  6ce0              LDR      r0,[r4,#0x4c]
000008  f0400001          ORR      r0,r0,#1
00000c  64e0              STR      r0,[r4,#0x4c]
00000e  6ce0              LDR      r0,[r4,#0x4c]
000010  f0000001          AND      r0,r0,#1
000014  9001              STR      r0,[sp,#4]
;;;734      NUCLEO_SPIx_MISO_MOSI_GPIO_CLK_ENABLE();
000016  6ce0              LDR      r0,[r4,#0x4c]
000018  f0400001          ORR      r0,r0,#1
00001c  64e0              STR      r0,[r4,#0x4c]
00001e  6ce0              LDR      r0,[r4,#0x4c]
000020  f0000001          AND      r0,r0,#1
000024  9001              STR      r0,[sp,#4]
;;;735    
;;;736      /* Configure SPI SCK */
;;;737      GPIO_InitStruct.Pin = NUCLEO_SPIx_SCK_PIN;
000026  2020              MOVS     r0,#0x20
000028  9002              STR      r0,[sp,#8]
;;;738      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00002a  2502              MOVS     r5,#2
00002c  9503              STR      r5,[sp,#0xc]
;;;739      GPIO_InitStruct.Pull  = GPIO_PULLUP;
00002e  2001              MOVS     r0,#1
000030  9004              STR      r0,[sp,#0x10]
;;;740      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000032  9505              STR      r5,[sp,#0x14]
;;;741      GPIO_InitStruct.Alternate = NUCLEO_SPIx_SCK_AF;
000034  2605              MOVS     r6,#5
000036  9606              STR      r6,[sp,#0x18]
;;;742      HAL_GPIO_Init(NUCLEO_SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
000038  f04f4790          MOV      r7,#0x48000000
00003c  a902              ADD      r1,sp,#8
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       HAL_GPIO_Init
;;;743    
;;;744      /* Configure SPI MISO and MOSI */
;;;745      GPIO_InitStruct.Pin = NUCLEO_SPIx_MOSI_PIN;
000044  2180              MOVS     r1,#0x80
000046  9102              STR      r1,[sp,#8]
;;;746      GPIO_InitStruct.Alternate = NUCLEO_SPIx_MISO_MOSI_AF;
000048  9606              STR      r6,[sp,#0x18]
;;;747      GPIO_InitStruct.Pull  = GPIO_PULLDOWN;
00004a  9504              STR      r5,[sp,#0x10]
;;;748      HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &GPIO_InitStruct);
00004c  a902              ADD      r1,sp,#8
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       HAL_GPIO_Init
;;;749    
;;;750      GPIO_InitStruct.Pin = NUCLEO_SPIx_MISO_PIN;
000054  2040              MOVS     r0,#0x40
000056  9002              STR      r0,[sp,#8]
;;;751      GPIO_InitStruct.Pull  = GPIO_PULLDOWN;
000058  9504              STR      r5,[sp,#0x10]
;;;752      HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &GPIO_InitStruct);
00005a  a902              ADD      r1,sp,#8
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       HAL_GPIO_Init
;;;753    
;;;754      /*** Configure the SPI peripheral ***/
;;;755      /* Enable SPI clock */
;;;756      NUCLEO_SPIx_CLK_ENABLE();
000062  6e20              LDR      r0,[r4,#0x60]
000064  f4405080          ORR      r0,r0,#0x1000
000068  6620              STR      r0,[r4,#0x60]
00006a  6e20              LDR      r0,[r4,#0x60]
00006c  f4005080          AND      r0,r0,#0x1000
000070  9001              STR      r0,[sp,#4]
;;;757    }
000072  b007              ADD      sp,sp,#0x1c
000074  bdf0              POP      {r4-r7,pc}
;;;758    
                          ENDP

000076  0000              DCW      0x0000
                  |L34.120|
                          DCD      0x40021000

                          AREA ||i.SPIx_Write||, CODE, READONLY, ALIGN=2

                  SPIx_Write PROC
;;;820      */
;;;821    static void SPIx_Write(uint8_t Value)
000000  b501              PUSH     {r0,lr}
;;;822    {
000002  b082              SUB      sp,sp,#8
;;;823      HAL_StatusTypeDef status = HAL_OK;
;;;824      uint8_t data;
;;;825    
;;;826      status = HAL_SPI_TransmitReceive(&hnucleo_Spi, (uint8_t *) &Value, &data, 1, SpixTimeout);
000004  4806              LDR      r0,|L35.32|
000006  2301              MOVS     r3,#1
000008  aa01              ADD      r2,sp,#4
00000a  6840              LDR      r0,[r0,#4]  ; SpixTimeout
00000c  9000              STR      r0,[sp,#0]
00000e  a902              ADD      r1,sp,#8
000010  4804              LDR      r0,|L35.36|
000012  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;827    
;;;828      /* Check the communication status */
;;;829      if (status != HAL_OK)
000016  2800              CMP      r0,#0
000018  d001              BEQ      |L35.30|
;;;830      {
;;;831        /* Execute user timeout callback */
;;;832        SPIx_Error();
00001a  f7fffffe          BL       SPIx_Error
                  |L35.30|
;;;833      }
;;;834    }
00001e  bd0e              POP      {r1-r3,pc}
;;;835    
                          ENDP

                  |L35.32|
                          DCD      ||.data||
                  |L35.36|
                          DCD      ||.bss||

                          AREA ||i.SPIx_WriteReadData||, CODE, READONLY, ALIGN=2

                  SPIx_WriteReadData PROC
;;;801      */
;;;802    static void SPIx_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength)
000000  b538              PUSH     {r3-r5,lr}
;;;803    {
000002  460c              MOV      r4,r1
;;;804      HAL_StatusTypeDef status = HAL_OK;
;;;805    
;;;806      status = HAL_SPI_TransmitReceive(&hnucleo_Spi, (uint8_t *) DataIn, DataOut, DataLength, SpixTimeout);
000004  4907              LDR      r1,|L36.36|
000006  4613              MOV      r3,r2
000008  4622              MOV      r2,r4
00000a  6849              LDR      r1,[r1,#4]  ; SpixTimeout
00000c  9100              STR      r1,[sp,#0]
00000e  4601              MOV      r1,r0
000010  4805              LDR      r0,|L36.40|
000012  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;807    
;;;808      /* Check the communication status */
;;;809      if (status != HAL_OK)
000016  2800              CMP      r0,#0
000018  d003              BEQ      |L36.34|
;;;810      {
;;;811        /* Execute user timeout callback */
;;;812        SPIx_Error();
00001a  e8bd4038          POP      {r3-r5,lr}
00001e  f7ffbffe          B.W      SPIx_Error
                  |L36.34|
;;;813      }
;;;814    }
000022  bd38              POP      {r3-r5,pc}
;;;815    
                          ENDP

                  |L36.36|
                          DCD      ||.data||
                  |L36.40|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hnucleo_Spi
                          %        100
                  hnucleo_Adc
                          %        104
                  sConfig
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  BUTTON_IRQn
000000  2800              DCB      0x28,0x00
                  BUTTON_PIN
000002  2000              DCW      0x2000
                  GPIO_PIN
000004  00800080          DCW      0x0080,0x0080
000008  4000              DCW      0x4000

                          AREA ||.data||, DATA, ALIGN=2

                  BUTTON_PORT
                          DCD      0x48000800
                  SpixTimeout
                          DCD      0x000003e8
                  GPIO_PORT
                          DCD      0x48000800
                          DCD      0x48000400
                          DCD      0x48000400

;*** Start embedded assembler ***

#line 1 "../../../Drivers/BSP/STM32L4xx_Nucleo_144/stm32l4xx_nucleo_144.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_nucleo_144_c_c84236cb____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32l4xx_nucleo_144_c_c84236cb____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_nucleo_144_c_c84236cb____REVSH|
#line 507
|__asm___22_stm32l4xx_nucleo_144_c_c84236cb____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32l4xx_nucleo_144_c_c84236cb____RRX|
#line 694
|__asm___22_stm32l4xx_nucleo_144_c_c84236cb____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
