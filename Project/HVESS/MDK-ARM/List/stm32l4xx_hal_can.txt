; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_can.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_can.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_can.c]
                          THUMB

                          AREA ||i.HAL_CAN_AbortTxRequest||, CODE, READONLY, ALIGN=1

                  HAL_CAN_AbortTxRequest PROC
;;;1329     */
;;;1330   HAL_StatusTypeDef HAL_CAN_AbortTxRequest(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)
000000  f8902020          LDRB     r2,[r0,#0x20]
;;;1331   {
;;;1332     HAL_CAN_StateTypeDef state = hcan->State;
;;;1333   
;;;1334     /* Check function parameters */
;;;1335     assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));
;;;1336   
;;;1337     if ((state == HAL_CAN_STATE_READY) ||
000004  2a01              CMP      r2,#1
000006  d007              BEQ      |L1.24|
;;;1338         (state == HAL_CAN_STATE_LISTENING))
000008  2a02              CMP      r2,#2
00000a  d005              BEQ      |L1.24|
;;;1339     {
;;;1340       /* Check Tx Mailbox 0 */
;;;1341       if ((TxMailboxes & CAN_TX_MAILBOX0) != 0U)
;;;1342       {
;;;1343         /* Add cancellation request for Tx Mailbox 0 */
;;;1344         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ0);
;;;1345       }
;;;1346   
;;;1347       /* Check Tx Mailbox 1 */
;;;1348       if ((TxMailboxes & CAN_TX_MAILBOX1) != 0U)
;;;1349       {
;;;1350         /* Add cancellation request for Tx Mailbox 1 */
;;;1351         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ1);
;;;1352       }
;;;1353   
;;;1354       /* Check Tx Mailbox 2 */
;;;1355       if ((TxMailboxes & CAN_TX_MAILBOX2) != 0U)
;;;1356       {
;;;1357         /* Add cancellation request for Tx Mailbox 2 */
;;;1358         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ2);
;;;1359       }
;;;1360   
;;;1361       /* Return function status */
;;;1362       return HAL_OK;
;;;1363     }
;;;1364     else
;;;1365     {
;;;1366       /* Update error code */
;;;1367       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  f4412180          ORR      r1,r1,#0x40000
000012  6241              STR      r1,[r0,#0x24]
;;;1368   
;;;1369       return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;1370     }
;;;1371   }
000016  4770              BX       lr
                  |L1.24|
000018  07ca              LSLS     r2,r1,#31             ;1341
00001a  d004              BEQ      |L1.38|
00001c  6802              LDR      r2,[r0,#0]            ;1344
00001e  6893              LDR      r3,[r2,#8]            ;1344
000020  f0430380          ORR      r3,r3,#0x80           ;1344
000024  6093              STR      r3,[r2,#8]            ;1344
                  |L1.38|
000026  078a              LSLS     r2,r1,#30             ;1348
000028  d504              BPL      |L1.52|
00002a  6802              LDR      r2,[r0,#0]            ;1351
00002c  6893              LDR      r3,[r2,#8]            ;1351
00002e  f4434300          ORR      r3,r3,#0x8000         ;1351
000032  6093              STR      r3,[r2,#8]            ;1351
                  |L1.52|
000034  0749              LSLS     r1,r1,#29             ;1355
000036  d504              BPL      |L1.66|
000038  6800              LDR      r0,[r0,#0]            ;1358
00003a  6881              LDR      r1,[r0,#8]            ;1358
00003c  f4410100          ORR      r1,r1,#0x800000       ;1358
000040  6081              STR      r1,[r0,#8]            ;1358
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;1362
000044  4770              BX       lr
;;;1372   
                          ENDP


                          AREA ||i.HAL_CAN_ActivateNotification||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ActivateNotification PROC
;;;1630     */
;;;1631   HAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs)
000000  f8902020          LDRB     r2,[r0,#0x20]
;;;1632   {
;;;1633     HAL_CAN_StateTypeDef state = hcan->State;
;;;1634   
;;;1635     /* Check function parameters */
;;;1636     assert_param(IS_CAN_IT(ActiveITs));
;;;1637   
;;;1638     if ((state == HAL_CAN_STATE_READY) ||
000004  2a01              CMP      r2,#1
000006  d007              BEQ      |L2.24|
;;;1639         (state == HAL_CAN_STATE_LISTENING))
000008  2a02              CMP      r2,#2
00000a  d005              BEQ      |L2.24|
;;;1640     {
;;;1641       /* Enable the selected interrupts */
;;;1642       __HAL_CAN_ENABLE_IT(hcan, ActiveITs);
;;;1643   
;;;1644       /* Return function status */
;;;1645       return HAL_OK;
;;;1646     }
;;;1647     else
;;;1648     {
;;;1649       /* Update error code */
;;;1650       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  f4412180          ORR      r1,r1,#0x40000
000012  6241              STR      r1,[r0,#0x24]
;;;1651   
;;;1652       return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;1653     }
;;;1654   }
000016  4770              BX       lr
                  |L2.24|
000018  6800              LDR      r0,[r0,#0]            ;1642
00001a  6942              LDR      r2,[r0,#0x14]         ;1642
00001c  430a              ORRS     r2,r2,r1              ;1642
00001e  6142              STR      r2,[r0,#0x14]         ;1642
000020  2000              MOVS     r0,#0                 ;1645
000022  4770              BX       lr
;;;1655   
                          ENDP


                          AREA ||i.HAL_CAN_AddTxMessage||, CODE, READONLY, ALIGN=1

                  HAL_CAN_AddTxMessage PROC
;;;1221     */
;;;1222   HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1223   {
;;;1224     uint32_t transmitmailbox;
;;;1225     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8905020          LDRB     r5,[r0,#0x20]
;;;1226     uint32_t tsr = READ_REG(hcan->Instance->TSR);
000006  6804              LDR      r4,[r0,#0]
000008  68a4              LDR      r4,[r4,#8]
;;;1227   
;;;1228     /* Check the parameters */
;;;1229     assert_param(IS_CAN_IDTYPE(pHeader->IDE));
;;;1230     assert_param(IS_CAN_RTR(pHeader->RTR));
;;;1231     assert_param(IS_CAN_DLC(pHeader->DLC));
;;;1232     if (pHeader->IDE == CAN_ID_STD)
;;;1233     {
;;;1234       assert_param(IS_CAN_STDID(pHeader->StdId));
;;;1235     }
;;;1236     else
;;;1237     {
;;;1238       assert_param(IS_CAN_EXTID(pHeader->ExtId));
;;;1239     }
;;;1240     assert_param(IS_FUNCTIONAL_STATE(pHeader->TransmitGlobalTime));
;;;1241   
;;;1242     if ((state == HAL_CAN_STATE_READY) ||
00000a  2d01              CMP      r5,#1
00000c  d007              BEQ      |L3.30|
;;;1243         (state == HAL_CAN_STATE_LISTENING))
00000e  2d02              CMP      r5,#2
000010  d005              BEQ      |L3.30|
;;;1244     {
;;;1245       /* Check that all the Tx mailboxes are not full */
;;;1246       if (((tsr & CAN_TSR_TME0) != 0U) ||
;;;1247           ((tsr & CAN_TSR_TME1) != 0U) ||
;;;1248           ((tsr & CAN_TSR_TME2) != 0U))
;;;1249       {
;;;1250         /* Select an empty transmit mailbox */
;;;1251         transmitmailbox = (tsr & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;
;;;1252   
;;;1253         /* Check transmit mailbox value */
;;;1254         if (transmitmailbox > 2U)
;;;1255         {
;;;1256           /* Update error code */
;;;1257           hcan->ErrorCode |= HAL_CAN_ERROR_INTERNAL;
;;;1258   
;;;1259           return HAL_ERROR;
;;;1260         }
;;;1261   
;;;1262         /* Store the Tx mailbox */
;;;1263         *pTxMailbox = (uint32_t)1 << transmitmailbox;
;;;1264   
;;;1265         /* Set up the Id */
;;;1266         if (pHeader->IDE == CAN_ID_STD)		
;;;1267         {
;;;1268           hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |
;;;1269                                                              pHeader->RTR);
;;;1270         }
;;;1271         else
;;;1272         {
;;;1273           hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
;;;1274                                                              pHeader->IDE |
;;;1275                                                              pHeader->RTR);
;;;1276         }
;;;1277   
;;;1278         /* Set up the DLC */
;;;1279         hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);
;;;1280   
;;;1281         /* Set up the Transmit Global Time mode */
;;;1282         if (pHeader->TransmitGlobalTime == ENABLE)
;;;1283         {
;;;1284           SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TDTR, CAN_TDT0R_TGT);
;;;1285         }
;;;1286   
;;;1287         /* Set up the data field */
;;;1288         WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDHR,
;;;1289                   ((uint32_t)aData[7] << CAN_TDH0R_DATA7_Pos) |
;;;1290                   ((uint32_t)aData[6] << CAN_TDH0R_DATA6_Pos) |
;;;1291                   ((uint32_t)aData[5] << CAN_TDH0R_DATA5_Pos) |
;;;1292                   ((uint32_t)aData[4] << CAN_TDH0R_DATA4_Pos));
;;;1293         WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,
;;;1294                   ((uint32_t)aData[3] << CAN_TDL0R_DATA3_Pos) |
;;;1295                   ((uint32_t)aData[2] << CAN_TDL0R_DATA2_Pos) |
;;;1296                   ((uint32_t)aData[1] << CAN_TDL0R_DATA1_Pos) |
;;;1297                   ((uint32_t)aData[0] << CAN_TDL0R_DATA0_Pos));
;;;1298   
;;;1299         /* Request transmission */
;;;1300         SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TIR, CAN_TI0R_TXRQ);
;;;1301   
;;;1302         /* Return function status */
;;;1303         return HAL_OK;
;;;1304       }
;;;1305       else
;;;1306       {
;;;1307         /* Update error code */
;;;1308         hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
;;;1309   
;;;1310         return HAL_ERROR;
;;;1311       }
;;;1312     }
;;;1313     else
;;;1314     {
;;;1315       /* Update error code */
;;;1316       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
000012  6a41              LDR      r1,[r0,#0x24]
000014  f4412180          ORR      r1,r1,#0x40000
000018  6241              STR      r1,[r0,#0x24]
;;;1317   
;;;1318       return HAL_ERROR;
00001a  2001              MOVS     r0,#1
;;;1319     }
;;;1320   }
00001c  bdf0              POP      {r4-r7,pc}
                  |L3.30|
00001e  f0046580          AND      r5,r4,#0x4000000      ;1246
000022  f0046600          AND      r6,r4,#0x8000000      ;1246
000026  4335              ORRS     r5,r5,r6              ;1246
000028  d101              BNE      |L3.46|
00002a  00e5              LSLS     r5,r4,#3              ;1248
00002c  d55b              BPL      |L3.230|
                  |L3.46|
00002e  f3c46401          UBFX     r4,r4,#24,#2          ;1251
000032  2c02              CMP      r4,#2                 ;1254
000034  d905              BLS      |L3.66|
000036  6a41              LDR      r1,[r0,#0x24]         ;1257
000038  f4410100          ORR      r1,r1,#0x800000       ;1257
00003c  6241              STR      r1,[r0,#0x24]         ;1257
00003e  2001              MOVS     r0,#1                 ;1259
000040  bdf0              POP      {r4-r7,pc}
                  |L3.66|
000042  2501              MOVS     r5,#1                 ;1263
000044  40a5              LSLS     r5,r5,r4              ;1263
000046  601d              STR      r5,[r3,#0]            ;1263
000048  688b              LDR      r3,[r1,#8]            ;1266
00004a  f44f75c0          MOV      r5,#0x180             ;1268
00004e  b19b              CBZ      r3,|L3.120|
000050  68ce              LDR      r6,[r1,#0xc]          ;1273
000052  eb051704          ADD      r7,r5,r4,LSL #4       ;1273
000056  4333              ORRS     r3,r3,r6              ;1273
000058  684e              LDR      r6,[r1,#4]            ;1273
00005a  ea4303c6          ORR      r3,r3,r6,LSL #3       ;1273
00005e  6806              LDR      r6,[r0,#0]            ;1273
000060  51f3              STR      r3,[r6,r7]            ;1273
                  |L3.98|
000062  f44f73c2          MOV      r3,#0x184             ;1279
000066  6807              LDR      r7,[r0,#0]            ;1279
000068  eb031304          ADD      r3,r3,r4,LSL #4       ;1279
00006c  690e              LDR      r6,[r1,#0x10]         ;1279
00006e  50fe              STR      r6,[r7,r3]            ;1279
000070  7d09              LDRB     r1,[r1,#0x14]         ;1282
000072  2901              CMP      r1,#1                 ;1282
000074  d009              BEQ      |L3.138|
000076  e00d              B        |L3.148|
                  |L3.120|
000078  880e              LDRH     r6,[r1,#0]            ;1268
00007a  68cb              LDR      r3,[r1,#0xc]          ;1268
00007c  eb051704          ADD      r7,r5,r4,LSL #4       ;1268
000080  ea435346          ORR      r3,r3,r6,LSL #21      ;1268
000084  6806              LDR      r6,[r0,#0]            ;1268
000086  51f3              STR      r3,[r6,r7]            ;1268
000088  e7eb              B        |L3.98|
                  |L3.138|
00008a  6801              LDR      r1,[r0,#0]            ;1284
00008c  58ce              LDR      r6,[r1,r3]            ;1284
00008e  f4467680          ORR      r6,r6,#0x100          ;1284
000092  50ce              STR      r6,[r1,r3]            ;1284
                  |L3.148|
000094  7911              LDRB     r1,[r2,#4]            ;1288
000096  79d3              LDRB     r3,[r2,#7]            ;1288
000098  7956              LDRB     r6,[r2,#5]            ;1288
00009a  ea416103          ORR      r1,r1,r3,LSL #24      ;1288
00009e  7993              LDRB     r3,[r2,#6]            ;1288
0000a0  041b              LSLS     r3,r3,#16             ;1288
0000a2  ea432306          ORR      r3,r3,r6,LSL #8       ;1288
0000a6  4319              ORRS     r1,r1,r3              ;1288
0000a8  f44f76c6          MOV      r6,#0x18c             ;1288
0000ac  6803              LDR      r3,[r0,#0]            ;1288
0000ae  eb061604          ADD      r6,r6,r4,LSL #4       ;1288
0000b2  5199              STR      r1,[r3,r6]            ;1288
0000b4  7811              LDRB     r1,[r2,#0]            ;1293
0000b6  78d3              LDRB     r3,[r2,#3]            ;1293
0000b8  ea416103          ORR      r1,r1,r3,LSL #24      ;1293
0000bc  7893              LDRB     r3,[r2,#2]            ;1293
0000be  7852              LDRB     r2,[r2,#1]            ;1293
0000c0  041b              LSLS     r3,r3,#16             ;1293
0000c2  ea432202          ORR      r2,r3,r2,LSL #8       ;1293
0000c6  4311              ORRS     r1,r1,r2              ;1293
0000c8  f44f73c4          MOV      r3,#0x188             ;1293
0000cc  6802              LDR      r2,[r0,#0]            ;1293
0000ce  eb031304          ADD      r3,r3,r4,LSL #4       ;1293
0000d2  50d1              STR      r1,[r2,r3]            ;1293
0000d4  6800              LDR      r0,[r0,#0]            ;1300
0000d6  eb051104          ADD      r1,r5,r4,LSL #4       ;1300
0000da  5842              LDR      r2,[r0,r1]            ;1300
0000dc  f0420201          ORR      r2,r2,#1              ;1300
0000e0  5042              STR      r2,[r0,r1]            ;1300
0000e2  2000              MOVS     r0,#0                 ;1303
0000e4  bdf0              POP      {r4-r7,pc}
                  |L3.230|
0000e6  6a41              LDR      r1,[r0,#0x24]         ;1308
0000e8  f4411100          ORR      r1,r1,#0x200000       ;1308
0000ec  6241              STR      r1,[r0,#0x24]         ;1308
0000ee  2001              MOVS     r0,#1                 ;1310
0000f0  bdf0              POP      {r4-r7,pc}
;;;1321   
                          ENDP


                          AREA ||i.HAL_CAN_ConfigFilter||, CODE, READONLY, ALIGN=2

                  HAL_CAN_ConfigFilter PROC
;;;837      */
;;;838    HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)
000000  b510              PUSH     {r4,lr}
;;;839    {
;;;840      uint32_t filternbrbitpos;
;;;841      CAN_TypeDef *can_ip = hcan->Instance;
;;;842      HAL_CAN_StateTypeDef state = hcan->State;
000002  f8902020          LDRB     r2,[r0,#0x20]
;;;843    
;;;844      if ((state == HAL_CAN_STATE_READY) ||
000006  2a01              CMP      r2,#1
000008  d007              BEQ      |L4.26|
;;;845          (state == HAL_CAN_STATE_LISTENING))
00000a  2a02              CMP      r2,#2
00000c  d005              BEQ      |L4.26|
;;;846      {
;;;847        /* Check the parameters */
;;;848        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdHigh));
;;;849        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdLow));
;;;850        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdHigh));
;;;851        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdLow));
;;;852        assert_param(IS_CAN_FILTER_MODE(sFilterConfig->FilterMode));
;;;853        assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
;;;854        assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
;;;855        assert_param(IS_CAN_FILTER_ACTIVATION(sFilterConfig->FilterActivation));
;;;856    
;;;857    #if   defined(CAN2)
;;;858        /* CAN1 and CAN2 are dual instances with 28 common filters banks */
;;;859        /* Select master instance to access the filter banks */
;;;860        can_ip = CAN1;
;;;861    
;;;862        /* Check the parameters */
;;;863        assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->FilterBank));
;;;864        assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->SlaveStartFilterBank));
;;;865    #else
;;;866        /* CAN1 is single instance with 14 dedicated filters banks */
;;;867    
;;;868        /* Check the parameters */
;;;869        assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
;;;870    #endif
;;;871    
;;;872        /* Initialisation mode for the filter */
;;;873        SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
;;;874    
;;;875    #if   defined(CAN2)
;;;876        /* Select the start filter number of CAN2 slave instance */
;;;877        CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
;;;878        SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
;;;879    
;;;880    #endif
;;;881        /* Convert filter number into bit position */
;;;882        filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
;;;883    
;;;884        /* Filter Deactivation */
;;;885        CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
;;;886    
;;;887        /* Filter Scale */
;;;888        if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
;;;889        {
;;;890          /* 16-bit scale for the filter */
;;;891          CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
;;;892    
;;;893          /* First 16-bit identifier and First 16-bit mask */
;;;894          /* Or First 16-bit identifier and Second 16-bit identifier */
;;;895          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
;;;896            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
;;;897            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
;;;898    
;;;899          /* Second 16-bit identifier and Second 16-bit mask */
;;;900          /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;901          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
;;;902            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
;;;903            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
;;;904        }
;;;905    
;;;906        if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
;;;907        {
;;;908          /* 32-bit scale for the filter */
;;;909          SET_BIT(can_ip->FS1R, filternbrbitpos);
;;;910    
;;;911          /* 32-bit identifier or First 32-bit identifier */
;;;912          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
;;;913            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
;;;914            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
;;;915    
;;;916          /* 32-bit mask or Second 32-bit identifier */
;;;917          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
;;;918            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
;;;919            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
;;;920        }
;;;921    
;;;922        /* Filter Mode */
;;;923        if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
;;;924        {
;;;925          /* Id/Mask mode for the filter*/
;;;926          CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
;;;927        }
;;;928        else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;929        {
;;;930          /* Identifier list mode for the filter*/
;;;931          SET_BIT(can_ip->FM1R, filternbrbitpos);
;;;932        }
;;;933    
;;;934        /* Filter FIFO assignment */
;;;935        if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
;;;936        {
;;;937          /* FIFO 0 assignation for the filter */
;;;938          CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
;;;939        }
;;;940        else
;;;941        {
;;;942          /* FIFO 1 assignation for the filter */
;;;943          SET_BIT(can_ip->FFA1R, filternbrbitpos);
;;;944        }
;;;945    
;;;946        /* Filter activation */
;;;947        if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
;;;948        {
;;;949          SET_BIT(can_ip->FA1R, filternbrbitpos);
;;;950        }
;;;951    
;;;952        /* Leave the initialisation mode for the filter */
;;;953        CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
;;;954    
;;;955        /* Return function status */
;;;956        return HAL_OK;
;;;957      }
;;;958      else
;;;959      {
;;;960        /* Update error code */
;;;961        hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
00000e  6a41              LDR      r1,[r0,#0x24]
000010  f4412180          ORR      r1,r1,#0x40000
000014  6241              STR      r1,[r0,#0x24]
;;;962    
;;;963        return HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;964      }
;;;965    }
000018  bd10              POP      {r4,pc}
                  |L4.26|
00001a  483c              LDR      r0,|L4.268|
00001c  f5007000          ADD      r0,r0,#0x200          ;873
000020  6802              LDR      r2,[r0,#0]            ;873
000022  f0420201          ORR      r2,r2,#1              ;873
000026  6002              STR      r2,[r0,#0]            ;873
000028  6802              LDR      r2,[r0,#0]            ;877
00002a  f422527c          BIC      r2,r2,#0x3f00         ;877
00002e  6002              STR      r2,[r0,#0]            ;877
000030  6802              LDR      r2,[r0,#0]            ;878
000032  6a4b              LDR      r3,[r1,#0x24]         ;878
000034  ea422203          ORR      r2,r2,r3,LSL #8       ;878
000038  6002              STR      r2,[r0,#0]            ;878
00003a  7d0a              LDRB     r2,[r1,#0x14]         ;882
00003c  f002031f          AND      r3,r2,#0x1f           ;882
000040  2201              MOVS     r2,#1                 ;882
000042  409a              LSLS     r2,r2,r3              ;882
000044  69c3              LDR      r3,[r0,#0x1c]         ;885
000046  4393              BICS     r3,r3,r2              ;885
000048  61c3              STR      r3,[r0,#0x1c]         ;885
00004a  f5a07000          SUB      r0,r0,#0x200          ;885
00004e  69cb              LDR      r3,[r1,#0x1c]         ;888
000050  b9b3              CBNZ     r3,|L4.128|
000052  f8d0320c          LDR      r3,[r0,#0x20c]        ;891
000056  4393              BICS     r3,r3,r2              ;891
000058  f8c0320c          STR      r3,[r0,#0x20c]        ;891
00005c  898c              LDRH     r4,[r1,#0xc]          ;895
00005e  684b              LDR      r3,[r1,#4]            ;895
000060  f364431f          BFI      r3,r4,#16,#16         ;895
000064  694c              LDR      r4,[r1,#0x14]         ;895
000066  eb0004c4          ADD      r4,r0,r4,LSL #3       ;895
00006a  f8c43240          STR      r3,[r4,#0x240]        ;895
00006e  890c              LDRH     r4,[r1,#8]            ;901
000070  680b              LDR      r3,[r1,#0]            ;901
000072  f364431f          BFI      r3,r4,#16,#16         ;901
000076  694c              LDR      r4,[r1,#0x14]         ;901
000078  eb0004c4          ADD      r4,r0,r4,LSL #3       ;901
00007c  f8c43244          STR      r3,[r4,#0x244]        ;901
                  |L4.128|
000080  69cb              LDR      r3,[r1,#0x1c]         ;906
000082  2b01              CMP      r3,#1                 ;906
000084  d116              BNE      |L4.180|
000086  f8d0320c          LDR      r3,[r0,#0x20c]        ;909
00008a  4313              ORRS     r3,r3,r2              ;909
00008c  f8c0320c          STR      r3,[r0,#0x20c]        ;909
000090  880c              LDRH     r4,[r1,#0]            ;912
000092  684b              LDR      r3,[r1,#4]            ;912
000094  f364431f          BFI      r3,r4,#16,#16         ;912
000098  694c              LDR      r4,[r1,#0x14]         ;912
00009a  eb0004c4          ADD      r4,r0,r4,LSL #3       ;912
00009e  f8c43240          STR      r3,[r4,#0x240]        ;912
0000a2  890c              LDRH     r4,[r1,#8]            ;917
0000a4  68cb              LDR      r3,[r1,#0xc]          ;917
0000a6  f364431f          BFI      r3,r4,#16,#16         ;917
0000aa  694c              LDR      r4,[r1,#0x14]         ;917
0000ac  eb0004c4          ADD      r4,r0,r4,LSL #3       ;917
0000b0  f8c43244          STR      r3,[r4,#0x244]        ;917
                  |L4.180|
0000b4  698b              LDR      r3,[r1,#0x18]         ;923
0000b6  b17b              CBZ      r3,|L4.216|
0000b8  f8d03204          LDR      r3,[r0,#0x204]        ;931
0000bc  4313              ORRS     r3,r3,r2              ;931
0000be  f8c03204          STR      r3,[r0,#0x204]        ;931
                  |L4.194|
0000c2  690b              LDR      r3,[r1,#0x10]         ;935
0000c4  b173              CBZ      r3,|L4.228|
0000c6  f8d03214          LDR      r3,[r0,#0x214]        ;943
0000ca  4313              ORRS     r3,r3,r2              ;943
0000cc  f8c03214          STR      r3,[r0,#0x214]        ;943
                  |L4.208|
0000d0  6a09              LDR      r1,[r1,#0x20]         ;947
0000d2  2901              CMP      r1,#1                 ;947
0000d4  d00c              BEQ      |L4.240|
0000d6  e010              B        |L4.250|
                  |L4.216|
0000d8  f8d03204          LDR      r3,[r0,#0x204]        ;926
0000dc  4393              BICS     r3,r3,r2              ;926
0000de  f8c03204          STR      r3,[r0,#0x204]        ;926
0000e2  e7ee              B        |L4.194|
                  |L4.228|
0000e4  f8d03214          LDR      r3,[r0,#0x214]        ;938
0000e8  4393              BICS     r3,r3,r2              ;938
0000ea  f8c03214          STR      r3,[r0,#0x214]        ;938
0000ee  e7ef              B        |L4.208|
                  |L4.240|
0000f0  f8d0121c          LDR      r1,[r0,#0x21c]        ;949
0000f4  4311              ORRS     r1,r1,r2              ;949
0000f6  f8c0121c          STR      r1,[r0,#0x21c]        ;949
                  |L4.250|
0000fa  f8d01200          LDR      r1,[r0,#0x200]        ;953
0000fe  f0210101          BIC      r1,r1,#1              ;953
000102  f8c01200          STR      r1,[r0,#0x200]        ;953
000106  2000              MOVS     r0,#0                 ;956
000108  bd10              POP      {r4,pc}
;;;966    
                          ENDP

00010a  0000              DCW      0x0000
                  |L4.268|
                          DCD      0x40006400

                          AREA ||i.HAL_CAN_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_DeInit PROC
;;;458      */
;;;459    HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef *hcan)
000000  b510              PUSH     {r4,lr}
;;;460    {
000002  4604              MOV      r4,r0
;;;461      /* Check CAN handle */
;;;462      if (hcan == NULL)
000004  2c00              CMP      r4,#0
000006  d00f              BEQ      |L5.40|
;;;463      {
;;;464        return HAL_ERROR;
;;;465      }
;;;466    
;;;467      /* Check the parameters */
;;;468      assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;469    
;;;470      /* Stop the CAN module */
;;;471      (void)HAL_CAN_Stop(hcan);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       HAL_CAN_Stop
;;;472    
;;;473    #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;474      if (hcan->MspDeInitCallback == NULL)
;;;475      {
;;;476        hcan->MspDeInitCallback = HAL_CAN_MspDeInit; /* Legacy weak MspDeInit */
;;;477      }
;;;478    
;;;479      /* DeInit the low level hardware: CLOCK, NVIC */
;;;480      hcan->MspDeInitCallback(hcan);
;;;481    
;;;482    #else
;;;483      /* DeInit the low level hardware: CLOCK, NVIC */
;;;484      HAL_CAN_MspDeInit(hcan);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_CAN_MspDeInit
;;;485    #endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
;;;486    
;;;487      /* Reset the CAN peripheral */
;;;488      SET_BIT(hcan->Instance->MCR, CAN_MCR_RESET);
000014  6820              LDR      r0,[r4,#0]
000016  6801              LDR      r1,[r0,#0]
000018  f4414100          ORR      r1,r1,#0x8000
00001c  6001              STR      r1,[r0,#0]
;;;489    
;;;490      /* Reset the CAN ErrorCode */
;;;491      hcan->ErrorCode = HAL_CAN_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  6260              STR      r0,[r4,#0x24]
;;;492    
;;;493      /* Change CAN state */
;;;494      hcan->State = HAL_CAN_STATE_RESET;
000022  f8840020          STRB     r0,[r4,#0x20]
;;;495    
;;;496      /* Return function status */
;;;497      return HAL_OK;
;;;498    }
000026  bd10              POP      {r4,pc}
                  |L5.40|
000028  2001              MOVS     r0,#1                 ;464
00002a  bd10              POP      {r4,pc}
;;;499    
                          ENDP


                          AREA ||i.HAL_CAN_DeactivateNotification||, CODE, READONLY, ALIGN=1

                  HAL_CAN_DeactivateNotification PROC
;;;1663     */
;;;1664   HAL_StatusTypeDef HAL_CAN_DeactivateNotification(CAN_HandleTypeDef *hcan, uint32_t InactiveITs)
000000  f8902020          LDRB     r2,[r0,#0x20]
;;;1665   {
;;;1666     HAL_CAN_StateTypeDef state = hcan->State;
;;;1667   
;;;1668     /* Check function parameters */
;;;1669     assert_param(IS_CAN_IT(InactiveITs));
;;;1670   
;;;1671     if ((state == HAL_CAN_STATE_READY) ||
000004  2a01              CMP      r2,#1
000006  d007              BEQ      |L6.24|
;;;1672         (state == HAL_CAN_STATE_LISTENING))
000008  2a02              CMP      r2,#2
00000a  d005              BEQ      |L6.24|
;;;1673     {
;;;1674       /* Disable the selected interrupts */
;;;1675       __HAL_CAN_DISABLE_IT(hcan, InactiveITs);
;;;1676   
;;;1677       /* Return function status */
;;;1678       return HAL_OK;
;;;1679     }
;;;1680     else
;;;1681     {
;;;1682       /* Update error code */
;;;1683       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  f4412180          ORR      r1,r1,#0x40000
000012  6241              STR      r1,[r0,#0x24]
;;;1684   
;;;1685       return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;1686     }
;;;1687   }
000016  4770              BX       lr
                  |L6.24|
000018  6800              LDR      r0,[r0,#0]            ;1675
00001a  6942              LDR      r2,[r0,#0x14]         ;1675
00001c  438a              BICS     r2,r2,r1              ;1675
00001e  6142              STR      r2,[r0,#0x14]         ;1675
000020  2000              MOVS     r0,#0                 ;1678
000022  4770              BX       lr
;;;1688   
                          ENDP


                          AREA ||i.HAL_CAN_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ErrorCallback PROC
;;;2308     */
;;;2309   __weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2310   {
;;;2311     /* Prevent unused argument(s) compilation warning */
;;;2312     UNUSED(hcan);
;;;2313   
;;;2314     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2315               the HAL_CAN_ErrorCallback could be implemented in the user file
;;;2316      */
;;;2317   }
;;;2318   
                          ENDP


                          AREA ||i.HAL_CAN_GetError||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetError PROC
;;;2380     */
;;;2381   uint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan)
000000  6a40              LDR      r0,[r0,#0x24]
;;;2382   {
;;;2383     /* Return CAN error code */
;;;2384     return hcan->ErrorCode;
;;;2385   }
000002  4770              BX       lr
;;;2386   
                          ENDP


                          AREA ||i.HAL_CAN_GetRxFifoFillLevel||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetRxFifoFillLevel PROC
;;;1577     */
;;;1578   uint32_t HAL_CAN_GetRxFifoFillLevel(CAN_HandleTypeDef *hcan, uint32_t RxFifo)
000000  4602              MOV      r2,r0
;;;1579   {
;;;1580     uint32_t filllevel = 0U;
000002  2000              MOVS     r0,#0
;;;1581     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8923020          LDRB     r3,[r2,#0x20]
;;;1582   
;;;1583     /* Check function parameters */
;;;1584     assert_param(IS_CAN_RX_FIFO(RxFifo));
;;;1585   
;;;1586     if ((state == HAL_CAN_STATE_READY) ||
000008  2b01              CMP      r3,#1
00000a  d001              BEQ      |L9.16|
;;;1587         (state == HAL_CAN_STATE_LISTENING))
00000c  2b02              CMP      r3,#2
00000e  d104              BNE      |L9.26|
                  |L9.16|
;;;1588     {
;;;1589       if (RxFifo == CAN_RX_FIFO0)
000010  b121              CBZ      r1,|L9.28|
;;;1590       {
;;;1591         filllevel = hcan->Instance->RF0R & CAN_RF0R_FMP0;
;;;1592       }
;;;1593       else /* RxFifo == CAN_RX_FIFO1 */
;;;1594       {
;;;1595         filllevel = hcan->Instance->RF1R & CAN_RF1R_FMP1;
000012  6810              LDR      r0,[r2,#0]
000014  6900              LDR      r0,[r0,#0x10]
000016  f0000003          AND      r0,r0,#3
                  |L9.26|
;;;1596       }
;;;1597     }
;;;1598   
;;;1599     /* Return Rx FIFO fill level */
;;;1600     return filllevel;
;;;1601   }
00001a  4770              BX       lr
                  |L9.28|
00001c  6810              LDR      r0,[r2,#0]            ;1591
00001e  68c0              LDR      r0,[r0,#0xc]          ;1591
000020  f0000003          AND      r0,r0,#3              ;1591
000024  4770              BX       lr
;;;1602   
                          ENDP


                          AREA ||i.HAL_CAN_GetRxMessage||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetRxMessage PROC
;;;1487     */
;;;1488   HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
000000  b530              PUSH     {r4,r5,lr}
;;;1489   {
;;;1490     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8904020          LDRB     r4,[r0,#0x20]
;;;1491   
;;;1492     assert_param(IS_CAN_RX_FIFO(RxFifo));
;;;1493   
;;;1494     if ((state == HAL_CAN_STATE_READY) ||
000006  2c01              CMP      r4,#1
000008  d007              BEQ      |L10.26|
;;;1495         (state == HAL_CAN_STATE_LISTENING))
00000a  2c02              CMP      r4,#2
00000c  d005              BEQ      |L10.26|
;;;1496     {
;;;1497       /* Check the Rx FIFO */
;;;1498       if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
;;;1499       {
;;;1500         /* Check that the Rx FIFO 0 is not empty */
;;;1501         if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
;;;1502         {
;;;1503           /* Update error code */
;;;1504           hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
;;;1505   
;;;1506           return HAL_ERROR;
;;;1507         }
;;;1508       }
;;;1509       else /* Rx element is assigned to Rx FIFO 1 */
;;;1510       {
;;;1511         /* Check that the Rx FIFO 1 is not empty */
;;;1512         if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
;;;1513         {
;;;1514           /* Update error code */
;;;1515           hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
;;;1516   
;;;1517           return HAL_ERROR;
;;;1518         }
;;;1519       }
;;;1520   
;;;1521       /* Get the header */
;;;1522       pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
;;;1523       if (pHeader->IDE == CAN_ID_STD)
;;;1524       {
;;;1525         pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
;;;1526       }
;;;1527       else
;;;1528       {
;;;1529         pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
;;;1530       }
;;;1531       pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);
;;;1532       pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
;;;1533       pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
;;;1534       pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
;;;1535   
;;;1536       /* Get the data */
;;;1537       aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
;;;1538       aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
;;;1539       aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
;;;1540       aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
;;;1541       aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
;;;1542       aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
;;;1543       aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
;;;1544       aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
;;;1545   
;;;1546       /* Release the FIFO */
;;;1547       if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
;;;1548       {
;;;1549         /* Release RX FIFO 0 */
;;;1550         SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
;;;1551       }
;;;1552       else /* Rx element is assigned to Rx FIFO 1 */
;;;1553       {
;;;1554         /* Release RX FIFO 1 */
;;;1555         SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
;;;1556       }
;;;1557   
;;;1558       /* Return function status */
;;;1559       return HAL_OK;
;;;1560     }
;;;1561     else
;;;1562     {
;;;1563       /* Update error code */
;;;1564       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
00000e  6a41              LDR      r1,[r0,#0x24]
000010  f4412180          ORR      r1,r1,#0x40000
000014  6241              STR      r1,[r0,#0x24]
;;;1565   
;;;1566       return HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;1567     }
;;;1568   }
000018  bd30              POP      {r4,r5,pc}
                  |L10.26|
00001a  b121              CBZ      r1,|L10.38|
00001c  6804              LDR      r4,[r0,#0]            ;1512
00001e  6924              LDR      r4,[r4,#0x10]         ;1512
000020  07a4              LSLS     r4,r4,#30             ;1512
000022  d05f              BEQ      |L10.228|
000024  e003              B        |L10.46|
                  |L10.38|
000026  6804              LDR      r4,[r0,#0]            ;1501
000028  68e4              LDR      r4,[r4,#0xc]          ;1501
00002a  07a4              LSLS     r4,r4,#30             ;1501
00002c  d054              BEQ      |L10.216|
                  |L10.46|
00002e  f44f74d8          MOV      r4,#0x1b0             ;1522
000032  6805              LDR      r5,[r0,#0]            ;1522
000034  eb041401          ADD      r4,r4,r1,LSL #4       ;1522
000038  592d              LDR      r5,[r5,r4]            ;1522
00003a  f0050504          AND      r5,r5,#4              ;1522
00003e  6095              STR      r5,[r2,#8]            ;1522
000040  b3f5              CBZ      r5,|L10.192|
000042  6805              LDR      r5,[r0,#0]            ;1529
000044  592d              LDR      r5,[r5,r4]            ;1529
000046  08ed              LSRS     r5,r5,#3              ;1529
000048  6055              STR      r5,[r2,#4]            ;1529
                  |L10.74|
00004a  6805              LDR      r5,[r0,#0]            ;1531
00004c  592c              LDR      r4,[r5,r4]            ;1531
00004e  f0040402          AND      r4,r4,#2              ;1531
000052  60d4              STR      r4,[r2,#0xc]          ;1531
000054  f44f74da          MOV      r4,#0x1b4             ;1532
000058  6805              LDR      r5,[r0,#0]            ;1532
00005a  eb041401          ADD      r4,r4,r1,LSL #4       ;1532
00005e  592d              LDR      r5,[r5,r4]            ;1532
000060  f005050f          AND      r5,r5,#0xf            ;1532
000064  6115              STR      r5,[r2,#0x10]         ;1532
000066  6805              LDR      r5,[r0,#0]            ;1533
000068  592d              LDR      r5,[r5,r4]            ;1533
00006a  f3c52507          UBFX     r5,r5,#8,#8           ;1533
00006e  6195              STR      r5,[r2,#0x18]         ;1533
000070  6805              LDR      r5,[r0,#0]            ;1534
000072  592c              LDR      r4,[r5,r4]            ;1534
000074  0c24              LSRS     r4,r4,#16             ;1534
000076  6154              STR      r4,[r2,#0x14]         ;1534
000078  f44f72dc          MOV      r2,#0x1b8             ;1537
00007c  6804              LDR      r4,[r0,#0]            ;1537
00007e  eb021201          ADD      r2,r2,r1,LSL #4       ;1537
000082  58a4              LDR      r4,[r4,r2]            ;1537
000084  701c              STRB     r4,[r3,#0]            ;1537
000086  6804              LDR      r4,[r0,#0]            ;1538
000088  58a4              LDR      r4,[r4,r2]            ;1538
00008a  0a24              LSRS     r4,r4,#8              ;1538
00008c  705c              STRB     r4,[r3,#1]            ;1538
00008e  6804              LDR      r4,[r0,#0]            ;1539
000090  58a4              LDR      r4,[r4,r2]            ;1539
000092  0c24              LSRS     r4,r4,#16             ;1539
000094  709c              STRB     r4,[r3,#2]            ;1539
000096  6804              LDR      r4,[r0,#0]            ;1540
000098  58a2              LDR      r2,[r4,r2]            ;1540
00009a  0e12              LSRS     r2,r2,#24             ;1540
00009c  70da              STRB     r2,[r3,#3]            ;1540
00009e  f44f72de          MOV      r2,#0x1bc             ;1541
0000a2  6804              LDR      r4,[r0,#0]            ;1541
0000a4  eb021201          ADD      r2,r2,r1,LSL #4       ;1541
0000a8  58a4              LDR      r4,[r4,r2]            ;1541
0000aa  711c              STRB     r4,[r3,#4]            ;1541
0000ac  6804              LDR      r4,[r0,#0]            ;1542
0000ae  58a4              LDR      r4,[r4,r2]            ;1542
0000b0  0a24              LSRS     r4,r4,#8              ;1542
0000b2  715c              STRB     r4,[r3,#5]            ;1542
0000b4  6804              LDR      r4,[r0,#0]            ;1543
0000b6  58a4              LDR      r4,[r4,r2]            ;1543
0000b8  0c24              LSRS     r4,r4,#16             ;1543
0000ba  719c              STRB     r4,[r3,#6]            ;1543
0000bc  6804              LDR      r4,[r0,#0]            ;1544
0000be  e000              B        |L10.194|
                  |L10.192|
0000c0  e016              B        |L10.240|
                  |L10.194|
0000c2  58a2              LDR      r2,[r4,r2]            ;1544
0000c4  0e12              LSRS     r2,r2,#24             ;1544
0000c6  71da              STRB     r2,[r3,#7]            ;1544
0000c8  b1b9              CBZ      r1,|L10.250|
0000ca  6800              LDR      r0,[r0,#0]            ;1555
0000cc  6901              LDR      r1,[r0,#0x10]         ;1555
0000ce  f0410120          ORR      r1,r1,#0x20           ;1555
0000d2  6101              STR      r1,[r0,#0x10]         ;1555
                  |L10.212|
0000d4  2000              MOVS     r0,#0                 ;1559
0000d6  bd30              POP      {r4,r5,pc}
                  |L10.216|
0000d8  6a41              LDR      r1,[r0,#0x24]         ;1504
0000da  f4411100          ORR      r1,r1,#0x200000       ;1504
0000de  6241              STR      r1,[r0,#0x24]         ;1504
0000e0  2001              MOVS     r0,#1                 ;1506
0000e2  bd30              POP      {r4,r5,pc}
                  |L10.228|
0000e4  6a41              LDR      r1,[r0,#0x24]         ;1515
0000e6  f4411100          ORR      r1,r1,#0x200000       ;1515
0000ea  6241              STR      r1,[r0,#0x24]         ;1515
0000ec  2001              MOVS     r0,#1                 ;1517
0000ee  bd30              POP      {r4,r5,pc}
                  |L10.240|
0000f0  6805              LDR      r5,[r0,#0]            ;1525
0000f2  592d              LDR      r5,[r5,r4]            ;1525
0000f4  0d6d              LSRS     r5,r5,#21             ;1525
0000f6  6015              STR      r5,[r2,#0]            ;1525
0000f8  e7a7              B        |L10.74|
                  |L10.250|
0000fa  6800              LDR      r0,[r0,#0]            ;1550
0000fc  68c1              LDR      r1,[r0,#0xc]          ;1550
0000fe  f0410120          ORR      r1,r1,#0x20           ;1550
000102  60c1              STR      r1,[r0,#0xc]          ;1550
000104  e7e6              B        |L10.212|
;;;1569   
                          ENDP


                          AREA ||i.HAL_CAN_GetState||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetState PROC
;;;2345     */
;;;2346   HAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;2347   {
;;;2348     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8910020          LDRB     r0,[r1,#0x20]
;;;2349   
;;;2350     if ((state == HAL_CAN_STATE_READY) ||
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L11.14|
;;;2351         (state == HAL_CAN_STATE_LISTENING))
00000a  2802              CMP      r0,#2
00000c  d104              BNE      |L11.24|
                  |L11.14|
;;;2352     {
;;;2353       /* Check sleep mode acknowledge flag */
;;;2354       if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
00000e  6809              LDR      r1,[r1,#0]
000010  684a              LDR      r2,[r1,#4]
000012  0792              LSLS     r2,r2,#30
000014  d501              BPL      |L11.26|
;;;2355       {
;;;2356         /* Sleep mode is active */
;;;2357         state = HAL_CAN_STATE_SLEEP_ACTIVE;
000016  2004              MOVS     r0,#4
                  |L11.24|
;;;2358       }
;;;2359       /* Check sleep mode request flag */
;;;2360       else if ((hcan->Instance->MCR & CAN_MCR_SLEEP) != 0U)
;;;2361       {
;;;2362         /* Sleep mode request is pending */
;;;2363         state = HAL_CAN_STATE_SLEEP_PENDING;
;;;2364       }
;;;2365       else
;;;2366       {
;;;2367         /* Neither sleep mode request nor sleep mode acknowledge */
;;;2368       }
;;;2369     }
;;;2370   
;;;2371     /* Return CAN state */
;;;2372     return state;
;;;2373   }
000018  4770              BX       lr
                  |L11.26|
00001a  6809              LDR      r1,[r1,#0]            ;2360
00001c  0789              LSLS     r1,r1,#30             ;2360
00001e  d5fb              BPL      |L11.24|
000020  2003              MOVS     r0,#3                 ;2363
000022  4770              BX       lr
;;;2374   
                          ENDP


                          AREA ||i.HAL_CAN_GetTxMailboxesFreeLevel||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetTxMailboxesFreeLevel PROC
;;;1378     */
;;;1379   uint32_t HAL_CAN_GetTxMailboxesFreeLevel(CAN_HandleTypeDef *hcan)
000000  4602              MOV      r2,r0
;;;1380   {
;;;1381     uint32_t freelevel = 0U;
000002  2000              MOVS     r0,#0
;;;1382     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8921020          LDRB     r1,[r2,#0x20]
;;;1383   
;;;1384     if ((state == HAL_CAN_STATE_READY) ||
000008  2901              CMP      r1,#1
00000a  d001              BEQ      |L12.16|
;;;1385         (state == HAL_CAN_STATE_LISTENING))
00000c  2902              CMP      r1,#2
00000e  d10c              BNE      |L12.42|
                  |L12.16|
;;;1386     {
;;;1387       /* Check Tx Mailbox 0 status */
;;;1388       if ((hcan->Instance->TSR & CAN_TSR_TME0) != 0U)
000010  6811              LDR      r1,[r2,#0]
000012  688a              LDR      r2,[r1,#8]
000014  0152              LSLS     r2,r2,#5
000016  d500              BPL      |L12.26|
;;;1389       {
;;;1390         freelevel++;
000018  2001              MOVS     r0,#1
                  |L12.26|
;;;1391       }
;;;1392   
;;;1393       /* Check Tx Mailbox 1 status */
;;;1394       if ((hcan->Instance->TSR & CAN_TSR_TME1) != 0U)
00001a  688a              LDR      r2,[r1,#8]
00001c  0112              LSLS     r2,r2,#4
00001e  d500              BPL      |L12.34|
;;;1395       {
;;;1396         freelevel++;
000020  1c40              ADDS     r0,r0,#1
                  |L12.34|
;;;1397       }
;;;1398   
;;;1399       /* Check Tx Mailbox 2 status */
;;;1400       if ((hcan->Instance->TSR & CAN_TSR_TME2) != 0U)
000022  6889              LDR      r1,[r1,#8]
000024  00c9              LSLS     r1,r1,#3
000026  d500              BPL      |L12.42|
;;;1401       {
;;;1402         freelevel++;
000028  1c40              ADDS     r0,r0,#1
                  |L12.42|
;;;1403       }
;;;1404     }
;;;1405   
;;;1406     /* Return Tx Mailboxes free level */
;;;1407     return freelevel;
;;;1408   }
00002a  4770              BX       lr
;;;1409   
                          ENDP


                          AREA ||i.HAL_CAN_GetTxTimestamp||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetTxTimestamp PROC
;;;1453     */
;;;1454   uint32_t HAL_CAN_GetTxTimestamp(CAN_HandleTypeDef *hcan, uint32_t TxMailbox)
000000  4603              MOV      r3,r0
;;;1455   {
;;;1456     uint32_t timestamp = 0U;
000002  2000              MOVS     r0,#0
;;;1457     uint32_t transmitmailbox;
;;;1458     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8932020          LDRB     r2,[r3,#0x20]
;;;1459   
;;;1460     /* Check function parameters */
;;;1461     assert_param(IS_CAN_TX_MAILBOX(TxMailbox));
;;;1462   
;;;1463     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L13.16|
;;;1464         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d10a              BNE      |L13.38|
                  |L13.16|
;;;1465     {
;;;1466       /* Select the Tx mailbox */
;;;1467       transmitmailbox = POSITION_VAL(TxMailbox);
000010  fa91f0a1          RBIT     r0,r1
000014  fab0f080          CLZ      r0,r0
;;;1468   
;;;1469       /* Get timestamp */
;;;1470       timestamp = (hcan->Instance->sTxMailBox[transmitmailbox].TDTR & CAN_TDT0R_TIME) >> CAN_TDT0R_TIME_Pos;
000018  f44f72c2          MOV      r2,#0x184
00001c  6819              LDR      r1,[r3,#0]
00001e  eb021000          ADD      r0,r2,r0,LSL #4
000022  5808              LDR      r0,[r1,r0]
000024  0c00              LSRS     r0,r0,#16
                  |L13.38|
;;;1471     }
;;;1472   
;;;1473     /* Return the timestamp */
;;;1474     return timestamp;
;;;1475   }
000026  4770              BX       lr
;;;1476   
                          ENDP


                          AREA ||i.HAL_CAN_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IRQHandler PROC
;;;1694     */
;;;1695   void HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1696   {
000004  4605              MOV      r5,r0
;;;1697     uint32_t errorcode = HAL_CAN_ERROR_NONE;
000006  2400              MOVS     r4,#0
;;;1698     uint32_t interrupts = READ_REG(hcan->Instance->IER);
000008  6828              LDR      r0,[r5,#0]
00000a  6946              LDR      r6,[r0,#0x14]
;;;1699     uint32_t msrflags = READ_REG(hcan->Instance->MSR);
00000c  f8d09004          LDR      r9,[r0,#4]
;;;1700     uint32_t tsrflags = READ_REG(hcan->Instance->TSR);
000010  6887              LDR      r7,[r0,#8]
;;;1701     uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
000012  f8d0a00c          LDR      r10,[r0,#0xc]
;;;1702     uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
000016  f8d0b010          LDR      r11,[r0,#0x10]
;;;1703     uint32_t esrflags = READ_REG(hcan->Instance->ESR);
00001a  f8d08018          LDR      r8,[r0,#0x18]
;;;1704   
;;;1705     /* Transmit Mailbox empty interrupt management *****************************/
;;;1706     if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
00001e  07f1              LSLS     r1,r6,#31
000020  d048              BEQ      |L14.180|
;;;1707     {
;;;1708       /* Transmit Mailbox 0 management *****************************************/
;;;1709       if ((tsrflags & CAN_TSR_RQCP0) != 0U)
000022  07f9              LSLS     r1,r7,#31
000024  d014              BEQ      |L14.80|
;;;1710       {
;;;1711         /* Clear the Transmission Complete flag (and TXOK0,ALST0,TERR0 bits) */
;;;1712         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
000026  2101              MOVS     r1,#1
000028  6081              STR      r1,[r0,#8]
;;;1713   
;;;1714         if ((tsrflags & CAN_TSR_TXOK0) != 0U)
00002a  07b8              LSLS     r0,r7,#30
00002c  d503              BPL      |L14.54|
;;;1715         {
;;;1716           /* Transmission Mailbox 0 complete callback */
;;;1717   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1718           /* Call registered callback*/
;;;1719           hcan->TxMailbox0CompleteCallback(hcan);
;;;1720   #else
;;;1721           /* Call weak (surcharged) callback */
;;;1722           HAL_CAN_TxMailbox0CompleteCallback(hcan);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       HAL_CAN_TxMailbox0CompleteCallback
000034  e00c              B        |L14.80|
                  |L14.54|
;;;1723   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1724         }
;;;1725         else
;;;1726         {
;;;1727           if ((tsrflags & CAN_TSR_ALST0) != 0U)
000036  0778              LSLS     r0,r7,#29
000038  d502              BPL      |L14.64|
;;;1728           {
;;;1729             /* Update error code */
;;;1730             errorcode |= HAL_CAN_ERROR_TX_ALST0;
00003a  f44f6400          MOV      r4,#0x800
00003e  e007              B        |L14.80|
                  |L14.64|
;;;1731           }
;;;1732           else if ((tsrflags & CAN_TSR_TERR0) != 0U)
000040  0738              LSLS     r0,r7,#28
000042  d502              BPL      |L14.74|
;;;1733           {
;;;1734             /* Update error code */
;;;1735             errorcode |= HAL_CAN_ERROR_TX_TERR0;
000044  f44f5480          MOV      r4,#0x1000
000048  e002              B        |L14.80|
                  |L14.74|
;;;1736           }
;;;1737           else
;;;1738           {
;;;1739             /* Transmission Mailbox 0 abort callback */
;;;1740   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1741             /* Call registered callback*/
;;;1742             hcan->TxMailbox0AbortCallback(hcan);
;;;1743   #else
;;;1744             /* Call weak (surcharged) callback */
;;;1745             HAL_CAN_TxMailbox0AbortCallback(hcan);
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       HAL_CAN_TxMailbox0AbortCallback
                  |L14.80|
;;;1746   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1747           }
;;;1748         }
;;;1749       }
;;;1750   
;;;1751       /* Transmit Mailbox 1 management *****************************************/
;;;1752       if ((tsrflags & CAN_TSR_RQCP1) != 0U)
000050  05f8              LSLS     r0,r7,#23
000052  d516              BPL      |L14.130|
;;;1753       {
;;;1754         /* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */
;;;1755         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);
000054  6829              LDR      r1,[r5,#0]
000056  f44f7080          MOV      r0,#0x100
00005a  6088              STR      r0,[r1,#8]
;;;1756   
;;;1757         if ((tsrflags & CAN_TSR_TXOK1) != 0U)
00005c  05b8              LSLS     r0,r7,#22
00005e  d503              BPL      |L14.104|
;;;1758         {
;;;1759           /* Transmission Mailbox 1 complete callback */
;;;1760   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1761           /* Call registered callback*/
;;;1762           hcan->TxMailbox1CompleteCallback(hcan);
;;;1763   #else
;;;1764           /* Call weak (surcharged) callback */
;;;1765           HAL_CAN_TxMailbox1CompleteCallback(hcan);
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       HAL_CAN_TxMailbox1CompleteCallback
000066  e00c              B        |L14.130|
                  |L14.104|
;;;1766   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1767         }
;;;1768         else
;;;1769         {
;;;1770           if ((tsrflags & CAN_TSR_ALST1) != 0U)
000068  0578              LSLS     r0,r7,#21
00006a  d502              BPL      |L14.114|
;;;1771           {
;;;1772             /* Update error code */
;;;1773             errorcode |= HAL_CAN_ERROR_TX_ALST1;
00006c  f4445400          ORR      r4,r4,#0x2000
000070  e007              B        |L14.130|
                  |L14.114|
;;;1774           }
;;;1775           else if ((tsrflags & CAN_TSR_TERR1) != 0U)
000072  0538              LSLS     r0,r7,#20
000074  d502              BPL      |L14.124|
;;;1776           {
;;;1777             /* Update error code */
;;;1778             errorcode |= HAL_CAN_ERROR_TX_TERR1;
000076  f4444480          ORR      r4,r4,#0x4000
00007a  e002              B        |L14.130|
                  |L14.124|
;;;1779           }
;;;1780           else
;;;1781           {
;;;1782             /* Transmission Mailbox 1 abort callback */
;;;1783   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1784             /* Call registered callback*/
;;;1785             hcan->TxMailbox1AbortCallback(hcan);
;;;1786   #else
;;;1787             /* Call weak (surcharged) callback */
;;;1788             HAL_CAN_TxMailbox1AbortCallback(hcan);
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       HAL_CAN_TxMailbox1AbortCallback
                  |L14.130|
;;;1789   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1790           }
;;;1791         }
;;;1792       }
;;;1793   
;;;1794       /* Transmit Mailbox 2 management *****************************************/
;;;1795       if ((tsrflags & CAN_TSR_RQCP2) != 0U)
000082  03f8              LSLS     r0,r7,#15
000084  d516              BPL      |L14.180|
;;;1796       {
;;;1797         /* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */
;;;1798         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
000086  6829              LDR      r1,[r5,#0]
000088  f44f3080          MOV      r0,#0x10000
00008c  6088              STR      r0,[r1,#8]
;;;1799   
;;;1800         if ((tsrflags & CAN_TSR_TXOK2) != 0U)
00008e  03b8              LSLS     r0,r7,#14
000090  d503              BPL      |L14.154|
;;;1801         {
;;;1802           /* Transmission Mailbox 2 complete callback */
;;;1803   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1804           /* Call registered callback*/
;;;1805           hcan->TxMailbox2CompleteCallback(hcan);
;;;1806   #else
;;;1807           /* Call weak (surcharged) callback */
;;;1808           HAL_CAN_TxMailbox2CompleteCallback(hcan);
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       HAL_CAN_TxMailbox2CompleteCallback
000098  e00c              B        |L14.180|
                  |L14.154|
;;;1809   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1810         }
;;;1811         else
;;;1812         {
;;;1813           if ((tsrflags & CAN_TSR_ALST2) != 0U)
00009a  0378              LSLS     r0,r7,#13
00009c  d502              BPL      |L14.164|
;;;1814           {
;;;1815             /* Update error code */
;;;1816             errorcode |= HAL_CAN_ERROR_TX_ALST2;
00009e  f4444400          ORR      r4,r4,#0x8000
0000a2  e007              B        |L14.180|
                  |L14.164|
;;;1817           }
;;;1818           else if ((tsrflags & CAN_TSR_TERR2) != 0U)
0000a4  0338              LSLS     r0,r7,#12
0000a6  d502              BPL      |L14.174|
;;;1819           {
;;;1820             /* Update error code */
;;;1821             errorcode |= HAL_CAN_ERROR_TX_TERR2;
0000a8  f4443480          ORR      r4,r4,#0x10000
0000ac  e002              B        |L14.180|
                  |L14.174|
;;;1822           }
;;;1823           else
;;;1824           {
;;;1825             /* Transmission Mailbox 2 abort callback */
;;;1826   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1827             /* Call registered callback*/
;;;1828             hcan->TxMailbox2AbortCallback(hcan);
;;;1829   #else
;;;1830             /* Call weak (surcharged) callback */
;;;1831             HAL_CAN_TxMailbox2AbortCallback(hcan);
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       HAL_CAN_TxMailbox2AbortCallback
                  |L14.180|
;;;1832   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1833           }
;;;1834         }
;;;1835       }
;;;1836     }
;;;1837   
;;;1838     /* Receive FIFO 0 overrun interrupt management *****************************/
;;;1839     if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)
0000b4  0730              LSLS     r0,r6,#28
0000b6  d507              BPL      |L14.200|
;;;1840     {
;;;1841       if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)
0000b8  ea5f60ca          LSLS     r0,r10,#27
0000bc  d504              BPL      |L14.200|
;;;1842       {
;;;1843         /* Set CAN error code to Rx Fifo 0 overrun error */
;;;1844         errorcode |= HAL_CAN_ERROR_RX_FOV0;
0000be  f4447400          ORR      r4,r4,#0x200
;;;1845   
;;;1846         /* Clear FIFO0 Overrun Flag */
;;;1847         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
0000c2  6829              LDR      r1,[r5,#0]
0000c4  2010              MOVS     r0,#0x10
0000c6  60c8              STR      r0,[r1,#0xc]
                  |L14.200|
;;;1848       }
;;;1849     }
;;;1850   
;;;1851     /* Receive FIFO 0 full interrupt management ********************************/
;;;1852     if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)
0000c8  0770              LSLS     r0,r6,#29
;;;1853     {
;;;1854       if ((rf0rflags & CAN_RF0R_FULL0) != 0U)
;;;1855       {
;;;1856         /* Clear FIFO 0 full Flag */
;;;1857         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
0000ca  f04f0708          MOV      r7,#8
0000ce  d507              BPL      |L14.224|
0000d0  ea5f700a          LSLS     r0,r10,#28            ;1854
0000d4  d504              BPL      |L14.224|
0000d6  6828              LDR      r0,[r5,#0]
0000d8  60c7              STR      r7,[r0,#0xc]
;;;1858   
;;;1859         /* Receive FIFO 0 full Callback */
;;;1860   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1861         /* Call registered callback*/
;;;1862         hcan->RxFifo0FullCallback(hcan);
;;;1863   #else
;;;1864         /* Call weak (surcharged) callback */
;;;1865         HAL_CAN_RxFifo0FullCallback(hcan);
0000da  4628              MOV      r0,r5
0000dc  f7fffffe          BL       HAL_CAN_RxFifo0FullCallback
                  |L14.224|
;;;1866   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1867       }
;;;1868     }
;;;1869   
;;;1870     /* Receive FIFO 0 message pending interrupt management *********************/
;;;1871     if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)
0000e0  07b0              LSLS     r0,r6,#30
0000e2  d506              BPL      |L14.242|
;;;1872     {
;;;1873       /* Check if message is still pending */
;;;1874       if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)
0000e4  6828              LDR      r0,[r5,#0]
0000e6  68c0              LDR      r0,[r0,#0xc]
0000e8  0780              LSLS     r0,r0,#30
0000ea  d002              BEQ      |L14.242|
;;;1875       {
;;;1876         /* Receive FIFO 0 mesage pending Callback */
;;;1877   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1878         /* Call registered callback*/
;;;1879         hcan->RxFifo0MsgPendingCallback(hcan);
;;;1880   #else
;;;1881         /* Call weak (surcharged) callback */
;;;1882         HAL_CAN_RxFifo0MsgPendingCallback(hcan);
0000ec  4628              MOV      r0,r5
0000ee  f7fffffe          BL       HAL_CAN_RxFifo0MsgPendingCallback
                  |L14.242|
;;;1883   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1884       }
;;;1885     }
;;;1886   
;;;1887     /* Receive FIFO 1 overrun interrupt management *****************************/
;;;1888     if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)
0000f2  0670              LSLS     r0,r6,#25
0000f4  d507              BPL      |L14.262|
;;;1889     {
;;;1890       if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)
0000f6  ea5f60cb          LSLS     r0,r11,#27
0000fa  d504              BPL      |L14.262|
;;;1891       {
;;;1892         /* Set CAN error code to Rx Fifo 1 overrun error */
;;;1893         errorcode |= HAL_CAN_ERROR_RX_FOV1;
0000fc  f4446480          ORR      r4,r4,#0x400
;;;1894   
;;;1895         /* Clear FIFO1 Overrun Flag */
;;;1896         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
000100  6829              LDR      r1,[r5,#0]
000102  2010              MOVS     r0,#0x10
000104  6108              STR      r0,[r1,#0x10]
                  |L14.262|
;;;1897       }
;;;1898     }
;;;1899   
;;;1900     /* Receive FIFO 1 full interrupt management ********************************/
;;;1901     if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)
000106  06b0              LSLS     r0,r6,#26
000108  d507              BPL      |L14.282|
;;;1902     {
;;;1903       if ((rf1rflags & CAN_RF1R_FULL1) != 0U)
00010a  ea5f700b          LSLS     r0,r11,#28
00010e  d504              BPL      |L14.282|
;;;1904       {
;;;1905         /* Clear FIFO 1 full Flag */
;;;1906         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
000110  6828              LDR      r0,[r5,#0]
000112  6107              STR      r7,[r0,#0x10]
;;;1907   
;;;1908         /* Receive FIFO 1 full Callback */
;;;1909   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1910         /* Call registered callback*/
;;;1911         hcan->RxFifo1FullCallback(hcan);
;;;1912   #else
;;;1913         /* Call weak (surcharged) callback */
;;;1914         HAL_CAN_RxFifo1FullCallback(hcan);
000114  4628              MOV      r0,r5
000116  f7fffffe          BL       HAL_CAN_RxFifo1FullCallback
                  |L14.282|
;;;1915   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1916       }
;;;1917     }
;;;1918   
;;;1919     /* Receive FIFO 1 message pending interrupt management *********************/
;;;1920     if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)
00011a  06f0              LSLS     r0,r6,#27
00011c  d506              BPL      |L14.300|
;;;1921     {
;;;1922       /* Check if message is still pending */
;;;1923       if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)
00011e  6828              LDR      r0,[r5,#0]
000120  6900              LDR      r0,[r0,#0x10]
000122  0780              LSLS     r0,r0,#30
000124  d002              BEQ      |L14.300|
;;;1924       {
;;;1925         /* Receive FIFO 1 mesage pending Callback */
;;;1926   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1927         /* Call registered callback*/
;;;1928         hcan->RxFifo1MsgPendingCallback(hcan);
;;;1929   #else
;;;1930         /* Call weak (surcharged) callback */
;;;1931         HAL_CAN_RxFifo1MsgPendingCallback(hcan);
000126  4628              MOV      r0,r5
000128  f7fffffe          BL       HAL_CAN_RxFifo1MsgPendingCallback
                  |L14.300|
;;;1932   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1933       }
;;;1934     }
;;;1935   
;;;1936     /* Sleep interrupt management *********************************************/
;;;1937     if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)
00012c  03b0              LSLS     r0,r6,#14
00012e  d508              BPL      |L14.322|
;;;1938     {
;;;1939       if ((msrflags & CAN_MSR_SLAKI) != 0U)
000130  ea5f60c9          LSLS     r0,r9,#27
000134  d505              BPL      |L14.322|
;;;1940       {
;;;1941         /* Clear Sleep interrupt Flag */
;;;1942         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
000136  6829              LDR      r1,[r5,#0]
000138  2010              MOVS     r0,#0x10
00013a  6048              STR      r0,[r1,#4]
;;;1943   
;;;1944         /* Sleep Callback */
;;;1945   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1946         /* Call registered callback*/
;;;1947         hcan->SleepCallback(hcan);
;;;1948   #else
;;;1949         /* Call weak (surcharged) callback */
;;;1950         HAL_CAN_SleepCallback(hcan);
00013c  4628              MOV      r0,r5
00013e  f7fffffe          BL       HAL_CAN_SleepCallback
                  |L14.322|
;;;1951   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1952       }
;;;1953     }
;;;1954   
;;;1955     /* WakeUp interrupt management *********************************************/
;;;1956     if ((interrupts & CAN_IT_WAKEUP) != 0U)
000142  03f0              LSLS     r0,r6,#15
000144  d507              BPL      |L14.342|
;;;1957     {
;;;1958       if ((msrflags & CAN_MSR_WKUI) != 0U)
000146  ea5f7009          LSLS     r0,r9,#28
00014a  d504              BPL      |L14.342|
;;;1959       {
;;;1960         /* Clear WakeUp Flag */
;;;1961         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
00014c  6828              LDR      r0,[r5,#0]
00014e  6047              STR      r7,[r0,#4]
;;;1962   
;;;1963         /* WakeUp Callback */
;;;1964   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1965         /* Call registered callback*/
;;;1966         hcan->WakeUpFromRxMsgCallback(hcan);
;;;1967   #else
;;;1968         /* Call weak (surcharged) callback */
;;;1969         HAL_CAN_WakeUpFromRxMsgCallback(hcan);
000150  4628              MOV      r0,r5
000152  f7fffffe          BL       HAL_CAN_WakeUpFromRxMsgCallback
                  |L14.342|
;;;1970   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1971       }
;;;1972     }
;;;1973   
;;;1974     /* Error interrupts management *********************************************/
;;;1975     if ((interrupts & CAN_IT_ERROR) != 0U)
000156  0430              LSLS     r0,r6,#16
000158  d546              BPL      |L14.488|
;;;1976     {
;;;1977       if ((msrflags & CAN_MSR_ERRI) != 0U)
00015a  ea5f7049          LSLS     r0,r9,#29
00015e  d540              BPL      |L14.482|
;;;1978       {
;;;1979         /* Check Error Warning Flag */
;;;1980         if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
000160  05f0              LSLS     r0,r6,#23
000162  d504              BPL      |L14.366|
;;;1981             ((esrflags & CAN_ESR_EWGF) != 0U))
000164  ea5f70c8          LSLS     r0,r8,#31
000168  d001              BEQ      |L14.366|
;;;1982         {
;;;1983           /* Set CAN error code to Error Warning */
;;;1984           errorcode |= HAL_CAN_ERROR_EWG;
00016a  f0440401          ORR      r4,r4,#1
                  |L14.366|
;;;1985   
;;;1986           /* No need for clear of Error Warning Flag as read-only */
;;;1987         }
;;;1988   
;;;1989         /* Check Error Passive Flag */
;;;1990         if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
00016e  05b0              LSLS     r0,r6,#22
000170  d504              BPL      |L14.380|
;;;1991             ((esrflags & CAN_ESR_EPVF) != 0U))
000172  ea5f7088          LSLS     r0,r8,#30
000176  d501              BPL      |L14.380|
;;;1992         {
;;;1993           /* Set CAN error code to Error Passive */
;;;1994           errorcode |= HAL_CAN_ERROR_EPV;
000178  f0440402          ORR      r4,r4,#2
                  |L14.380|
;;;1995   
;;;1996           /* No need for clear of Error Passive Flag as read-only */
;;;1997         }
;;;1998   
;;;1999         /* Check Bus-off Flag */
;;;2000         if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
00017c  0570              LSLS     r0,r6,#21
00017e  d504              BPL      |L14.394|
;;;2001             ((esrflags & CAN_ESR_BOFF) != 0U))
000180  ea5f7048          LSLS     r0,r8,#29
000184  d501              BPL      |L14.394|
;;;2002         {
;;;2003           /* Set CAN error code to Bus-Off */
;;;2004           errorcode |= HAL_CAN_ERROR_BOF;
000186  f0440404          ORR      r4,r4,#4
                  |L14.394|
;;;2005   
;;;2006           /* No need for clear of Error Bus-Off as read-only */
;;;2007         }
;;;2008   
;;;2009         /* Check Last Error Code Flag */
;;;2010         if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
00018a  0530              LSLS     r0,r6,#20
00018c  d529              BPL      |L14.482|
;;;2011             ((esrflags & CAN_ESR_LEC) != 0U))
00018e  f0180f70          TST      r8,#0x70
000192  d026              BEQ      |L14.482|
;;;2012         {
;;;2013           switch (esrflags & CAN_ESR_LEC)
000194  f0080070          AND      r0,r8,#0x70
000198  2840              CMP      r0,#0x40
00019a  d015              BEQ      |L14.456|
00019c  dc06              BGT      |L14.428|
00019e  2810              CMP      r0,#0x10
0001a0  d009              BEQ      |L14.438|
0001a2  2820              CMP      r0,#0x20
0001a4  d00a              BEQ      |L14.444|
0001a6  2830              CMP      r0,#0x30
0001a8  d116              BNE      |L14.472|
0001aa  e00a              B        |L14.450|
                  |L14.428|
0001ac  2850              CMP      r0,#0x50
0001ae  d00e              BEQ      |L14.462|
0001b0  2860              CMP      r0,#0x60
0001b2  d111              BNE      |L14.472|
0001b4  e00e              B        |L14.468|
                  |L14.438|
;;;2014           {
;;;2015             case (CAN_ESR_LEC_0):
;;;2016               /* Set CAN error code to Stuff error */
;;;2017               errorcode |= HAL_CAN_ERROR_STF;
0001b6  f0440408          ORR      r4,r4,#8
;;;2018               break;
0001ba  e00d              B        |L14.472|
                  |L14.444|
;;;2019             case (CAN_ESR_LEC_1):
;;;2020               /* Set CAN error code to Form error */
;;;2021               errorcode |= HAL_CAN_ERROR_FOR;
0001bc  f0440410          ORR      r4,r4,#0x10
;;;2022               break;
0001c0  e00a              B        |L14.472|
                  |L14.450|
;;;2023             case (CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
;;;2024               /* Set CAN error code to Acknowledgement error */
;;;2025               errorcode |= HAL_CAN_ERROR_ACK;
0001c2  f0440420          ORR      r4,r4,#0x20
;;;2026               break;
0001c6  e007              B        |L14.472|
                  |L14.456|
;;;2027             case (CAN_ESR_LEC_2):
;;;2028               /* Set CAN error code to Bit recessive error */
;;;2029               errorcode |= HAL_CAN_ERROR_BR;
0001c8  f0440440          ORR      r4,r4,#0x40
;;;2030               break;
0001cc  e004              B        |L14.472|
                  |L14.462|
;;;2031             case (CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
;;;2032               /* Set CAN error code to Bit Dominant error */
;;;2033               errorcode |= HAL_CAN_ERROR_BD;
0001ce  f0440480          ORR      r4,r4,#0x80
;;;2034               break;
0001d2  e001              B        |L14.472|
                  |L14.468|
;;;2035             case (CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
;;;2036               /* Set CAN error code to CRC error */
;;;2037               errorcode |= HAL_CAN_ERROR_CRC;
0001d4  f4447480          ORR      r4,r4,#0x100
                  |L14.472|
;;;2038               break;
;;;2039             default:
;;;2040               break;
;;;2041           }
;;;2042   
;;;2043           /* Clear Last error code Flag */
;;;2044           CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
0001d8  6828              LDR      r0,[r5,#0]
0001da  6981              LDR      r1,[r0,#0x18]
0001dc  f0210170          BIC      r1,r1,#0x70
0001e0  6181              STR      r1,[r0,#0x18]
                  |L14.482|
;;;2045         }
;;;2046       }
;;;2047   
;;;2048       /* Clear ERRI Flag */
;;;2049       __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
0001e2  6829              LDR      r1,[r5,#0]
0001e4  2004              MOVS     r0,#4
0001e6  6048              STR      r0,[r1,#4]
                  |L14.488|
;;;2050     }
;;;2051   
;;;2052     /* Call the Error call Back in case of Errors */
;;;2053     if (errorcode != HAL_CAN_ERROR_NONE)
0001e8  2c00              CMP      r4,#0
0001ea  d005              BEQ      |L14.504|
;;;2054     {
;;;2055       /* Update error code in handle */
;;;2056       hcan->ErrorCode |= errorcode;
0001ec  6a68              LDR      r0,[r5,#0x24]
0001ee  4320              ORRS     r0,r0,r4
0001f0  6268              STR      r0,[r5,#0x24]
;;;2057   
;;;2058       /* Call Error callback function */
;;;2059   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;2060       /* Call registered callback*/
;;;2061       hcan->ErrorCallback(hcan);
;;;2062   #else
;;;2063       /* Call weak (surcharged) callback */
;;;2064       HAL_CAN_ErrorCallback(hcan);
0001f2  4628              MOV      r0,r5
0001f4  f7fffffe          BL       HAL_CAN_ErrorCallback
                  |L14.504|
;;;2065   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;2066     }
;;;2067   }
0001f8  e8bd9ff0          POP      {r4-r12,pc}
;;;2068   
                          ENDP


                          AREA ||i.HAL_CAN_Init||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Init PROC
;;;273      */
;;;274    HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;275    {
000002  4604              MOV      r4,r0
;;;276      uint32_t tickstart;
;;;277    
;;;278      /* Check CAN handle */
;;;279      if (hcan == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L15.16|
;;;280      {
;;;281        return HAL_ERROR;
;;;282      }
;;;283    
;;;284      /* Check the parameters */
;;;285      assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;286      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TimeTriggeredMode));
;;;287      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoBusOff));
;;;288      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoWakeUp));
;;;289      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoRetransmission));
;;;290      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.ReceiveFifoLocked));
;;;291      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TransmitFifoPriority));
;;;292      assert_param(IS_CAN_MODE(hcan->Init.Mode));
;;;293      assert_param(IS_CAN_SJW(hcan->Init.SyncJumpWidth));
;;;294      assert_param(IS_CAN_BS1(hcan->Init.TimeSeg1));
;;;295      assert_param(IS_CAN_BS2(hcan->Init.TimeSeg2));
;;;296      assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
;;;297    
;;;298    #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;299      if (hcan->State == HAL_CAN_STATE_RESET)
;;;300      {
;;;301        /* Reset callbacks to legacy functions */
;;;302        hcan->RxFifo0MsgPendingCallback  =  HAL_CAN_RxFifo0MsgPendingCallback;  /* Legacy weak RxFifo0MsgPendingCallback  */
;;;303        hcan->RxFifo0FullCallback        =  HAL_CAN_RxFifo0FullCallback;        /* Legacy weak RxFifo0FullCallback        */
;;;304        hcan->RxFifo1MsgPendingCallback  =  HAL_CAN_RxFifo1MsgPendingCallback;  /* Legacy weak RxFifo1MsgPendingCallback  */
;;;305        hcan->RxFifo1FullCallback        =  HAL_CAN_RxFifo1FullCallback;        /* Legacy weak RxFifo1FullCallback        */
;;;306        hcan->TxMailbox0CompleteCallback =  HAL_CAN_TxMailbox0CompleteCallback; /* Legacy weak TxMailbox0CompleteCallback */
;;;307        hcan->TxMailbox1CompleteCallback =  HAL_CAN_TxMailbox1CompleteCallback; /* Legacy weak TxMailbox1CompleteCallback */
;;;308        hcan->TxMailbox2CompleteCallback =  HAL_CAN_TxMailbox2CompleteCallback; /* Legacy weak TxMailbox2CompleteCallback */
;;;309        hcan->TxMailbox0AbortCallback    =  HAL_CAN_TxMailbox0AbortCallback;    /* Legacy weak TxMailbox0AbortCallback    */
;;;310        hcan->TxMailbox1AbortCallback    =  HAL_CAN_TxMailbox1AbortCallback;    /* Legacy weak TxMailbox1AbortCallback    */
;;;311        hcan->TxMailbox2AbortCallback    =  HAL_CAN_TxMailbox2AbortCallback;    /* Legacy weak TxMailbox2AbortCallback    */
;;;312        hcan->SleepCallback              =  HAL_CAN_SleepCallback;              /* Legacy weak SleepCallback              */
;;;313        hcan->WakeUpFromRxMsgCallback    =  HAL_CAN_WakeUpFromRxMsgCallback;    /* Legacy weak WakeUpFromRxMsgCallback    */
;;;314        hcan->ErrorCallback              =  HAL_CAN_ErrorCallback;              /* Legacy weak ErrorCallback              */
;;;315    
;;;316        if (hcan->MspInitCallback == NULL)
;;;317        {
;;;318          hcan->MspInitCallback = HAL_CAN_MspInit; /* Legacy weak MspInit */
;;;319        }
;;;320    
;;;321        /* Init the low level hardware: CLOCK, NVIC */
;;;322        hcan->MspInitCallback(hcan);
;;;323      }
;;;324    
;;;325    #else
;;;326      if (hcan->State == HAL_CAN_STATE_RESET)
000008  f8940020          LDRB     r0,[r4,#0x20]
00000c  b110              CBZ      r0,|L15.20|
00000e  e004              B        |L15.26|
                  |L15.16|
000010  2001              MOVS     r0,#1                 ;281
;;;327      {
;;;328        /* Init the low level hardware: CLOCK, NVIC */
;;;329        HAL_CAN_MspInit(hcan);
;;;330      }
;;;331    #endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
;;;332    
;;;333      /* Exit from sleep mode */
;;;334      CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;335    
;;;336      /* Get tick */
;;;337      tickstart = HAL_GetTick();
;;;338    
;;;339      /* Check Sleep mode leave acknowledge */
;;;340      while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
;;;341      {
;;;342        if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;343        {
;;;344          /* Update error code */
;;;345          hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;346    
;;;347          /* Change CAN state */
;;;348          hcan->State = HAL_CAN_STATE_ERROR;
;;;349    
;;;350          return HAL_ERROR;
;;;351        }
;;;352      }
;;;353    
;;;354      /* Request initialisation */
;;;355      SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
;;;356    
;;;357      /* Get tick */
;;;358      tickstart = HAL_GetTick();
;;;359    
;;;360      /* Wait initialisation acknowledge */
;;;361      while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
;;;362      {
;;;363        if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;364        {
;;;365          /* Update error code */
;;;366          hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;367    
;;;368          /* Change CAN state */
;;;369          hcan->State = HAL_CAN_STATE_ERROR;
;;;370    
;;;371          return HAL_ERROR;
;;;372        }
;;;373      }
;;;374    
;;;375      /* Set the time triggered communication mode */
;;;376      if (hcan->Init.TimeTriggeredMode == ENABLE)
;;;377      {
;;;378        SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
;;;379      }
;;;380      else
;;;381      {
;;;382        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
;;;383      }
;;;384    
;;;385      /* Set the automatic bus-off management */
;;;386      if (hcan->Init.AutoBusOff == ENABLE)
;;;387      {
;;;388        SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
;;;389      }
;;;390      else
;;;391      {
;;;392        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
;;;393      }
;;;394    
;;;395      /* Set the automatic wake-up mode */
;;;396      if (hcan->Init.AutoWakeUp == ENABLE)
;;;397      {
;;;398        SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
;;;399      }
;;;400      else
;;;401      {
;;;402        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
;;;403      }
;;;404    
;;;405      /* Set the automatic retransmission */
;;;406      if (hcan->Init.AutoRetransmission == ENABLE)
;;;407      {
;;;408        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
;;;409      }
;;;410      else
;;;411      {
;;;412        SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
;;;413      }
;;;414    
;;;415      /* Set the receive FIFO locked mode */
;;;416      if (hcan->Init.ReceiveFifoLocked == ENABLE)
;;;417      {
;;;418        SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
;;;419      }
;;;420      else
;;;421      {
;;;422        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
;;;423      }
;;;424    
;;;425      /* Set the transmit FIFO priority */
;;;426      if (hcan->Init.TransmitFifoPriority == ENABLE)
;;;427      {
;;;428        SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
;;;429      }
;;;430      else
;;;431      {
;;;432        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
;;;433      }
;;;434    
;;;435      /* Set the bit timing register */
;;;436      WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
;;;437                                                hcan->Init.SyncJumpWidth  |
;;;438                                                hcan->Init.TimeSeg1       |
;;;439                                                hcan->Init.TimeSeg2       |
;;;440                                                (hcan->Init.Prescaler - 1U)));
;;;441    
;;;442      /* Initialize the error code */
;;;443      hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;444    
;;;445      /* Initialize the CAN state */
;;;446      hcan->State = HAL_CAN_STATE_READY;
;;;447    
;;;448      /* Return function status */
;;;449      return HAL_OK;
;;;450    }
000012  bd70              POP      {r4-r6,pc}
                  |L15.20|
000014  4620              MOV      r0,r4                 ;329
000016  f7fffffe          BL       HAL_CAN_MspInit
                  |L15.26|
00001a  6820              LDR      r0,[r4,#0]            ;334
00001c  6801              LDR      r1,[r0,#0]            ;334
00001e  f0210102          BIC      r1,r1,#2              ;334
000022  6001              STR      r1,[r0,#0]            ;334
000024  f7fffffe          BL       HAL_GetTick
000028  4605              MOV      r5,r0                 ;337
00002a  2605              MOVS     r6,#5                 ;348
00002c  e00c              B        |L15.72|
                  |L15.46|
00002e  f7fffffe          BL       HAL_GetTick
000032  1b40              SUBS     r0,r0,r5              ;342
000034  280a              CMP      r0,#0xa               ;342
000036  d907              BLS      |L15.72|
000038  6a60              LDR      r0,[r4,#0x24]         ;345
00003a  f4403000          ORR      r0,r0,#0x20000        ;345
00003e  6260              STR      r0,[r4,#0x24]         ;345
000040  f8846020          STRB     r6,[r4,#0x20]         ;348
000044  2001              MOVS     r0,#1                 ;350
000046  bd70              POP      {r4-r6,pc}
                  |L15.72|
000048  6820              LDR      r0,[r4,#0]            ;340
00004a  6840              LDR      r0,[r0,#4]            ;340
00004c  0780              LSLS     r0,r0,#30             ;340
00004e  d4ee              BMI      |L15.46|
000050  6820              LDR      r0,[r4,#0]            ;355
000052  6801              LDR      r1,[r0,#0]            ;355
000054  f0410101          ORR      r1,r1,#1              ;355
000058  6001              STR      r1,[r0,#0]            ;355
00005a  f7fffffe          BL       HAL_GetTick
00005e  4605              MOV      r5,r0                 ;358
000060  e00c              B        |L15.124|
                  |L15.98|
000062  f7fffffe          BL       HAL_GetTick
000066  1b40              SUBS     r0,r0,r5              ;363
000068  280a              CMP      r0,#0xa               ;363
00006a  d907              BLS      |L15.124|
00006c  6a60              LDR      r0,[r4,#0x24]         ;366
00006e  f4403000          ORR      r0,r0,#0x20000        ;366
000072  6260              STR      r0,[r4,#0x24]         ;366
000074  f8846020          STRB     r6,[r4,#0x20]         ;369
000078  2001              MOVS     r0,#1                 ;371
00007a  bd70              POP      {r4-r6,pc}
                  |L15.124|
00007c  6820              LDR      r0,[r4,#0]            ;361
00007e  6840              LDR      r0,[r0,#4]            ;361
000080  07c0              LSLS     r0,r0,#31             ;361
000082  d0ee              BEQ      |L15.98|
000084  7e20              LDRB     r0,[r4,#0x18]         ;376
000086  2801              CMP      r0,#1                 ;376
000088  d03f              BEQ      |L15.266|
00008a  6820              LDR      r0,[r4,#0]            ;382
00008c  6801              LDR      r1,[r0,#0]            ;382
00008e  f0210180          BIC      r1,r1,#0x80           ;382
000092  6001              STR      r1,[r0,#0]            ;382
                  |L15.148|
000094  7e60              LDRB     r0,[r4,#0x19]         ;386
000096  2801              CMP      r0,#1                 ;386
000098  d03d              BEQ      |L15.278|
00009a  6820              LDR      r0,[r4,#0]            ;392
00009c  6801              LDR      r1,[r0,#0]            ;392
00009e  f0210140          BIC      r1,r1,#0x40           ;392
0000a2  6001              STR      r1,[r0,#0]            ;392
                  |L15.164|
0000a4  7ea0              LDRB     r0,[r4,#0x1a]         ;396
0000a6  2801              CMP      r0,#1                 ;396
0000a8  d03b              BEQ      |L15.290|
0000aa  6820              LDR      r0,[r4,#0]            ;402
0000ac  6801              LDR      r1,[r0,#0]            ;402
0000ae  f0210120          BIC      r1,r1,#0x20           ;402
0000b2  6001              STR      r1,[r0,#0]            ;402
                  |L15.180|
0000b4  7ee0              LDRB     r0,[r4,#0x1b]         ;406
0000b6  2801              CMP      r0,#1                 ;406
0000b8  d039              BEQ      |L15.302|
0000ba  6820              LDR      r0,[r4,#0]            ;412
0000bc  6801              LDR      r1,[r0,#0]            ;412
0000be  f0410110          ORR      r1,r1,#0x10           ;412
0000c2  6001              STR      r1,[r0,#0]            ;412
                  |L15.196|
0000c4  7f20              LDRB     r0,[r4,#0x1c]         ;416
0000c6  2801              CMP      r0,#1                 ;416
0000c8  d037              BEQ      |L15.314|
0000ca  6820              LDR      r0,[r4,#0]            ;422
0000cc  6801              LDR      r1,[r0,#0]            ;422
0000ce  f0210108          BIC      r1,r1,#8              ;422
0000d2  6001              STR      r1,[r0,#0]            ;422
                  |L15.212|
0000d4  7f60              LDRB     r0,[r4,#0x1d]         ;426
0000d6  2801              CMP      r0,#1                 ;426
0000d8  d035              BEQ      |L15.326|
0000da  6820              LDR      r0,[r4,#0]            ;432
0000dc  6801              LDR      r1,[r0,#0]            ;432
0000de  f0210104          BIC      r1,r1,#4              ;432
0000e2  6001              STR      r1,[r0,#0]            ;432
                  |L15.228|
0000e4  e9d40102          LDRD     r0,r1,[r4,#8]         ;436
0000e8  4308              ORRS     r0,r0,r1              ;436
0000ea  e9d41204          LDRD     r1,r2,[r4,#0x10]      ;436
0000ee  4311              ORRS     r1,r1,r2              ;436
0000f0  4308              ORRS     r0,r0,r1              ;436
0000f2  6861              LDR      r1,[r4,#4]            ;436
0000f4  1e49              SUBS     r1,r1,#1              ;436
0000f6  4308              ORRS     r0,r0,r1              ;436
0000f8  6821              LDR      r1,[r4,#0]            ;436
0000fa  61c8              STR      r0,[r1,#0x1c]         ;436
0000fc  2000              MOVS     r0,#0                 ;443
0000fe  6260              STR      r0,[r4,#0x24]         ;443
000100  2001              MOVS     r0,#1                 ;446
000102  f8840020          STRB     r0,[r4,#0x20]         ;446
000106  2000              MOVS     r0,#0                 ;449
000108  bd70              POP      {r4-r6,pc}
                  |L15.266|
00010a  6820              LDR      r0,[r4,#0]            ;378
00010c  6801              LDR      r1,[r0,#0]            ;378
00010e  f0410180          ORR      r1,r1,#0x80           ;378
000112  6001              STR      r1,[r0,#0]            ;378
000114  e7be              B        |L15.148|
                  |L15.278|
000116  6820              LDR      r0,[r4,#0]            ;388
000118  6801              LDR      r1,[r0,#0]            ;388
00011a  f0410140          ORR      r1,r1,#0x40           ;388
00011e  6001              STR      r1,[r0,#0]            ;388
000120  e7c0              B        |L15.164|
                  |L15.290|
000122  6820              LDR      r0,[r4,#0]            ;398
000124  6801              LDR      r1,[r0,#0]            ;398
000126  f0410120          ORR      r1,r1,#0x20           ;398
00012a  6001              STR      r1,[r0,#0]            ;398
00012c  e7c2              B        |L15.180|
                  |L15.302|
00012e  6820              LDR      r0,[r4,#0]            ;408
000130  6801              LDR      r1,[r0,#0]            ;408
000132  f0210110          BIC      r1,r1,#0x10           ;408
000136  6001              STR      r1,[r0,#0]            ;408
000138  e7c4              B        |L15.196|
                  |L15.314|
00013a  6820              LDR      r0,[r4,#0]            ;418
00013c  6801              LDR      r1,[r0,#0]            ;418
00013e  f0410108          ORR      r1,r1,#8              ;418
000142  6001              STR      r1,[r0,#0]            ;418
000144  e7c6              B        |L15.212|
                  |L15.326|
000146  6820              LDR      r0,[r4,#0]            ;428
000148  6801              LDR      r1,[r0,#0]            ;428
00014a  f0410104          ORR      r1,r1,#4              ;428
00014e  6001              STR      r1,[r0,#0]            ;428
000150  e7c8              B        |L15.228|
;;;451    
                          ENDP


                          AREA ||i.HAL_CAN_IsSleepActive||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IsSleepActive PROC
;;;1190     */
;;;1191   uint32_t HAL_CAN_IsSleepActive(CAN_HandleTypeDef *hcan)
000000  4602              MOV      r2,r0
;;;1192   {
;;;1193     uint32_t status = 0U;
000002  2000              MOVS     r0,#0
;;;1194     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8921020          LDRB     r1,[r2,#0x20]
;;;1195   
;;;1196     if ((state == HAL_CAN_STATE_READY) ||
000008  2901              CMP      r1,#1
00000a  d001              BEQ      |L16.16|
;;;1197         (state == HAL_CAN_STATE_LISTENING))
00000c  2902              CMP      r1,#2
00000e  d104              BNE      |L16.26|
                  |L16.16|
;;;1198     {
;;;1199       /* Check Sleep mode */
;;;1200       if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
000010  6811              LDR      r1,[r2,#0]
000012  6849              LDR      r1,[r1,#4]
000014  0789              LSLS     r1,r1,#30
000016  d500              BPL      |L16.26|
;;;1201       {
;;;1202         status = 1U;
000018  2001              MOVS     r0,#1
                  |L16.26|
;;;1203       }
;;;1204     }
;;;1205   
;;;1206     /* Return function status */
;;;1207     return status;
;;;1208   }
00001a  4770              BX       lr
;;;1209   
                          ENDP


                          AREA ||i.HAL_CAN_IsTxMessagePending||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IsTxMessagePending PROC
;;;1421     */
;;;1422   uint32_t HAL_CAN_IsTxMessagePending(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)
000000  4603              MOV      r3,r0
;;;1423   {
;;;1424     uint32_t status = 0U;
000002  2000              MOVS     r0,#0
;;;1425     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8932020          LDRB     r2,[r3,#0x20]
;;;1426   
;;;1427     /* Check function parameters */
;;;1428     assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));
;;;1429   
;;;1430     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L17.16|
;;;1431         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d105              BNE      |L17.28|
                  |L17.16|
;;;1432     {
;;;1433       /* Check pending transmission request on the selected Tx Mailboxes */
;;;1434       if ((hcan->Instance->TSR & (TxMailboxes << CAN_TSR_TME0_Pos)) != (TxMailboxes << CAN_TSR_TME0_Pos))
000010  681a              LDR      r2,[r3,#0]
000012  0689              LSLS     r1,r1,#26
000014  6892              LDR      r2,[r2,#8]
000016  4391              BICS     r1,r1,r2
000018  d000              BEQ      |L17.28|
;;;1435       {
;;;1436         status = 1U;
00001a  2001              MOVS     r0,#1
                  |L17.28|
;;;1437       }
;;;1438     }
;;;1439   
;;;1440     /* Return status */
;;;1441     return status;
;;;1442   }
00001c  4770              BX       lr
;;;1443   
                          ENDP


                          AREA ||i.HAL_CAN_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspDeInit PROC
;;;521      */
;;;522    __weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;523    {
;;;524      /* Prevent unused argument(s) compilation warning */
;;;525      UNUSED(hcan);
;;;526    
;;;527      /* NOTE : This function Should not be modified, when the callback is needed,
;;;528                the HAL_CAN_MspDeInit could be implemented in the user file
;;;529       */
;;;530    }
;;;531    
                          ENDP


                          AREA ||i.HAL_CAN_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspInit PROC
;;;505      */
;;;506    __weak void HAL_CAN_MspInit(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;507    {
;;;508      /* Prevent unused argument(s) compilation warning */
;;;509      UNUSED(hcan);
;;;510    
;;;511      /* NOTE : This function Should not be modified, when the callback is needed,
;;;512                the HAL_CAN_MspInit could be implemented in the user file
;;;513       */
;;;514    }
;;;515    
                          ENDP


                          AREA ||i.HAL_CAN_RequestSleep||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RequestSleep PROC
;;;1110     */
;;;1111   HAL_StatusTypeDef HAL_CAN_RequestSleep(CAN_HandleTypeDef *hcan)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;1112   {
;;;1113     HAL_CAN_StateTypeDef state = hcan->State;
;;;1114   
;;;1115     if ((state == HAL_CAN_STATE_READY) ||
000004  2901              CMP      r1,#1
000006  d007              BEQ      |L20.24|
;;;1116         (state == HAL_CAN_STATE_LISTENING))
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L20.24|
;;;1117     {
;;;1118       /* Request Sleep mode */
;;;1119       SET_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;1120   
;;;1121       /* Return function status */
;;;1122       return HAL_OK;
;;;1123     }
;;;1124     else
;;;1125     {
;;;1126       /* Update error code */
;;;1127       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  f4412180          ORR      r1,r1,#0x40000
000012  6241              STR      r1,[r0,#0x24]
;;;1128   
;;;1129       /* Return function status */
;;;1130       return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;1131     }
;;;1132   }
000016  4770              BX       lr
                  |L20.24|
000018  6800              LDR      r0,[r0,#0]            ;1119
00001a  6801              LDR      r1,[r0,#0]            ;1119
00001c  f0410102          ORR      r1,r1,#2              ;1119
000020  6001              STR      r1,[r0,#0]            ;1119
000022  2000              MOVS     r0,#0                 ;1122
000024  4770              BX       lr
;;;1133   
                          ENDP


                          AREA ||i.HAL_CAN_ResetError||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ResetError PROC
;;;2392     */
;;;2393   HAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef *hcan)
000000  2100              MOVS     r1,#0
;;;2394   {
;;;2395     HAL_StatusTypeDef status = HAL_OK;
;;;2396     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8902020          LDRB     r2,[r0,#0x20]
;;;2397   
;;;2398     if ((state == HAL_CAN_STATE_READY) ||
000006  2a01              CMP      r2,#1
000008  d008              BEQ      |L21.28|
;;;2399         (state == HAL_CAN_STATE_LISTENING))
00000a  2a02              CMP      r2,#2
00000c  d006              BEQ      |L21.28|
;;;2400     {
;;;2401       /* Reset CAN error code */
;;;2402       hcan->ErrorCode = 0U;
;;;2403     }
;;;2404     else
;;;2405     {
;;;2406       /* Update error code */
;;;2407       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
00000e  6a41              LDR      r1,[r0,#0x24]
000010  f4412180          ORR      r1,r1,#0x40000
000014  6241              STR      r1,[r0,#0x24]
;;;2408   
;;;2409       status = HAL_ERROR;
000016  2101              MOVS     r1,#1
                  |L21.24|
;;;2410     }
;;;2411   
;;;2412     /* Return the status */
;;;2413     return status;
000018  4608              MOV      r0,r1
;;;2414   }
00001a  4770              BX       lr
                  |L21.28|
00001c  2200              MOVS     r2,#0                 ;2402
00001e  6242              STR      r2,[r0,#0x24]         ;2402
000020  e7fa              B        |L21.24|
;;;2415   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo0FullCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo0FullCallback PROC
;;;2224     */
;;;2225   __weak void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2226   {
;;;2227     /* Prevent unused argument(s) compilation warning */
;;;2228     UNUSED(hcan);
;;;2229   
;;;2230     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2231               the HAL_CAN_RxFifo0FullCallback could be implemented in the user
;;;2232               file
;;;2233      */
;;;2234   }
;;;2235   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo0MsgPendingCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo0MsgPendingCallback PROC
;;;2207     */
;;;2208   __weak void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2209   {
;;;2210     /* Prevent unused argument(s) compilation warning */
;;;2211     UNUSED(hcan);
;;;2212   
;;;2213     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2214               the HAL_CAN_RxFifo0MsgPendingCallback could be implemented in the
;;;2215               user file
;;;2216      */
;;;2217   }
;;;2218   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo1FullCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo1FullCallback PROC
;;;2258     */
;;;2259   __weak void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2260   {
;;;2261     /* Prevent unused argument(s) compilation warning */
;;;2262     UNUSED(hcan);
;;;2263   
;;;2264     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2265               the HAL_CAN_RxFifo1FullCallback could be implemented in the user
;;;2266               file
;;;2267      */
;;;2268   }
;;;2269   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo1MsgPendingCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo1MsgPendingCallback PROC
;;;2241     */
;;;2242   __weak void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2243   {
;;;2244     /* Prevent unused argument(s) compilation warning */
;;;2245     UNUSED(hcan);
;;;2246   
;;;2247     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2248               the HAL_CAN_RxFifo1MsgPendingCallback could be implemented in the
;;;2249               user file
;;;2250      */
;;;2251   }
;;;2252   
                          ENDP


                          AREA ||i.HAL_CAN_SleepCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_SleepCallback PROC
;;;2275     */
;;;2276   __weak void HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2277   {
;;;2278     /* Prevent unused argument(s) compilation warning */
;;;2279     UNUSED(hcan);
;;;2280   
;;;2281     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2282               the HAL_CAN_SleepCallback could be implemented in the user file
;;;2283      */
;;;2284   }
;;;2285   
                          ENDP


                          AREA ||i.HAL_CAN_Start||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Start PROC
;;;1003     */
;;;1004   HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;1005   {
000002  4604              MOV      r4,r0
;;;1006     uint32_t tickstart;
;;;1007   
;;;1008     if (hcan->State == HAL_CAN_STATE_READY)
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2801              CMP      r0,#1
00000a  d005              BEQ      |L27.24|
;;;1009     {
;;;1010       /* Change CAN peripheral state */
;;;1011       hcan->State = HAL_CAN_STATE_LISTENING;
;;;1012   
;;;1013       /* Request leave initialisation */
;;;1014       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
;;;1015   
;;;1016       /* Get tick */
;;;1017       tickstart = HAL_GetTick();
;;;1018   
;;;1019       /* Wait the acknowledge */
;;;1020       while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
;;;1021       {
;;;1022         /* Check for the Timeout */
;;;1023         if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;1024         {
;;;1025           /* Update error code */
;;;1026           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;1027   
;;;1028           /* Change CAN state */
;;;1029           hcan->State = HAL_CAN_STATE_ERROR;
;;;1030   
;;;1031           return HAL_ERROR;
;;;1032         }
;;;1033       }
;;;1034   
;;;1035       /* Reset the CAN ErrorCode */
;;;1036       hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;1037   
;;;1038       /* Return function status */
;;;1039       return HAL_OK;
;;;1040     }
;;;1041     else
;;;1042     {
;;;1043       /* Update error code */
;;;1044       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  f4402000          ORR      r0,r0,#0x80000
000012  6260              STR      r0,[r4,#0x24]
;;;1045   
;;;1046       return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;1047     }
;;;1048   }
000016  bd70              POP      {r4-r6,pc}
                  |L27.24|
000018  2002              MOVS     r0,#2                 ;1011
00001a  f8840020          STRB     r0,[r4,#0x20]         ;1011
00001e  6820              LDR      r0,[r4,#0]            ;1014
000020  6801              LDR      r1,[r0,#0]            ;1014
000022  f0210101          BIC      r1,r1,#1              ;1014
000026  6001              STR      r1,[r0,#0]            ;1014
000028  f7fffffe          BL       HAL_GetTick
00002c  4605              MOV      r5,r0                 ;1017
00002e  e00d              B        |L27.76|
                  |L27.48|
000030  f7fffffe          BL       HAL_GetTick
000034  1b40              SUBS     r0,r0,r5              ;1023
000036  280a              CMP      r0,#0xa               ;1023
000038  d908              BLS      |L27.76|
00003a  6a60              LDR      r0,[r4,#0x24]         ;1026
00003c  f4403000          ORR      r0,r0,#0x20000        ;1026
000040  6260              STR      r0,[r4,#0x24]         ;1026
000042  2005              MOVS     r0,#5                 ;1029
000044  f8840020          STRB     r0,[r4,#0x20]         ;1029
000048  2001              MOVS     r0,#1                 ;1031
00004a  bd70              POP      {r4-r6,pc}
                  |L27.76|
00004c  6820              LDR      r0,[r4,#0]            ;1020
00004e  6840              LDR      r0,[r0,#4]            ;1020
000050  07c0              LSLS     r0,r0,#31             ;1020
000052  d1ed              BNE      |L27.48|
000054  6260              STR      r0,[r4,#0x24]         ;1036
000056  bd70              POP      {r4-r6,pc}
;;;1049   
                          ENDP


                          AREA ||i.HAL_CAN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Stop PROC
;;;1055     */
;;;1056   HAL_StatusTypeDef HAL_CAN_Stop(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;1057   {
000002  4604              MOV      r4,r0
;;;1058     uint32_t tickstart;
;;;1059   
;;;1060     if (hcan->State == HAL_CAN_STATE_LISTENING)
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L28.24|
;;;1061     {
;;;1062       /* Request initialisation */
;;;1063       SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
;;;1064   
;;;1065       /* Get tick */
;;;1066       tickstart = HAL_GetTick();
;;;1067   
;;;1068       /* Wait the acknowledge */
;;;1069       while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
;;;1070       {
;;;1071         /* Check for the Timeout */
;;;1072         if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;1073         {
;;;1074           /* Update error code */
;;;1075           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;1076   
;;;1077           /* Change CAN state */
;;;1078           hcan->State = HAL_CAN_STATE_ERROR;
;;;1079   
;;;1080           return HAL_ERROR;
;;;1081         }
;;;1082       }
;;;1083   
;;;1084       /* Exit from sleep mode */
;;;1085       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;1086   
;;;1087       /* Change CAN peripheral state */
;;;1088       hcan->State = HAL_CAN_STATE_READY;
;;;1089   
;;;1090       /* Return function status */
;;;1091       return HAL_OK;
;;;1092     }
;;;1093     else
;;;1094     {
;;;1095       /* Update error code */
;;;1096       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_STARTED;
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  f4401080          ORR      r0,r0,#0x100000
000012  6260              STR      r0,[r4,#0x24]
;;;1097   
;;;1098       return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;1099     }
;;;1100   }
000016  bd70              POP      {r4-r6,pc}
                  |L28.24|
000018  6820              LDR      r0,[r4,#0]            ;1063
00001a  6801              LDR      r1,[r0,#0]            ;1063
00001c  f0410101          ORR      r1,r1,#1              ;1063
000020  6001              STR      r1,[r0,#0]            ;1063
000022  f7fffffe          BL       HAL_GetTick
000026  4605              MOV      r5,r0                 ;1066
000028  e00d              B        |L28.70|
                  |L28.42|
00002a  f7fffffe          BL       HAL_GetTick
00002e  1b40              SUBS     r0,r0,r5              ;1072
000030  280a              CMP      r0,#0xa               ;1072
000032  d908              BLS      |L28.70|
000034  6a60              LDR      r0,[r4,#0x24]         ;1075
000036  f4403000          ORR      r0,r0,#0x20000        ;1075
00003a  6260              STR      r0,[r4,#0x24]         ;1075
00003c  2005              MOVS     r0,#5                 ;1078
00003e  f8840020          STRB     r0,[r4,#0x20]         ;1078
000042  2001              MOVS     r0,#1                 ;1080
000044  bd70              POP      {r4-r6,pc}
                  |L28.70|
000046  6820              LDR      r0,[r4,#0]            ;1069
000048  6840              LDR      r0,[r0,#4]            ;1069
00004a  07c0              LSLS     r0,r0,#31             ;1069
00004c  d0ed              BEQ      |L28.42|
00004e  6820              LDR      r0,[r4,#0]            ;1085
000050  6801              LDR      r1,[r0,#0]            ;1085
000052  f0210102          BIC      r1,r1,#2              ;1085
000056  6001              STR      r1,[r0,#0]            ;1085
000058  2001              MOVS     r0,#1                 ;1088
00005a  f8840020          STRB     r0,[r4,#0x20]         ;1088
00005e  2000              MOVS     r0,#0                 ;1091
000060  bd70              POP      {r4-r6,pc}
;;;1101   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox0AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox0AbortCallback PROC
;;;2156     */
;;;2157   __weak void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2158   {
;;;2159     /* Prevent unused argument(s) compilation warning */
;;;2160     UNUSED(hcan);
;;;2161   
;;;2162     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2163               the HAL_CAN_TxMailbox0AbortCallback could be implemented in the
;;;2164               user file
;;;2165      */
;;;2166   }
;;;2167   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox0CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox0CompleteCallback PROC
;;;2105     */
;;;2106   __weak void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2107   {
;;;2108     /* Prevent unused argument(s) compilation warning */
;;;2109     UNUSED(hcan);
;;;2110   
;;;2111     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2112               the HAL_CAN_TxMailbox0CompleteCallback could be implemented in the
;;;2113               user file
;;;2114      */
;;;2115   }
;;;2116   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox1AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox1AbortCallback PROC
;;;2173     */
;;;2174   __weak void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2175   {
;;;2176     /* Prevent unused argument(s) compilation warning */
;;;2177     UNUSED(hcan);
;;;2178   
;;;2179     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2180               the HAL_CAN_TxMailbox1AbortCallback could be implemented in the
;;;2181               user file
;;;2182      */
;;;2183   }
;;;2184   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox1CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox1CompleteCallback PROC
;;;2122     */
;;;2123   __weak void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2124   {
;;;2125     /* Prevent unused argument(s) compilation warning */
;;;2126     UNUSED(hcan);
;;;2127   
;;;2128     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2129               the HAL_CAN_TxMailbox1CompleteCallback could be implemented in the
;;;2130               user file
;;;2131      */
;;;2132   }
;;;2133   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox2AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox2AbortCallback PROC
;;;2190     */
;;;2191   __weak void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2192   {
;;;2193     /* Prevent unused argument(s) compilation warning */
;;;2194     UNUSED(hcan);
;;;2195   
;;;2196     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2197               the HAL_CAN_TxMailbox2AbortCallback could be implemented in the
;;;2198               user file
;;;2199      */
;;;2200   }
;;;2201   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox2CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox2CompleteCallback PROC
;;;2139     */
;;;2140   __weak void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2141   {
;;;2142     /* Prevent unused argument(s) compilation warning */
;;;2143     UNUSED(hcan);
;;;2144   
;;;2145     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2146               the HAL_CAN_TxMailbox2CompleteCallback could be implemented in the
;;;2147               user file
;;;2148      */
;;;2149   }
;;;2150   
                          ENDP


                          AREA ||i.HAL_CAN_WakeUp||, CODE, READONLY, ALIGN=2

                  HAL_CAN_WakeUp PROC
;;;1141     */
;;;1142   HAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef *hcan)
000000  b508              PUSH     {r3,lr}
;;;1143   {
;;;1144     __IO uint32_t count = 0;
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
;;;1145     uint32_t timeout = 1000000U;
000006  4912              LDR      r1,|L35.80|
;;;1146     HAL_CAN_StateTypeDef state = hcan->State;
000008  f8902020          LDRB     r2,[r0,#0x20]
;;;1147   
;;;1148     if ((state == HAL_CAN_STATE_READY) ||
00000c  2a01              CMP      r2,#1
00000e  d007              BEQ      |L35.32|
;;;1149         (state == HAL_CAN_STATE_LISTENING))
000010  2a02              CMP      r2,#2
000012  d005              BEQ      |L35.32|
;;;1150     {
;;;1151       /* Wake up request */
;;;1152       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;1153   
;;;1154       /* Wait sleep mode is exited */
;;;1155       do
;;;1156       {
;;;1157         /* Increment counter */
;;;1158         count++;
;;;1159   
;;;1160         /* Check if timeout is reached */
;;;1161         if (count > timeout)
;;;1162         {
;;;1163           /* Update error code */
;;;1164           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;1165   
;;;1166           return HAL_ERROR;
;;;1167         }
;;;1168       }
;;;1169       while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U);
;;;1170   
;;;1171       /* Return function status */
;;;1172       return HAL_OK;
;;;1173     }
;;;1174     else
;;;1175     {
;;;1176       /* Update error code */
;;;1177       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
000014  6a41              LDR      r1,[r0,#0x24]
000016  f4412180          ORR      r1,r1,#0x40000
00001a  6241              STR      r1,[r0,#0x24]
;;;1178   
;;;1179       return HAL_ERROR;
00001c  2001              MOVS     r0,#1
;;;1180     }
;;;1181   }
00001e  bd08              POP      {r3,pc}
                  |L35.32|
000020  6802              LDR      r2,[r0,#0]            ;1152
000022  6813              LDR      r3,[r2,#0]            ;1152
000024  f0230302          BIC      r3,r3,#2              ;1152
000028  6013              STR      r3,[r2,#0]            ;1152
                  |L35.42|
00002a  9a00              LDR      r2,[sp,#0]            ;1158
00002c  1c52              ADDS     r2,r2,#1              ;1158
00002e  9200              STR      r2,[sp,#0]            ;1158
000030  9a00              LDR      r2,[sp,#0]            ;1161
000032  428a              CMP      r2,r1                 ;1161
000034  d905              BLS      |L35.66|
000036  6a41              LDR      r1,[r0,#0x24]         ;1164
000038  f4413100          ORR      r1,r1,#0x20000        ;1164
00003c  6241              STR      r1,[r0,#0x24]         ;1164
00003e  2001              MOVS     r0,#1                 ;1166
000040  bd08              POP      {r3,pc}
                  |L35.66|
000042  6802              LDR      r2,[r0,#0]            ;1169
000044  6852              LDR      r2,[r2,#4]            ;1169
000046  0792              LSLS     r2,r2,#30             ;1169
000048  d4ef              BMI      |L35.42|
00004a  2000              MOVS     r0,#0                 ;1172
00004c  bd08              POP      {r3,pc}
;;;1182   
                          ENDP

00004e  0000              DCW      0x0000
                  |L35.80|
                          DCD      0x000f4240

                          AREA ||i.HAL_CAN_WakeUpFromRxMsgCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_WakeUpFromRxMsgCallback PROC
;;;2291     */
;;;2292   __weak void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2293   {
;;;2294     /* Prevent unused argument(s) compilation warning */
;;;2295     UNUSED(hcan);
;;;2296   
;;;2297     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2298               the HAL_CAN_WakeUpFromRxMsgCallback could be implemented in the
;;;2299               user file
;;;2300      */
;;;2301   }
;;;2302   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_can_c_fe6cb454____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_can_c_fe6cb454____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_can_c_fe6cb454____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_can_c_fe6cb454____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_can_c_fe6cb454____RRX|
#line 694
|__asm___19_stm32l4xx_hal_can_c_fe6cb454____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
