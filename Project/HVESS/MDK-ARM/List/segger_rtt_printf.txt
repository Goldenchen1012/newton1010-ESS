; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\segger_rtt_printf.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\segger_rtt_printf.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\RTT\SEGGER_RTT_printf.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_printf||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_printf PROC
;;;503    */
;;;504    int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
000000  b40f              PUSH     {r0-r3}
000002  b508              PUSH     {r3,lr}
;;;505      int r;
;;;506      va_list ParamList;
;;;507    
;;;508      va_start(ParamList, sFormat);
000004  a904              ADD      r1,sp,#0x10
000006  9100              STR      r1,[sp,#0]
;;;509      r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
000008  466a              MOV      r2,sp
00000a  9903              LDR      r1,[sp,#0xc]
00000c  f7fffffe          BL       SEGGER_RTT_vprintf
;;;510      va_end(ParamList);
;;;511      return r;
;;;512    }
000010  b001              ADD      sp,sp,#4
000012  f85dfb14          LDR      pc,[sp],#0x14
;;;513    /*************************** End of file ****************************/
                          ENDP


                          AREA ||i.SEGGER_RTT_vprintf||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_vprintf PROC
;;;320    */
;;;321    int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4682              MOV      r10,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b098              SUB      sp,sp,#0x60
00000c  460c              MOV      r4,r1
00000e  4616              MOV      r6,r2
;;;322      char c;
;;;323      SEGGER_RTT_PRINTF_DESC BufferDesc;
;;;324      int v;
;;;325      unsigned NumDigits;
;;;326      unsigned FormatFlags;
;;;327      unsigned FieldWidth;
;;;328      char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];
;;;329    	float fv;
;;;330      BufferDesc.pBuffer        = acBuffer;
000010  a803              ADD      r0,sp,#0xc
000012  9013              STR      r0,[sp,#0x4c]
;;;331      BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
000014  2040              MOVS     r0,#0x40
000016  9014              STR      r0,[sp,#0x50]
;;;332      BufferDesc.Cnt            = 0u;
000018  f04f0900          MOV      r9,#0
00001c  f8cd9054          STR      r9,[sp,#0x54]
;;;333      BufferDesc.RTTBufferIndex = BufferIndex;
000020  f8cda05c          STR      r10,[sp,#0x5c]
;;;334      BufferDesc.ReturnValue    = 0;
000024  f8cd9058          STR      r9,[sp,#0x58]
                  |L2.40|
;;;335    
;;;336      do {
;;;337        c = *sFormat;
000028  f8141b01          LDRB     r1,[r4],#1
;;;338        sFormat++;
;;;339        if (c == 0u) {
00002c  b139              CBZ      r1,|L2.62|
;;;340          break;
;;;341        }
;;;342        if (c == '%') {
00002e  2925              CMP      r1,#0x25
000030  d019              BEQ      |L2.102|
;;;343          //
;;;344          // Filter out flags
;;;345          //
;;;346          FormatFlags = 0u;
;;;347          v = 1;
;;;348          do {
;;;349            c = *sFormat;
;;;350            switch (c) {
;;;351            case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
;;;352            case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
;;;353            case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
;;;354            case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
;;;355            default:  v = 0; break;
;;;356            }
;;;357          } while (v);
;;;358          //
;;;359          // filter out field with
;;;360          //
;;;361          FieldWidth = 0u;
;;;362          do {
;;;363            c = *sFormat;
;;;364            if ((c < '0') || (c > '9')) {
;;;365              break;
;;;366            }
;;;367            sFormat++;
;;;368            FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
;;;369          } while (1);
;;;370    
;;;371          //
;;;372          // Filter out precision (number of digits to display)
;;;373          //
;;;374          NumDigits = 0u;
;;;375          c = *sFormat;
;;;376          if (c == '.') {
;;;377            sFormat++;
;;;378            do {
;;;379              c = *sFormat;
;;;380              if ((c < '0') || (c > '9')) {
;;;381                break;
;;;382              }
;;;383              sFormat++;
;;;384              NumDigits = NumDigits * 10u + ((unsigned)c - '0');
;;;385            } while (1);
;;;386          }
;;;387          //
;;;388          // Filter out length modifier
;;;389          //
;;;390          c = *sFormat;
;;;391          do {
;;;392            if ((c == 'l') || (c == 'h')) {
;;;393              sFormat++;
;;;394              c = *sFormat;
;;;395            } else {
;;;396              break;
;;;397            }
;;;398          } while (1);
;;;399          //
;;;400          // Handle specifiers
;;;401          //
;;;402          switch (c) {
;;;403          case 'c': {
;;;404            char c0;
;;;405            v = va_arg(*pParamList, int);
;;;406            c0 = (char)v;
;;;407            _StoreChar(&BufferDesc, c0);
;;;408            break;
;;;409          }
;;;410          case 'd':
;;;411            v = va_arg(*pParamList, int);
;;;412            _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
;;;413            break;
;;;414          case 'u':
;;;415            v = va_arg(*pParamList, int);
;;;416            _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
;;;417            break;
;;;418          case 'x':
;;;419          case 'X':
;;;420            v = va_arg(*pParamList, int);
;;;421            _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
;;;422            break;
;;;423          case 's':
;;;424            {
;;;425              const char * s = va_arg(*pParamList, const char *);
;;;426              do {
;;;427                c = *s;
;;;428                s++;
;;;429                if (c == '\0') {
;;;430                  break;
;;;431                }
;;;432               _StoreChar(&BufferDesc, c);
;;;433              } while (BufferDesc.ReturnValue >= 0);
;;;434            }
;;;435            break;
;;;436          case 'p':
;;;437            v = va_arg(*pParamList, int);
;;;438            _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
;;;439            break;
;;;440          case '%':
;;;441            _StoreChar(&BufferDesc, '%');
;;;442            break;
;;;443    			case 'f':
;;;444    			  fv = (float)va_arg(*pParamList,double);
;;;445    				v = (int)fv;
;;;446    				_PrintInt(&BufferDesc, v,10u,NumDigits, FieldWidth, FormatFlags);
;;;447    				_StoreChar(&BufferDesc, '.' );
;;;448    				v = abs((int)(fv*1000));
;;;449    				v = v % 1000;
;;;450    				_PrintInt(&BufferDesc,v,10u,3,FieldWidth, FormatFlags);
;;;451            break;
;;;452          default:
;;;453            break;
;;;454          }
;;;455          sFormat++;
;;;456        } else {
;;;457          _StoreChar(&BufferDesc, c);
000032  a813              ADD      r0,sp,#0x4c
000034  f7fffffe          BL       _StoreChar
                  |L2.56|
;;;458        }
;;;459      } while (BufferDesc.ReturnValue >= 0);
000038  9816              LDR      r0,[sp,#0x58]
00003a  2800              CMP      r0,#0
00003c  daf4              BGE      |L2.40|
                  |L2.62|
;;;460    
;;;461      if (BufferDesc.ReturnValue > 0) {
00003e  9816              LDR      r0,[sp,#0x58]
000040  2800              CMP      r0,#0
000042  dd0a              BLE      |L2.90|
;;;462        //
;;;463        // Write remaining data, if any
;;;464        //
;;;465        if (BufferDesc.Cnt != 0u) {
000044  9815              LDR      r0,[sp,#0x54]
000046  b120              CBZ      r0,|L2.82|
;;;466          SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
000048  a903              ADD      r1,sp,#0xc
00004a  4650              MOV      r0,r10
00004c  9a15              LDR      r2,[sp,#0x54]
00004e  f7fffffe          BL       SEGGER_RTT_Write
                  |L2.82|
;;;467        }
;;;468        BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
000052  e9dd1015          LDRD     r1,r0,[sp,#0x54]
000056  4408              ADD      r0,r0,r1
000058  9016              STR      r0,[sp,#0x58]
                  |L2.90|
;;;469      }
;;;470      return BufferDesc.ReturnValue;
00005a  9816              LDR      r0,[sp,#0x58]
;;;471    }
00005c  b018              ADD      sp,sp,#0x60
00005e  ecbd8b02          VPOP     {d8}
000062  e8bd87f0          POP      {r4-r10,pc}
                  |L2.102|
000066  2500              MOVS     r5,#0                 ;346
000068  2101              MOVS     r1,#1                 ;347
                  |L2.106|
00006a  7820              LDRB     r0,[r4,#0]            ;349
00006c  2823              CMP      r0,#0x23              ;350
00006e  d020              BEQ      |L2.178|
000070  282b              CMP      r0,#0x2b              ;350
000072  d01a              BEQ      |L2.170|
000074  282d              CMP      r0,#0x2d              ;350
000076  d010              BEQ      |L2.154|
000078  2830              CMP      r0,#0x30              ;350
00007a  d012              BEQ      |L2.162|
00007c  2100              MOVS     r1,#0                 ;355
                  |L2.126|
00007e  2900              CMP      r1,#0                 ;357
000080  d1f3              BNE      |L2.106|
000082  2700              MOVS     r7,#0                 ;361
                  |L2.132|
000084  7821              LDRB     r1,[r4,#0]            ;363
000086  f1a10030          SUB      r0,r1,#0x30           ;364
00008a  280a              CMP      r0,#0xa               ;364
00008c  d315              BCC      |L2.186|
00008e  f04f0800          MOV      r8,#0                 ;374
000092  7820              LDRB     r0,[r4,#0]            ;375
000094  282e              CMP      r0,#0x2e              ;376
000096  d017              BEQ      |L2.200|
000098  e024              B        |L2.228|
                  |L2.154|
00009a  f0450501          ORR      r5,r5,#1              ;351
00009e  1c64              ADDS     r4,r4,#1              ;351
0000a0  e7ed              B        |L2.126|
                  |L2.162|
0000a2  f0450502          ORR      r5,r5,#2              ;352
0000a6  1c64              ADDS     r4,r4,#1              ;352
0000a8  e7e9              B        |L2.126|
                  |L2.170|
0000aa  f0450504          ORR      r5,r5,#4              ;353
0000ae  1c64              ADDS     r4,r4,#1              ;353
0000b0  e7e5              B        |L2.126|
                  |L2.178|
0000b2  f0450508          ORR      r5,r5,#8              ;354
0000b6  1c64              ADDS     r4,r4,#1              ;354
0000b8  e7e1              B        |L2.126|
                  |L2.186|
0000ba  1c64              ADDS     r4,r4,#1              ;367
0000bc  eb070087          ADD      r0,r7,r7,LSL #2       ;368
0000c0  eb010740          ADD      r7,r1,r0,LSL #1       ;368
0000c4  3f30              SUBS     r7,r7,#0x30           ;368
0000c6  e7dd              B        |L2.132|
                  |L2.200|
0000c8  1c64              ADDS     r4,r4,#1              ;377
                  |L2.202|
0000ca  7821              LDRB     r1,[r4,#0]            ;379
0000cc  f1a10030          SUB      r0,r1,#0x30           ;380
0000d0  280a              CMP      r0,#0xa               ;380
0000d2  d207              BCS      |L2.228|
0000d4  1c64              ADDS     r4,r4,#1              ;383
0000d6  eb080088          ADD      r0,r8,r8,LSL #2       ;384
0000da  eb010840          ADD      r8,r1,r0,LSL #1       ;384
0000de  f1a80830          SUB      r8,r8,#0x30           ;384
0000e2  e7f2              B        |L2.202|
                  |L2.228|
0000e4  296c              CMP      r1,#0x6c              ;392
0000e6  d00d              BEQ      |L2.260|
0000e8  2968              CMP      r1,#0x68              ;392
0000ea  d00b              BEQ      |L2.260|
0000ec  2966              CMP      r1,#0x66              ;402
0000ee  d062              BEQ      |L2.438|
0000f0  dc0b              BGT      |L2.266|
0000f2  2925              CMP      r1,#0x25              ;402
0000f4  d05a              BEQ      |L2.428|
0000f6  2958              CMP      r1,#0x58              ;402
0000f8  d031              BEQ      |L2.350|
0000fa  2963              CMP      r1,#0x63              ;402
0000fc  d00e              BEQ      |L2.284|
0000fe  2964              CMP      r1,#0x64              ;402
000100  d114              BNE      |L2.300|
000102  e014              B        |L2.302|
                  |L2.260|
000104  1c64              ADDS     r4,r4,#1              ;393
000106  7821              LDRB     r1,[r4,#0]            ;394
000108  e7ec              B        |L2.228|
                  |L2.266|
00010a  2970              CMP      r1,#0x70              ;402
00010c  d041              BEQ      |L2.402|
00010e  2973              CMP      r1,#0x73              ;402
000110  d031              BEQ      |L2.374|
000112  2975              CMP      r1,#0x75              ;402
000114  d017              BEQ      |L2.326|
000116  2978              CMP      r1,#0x78              ;402
000118  d108              BNE      |L2.300|
00011a  e020              B        |L2.350|
                  |L2.284|
00011c  6830              LDR      r0,[r6,#0]            ;405
00011e  1d01              ADDS     r1,r0,#4              ;405
000120  6031              STR      r1,[r6,#0]            ;405
000122  7800              LDRB     r0,[r0,#0]            ;405
000124  b2c1              UXTB     r1,r0                 ;406
000126  a813              ADD      r0,sp,#0x4c           ;407
000128  f7fffffe          BL       _StoreChar
                  |L2.300|
00012c  e07b              B        |L2.550|
                  |L2.302|
00012e  6830              LDR      r0,[r6,#0]            ;411
000130  1d01              ADDS     r1,r0,#4              ;411
000132  6031              STR      r1,[r6,#0]            ;411
000134  6801              LDR      r1,[r0,#0]            ;411
000136  e9cd7500          STRD     r7,r5,[sp,#0]         ;412
00013a  4643              MOV      r3,r8                 ;412
00013c  220a              MOVS     r2,#0xa               ;412
00013e  a813              ADD      r0,sp,#0x4c           ;412
000140  f7fffffe          BL       _PrintInt
000144  e06f              B        |L2.550|
                  |L2.326|
000146  6830              LDR      r0,[r6,#0]            ;415
000148  1d01              ADDS     r1,r0,#4              ;415
00014a  6031              STR      r1,[r6,#0]            ;415
00014c  6801              LDR      r1,[r0,#0]            ;415
00014e  e9cd7500          STRD     r7,r5,[sp,#0]         ;416
000152  4643              MOV      r3,r8                 ;416
000154  220a              MOVS     r2,#0xa               ;416
000156  a813              ADD      r0,sp,#0x4c           ;416
000158  f7fffffe          BL       _PrintUnsigned
00015c  e063              B        |L2.550|
                  |L2.350|
00015e  6830              LDR      r0,[r6,#0]            ;420
000160  1d01              ADDS     r1,r0,#4              ;420
000162  6031              STR      r1,[r6,#0]            ;420
000164  6801              LDR      r1,[r0,#0]            ;420
000166  e9cd7500          STRD     r7,r5,[sp,#0]         ;421
00016a  4643              MOV      r3,r8                 ;421
00016c  2210              MOVS     r2,#0x10              ;421
00016e  a813              ADD      r0,sp,#0x4c           ;421
000170  f7fffffe          BL       _PrintUnsigned
000174  e057              B        |L2.550|
                  |L2.374|
000176  6830              LDR      r0,[r6,#0]            ;425
000178  1d01              ADDS     r1,r0,#4              ;425
00017a  6031              STR      r1,[r6,#0]            ;425
00017c  6805              LDR      r5,[r0,#0]            ;425
                  |L2.382|
00017e  f8151b01          LDRB     r1,[r5],#1            ;427
000182  b3e9              CBZ      r1,|L2.512|
000184  a813              ADD      r0,sp,#0x4c           ;432
000186  f7fffffe          BL       _StoreChar
00018a  9816              LDR      r0,[sp,#0x58]         ;433
00018c  2800              CMP      r0,#0                 ;433
00018e  daf6              BGE      |L2.382|
000190  e049              B        |L2.550|
                  |L2.402|
000192  6830              LDR      r0,[r6,#0]            ;437
000194  1d01              ADDS     r1,r0,#4              ;437
000196  6031              STR      r1,[r6,#0]            ;437
000198  6801              LDR      r1,[r0,#0]            ;437
00019a  2008              MOVS     r0,#8                 ;438
00019c  e9cd0900          STRD     r0,r9,[sp,#0]         ;438
0001a0  4603              MOV      r3,r0                 ;438
0001a2  2210              MOVS     r2,#0x10              ;438
0001a4  a813              ADD      r0,sp,#0x4c           ;438
0001a6  f7fffffe          BL       _PrintUnsigned
0001aa  e03c              B        |L2.550|
                  |L2.428|
0001ac  2125              MOVS     r1,#0x25              ;441
0001ae  a813              ADD      r0,sp,#0x4c           ;441
0001b0  f7fffffe          BL       _StoreChar
0001b4  e037              B        |L2.550|
                  |L2.438|
0001b6  6830              LDR      r0,[r6,#0]            ;444
0001b8  1dc0              ADDS     r0,r0,#7              ;444
0001ba  f0200007          BIC      r0,r0,#7              ;444
0001be  f1000108          ADD      r1,r0,#8              ;444
0001c2  6031              STR      r1,[r6,#0]            ;444
0001c4  ed900b00          VLDR     d0,[r0,#0]            ;444
0001c8  ec510b10          VMOV     r0,r1,d0              ;444
0001cc  f7fffffe          BL       __aeabi_d2f
0001d0  ee080a10          VMOV     s16,r0                ;444
0001d4  eebd0ac8          VCVT.S32.F32 s0,s16                ;445
0001d8  ee101a10          VMOV     r1,s0                 ;445
0001dc  e9cd7500          STRD     r7,r5,[sp,#0]         ;446
0001e0  4643              MOV      r3,r8                 ;446
0001e2  220a              MOVS     r2,#0xa               ;446
0001e4  a813              ADD      r0,sp,#0x4c           ;446
0001e6  f7fffffe          BL       _PrintInt
0001ea  212e              MOVS     r1,#0x2e              ;447
0001ec  a813              ADD      r0,sp,#0x4c           ;447
0001ee  f7fffffe          BL       _StoreChar
0001f2  ed9f0a0e          VLDR     s0,|L2.556|
0001f6  ee280a00          VMUL.F32 s0,s16,s0             ;448
0001fa  eebd0ac0          VCVT.S32.F32 s0,s0                 ;448
0001fe  e000              B        |L2.514|
                  |L2.512|
000200  e011              B        |L2.550|
                  |L2.514|
000202  ee100a10          VMOV     r0,s0                 ;448
000206  2800              CMP      r0,#0                 ;448
000208  da00              BGE      |L2.524|
00020a  4240              RSBS     r0,r0,#0              ;448
                  |L2.524|
00020c  f44f717a          MOV      r1,#0x3e8             ;449
000210  fb90f2f1          SDIV     r2,r0,r1              ;449
000214  fb010112          MLS      r1,r1,r2,r0           ;449
000218  e9cd7500          STRD     r7,r5,[sp,#0]         ;450
00021c  2303              MOVS     r3,#3                 ;450
00021e  220a              MOVS     r2,#0xa               ;450
000220  a813              ADD      r0,sp,#0x4c           ;450
000222  f7fffffe          BL       _PrintInt
                  |L2.550|
000226  1c64              ADDS     r4,r4,#1              ;455
000228  e706              B        |L2.56|
;;;472    
                          ENDP

00022a  0000              DCW      0x0000
                  |L2.556|
00022c  447a0000          DCFS     0x447a0000 ; 1000

                          AREA ||i._PrintInt||, CODE, READONLY, ALIGN=1

                  _PrintInt PROC
;;;225    */
;;;226    static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4606              MOV      r6,r0
000006  e9dd480c          LDRD     r4,r8,[sp,#0x30]
00000a  460f              MOV      r7,r1
00000c  4692              MOV      r10,r2
00000e  4699              MOV      r9,r3
;;;227      unsigned Width;
;;;228      int Number;
;;;229    
;;;230      Number = (v < 0) ? -v : v;
000010  f1c70b00          RSB      r11,r7,#0
000014  2f00              CMP      r7,#0
000016  da01              BGE      |L3.28|
000018  4658              MOV      r0,r11
00001a  e000              B        |L3.30|
                  |L3.28|
00001c  4638              MOV      r0,r7
                  |L3.30|
;;;231    
;;;232      //
;;;233      // Get actual field width
;;;234      //
;;;235      Width = 1u;
00001e  2501              MOVS     r5,#1
;;;236      while (Number >= (int)Base) {
000020  e002              B        |L3.40|
                  |L3.34|
;;;237        Number = (Number / (int)Base);
000022  fb90f0fa          SDIV     r0,r0,r10
;;;238        Width++;
000026  1c6d              ADDS     r5,r5,#1
                  |L3.40|
000028  4550              CMP      r0,r10                ;236
00002a  dafa              BGE      |L3.34|
;;;239      }
;;;240      if (NumDigits > Width) {
00002c  45a9              CMP      r9,r5
00002e  d900              BLS      |L3.50|
;;;241        Width = NumDigits;
000030  464d              MOV      r5,r9
                  |L3.50|
;;;242      }
;;;243      if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
000032  b12c              CBZ      r4,|L3.64|
000034  2f00              CMP      r7,#0
000036  db02              BLT      |L3.62|
000038  ea5f7048          LSLS     r0,r8,#29
00003c  d500              BPL      |L3.64|
                  |L3.62|
;;;244        FieldWidth--;
00003e  1e64              SUBS     r4,r4,#1
                  |L3.64|
;;;245      }
;;;246    
;;;247      //
;;;248      // Print leading spaces if necessary
;;;249      //
;;;250      if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
000040  ea5f7088          LSLS     r0,r8,#30
000044  d502              BPL      |L3.76|
000046  f1b90f00          CMP      r9,#0
00004a  d00f              BEQ      |L3.108|
                  |L3.76|
00004c  ea5f70c8          LSLS     r0,r8,#31
000050  d10c              BNE      |L3.108|
;;;251        if (FieldWidth != 0u) {
000052  b944              CBNZ     r4,|L3.102|
000054  e00a              B        |L3.108|
                  |L3.86|
;;;252          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
;;;253            FieldWidth--;
000056  1e64              SUBS     r4,r4,#1
;;;254            _StoreChar(pBufferDesc, ' ');
000058  2120              MOVS     r1,#0x20
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       _StoreChar
;;;255            if (pBufferDesc->ReturnValue < 0) {
000060  68f0              LDR      r0,[r6,#0xc]
000062  2800              CMP      r0,#0
000064  db02              BLT      |L3.108|
                  |L3.102|
000066  b10c              CBZ      r4,|L3.108|
000068  42a5              CMP      r5,r4                 ;252
00006a  d3f4              BCC      |L3.86|
                  |L3.108|
;;;256              break;
;;;257            }
;;;258          }
;;;259        }
;;;260      }
;;;261      //
;;;262      // Print sign if necessary
;;;263      //
;;;264      if (pBufferDesc->ReturnValue >= 0) {
00006c  68f0              LDR      r0,[r6,#0xc]
00006e  2800              CMP      r0,#0
000070  db30              BLT      |L3.212|
;;;265        if (v < 0) {
000072  2f00              CMP      r7,#0
000074  da05              BGE      |L3.130|
;;;266          v = -v;
000076  465f              MOV      r7,r11
;;;267          _StoreChar(pBufferDesc, '-');
000078  212d              MOVS     r1,#0x2d
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       _StoreChar
000080  e006              B        |L3.144|
                  |L3.130|
;;;268        } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
000082  ea5f7048          LSLS     r0,r8,#29
000086  d503              BPL      |L3.144|
;;;269          _StoreChar(pBufferDesc, '+');
000088  212b              MOVS     r1,#0x2b
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       _StoreChar
                  |L3.144|
;;;270        } else {
;;;271    
;;;272        }
;;;273        if (pBufferDesc->ReturnValue >= 0) {
000090  68f0              LDR      r0,[r6,#0xc]
000092  2800              CMP      r0,#0
000094  db1e              BLT      |L3.212|
;;;274          //
;;;275          // Print leading zeros if necessary
;;;276          //
;;;277          if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
000096  f0080003          AND      r0,r8,#3
00009a  2802              CMP      r0,#2
00009c  d10f              BNE      |L3.190|
00009e  f1b90f00          CMP      r9,#0
0000a2  d10c              BNE      |L3.190|
;;;278            if (FieldWidth != 0u) {
0000a4  b944              CBNZ     r4,|L3.184|
0000a6  e00a              B        |L3.190|
                  |L3.168|
;;;279              while ((FieldWidth != 0u) && (Width < FieldWidth)) {
;;;280                FieldWidth--;
0000a8  1e64              SUBS     r4,r4,#1
;;;281                _StoreChar(pBufferDesc, '0');
0000aa  2130              MOVS     r1,#0x30
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       _StoreChar
;;;282                if (pBufferDesc->ReturnValue < 0) {
0000b2  68f0              LDR      r0,[r6,#0xc]
0000b4  2800              CMP      r0,#0
0000b6  db02              BLT      |L3.190|
                  |L3.184|
0000b8  b10c              CBZ      r4,|L3.190|
0000ba  42a5              CMP      r5,r4                 ;279
0000bc  d3f4              BCC      |L3.168|
                  |L3.190|
;;;283                  break;
;;;284                }
;;;285              }
;;;286            }
;;;287          }
;;;288          if (pBufferDesc->ReturnValue >= 0) {
0000be  68f0              LDR      r0,[r6,#0xc]
0000c0  2800              CMP      r0,#0
0000c2  db07              BLT      |L3.212|
;;;289            //
;;;290            // Print number without sign
;;;291            //
;;;292            _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
0000c4  e9cd4800          STRD     r4,r8,[sp,#0]
0000c8  464b              MOV      r3,r9
0000ca  4652              MOV      r2,r10
0000cc  4639              MOV      r1,r7
0000ce  4630              MOV      r0,r6
0000d0  f7fffffe          BL       _PrintUnsigned
                  |L3.212|
;;;293          }
;;;294        }
;;;295      }
;;;296    }
0000d4  e8bd9ffc          POP      {r2-r12,pc}
;;;297    
                          ENDP


                          AREA ||i._PrintUnsigned||, CODE, READONLY, ALIGN=2

                  _PrintUnsigned PROC
;;;135    */
;;;136    static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4682              MOV      r10,r0
000006  e9dd4b0a          LDRD     r4,r11,[sp,#0x28]
00000a  4688              MOV      r8,r1
00000c  4617              MOV      r7,r2
00000e  4699              MOV      r9,r3
;;;137      static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
;;;138      unsigned Div;
;;;139      unsigned Digit;
;;;140      unsigned Number;
;;;141      unsigned Width;
;;;142      char c;
;;;143    
;;;144      Number = v;
000010  4640              MOV      r0,r8
;;;145      Digit = 1u;
000012  2501              MOVS     r5,#1
;;;146      //
;;;147      // Get actual field width
;;;148      //
;;;149      Width = 1u;
000014  2601              MOVS     r6,#1
000016  e002              B        |L4.30|
                  |L4.24|
;;;150      while (Number >= Base) {
;;;151        Number = (Number / Base);
000018  fbb0f0f7          UDIV     r0,r0,r7
;;;152        Width++;
00001c  1c76              ADDS     r6,r6,#1
                  |L4.30|
00001e  42b8              CMP      r0,r7                 ;150
000020  d2fa              BCS      |L4.24|
;;;153      }
;;;154      if (NumDigits > Width) {
000022  45b1              CMP      r9,r6
000024  d900              BLS      |L4.40|
;;;155        Width = NumDigits;
000026  464e              MOV      r6,r9
                  |L4.40|
;;;156      }
;;;157      //
;;;158      // Print leading chars if necessary
;;;159      //
;;;160      if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
000028  ea5f70cb          LSLS     r0,r11,#31
00002c  d118              BNE      |L4.96|
;;;161        if (FieldWidth != 0u) {
00002e  b1bc              CBZ      r4,|L4.96|
;;;162          if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
000030  ea5f708b          LSLS     r0,r11,#30
000034  d502              BPL      |L4.60|
000036  f1b90f00          CMP      r9,#0
00003a  d002              BEQ      |L4.66|
                  |L4.60|
;;;163            c = '0';
;;;164          } else {
;;;165            c = ' ';
00003c  2020              MOVS     r0,#0x20
00003e  9000              STR      r0,[sp,#0]
000040  e00b              B        |L4.90|
                  |L4.66|
000042  2030              MOVS     r0,#0x30              ;163
000044  9000              STR      r0,[sp,#0]            ;163
000046  e008              B        |L4.90|
                  |L4.72|
;;;166          }
;;;167          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
;;;168            FieldWidth--;
000048  1e64              SUBS     r4,r4,#1
;;;169            _StoreChar(pBufferDesc, c);
00004a  4650              MOV      r0,r10
00004c  9900              LDR      r1,[sp,#0]
00004e  f7fffffe          BL       _StoreChar
;;;170            if (pBufferDesc->ReturnValue < 0) {
000052  f8da000c          LDR      r0,[r10,#0xc]
000056  2800              CMP      r0,#0
000058  db02              BLT      |L4.96|
                  |L4.90|
00005a  b10c              CBZ      r4,|L4.96|
00005c  42a6              CMP      r6,r4                 ;167
00005e  d3f3              BCC      |L4.72|
                  |L4.96|
;;;171              break;
;;;172            }
;;;173          }
;;;174        }
;;;175      }
;;;176      if (pBufferDesc->ReturnValue >= 0) {
000060  f8da000c          LDR      r0,[r10,#0xc]
000064  2800              CMP      r0,#0
000066  da0c              BGE      |L4.130|
                  |L4.104|
;;;177        //
;;;178        // Compute Digit.
;;;179        // Loop until Digit has the value of the highest digit required.
;;;180        // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
;;;181        //
;;;182        while (1) {
;;;183          if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
;;;184            NumDigits--;
;;;185          } else {
;;;186            Div = v / Digit;
;;;187            if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
;;;188              break;
;;;189            }
;;;190          }
;;;191          Digit *= Base;
;;;192        }
;;;193        //
;;;194        // Output digits
;;;195        //
;;;196        do {
;;;197          Div = v / Digit;
;;;198          v -= Div * Digit;
;;;199          _StoreChar(pBufferDesc, _aV2C[Div]);
;;;200          if (pBufferDesc->ReturnValue < 0) {
;;;201            break;
;;;202          }
;;;203          Digit /= Base;
;;;204        } while (Digit);
;;;205        //
;;;206        // Print trailing spaces if necessary
;;;207        //
;;;208        if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
;;;209          if (FieldWidth != 0u) {
;;;210            while ((FieldWidth != 0u) && (Width < FieldWidth)) {
;;;211              FieldWidth--;
;;;212              _StoreChar(pBufferDesc, ' ');
;;;213              if (pBufferDesc->ReturnValue < 0) {
;;;214                break;
;;;215              }
;;;216            }
;;;217          }
;;;218        }
;;;219      }
;;;220    }
000068  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.108|
00006c  f1a90901          SUB      r9,r9,#1              ;184
000070  e006              B        |L4.128|
                  |L4.114|
000072  fbb8f0f5          UDIV     r0,r8,r5              ;186
000076  42b8              CMP      r0,r7                 ;187
000078  d202              BCS      |L4.128|
00007a  f8df9058          LDR      r9,|L4.212|
00007e  e004              B        |L4.138|
                  |L4.128|
000080  437d              MULS     r5,r7,r5              ;191
                  |L4.130|
000082  f1b90f01          CMP      r9,#1                 ;183
000086  d9f4              BLS      |L4.114|
000088  e7f0              B        |L4.108|
                  |L4.138|
00008a  fbb8f0f5          UDIV     r0,r8,r5              ;197
00008e  fb008815          MLS      r8,r0,r5,r8           ;198
000092  f8191000          LDRB     r1,[r9,r0]            ;199
000096  4650              MOV      r0,r10                ;199
000098  f7fffffe          BL       _StoreChar
00009c  f8da000c          LDR      r0,[r10,#0xc]         ;200
0000a0  2800              CMP      r0,#0                 ;200
0000a2  db03              BLT      |L4.172|
0000a4  fbb5f5f7          UDIV     r5,r5,r7              ;203
0000a8  2d00              CMP      r5,#0                 ;204
0000aa  d1ee              BNE      |L4.138|
                  |L4.172|
0000ac  ea5f70cb          LSLS     r0,r11,#31            ;208
0000b0  d0da              BEQ      |L4.104|
0000b2  b94c              CBNZ     r4,|L4.200|
0000b4  e7d8              B        |L4.104|
                  |L4.182|
0000b6  1e64              SUBS     r4,r4,#1              ;211
0000b8  2120              MOVS     r1,#0x20              ;212
0000ba  4650              MOV      r0,r10                ;212
0000bc  f7fffffe          BL       _StoreChar
0000c0  f8da000c          LDR      r0,[r10,#0xc]         ;213
0000c4  2800              CMP      r0,#0                 ;213
0000c6  dbcf              BLT      |L4.104|
                  |L4.200|
0000c8  2c00              CMP      r4,#0                 ;210
0000ca  d0cd              BEQ      |L4.104|
0000cc  42a6              CMP      r6,r4                 ;210
0000ce  d3f2              BCC      |L4.182|
0000d0  e7ca              B        |L4.104|
;;;221    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L4.212|
                          DCD      ||.constdata||

                          AREA ||i._StoreChar||, CODE, READONLY, ALIGN=1

                  _StoreChar PROC
;;;110    */
;;;111    static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;112      unsigned Cnt;
;;;113    
;;;114      Cnt = p->Cnt;
000004  68a0              LDR      r0,[r4,#8]
;;;115      if ((Cnt + 1u) <= p->BufferSize) {
000006  6863              LDR      r3,[r4,#4]
000008  1c42              ADDS     r2,r0,#1
00000a  4293              CMP      r3,r2
00000c  d305              BCC      |L5.26|
;;;116        *(p->pBuffer + Cnt) = c;
00000e  6823              LDR      r3,[r4,#0]
000010  5419              STRB     r1,[r3,r0]
;;;117        p->Cnt = Cnt + 1u;
000012  60a2              STR      r2,[r4,#8]
;;;118        p->ReturnValue++;
000014  68e0              LDR      r0,[r4,#0xc]
000016  1c40              ADDS     r0,r0,#1
000018  60e0              STR      r0,[r4,#0xc]
                  |L5.26|
;;;119      }
;;;120      //
;;;121      // Write part of string, when the buffer is full
;;;122      //
;;;123      if (p->Cnt == p->BufferSize) {
00001a  e9d40201          LDRD     r0,r2,[r4,#4]
00001e  4282              CMP      r2,r0
000020  d109              BNE      |L5.54|
;;;124        if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
000022  6821              LDR      r1,[r4,#0]
000024  6920              LDR      r0,[r4,#0x10]
000026  f7fffffe          BL       SEGGER_RTT_Write
00002a  68a1              LDR      r1,[r4,#8]
00002c  4288              CMP      r0,r1
00002e  d003              BEQ      |L5.56|
;;;125          p->ReturnValue = -1;
000030  f04f30ff          MOV      r0,#0xffffffff
000034  60e0              STR      r0,[r4,#0xc]
                  |L5.54|
;;;126        } else {
;;;127          p->Cnt = 0u;
;;;128        }
;;;129      }
;;;130    }
000036  bd10              POP      {r4,pc}
                  |L5.56|
000038  2000              MOVS     r0,#0                 ;127
00003a  60a0              STR      r0,[r4,#8]            ;127
00003c  bd10              POP      {r4,pc}
;;;131    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _aV2C
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
