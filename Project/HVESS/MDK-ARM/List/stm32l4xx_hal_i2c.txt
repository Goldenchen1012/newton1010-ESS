; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_i2c.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_i2c.c]
                          THUMB

                          AREA ||i.HAL_I2C_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AbortCpltCallback PROC
;;;4547     */
;;;4548   __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4549   {
;;;4550     /* Prevent unused argument(s) compilation warning */
;;;4551     UNUSED(hi2c);
;;;4552   
;;;4553     /* NOTE : This function should not be modified, when the callback is needed,
;;;4554               the HAL_I2C_AbortCpltCallback could be implemented in the user file
;;;4555      */
;;;4556   }
;;;4557   
                          ENDP


                          AREA ||i.HAL_I2C_AddrCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AddrCallback PROC
;;;4465     */
;;;4466   __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
000000  4770              BX       lr
;;;4467   {
;;;4468     /* Prevent unused argument(s) compilation warning */
;;;4469     UNUSED(hi2c);
;;;4470     UNUSED(TransferDirection);
;;;4471     UNUSED(AddrMatchCode);
;;;4472   
;;;4473     /* NOTE : This function should not be modified, when the callback is needed,
;;;4474               the HAL_I2C_AddrCallback() could be implemented in the user file
;;;4475      */
;;;4476   }
;;;4477   
                          ENDP


                          AREA ||i.HAL_I2C_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DeInit PROC
;;;584      */
;;;585    HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;586    {
000002  4604              MOV      r4,r0
;;;587      /* Check the I2C handle allocation */
;;;588      if (hi2c == NULL)
000004  2c00              CMP      r4,#0
000006  d012              BEQ      |L3.46|
;;;589      {
;;;590        return HAL_ERROR;
;;;591      }
;;;592    
;;;593      /* Check the parameters */
;;;594      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;595    
;;;596      hi2c->State = HAL_I2C_STATE_BUSY;
000008  2024              MOVS     r0,#0x24
00000a  f8840041          STRB     r0,[r4,#0x41]
;;;597    
;;;598      /* Disable the I2C Peripheral Clock */
;;;599      __HAL_I2C_DISABLE(hi2c);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0210101          BIC      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;600    
;;;601    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;602      if (hi2c->MspDeInitCallback == NULL)
;;;603      {
;;;604        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
;;;605      }
;;;606    
;;;607      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;608      hi2c->MspDeInitCallback(hi2c);
;;;609    #else
;;;610      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;611      HAL_I2C_MspDeInit(hi2c);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_I2C_MspDeInit
;;;612    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;613    
;;;614      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  3430              ADDS     r4,r4,#0x30
000022  6160              STR      r0,[r4,#0x14]
;;;615      hi2c->State = HAL_I2C_STATE_RESET;
000024  7460              STRB     r0,[r4,#0x11]
;;;616      hi2c->PreviousState = I2C_STATE_NONE;
000026  6020              STR      r0,[r4,#0]
;;;617      hi2c->Mode = HAL_I2C_MODE_NONE;
000028  74a0              STRB     r0,[r4,#0x12]
;;;618    
;;;619      /* Release Lock */
;;;620      __HAL_UNLOCK(hi2c);
00002a  7420              STRB     r0,[r4,#0x10]
;;;621    
;;;622      return HAL_OK;
;;;623    }
00002c  bd10              POP      {r4,pc}
                  |L3.46|
00002e  2001              MOVS     r0,#1                 ;590
000030  bd10              POP      {r4,pc}
;;;624    
                          ENDP


                          AREA ||i.HAL_I2C_DisableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DisableListen_IT PROC
;;;4237     */
;;;4238   HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;4239   {
;;;4240     /* Declaration of tmp to prevent undefined behavior of volatile usage */
;;;4241     uint32_t tmp;
;;;4242   
;;;4243     /* Disable Address listen mode only if a transfer is not ongoing */
;;;4244     if (hi2c->State == HAL_I2C_STATE_LISTEN)
000002  f8901041          LDRB     r1,[r0,#0x41]
000006  2928              CMP      r1,#0x28
000008  d001              BEQ      |L4.14|
;;;4245     {
;;;4246       tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
;;;4247       hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
;;;4248       hi2c->State = HAL_I2C_STATE_READY;
;;;4249       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4250       hi2c->XferISR = NULL;
;;;4251   
;;;4252       /* Disable the Address Match interrupt */
;;;4253       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;4254   
;;;4255       return HAL_OK;
;;;4256     }
;;;4257     else
;;;4258     {
;;;4259       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;4260     }
;;;4261   }
00000c  bd10              POP      {r4,pc}
                  |L4.14|
00000e  3030              ADDS     r0,r0,#0x30           ;4246
000010  7c41              LDRB     r1,[r0,#0x11]         ;4246
000012  f0010103          AND      r1,r1,#3              ;4246
000016  7c82              LDRB     r2,[r0,#0x12]         ;4247
000018  430a              ORRS     r2,r2,r1              ;4247
00001a  6002              STR      r2,[r0,#0]            ;4247
00001c  2120              MOVS     r1,#0x20              ;4248
00001e  7441              STRB     r1,[r0,#0x11]         ;4248
000020  2100              MOVS     r1,#0                 ;4249
000022  7481              STRB     r1,[r0,#0x12]         ;4249
000024  6041              STR      r1,[r0,#4]            ;4250
000026  3830              SUBS     r0,r0,#0x30           ;4250
000028  f44f4100          MOV      r1,#0x8000            ;4253
00002c  f7fffffe          BL       I2C_Disable_IRQ
000030  2000              MOVS     r0,#0                 ;4255
000032  bd10              POP      {r4,pc}
;;;4262   
                          ENDP


                          AREA ||i.HAL_I2C_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ER_IRQHandler PROC
;;;4351     */
;;;4352   void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  b430              PUSH     {r4,r5}
;;;4353   {
;;;4354     uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
000002  6802              LDR      r2,[r0,#0]
000004  6993              LDR      r3,[r2,#0x18]
;;;4355     uint32_t itsources = READ_REG(hi2c->Instance->CR1);
000006  6811              LDR      r1,[r2,#0]
;;;4356     uint32_t tmperror;
;;;4357   
;;;4358     /* I2C Bus error interrupt occurred ------------------------------------*/
;;;4359     if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
000008  43db              MVNS     r3,r3
00000a  05dc              LSLS     r4,r3,#23
00000c  d409              BMI      |L5.34|
00000e  43cc              MVNS     r4,r1
000010  0624              LSLS     r4,r4,#24
000012  d406              BMI      |L5.34|
;;;4360     {
;;;4361       hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
000014  6c44              LDR      r4,[r0,#0x44]
000016  f0440401          ORR      r4,r4,#1
00001a  6444              STR      r4,[r0,#0x44]
;;;4362   
;;;4363       /* Clear BERR flag */
;;;4364       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
00001c  f44f7480          MOV      r4,#0x100
000020  61d4              STR      r4,[r2,#0x1c]
                  |L5.34|
;;;4365     }
;;;4366   
;;;4367     /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
;;;4368     if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
000022  055a              LSLS     r2,r3,#21
000024  d40a              BMI      |L5.60|
000026  43ca              MVNS     r2,r1
000028  0612              LSLS     r2,r2,#24
00002a  d407              BMI      |L5.60|
;;;4369     {
;;;4370       hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
00002c  6c42              LDR      r2,[r0,#0x44]
00002e  f0420208          ORR      r2,r2,#8
000032  6442              STR      r2,[r0,#0x44]
;;;4371   
;;;4372       /* Clear OVR flag */
;;;4373       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
000034  6804              LDR      r4,[r0,#0]
000036  f44f6280          MOV      r2,#0x400
00003a  61e2              STR      r2,[r4,#0x1c]
                  |L5.60|
;;;4374     }
;;;4375   
;;;4376     /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
;;;4377     if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
00003c  059a              LSLS     r2,r3,#22
00003e  d40a              BMI      |L5.86|
000040  43c9              MVNS     r1,r1
000042  0609              LSLS     r1,r1,#24
000044  d407              BMI      |L5.86|
;;;4378     {
;;;4379       hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
000046  6c41              LDR      r1,[r0,#0x44]
000048  f0410102          ORR      r1,r1,#2
00004c  6441              STR      r1,[r0,#0x44]
;;;4380   
;;;4381       /* Clear ARLO flag */
;;;4382       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
00004e  6802              LDR      r2,[r0,#0]
000050  f44f7100          MOV      r1,#0x200
000054  61d1              STR      r1,[r2,#0x1c]
                  |L5.86|
;;;4383     }
;;;4384   
;;;4385     /* Store current volatile hi2c->ErrorCode, misra rule */
;;;4386     tmperror = hi2c->ErrorCode;
000056  6c41              LDR      r1,[r0,#0x44]
;;;4387   
;;;4388     /* Call the Error Callback in case of Error detected */
;;;4389     if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
000058  f0110f0b          TST      r1,#0xb
00005c  d002              BEQ      |L5.100|
;;;4390     {
;;;4391       I2C_ITError(hi2c, tmperror);
00005e  bc30              POP      {r4,r5}
000060  f7ffbffe          B.W      I2C_ITError
                  |L5.100|
;;;4392     }
;;;4393   }
000064  bc30              POP      {r4,r5}
000066  4770              BX       lr
;;;4394   
                          ENDP


                          AREA ||i.HAL_I2C_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EV_IRQHandler PROC
;;;4332     */
;;;4333   void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  6802              LDR      r2,[r0,#0]
;;;4334   {
;;;4335     /* Get current IT Flags and IT sources value */
;;;4336     uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
000002  6991              LDR      r1,[r2,#0x18]
;;;4337     uint32_t itsources = READ_REG(hi2c->Instance->CR1);
000004  6812              LDR      r2,[r2,#0]
;;;4338   
;;;4339     /* I2C events treatment -------------------------------------*/
;;;4340     if (hi2c->XferISR != NULL)
000006  6b43              LDR      r3,[r0,#0x34]
000008  2b00              CMP      r3,#0
00000a  d000              BEQ      |L6.14|
;;;4341     {
;;;4342       hi2c->XferISR(hi2c, itflags, itsources);
00000c  4718              BX       r3
                  |L6.14|
;;;4343     }
;;;4344   }
00000e  4770              BX       lr
;;;4345   
                          ENDP


                          AREA ||i.HAL_I2C_EnableListen_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_EnableListen_IT PROC
;;;4213     */
;;;4214   HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;4215   {
;;;4216     if (hi2c->State == HAL_I2C_STATE_READY)
000002  f8901041          LDRB     r1,[r0,#0x41]
000006  2920              CMP      r1,#0x20
000008  d001              BEQ      |L7.14|
;;;4217     {
;;;4218       hi2c->State = HAL_I2C_STATE_LISTEN;
;;;4219       hi2c->XferISR = I2C_Slave_ISR_IT;
;;;4220   
;;;4221       /* Enable the Address Match interrupt */
;;;4222       I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;4223   
;;;4224       return HAL_OK;
;;;4225     }
;;;4226     else
;;;4227     {
;;;4228       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;4229     }
;;;4230   }
00000c  bd10              POP      {r4,pc}
                  |L7.14|
00000e  2128              MOVS     r1,#0x28              ;4218
000010  f8801041          STRB     r1,[r0,#0x41]         ;4218
000014  4903              LDR      r1,|L7.36|
000016  6341              STR      r1,[r0,#0x34]         ;4219
000018  f44f4100          MOV      r1,#0x8000            ;4222
00001c  f7fffffe          BL       I2C_Enable_IRQ
000020  2000              MOVS     r0,#0                 ;4224
000022  bd10              POP      {r4,pc}
;;;4231   
                          ENDP

                  |L7.36|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ErrorCallback PROC
;;;4531     */
;;;4532   __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4533   {
;;;4534     /* Prevent unused argument(s) compilation warning */
;;;4535     UNUSED(hi2c);
;;;4536   
;;;4537     /* NOTE : This function should not be modified, when the callback is needed,
;;;4538               the HAL_I2C_ErrorCallback could be implemented in the user file
;;;4539      */
;;;4540   }
;;;4541   
                          ENDP


                          AREA ||i.HAL_I2C_GetError||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetError PROC
;;;4605     */
;;;4606   uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
000000  6c40              LDR      r0,[r0,#0x44]
;;;4607   {
;;;4608     return hi2c->ErrorCode;
;;;4609   }
000002  4770              BX       lr
;;;4610   
                          ENDP


                          AREA ||i.HAL_I2C_GetMode||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetMode PROC
;;;4594     */
;;;4595   HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
000000  f8900042          LDRB     r0,[r0,#0x42]
;;;4596   {
;;;4597     return hi2c->Mode;
;;;4598   }
000004  4770              BX       lr
;;;4599   
                          ENDP


                          AREA ||i.HAL_I2C_GetState||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetState PROC
;;;4582     */
;;;4583   HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
000000  f8900041          LDRB     r0,[r0,#0x41]
;;;4584   {
;;;4585     /* Return I2C handle state */
;;;4586     return hi2c->State;
;;;4587   }
000004  4770              BX       lr
;;;4588   
                          ENDP


                          AREA ||i.HAL_I2C_Init||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Init PROC
;;;475      */
;;;476    HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;477    {
000002  4604              MOV      r4,r0
;;;478      /* Check the I2C handle allocation */
;;;479      if (hi2c == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L12.18|
;;;480      {
;;;481        return HAL_ERROR;
;;;482      }
;;;483    
;;;484      /* Check the parameters */
;;;485      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;486      assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
;;;487      assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
;;;488      assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
;;;489      assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
;;;490      assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
;;;491      assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
;;;492      assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
;;;493    
;;;494      if (hi2c->State == HAL_I2C_STATE_RESET)
000008  f8940041          LDRB     r0,[r4,#0x41]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L12.22|
000010  e006              B        |L12.32|
                  |L12.18|
000012  2001              MOVS     r0,#1                 ;481
;;;495      {
;;;496        /* Allocate lock resource and initialize it */
;;;497        hi2c->Lock = HAL_UNLOCKED;
;;;498    
;;;499    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;500        /* Init the I2C Callback settings */
;;;501        hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
;;;502        hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
;;;503        hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
;;;504        hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
;;;505        hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
;;;506        hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
;;;507        hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
;;;508        hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;509        hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;510        hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
;;;511    
;;;512        if (hi2c->MspInitCallback == NULL)
;;;513        {
;;;514          hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
;;;515        }
;;;516    
;;;517        /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
;;;518        hi2c->MspInitCallback(hi2c);
;;;519    #else
;;;520        /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
;;;521        HAL_I2C_MspInit(hi2c);
;;;522    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;523      }
;;;524    
;;;525      hi2c->State = HAL_I2C_STATE_BUSY;
;;;526    
;;;527      /* Disable the selected I2C peripheral */
;;;528      __HAL_I2C_DISABLE(hi2c);
;;;529    
;;;530      /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
;;;531      /* Configure I2Cx: Frequency range */
;;;532      hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
;;;533    
;;;534      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;535      /* Disable Own Address1 before set the Own Address1 configuration */
;;;536      hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
;;;537    
;;;538      /* Configure I2Cx: Own Address1 and ack own address1 mode */
;;;539      if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;540      {
;;;541        hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
;;;542      }
;;;543      else /* I2C_ADDRESSINGMODE_10BIT */
;;;544      {
;;;545        hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
;;;546      }
;;;547    
;;;548      /*---------------------------- I2Cx CR2 Configuration ----------------------*/
;;;549      /* Configure I2Cx: Addressing Master mode */
;;;550      if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;551      {
;;;552        hi2c->Instance->CR2 = (I2C_CR2_ADD10);
;;;553      }
;;;554      /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
;;;555      hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
;;;556    
;;;557      /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
;;;558      /* Disable Own Address2 before set the Own Address2 configuration */
;;;559      hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
;;;560    
;;;561      /* Configure I2Cx: Dual mode and Own Address2 */
;;;562      hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
;;;563    
;;;564      /*---------------------------- I2Cx CR1 Configuration ----------------------*/
;;;565      /* Configure I2Cx: Generalcall and NoStretch mode */
;;;566      hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
;;;567    
;;;568      /* Enable the selected I2C peripheral */
;;;569      __HAL_I2C_ENABLE(hi2c);
;;;570    
;;;571      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;572      hi2c->State = HAL_I2C_STATE_READY;
;;;573      hi2c->PreviousState = I2C_STATE_NONE;
;;;574      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;575    
;;;576      return HAL_OK;
;;;577    }
000014  bd70              POP      {r4-r6,pc}
                  |L12.22|
000016  f8845040          STRB     r5,[r4,#0x40]         ;497
00001a  4620              MOV      r0,r4                 ;521
00001c  f7fffffe          BL       HAL_I2C_MspInit
                  |L12.32|
000020  2024              MOVS     r0,#0x24              ;525
000022  f8840041          STRB     r0,[r4,#0x41]         ;525
000026  6820              LDR      r0,[r4,#0]            ;528
000028  6801              LDR      r1,[r0,#0]            ;528
00002a  f0210101          BIC      r1,r1,#1              ;528
00002e  6001              STR      r1,[r0,#0]            ;528
000030  6860              LDR      r0,[r4,#4]            ;532
000032  6821              LDR      r1,[r4,#0]            ;532
000034  f0206070          BIC      r0,r0,#0xf000000      ;532
000038  6108              STR      r0,[r1,#0x10]         ;532
00003a  6820              LDR      r0,[r4,#0]            ;536
00003c  6881              LDR      r1,[r0,#8]            ;536
00003e  f4214100          BIC      r1,r1,#0x8000         ;536
000042  6081              STR      r1,[r0,#8]            ;536
000044  68e0              LDR      r0,[r4,#0xc]          ;539
000046  2801              CMP      r0,#1                 ;539
000048  d008              BEQ      |L12.92|
00004a  68a0              LDR      r0,[r4,#8]            ;545
00004c  6821              LDR      r1,[r4,#0]            ;545
00004e  f4404004          ORR      r0,r0,#0x8400         ;545
000052  6088              STR      r0,[r1,#8]            ;545
                  |L12.84|
000054  68e0              LDR      r0,[r4,#0xc]          ;550
000056  2802              CMP      r0,#2                 ;550
000058  d006              BEQ      |L12.104|
00005a  e009              B        |L12.112|
                  |L12.92|
00005c  68a0              LDR      r0,[r4,#8]            ;541
00005e  6821              LDR      r1,[r4,#0]            ;541
000060  f4404000          ORR      r0,r0,#0x8000         ;541
000064  6088              STR      r0,[r1,#8]            ;541
000066  e7f5              B        |L12.84|
                  |L12.104|
000068  6821              LDR      r1,[r4,#0]            ;552
00006a  f44f6000          MOV      r0,#0x800             ;552
00006e  6048              STR      r0,[r1,#4]            ;552
                  |L12.112|
000070  6820              LDR      r0,[r4,#0]            ;555
000072  6841              LDR      r1,[r0,#4]            ;555
000074  4a11              LDR      r2,|L12.188|
000076  4311              ORRS     r1,r1,r2              ;555
000078  6041              STR      r1,[r0,#4]            ;555
00007a  6820              LDR      r0,[r4,#0]            ;559
00007c  68c1              LDR      r1,[r0,#0xc]          ;559
00007e  f4214100          BIC      r1,r1,#0x8000         ;559
000082  60c1              STR      r1,[r0,#0xc]          ;559
000084  e9d40104          LDRD     r0,r1,[r4,#0x10]      ;562
000088  4308              ORRS     r0,r0,r1              ;562
00008a  69a1              LDR      r1,[r4,#0x18]         ;562
00008c  ea402001          ORR      r0,r0,r1,LSL #8       ;562
000090  6821              LDR      r1,[r4,#0]            ;562
000092  60c8              STR      r0,[r1,#0xc]          ;562
000094  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;566
000098  4308              ORRS     r0,r0,r1              ;566
00009a  6821              LDR      r1,[r4,#0]            ;566
00009c  6008              STR      r0,[r1,#0]            ;566
00009e  6820              LDR      r0,[r4,#0]            ;569
0000a0  6801              LDR      r1,[r0,#0]            ;569
0000a2  f0410101          ORR      r1,r1,#1              ;569
0000a6  6001              STR      r1,[r0,#0]            ;569
0000a8  6465              STR      r5,[r4,#0x44]         ;571
0000aa  2020              MOVS     r0,#0x20              ;572
0000ac  f8840041          STRB     r0,[r4,#0x41]         ;572
0000b0  6325              STR      r5,[r4,#0x30]         ;573
0000b2  f8845042          STRB     r5,[r4,#0x42]         ;574
0000b6  2000              MOVS     r0,#0                 ;576
0000b8  bd70              POP      {r4-r6,pc}
;;;578    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L12.188|
                          DCD      0x02008000

                          AREA ||i.HAL_I2C_IsDeviceReady||, CODE, READONLY, ALIGN=2

                  HAL_I2C_IsDeviceReady PROC
;;;3030     */
;;;3031   HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3032   {
000004  4604              MOV      r4,r0
000006  4690              MOV      r8,r2
000008  461e              MOV      r6,r3
;;;3033     uint32_t tickstart;
;;;3034   
;;;3035     __IO uint32_t I2C_Trials = 0UL;
00000a  f04f0a00          MOV      r10,#0
00000e  f8cda004          STR      r10,[sp,#4]
;;;3036   
;;;3037     FlagStatus tmp1;
;;;3038     FlagStatus tmp2;
;;;3039   
;;;3040     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f8940041          LDRB     r0,[r4,#0x41]
000016  2820              CMP      r0,#0x20
000018  d002              BEQ      |L13.32|
;;;3041     {
;;;3042       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;3043       {
;;;3044         return HAL_BUSY;
;;;3045       }
;;;3046   
;;;3047       /* Process Locked */
;;;3048       __HAL_LOCK(hi2c);
;;;3049   
;;;3050       hi2c->State = HAL_I2C_STATE_BUSY;
;;;3051       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3052   
;;;3053       do
;;;3054       {
;;;3055         /* Generate Start */
;;;3056         hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
;;;3057   
;;;3058         /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;3059         /* Wait until STOPF flag is set or a NACK flag is set*/
;;;3060         tickstart = HAL_GetTick();
;;;3061   
;;;3062         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
;;;3063         tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3064   
;;;3065         while ((tmp1 == RESET) && (tmp2 == RESET))
;;;3066         {
;;;3067           if (Timeout != HAL_MAX_DELAY)
;;;3068           {
;;;3069             if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;3070             {
;;;3071               /* Update I2C state */
;;;3072               hi2c->State = HAL_I2C_STATE_READY;
;;;3073   
;;;3074               /* Update I2C error code */
;;;3075               hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;3076   
;;;3077               /* Process Unlocked */
;;;3078               __HAL_UNLOCK(hi2c);
;;;3079   
;;;3080               return HAL_ERROR;
;;;3081             }
;;;3082           }
;;;3083   
;;;3084           tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
;;;3085           tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3086         }
;;;3087   
;;;3088         /* Check if the NACKF flag has not been set */
;;;3089         if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
;;;3090         {
;;;3091           /* Wait until STOPF flag is reset */
;;;3092           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
;;;3093           {
;;;3094             return HAL_ERROR;
;;;3095           }
;;;3096   
;;;3097           /* Clear STOP Flag */
;;;3098           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;3099   
;;;3100           /* Device is ready */
;;;3101           hi2c->State = HAL_I2C_STATE_READY;
;;;3102   
;;;3103           /* Process Unlocked */
;;;3104           __HAL_UNLOCK(hi2c);
;;;3105   
;;;3106           return HAL_OK;
;;;3107         }
;;;3108         else
;;;3109         {
;;;3110           /* Wait until STOPF flag is reset */
;;;3111           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
;;;3112           {
;;;3113             return HAL_ERROR;
;;;3114           }
;;;3115   
;;;3116           /* Clear NACK Flag */
;;;3117           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3118   
;;;3119           /* Clear STOP Flag, auto generated with autoend*/
;;;3120           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;3121         }
;;;3122   
;;;3123         /* Check if the maximum allowed number of trials has been reached */
;;;3124         if (I2C_Trials == Trials)
;;;3125         {
;;;3126           /* Generate Stop */
;;;3127           hi2c->Instance->CR2 |= I2C_CR2_STOP;
;;;3128   
;;;3129           /* Wait until STOPF flag is reset */
;;;3130           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
;;;3131           {
;;;3132             return HAL_ERROR;
;;;3133           }
;;;3134   
;;;3135           /* Clear STOP Flag */
;;;3136           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;3137         }
;;;3138   
;;;3139         /* Increment Trials */
;;;3140         I2C_Trials++;
;;;3141       } while (I2C_Trials < Trials);
;;;3142   
;;;3143       /* Update I2C state */
;;;3144       hi2c->State = HAL_I2C_STATE_READY;
;;;3145   
;;;3146       /* Update I2C error code */
;;;3147       hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;3148   
;;;3149       /* Process Unlocked */
;;;3150       __HAL_UNLOCK(hi2c);
;;;3151   
;;;3152       return HAL_ERROR;
;;;3153     }
;;;3154     else
;;;3155     {
;;;3156       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L13.28|
;;;3157     }
;;;3158   }
00001c  e8bd87fc          POP      {r2-r10,pc}
                  |L13.32|
000020  6820              LDR      r0,[r4,#0]            ;3042
000022  6980              LDR      r0,[r0,#0x18]         ;3042
000024  43c0              MVNS     r0,r0                 ;3042
000026  0400              LSLS     r0,r0,#16             ;3042
000028  d401              BMI      |L13.46|
00002a  2002              MOVS     r0,#2                 ;3044
00002c  e7f6              B        |L13.28|
                  |L13.46|
00002e  f8940040          LDRB     r0,[r4,#0x40]         ;3048
000032  2801              CMP      r0,#1                 ;3048
000034  d01f              BEQ      |L13.118|
000036  2001              MOVS     r0,#1                 ;3048
000038  f8840040          STRB     r0,[r4,#0x40]         ;3048
00003c  2024              MOVS     r0,#0x24              ;3050
00003e  f8840041          STRB     r0,[r4,#0x41]         ;3050
000042  f8c4a044          STR      r10,[r4,#0x44]        ;3051
000046  f3c10709          UBFX     r7,r1,#0,#10          ;3056
00004a  f04f0920          MOV      r9,#0x20              ;3072
                  |L13.78|
00004e  68e0              LDR      r0,[r4,#0xc]          ;3056
000050  2801              CMP      r0,#1                 ;3056
000052  d012              BEQ      |L13.122|
000054  f4276080          BIC      r0,r7,#0x400          ;3056
000058  f4405020          ORR      r0,r0,#0x2800         ;3056
                  |L13.92|
00005c  6821              LDR      r1,[r4,#0]            ;3056
00005e  6048              STR      r0,[r1,#4]            ;3056
000060  f7fffffe          BL       HAL_GetTick
000064  4605              MOV      r5,r0                 ;3060
000066  6820              LDR      r0,[r4,#0]            ;3062
000068  6981              LDR      r1,[r0,#0x18]         ;3062
00006a  f3c11140          UBFX     r1,r1,#5,#1           ;3062
00006e  6980              LDR      r0,[r0,#0x18]         ;3063
000070  f3c01000          UBFX     r0,r0,#4,#1           ;3063
000074  e015              B        |L13.162|
                  |L13.118|
000076  2002              MOVS     r0,#2                 ;3048
000078  e7d0              B        |L13.28|
                  |L13.122|
00007a  4836              LDR      r0,|L13.340|
00007c  4338              ORRS     r0,r0,r7              ;3056
00007e  f4206080          BIC      r0,r0,#0x400          ;3056
000082  e7eb              B        |L13.92|
                  |L13.132|
000084  1c70              ADDS     r0,r6,#1              ;3067
000086  d005              BEQ      |L13.148|
000088  f7fffffe          BL       HAL_GetTick
00008c  1b40              SUBS     r0,r0,r5              ;3069
00008e  42b0              CMP      r0,r6                 ;3069
000090  d818              BHI      |L13.196|
000092  b1be              CBZ      r6,|L13.196|
                  |L13.148|
000094  6820              LDR      r0,[r4,#0]            ;3084
000096  6981              LDR      r1,[r0,#0x18]         ;3084
000098  f3c11140          UBFX     r1,r1,#5,#1           ;3084
00009c  6980              LDR      r0,[r0,#0x18]         ;3085
00009e  f3c01000          UBFX     r0,r0,#4,#1           ;3085
                  |L13.162|
0000a2  4301              ORRS     r1,r1,r0              ;3065
0000a4  d0ee              BEQ      |L13.132|
0000a6  6820              LDR      r0,[r4,#0]            ;3089
0000a8  6980              LDR      r0,[r0,#0x18]         ;3089
0000aa  43c0              MVNS     r0,r0                 ;3089
0000ac  06c0              LSLS     r0,r0,#27             ;3089
0000ae  d51c              BPL      |L13.234|
0000b0  4633              MOV      r3,r6                 ;3092
0000b2  2200              MOVS     r2,#0                 ;3092
0000b4  2120              MOVS     r1,#0x20              ;3092
0000b6  4620              MOV      r0,r4                 ;3092
0000b8  9500              STR      r5,[sp,#0]            ;3092
0000ba  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000be  b158              CBZ      r0,|L13.216|
0000c0  2001              MOVS     r0,#1                 ;3094
0000c2  e7ab              B        |L13.28|
                  |L13.196|
0000c4  f8849041          STRB     r9,[r4,#0x41]         ;3072
0000c8  6c60              LDR      r0,[r4,#0x44]         ;3075
0000ca  f0400020          ORR      r0,r0,#0x20           ;3075
0000ce  6460              STR      r0,[r4,#0x44]         ;3075
0000d0  f884a040          STRB     r10,[r4,#0x40]        ;3078
0000d4  2001              MOVS     r0,#1                 ;3080
0000d6  e7a1              B        |L13.28|
                  |L13.216|
0000d8  6820              LDR      r0,[r4,#0]            ;3098
0000da  f8c0901c          STR      r9,[r0,#0x1c]         ;3098
0000de  f8849041          STRB     r9,[r4,#0x41]         ;3101
0000e2  f884a040          STRB     r10,[r4,#0x40]        ;3104
0000e6  2000              MOVS     r0,#0                 ;3106
0000e8  e798              B        |L13.28|
                  |L13.234|
0000ea  4633              MOV      r3,r6                 ;3111
0000ec  2200              MOVS     r2,#0                 ;3111
0000ee  2120              MOVS     r1,#0x20              ;3111
0000f0  4620              MOV      r0,r4                 ;3111
0000f2  9500              STR      r5,[sp,#0]            ;3111
0000f4  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000f8  b108              CBZ      r0,|L13.254|
0000fa  2001              MOVS     r0,#1                 ;3113
0000fc  e78e              B        |L13.28|
                  |L13.254|
0000fe  6821              LDR      r1,[r4,#0]            ;3117
000100  2010              MOVS     r0,#0x10              ;3117
000102  61c8              STR      r0,[r1,#0x1c]         ;3117
000104  6820              LDR      r0,[r4,#0]            ;3120
000106  f8c0901c          STR      r9,[r0,#0x1c]         ;3120
00010a  9801              LDR      r0,[sp,#4]            ;3124
00010c  4540              CMP      r0,r8                 ;3124
00010e  d111              BNE      |L13.308|
000110  6820              LDR      r0,[r4,#0]            ;3127
000112  6841              LDR      r1,[r0,#4]            ;3127
000114  f4414180          ORR      r1,r1,#0x4000         ;3127
000118  6041              STR      r1,[r0,#4]            ;3127
00011a  4633              MOV      r3,r6                 ;3130
00011c  2200              MOVS     r2,#0                 ;3130
00011e  2120              MOVS     r1,#0x20              ;3130
000120  4620              MOV      r0,r4                 ;3130
000122  9500              STR      r5,[sp,#0]            ;3130
000124  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000128  b108              CBZ      r0,|L13.302|
00012a  2001              MOVS     r0,#1                 ;3132
00012c  e776              B        |L13.28|
                  |L13.302|
00012e  6820              LDR      r0,[r4,#0]            ;3136
000130  f8c0901c          STR      r9,[r0,#0x1c]         ;3136
                  |L13.308|
000134  9801              LDR      r0,[sp,#4]            ;3140
000136  1c40              ADDS     r0,r0,#1              ;3140
000138  9001              STR      r0,[sp,#4]            ;3140
00013a  9801              LDR      r0,[sp,#4]            ;3141
00013c  4540              CMP      r0,r8                 ;3141
00013e  d386              BCC      |L13.78|
000140  f8849041          STRB     r9,[r4,#0x41]         ;3144
000144  6c60              LDR      r0,[r4,#0x44]         ;3147
000146  f0400020          ORR      r0,r0,#0x20           ;3147
00014a  6460              STR      r0,[r4,#0x44]         ;3147
00014c  f884a040          STRB     r10,[r4,#0x40]        ;3150
000150  2001              MOVS     r0,#1                 ;3152
000152  e763              B        |L13.28|
;;;3159   
                          ENDP

                  |L13.340|
                          DCD      0x02002000

                          AREA ||i.HAL_I2C_ListenCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ListenCpltCallback PROC
;;;4483     */
;;;4484   __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4485   {
;;;4486     /* Prevent unused argument(s) compilation warning */
;;;4487     UNUSED(hi2c);
;;;4488   
;;;4489     /* NOTE : This function should not be modified, when the callback is needed,
;;;4490               the HAL_I2C_ListenCpltCallback() could be implemented in the user file
;;;4491      */
;;;4492   }
;;;4493   
                          ENDP


                          AREA ||i.HAL_I2C_MasterRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterRxCpltCallback PROC
;;;4416     */
;;;4417   __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4418   {
;;;4419     /* Prevent unused argument(s) compilation warning */
;;;4420     UNUSED(hi2c);
;;;4421   
;;;4422     /* NOTE : This function should not be modified, when the callback is needed,
;;;4423               the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
;;;4424      */
;;;4425   }
;;;4426   
                          ENDP


                          AREA ||i.HAL_I2C_MasterTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterTxCpltCallback PROC
;;;4400     */
;;;4401   __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4402   {
;;;4403     /* Prevent unused argument(s) compilation warning */
;;;4404     UNUSED(hi2c);
;;;4405   
;;;4406     /* NOTE : This function should not be modified, when the callback is needed,
;;;4407               the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
;;;4408      */
;;;4409   }
;;;4410   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Abort_IT PROC
;;;4270     */
;;;4271   HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
000000  b538              PUSH     {r3-r5,lr}
;;;4272   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4273     if (hi2c->Mode == HAL_I2C_MODE_MASTER)
000006  f8940042          LDRB     r0,[r4,#0x42]
00000a  2810              CMP      r0,#0x10
00000c  d001              BEQ      |L17.18|
;;;4274     {
;;;4275       /* Process Locked */
;;;4276       __HAL_LOCK(hi2c);
;;;4277   
;;;4278       /* Disable Interrupts and Store Previous state */
;;;4279       if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
;;;4280       {
;;;4281         I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;4282         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
;;;4283       }
;;;4284       else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
;;;4285       {
;;;4286         I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;4287         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
;;;4288       }
;;;4289       else
;;;4290       {
;;;4291         /* Do nothing */
;;;4292       }
;;;4293   
;;;4294       /* Set State at HAL_I2C_STATE_ABORT */
;;;4295       hi2c->State = HAL_I2C_STATE_ABORT;
;;;4296   
;;;4297       /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
;;;4298       /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
;;;4299       I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
;;;4300   
;;;4301       /* Process Unlocked */
;;;4302       __HAL_UNLOCK(hi2c);
;;;4303   
;;;4304       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4305                 to avoid the risk of I2C interrupt handle execution before current
;;;4306                 process unlock */
;;;4307       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
;;;4308   
;;;4309       return HAL_OK;
;;;4310     }
;;;4311     else
;;;4312     {
;;;4313       /* Wrong usage of abort function */
;;;4314       /* This function should be used only in case of abort monitored by master device */
;;;4315       return HAL_ERROR;
00000e  2001              MOVS     r0,#1
;;;4316     }
;;;4317   }
000010  bd38              POP      {r3-r5,pc}
                  |L17.18|
000012  f8940040          LDRB     r0,[r4,#0x40]         ;4276
000016  2801              CMP      r0,#1                 ;4276
000018  d00b              BEQ      |L17.50|
00001a  2001              MOVS     r0,#1                 ;4276
00001c  f8840040          STRB     r0,[r4,#0x40]         ;4276
000020  f8940041          LDRB     r0,[r4,#0x41]         ;4279
000024  2821              CMP      r0,#0x21              ;4279
000026  d006              BEQ      |L17.54|
000028  f8940041          LDRB     r0,[r4,#0x41]         ;4284
00002c  2822              CMP      r0,#0x22              ;4284
00002e  d009              BEQ      |L17.68|
000030  e00e              B        |L17.80|
                  |L17.50|
000032  2002              MOVS     r0,#2                 ;4276
000034  bd38              POP      {r3-r5,pc}
                  |L17.54|
000036  2101              MOVS     r1,#1                 ;4281
000038  4620              MOV      r0,r4                 ;4281
00003a  f7fffffe          BL       I2C_Disable_IRQ
00003e  2011              MOVS     r0,#0x11              ;4282
000040  6320              STR      r0,[r4,#0x30]         ;4282
000042  e005              B        |L17.80|
                  |L17.68|
000044  2102              MOVS     r1,#2                 ;4286
000046  4620              MOV      r0,r4                 ;4286
000048  f7fffffe          BL       I2C_Disable_IRQ
00004c  2012              MOVS     r0,#0x12              ;4287
00004e  6320              STR      r0,[r4,#0x30]         ;4287
                  |L17.80|
000050  2060              MOVS     r0,#0x60              ;4295
000052  f8840041          STRB     r0,[r4,#0x41]         ;4295
000056  4808              LDR      r0,|L17.120|
000058  9000              STR      r0,[sp,#0]            ;4299
00005a  02c3              LSLS     r3,r0,#11             ;4299
00005c  2201              MOVS     r2,#1                 ;4299
00005e  4629              MOV      r1,r5                 ;4299
000060  4620              MOV      r0,r4                 ;4299
000062  f7fffffe          BL       I2C_TransferConfig
000066  2000              MOVS     r0,#0                 ;4302
000068  f8840040          STRB     r0,[r4,#0x40]         ;4302
00006c  2120              MOVS     r1,#0x20              ;4307
00006e  4620              MOV      r0,r4                 ;4307
000070  f7fffffe          BL       I2C_Enable_IRQ
000074  2000              MOVS     r0,#0                 ;4309
000076  bd38              POP      {r3-r5,pc}
;;;4318   
                          ENDP

                  |L17.120|
                          DCD      0x80004000

                          AREA ||i.HAL_I2C_Master_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive PROC
;;;1182     */
;;;1183   HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1184                                            uint32_t Timeout)
;;;1185   {
000004  4604              MOV      r4,r0
000006  f8dda028          LDR      r10,[sp,#0x28]
00000a  468b              MOV      r11,r1
00000c  4617              MOV      r7,r2
00000e  4698              MOV      r8,r3
;;;1186     uint32_t tickstart;
;;;1187   
;;;1188     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2820              CMP      r0,#0x20
000016  d002              BEQ      |L18.30|
;;;1189     {
;;;1190       /* Process Locked */
;;;1191       __HAL_LOCK(hi2c);
;;;1192   
;;;1193       /* Init tickstart for timeout management*/
;;;1194       tickstart = HAL_GetTick();
;;;1195   
;;;1196       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;1197       {
;;;1198         return HAL_ERROR;
;;;1199       }
;;;1200   
;;;1201       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1202       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1203       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1204   
;;;1205       /* Prepare transfer parameters */
;;;1206       hi2c->pBuffPtr  = pData;
;;;1207       hi2c->XferCount = Size;
;;;1208       hi2c->XferISR   = NULL;
;;;1209   
;;;1210       /* Send Slave Address */
;;;1211       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;1212       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1213       {
;;;1214         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1215         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
;;;1216       }
;;;1217       else
;;;1218       {
;;;1219         hi2c->XferSize = hi2c->XferCount;
;;;1220         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
;;;1221       }
;;;1222   
;;;1223       while (hi2c->XferCount > 0U)
;;;1224       {
;;;1225         /* Wait until RXNE flag is set */
;;;1226         if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1227         {
;;;1228           return HAL_ERROR;
;;;1229         }
;;;1230   
;;;1231         /* Read data from RXDR */
;;;1232         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
;;;1233   
;;;1234         /* Increment Buffer pointer */
;;;1235         hi2c->pBuffPtr++;
;;;1236   
;;;1237         hi2c->XferSize--;
;;;1238         hi2c->XferCount--;
;;;1239   
;;;1240         if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
;;;1241         {
;;;1242           /* Wait until TCR flag is set */
;;;1243           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;1244           {
;;;1245             return HAL_ERROR;
;;;1246           }
;;;1247   
;;;1248           if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1249           {
;;;1250             hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1251             I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;1252           }
;;;1253           else
;;;1254           {
;;;1255             hi2c->XferSize = hi2c->XferCount;
;;;1256             I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;1257           }
;;;1258         }
;;;1259       }
;;;1260   
;;;1261       /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;1262       /* Wait until STOPF flag is set */
;;;1263       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1264       {
;;;1265         return HAL_ERROR;
;;;1266       }
;;;1267   
;;;1268       /* Clear STOP Flag */
;;;1269       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;1270   
;;;1271       /* Clear Configuration Register 2 */
;;;1272       I2C_RESET_CR2(hi2c);
;;;1273   
;;;1274       hi2c->State = HAL_I2C_STATE_READY;
;;;1275       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;1276   
;;;1277       /* Process Unlocked */
;;;1278       __HAL_UNLOCK(hi2c);
;;;1279   
;;;1280       return HAL_OK;
;;;1281     }
;;;1282     else
;;;1283     {
;;;1284       return HAL_BUSY;
000018  2002              MOVS     r0,#2
                  |L18.26|
;;;1285     }
;;;1286   }
00001a  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.30|
00001e  f8940040          LDRB     r0,[r4,#0x40]         ;1191
000022  2801              CMP      r0,#1                 ;1191
000024  d00f              BEQ      |L18.70|
000026  2001              MOVS     r0,#1                 ;1191
000028  f8840040          STRB     r0,[r4,#0x40]         ;1191
00002c  f7fffffe          BL       HAL_GetTick
000030  4606              MOV      r6,r0                 ;1194
000032  2201              MOVS     r2,#1                 ;1196
000034  2319              MOVS     r3,#0x19              ;1196
000036  03d1              LSLS     r1,r2,#15             ;1196
000038  4620              MOV      r0,r4                 ;1196
00003a  9600              STR      r6,[sp,#0]            ;1196
00003c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000040  b118              CBZ      r0,|L18.74|
000042  2001              MOVS     r0,#1                 ;1198
000044  e7e9              B        |L18.26|
                  |L18.70|
000046  2002              MOVS     r0,#2                 ;1191
000048  e7e7              B        |L18.26|
                  |L18.74|
00004a  2022              MOVS     r0,#0x22              ;1201
00004c  f8840041          STRB     r0,[r4,#0x41]         ;1201
000050  2010              MOVS     r0,#0x10              ;1202
000052  f8840042          STRB     r0,[r4,#0x42]         ;1202
000056  2500              MOVS     r5,#0                 ;1203
000058  6465              STR      r5,[r4,#0x44]         ;1203
00005a  6267              STR      r7,[r4,#0x24]         ;1206
00005c  f8a4802a          STRH     r8,[r4,#0x2a]         ;1207
000060  6365              STR      r5,[r4,#0x34]         ;1208
000062  8d61              LDRH     r1,[r4,#0x2a]         ;1212
000064  4837              LDR      r0,|L18.324|
000066  27ff              MOVS     r7,#0xff              ;1214
000068  f04f7880          MOV      r8,#0x1000000         ;1215
00006c  f04f7900          MOV      r9,#0x2000000         ;1220
000070  29ff              CMP      r1,#0xff              ;1212
000072  d908              BLS      |L18.134|
000074  463a              MOV      r2,r7                 ;1214
000076  8527              STRH     r7,[r4,#0x28]         ;1214
000078  9000              STR      r0,[sp,#0]            ;1215
00007a  4643              MOV      r3,r8                 ;1215
00007c  4659              MOV      r1,r11                ;1215
00007e  4620              MOV      r0,r4                 ;1215
000080  f7fffffe          BL       I2C_TransferConfig
000084  e043              B        |L18.270|
                  |L18.134|
000086  8d61              LDRH     r1,[r4,#0x2a]         ;1219
000088  8521              STRH     r1,[r4,#0x28]         ;1219
00008a  9000              STR      r0,[sp,#0]            ;1220
00008c  f8942028          LDRB     r2,[r4,#0x28]         ;1220
000090  464b              MOV      r3,r9                 ;1220
000092  4659              MOV      r1,r11                ;1220
000094  4620              MOV      r0,r4                 ;1220
000096  f7fffffe          BL       I2C_TransferConfig
00009a  e038              B        |L18.270|
                  |L18.156|
00009c  4632              MOV      r2,r6                 ;1226
00009e  4651              MOV      r1,r10                ;1226
0000a0  4620              MOV      r0,r4                 ;1226
0000a2  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000a6  b108              CBZ      r0,|L18.172|
0000a8  2001              MOVS     r0,#1                 ;1228
0000aa  e7b6              B        |L18.26|
                  |L18.172|
0000ac  6820              LDR      r0,[r4,#0]            ;1232
0000ae  6a40              LDR      r0,[r0,#0x24]         ;1232
0000b0  6a61              LDR      r1,[r4,#0x24]         ;1232
0000b2  7008              STRB     r0,[r1,#0]            ;1232
0000b4  6a60              LDR      r0,[r4,#0x24]         ;1235
0000b6  1c40              ADDS     r0,r0,#1              ;1235
0000b8  6260              STR      r0,[r4,#0x24]         ;1235
0000ba  8d20              LDRH     r0,[r4,#0x28]         ;1237
0000bc  1e40              SUBS     r0,r0,#1              ;1237
0000be  b280              UXTH     r0,r0                 ;1237
0000c0  8520              STRH     r0,[r4,#0x28]         ;1237
0000c2  8d61              LDRH     r1,[r4,#0x2a]         ;1238
0000c4  1e49              SUBS     r1,r1,#1              ;1238
0000c6  8561              STRH     r1,[r4,#0x2a]         ;1238
0000c8  8d61              LDRH     r1,[r4,#0x2a]         ;1240
0000ca  b301              CBZ      r1,|L18.270|
0000cc  b9f8              CBNZ     r0,|L18.270|
0000ce  4653              MOV      r3,r10                ;1243
0000d0  2200              MOVS     r2,#0                 ;1243
0000d2  2180              MOVS     r1,#0x80              ;1243
0000d4  4620              MOV      r0,r4                 ;1243
0000d6  9600              STR      r6,[sp,#0]            ;1243
0000d8  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000dc  b108              CBZ      r0,|L18.226|
0000de  2001              MOVS     r0,#1                 ;1245
0000e0  e79b              B        |L18.26|
                  |L18.226|
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1248
0000e4  28ff              CMP      r0,#0xff              ;1248
0000e6  d908              BLS      |L18.250|
0000e8  463a              MOV      r2,r7                 ;1250
0000ea  8527              STRH     r7,[r4,#0x28]         ;1250
0000ec  4643              MOV      r3,r8                 ;1251
0000ee  4659              MOV      r1,r11                ;1251
0000f0  4620              MOV      r0,r4                 ;1251
0000f2  9500              STR      r5,[sp,#0]            ;1251
0000f4  f7fffffe          BL       I2C_TransferConfig
0000f8  e009              B        |L18.270|
                  |L18.250|
0000fa  8d60              LDRH     r0,[r4,#0x2a]         ;1255
0000fc  8520              STRH     r0,[r4,#0x28]         ;1255
0000fe  9500              STR      r5,[sp,#0]            ;1256
000100  f8942028          LDRB     r2,[r4,#0x28]         ;1256
000104  464b              MOV      r3,r9                 ;1256
000106  4659              MOV      r1,r11                ;1256
000108  4620              MOV      r0,r4                 ;1256
00010a  f7fffffe          BL       I2C_TransferConfig
                  |L18.270|
00010e  8d60              LDRH     r0,[r4,#0x2a]         ;1223
000110  2800              CMP      r0,#0                 ;1223
000112  d1c3              BNE      |L18.156|
000114  4632              MOV      r2,r6                 ;1263
000116  4651              MOV      r1,r10                ;1263
000118  4620              MOV      r0,r4                 ;1263
00011a  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00011e  b108              CBZ      r0,|L18.292|
000120  2001              MOVS     r0,#1                 ;1265
000122  e77a              B        |L18.26|
                  |L18.292|
000124  6820              LDR      r0,[r4,#0]            ;1269
000126  2120              MOVS     r1,#0x20              ;1269
000128  61c1              STR      r1,[r0,#0x1c]         ;1269
00012a  6820              LDR      r0,[r4,#0]            ;1272
00012c  6842              LDR      r2,[r0,#4]            ;1272
00012e  4b06              LDR      r3,|L18.328|
000130  401a              ANDS     r2,r2,r3              ;1272
000132  6042              STR      r2,[r0,#4]            ;1272
000134  f8841041          STRB     r1,[r4,#0x41]         ;1274
000138  f8845042          STRB     r5,[r4,#0x42]         ;1275
00013c  f8845040          STRB     r5,[r4,#0x40]         ;1278
000140  2000              MOVS     r0,#0                 ;1280
000142  e76a              B        |L18.26|
;;;1287   
                          ENDP

                  |L18.324|
                          DCD      0x80002400
                  |L18.328|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Master_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_DMA PROC
;;;1940     */
;;;1941   HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1942                                                uint16_t Size)
;;;1943   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;1944     uint32_t xfermode;
;;;1945     HAL_StatusTypeDef dmaxferstatus;
;;;1946   
;;;1947     if (hi2c->State == HAL_I2C_STATE_READY)
000008  f8940041          LDRB     r0,[r4,#0x41]
00000c  2820              CMP      r0,#0x20
00000e  d002              BEQ      |L19.22|
;;;1948     {
;;;1949       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;1950       {
;;;1951         return HAL_BUSY;
;;;1952       }
;;;1953   
;;;1954       /* Process Locked */
;;;1955       __HAL_LOCK(hi2c);
;;;1956   
;;;1957       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1958       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1959       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1960   
;;;1961       /* Prepare transfer parameters */
;;;1962       hi2c->pBuffPtr    = pData;
;;;1963       hi2c->XferCount   = Size;
;;;1964       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1965       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;1966   
;;;1967       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1968       {
;;;1969         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1970         xfermode = I2C_RELOAD_MODE;
;;;1971       }
;;;1972       else
;;;1973       {
;;;1974         hi2c->XferSize = hi2c->XferCount;
;;;1975         xfermode = I2C_AUTOEND_MODE;
;;;1976       }
;;;1977   
;;;1978       if (hi2c->XferSize > 0U)
;;;1979       {
;;;1980         if (hi2c->hdmarx != NULL)
;;;1981         {
;;;1982           /* Set the I2C DMA transfer complete callback */
;;;1983           hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
;;;1984   
;;;1985           /* Set the DMA error callback */
;;;1986           hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;1987   
;;;1988           /* Set the unused DMA callbacks to NULL */
;;;1989           hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;1990           hi2c->hdmarx->XferAbortCallback = NULL;
;;;1991   
;;;1992           /* Enable the DMA channel */
;;;1993           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;1994         }
;;;1995         else
;;;1996         {
;;;1997           /* Update I2C state */
;;;1998           hi2c->State     = HAL_I2C_STATE_READY;
;;;1999           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2000   
;;;2001           /* Update I2C error code */
;;;2002           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2003   
;;;2004           /* Process Unlocked */
;;;2005           __HAL_UNLOCK(hi2c);
;;;2006   
;;;2007           return HAL_ERROR;
;;;2008         }
;;;2009   
;;;2010         if (dmaxferstatus == HAL_OK)
;;;2011         {
;;;2012           /* Send Slave Address */
;;;2013           /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2014           I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;2015   
;;;2016           /* Update XferCount value */
;;;2017           hi2c->XferCount -= hi2c->XferSize;
;;;2018   
;;;2019           /* Process Unlocked */
;;;2020           __HAL_UNLOCK(hi2c);
;;;2021   
;;;2022           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2023                     to avoid the risk of I2C interrupt handle execution before current
;;;2024                     process unlock */
;;;2025           /* Enable ERR and NACK interrupts */
;;;2026           I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;2027   
;;;2028           /* Enable DMA Request */
;;;2029           hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;2030         }
;;;2031         else
;;;2032         {
;;;2033           /* Update I2C state */
;;;2034           hi2c->State     = HAL_I2C_STATE_READY;
;;;2035           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2036   
;;;2037           /* Update I2C error code */
;;;2038           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2039   
;;;2040           /* Process Unlocked */
;;;2041           __HAL_UNLOCK(hi2c);
;;;2042   
;;;2043           return HAL_ERROR;
;;;2044         }
;;;2045       }
;;;2046       else
;;;2047       {
;;;2048         /* Update Transfer ISR function pointer */
;;;2049         hi2c->XferISR = I2C_Master_ISR_IT;
;;;2050   
;;;2051         /* Send Slave Address */
;;;2052         /* Set NBYTES to read and generate START condition */
;;;2053         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
;;;2054   
;;;2055         /* Process Unlocked */
;;;2056         __HAL_UNLOCK(hi2c);
;;;2057   
;;;2058         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2059                   to avoid the risk of I2C interrupt handle execution before current
;;;2060                   process unlock */
;;;2061         /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;2062         /* possible to enable all of these */
;;;2063         /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;2064         I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;2065       }
;;;2066   
;;;2067       return HAL_OK;
;;;2068     }
;;;2069     else
;;;2070     {
;;;2071       return HAL_BUSY;
000010  2002              MOVS     r0,#2
                  |L19.18|
;;;2072     }
;;;2073   }
000012  e8bd83f8          POP      {r3-r9,pc}
                  |L19.22|
000016  6820              LDR      r0,[r4,#0]            ;1949
000018  6980              LDR      r0,[r0,#0x18]         ;1949
00001a  43c0              MVNS     r0,r0                 ;1949
00001c  0400              LSLS     r0,r0,#16             ;1949
00001e  d401              BMI      |L19.36|
000020  2002              MOVS     r0,#2                 ;1951
000022  e7f6              B        |L19.18|
                  |L19.36|
000024  f8940040          LDRB     r0,[r4,#0x40]         ;1955
000028  2801              CMP      r0,#1                 ;1955
00002a  d018              BEQ      |L19.94|
00002c  2001              MOVS     r0,#1                 ;1955
00002e  3424              ADDS     r4,r4,#0x24           ;1955
000030  7720              STRB     r0,[r4,#0x1c]         ;1955
000032  2022              MOVS     r0,#0x22              ;1957
000034  7760              STRB     r0,[r4,#0x1d]         ;1957
000036  2010              MOVS     r0,#0x10              ;1958
000038  77a0              STRB     r0,[r4,#0x1e]         ;1958
00003a  2500              MOVS     r5,#0                 ;1959
00003c  6225              STR      r5,[r4,#0x20]         ;1959
00003e  6022              STR      r2,[r4,#0]            ;1962
000040  80e3              STRH     r3,[r4,#6]            ;1963
000042  4835              LDR      r0,|L19.280|
000044  60a0              STR      r0,[r4,#8]            ;1964
000046  4835              LDR      r0,|L19.284|
000048  6120              STR      r0,[r4,#0x10]         ;1965
00004a  88e0              LDRH     r0,[r4,#6]            ;1967
00004c  3c24              SUBS     r4,r4,#0x24           ;1967
00004e  f04f7300          MOV      r3,#0x2000000         ;1975
000052  28ff              CMP      r0,#0xff              ;1967
000054  d905              BLS      |L19.98|
000056  20ff              MOVS     r0,#0xff              ;1969
000058  8520              STRH     r0,[r4,#0x28]         ;1969
00005a  105e              ASRS     r6,r3,#1              ;1970
00005c  e004              B        |L19.104|
                  |L19.94|
00005e  2002              MOVS     r0,#2                 ;1955
000060  e7d7              B        |L19.18|
                  |L19.98|
000062  8d60              LDRH     r0,[r4,#0x2a]         ;1974
000064  8520              STRH     r0,[r4,#0x28]         ;1974
000066  461e              MOV      r6,r3                 ;1975
                  |L19.104|
000068  8d20              LDRH     r0,[r4,#0x28]         ;1978
00006a  4f2d              LDR      r7,|L19.288|
00006c  b3f0              CBZ      r0,|L19.236|
00006e  6be0              LDR      r0,[r4,#0x3c]         ;1980
000070  f04f0820          MOV      r8,#0x20              ;1998
000074  b1d0              CBZ      r0,|L19.172|
000076  492b              LDR      r1,|L19.292|
000078  62c1              STR      r1,[r0,#0x2c]         ;1983
00007a  6be1              LDR      r1,[r4,#0x3c]         ;1986
00007c  482a              LDR      r0,|L19.296|
00007e  6348              STR      r0,[r1,#0x34]         ;1986
000080  6be0              LDR      r0,[r4,#0x3c]         ;1989
000082  6305              STR      r5,[r0,#0x30]         ;1989
000084  6be0              LDR      r0,[r4,#0x3c]         ;1990
000086  6385              STR      r5,[r0,#0x38]         ;1990
000088  6821              LDR      r1,[r4,#0]            ;1993
00008a  8d23              LDRH     r3,[r4,#0x28]         ;1993
00008c  3124              ADDS     r1,r1,#0x24           ;1993
00008e  6be0              LDR      r0,[r4,#0x3c]         ;1993
000090  f7fffffe          BL       HAL_DMA_Start_IT
000094  b1a8              CBZ      r0,|L19.194|
000096  3440              ADDS     r4,r4,#0x40           ;2034
000098  f8848001          STRB     r8,[r4,#1]            ;2034
00009c  70a5              STRB     r5,[r4,#2]            ;2035
00009e  6860              LDR      r0,[r4,#4]            ;2038
0000a0  f0400010          ORR      r0,r0,#0x10           ;2038
0000a4  6060              STR      r0,[r4,#4]            ;2038
0000a6  7025              STRB     r5,[r4,#0]            ;2041
0000a8  2001              MOVS     r0,#1                 ;2043
0000aa  e7b2              B        |L19.18|
                  |L19.172|
0000ac  3440              ADDS     r4,r4,#0x40           ;1998
0000ae  f8848001          STRB     r8,[r4,#1]            ;1998
0000b2  70a5              STRB     r5,[r4,#2]            ;1999
0000b4  6860              LDR      r0,[r4,#4]            ;2002
0000b6  f0400080          ORR      r0,r0,#0x80           ;2002
0000ba  6060              STR      r0,[r4,#4]            ;2002
0000bc  7025              STRB     r5,[r4,#0]            ;2005
0000be  2001              MOVS     r0,#1                 ;2007
0000c0  e7a7              B        |L19.18|
                  |L19.194|
0000c2  9700              STR      r7,[sp,#0]            ;2014
0000c4  f8942028          LDRB     r2,[r4,#0x28]         ;2014
0000c8  4633              MOV      r3,r6                 ;2014
0000ca  4649              MOV      r1,r9                 ;2014
0000cc  4620              MOV      r0,r4                 ;2014
0000ce  f7fffffe          BL       I2C_TransferConfig
0000d2  8d60              LDRH     r0,[r4,#0x2a]         ;2017
0000d4  8d21              LDRH     r1,[r4,#0x28]         ;2017
0000d6  1a40              SUBS     r0,r0,r1              ;2017
0000d8  8560              STRH     r0,[r4,#0x2a]         ;2017
0000da  f8845040          STRB     r5,[r4,#0x40]         ;2020
0000de  2110              MOVS     r1,#0x10              ;2026
0000e0  4620              MOV      r0,r4                 ;2026
0000e2  f7fffffe          BL       I2C_Enable_IRQ
0000e6  6820              LDR      r0,[r4,#0]            ;2029
0000e8  6801              LDR      r1,[r0,#0]            ;2029
0000ea  e000              B        |L19.238|
                  |L19.236|
0000ec  e003              B        |L19.246|
                  |L19.238|
0000ee  f4414100          ORR      r1,r1,#0x8000         ;2029
0000f2  6001              STR      r1,[r0,#0]            ;2029
0000f4  e00d              B        |L19.274|
                  |L19.246|
0000f6  480d              LDR      r0,|L19.300|
0000f8  6360              STR      r0,[r4,#0x34]         ;2049
0000fa  2200              MOVS     r2,#0                 ;2053
0000fc  4649              MOV      r1,r9                 ;2053
0000fe  4620              MOV      r0,r4                 ;2053
000100  9700              STR      r7,[sp,#0]            ;2053
000102  f7fffffe          BL       I2C_TransferConfig
000106  f8845040          STRB     r5,[r4,#0x40]         ;2056
00010a  2101              MOVS     r1,#1                 ;2064
00010c  4620              MOV      r0,r4                 ;2064
00010e  f7fffffe          BL       I2C_Enable_IRQ
                  |L19.274|
000112  2000              MOVS     r0,#0                 ;2067
000114  e77d              B        |L19.18|
;;;2074   
                          ENDP

000116  0000              DCW      0x0000
                  |L19.280|
                          DCD      0xffff0000
                  |L19.284|
                          DCD      I2C_Master_ISR_DMA
                  |L19.288|
                          DCD      0x80002400
                  |L19.292|
                          DCD      I2C_DMAMasterReceiveCplt
                  |L19.296|
                          DCD      I2C_DMAError
                  |L19.300|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_IT PROC
;;;1629     */
;;;1630   HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;1631   {
000002  4604              MOV      r4,r0
;;;1632     uint32_t xfermode;
;;;1633   
;;;1634     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f8940041          LDRB     r0,[r4,#0x41]
000008  2820              CMP      r0,#0x20
00000a  d001              BEQ      |L20.16|
;;;1635     {
;;;1636       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;1637       {
;;;1638         return HAL_BUSY;
;;;1639       }
;;;1640   
;;;1641       /* Process Locked */
;;;1642       __HAL_LOCK(hi2c);
;;;1643   
;;;1644       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1645       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1646       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1647   
;;;1648       /* Prepare transfer parameters */
;;;1649       hi2c->pBuffPtr    = pData;
;;;1650       hi2c->XferCount   = Size;
;;;1651       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1652       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;1653   
;;;1654       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1655       {
;;;1656         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1657         xfermode = I2C_RELOAD_MODE;
;;;1658       }
;;;1659       else
;;;1660       {
;;;1661         hi2c->XferSize = hi2c->XferCount;
;;;1662         xfermode = I2C_AUTOEND_MODE;
;;;1663       }
;;;1664   
;;;1665       /* Send Slave Address */
;;;1666       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
;;;1667       I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;1668   
;;;1669       /* Process Unlocked */
;;;1670       __HAL_UNLOCK(hi2c);
;;;1671   
;;;1672       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1673                 to avoid the risk of I2C interrupt handle execution before current
;;;1674                 process unlock */
;;;1675   
;;;1676       /* Enable ERR, TC, STOP, NACK, RXI interrupt */
;;;1677       /* possible to enable all of these */
;;;1678       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1679       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;1680   
;;;1681       return HAL_OK;
;;;1682     }
;;;1683     else
;;;1684     {
;;;1685       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;1686     }
;;;1687   }
00000e  bd38              POP      {r3-r5,pc}
                  |L20.16|
000010  6820              LDR      r0,[r4,#0]            ;1636
000012  6980              LDR      r0,[r0,#0x18]         ;1636
000014  43c0              MVNS     r0,r0                 ;1636
000016  0400              LSLS     r0,r0,#16             ;1636
000018  d401              BMI      |L20.30|
00001a  2002              MOVS     r0,#2                 ;1638
00001c  bd38              POP      {r3-r5,pc}
                  |L20.30|
00001e  f8940040          LDRB     r0,[r4,#0x40]         ;1642
000022  2801              CMP      r0,#1                 ;1642
000024  d017              BEQ      |L20.86|
000026  2001              MOVS     r0,#1                 ;1642
000028  3424              ADDS     r4,r4,#0x24           ;1642
00002a  7720              STRB     r0,[r4,#0x1c]         ;1642
00002c  2022              MOVS     r0,#0x22              ;1644
00002e  7760              STRB     r0,[r4,#0x1d]         ;1644
000030  2010              MOVS     r0,#0x10              ;1645
000032  77a0              STRB     r0,[r4,#0x1e]         ;1645
000034  2500              MOVS     r5,#0                 ;1646
000036  6225              STR      r5,[r4,#0x20]         ;1646
000038  6022              STR      r2,[r4,#0]            ;1649
00003a  80e3              STRH     r3,[r4,#6]            ;1650
00003c  4810              LDR      r0,|L20.128|
00003e  60a0              STR      r0,[r4,#8]            ;1651
000040  4810              LDR      r0,|L20.132|
000042  6120              STR      r0,[r4,#0x10]         ;1652
000044  88e0              LDRH     r0,[r4,#6]            ;1654
000046  3c24              SUBS     r4,r4,#0x24           ;1654
000048  28ff              CMP      r0,#0xff              ;1654
00004a  d906              BLS      |L20.90|
00004c  20ff              MOVS     r0,#0xff              ;1656
00004e  8520              STRH     r0,[r4,#0x28]         ;1656
000050  f04f7380          MOV      r3,#0x1000000         ;1657
000054  e005              B        |L20.98|
                  |L20.86|
000056  2002              MOVS     r0,#2                 ;1642
000058  bd38              POP      {r3-r5,pc}
                  |L20.90|
00005a  8d60              LDRH     r0,[r4,#0x2a]         ;1661
00005c  8520              STRH     r0,[r4,#0x28]         ;1661
00005e  f04f7300          MOV      r3,#0x2000000         ;1662
                  |L20.98|
000062  4809              LDR      r0,|L20.136|
000064  9000              STR      r0,[sp,#0]            ;1667
000066  f8942028          LDRB     r2,[r4,#0x28]         ;1667
00006a  4620              MOV      r0,r4                 ;1667
00006c  f7fffffe          BL       I2C_TransferConfig
000070  f8845040          STRB     r5,[r4,#0x40]         ;1670
000074  2102              MOVS     r1,#2                 ;1679
000076  4620              MOV      r0,r4                 ;1679
000078  f7fffffe          BL       I2C_Enable_IRQ
00007c  2000              MOVS     r0,#0                 ;1681
00007e  bd38              POP      {r3-r5,pc}
;;;1688   
                          ENDP

                  |L20.128|
                          DCD      0xffff0000
                  |L20.132|
                          DCD      I2C_Master_ISR_IT
                  |L20.136|
                          DCD      0x80002400

                          AREA ||i.HAL_I2C_Master_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_DMA PROC
;;;3504     */
;;;3505   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3506                                                    uint16_t Size, uint32_t XferOptions)
;;;3507   {
000004  4604              MOV      r4,r0
000006  980a              LDR      r0,[sp,#0x28]
000008  4689              MOV      r9,r1
00000a  4690              MOV      r8,r2
;;;3508     uint32_t xfermode;
;;;3509     uint32_t xferrequest = I2C_GENERATE_START_READ;
00000c  f8dfa128          LDR      r10,|L21.312|
000010  4655              MOV      r5,r10
;;;3510     HAL_StatusTypeDef dmaxferstatus;
;;;3511   
;;;3512     /* Check the parameters */
;;;3513     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3514   
;;;3515     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f8941041          LDRB     r1,[r4,#0x41]
000016  2920              CMP      r1,#0x20
000018  d002              BEQ      |L21.32|
;;;3516     {
;;;3517       /* Process Locked */
;;;3518       __HAL_LOCK(hi2c);
;;;3519   
;;;3520       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3521       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3522       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3523   
;;;3524       /* Prepare transfer parameters */
;;;3525       hi2c->pBuffPtr    = pData;
;;;3526       hi2c->XferCount   = Size;
;;;3527       hi2c->XferOptions = XferOptions;
;;;3528       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;3529   
;;;3530       /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
;;;3531       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;3532       {
;;;3533         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;3534         xfermode = I2C_RELOAD_MODE;
;;;3535       }
;;;3536       else
;;;3537       {
;;;3538         hi2c->XferSize = hi2c->XferCount;
;;;3539         xfermode = hi2c->XferOptions;
;;;3540       }
;;;3541   
;;;3542       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3543       /* Mean Previous state is same as current state */
;;;3544       if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
;;;3545       {
;;;3546         xferrequest = I2C_NO_STARTSTOP;
;;;3547       }
;;;3548       else
;;;3549       {
;;;3550         /* Convert OTHER_xxx XferOptions if any */
;;;3551         I2C_ConvertOtherXferOptions(hi2c);
;;;3552   
;;;3553         /* Update xfermode accordingly if no reload is necessary */
;;;3554         if (hi2c->XferCount <= MAX_NBYTE_SIZE)
;;;3555         {
;;;3556           xfermode = hi2c->XferOptions;
;;;3557         }
;;;3558       }
;;;3559   
;;;3560       if (hi2c->XferSize > 0U)
;;;3561       {
;;;3562         if (hi2c->hdmarx != NULL)
;;;3563         {
;;;3564           /* Set the I2C DMA transfer complete callback */
;;;3565           hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
;;;3566   
;;;3567           /* Set the DMA error callback */
;;;3568           hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;3569   
;;;3570           /* Set the unused DMA callbacks to NULL */
;;;3571           hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;3572           hi2c->hdmarx->XferAbortCallback = NULL;
;;;3573   
;;;3574           /* Enable the DMA channel */
;;;3575           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;3576         }
;;;3577         else
;;;3578         {
;;;3579           /* Update I2C state */
;;;3580           hi2c->State     = HAL_I2C_STATE_READY;
;;;3581           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3582   
;;;3583           /* Update I2C error code */
;;;3584           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;3585   
;;;3586           /* Process Unlocked */
;;;3587           __HAL_UNLOCK(hi2c);
;;;3588   
;;;3589           return HAL_ERROR;
;;;3590         }
;;;3591   
;;;3592         if (dmaxferstatus == HAL_OK)
;;;3593         {
;;;3594           /* Send Slave Address and set NBYTES to read */
;;;3595           I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
;;;3596   
;;;3597           /* Update XferCount value */
;;;3598           hi2c->XferCount -= hi2c->XferSize;
;;;3599   
;;;3600           /* Process Unlocked */
;;;3601           __HAL_UNLOCK(hi2c);
;;;3602   
;;;3603           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3604                     to avoid the risk of I2C interrupt handle execution before current
;;;3605                     process unlock */
;;;3606           /* Enable ERR and NACK interrupts */
;;;3607           I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;3608   
;;;3609           /* Enable DMA Request */
;;;3610           hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;3611         }
;;;3612         else
;;;3613         {
;;;3614           /* Update I2C state */
;;;3615           hi2c->State     = HAL_I2C_STATE_READY;
;;;3616           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3617   
;;;3618           /* Update I2C error code */
;;;3619           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3620   
;;;3621           /* Process Unlocked */
;;;3622           __HAL_UNLOCK(hi2c);
;;;3623   
;;;3624           return HAL_ERROR;
;;;3625         }
;;;3626       }
;;;3627       else
;;;3628       {
;;;3629         /* Update Transfer ISR function pointer */
;;;3630         hi2c->XferISR = I2C_Master_ISR_IT;
;;;3631   
;;;3632         /* Send Slave Address */
;;;3633         /* Set NBYTES to read and generate START condition */
;;;3634         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
;;;3635   
;;;3636         /* Process Unlocked */
;;;3637         __HAL_UNLOCK(hi2c);
;;;3638   
;;;3639         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3640                   to avoid the risk of I2C interrupt handle execution before current
;;;3641                   process unlock */
;;;3642         /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;3643         /* possible to enable all of these */
;;;3644         /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;3645         I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;3646       }
;;;3647   
;;;3648       return HAL_OK;
;;;3649     }
;;;3650     else
;;;3651     {
;;;3652       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L21.28|
;;;3653     }
;;;3654   }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L21.32|
000020  f8941040          LDRB     r1,[r4,#0x40]         ;3518
000024  2901              CMP      r1,#1                 ;3518
000026  d017              BEQ      |L21.88|
000028  2101              MOVS     r1,#1                 ;3518
00002a  3424              ADDS     r4,r4,#0x24           ;3518
00002c  7721              STRB     r1,[r4,#0x1c]         ;3518
00002e  2122              MOVS     r1,#0x22              ;3520
000030  7761              STRB     r1,[r4,#0x1d]         ;3520
000032  2110              MOVS     r1,#0x10              ;3521
000034  77a1              STRB     r1,[r4,#0x1e]         ;3521
000036  2700              MOVS     r7,#0                 ;3522
000038  6227              STR      r7,[r4,#0x20]         ;3522
00003a  f8c48000          STR      r8,[r4,#0]            ;3525
00003e  80e3              STRH     r3,[r4,#6]            ;3526
000040  60a0              STR      r0,[r4,#8]            ;3527
000042  493e              LDR      r1,|L21.316|
000044  6121              STR      r1,[r4,#0x10]         ;3528
000046  88e1              LDRH     r1,[r4,#6]            ;3531
000048  3c24              SUBS     r4,r4,#0x24           ;3531
00004a  29ff              CMP      r1,#0xff              ;3531
00004c  d906              BLS      |L21.92|
00004e  21ff              MOVS     r1,#0xff              ;3533
000050  8521              STRH     r1,[r4,#0x28]         ;3533
000052  f04f7680          MOV      r6,#0x1000000         ;3534
000056  e004              B        |L21.98|
                  |L21.88|
000058  2002              MOVS     r0,#2                 ;3518
00005a  e7df              B        |L21.28|
                  |L21.92|
00005c  8d61              LDRH     r1,[r4,#0x2a]         ;3538
00005e  8521              STRH     r1,[r4,#0x28]         ;3538
000060  6ae6              LDR      r6,[r4,#0x2c]         ;3539
                  |L21.98|
000062  6b21              LDR      r1,[r4,#0x30]         ;3544
000064  2912              CMP      r1,#0x12              ;3544
000066  d106              BNE      |L21.118|
000068  28aa              CMP      r0,#0xaa              ;3544
00006a  d004              BEQ      |L21.118|
00006c  f5b04f2a          CMP      r0,#0xaa00            ;3544
000070  d001              BEQ      |L21.118|
000072  2500              MOVS     r5,#0                 ;3546
000074  e006              B        |L21.132|
                  |L21.118|
000076  4620              MOV      r0,r4                 ;3551
000078  f7fffffe          BL       I2C_ConvertOtherXferOptions
00007c  8d60              LDRH     r0,[r4,#0x2a]         ;3554
00007e  28ff              CMP      r0,#0xff              ;3554
000080  d800              BHI      |L21.132|
000082  6ae6              LDR      r6,[r4,#0x2c]         ;3556
                  |L21.132|
000084  8d20              LDRH     r0,[r4,#0x28]         ;3560
000086  b3e8              CBZ      r0,|L21.260|
000088  6be0              LDR      r0,[r4,#0x3c]         ;3562
00008a  f04f0a20          MOV      r10,#0x20             ;3580
00008e  b1d8              CBZ      r0,|L21.200|
000090  492b              LDR      r1,|L21.320|
000092  62c1              STR      r1,[r0,#0x2c]         ;3565
000094  6be1              LDR      r1,[r4,#0x3c]         ;3568
000096  482b              LDR      r0,|L21.324|
000098  6348              STR      r0,[r1,#0x34]         ;3568
00009a  6be0              LDR      r0,[r4,#0x3c]         ;3571
00009c  6307              STR      r7,[r0,#0x30]         ;3571
00009e  6be0              LDR      r0,[r4,#0x3c]         ;3572
0000a0  6387              STR      r7,[r0,#0x38]         ;3572
0000a2  6821              LDR      r1,[r4,#0]            ;3575
0000a4  8d23              LDRH     r3,[r4,#0x28]         ;3575
0000a6  3124              ADDS     r1,r1,#0x24           ;3575
0000a8  4642              MOV      r2,r8                 ;3575
0000aa  6be0              LDR      r0,[r4,#0x3c]         ;3575
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  b1a8              CBZ      r0,|L21.222|
0000b2  3440              ADDS     r4,r4,#0x40           ;3615
0000b4  f884a001          STRB     r10,[r4,#1]           ;3615
0000b8  70a7              STRB     r7,[r4,#2]            ;3616
0000ba  6860              LDR      r0,[r4,#4]            ;3619
0000bc  f0400010          ORR      r0,r0,#0x10           ;3619
0000c0  6060              STR      r0,[r4,#4]            ;3619
0000c2  7027              STRB     r7,[r4,#0]            ;3622
0000c4  2001              MOVS     r0,#1                 ;3624
0000c6  e7a9              B        |L21.28|
                  |L21.200|
0000c8  3440              ADDS     r4,r4,#0x40           ;3580
0000ca  f884a001          STRB     r10,[r4,#1]           ;3580
0000ce  70a7              STRB     r7,[r4,#2]            ;3581
0000d0  6860              LDR      r0,[r4,#4]            ;3584
0000d2  f0400080          ORR      r0,r0,#0x80           ;3584
0000d6  6060              STR      r0,[r4,#4]            ;3584
0000d8  7027              STRB     r7,[r4,#0]            ;3587
0000da  2001              MOVS     r0,#1                 ;3589
0000dc  e79e              B        |L21.28|
                  |L21.222|
0000de  9500              STR      r5,[sp,#0]            ;3595
0000e0  f8942028          LDRB     r2,[r4,#0x28]         ;3595
0000e4  4633              MOV      r3,r6                 ;3595
0000e6  4649              MOV      r1,r9                 ;3595
0000e8  4620              MOV      r0,r4                 ;3595
0000ea  f7fffffe          BL       I2C_TransferConfig
0000ee  8d60              LDRH     r0,[r4,#0x2a]         ;3598
0000f0  8d21              LDRH     r1,[r4,#0x28]         ;3598
0000f2  1a40              SUBS     r0,r0,r1              ;3598
0000f4  8560              STRH     r0,[r4,#0x2a]         ;3598
0000f6  f8847040          STRB     r7,[r4,#0x40]         ;3601
0000fa  2110              MOVS     r1,#0x10              ;3607
0000fc  4620              MOV      r0,r4                 ;3607
0000fe  f7fffffe          BL       I2C_Enable_IRQ
000102  e000              B        |L21.262|
                  |L21.260|
000104  e005              B        |L21.274|
                  |L21.262|
000106  6820              LDR      r0,[r4,#0]            ;3610
000108  6801              LDR      r1,[r0,#0]            ;3610
00010a  f4414100          ORR      r1,r1,#0x8000         ;3610
00010e  6001              STR      r1,[r0,#0]            ;3610
000110  e010              B        |L21.308|
                  |L21.274|
000112  480d              LDR      r0,|L21.328|
000114  6360              STR      r0,[r4,#0x34]         ;3630
000116  2200              MOVS     r2,#0                 ;3634
000118  f04f7300          MOV      r3,#0x2000000         ;3634
00011c  4649              MOV      r1,r9                 ;3634
00011e  4620              MOV      r0,r4                 ;3634
000120  f8cda000          STR      r10,[sp,#0]           ;3634
000124  f7fffffe          BL       I2C_TransferConfig
000128  f8847040          STRB     r7,[r4,#0x40]         ;3637
00012c  2101              MOVS     r1,#1                 ;3645
00012e  4620              MOV      r0,r4                 ;3645
000130  f7fffffe          BL       I2C_Enable_IRQ
                  |L21.308|
000134  2000              MOVS     r0,#0                 ;3648
000136  e771              B        |L21.28|
;;;3655   
                          ENDP

                  |L21.312|
                          DCD      0x80002400
                  |L21.316|
                          DCD      I2C_Master_ISR_DMA
                  |L21.320|
                          DCD      I2C_DMAMasterReceiveCplt
                  |L21.324|
                          DCD      I2C_DMAError
                  |L21.328|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Seq_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_IT PROC
;;;3419     */
;;;3420   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3421                                                   uint16_t Size, uint32_t XferOptions)
;;;3422   {
000004  4604              MOV      r4,r0
000006  9808              LDR      r0,[sp,#0x20]
000008  4688              MOV      r8,r1
;;;3423     uint32_t xfermode;
;;;3424     uint32_t xferrequest = I2C_GENERATE_START_READ;
00000a  4e24              LDR      r6,|L22.156|
;;;3425   
;;;3426     /* Check the parameters */
;;;3427     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3428   
;;;3429     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f8941041          LDRB     r1,[r4,#0x41]
000010  2920              CMP      r1,#0x20
000012  d002              BEQ      |L22.26|
;;;3430     {
;;;3431       /* Process Locked */
;;;3432       __HAL_LOCK(hi2c);
;;;3433   
;;;3434       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3435       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3436       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3437   
;;;3438       /* Prepare transfer parameters */
;;;3439       hi2c->pBuffPtr    = pData;
;;;3440       hi2c->XferCount   = Size;
;;;3441       hi2c->XferOptions = XferOptions;
;;;3442       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;3443   
;;;3444       /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
;;;3445       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;3446       {
;;;3447         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;3448         xfermode = I2C_RELOAD_MODE;
;;;3449       }
;;;3450       else
;;;3451       {
;;;3452         hi2c->XferSize = hi2c->XferCount;
;;;3453         xfermode = hi2c->XferOptions;
;;;3454       }
;;;3455   
;;;3456       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3457       /* Mean Previous state is same as current state */
;;;3458       if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
;;;3459       {
;;;3460         xferrequest = I2C_NO_STARTSTOP;
;;;3461       }
;;;3462       else
;;;3463       {
;;;3464         /* Convert OTHER_xxx XferOptions if any */
;;;3465         I2C_ConvertOtherXferOptions(hi2c);
;;;3466   
;;;3467         /* Update xfermode accordingly if no reload is necessary */
;;;3468         if (hi2c->XferCount <= MAX_NBYTE_SIZE)
;;;3469         {
;;;3470           xfermode = hi2c->XferOptions;
;;;3471         }
;;;3472       }
;;;3473   
;;;3474       /* Send Slave Address and set NBYTES to read */
;;;3475       I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
;;;3476   
;;;3477       /* Process Unlocked */
;;;3478       __HAL_UNLOCK(hi2c);
;;;3479   
;;;3480       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3481                 to avoid the risk of I2C interrupt handle execution before current
;;;3482                 process unlock */
;;;3483       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;3484   
;;;3485       return HAL_OK;
;;;3486     }
;;;3487     else
;;;3488     {
;;;3489       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L22.22|
;;;3490     }
;;;3491   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L22.26|
00001a  f8941040          LDRB     r1,[r4,#0x40]         ;3432
00001e  2901              CMP      r1,#1                 ;3432
000020  d016              BEQ      |L22.80|
000022  2101              MOVS     r1,#1                 ;3432
000024  3424              ADDS     r4,r4,#0x24           ;3432
000026  7721              STRB     r1,[r4,#0x1c]         ;3432
000028  2122              MOVS     r1,#0x22              ;3434
00002a  7761              STRB     r1,[r4,#0x1d]         ;3434
00002c  2110              MOVS     r1,#0x10              ;3435
00002e  77a1              STRB     r1,[r4,#0x1e]         ;3435
000030  2700              MOVS     r7,#0                 ;3436
000032  6227              STR      r7,[r4,#0x20]         ;3436
000034  6022              STR      r2,[r4,#0]            ;3439
000036  80e3              STRH     r3,[r4,#6]            ;3440
000038  60a0              STR      r0,[r4,#8]            ;3441
00003a  4919              LDR      r1,|L22.160|
00003c  6121              STR      r1,[r4,#0x10]         ;3442
00003e  88e1              LDRH     r1,[r4,#6]            ;3445
000040  3c24              SUBS     r4,r4,#0x24           ;3445
000042  29ff              CMP      r1,#0xff              ;3445
000044  d906              BLS      |L22.84|
000046  21ff              MOVS     r1,#0xff              ;3447
000048  8521              STRH     r1,[r4,#0x28]         ;3447
00004a  f04f7580          MOV      r5,#0x1000000         ;3448
00004e  e004              B        |L22.90|
                  |L22.80|
000050  2002              MOVS     r0,#2                 ;3432
000052  e7e0              B        |L22.22|
                  |L22.84|
000054  8d61              LDRH     r1,[r4,#0x2a]         ;3452
000056  8521              STRH     r1,[r4,#0x28]         ;3452
000058  6ae5              LDR      r5,[r4,#0x2c]         ;3453
                  |L22.90|
00005a  6b21              LDR      r1,[r4,#0x30]         ;3458
00005c  2912              CMP      r1,#0x12              ;3458
00005e  d106              BNE      |L22.110|
000060  28aa              CMP      r0,#0xaa              ;3458
000062  d004              BEQ      |L22.110|
000064  f5b04f2a          CMP      r0,#0xaa00            ;3458
000068  d001              BEQ      |L22.110|
00006a  2600              MOVS     r6,#0                 ;3460
00006c  e006              B        |L22.124|
                  |L22.110|
00006e  4620              MOV      r0,r4                 ;3465
000070  f7fffffe          BL       I2C_ConvertOtherXferOptions
000074  8d60              LDRH     r0,[r4,#0x2a]         ;3468
000076  28ff              CMP      r0,#0xff              ;3468
000078  d800              BHI      |L22.124|
00007a  6ae5              LDR      r5,[r4,#0x2c]         ;3470
                  |L22.124|
00007c  9600              STR      r6,[sp,#0]            ;3475
00007e  f8942028          LDRB     r2,[r4,#0x28]         ;3475
000082  462b              MOV      r3,r5                 ;3475
000084  4641              MOV      r1,r8                 ;3475
000086  4620              MOV      r0,r4                 ;3475
000088  f7fffffe          BL       I2C_TransferConfig
00008c  f8847040          STRB     r7,[r4,#0x40]         ;3478
000090  2102              MOVS     r1,#2                 ;3483
000092  4620              MOV      r0,r4                 ;3483
000094  f7fffffe          BL       I2C_Enable_IRQ
000098  2000              MOVS     r0,#0                 ;3485
00009a  e7bc              B        |L22.22|
;;;3492   
                          ENDP

                  |L22.156|
                          DCD      0x80002400
                  |L22.160|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_DMA PROC
;;;3256     */
;;;3257   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3258                                                     uint16_t Size, uint32_t XferOptions)
;;;3259   {
000004  4604              MOV      r4,r0
000006  980a              LDR      r0,[sp,#0x28]
000008  4689              MOV      r9,r1
00000a  4690              MOV      r8,r2
;;;3260     uint32_t xfermode;
;;;3261     uint32_t xferrequest = I2C_GENERATE_START_WRITE;
00000c  f8dfa128          LDR      r10,|L23.312|
000010  4655              MOV      r5,r10
;;;3262     HAL_StatusTypeDef dmaxferstatus;
;;;3263   
;;;3264     /* Check the parameters */
;;;3265     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3266   
;;;3267     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f8941041          LDRB     r1,[r4,#0x41]
000016  2920              CMP      r1,#0x20
000018  d002              BEQ      |L23.32|
;;;3268     {
;;;3269       /* Process Locked */
;;;3270       __HAL_LOCK(hi2c);
;;;3271   
;;;3272       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3273       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3274       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3275   
;;;3276       /* Prepare transfer parameters */
;;;3277       hi2c->pBuffPtr    = pData;
;;;3278       hi2c->XferCount   = Size;
;;;3279       hi2c->XferOptions = XferOptions;
;;;3280       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;3281   
;;;3282       /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
;;;3283       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;3284       {
;;;3285         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;3286         xfermode = I2C_RELOAD_MODE;
;;;3287       }
;;;3288       else
;;;3289       {
;;;3290         hi2c->XferSize = hi2c->XferCount;
;;;3291         xfermode = hi2c->XferOptions;
;;;3292       }
;;;3293   
;;;3294       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3295       /* Mean Previous state is same as current state */
;;;3296       if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
;;;3297       {
;;;3298         xferrequest = I2C_NO_STARTSTOP;
;;;3299       }
;;;3300       else
;;;3301       {
;;;3302         /* Convert OTHER_xxx XferOptions if any */
;;;3303         I2C_ConvertOtherXferOptions(hi2c);
;;;3304   
;;;3305         /* Update xfermode accordingly if no reload is necessary */
;;;3306         if (hi2c->XferCount <= MAX_NBYTE_SIZE)
;;;3307         {
;;;3308           xfermode = hi2c->XferOptions;
;;;3309         }
;;;3310       }
;;;3311   
;;;3312       if (hi2c->XferSize > 0U)
;;;3313       {
;;;3314         if (hi2c->hdmatx != NULL)
;;;3315         {
;;;3316           /* Set the I2C DMA transfer complete callback */
;;;3317           hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
;;;3318   
;;;3319           /* Set the DMA error callback */
;;;3320           hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3321   
;;;3322           /* Set the unused DMA callbacks to NULL */
;;;3323           hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3324           hi2c->hdmatx->XferAbortCallback = NULL;
;;;3325   
;;;3326           /* Enable the DMA channel */
;;;3327           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;3328         }
;;;3329         else
;;;3330         {
;;;3331           /* Update I2C state */
;;;3332           hi2c->State     = HAL_I2C_STATE_READY;
;;;3333           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3334   
;;;3335           /* Update I2C error code */
;;;3336           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;3337   
;;;3338           /* Process Unlocked */
;;;3339           __HAL_UNLOCK(hi2c);
;;;3340   
;;;3341           return HAL_ERROR;
;;;3342         }
;;;3343   
;;;3344         if (dmaxferstatus == HAL_OK)
;;;3345         {
;;;3346           /* Send Slave Address and set NBYTES to write */
;;;3347           I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
;;;3348   
;;;3349           /* Update XferCount value */
;;;3350           hi2c->XferCount -= hi2c->XferSize;
;;;3351   
;;;3352           /* Process Unlocked */
;;;3353           __HAL_UNLOCK(hi2c);
;;;3354   
;;;3355           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3356                     to avoid the risk of I2C interrupt handle execution before current
;;;3357                     process unlock */
;;;3358           /* Enable ERR and NACK interrupts */
;;;3359           I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;3360   
;;;3361           /* Enable DMA Request */
;;;3362           hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;3363         }
;;;3364         else
;;;3365         {
;;;3366           /* Update I2C state */
;;;3367           hi2c->State     = HAL_I2C_STATE_READY;
;;;3368           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3369   
;;;3370           /* Update I2C error code */
;;;3371           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3372   
;;;3373           /* Process Unlocked */
;;;3374           __HAL_UNLOCK(hi2c);
;;;3375   
;;;3376           return HAL_ERROR;
;;;3377         }
;;;3378       }
;;;3379       else
;;;3380       {
;;;3381         /* Update Transfer ISR function pointer */
;;;3382         hi2c->XferISR = I2C_Master_ISR_IT;
;;;3383   
;;;3384         /* Send Slave Address */
;;;3385         /* Set NBYTES to write and generate START condition */
;;;3386         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
;;;3387   
;;;3388         /* Process Unlocked */
;;;3389         __HAL_UNLOCK(hi2c);
;;;3390   
;;;3391         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3392                   to avoid the risk of I2C interrupt handle execution before current
;;;3393                   process unlock */
;;;3394         /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;3395         /* possible to enable all of these */
;;;3396         /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;3397         I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;3398       }
;;;3399   
;;;3400       return HAL_OK;
;;;3401     }
;;;3402     else
;;;3403     {
;;;3404       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L23.28|
;;;3405     }
;;;3406   }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.32|
000020  f8941040          LDRB     r1,[r4,#0x40]         ;3270
000024  2901              CMP      r1,#1                 ;3270
000026  d017              BEQ      |L23.88|
000028  2101              MOVS     r1,#1                 ;3270
00002a  3424              ADDS     r4,r4,#0x24           ;3270
00002c  7721              STRB     r1,[r4,#0x1c]         ;3270
00002e  2121              MOVS     r1,#0x21              ;3272
000030  7761              STRB     r1,[r4,#0x1d]         ;3272
000032  2110              MOVS     r1,#0x10              ;3273
000034  77a1              STRB     r1,[r4,#0x1e]         ;3273
000036  2700              MOVS     r7,#0                 ;3274
000038  6227              STR      r7,[r4,#0x20]         ;3274
00003a  f8c48000          STR      r8,[r4,#0]            ;3277
00003e  80e3              STRH     r3,[r4,#6]            ;3278
000040  60a0              STR      r0,[r4,#8]            ;3279
000042  493e              LDR      r1,|L23.316|
000044  6121              STR      r1,[r4,#0x10]         ;3280
000046  88e1              LDRH     r1,[r4,#6]            ;3283
000048  3c24              SUBS     r4,r4,#0x24           ;3283
00004a  29ff              CMP      r1,#0xff              ;3283
00004c  d906              BLS      |L23.92|
00004e  21ff              MOVS     r1,#0xff              ;3285
000050  8521              STRH     r1,[r4,#0x28]         ;3285
000052  f04f7680          MOV      r6,#0x1000000         ;3286
000056  e004              B        |L23.98|
                  |L23.88|
000058  2002              MOVS     r0,#2                 ;3270
00005a  e7df              B        |L23.28|
                  |L23.92|
00005c  8d61              LDRH     r1,[r4,#0x2a]         ;3290
00005e  8521              STRH     r1,[r4,#0x28]         ;3290
000060  6ae6              LDR      r6,[r4,#0x2c]         ;3291
                  |L23.98|
000062  6b21              LDR      r1,[r4,#0x30]         ;3296
000064  2911              CMP      r1,#0x11              ;3296
000066  d106              BNE      |L23.118|
000068  28aa              CMP      r0,#0xaa              ;3296
00006a  d004              BEQ      |L23.118|
00006c  f5b04f2a          CMP      r0,#0xaa00            ;3296
000070  d001              BEQ      |L23.118|
000072  2500              MOVS     r5,#0                 ;3298
000074  e006              B        |L23.132|
                  |L23.118|
000076  4620              MOV      r0,r4                 ;3303
000078  f7fffffe          BL       I2C_ConvertOtherXferOptions
00007c  8d60              LDRH     r0,[r4,#0x2a]         ;3306
00007e  28ff              CMP      r0,#0xff              ;3306
000080  d800              BHI      |L23.132|
000082  6ae6              LDR      r6,[r4,#0x2c]         ;3308
                  |L23.132|
000084  8d20              LDRH     r0,[r4,#0x28]         ;3312
000086  b3e8              CBZ      r0,|L23.260|
000088  6ba0              LDR      r0,[r4,#0x38]         ;3314
00008a  f04f0a20          MOV      r10,#0x20             ;3332
00008e  b1d8              CBZ      r0,|L23.200|
000090  492b              LDR      r1,|L23.320|
000092  62c1              STR      r1,[r0,#0x2c]         ;3317
000094  6ba1              LDR      r1,[r4,#0x38]         ;3320
000096  482b              LDR      r0,|L23.324|
000098  6348              STR      r0,[r1,#0x34]         ;3320
00009a  6ba0              LDR      r0,[r4,#0x38]         ;3323
00009c  6307              STR      r7,[r0,#0x30]         ;3323
00009e  6ba0              LDR      r0,[r4,#0x38]         ;3324
0000a0  6387              STR      r7,[r0,#0x38]         ;3324
0000a2  6822              LDR      r2,[r4,#0]            ;3327
0000a4  8d23              LDRH     r3,[r4,#0x28]         ;3327
0000a6  3228              ADDS     r2,r2,#0x28           ;3327
0000a8  4641              MOV      r1,r8                 ;3327
0000aa  6ba0              LDR      r0,[r4,#0x38]         ;3327
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  b1a8              CBZ      r0,|L23.222|
0000b2  3440              ADDS     r4,r4,#0x40           ;3367
0000b4  f884a001          STRB     r10,[r4,#1]           ;3367
0000b8  70a7              STRB     r7,[r4,#2]            ;3368
0000ba  6860              LDR      r0,[r4,#4]            ;3371
0000bc  f0400010          ORR      r0,r0,#0x10           ;3371
0000c0  6060              STR      r0,[r4,#4]            ;3371
0000c2  7027              STRB     r7,[r4,#0]            ;3374
0000c4  2001              MOVS     r0,#1                 ;3376
0000c6  e7a9              B        |L23.28|
                  |L23.200|
0000c8  3440              ADDS     r4,r4,#0x40           ;3332
0000ca  f884a001          STRB     r10,[r4,#1]           ;3332
0000ce  70a7              STRB     r7,[r4,#2]            ;3333
0000d0  6860              LDR      r0,[r4,#4]            ;3336
0000d2  f0400080          ORR      r0,r0,#0x80           ;3336
0000d6  6060              STR      r0,[r4,#4]            ;3336
0000d8  7027              STRB     r7,[r4,#0]            ;3339
0000da  2001              MOVS     r0,#1                 ;3341
0000dc  e79e              B        |L23.28|
                  |L23.222|
0000de  9500              STR      r5,[sp,#0]            ;3347
0000e0  f8942028          LDRB     r2,[r4,#0x28]         ;3347
0000e4  4633              MOV      r3,r6                 ;3347
0000e6  4649              MOV      r1,r9                 ;3347
0000e8  4620              MOV      r0,r4                 ;3347
0000ea  f7fffffe          BL       I2C_TransferConfig
0000ee  8d60              LDRH     r0,[r4,#0x2a]         ;3350
0000f0  8d21              LDRH     r1,[r4,#0x28]         ;3350
0000f2  1a40              SUBS     r0,r0,r1              ;3350
0000f4  8560              STRH     r0,[r4,#0x2a]         ;3350
0000f6  f8847040          STRB     r7,[r4,#0x40]         ;3353
0000fa  2110              MOVS     r1,#0x10              ;3359
0000fc  4620              MOV      r0,r4                 ;3359
0000fe  f7fffffe          BL       I2C_Enable_IRQ
000102  e000              B        |L23.262|
                  |L23.260|
000104  e005              B        |L23.274|
                  |L23.262|
000106  6820              LDR      r0,[r4,#0]            ;3362
000108  6801              LDR      r1,[r0,#0]            ;3362
00010a  f4414180          ORR      r1,r1,#0x4000         ;3362
00010e  6001              STR      r1,[r0,#0]            ;3362
000110  e010              B        |L23.308|
                  |L23.274|
000112  480d              LDR      r0,|L23.328|
000114  6360              STR      r0,[r4,#0x34]         ;3382
000116  2200              MOVS     r2,#0                 ;3386
000118  f04f7300          MOV      r3,#0x2000000         ;3386
00011c  4649              MOV      r1,r9                 ;3386
00011e  4620              MOV      r0,r4                 ;3386
000120  f8cda000          STR      r10,[sp,#0]           ;3386
000124  f7fffffe          BL       I2C_TransferConfig
000128  f8847040          STRB     r7,[r4,#0x40]         ;3389
00012c  2101              MOVS     r1,#1                 ;3397
00012e  4620              MOV      r0,r4                 ;3397
000130  f7fffffe          BL       I2C_Enable_IRQ
                  |L23.308|
000134  2000              MOVS     r0,#0                 ;3400
000136  e771              B        |L23.28|
;;;3407   
                          ENDP

                  |L23.312|
                          DCD      0x80002000
                  |L23.316|
                          DCD      I2C_Master_ISR_DMA
                  |L23.320|
                          DCD      I2C_DMAMasterTransmitCplt
                  |L23.324|
                          DCD      I2C_DMAError
                  |L23.328|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_IT PROC
;;;3171     */
;;;3172   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3173                                                    uint16_t Size, uint32_t XferOptions)
;;;3174   {
000004  4604              MOV      r4,r0
000006  9808              LDR      r0,[sp,#0x20]
000008  4688              MOV      r8,r1
;;;3175     uint32_t xfermode;
;;;3176     uint32_t xferrequest = I2C_GENERATE_START_WRITE;
00000a  4e24              LDR      r6,|L24.156|
;;;3177   
;;;3178     /* Check the parameters */
;;;3179     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3180   
;;;3181     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f8941041          LDRB     r1,[r4,#0x41]
000010  2920              CMP      r1,#0x20
000012  d002              BEQ      |L24.26|
;;;3182     {
;;;3183       /* Process Locked */
;;;3184       __HAL_LOCK(hi2c);
;;;3185   
;;;3186       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3187       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3188       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3189   
;;;3190       /* Prepare transfer parameters */
;;;3191       hi2c->pBuffPtr    = pData;
;;;3192       hi2c->XferCount   = Size;
;;;3193       hi2c->XferOptions = XferOptions;
;;;3194       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;3195   
;;;3196       /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
;;;3197       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;3198       {
;;;3199         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;3200         xfermode = I2C_RELOAD_MODE;
;;;3201       }
;;;3202       else
;;;3203       {
;;;3204         hi2c->XferSize = hi2c->XferCount;
;;;3205         xfermode = hi2c->XferOptions;
;;;3206       }
;;;3207   
;;;3208       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3209       /* Mean Previous state is same as current state */
;;;3210       if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
;;;3211       {
;;;3212         xferrequest = I2C_NO_STARTSTOP;
;;;3213       }
;;;3214       else
;;;3215       {
;;;3216         /* Convert OTHER_xxx XferOptions if any */
;;;3217         I2C_ConvertOtherXferOptions(hi2c);
;;;3218   
;;;3219         /* Update xfermode accordingly if no reload is necessary */
;;;3220         if (hi2c->XferCount <= MAX_NBYTE_SIZE)
;;;3221         {
;;;3222           xfermode = hi2c->XferOptions;
;;;3223         }
;;;3224       }
;;;3225   
;;;3226       /* Send Slave Address and set NBYTES to write */
;;;3227       I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
;;;3228   
;;;3229       /* Process Unlocked */
;;;3230       __HAL_UNLOCK(hi2c);
;;;3231   
;;;3232       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3233                 to avoid the risk of I2C interrupt handle execution before current
;;;3234                 process unlock */
;;;3235       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;3236   
;;;3237       return HAL_OK;
;;;3238     }
;;;3239     else
;;;3240     {
;;;3241       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L24.22|
;;;3242     }
;;;3243   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L24.26|
00001a  f8941040          LDRB     r1,[r4,#0x40]         ;3184
00001e  2901              CMP      r1,#1                 ;3184
000020  d016              BEQ      |L24.80|
000022  2101              MOVS     r1,#1                 ;3184
000024  3424              ADDS     r4,r4,#0x24           ;3184
000026  7721              STRB     r1,[r4,#0x1c]         ;3184
000028  2121              MOVS     r1,#0x21              ;3186
00002a  7761              STRB     r1,[r4,#0x1d]         ;3186
00002c  2110              MOVS     r1,#0x10              ;3187
00002e  77a1              STRB     r1,[r4,#0x1e]         ;3187
000030  2700              MOVS     r7,#0                 ;3188
000032  6227              STR      r7,[r4,#0x20]         ;3188
000034  6022              STR      r2,[r4,#0]            ;3191
000036  80e3              STRH     r3,[r4,#6]            ;3192
000038  60a0              STR      r0,[r4,#8]            ;3193
00003a  4919              LDR      r1,|L24.160|
00003c  6121              STR      r1,[r4,#0x10]         ;3194
00003e  88e1              LDRH     r1,[r4,#6]            ;3197
000040  3c24              SUBS     r4,r4,#0x24           ;3197
000042  29ff              CMP      r1,#0xff              ;3197
000044  d906              BLS      |L24.84|
000046  21ff              MOVS     r1,#0xff              ;3199
000048  8521              STRH     r1,[r4,#0x28]         ;3199
00004a  f04f7580          MOV      r5,#0x1000000         ;3200
00004e  e004              B        |L24.90|
                  |L24.80|
000050  2002              MOVS     r0,#2                 ;3184
000052  e7e0              B        |L24.22|
                  |L24.84|
000054  8d61              LDRH     r1,[r4,#0x2a]         ;3204
000056  8521              STRH     r1,[r4,#0x28]         ;3204
000058  6ae5              LDR      r5,[r4,#0x2c]         ;3205
                  |L24.90|
00005a  6b21              LDR      r1,[r4,#0x30]         ;3210
00005c  2911              CMP      r1,#0x11              ;3210
00005e  d106              BNE      |L24.110|
000060  28aa              CMP      r0,#0xaa              ;3210
000062  d004              BEQ      |L24.110|
000064  f5b04f2a          CMP      r0,#0xaa00            ;3210
000068  d001              BEQ      |L24.110|
00006a  2600              MOVS     r6,#0                 ;3212
00006c  e006              B        |L24.124|
                  |L24.110|
00006e  4620              MOV      r0,r4                 ;3217
000070  f7fffffe          BL       I2C_ConvertOtherXferOptions
000074  8d60              LDRH     r0,[r4,#0x2a]         ;3220
000076  28ff              CMP      r0,#0xff              ;3220
000078  d800              BHI      |L24.124|
00007a  6ae5              LDR      r5,[r4,#0x2c]         ;3222
                  |L24.124|
00007c  9600              STR      r6,[sp,#0]            ;3227
00007e  f8942028          LDRB     r2,[r4,#0x28]         ;3227
000082  462b              MOV      r3,r5                 ;3227
000084  4641              MOV      r1,r8                 ;3227
000086  4620              MOV      r0,r4                 ;3227
000088  f7fffffe          BL       I2C_TransferConfig
00008c  f8847040          STRB     r7,[r4,#0x40]         ;3230
000090  2101              MOVS     r1,#1                 ;3235
000092  4620              MOV      r0,r4                 ;3235
000094  f7fffffe          BL       I2C_Enable_IRQ
000098  2000              MOVS     r0,#0                 ;3237
00009a  e7bc              B        |L24.22|
;;;3244   
                          ENDP

                  |L24.156|
                          DCD      0x80002000
                  |L24.160|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit PROC
;;;1067     */
;;;1068   HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1069                                             uint32_t Timeout)
;;;1070   {
000004  4604              MOV      r4,r0
000006  f8dda028          LDR      r10,[sp,#0x28]
00000a  468b              MOV      r11,r1
00000c  4617              MOV      r7,r2
00000e  4698              MOV      r8,r3
;;;1071     uint32_t tickstart;
;;;1072   
;;;1073     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2820              CMP      r0,#0x20
000016  d002              BEQ      |L25.30|
;;;1074     {
;;;1075       /* Process Locked */
;;;1076       __HAL_LOCK(hi2c);
;;;1077   
;;;1078       /* Init tickstart for timeout management*/
;;;1079       tickstart = HAL_GetTick();
;;;1080   
;;;1081       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;1082       {
;;;1083         return HAL_ERROR;
;;;1084       }
;;;1085   
;;;1086       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1087       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1088       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1089   
;;;1090       /* Prepare transfer parameters */
;;;1091       hi2c->pBuffPtr  = pData;
;;;1092       hi2c->XferCount = Size;
;;;1093       hi2c->XferISR   = NULL;
;;;1094   
;;;1095       /* Send Slave Address */
;;;1096       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;1097       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1098       {
;;;1099         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1100         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
;;;1101       }
;;;1102       else
;;;1103       {
;;;1104         hi2c->XferSize = hi2c->XferCount;
;;;1105         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
;;;1106       }
;;;1107   
;;;1108       while (hi2c->XferCount > 0U)
;;;1109       {
;;;1110         /* Wait until TXIS flag is set */
;;;1111         if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1112         {
;;;1113           return HAL_ERROR;
;;;1114         }
;;;1115         /* Write data to TXDR */
;;;1116         hi2c->Instance->TXDR = *hi2c->pBuffPtr;
;;;1117   
;;;1118         /* Increment Buffer pointer */
;;;1119         hi2c->pBuffPtr++;
;;;1120   
;;;1121         hi2c->XferCount--;
;;;1122         hi2c->XferSize--;
;;;1123   
;;;1124         if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
;;;1125         {
;;;1126           /* Wait until TCR flag is set */
;;;1127           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;1128           {
;;;1129             return HAL_ERROR;
;;;1130           }
;;;1131   
;;;1132           if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1133           {
;;;1134             hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1135             I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;1136           }
;;;1137           else
;;;1138           {
;;;1139             hi2c->XferSize = hi2c->XferCount;
;;;1140             I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;1141           }
;;;1142         }
;;;1143       }
;;;1144   
;;;1145       /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;1146       /* Wait until STOPF flag is set */
;;;1147       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1148       {
;;;1149         return HAL_ERROR;
;;;1150       }
;;;1151   
;;;1152       /* Clear STOP Flag */
;;;1153       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;1154   
;;;1155       /* Clear Configuration Register 2 */
;;;1156       I2C_RESET_CR2(hi2c);
;;;1157   
;;;1158       hi2c->State = HAL_I2C_STATE_READY;
;;;1159       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;1160   
;;;1161       /* Process Unlocked */
;;;1162       __HAL_UNLOCK(hi2c);
;;;1163   
;;;1164       return HAL_OK;
;;;1165     }
;;;1166     else
;;;1167     {
;;;1168       return HAL_BUSY;
000018  2002              MOVS     r0,#2
                  |L25.26|
;;;1169     }
;;;1170   }
00001a  e8bd8ff8          POP      {r3-r11,pc}
                  |L25.30|
00001e  f8940040          LDRB     r0,[r4,#0x40]         ;1076
000022  2801              CMP      r0,#1                 ;1076
000024  d00f              BEQ      |L25.70|
000026  2001              MOVS     r0,#1                 ;1076
000028  f8840040          STRB     r0,[r4,#0x40]         ;1076
00002c  f7fffffe          BL       HAL_GetTick
000030  4606              MOV      r6,r0                 ;1079
000032  2201              MOVS     r2,#1                 ;1081
000034  2319              MOVS     r3,#0x19              ;1081
000036  03d1              LSLS     r1,r2,#15             ;1081
000038  4620              MOV      r0,r4                 ;1081
00003a  9600              STR      r6,[sp,#0]            ;1081
00003c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000040  b118              CBZ      r0,|L25.74|
000042  2001              MOVS     r0,#1                 ;1083
000044  e7e9              B        |L25.26|
                  |L25.70|
000046  2002              MOVS     r0,#2                 ;1076
000048  e7e7              B        |L25.26|
                  |L25.74|
00004a  2021              MOVS     r0,#0x21              ;1086
00004c  f8840041          STRB     r0,[r4,#0x41]         ;1086
000050  2010              MOVS     r0,#0x10              ;1087
000052  f8840042          STRB     r0,[r4,#0x42]         ;1087
000056  2500              MOVS     r5,#0                 ;1088
000058  6465              STR      r5,[r4,#0x44]         ;1088
00005a  6267              STR      r7,[r4,#0x24]         ;1091
00005c  f8a4802a          STRH     r8,[r4,#0x2a]         ;1092
000060  6365              STR      r5,[r4,#0x34]         ;1093
000062  8d61              LDRH     r1,[r4,#0x2a]         ;1097
000064  4837              LDR      r0,|L25.324|
000066  27ff              MOVS     r7,#0xff              ;1099
000068  f04f7880          MOV      r8,#0x1000000         ;1100
00006c  f04f7900          MOV      r9,#0x2000000         ;1105
000070  29ff              CMP      r1,#0xff              ;1097
000072  d908              BLS      |L25.134|
000074  463a              MOV      r2,r7                 ;1099
000076  8527              STRH     r7,[r4,#0x28]         ;1099
000078  9000              STR      r0,[sp,#0]            ;1100
00007a  4643              MOV      r3,r8                 ;1100
00007c  4659              MOV      r1,r11                ;1100
00007e  4620              MOV      r0,r4                 ;1100
000080  f7fffffe          BL       I2C_TransferConfig
000084  e043              B        |L25.270|
                  |L25.134|
000086  8d61              LDRH     r1,[r4,#0x2a]         ;1104
000088  8521              STRH     r1,[r4,#0x28]         ;1104
00008a  9000              STR      r0,[sp,#0]            ;1105
00008c  f8942028          LDRB     r2,[r4,#0x28]         ;1105
000090  464b              MOV      r3,r9                 ;1105
000092  4659              MOV      r1,r11                ;1105
000094  4620              MOV      r0,r4                 ;1105
000096  f7fffffe          BL       I2C_TransferConfig
00009a  e038              B        |L25.270|
                  |L25.156|
00009c  4632              MOV      r2,r6                 ;1111
00009e  4651              MOV      r1,r10                ;1111
0000a0  4620              MOV      r0,r4                 ;1111
0000a2  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
0000a6  b108              CBZ      r0,|L25.172|
0000a8  2001              MOVS     r0,#1                 ;1113
0000aa  e7b6              B        |L25.26|
                  |L25.172|
0000ac  6a60              LDR      r0,[r4,#0x24]         ;1116
0000ae  6821              LDR      r1,[r4,#0]            ;1116
0000b0  7800              LDRB     r0,[r0,#0]            ;1116
0000b2  6288              STR      r0,[r1,#0x28]         ;1116
0000b4  6a60              LDR      r0,[r4,#0x24]         ;1119
0000b6  1c40              ADDS     r0,r0,#1              ;1119
0000b8  6260              STR      r0,[r4,#0x24]         ;1119
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;1121
0000bc  1e40              SUBS     r0,r0,#1              ;1121
0000be  8560              STRH     r0,[r4,#0x2a]         ;1121
0000c0  8d20              LDRH     r0,[r4,#0x28]         ;1122
0000c2  1e40              SUBS     r0,r0,#1              ;1122
0000c4  b280              UXTH     r0,r0                 ;1122
0000c6  8520              STRH     r0,[r4,#0x28]         ;1122
0000c8  8d61              LDRH     r1,[r4,#0x2a]         ;1124
0000ca  b301              CBZ      r1,|L25.270|
0000cc  b9f8              CBNZ     r0,|L25.270|
0000ce  4653              MOV      r3,r10                ;1127
0000d0  2200              MOVS     r2,#0                 ;1127
0000d2  2180              MOVS     r1,#0x80              ;1127
0000d4  4620              MOV      r0,r4                 ;1127
0000d6  9600              STR      r6,[sp,#0]            ;1127
0000d8  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000dc  b108              CBZ      r0,|L25.226|
0000de  2001              MOVS     r0,#1                 ;1129
0000e0  e79b              B        |L25.26|
                  |L25.226|
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1132
0000e4  28ff              CMP      r0,#0xff              ;1132
0000e6  d908              BLS      |L25.250|
0000e8  463a              MOV      r2,r7                 ;1134
0000ea  8527              STRH     r7,[r4,#0x28]         ;1134
0000ec  4643              MOV      r3,r8                 ;1135
0000ee  4659              MOV      r1,r11                ;1135
0000f0  4620              MOV      r0,r4                 ;1135
0000f2  9500              STR      r5,[sp,#0]            ;1135
0000f4  f7fffffe          BL       I2C_TransferConfig
0000f8  e009              B        |L25.270|
                  |L25.250|
0000fa  8d60              LDRH     r0,[r4,#0x2a]         ;1139
0000fc  8520              STRH     r0,[r4,#0x28]         ;1139
0000fe  9500              STR      r5,[sp,#0]            ;1140
000100  f8942028          LDRB     r2,[r4,#0x28]         ;1140
000104  464b              MOV      r3,r9                 ;1140
000106  4659              MOV      r1,r11                ;1140
000108  4620              MOV      r0,r4                 ;1140
00010a  f7fffffe          BL       I2C_TransferConfig
                  |L25.270|
00010e  8d60              LDRH     r0,[r4,#0x2a]         ;1108
000110  2800              CMP      r0,#0                 ;1108
000112  d1c3              BNE      |L25.156|
000114  4632              MOV      r2,r6                 ;1147
000116  4651              MOV      r1,r10                ;1147
000118  4620              MOV      r0,r4                 ;1147
00011a  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00011e  b108              CBZ      r0,|L25.292|
000120  2001              MOVS     r0,#1                 ;1149
000122  e77a              B        |L25.26|
                  |L25.292|
000124  6820              LDR      r0,[r4,#0]            ;1153
000126  2120              MOVS     r1,#0x20              ;1153
000128  61c1              STR      r1,[r0,#0x1c]         ;1153
00012a  6820              LDR      r0,[r4,#0]            ;1156
00012c  6842              LDR      r2,[r0,#4]            ;1156
00012e  4b06              LDR      r3,|L25.328|
000130  401a              ANDS     r2,r2,r3              ;1156
000132  6042              STR      r2,[r0,#4]            ;1156
000134  f8841041          STRB     r1,[r4,#0x41]         ;1158
000138  f8845042          STRB     r5,[r4,#0x42]         ;1159
00013c  f8845040          STRB     r5,[r4,#0x40]         ;1162
000140  2000              MOVS     r0,#0                 ;1164
000142  e76a              B        |L25.26|
;;;1171   
                          ENDP

                  |L25.324|
                          DCD      0x80002000
                  |L25.328|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Master_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_DMA PROC
;;;1796     */
;;;1797   HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1798                                                 uint16_t Size)
;;;1799   {
000004  4689              MOV      r9,r1
000006  4604              MOV      r4,r0
000008  4611              MOV      r1,r2
;;;1800     uint32_t xfermode;
;;;1801     HAL_StatusTypeDef dmaxferstatus;
;;;1802   
;;;1803     if (hi2c->State == HAL_I2C_STATE_READY)
00000a  f8940041          LDRB     r0,[r4,#0x41]
00000e  2820              CMP      r0,#0x20
000010  d002              BEQ      |L26.24|
;;;1804     {
;;;1805       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;1806       {
;;;1807         return HAL_BUSY;
;;;1808       }
;;;1809   
;;;1810       /* Process Locked */
;;;1811       __HAL_LOCK(hi2c);
;;;1812   
;;;1813       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1814       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1815       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1816   
;;;1817       /* Prepare transfer parameters */
;;;1818       hi2c->pBuffPtr    = pData;
;;;1819       hi2c->XferCount   = Size;
;;;1820       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1821       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;1822   
;;;1823       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1824       {
;;;1825         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1826         xfermode = I2C_RELOAD_MODE;
;;;1827       }
;;;1828       else
;;;1829       {
;;;1830         hi2c->XferSize = hi2c->XferCount;
;;;1831         xfermode = I2C_AUTOEND_MODE;
;;;1832       }
;;;1833   
;;;1834       if (hi2c->XferSize > 0U)
;;;1835       {
;;;1836         if (hi2c->hdmatx != NULL)
;;;1837         {
;;;1838           /* Set the I2C DMA transfer complete callback */
;;;1839           hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
;;;1840   
;;;1841           /* Set the DMA error callback */
;;;1842           hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1843   
;;;1844           /* Set the unused DMA callbacks to NULL */
;;;1845           hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;1846           hi2c->hdmatx->XferAbortCallback = NULL;
;;;1847   
;;;1848           /* Enable the DMA channel */
;;;1849           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;1850         }
;;;1851         else
;;;1852         {
;;;1853           /* Update I2C state */
;;;1854           hi2c->State     = HAL_I2C_STATE_READY;
;;;1855           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;1856   
;;;1857           /* Update I2C error code */
;;;1858           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;1859   
;;;1860           /* Process Unlocked */
;;;1861           __HAL_UNLOCK(hi2c);
;;;1862   
;;;1863           return HAL_ERROR;
;;;1864         }
;;;1865   
;;;1866         if (dmaxferstatus == HAL_OK)
;;;1867         {
;;;1868           /* Send Slave Address */
;;;1869           /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;1870           I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
;;;1871   
;;;1872           /* Update XferCount value */
;;;1873           hi2c->XferCount -= hi2c->XferSize;
;;;1874   
;;;1875           /* Process Unlocked */
;;;1876           __HAL_UNLOCK(hi2c);
;;;1877   
;;;1878           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1879                     to avoid the risk of I2C interrupt handle execution before current
;;;1880                     process unlock */
;;;1881           /* Enable ERR and NACK interrupts */
;;;1882           I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;1883   
;;;1884           /* Enable DMA Request */
;;;1885           hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;1886         }
;;;1887         else
;;;1888         {
;;;1889           /* Update I2C state */
;;;1890           hi2c->State     = HAL_I2C_STATE_READY;
;;;1891           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;1892   
;;;1893           /* Update I2C error code */
;;;1894           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;1895   
;;;1896           /* Process Unlocked */
;;;1897           __HAL_UNLOCK(hi2c);
;;;1898   
;;;1899           return HAL_ERROR;
;;;1900         }
;;;1901       }
;;;1902       else
;;;1903       {
;;;1904         /* Update Transfer ISR function pointer */
;;;1905         hi2c->XferISR = I2C_Master_ISR_IT;
;;;1906   
;;;1907         /* Send Slave Address */
;;;1908         /* Set NBYTES to write and generate START condition */
;;;1909         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
;;;1910   
;;;1911         /* Process Unlocked */
;;;1912         __HAL_UNLOCK(hi2c);
;;;1913   
;;;1914         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1915                   to avoid the risk of I2C interrupt handle execution before current
;;;1916                   process unlock */
;;;1917         /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;1918         /* possible to enable all of these */
;;;1919         /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1920         I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;1921       }
;;;1922   
;;;1923       return HAL_OK;
;;;1924     }
;;;1925     else
;;;1926     {
;;;1927       return HAL_BUSY;
000012  2002              MOVS     r0,#2
                  |L26.20|
;;;1928     }
;;;1929   }
000014  e8bd83f8          POP      {r3-r9,pc}
                  |L26.24|
000018  6820              LDR      r0,[r4,#0]            ;1805
00001a  6980              LDR      r0,[r0,#0x18]         ;1805
00001c  43c0              MVNS     r0,r0                 ;1805
00001e  0400              LSLS     r0,r0,#16             ;1805
000020  d401              BMI      |L26.38|
000022  2002              MOVS     r0,#2                 ;1807
000024  e7f6              B        |L26.20|
                  |L26.38|
000026  f8940040          LDRB     r0,[r4,#0x40]         ;1811
00002a  2801              CMP      r0,#1                 ;1811
00002c  d018              BEQ      |L26.96|
00002e  2001              MOVS     r0,#1                 ;1811
000030  3424              ADDS     r4,r4,#0x24           ;1811
000032  7720              STRB     r0,[r4,#0x1c]         ;1811
000034  2021              MOVS     r0,#0x21              ;1813
000036  7760              STRB     r0,[r4,#0x1d]         ;1813
000038  2010              MOVS     r0,#0x10              ;1814
00003a  77a0              STRB     r0,[r4,#0x1e]         ;1814
00003c  2500              MOVS     r5,#0                 ;1815
00003e  6225              STR      r5,[r4,#0x20]         ;1815
000040  6021              STR      r1,[r4,#0]            ;1818
000042  80e3              STRH     r3,[r4,#6]            ;1819
000044  4834              LDR      r0,|L26.280|
000046  60a0              STR      r0,[r4,#8]            ;1820
000048  4834              LDR      r0,|L26.284|
00004a  6120              STR      r0,[r4,#0x10]         ;1821
00004c  88e0              LDRH     r0,[r4,#6]            ;1823
00004e  3c24              SUBS     r4,r4,#0x24           ;1823
000050  f04f7300          MOV      r3,#0x2000000         ;1831
000054  28ff              CMP      r0,#0xff              ;1823
000056  d905              BLS      |L26.100|
000058  20ff              MOVS     r0,#0xff              ;1825
00005a  8520              STRH     r0,[r4,#0x28]         ;1825
00005c  105e              ASRS     r6,r3,#1              ;1826
00005e  e004              B        |L26.106|
                  |L26.96|
000060  2002              MOVS     r0,#2                 ;1811
000062  e7d7              B        |L26.20|
                  |L26.100|
000064  8d60              LDRH     r0,[r4,#0x2a]         ;1830
000066  8520              STRH     r0,[r4,#0x28]         ;1830
000068  461e              MOV      r6,r3                 ;1831
                  |L26.106|
00006a  8d20              LDRH     r0,[r4,#0x28]         ;1834
00006c  4f2c              LDR      r7,|L26.288|
00006e  b3e8              CBZ      r0,|L26.236|
000070  6ba0              LDR      r0,[r4,#0x38]         ;1836
000072  f04f0820          MOV      r8,#0x20              ;1854
000076  b1d0              CBZ      r0,|L26.174|
000078  4a2a              LDR      r2,|L26.292|
00007a  62c2              STR      r2,[r0,#0x2c]         ;1839
00007c  6ba2              LDR      r2,[r4,#0x38]         ;1842
00007e  482a              LDR      r0,|L26.296|
000080  6350              STR      r0,[r2,#0x34]         ;1842
000082  6ba0              LDR      r0,[r4,#0x38]         ;1845
000084  6305              STR      r5,[r0,#0x30]         ;1845
000086  6ba0              LDR      r0,[r4,#0x38]         ;1846
000088  6385              STR      r5,[r0,#0x38]         ;1846
00008a  6822              LDR      r2,[r4,#0]            ;1849
00008c  8d23              LDRH     r3,[r4,#0x28]         ;1849
00008e  3228              ADDS     r2,r2,#0x28           ;1849
000090  6ba0              LDR      r0,[r4,#0x38]         ;1849
000092  f7fffffe          BL       HAL_DMA_Start_IT
000096  b1a8              CBZ      r0,|L26.196|
000098  3440              ADDS     r4,r4,#0x40           ;1890
00009a  f8848001          STRB     r8,[r4,#1]            ;1890
00009e  70a5              STRB     r5,[r4,#2]            ;1891
0000a0  6860              LDR      r0,[r4,#4]            ;1894
0000a2  f0400010          ORR      r0,r0,#0x10           ;1894
0000a6  6060              STR      r0,[r4,#4]            ;1894
0000a8  7025              STRB     r5,[r4,#0]            ;1897
0000aa  2001              MOVS     r0,#1                 ;1899
0000ac  e7b2              B        |L26.20|
                  |L26.174|
0000ae  3440              ADDS     r4,r4,#0x40           ;1854
0000b0  f8848001          STRB     r8,[r4,#1]            ;1854
0000b4  70a5              STRB     r5,[r4,#2]            ;1855
0000b6  6860              LDR      r0,[r4,#4]            ;1858
0000b8  f0400080          ORR      r0,r0,#0x80           ;1858
0000bc  6060              STR      r0,[r4,#4]            ;1858
0000be  7025              STRB     r5,[r4,#0]            ;1861
0000c0  2001              MOVS     r0,#1                 ;1863
0000c2  e7a7              B        |L26.20|
                  |L26.196|
0000c4  9700              STR      r7,[sp,#0]            ;1870
0000c6  f8942028          LDRB     r2,[r4,#0x28]         ;1870
0000ca  4633              MOV      r3,r6                 ;1870
0000cc  4649              MOV      r1,r9                 ;1870
0000ce  4620              MOV      r0,r4                 ;1870
0000d0  f7fffffe          BL       I2C_TransferConfig
0000d4  8d60              LDRH     r0,[r4,#0x2a]         ;1873
0000d6  8d21              LDRH     r1,[r4,#0x28]         ;1873
0000d8  1a40              SUBS     r0,r0,r1              ;1873
0000da  8560              STRH     r0,[r4,#0x2a]         ;1873
0000dc  f8845040          STRB     r5,[r4,#0x40]         ;1876
0000e0  2110              MOVS     r1,#0x10              ;1882
0000e2  4620              MOV      r0,r4                 ;1882
0000e4  f7fffffe          BL       I2C_Enable_IRQ
0000e8  6820              LDR      r0,[r4,#0]            ;1885
0000ea  e000              B        |L26.238|
                  |L26.236|
0000ec  e004              B        |L26.248|
                  |L26.238|
0000ee  6801              LDR      r1,[r0,#0]            ;1885
0000f0  f4414180          ORR      r1,r1,#0x4000         ;1885
0000f4  6001              STR      r1,[r0,#0]            ;1885
0000f6  e00d              B        |L26.276|
                  |L26.248|
0000f8  480c              LDR      r0,|L26.300|
0000fa  6360              STR      r0,[r4,#0x34]         ;1905
0000fc  2200              MOVS     r2,#0                 ;1909
0000fe  4649              MOV      r1,r9                 ;1909
000100  4620              MOV      r0,r4                 ;1909
000102  9700              STR      r7,[sp,#0]            ;1909
000104  f7fffffe          BL       I2C_TransferConfig
000108  f8845040          STRB     r5,[r4,#0x40]         ;1912
00010c  2101              MOVS     r1,#1                 ;1920
00010e  4620              MOV      r0,r4                 ;1920
000110  f7fffffe          BL       I2C_Enable_IRQ
                  |L26.276|
000114  2000              MOVS     r0,#0                 ;1923
000116  e77d              B        |L26.20|
;;;1930   
                          ENDP

                  |L26.280|
                          DCD      0xffff0000
                  |L26.284|
                          DCD      I2C_Master_ISR_DMA
                  |L26.288|
                          DCD      0x80002000
                  |L26.292|
                          DCD      I2C_DMAMasterTransmitCplt
                  |L26.296|
                          DCD      I2C_DMAError
                  |L26.300|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_IT PROC
;;;1559     */
;;;1560   HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
000000  b538              PUSH     {r3-r5,lr}
;;;1561                                                uint16_t Size)
;;;1562   {
000002  4604              MOV      r4,r0
;;;1563     uint32_t xfermode;
;;;1564   
;;;1565     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f8940041          LDRB     r0,[r4,#0x41]
000008  2820              CMP      r0,#0x20
00000a  d001              BEQ      |L27.16|
;;;1566     {
;;;1567       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;1568       {
;;;1569         return HAL_BUSY;
;;;1570       }
;;;1571   
;;;1572       /* Process Locked */
;;;1573       __HAL_LOCK(hi2c);
;;;1574   
;;;1575       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1576       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1577       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1578   
;;;1579       /* Prepare transfer parameters */
;;;1580       hi2c->pBuffPtr    = pData;
;;;1581       hi2c->XferCount   = Size;
;;;1582       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1583       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;1584   
;;;1585       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1586       {
;;;1587         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1588         xfermode = I2C_RELOAD_MODE;
;;;1589       }
;;;1590       else
;;;1591       {
;;;1592         hi2c->XferSize = hi2c->XferCount;
;;;1593         xfermode = I2C_AUTOEND_MODE;
;;;1594       }
;;;1595   
;;;1596       /* Send Slave Address */
;;;1597       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
;;;1598       I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
;;;1599   
;;;1600       /* Process Unlocked */
;;;1601       __HAL_UNLOCK(hi2c);
;;;1602   
;;;1603       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1604                 to avoid the risk of I2C interrupt handle execution before current
;;;1605                 process unlock */
;;;1606   
;;;1607       /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;1608       /* possible to enable all of these */
;;;1609       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1610       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;1611   
;;;1612       return HAL_OK;
;;;1613     }
;;;1614     else
;;;1615     {
;;;1616       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;1617     }
;;;1618   }
00000e  bd38              POP      {r3-r5,pc}
                  |L27.16|
000010  6820              LDR      r0,[r4,#0]            ;1567
000012  6980              LDR      r0,[r0,#0x18]         ;1567
000014  43c0              MVNS     r0,r0                 ;1567
000016  0400              LSLS     r0,r0,#16             ;1567
000018  d401              BMI      |L27.30|
00001a  2002              MOVS     r0,#2                 ;1569
00001c  bd38              POP      {r3-r5,pc}
                  |L27.30|
00001e  f8940040          LDRB     r0,[r4,#0x40]         ;1573
000022  2801              CMP      r0,#1                 ;1573
000024  d017              BEQ      |L27.86|
000026  2001              MOVS     r0,#1                 ;1573
000028  3424              ADDS     r4,r4,#0x24           ;1573
00002a  7720              STRB     r0,[r4,#0x1c]         ;1573
00002c  2021              MOVS     r0,#0x21              ;1575
00002e  7760              STRB     r0,[r4,#0x1d]         ;1575
000030  2010              MOVS     r0,#0x10              ;1576
000032  77a0              STRB     r0,[r4,#0x1e]         ;1576
000034  2500              MOVS     r5,#0                 ;1577
000036  6225              STR      r5,[r4,#0x20]         ;1577
000038  6022              STR      r2,[r4,#0]            ;1580
00003a  80e3              STRH     r3,[r4,#6]            ;1581
00003c  4810              LDR      r0,|L27.128|
00003e  60a0              STR      r0,[r4,#8]            ;1582
000040  4810              LDR      r0,|L27.132|
000042  6120              STR      r0,[r4,#0x10]         ;1583
000044  88e0              LDRH     r0,[r4,#6]            ;1585
000046  3c24              SUBS     r4,r4,#0x24           ;1585
000048  28ff              CMP      r0,#0xff              ;1585
00004a  d906              BLS      |L27.90|
00004c  20ff              MOVS     r0,#0xff              ;1587
00004e  8520              STRH     r0,[r4,#0x28]         ;1587
000050  f04f7380          MOV      r3,#0x1000000         ;1588
000054  e005              B        |L27.98|
                  |L27.86|
000056  2002              MOVS     r0,#2                 ;1573
000058  bd38              POP      {r3-r5,pc}
                  |L27.90|
00005a  8d60              LDRH     r0,[r4,#0x2a]         ;1592
00005c  8520              STRH     r0,[r4,#0x28]         ;1592
00005e  f04f7300          MOV      r3,#0x2000000         ;1593
                  |L27.98|
000062  4809              LDR      r0,|L27.136|
000064  9000              STR      r0,[sp,#0]            ;1598
000066  f8942028          LDRB     r2,[r4,#0x28]         ;1598
00006a  4620              MOV      r0,r4                 ;1598
00006c  f7fffffe          BL       I2C_TransferConfig
000070  f8845040          STRB     r5,[r4,#0x40]         ;1601
000074  2101              MOVS     r1,#1                 ;1610
000076  4620              MOV      r0,r4                 ;1610
000078  f7fffffe          BL       I2C_Enable_IRQ
00007c  2000              MOVS     r0,#0                 ;1612
00007e  bd38              POP      {r3-r5,pc}
;;;1619   
                          ENDP

                  |L27.128|
                          DCD      0xffff0000
                  |L27.132|
                          DCD      I2C_Master_ISR_IT
                  |L27.136|
                          DCD      0x80002000

                          AREA ||i.HAL_I2C_MemRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemRxCpltCallback PROC
;;;4515     */
;;;4516   __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4517   {
;;;4518     /* Prevent unused argument(s) compilation warning */
;;;4519     UNUSED(hi2c);
;;;4520   
;;;4521     /* NOTE : This function should not be modified, when the callback is needed,
;;;4522               the HAL_I2C_MemRxCpltCallback could be implemented in the user file
;;;4523      */
;;;4524   }
;;;4525   
                          ENDP


                          AREA ||i.HAL_I2C_MemTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemTxCpltCallback PROC
;;;4499     */
;;;4500   __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4501   {
;;;4502     /* Prevent unused argument(s) compilation warning */
;;;4503     UNUSED(hi2c);
;;;4504   
;;;4505     /* NOTE : This function should not be modified, when the callback is needed,
;;;4506               the HAL_I2C_MemTxCpltCallback could be implemented in the user file
;;;4507      */
;;;4508   }
;;;4509   
                          ENDP


                          AREA ||i.HAL_I2C_Mem_Read||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read PROC
;;;2427     */
;;;2428   HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2429                                      uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
;;;2430   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  e9dd9811          LDRD     r9,r8,[sp,#0x44]
00000c  9f10              LDR      r7,[sp,#0x40]
00000e  4692              MOV      r10,r2
000010  469b              MOV      r11,r3
;;;2431     uint32_t tickstart;
;;;2432   
;;;2433     /* Check the parameters */
;;;2434     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2435   
;;;2436     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f8940041          LDRB     r0,[r4,#0x41]
000016  2820              CMP      r0,#0x20
000018  d003              BEQ      |L30.34|
;;;2437     {
;;;2438       if ((pData == NULL) || (Size == 0U))
;;;2439       {
;;;2440         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2441         return  HAL_ERROR;
;;;2442       }
;;;2443   
;;;2444       /* Process Locked */
;;;2445       __HAL_LOCK(hi2c);
;;;2446   
;;;2447       /* Init tickstart for timeout management*/
;;;2448       tickstart = HAL_GetTick();
;;;2449   
;;;2450       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;2451       {
;;;2452         return HAL_ERROR;
;;;2453       }
;;;2454   
;;;2455       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2456       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2457       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2458   
;;;2459       /* Prepare transfer parameters */
;;;2460       hi2c->pBuffPtr  = pData;
;;;2461       hi2c->XferCount = Size;
;;;2462       hi2c->XferISR   = NULL;
;;;2463   
;;;2464       /* Send Slave Address and Memory Address */
;;;2465       if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2466       {
;;;2467         /* Process Unlocked */
;;;2468         __HAL_UNLOCK(hi2c);
;;;2469         return HAL_ERROR;
;;;2470       }
;;;2471   
;;;2472       /* Send Slave Address */
;;;2473       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2474       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2475       {
;;;2476         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2477         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
;;;2478       }
;;;2479       else
;;;2480       {
;;;2481         hi2c->XferSize = hi2c->XferCount;
;;;2482         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
;;;2483       }
;;;2484   
;;;2485       do
;;;2486       {
;;;2487         /* Wait until RXNE flag is set */
;;;2488         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
;;;2489         {
;;;2490           return HAL_ERROR;
;;;2491         }
;;;2492   
;;;2493         /* Read data from RXDR */
;;;2494         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
;;;2495   
;;;2496         /* Increment Buffer pointer */
;;;2497         hi2c->pBuffPtr++;
;;;2498   
;;;2499         hi2c->XferSize--;
;;;2500         hi2c->XferCount--;
;;;2501   
;;;2502         if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
;;;2503         {
;;;2504           /* Wait until TCR flag is set */
;;;2505           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;2506           {
;;;2507             return HAL_ERROR;
;;;2508           }
;;;2509   
;;;2510           if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2511           {
;;;2512             hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2513             I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;2514           }
;;;2515           else
;;;2516           {
;;;2517             hi2c->XferSize = hi2c->XferCount;
;;;2518             I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;2519           }
;;;2520         }
;;;2521       } while (hi2c->XferCount > 0U);
;;;2522   
;;;2523       /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;2524       /* Wait until STOPF flag is reset */
;;;2525       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2526       {
;;;2527         return HAL_ERROR;
;;;2528       }
;;;2529   
;;;2530       /* Clear STOP Flag */
;;;2531       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;2532   
;;;2533       /* Clear Configuration Register 2 */
;;;2534       I2C_RESET_CR2(hi2c);
;;;2535   
;;;2536       hi2c->State = HAL_I2C_STATE_READY;
;;;2537       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;2538   
;;;2539       /* Process Unlocked */
;;;2540       __HAL_UNLOCK(hi2c);
;;;2541   
;;;2542       return HAL_OK;
;;;2543     }
;;;2544     else
;;;2545     {
;;;2546       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L30.28|
;;;2547     }
;;;2548   }
00001c  b007              ADD      sp,sp,#0x1c
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L30.34|
000022  b1b7              CBZ      r7,|L30.82|
000024  f1b90f00          CMP      r9,#0                 ;2438
000028  d013              BEQ      |L30.82|
00002a  f8940040          LDRB     r0,[r4,#0x40]         ;2445
00002e  2801              CMP      r0,#1                 ;2445
000030  d014              BEQ      |L30.92|
000032  2001              MOVS     r0,#1                 ;2445
000034  f8840040          STRB     r0,[r4,#0x40]         ;2445
000038  f7fffffe          BL       HAL_GetTick
00003c  4605              MOV      r5,r0                 ;2448
00003e  2201              MOVS     r2,#1                 ;2450
000040  2319              MOVS     r3,#0x19              ;2450
000042  03d1              LSLS     r1,r2,#15             ;2450
000044  4620              MOV      r0,r4                 ;2450
000046  9500              STR      r5,[sp,#0]            ;2450
000048  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00004c  b140              CBZ      r0,|L30.96|
00004e  2001              MOVS     r0,#1                 ;2452
000050  e7e4              B        |L30.28|
                  |L30.82|
000052  f44f7000          MOV      r0,#0x200             ;2440
000056  6460              STR      r0,[r4,#0x44]         ;2440
000058  2001              MOVS     r0,#1                 ;2441
00005a  e7df              B        |L30.28|
                  |L30.92|
00005c  2002              MOVS     r0,#2                 ;2445
00005e  e7dd              B        |L30.28|
                  |L30.96|
000060  2022              MOVS     r0,#0x22              ;2455
000062  f8840041          STRB     r0,[r4,#0x41]         ;2455
000066  2040              MOVS     r0,#0x40              ;2456
000068  f8840042          STRB     r0,[r4,#0x42]         ;2456
00006c  2600              MOVS     r6,#0                 ;2457
00006e  6466              STR      r6,[r4,#0x44]         ;2457
000070  6267              STR      r7,[r4,#0x24]         ;2460
000072  f8a4902a          STRH     r9,[r4,#0x2a]         ;2461
000076  6366              STR      r6,[r4,#0x34]         ;2462
000078  e9cd8500          STRD     r8,r5,[sp,#0]         ;2465
00007c  465b              MOV      r3,r11                ;2465
00007e  4652              MOV      r2,r10                ;2465
000080  4620              MOV      r0,r4                 ;2465
000082  9904              LDR      r1,[sp,#0x10]         ;2465
000084  f7fffffe          BL       I2C_RequestMemoryRead
000088  b118              CBZ      r0,|L30.146|
00008a  f8846040          STRB     r6,[r4,#0x40]         ;2468
00008e  2001              MOVS     r0,#1                 ;2469
000090  e7c4              B        |L30.28|
                  |L30.146|
000092  8d61              LDRH     r1,[r4,#0x2a]         ;2474
000094  4838              LDR      r0,|L30.376|
000096  27ff              MOVS     r7,#0xff              ;2476
000098  f04f7980          MOV      r9,#0x1000000         ;2477
00009c  f04f7a00          MOV      r10,#0x2000000        ;2482
0000a0  29ff              CMP      r1,#0xff              ;2474
0000a2  d908              BLS      |L30.182|
0000a4  463a              MOV      r2,r7                 ;2476
0000a6  8527              STRH     r7,[r4,#0x28]         ;2476
0000a8  9000              STR      r0,[sp,#0]            ;2477
0000aa  464b              MOV      r3,r9                 ;2477
0000ac  4620              MOV      r0,r4                 ;2477
0000ae  9904              LDR      r1,[sp,#0x10]         ;2477
0000b0  f7fffffe          BL       I2C_TransferConfig
0000b4  e009              B        |L30.202|
                  |L30.182|
0000b6  8d61              LDRH     r1,[r4,#0x2a]         ;2481
0000b8  8521              STRH     r1,[r4,#0x28]         ;2481
0000ba  9000              STR      r0,[sp,#0]            ;2482
0000bc  f8942028          LDRB     r2,[r4,#0x28]         ;2482
0000c0  4653              MOV      r3,r10                ;2482
0000c2  4620              MOV      r0,r4                 ;2482
0000c4  9904              LDR      r1,[sp,#0x10]         ;2482
0000c6  f7fffffe          BL       I2C_TransferConfig
                  |L30.202|
0000ca  4643              MOV      r3,r8                 ;2488
0000cc  2200              MOVS     r2,#0                 ;2488
0000ce  2104              MOVS     r1,#4                 ;2488
0000d0  4620              MOV      r0,r4                 ;2488
0000d2  9500              STR      r5,[sp,#0]            ;2488
0000d4  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000d8  b108              CBZ      r0,|L30.222|
0000da  2001              MOVS     r0,#1                 ;2490
0000dc  e79e              B        |L30.28|
                  |L30.222|
0000de  6820              LDR      r0,[r4,#0]            ;2494
0000e0  6a40              LDR      r0,[r0,#0x24]         ;2494
0000e2  6a61              LDR      r1,[r4,#0x24]         ;2494
0000e4  7008              STRB     r0,[r1,#0]            ;2494
0000e6  6a60              LDR      r0,[r4,#0x24]         ;2497
0000e8  1c40              ADDS     r0,r0,#1              ;2497
0000ea  6260              STR      r0,[r4,#0x24]         ;2497
0000ec  8d20              LDRH     r0,[r4,#0x28]         ;2499
0000ee  1e40              SUBS     r0,r0,#1              ;2499
0000f0  b280              UXTH     r0,r0                 ;2499
0000f2  8520              STRH     r0,[r4,#0x28]         ;2499
0000f4  8d61              LDRH     r1,[r4,#0x2a]         ;2500
0000f6  1e49              SUBS     r1,r1,#1              ;2500
0000f8  8561              STRH     r1,[r4,#0x2a]         ;2500
0000fa  8d61              LDRH     r1,[r4,#0x2a]         ;2502
0000fc  b301              CBZ      r1,|L30.320|
0000fe  b9f8              CBNZ     r0,|L30.320|
000100  4643              MOV      r3,r8                 ;2505
000102  2200              MOVS     r2,#0                 ;2505
000104  2180              MOVS     r1,#0x80              ;2505
000106  4620              MOV      r0,r4                 ;2505
000108  9500              STR      r5,[sp,#0]            ;2505
00010a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00010e  b108              CBZ      r0,|L30.276|
000110  2001              MOVS     r0,#1                 ;2507
000112  e783              B        |L30.28|
                  |L30.276|
000114  8d60              LDRH     r0,[r4,#0x2a]         ;2510
000116  28ff              CMP      r0,#0xff              ;2510
000118  d908              BLS      |L30.300|
00011a  463a              MOV      r2,r7                 ;2512
00011c  8527              STRH     r7,[r4,#0x28]         ;2512
00011e  464b              MOV      r3,r9                 ;2513
000120  9600              STR      r6,[sp,#0]            ;2513
000122  4620              MOV      r0,r4                 ;2513
000124  9904              LDR      r1,[sp,#0x10]         ;2513
000126  f7fffffe          BL       I2C_TransferConfig
00012a  e009              B        |L30.320|
                  |L30.300|
00012c  8d60              LDRH     r0,[r4,#0x2a]         ;2517
00012e  8520              STRH     r0,[r4,#0x28]         ;2517
000130  9600              STR      r6,[sp,#0]            ;2518
000132  f8942028          LDRB     r2,[r4,#0x28]         ;2518
000136  4653              MOV      r3,r10                ;2518
000138  4620              MOV      r0,r4                 ;2518
00013a  9904              LDR      r1,[sp,#0x10]         ;2518
00013c  f7fffffe          BL       I2C_TransferConfig
                  |L30.320|
000140  8d60              LDRH     r0,[r4,#0x2a]         ;2521
000142  2800              CMP      r0,#0                 ;2521
000144  d1c1              BNE      |L30.202|
000146  462a              MOV      r2,r5                 ;2525
000148  4641              MOV      r1,r8                 ;2525
00014a  4620              MOV      r0,r4                 ;2525
00014c  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000150  b108              CBZ      r0,|L30.342|
000152  2001              MOVS     r0,#1                 ;2527
000154  e762              B        |L30.28|
                  |L30.342|
000156  6820              LDR      r0,[r4,#0]            ;2531
000158  2120              MOVS     r1,#0x20              ;2531
00015a  61c1              STR      r1,[r0,#0x1c]         ;2531
00015c  6820              LDR      r0,[r4,#0]            ;2534
00015e  6842              LDR      r2,[r0,#4]            ;2534
000160  4b06              LDR      r3,|L30.380|
000162  401a              ANDS     r2,r2,r3              ;2534
000164  6042              STR      r2,[r0,#4]            ;2534
000166  f8841041          STRB     r1,[r4,#0x41]         ;2536
00016a  f8846042          STRB     r6,[r4,#0x42]         ;2537
00016e  f8846040          STRB     r6,[r4,#0x40]         ;2540
000172  2000              MOVS     r0,#0                 ;2542
000174  e752              B        |L30.28|
;;;2549   /**
                          ENDP

000176  0000              DCW      0x0000
                  |L30.376|
                          DCD      0x80002400
                  |L30.380|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Mem_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_DMA PROC
;;;2888     */
;;;2889   HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2890                                          uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
;;;2891   {
000004  4604              MOV      r4,r0
000006  e9dd670a          LDRD     r6,r7,[sp,#0x28]
00000a  4689              MOV      r9,r1
00000c  4690              MOV      r8,r2
00000e  469a              MOV      r10,r3
;;;2892     uint32_t tickstart;
;;;2893     uint32_t xfermode;
;;;2894     HAL_StatusTypeDef dmaxferstatus;
;;;2895   
;;;2896     /* Check the parameters */
;;;2897     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2898   
;;;2899     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2820              CMP      r0,#0x20
000016  d002              BEQ      |L31.30|
;;;2900     {
;;;2901       if ((pData == NULL) || (Size == 0U))
;;;2902       {
;;;2903         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2904         return  HAL_ERROR;
;;;2905       }
;;;2906   
;;;2907       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2908       {
;;;2909         return HAL_BUSY;
;;;2910       }
;;;2911   
;;;2912       /* Process Locked */
;;;2913       __HAL_LOCK(hi2c);
;;;2914   
;;;2915       /* Init tickstart for timeout management*/
;;;2916       tickstart = HAL_GetTick();
;;;2917   
;;;2918       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;2919       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2920       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2921   
;;;2922       /* Prepare transfer parameters */
;;;2923       hi2c->pBuffPtr    = pData;
;;;2924       hi2c->XferCount   = Size;
;;;2925       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2926       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;2927   
;;;2928       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2929       {
;;;2930         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2931         xfermode = I2C_RELOAD_MODE;
;;;2932       }
;;;2933       else
;;;2934       {
;;;2935         hi2c->XferSize = hi2c->XferCount;
;;;2936         xfermode = I2C_AUTOEND_MODE;
;;;2937       }
;;;2938   
;;;2939       /* Send Slave Address and Memory Address */
;;;2940       if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2941       {
;;;2942         /* Process Unlocked */
;;;2943         __HAL_UNLOCK(hi2c);
;;;2944         return HAL_ERROR;
;;;2945       }
;;;2946   
;;;2947       if (hi2c->hdmarx != NULL)
;;;2948       {
;;;2949         /* Set the I2C DMA transfer complete callback */
;;;2950         hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
;;;2951   
;;;2952         /* Set the DMA error callback */
;;;2953         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2954   
;;;2955         /* Set the unused DMA callbacks to NULL */
;;;2956         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2957         hi2c->hdmarx->XferAbortCallback = NULL;
;;;2958   
;;;2959         /* Enable the DMA channel */
;;;2960         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;2961       }
;;;2962       else
;;;2963       {
;;;2964         /* Update I2C state */
;;;2965         hi2c->State     = HAL_I2C_STATE_READY;
;;;2966         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2967   
;;;2968         /* Update I2C error code */
;;;2969         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2970   
;;;2971         /* Process Unlocked */
;;;2972         __HAL_UNLOCK(hi2c);
;;;2973   
;;;2974         return HAL_ERROR;
;;;2975       }
;;;2976   
;;;2977       if (dmaxferstatus == HAL_OK)
;;;2978       {
;;;2979         /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2980         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;2981   
;;;2982         /* Update XferCount value */
;;;2983         hi2c->XferCount -= hi2c->XferSize;
;;;2984   
;;;2985         /* Process Unlocked */
;;;2986         __HAL_UNLOCK(hi2c);
;;;2987   
;;;2988         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2989                   to avoid the risk of I2C interrupt handle execution before current
;;;2990                   process unlock */
;;;2991         /* Enable ERR and NACK interrupts */
;;;2992         I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;2993   
;;;2994         /* Enable DMA Request */
;;;2995         hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;2996       }
;;;2997       else
;;;2998       {
;;;2999         /* Update I2C state */
;;;3000         hi2c->State     = HAL_I2C_STATE_READY;
;;;3001         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3002   
;;;3003         /* Update I2C error code */
;;;3004         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3005   
;;;3006         /* Process Unlocked */
;;;3007         __HAL_UNLOCK(hi2c);
;;;3008   
;;;3009         return HAL_ERROR;
;;;3010       }
;;;3011   
;;;3012       return HAL_OK;
;;;3013     }
;;;3014     else
;;;3015     {
;;;3016       return HAL_BUSY;
000018  2002              MOVS     r0,#2
                  |L31.26|
;;;3017     }
;;;3018   }
00001a  e8bd87fc          POP      {r2-r10,pc}
                  |L31.30|
00001e  b13e              CBZ      r6,|L31.48|
000020  b137              CBZ      r7,|L31.48|
000022  6820              LDR      r0,[r4,#0]            ;2907
000024  6980              LDR      r0,[r0,#0x18]         ;2907
000026  43c0              MVNS     r0,r0                 ;2907
000028  0400              LSLS     r0,r0,#16             ;2907
00002a  d406              BMI      |L31.58|
00002c  2002              MOVS     r0,#2                 ;2909
00002e  e7f4              B        |L31.26|
                  |L31.48|
000030  f44f7000          MOV      r0,#0x200             ;2903
000034  6460              STR      r0,[r4,#0x44]         ;2903
000036  2001              MOVS     r0,#1                 ;2904
000038  e7ef              B        |L31.26|
                  |L31.58|
00003a  f8940040          LDRB     r0,[r4,#0x40]         ;2913
00003e  2801              CMP      r0,#1                 ;2913
000040  d019              BEQ      |L31.118|
000042  3424              ADDS     r4,r4,#0x24           ;2913
000044  2001              MOVS     r0,#1                 ;2913
000046  7720              STRB     r0,[r4,#0x1c]         ;2913
000048  f7fffffe          BL       HAL_GetTick
00004c  2122              MOVS     r1,#0x22              ;2918
00004e  7761              STRB     r1,[r4,#0x1d]         ;2918
000050  2140              MOVS     r1,#0x40              ;2919
000052  77a1              STRB     r1,[r4,#0x1e]         ;2919
000054  2500              MOVS     r5,#0                 ;2920
000056  6225              STR      r5,[r4,#0x20]         ;2920
000058  6026              STR      r6,[r4,#0]            ;2923
00005a  80e7              STRH     r7,[r4,#6]            ;2924
00005c  4932              LDR      r1,|L31.296|
00005e  60a1              STR      r1,[r4,#8]            ;2925
000060  4932              LDR      r1,|L31.300|
000062  6121              STR      r1,[r4,#0x10]         ;2926
000064  88e1              LDRH     r1,[r4,#6]            ;2928
000066  3c24              SUBS     r4,r4,#0x24           ;2928
000068  29ff              CMP      r1,#0xff              ;2928
00006a  d906              BLS      |L31.122|
00006c  21ff              MOVS     r1,#0xff              ;2930
00006e  8521              STRH     r1,[r4,#0x28]         ;2930
000070  f04f7780          MOV      r7,#0x1000000         ;2931
000074  e005              B        |L31.130|
                  |L31.118|
000076  2002              MOVS     r0,#2                 ;2913
000078  e7cf              B        |L31.26|
                  |L31.122|
00007a  8d61              LDRH     r1,[r4,#0x2a]         ;2935
00007c  8521              STRH     r1,[r4,#0x28]         ;2935
00007e  f04f7700          MOV      r7,#0x2000000         ;2936
                  |L31.130|
000082  2119              MOVS     r1,#0x19              ;2940
000084  e9cd1000          STRD     r1,r0,[sp,#0]         ;2940
000088  4653              MOV      r3,r10                ;2940
00008a  4642              MOV      r2,r8                 ;2940
00008c  4649              MOV      r1,r9                 ;2940
00008e  4620              MOV      r0,r4                 ;2940
000090  f7fffffe          BL       I2C_RequestMemoryRead
000094  b118              CBZ      r0,|L31.158|
000096  f8845040          STRB     r5,[r4,#0x40]         ;2943
00009a  2001              MOVS     r0,#1                 ;2944
00009c  e7bd              B        |L31.26|
                  |L31.158|
00009e  6be0              LDR      r0,[r4,#0x3c]         ;2947
0000a0  f04f0820          MOV      r8,#0x20              ;2965
0000a4  b1d8              CBZ      r0,|L31.222|
0000a6  4922              LDR      r1,|L31.304|
0000a8  62c1              STR      r1,[r0,#0x2c]         ;2950
0000aa  6be1              LDR      r1,[r4,#0x3c]         ;2953
0000ac  4821              LDR      r0,|L31.308|
0000ae  6348              STR      r0,[r1,#0x34]         ;2953
0000b0  6be0              LDR      r0,[r4,#0x3c]         ;2956
0000b2  6305              STR      r5,[r0,#0x30]         ;2956
0000b4  6be0              LDR      r0,[r4,#0x3c]         ;2957
0000b6  6385              STR      r5,[r0,#0x38]         ;2957
0000b8  6821              LDR      r1,[r4,#0]            ;2960
0000ba  8d23              LDRH     r3,[r4,#0x28]         ;2960
0000bc  3124              ADDS     r1,r1,#0x24           ;2960
0000be  4632              MOV      r2,r6                 ;2960
0000c0  6be0              LDR      r0,[r4,#0x3c]         ;2960
0000c2  f7fffffe          BL       HAL_DMA_Start_IT
0000c6  b1a8              CBZ      r0,|L31.244|
0000c8  3440              ADDS     r4,r4,#0x40           ;3000
0000ca  f8848001          STRB     r8,[r4,#1]            ;3000
0000ce  70a5              STRB     r5,[r4,#2]            ;3001
0000d0  6860              LDR      r0,[r4,#4]            ;3004
0000d2  f0400010          ORR      r0,r0,#0x10           ;3004
0000d6  6060              STR      r0,[r4,#4]            ;3004
0000d8  7025              STRB     r5,[r4,#0]            ;3007
0000da  2001              MOVS     r0,#1                 ;3009
0000dc  e79d              B        |L31.26|
                  |L31.222|
0000de  3440              ADDS     r4,r4,#0x40           ;2965
0000e0  f8848001          STRB     r8,[r4,#1]            ;2965
0000e4  70a5              STRB     r5,[r4,#2]            ;2966
0000e6  6860              LDR      r0,[r4,#4]            ;2969
0000e8  f0400080          ORR      r0,r0,#0x80           ;2969
0000ec  6060              STR      r0,[r4,#4]            ;2969
0000ee  7025              STRB     r5,[r4,#0]            ;2972
0000f0  2001              MOVS     r0,#1                 ;2974
0000f2  e792              B        |L31.26|
                  |L31.244|
0000f4  4810              LDR      r0,|L31.312|
0000f6  9000              STR      r0,[sp,#0]            ;2980
0000f8  f8942028          LDRB     r2,[r4,#0x28]         ;2980
0000fc  463b              MOV      r3,r7                 ;2980
0000fe  4649              MOV      r1,r9                 ;2980
000100  4620              MOV      r0,r4                 ;2980
000102  f7fffffe          BL       I2C_TransferConfig
000106  8d60              LDRH     r0,[r4,#0x2a]         ;2983
000108  8d21              LDRH     r1,[r4,#0x28]         ;2983
00010a  1a40              SUBS     r0,r0,r1              ;2983
00010c  8560              STRH     r0,[r4,#0x2a]         ;2983
00010e  f8845040          STRB     r5,[r4,#0x40]         ;2986
000112  2110              MOVS     r1,#0x10              ;2992
000114  4620              MOV      r0,r4                 ;2992
000116  f7fffffe          BL       I2C_Enable_IRQ
00011a  6820              LDR      r0,[r4,#0]            ;2995
00011c  6801              LDR      r1,[r0,#0]            ;2995
00011e  f4414100          ORR      r1,r1,#0x8000         ;2995
000122  6001              STR      r1,[r0,#0]            ;2995
000124  2000              MOVS     r0,#0                 ;3012
000126  e778              B        |L31.26|
;;;3019   
                          ENDP

                  |L31.296|
                          DCD      0xffff0000
                  |L31.300|
                          DCD      I2C_Master_ISR_DMA
                  |L31.304|
                          DCD      I2C_DMAMasterReceiveCplt
                  |L31.308|
                          DCD      I2C_DMAError
                  |L31.312|
                          DCD      0x80002400

                          AREA ||i.HAL_I2C_Mem_Read_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_IT PROC
;;;2652     */
;;;2653   HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2654                                         uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
;;;2655   {
000004  4604              MOV      r4,r0
000006  e9dd6a0a          LDRD     r6,r10,[sp,#0x28]
00000a  460f              MOV      r7,r1
00000c  4690              MOV      r8,r2
00000e  4699              MOV      r9,r3
;;;2656     uint32_t tickstart;
;;;2657     uint32_t xfermode;
;;;2658   
;;;2659     /* Check the parameters */
;;;2660     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2661   
;;;2662     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2820              CMP      r0,#0x20
000016  d002              BEQ      |L32.30|
;;;2663     {
;;;2664       if ((pData == NULL) || (Size == 0U))
;;;2665       {
;;;2666         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2667         return  HAL_ERROR;
;;;2668       }
;;;2669   
;;;2670       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2671       {
;;;2672         return HAL_BUSY;
;;;2673       }
;;;2674   
;;;2675       /* Process Locked */
;;;2676       __HAL_LOCK(hi2c);
;;;2677   
;;;2678       /* Init tickstart for timeout management*/
;;;2679       tickstart = HAL_GetTick();
;;;2680   
;;;2681       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;2682       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2683       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2684   
;;;2685       /* Prepare transfer parameters */
;;;2686       hi2c->pBuffPtr    = pData;
;;;2687       hi2c->XferCount   = Size;
;;;2688       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2689       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;2690   
;;;2691       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2692       {
;;;2693         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2694         xfermode = I2C_RELOAD_MODE;
;;;2695       }
;;;2696       else
;;;2697       {
;;;2698         hi2c->XferSize = hi2c->XferCount;
;;;2699         xfermode = I2C_AUTOEND_MODE;
;;;2700       }
;;;2701   
;;;2702       /* Send Slave Address and Memory Address */
;;;2703       if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2704       {
;;;2705         /* Process Unlocked */
;;;2706         __HAL_UNLOCK(hi2c);
;;;2707         return HAL_ERROR;
;;;2708       }
;;;2709   
;;;2710       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2711       I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;2712   
;;;2713       /* Process Unlocked */
;;;2714       __HAL_UNLOCK(hi2c);
;;;2715   
;;;2716       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2717                 to avoid the risk of I2C interrupt handle execution before current
;;;2718                 process unlock */
;;;2719   
;;;2720       /* Enable ERR, TC, STOP, NACK, RXI interrupt */
;;;2721       /* possible to enable all of these */
;;;2722       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;2723       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;2724   
;;;2725       return HAL_OK;
;;;2726     }
;;;2727     else
;;;2728     {
;;;2729       return HAL_BUSY;
000018  2002              MOVS     r0,#2
                  |L32.26|
;;;2730     }
;;;2731   }
00001a  e8bd87fc          POP      {r2-r10,pc}
                  |L32.30|
00001e  b14e              CBZ      r6,|L32.52|
000020  f1ba0f00          CMP      r10,#0                ;2664
000024  d006              BEQ      |L32.52|
000026  6820              LDR      r0,[r4,#0]            ;2670
000028  6980              LDR      r0,[r0,#0x18]         ;2670
00002a  43c0              MVNS     r0,r0                 ;2670
00002c  0400              LSLS     r0,r0,#16             ;2670
00002e  d406              BMI      |L32.62|
000030  2002              MOVS     r0,#2                 ;2672
000032  e7f2              B        |L32.26|
                  |L32.52|
000034  f44f7000          MOV      r0,#0x200             ;2666
000038  6460              STR      r0,[r4,#0x44]         ;2666
00003a  2001              MOVS     r0,#1                 ;2667
00003c  e7ed              B        |L32.26|
                  |L32.62|
00003e  f8940040          LDRB     r0,[r4,#0x40]         ;2676
000042  2801              CMP      r0,#1                 ;2676
000044  d01a              BEQ      |L32.124|
000046  3424              ADDS     r4,r4,#0x24           ;2676
000048  2001              MOVS     r0,#1                 ;2676
00004a  7720              STRB     r0,[r4,#0x1c]         ;2676
00004c  f7fffffe          BL       HAL_GetTick
000050  2122              MOVS     r1,#0x22              ;2681
000052  7761              STRB     r1,[r4,#0x1d]         ;2681
000054  2140              MOVS     r1,#0x40              ;2682
000056  77a1              STRB     r1,[r4,#0x1e]         ;2682
000058  2500              MOVS     r5,#0                 ;2683
00005a  6225              STR      r5,[r4,#0x20]         ;2683
00005c  6026              STR      r6,[r4,#0]            ;2686
00005e  f8a4a006          STRH     r10,[r4,#6]           ;2687
000062  4919              LDR      r1,|L32.200|
000064  60a1              STR      r1,[r4,#8]            ;2688
000066  4919              LDR      r1,|L32.204|
000068  6121              STR      r1,[r4,#0x10]         ;2689
00006a  88e1              LDRH     r1,[r4,#6]            ;2691
00006c  3c24              SUBS     r4,r4,#0x24           ;2691
00006e  29ff              CMP      r1,#0xff              ;2691
000070  d906              BLS      |L32.128|
000072  21ff              MOVS     r1,#0xff              ;2693
000074  8521              STRH     r1,[r4,#0x28]         ;2693
000076  f04f7680          MOV      r6,#0x1000000         ;2694
00007a  e005              B        |L32.136|
                  |L32.124|
00007c  2002              MOVS     r0,#2                 ;2676
00007e  e7cc              B        |L32.26|
                  |L32.128|
000080  8d61              LDRH     r1,[r4,#0x2a]         ;2698
000082  8521              STRH     r1,[r4,#0x28]         ;2698
000084  f04f7600          MOV      r6,#0x2000000         ;2699
                  |L32.136|
000088  2119              MOVS     r1,#0x19              ;2703
00008a  e9cd1000          STRD     r1,r0,[sp,#0]         ;2703
00008e  464b              MOV      r3,r9                 ;2703
000090  4642              MOV      r2,r8                 ;2703
000092  4639              MOV      r1,r7                 ;2703
000094  4620              MOV      r0,r4                 ;2703
000096  f7fffffe          BL       I2C_RequestMemoryRead
00009a  b118              CBZ      r0,|L32.164|
00009c  f8845040          STRB     r5,[r4,#0x40]         ;2706
0000a0  2001              MOVS     r0,#1                 ;2707
0000a2  e7ba              B        |L32.26|
                  |L32.164|
0000a4  480a              LDR      r0,|L32.208|
0000a6  9000              STR      r0,[sp,#0]            ;2711
0000a8  f8942028          LDRB     r2,[r4,#0x28]         ;2711
0000ac  4633              MOV      r3,r6                 ;2711
0000ae  4639              MOV      r1,r7                 ;2711
0000b0  4620              MOV      r0,r4                 ;2711
0000b2  f7fffffe          BL       I2C_TransferConfig
0000b6  f8845040          STRB     r5,[r4,#0x40]         ;2714
0000ba  2102              MOVS     r1,#2                 ;2723
0000bc  4620              MOV      r0,r4                 ;2723
0000be  f7fffffe          BL       I2C_Enable_IRQ
0000c2  2000              MOVS     r0,#0                 ;2725
0000c4  e7a9              B        |L32.26|
;;;2732   /**
                          ENDP

0000c6  0000              DCW      0x0000
                  |L32.200|
                          DCD      0xffff0000
                  |L32.204|
                          DCD      I2C_Master_ISR_IT
                  |L32.208|
                          DCD      0x80002400

                          AREA ||i.HAL_I2C_Mem_Write||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write PROC
;;;2292     */
;;;2293   HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2294                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
;;;2295   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  e9dd9811          LDRD     r9,r8,[sp,#0x44]
00000c  9f10              LDR      r7,[sp,#0x40]
00000e  4692              MOV      r10,r2
000010  469b              MOV      r11,r3
;;;2296     uint32_t tickstart;
;;;2297   
;;;2298     /* Check the parameters */
;;;2299     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2300   
;;;2301     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f8940041          LDRB     r0,[r4,#0x41]
000016  2820              CMP      r0,#0x20
000018  d003              BEQ      |L33.34|
;;;2302     {
;;;2303       if ((pData == NULL) || (Size == 0U))
;;;2304       {
;;;2305         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2306         return  HAL_ERROR;
;;;2307       }
;;;2308   
;;;2309       /* Process Locked */
;;;2310       __HAL_LOCK(hi2c);
;;;2311   
;;;2312       /* Init tickstart for timeout management*/
;;;2313       tickstart = HAL_GetTick();
;;;2314   
;;;2315       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;2316       {
;;;2317         return HAL_ERROR;
;;;2318       }
;;;2319   
;;;2320       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2321       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2322       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2323   
;;;2324       /* Prepare transfer parameters */
;;;2325       hi2c->pBuffPtr  = pData;
;;;2326       hi2c->XferCount = Size;
;;;2327       hi2c->XferISR   = NULL;
;;;2328   
;;;2329       /* Send Slave Address and Memory Address */
;;;2330       if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2331       {
;;;2332         /* Process Unlocked */
;;;2333         __HAL_UNLOCK(hi2c);
;;;2334         return HAL_ERROR;
;;;2335       }
;;;2336   
;;;2337       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
;;;2338       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2339       {
;;;2340         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2341         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;2342       }
;;;2343       else
;;;2344       {
;;;2345         hi2c->XferSize = hi2c->XferCount;
;;;2346         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;2347       }
;;;2348   
;;;2349       do
;;;2350       {
;;;2351         /* Wait until TXIS flag is set */
;;;2352         if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2353         {
;;;2354           return HAL_ERROR;
;;;2355         }
;;;2356   
;;;2357         /* Write data to TXDR */
;;;2358         hi2c->Instance->TXDR = *hi2c->pBuffPtr;
;;;2359   
;;;2360         /* Increment Buffer pointer */
;;;2361         hi2c->pBuffPtr++;
;;;2362   
;;;2363         hi2c->XferCount--;
;;;2364         hi2c->XferSize--;
;;;2365   
;;;2366         if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
;;;2367         {
;;;2368           /* Wait until TCR flag is set */
;;;2369           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;2370           {
;;;2371             return HAL_ERROR;
;;;2372           }
;;;2373   
;;;2374           if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2375           {
;;;2376             hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2377             I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;2378           }
;;;2379           else
;;;2380           {
;;;2381             hi2c->XferSize = hi2c->XferCount;
;;;2382             I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;2383           }
;;;2384         }
;;;2385   
;;;2386       } while (hi2c->XferCount > 0U);
;;;2387   
;;;2388       /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;2389       /* Wait until STOPF flag is reset */
;;;2390       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2391       {
;;;2392         return HAL_ERROR;
;;;2393       }
;;;2394   
;;;2395       /* Clear STOP Flag */
;;;2396       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;2397   
;;;2398       /* Clear Configuration Register 2 */
;;;2399       I2C_RESET_CR2(hi2c);
;;;2400   
;;;2401       hi2c->State = HAL_I2C_STATE_READY;
;;;2402       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;2403   
;;;2404       /* Process Unlocked */
;;;2405       __HAL_UNLOCK(hi2c);
;;;2406   
;;;2407       return HAL_OK;
;;;2408     }
;;;2409     else
;;;2410     {
;;;2411       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L33.28|
;;;2412     }
;;;2413   }
00001c  b007              ADD      sp,sp,#0x1c
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L33.34|
000022  b1b7              CBZ      r7,|L33.82|
000024  f1b90f00          CMP      r9,#0                 ;2303
000028  d013              BEQ      |L33.82|
00002a  f8940040          LDRB     r0,[r4,#0x40]         ;2310
00002e  2801              CMP      r0,#1                 ;2310
000030  d014              BEQ      |L33.92|
000032  2001              MOVS     r0,#1                 ;2310
000034  f8840040          STRB     r0,[r4,#0x40]         ;2310
000038  f7fffffe          BL       HAL_GetTick
00003c  4606              MOV      r6,r0                 ;2313
00003e  2201              MOVS     r2,#1                 ;2315
000040  2319              MOVS     r3,#0x19              ;2315
000042  03d1              LSLS     r1,r2,#15             ;2315
000044  4620              MOV      r0,r4                 ;2315
000046  9600              STR      r6,[sp,#0]            ;2315
000048  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00004c  b140              CBZ      r0,|L33.96|
00004e  2001              MOVS     r0,#1                 ;2317
000050  e7e4              B        |L33.28|
                  |L33.82|
000052  f44f7000          MOV      r0,#0x200             ;2305
000056  6460              STR      r0,[r4,#0x44]         ;2305
000058  2001              MOVS     r0,#1                 ;2306
00005a  e7df              B        |L33.28|
                  |L33.92|
00005c  2002              MOVS     r0,#2                 ;2310
00005e  e7dd              B        |L33.28|
                  |L33.96|
000060  2021              MOVS     r0,#0x21              ;2320
000062  f8840041          STRB     r0,[r4,#0x41]         ;2320
000066  2040              MOVS     r0,#0x40              ;2321
000068  f8840042          STRB     r0,[r4,#0x42]         ;2321
00006c  2500              MOVS     r5,#0                 ;2322
00006e  6465              STR      r5,[r4,#0x44]         ;2322
000070  6267              STR      r7,[r4,#0x24]         ;2325
000072  f8a4902a          STRH     r9,[r4,#0x2a]         ;2326
000076  6365              STR      r5,[r4,#0x34]         ;2327
000078  e9cd8600          STRD     r8,r6,[sp,#0]         ;2330
00007c  465b              MOV      r3,r11                ;2330
00007e  4652              MOV      r2,r10                ;2330
000080  4620              MOV      r0,r4                 ;2330
000082  9904              LDR      r1,[sp,#0x10]         ;2330
000084  f7fffffe          BL       I2C_RequestMemoryWrite
000088  b118              CBZ      r0,|L33.146|
00008a  f8845040          STRB     r5,[r4,#0x40]         ;2333
00008e  2001              MOVS     r0,#1                 ;2334
000090  e7c4              B        |L33.28|
                  |L33.146|
000092  8d60              LDRH     r0,[r4,#0x2a]         ;2338
000094  27ff              MOVS     r7,#0xff              ;2340
000096  f04f7980          MOV      r9,#0x1000000         ;2341
00009a  f04f7a00          MOV      r10,#0x2000000        ;2346
00009e  28ff              CMP      r0,#0xff              ;2338
0000a0  d908              BLS      |L33.180|
0000a2  463a              MOV      r2,r7                 ;2340
0000a4  8527              STRH     r7,[r4,#0x28]         ;2340
0000a6  464b              MOV      r3,r9                 ;2341
0000a8  9500              STR      r5,[sp,#0]            ;2341
0000aa  4620              MOV      r0,r4                 ;2341
0000ac  9904              LDR      r1,[sp,#0x10]         ;2341
0000ae  f7fffffe          BL       I2C_TransferConfig
0000b2  e009              B        |L33.200|
                  |L33.180|
0000b4  8d60              LDRH     r0,[r4,#0x2a]         ;2345
0000b6  8520              STRH     r0,[r4,#0x28]         ;2345
0000b8  9500              STR      r5,[sp,#0]            ;2346
0000ba  f8942028          LDRB     r2,[r4,#0x28]         ;2346
0000be  4653              MOV      r3,r10                ;2346
0000c0  4620              MOV      r0,r4                 ;2346
0000c2  9904              LDR      r1,[sp,#0x10]         ;2346
0000c4  f7fffffe          BL       I2C_TransferConfig
                  |L33.200|
0000c8  4632              MOV      r2,r6                 ;2352
0000ca  4641              MOV      r1,r8                 ;2352
0000cc  4620              MOV      r0,r4                 ;2352
0000ce  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
0000d2  b108              CBZ      r0,|L33.216|
0000d4  2001              MOVS     r0,#1                 ;2354
0000d6  e7a1              B        |L33.28|
                  |L33.216|
0000d8  6a60              LDR      r0,[r4,#0x24]         ;2358
0000da  6821              LDR      r1,[r4,#0]            ;2358
0000dc  7800              LDRB     r0,[r0,#0]            ;2358
0000de  6288              STR      r0,[r1,#0x28]         ;2358
0000e0  6a60              LDR      r0,[r4,#0x24]         ;2361
0000e2  1c40              ADDS     r0,r0,#1              ;2361
0000e4  6260              STR      r0,[r4,#0x24]         ;2361
0000e6  8d60              LDRH     r0,[r4,#0x2a]         ;2363
0000e8  1e40              SUBS     r0,r0,#1              ;2363
0000ea  8560              STRH     r0,[r4,#0x2a]         ;2363
0000ec  8d20              LDRH     r0,[r4,#0x28]         ;2364
0000ee  1e40              SUBS     r0,r0,#1              ;2364
0000f0  b280              UXTH     r0,r0                 ;2364
0000f2  8520              STRH     r0,[r4,#0x28]         ;2364
0000f4  8d61              LDRH     r1,[r4,#0x2a]         ;2366
0000f6  b301              CBZ      r1,|L33.314|
0000f8  b9f8              CBNZ     r0,|L33.314|
0000fa  4643              MOV      r3,r8                 ;2369
0000fc  2200              MOVS     r2,#0                 ;2369
0000fe  2180              MOVS     r1,#0x80              ;2369
000100  4620              MOV      r0,r4                 ;2369
000102  9600              STR      r6,[sp,#0]            ;2369
000104  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000108  b108              CBZ      r0,|L33.270|
00010a  2001              MOVS     r0,#1                 ;2371
00010c  e786              B        |L33.28|
                  |L33.270|
00010e  8d60              LDRH     r0,[r4,#0x2a]         ;2374
000110  28ff              CMP      r0,#0xff              ;2374
000112  d908              BLS      |L33.294|
000114  463a              MOV      r2,r7                 ;2376
000116  8527              STRH     r7,[r4,#0x28]         ;2376
000118  464b              MOV      r3,r9                 ;2377
00011a  9500              STR      r5,[sp,#0]            ;2377
00011c  4620              MOV      r0,r4                 ;2377
00011e  9904              LDR      r1,[sp,#0x10]         ;2377
000120  f7fffffe          BL       I2C_TransferConfig
000124  e009              B        |L33.314|
                  |L33.294|
000126  8d60              LDRH     r0,[r4,#0x2a]         ;2381
000128  8520              STRH     r0,[r4,#0x28]         ;2381
00012a  9500              STR      r5,[sp,#0]            ;2382
00012c  f8942028          LDRB     r2,[r4,#0x28]         ;2382
000130  4653              MOV      r3,r10                ;2382
000132  4620              MOV      r0,r4                 ;2382
000134  9904              LDR      r1,[sp,#0x10]         ;2382
000136  f7fffffe          BL       I2C_TransferConfig
                  |L33.314|
00013a  8d60              LDRH     r0,[r4,#0x2a]         ;2386
00013c  2800              CMP      r0,#0                 ;2386
00013e  d1c3              BNE      |L33.200|
000140  4632              MOV      r2,r6                 ;2390
000142  4641              MOV      r1,r8                 ;2390
000144  4620              MOV      r0,r4                 ;2390
000146  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00014a  b108              CBZ      r0,|L33.336|
00014c  2001              MOVS     r0,#1                 ;2392
00014e  e765              B        |L33.28|
                  |L33.336|
000150  6820              LDR      r0,[r4,#0]            ;2396
000152  2120              MOVS     r1,#0x20              ;2396
000154  61c1              STR      r1,[r0,#0x1c]         ;2396
000156  6820              LDR      r0,[r4,#0]            ;2399
000158  6842              LDR      r2,[r0,#4]            ;2399
00015a  4b05              LDR      r3,|L33.368|
00015c  401a              ANDS     r2,r2,r3              ;2399
00015e  6042              STR      r2,[r0,#4]            ;2399
000160  f8841041          STRB     r1,[r4,#0x41]         ;2401
000164  f8845042          STRB     r5,[r4,#0x42]         ;2402
000168  f8845040          STRB     r5,[r4,#0x40]         ;2405
00016c  2000              MOVS     r0,#0                 ;2407
00016e  e755              B        |L33.28|
;;;2414   
                          ENDP

                  |L33.368|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Mem_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_DMA PROC
;;;2743     */
;;;2744   HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2745                                           uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
;;;2746   {
000004  4604              MOV      r4,r0
000006  e9dd670a          LDRD     r6,r7,[sp,#0x28]
00000a  4689              MOV      r9,r1
00000c  4690              MOV      r8,r2
00000e  469a              MOV      r10,r3
;;;2747     uint32_t tickstart;
;;;2748     uint32_t xfermode;
;;;2749     HAL_StatusTypeDef dmaxferstatus;
;;;2750   
;;;2751     /* Check the parameters */
;;;2752     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2753   
;;;2754     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2820              CMP      r0,#0x20
000016  d002              BEQ      |L34.30|
;;;2755     {
;;;2756       if ((pData == NULL) || (Size == 0U))
;;;2757       {
;;;2758         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2759         return  HAL_ERROR;
;;;2760       }
;;;2761   
;;;2762       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2763       {
;;;2764         return HAL_BUSY;
;;;2765       }
;;;2766   
;;;2767       /* Process Locked */
;;;2768       __HAL_LOCK(hi2c);
;;;2769   
;;;2770       /* Init tickstart for timeout management*/
;;;2771       tickstart = HAL_GetTick();
;;;2772   
;;;2773       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;2774       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2775       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2776   
;;;2777       /* Prepare transfer parameters */
;;;2778       hi2c->pBuffPtr    = pData;
;;;2779       hi2c->XferCount   = Size;
;;;2780       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2781       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;2782   
;;;2783       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2784       {
;;;2785         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2786         xfermode = I2C_RELOAD_MODE;
;;;2787       }
;;;2788       else
;;;2789       {
;;;2790         hi2c->XferSize = hi2c->XferCount;
;;;2791         xfermode = I2C_AUTOEND_MODE;
;;;2792       }
;;;2793   
;;;2794       /* Send Slave Address and Memory Address */
;;;2795       if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2796       {
;;;2797         /* Process Unlocked */
;;;2798         __HAL_UNLOCK(hi2c);
;;;2799         return HAL_ERROR;
;;;2800       }
;;;2801   
;;;2802   
;;;2803       if (hi2c->hdmatx != NULL)
;;;2804       {
;;;2805         /* Set the I2C DMA transfer complete callback */
;;;2806         hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
;;;2807   
;;;2808         /* Set the DMA error callback */
;;;2809         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2810   
;;;2811         /* Set the unused DMA callbacks to NULL */
;;;2812         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2813         hi2c->hdmatx->XferAbortCallback = NULL;
;;;2814   
;;;2815         /* Enable the DMA channel */
;;;2816         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;2817       }
;;;2818       else
;;;2819       {
;;;2820         /* Update I2C state */
;;;2821         hi2c->State     = HAL_I2C_STATE_READY;
;;;2822         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2823   
;;;2824         /* Update I2C error code */
;;;2825         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2826   
;;;2827         /* Process Unlocked */
;;;2828         __HAL_UNLOCK(hi2c);
;;;2829   
;;;2830         return HAL_ERROR;
;;;2831       }
;;;2832   
;;;2833       if (dmaxferstatus == HAL_OK)
;;;2834       {
;;;2835         /* Send Slave Address */
;;;2836         /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2837         I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
;;;2838   
;;;2839         /* Update XferCount value */
;;;2840         hi2c->XferCount -= hi2c->XferSize;
;;;2841   
;;;2842         /* Process Unlocked */
;;;2843         __HAL_UNLOCK(hi2c);
;;;2844   
;;;2845         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2846                   to avoid the risk of I2C interrupt handle execution before current
;;;2847                   process unlock */
;;;2848         /* Enable ERR and NACK interrupts */
;;;2849         I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;2850   
;;;2851         /* Enable DMA Request */
;;;2852         hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;2853       }
;;;2854       else
;;;2855       {
;;;2856         /* Update I2C state */
;;;2857         hi2c->State     = HAL_I2C_STATE_READY;
;;;2858         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2859   
;;;2860         /* Update I2C error code */
;;;2861         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2862   
;;;2863         /* Process Unlocked */
;;;2864         __HAL_UNLOCK(hi2c);
;;;2865   
;;;2866         return HAL_ERROR;
;;;2867       }
;;;2868   
;;;2869       return HAL_OK;
;;;2870     }
;;;2871     else
;;;2872     {
;;;2873       return HAL_BUSY;
000018  2002              MOVS     r0,#2
                  |L34.26|
;;;2874     }
;;;2875   }
00001a  e8bd87fc          POP      {r2-r10,pc}
                  |L34.30|
00001e  b13e              CBZ      r6,|L34.48|
000020  b137              CBZ      r7,|L34.48|
000022  6820              LDR      r0,[r4,#0]            ;2762
000024  6980              LDR      r0,[r0,#0x18]         ;2762
000026  43c0              MVNS     r0,r0                 ;2762
000028  0400              LSLS     r0,r0,#16             ;2762
00002a  d406              BMI      |L34.58|
00002c  2002              MOVS     r0,#2                 ;2764
00002e  e7f4              B        |L34.26|
                  |L34.48|
000030  f44f7000          MOV      r0,#0x200             ;2758
000034  6460              STR      r0,[r4,#0x44]         ;2758
000036  2001              MOVS     r0,#1                 ;2759
000038  e7ef              B        |L34.26|
                  |L34.58|
00003a  f8940040          LDRB     r0,[r4,#0x40]         ;2768
00003e  2801              CMP      r0,#1                 ;2768
000040  d019              BEQ      |L34.118|
000042  3424              ADDS     r4,r4,#0x24           ;2768
000044  2001              MOVS     r0,#1                 ;2768
000046  7720              STRB     r0,[r4,#0x1c]         ;2768
000048  f7fffffe          BL       HAL_GetTick
00004c  2121              MOVS     r1,#0x21              ;2773
00004e  7761              STRB     r1,[r4,#0x1d]         ;2773
000050  2140              MOVS     r1,#0x40              ;2774
000052  77a1              STRB     r1,[r4,#0x1e]         ;2774
000054  2500              MOVS     r5,#0                 ;2775
000056  6225              STR      r5,[r4,#0x20]         ;2775
000058  6026              STR      r6,[r4,#0]            ;2778
00005a  80e7              STRH     r7,[r4,#6]            ;2779
00005c  4932              LDR      r1,|L34.296|
00005e  60a1              STR      r1,[r4,#8]            ;2780
000060  4932              LDR      r1,|L34.300|
000062  6121              STR      r1,[r4,#0x10]         ;2781
000064  88e1              LDRH     r1,[r4,#6]            ;2783
000066  3c24              SUBS     r4,r4,#0x24           ;2783
000068  29ff              CMP      r1,#0xff              ;2783
00006a  d906              BLS      |L34.122|
00006c  21ff              MOVS     r1,#0xff              ;2785
00006e  8521              STRH     r1,[r4,#0x28]         ;2785
000070  f04f7780          MOV      r7,#0x1000000         ;2786
000074  e005              B        |L34.130|
                  |L34.118|
000076  2002              MOVS     r0,#2                 ;2768
000078  e7cf              B        |L34.26|
                  |L34.122|
00007a  8d61              LDRH     r1,[r4,#0x2a]         ;2790
00007c  8521              STRH     r1,[r4,#0x28]         ;2790
00007e  f04f7700          MOV      r7,#0x2000000         ;2791
                  |L34.130|
000082  2119              MOVS     r1,#0x19              ;2795
000084  e9cd1000          STRD     r1,r0,[sp,#0]         ;2795
000088  4653              MOV      r3,r10                ;2795
00008a  4642              MOV      r2,r8                 ;2795
00008c  4649              MOV      r1,r9                 ;2795
00008e  4620              MOV      r0,r4                 ;2795
000090  f7fffffe          BL       I2C_RequestMemoryWrite
000094  b118              CBZ      r0,|L34.158|
000096  f8845040          STRB     r5,[r4,#0x40]         ;2798
00009a  2001              MOVS     r0,#1                 ;2799
00009c  e7bd              B        |L34.26|
                  |L34.158|
00009e  6ba0              LDR      r0,[r4,#0x38]         ;2803
0000a0  f04f0820          MOV      r8,#0x20              ;2821
0000a4  b1d8              CBZ      r0,|L34.222|
0000a6  4922              LDR      r1,|L34.304|
0000a8  62c1              STR      r1,[r0,#0x2c]         ;2806
0000aa  6ba1              LDR      r1,[r4,#0x38]         ;2809
0000ac  4821              LDR      r0,|L34.308|
0000ae  6348              STR      r0,[r1,#0x34]         ;2809
0000b0  6ba0              LDR      r0,[r4,#0x38]         ;2812
0000b2  6305              STR      r5,[r0,#0x30]         ;2812
0000b4  6ba0              LDR      r0,[r4,#0x38]         ;2813
0000b6  6385              STR      r5,[r0,#0x38]         ;2813
0000b8  6822              LDR      r2,[r4,#0]            ;2816
0000ba  8d23              LDRH     r3,[r4,#0x28]         ;2816
0000bc  3228              ADDS     r2,r2,#0x28           ;2816
0000be  4631              MOV      r1,r6                 ;2816
0000c0  6ba0              LDR      r0,[r4,#0x38]         ;2816
0000c2  f7fffffe          BL       HAL_DMA_Start_IT
0000c6  b1a8              CBZ      r0,|L34.244|
0000c8  3440              ADDS     r4,r4,#0x40           ;2857
0000ca  f8848001          STRB     r8,[r4,#1]            ;2857
0000ce  70a5              STRB     r5,[r4,#2]            ;2858
0000d0  6860              LDR      r0,[r4,#4]            ;2861
0000d2  f0400010          ORR      r0,r0,#0x10           ;2861
0000d6  6060              STR      r0,[r4,#4]            ;2861
0000d8  7025              STRB     r5,[r4,#0]            ;2864
0000da  2001              MOVS     r0,#1                 ;2866
0000dc  e79d              B        |L34.26|
                  |L34.222|
0000de  3440              ADDS     r4,r4,#0x40           ;2821
0000e0  f8848001          STRB     r8,[r4,#1]            ;2821
0000e4  70a5              STRB     r5,[r4,#2]            ;2822
0000e6  6860              LDR      r0,[r4,#4]            ;2825
0000e8  f0400080          ORR      r0,r0,#0x80           ;2825
0000ec  6060              STR      r0,[r4,#4]            ;2825
0000ee  7025              STRB     r5,[r4,#0]            ;2828
0000f0  2001              MOVS     r0,#1                 ;2830
0000f2  e792              B        |L34.26|
                  |L34.244|
0000f4  9500              STR      r5,[sp,#0]            ;2837
0000f6  f8942028          LDRB     r2,[r4,#0x28]         ;2837
0000fa  463b              MOV      r3,r7                 ;2837
0000fc  4649              MOV      r1,r9                 ;2837
0000fe  4620              MOV      r0,r4                 ;2837
000100  f7fffffe          BL       I2C_TransferConfig
000104  8d60              LDRH     r0,[r4,#0x2a]         ;2840
000106  8d21              LDRH     r1,[r4,#0x28]         ;2840
000108  1a40              SUBS     r0,r0,r1              ;2840
00010a  8560              STRH     r0,[r4,#0x2a]         ;2840
00010c  f8845040          STRB     r5,[r4,#0x40]         ;2843
000110  2110              MOVS     r1,#0x10              ;2849
000112  4620              MOV      r0,r4                 ;2849
000114  f7fffffe          BL       I2C_Enable_IRQ
000118  6820              LDR      r0,[r4,#0]            ;2852
00011a  6801              LDR      r1,[r0,#0]            ;2852
00011c  f4414180          ORR      r1,r1,#0x4000         ;2852
000120  6001              STR      r1,[r0,#0]            ;2852
000122  2000              MOVS     r0,#0                 ;2869
000124  e779              B        |L34.26|
;;;2876   
                          ENDP

000126  0000              DCW      0x0000
                  |L34.296|
                          DCD      0xffff0000
                  |L34.300|
                          DCD      I2C_Master_ISR_DMA
                  |L34.304|
                          DCD      I2C_DMAMasterTransmitCplt
                  |L34.308|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Write_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_IT PROC
;;;2560     */
;;;2561   HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2562                                          uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
;;;2563   {
000004  4604              MOV      r4,r0
000006  e9dd6a0a          LDRD     r6,r10,[sp,#0x28]
00000a  460f              MOV      r7,r1
00000c  4690              MOV      r8,r2
00000e  4699              MOV      r9,r3
;;;2564     uint32_t tickstart;
;;;2565     uint32_t xfermode;
;;;2566   
;;;2567     /* Check the parameters */
;;;2568     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2569   
;;;2570     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2820              CMP      r0,#0x20
000016  d002              BEQ      |L35.30|
;;;2571     {
;;;2572       if ((pData == NULL) || (Size == 0U))
;;;2573       {
;;;2574         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2575         return  HAL_ERROR;
;;;2576       }
;;;2577   
;;;2578       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2579       {
;;;2580         return HAL_BUSY;
;;;2581       }
;;;2582   
;;;2583       /* Process Locked */
;;;2584       __HAL_LOCK(hi2c);
;;;2585   
;;;2586       /* Init tickstart for timeout management*/
;;;2587       tickstart = HAL_GetTick();
;;;2588   
;;;2589       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;2590       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2591       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2592   
;;;2593       /* Prepare transfer parameters */
;;;2594       hi2c->pBuffPtr    = pData;
;;;2595       hi2c->XferCount   = Size;
;;;2596       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2597       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;2598   
;;;2599       if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2600       {
;;;2601         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2602         xfermode = I2C_RELOAD_MODE;
;;;2603       }
;;;2604       else
;;;2605       {
;;;2606         hi2c->XferSize = hi2c->XferCount;
;;;2607         xfermode = I2C_AUTOEND_MODE;
;;;2608       }
;;;2609   
;;;2610       /* Send Slave Address and Memory Address */
;;;2611       if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2612       {
;;;2613         /* Process Unlocked */
;;;2614         __HAL_UNLOCK(hi2c);
;;;2615         return HAL_ERROR;
;;;2616       }
;;;2617   
;;;2618       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2619       I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
;;;2620   
;;;2621       /* Process Unlocked */
;;;2622       __HAL_UNLOCK(hi2c);
;;;2623   
;;;2624       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2625                 to avoid the risk of I2C interrupt handle execution before current
;;;2626                 process unlock */
;;;2627   
;;;2628       /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;2629       /* possible to enable all of these */
;;;2630       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;2631       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;2632   
;;;2633       return HAL_OK;
;;;2634     }
;;;2635     else
;;;2636     {
;;;2637       return HAL_BUSY;
000018  2002              MOVS     r0,#2
                  |L35.26|
;;;2638     }
;;;2639   }
00001a  e8bd87fc          POP      {r2-r10,pc}
                  |L35.30|
00001e  b14e              CBZ      r6,|L35.52|
000020  f1ba0f00          CMP      r10,#0                ;2572
000024  d006              BEQ      |L35.52|
000026  6820              LDR      r0,[r4,#0]            ;2578
000028  6980              LDR      r0,[r0,#0x18]         ;2578
00002a  43c0              MVNS     r0,r0                 ;2578
00002c  0400              LSLS     r0,r0,#16             ;2578
00002e  d406              BMI      |L35.62|
000030  2002              MOVS     r0,#2                 ;2580
000032  e7f2              B        |L35.26|
                  |L35.52|
000034  f44f7000          MOV      r0,#0x200             ;2574
000038  6460              STR      r0,[r4,#0x44]         ;2574
00003a  2001              MOVS     r0,#1                 ;2575
00003c  e7ed              B        |L35.26|
                  |L35.62|
00003e  f8940040          LDRB     r0,[r4,#0x40]         ;2584
000042  2801              CMP      r0,#1                 ;2584
000044  d01a              BEQ      |L35.124|
000046  3424              ADDS     r4,r4,#0x24           ;2584
000048  2001              MOVS     r0,#1                 ;2584
00004a  7720              STRB     r0,[r4,#0x1c]         ;2584
00004c  f7fffffe          BL       HAL_GetTick
000050  2121              MOVS     r1,#0x21              ;2589
000052  7761              STRB     r1,[r4,#0x1d]         ;2589
000054  2140              MOVS     r1,#0x40              ;2590
000056  77a1              STRB     r1,[r4,#0x1e]         ;2590
000058  2500              MOVS     r5,#0                 ;2591
00005a  6225              STR      r5,[r4,#0x20]         ;2591
00005c  6026              STR      r6,[r4,#0]            ;2594
00005e  f8a4a006          STRH     r10,[r4,#6]           ;2595
000062  4918              LDR      r1,|L35.196|
000064  60a1              STR      r1,[r4,#8]            ;2596
000066  4918              LDR      r1,|L35.200|
000068  6121              STR      r1,[r4,#0x10]         ;2597
00006a  88e1              LDRH     r1,[r4,#6]            ;2599
00006c  3c24              SUBS     r4,r4,#0x24           ;2599
00006e  29ff              CMP      r1,#0xff              ;2599
000070  d906              BLS      |L35.128|
000072  21ff              MOVS     r1,#0xff              ;2601
000074  8521              STRH     r1,[r4,#0x28]         ;2601
000076  f04f7680          MOV      r6,#0x1000000         ;2602
00007a  e005              B        |L35.136|
                  |L35.124|
00007c  2002              MOVS     r0,#2                 ;2584
00007e  e7cc              B        |L35.26|
                  |L35.128|
000080  8d61              LDRH     r1,[r4,#0x2a]         ;2606
000082  8521              STRH     r1,[r4,#0x28]         ;2606
000084  f04f7600          MOV      r6,#0x2000000         ;2607
                  |L35.136|
000088  2119              MOVS     r1,#0x19              ;2611
00008a  e9cd1000          STRD     r1,r0,[sp,#0]         ;2611
00008e  464b              MOV      r3,r9                 ;2611
000090  4642              MOV      r2,r8                 ;2611
000092  4639              MOV      r1,r7                 ;2611
000094  4620              MOV      r0,r4                 ;2611
000096  f7fffffe          BL       I2C_RequestMemoryWrite
00009a  b118              CBZ      r0,|L35.164|
00009c  f8845040          STRB     r5,[r4,#0x40]         ;2614
0000a0  2001              MOVS     r0,#1                 ;2615
0000a2  e7ba              B        |L35.26|
                  |L35.164|
0000a4  9500              STR      r5,[sp,#0]            ;2619
0000a6  f8942028          LDRB     r2,[r4,#0x28]         ;2619
0000aa  4633              MOV      r3,r6                 ;2619
0000ac  4639              MOV      r1,r7                 ;2619
0000ae  4620              MOV      r0,r4                 ;2619
0000b0  f7fffffe          BL       I2C_TransferConfig
0000b4  f8845040          STRB     r5,[r4,#0x40]         ;2622
0000b8  2101              MOVS     r1,#1                 ;2631
0000ba  4620              MOV      r0,r4                 ;2631
0000bc  f7fffffe          BL       I2C_Enable_IRQ
0000c0  2000              MOVS     r0,#0                 ;2633
0000c2  e7aa              B        |L35.26|
;;;2640   
                          ENDP

                  |L35.196|
                          DCD      0xffff0000
                  |L35.200|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspDeInit PROC
;;;646      */
;;;647    __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;648    {
;;;649      /* Prevent unused argument(s) compilation warning */
;;;650      UNUSED(hi2c);
;;;651    
;;;652      /* NOTE : This function should not be modified, when the callback is needed,
;;;653                the HAL_I2C_MspDeInit could be implemented in the user file
;;;654       */
;;;655    }
;;;656    
                          ENDP


                          AREA ||i.HAL_I2C_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspInit PROC
;;;630      */
;;;631    __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;632    {
;;;633      /* Prevent unused argument(s) compilation warning */
;;;634      UNUSED(hi2c);
;;;635    
;;;636      /* NOTE : This function should not be modified, when the callback is needed,
;;;637                the HAL_I2C_MspInit could be implemented in the user file
;;;638       */
;;;639    }
;;;640    
                          ENDP


                          AREA ||i.HAL_I2C_SlaveRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveRxCpltCallback PROC
;;;4447     */
;;;4448   __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4449   {
;;;4450     /* Prevent unused argument(s) compilation warning */
;;;4451     UNUSED(hi2c);
;;;4452   
;;;4453     /* NOTE : This function should not be modified, when the callback is needed,
;;;4454               the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
;;;4455      */
;;;4456   }
;;;4457   
                          ENDP


                          AREA ||i.HAL_I2C_SlaveTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveTxCpltCallback PROC
;;;4431     */
;;;4432   __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4433   {
;;;4434     /* Prevent unused argument(s) compilation warning */
;;;4435     UNUSED(hi2c);
;;;4436   
;;;4437     /* NOTE : This function should not be modified, when the callback is needed,
;;;4438               the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
;;;4439      */
;;;4440   }
;;;4441   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Receive PROC
;;;1433     */
;;;1434   HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1435   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  4698              MOV      r8,r3
;;;1436     uint32_t tickstart;
;;;1437   
;;;1438     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f8940041          LDRB     r0,[r4,#0x41]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L40.26|
;;;1439     {
;;;1440       if ((pData == NULL) || (Size == 0U))
;;;1441       {
;;;1442         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;1443         return  HAL_ERROR;
;;;1444       }
;;;1445       /* Process Locked */
;;;1446       __HAL_LOCK(hi2c);
;;;1447   
;;;1448       /* Init tickstart for timeout management*/
;;;1449       tickstart = HAL_GetTick();
;;;1450   
;;;1451       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1452       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1453       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1454   
;;;1455       /* Prepare transfer parameters */
;;;1456       hi2c->pBuffPtr  = pData;
;;;1457       hi2c->XferCount = Size;
;;;1458       hi2c->XferISR   = NULL;
;;;1459   
;;;1460       /* Enable Address Acknowledge */
;;;1461       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1462   
;;;1463       /* Wait until ADDR flag is set */
;;;1464       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1465       {
;;;1466         /* Disable Address Acknowledge */
;;;1467         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1468         return HAL_ERROR;
;;;1469       }
;;;1470   
;;;1471       /* Clear ADDR flag */
;;;1472       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;1473   
;;;1474       /* Wait until DIR flag is reset Receiver mode */
;;;1475       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
;;;1476       {
;;;1477         /* Disable Address Acknowledge */
;;;1478         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1479         return HAL_ERROR;
;;;1480       }
;;;1481   
;;;1482       while (hi2c->XferCount > 0U)
;;;1483       {
;;;1484         /* Wait until RXNE flag is set */
;;;1485         if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1486         {
;;;1487           /* Disable Address Acknowledge */
;;;1488           hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1489   
;;;1490           /* Store Last receive data if any */
;;;1491           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
;;;1492           {
;;;1493             /* Read data from RXDR */
;;;1494             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
;;;1495   
;;;1496             /* Increment Buffer pointer */
;;;1497             hi2c->pBuffPtr++;
;;;1498   
;;;1499             hi2c->XferCount--;
;;;1500           }
;;;1501   
;;;1502           return HAL_ERROR;
;;;1503         }
;;;1504   
;;;1505         /* Read data from RXDR */
;;;1506         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
;;;1507   
;;;1508         /* Increment Buffer pointer */
;;;1509         hi2c->pBuffPtr++;
;;;1510   
;;;1511         hi2c->XferCount--;
;;;1512       }
;;;1513   
;;;1514       /* Wait until STOP flag is set */
;;;1515       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1516       {
;;;1517         /* Disable Address Acknowledge */
;;;1518         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1519         return HAL_ERROR;
;;;1520       }
;;;1521   
;;;1522       /* Clear STOP flag */
;;;1523       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;1524   
;;;1525       /* Wait until BUSY flag is reset */
;;;1526       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
;;;1527       {
;;;1528         /* Disable Address Acknowledge */
;;;1529         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1530         return HAL_ERROR;
;;;1531       }
;;;1532   
;;;1533       /* Disable Address Acknowledge */
;;;1534       hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1535   
;;;1536       hi2c->State = HAL_I2C_STATE_READY;
;;;1537       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;1538   
;;;1539       /* Process Unlocked */
;;;1540       __HAL_UNLOCK(hi2c);
;;;1541   
;;;1542       return HAL_OK;
;;;1543     }
;;;1544     else
;;;1545     {
;;;1546       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L40.22|
;;;1547     }
;;;1548   }
000016  e8bd8ff8          POP      {r3-r11,pc}
                  |L40.26|
00001a  f1b90f00          CMP      r9,#0                 ;1440
00001e  d02d              BEQ      |L40.124|
000020  f1ba0f00          CMP      r10,#0                ;1440
000024  d02a              BEQ      |L40.124|
000026  f8940040          LDRB     r0,[r4,#0x40]         ;1446
00002a  2801              CMP      r0,#1                 ;1446
00002c  d02b              BEQ      |L40.134|
00002e  2001              MOVS     r0,#1                 ;1446
000030  f8840040          STRB     r0,[r4,#0x40]         ;1446
000034  f7fffffe          BL       HAL_GetTick
000038  4605              MOV      r5,r0                 ;1449
00003a  2022              MOVS     r0,#0x22              ;1451
00003c  f8840041          STRB     r0,[r4,#0x41]         ;1451
000040  2720              MOVS     r7,#0x20              ;1452
000042  f8847042          STRB     r7,[r4,#0x42]         ;1452
000046  2600              MOVS     r6,#0                 ;1453
000048  6466              STR      r6,[r4,#0x44]         ;1453
00004a  f8c49024          STR      r9,[r4,#0x24]         ;1456
00004e  f8a4a02a          STRH     r10,[r4,#0x2a]        ;1457
000052  6366              STR      r6,[r4,#0x34]         ;1458
000054  6820              LDR      r0,[r4,#0]            ;1461
000056  6841              LDR      r1,[r0,#4]            ;1461
000058  f4214100          BIC      r1,r1,#0x8000         ;1461
00005c  6041              STR      r1,[r0,#4]            ;1461
00005e  4643              MOV      r3,r8                 ;1464
000060  2200              MOVS     r2,#0                 ;1464
000062  2108              MOVS     r1,#8                 ;1464
000064  4620              MOV      r0,r4                 ;1464
000066  9500              STR      r5,[sp,#0]            ;1464
000068  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00006c  b168              CBZ      r0,|L40.138|
00006e  6820              LDR      r0,[r4,#0]            ;1467
000070  6841              LDR      r1,[r0,#4]            ;1467
000072  f4414100          ORR      r1,r1,#0x8000         ;1467
000076  6041              STR      r1,[r0,#4]            ;1467
000078  2001              MOVS     r0,#1                 ;1468
00007a  e7cc              B        |L40.22|
                  |L40.124|
00007c  f44f7000          MOV      r0,#0x200             ;1442
000080  6460              STR      r0,[r4,#0x44]         ;1442
000082  2001              MOVS     r0,#1                 ;1443
000084  e7c7              B        |L40.22|
                  |L40.134|
000086  2002              MOVS     r0,#2                 ;1446
000088  e7c5              B        |L40.22|
                  |L40.138|
00008a  6821              LDR      r1,[r4,#0]            ;1472
00008c  2008              MOVS     r0,#8                 ;1472
00008e  61c8              STR      r0,[r1,#0x1c]         ;1472
000090  0341              LSLS     r1,r0,#13             ;1475
000092  4643              MOV      r3,r8                 ;1475
000094  2201              MOVS     r2,#1                 ;1475
000096  4620              MOV      r0,r4                 ;1475
000098  9500              STR      r5,[sp,#0]            ;1475
00009a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00009e  b358              CBZ      r0,|L40.248|
0000a0  6820              LDR      r0,[r4,#0]            ;1478
0000a2  6841              LDR      r1,[r0,#4]            ;1478
0000a4  f4414100          ORR      r1,r1,#0x8000         ;1478
0000a8  6041              STR      r1,[r0,#4]            ;1478
0000aa  2001              MOVS     r0,#1                 ;1479
0000ac  e7b3              B        |L40.22|
                  |L40.174|
0000ae  462a              MOV      r2,r5                 ;1485
0000b0  4641              MOV      r1,r8                 ;1485
0000b2  4620              MOV      r0,r4                 ;1485
0000b4  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000b8  b1a0              CBZ      r0,|L40.228|
0000ba  6820              LDR      r0,[r4,#0]            ;1488
0000bc  6841              LDR      r1,[r0,#4]            ;1488
0000be  f4414100          ORR      r1,r1,#0x8000         ;1488
0000c2  6041              STR      r1,[r0,#4]            ;1488
0000c4  6820              LDR      r0,[r4,#0]            ;1491
0000c6  6981              LDR      r1,[r0,#0x18]         ;1491
0000c8  43c9              MVNS     r1,r1                 ;1491
0000ca  0749              LSLS     r1,r1,#29             ;1491
0000cc  d408              BMI      |L40.224|
0000ce  6a40              LDR      r0,[r0,#0x24]         ;1494
0000d0  6a61              LDR      r1,[r4,#0x24]         ;1494
0000d2  7008              STRB     r0,[r1,#0]            ;1494
0000d4  6a60              LDR      r0,[r4,#0x24]         ;1497
0000d6  1c40              ADDS     r0,r0,#1              ;1497
0000d8  6260              STR      r0,[r4,#0x24]         ;1497
0000da  8d60              LDRH     r0,[r4,#0x2a]         ;1499
0000dc  1e40              SUBS     r0,r0,#1              ;1499
0000de  8560              STRH     r0,[r4,#0x2a]         ;1499
                  |L40.224|
0000e0  2001              MOVS     r0,#1                 ;1502
0000e2  e798              B        |L40.22|
                  |L40.228|
0000e4  6820              LDR      r0,[r4,#0]            ;1506
0000e6  6a40              LDR      r0,[r0,#0x24]         ;1506
0000e8  6a61              LDR      r1,[r4,#0x24]         ;1506
0000ea  7008              STRB     r0,[r1,#0]            ;1506
0000ec  6a60              LDR      r0,[r4,#0x24]         ;1509
0000ee  1c40              ADDS     r0,r0,#1              ;1509
0000f0  6260              STR      r0,[r4,#0x24]         ;1509
0000f2  8d60              LDRH     r0,[r4,#0x2a]         ;1511
0000f4  1e40              SUBS     r0,r0,#1              ;1511
0000f6  8560              STRH     r0,[r4,#0x2a]         ;1511
                  |L40.248|
0000f8  8d60              LDRH     r0,[r4,#0x2a]         ;1482
0000fa  2800              CMP      r0,#0                 ;1482
0000fc  d1d7              BNE      |L40.174|
0000fe  462a              MOV      r2,r5                 ;1515
000100  4641              MOV      r1,r8                 ;1515
000102  4620              MOV      r0,r4                 ;1515
000104  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000108  b130              CBZ      r0,|L40.280|
00010a  6820              LDR      r0,[r4,#0]            ;1518
00010c  6841              LDR      r1,[r0,#4]            ;1518
00010e  f4414100          ORR      r1,r1,#0x8000         ;1518
000112  6041              STR      r1,[r0,#4]            ;1518
000114  2001              MOVS     r0,#1                 ;1519
000116  e77e              B        |L40.22|
                  |L40.280|
000118  6820              LDR      r0,[r4,#0]            ;1523
00011a  61c7              STR      r7,[r0,#0x1c]         ;1523
00011c  2201              MOVS     r2,#1                 ;1526
00011e  4643              MOV      r3,r8                 ;1526
000120  03d1              LSLS     r1,r2,#15             ;1526
000122  4620              MOV      r0,r4                 ;1526
000124  9500              STR      r5,[sp,#0]            ;1526
000126  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00012a  b130              CBZ      r0,|L40.314|
00012c  6820              LDR      r0,[r4,#0]            ;1529
00012e  6841              LDR      r1,[r0,#4]            ;1529
000130  f4414100          ORR      r1,r1,#0x8000         ;1529
000134  6041              STR      r1,[r0,#4]            ;1529
000136  2001              MOVS     r0,#1                 ;1530
000138  e76d              B        |L40.22|
                  |L40.314|
00013a  3423              ADDS     r4,r4,#0x23           ;1534
00013c  f8540c23          LDR      r0,[r4,#-0x23]        ;1534
000140  6841              LDR      r1,[r0,#4]            ;1534
000142  f4414100          ORR      r1,r1,#0x8000         ;1534
000146  6041              STR      r1,[r0,#4]            ;1534
000148  77a7              STRB     r7,[r4,#0x1e]         ;1536
00014a  77e6              STRB     r6,[r4,#0x1f]         ;1537
00014c  7766              STRB     r6,[r4,#0x1d]         ;1540
00014e  2000              MOVS     r0,#0                 ;1542
000150  e761              B        |L40.22|
;;;1549   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_DMA PROC
;;;2185     */
;;;2186   HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2187   {
000004  4604              MOV      r4,r0
;;;2188     HAL_StatusTypeDef dmaxferstatus;
;;;2189   
;;;2190     if (hi2c->State == HAL_I2C_STATE_READY)
000006  f8940041          LDRB     r0,[r4,#0x41]
00000a  2820              CMP      r0,#0x20
00000c  d002              BEQ      |L41.20|
;;;2191     {
;;;2192       if ((pData == NULL) || (Size == 0U))
;;;2193       {
;;;2194         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2195         return  HAL_ERROR;
;;;2196       }
;;;2197       /* Process Locked */
;;;2198       __HAL_LOCK(hi2c);
;;;2199   
;;;2200       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;2201       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;2202       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2203   
;;;2204       /* Prepare transfer parameters */
;;;2205       hi2c->pBuffPtr    = pData;
;;;2206       hi2c->XferCount   = Size;
;;;2207       hi2c->XferSize    = hi2c->XferCount;
;;;2208       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2209       hi2c->XferISR     = I2C_Slave_ISR_DMA;
;;;2210   
;;;2211       if (hi2c->hdmarx != NULL)
;;;2212       {
;;;2213         /* Set the I2C DMA transfer complete callback */
;;;2214         hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
;;;2215   
;;;2216         /* Set the DMA error callback */
;;;2217         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2218   
;;;2219         /* Set the unused DMA callbacks to NULL */
;;;2220         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2221         hi2c->hdmarx->XferAbortCallback = NULL;
;;;2222   
;;;2223         /* Enable the DMA channel */
;;;2224         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;2225       }
;;;2226       else
;;;2227       {
;;;2228         /* Update I2C state */
;;;2229         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;2230         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2231   
;;;2232         /* Update I2C error code */
;;;2233         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2234   
;;;2235         /* Process Unlocked */
;;;2236         __HAL_UNLOCK(hi2c);
;;;2237   
;;;2238         return HAL_ERROR;
;;;2239       }
;;;2240   
;;;2241       if (dmaxferstatus == HAL_OK)
;;;2242       {
;;;2243         /* Enable Address Acknowledge */
;;;2244         hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;2245   
;;;2246         /* Process Unlocked */
;;;2247         __HAL_UNLOCK(hi2c);
;;;2248   
;;;2249         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2250                   to avoid the risk of I2C interrupt handle execution before current
;;;2251                   process unlock */
;;;2252         /* Enable ERR, STOP, NACK, ADDR interrupts */
;;;2253         I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;2254   
;;;2255         /* Enable DMA Request */
;;;2256         hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;2257       }
;;;2258       else
;;;2259       {
;;;2260         /* Update I2C state */
;;;2261         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;2262         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2263   
;;;2264         /* Update I2C error code */
;;;2265         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2266   
;;;2267         /* Process Unlocked */
;;;2268         __HAL_UNLOCK(hi2c);
;;;2269   
;;;2270         return HAL_ERROR;
;;;2271       }
;;;2272   
;;;2273       return HAL_OK;
;;;2274     }
;;;2275     else
;;;2276     {
;;;2277       return HAL_BUSY;
00000e  2002              MOVS     r0,#2
                  |L41.16|
;;;2278     }
;;;2279   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L41.20|
000014  b3b1              CBZ      r1,|L41.132|
000016  b3aa              CBZ      r2,|L41.132|
000018  f8940040          LDRB     r0,[r4,#0x40]         ;2198
00001c  2801              CMP      r0,#1                 ;2198
00001e  d037              BEQ      |L41.144|
000020  2001              MOVS     r0,#1                 ;2198
000022  3424              ADDS     r4,r4,#0x24           ;2198
000024  7720              STRB     r0,[r4,#0x1c]         ;2198
000026  2022              MOVS     r0,#0x22              ;2200
000028  7760              STRB     r0,[r4,#0x1d]         ;2200
00002a  2020              MOVS     r0,#0x20              ;2201
00002c  77a0              STRB     r0,[r4,#0x1e]         ;2201
00002e  2500              MOVS     r5,#0                 ;2202
000030  6225              STR      r5,[r4,#0x20]         ;2202
000032  6021              STR      r1,[r4,#0]            ;2205
000034  80e2              STRH     r2,[r4,#6]            ;2206
000036  88e0              LDRH     r0,[r4,#6]            ;2207
000038  80a0              STRH     r0,[r4,#4]            ;2207
00003a  4825              LDR      r0,|L41.208|
00003c  60a0              STR      r0,[r4,#8]            ;2208
00003e  4825              LDR      r0,|L41.212|
000040  6120              STR      r0,[r4,#0x10]         ;2209
000042  69a0              LDR      r0,[r4,#0x18]         ;2211
000044  3c24              SUBS     r4,r4,#0x24           ;2211
000046  2628              MOVS     r6,#0x28              ;2229
000048  b320              CBZ      r0,|L41.148|
00004a  4a23              LDR      r2,|L41.216|
00004c  62c2              STR      r2,[r0,#0x2c]         ;2214
00004e  6be2              LDR      r2,[r4,#0x3c]         ;2217
000050  4822              LDR      r0,|L41.220|
000052  6350              STR      r0,[r2,#0x34]         ;2217
000054  6be0              LDR      r0,[r4,#0x3c]         ;2220
000056  6305              STR      r5,[r0,#0x30]         ;2220
000058  6be0              LDR      r0,[r4,#0x3c]         ;2221
00005a  6385              STR      r5,[r0,#0x38]         ;2221
00005c  6820              LDR      r0,[r4,#0]            ;2224
00005e  460a              MOV      r2,r1                 ;2224
000060  3024              ADDS     r0,r0,#0x24           ;2224
000062  6be7              LDR      r7,[r4,#0x3c]         ;2224
000064  4601              MOV      r1,r0                 ;2224
000066  8d23              LDRH     r3,[r4,#0x28]         ;2224
000068  4638              MOV      r0,r7                 ;2224
00006a  f7fffffe          BL       HAL_DMA_Start_IT
00006e  b1d8              CBZ      r0,|L41.168|
000070  3440              ADDS     r4,r4,#0x40           ;2261
000072  7066              STRB     r6,[r4,#1]            ;2261
000074  70a5              STRB     r5,[r4,#2]            ;2262
000076  6860              LDR      r0,[r4,#4]            ;2265
000078  f0400010          ORR      r0,r0,#0x10           ;2265
00007c  6060              STR      r0,[r4,#4]            ;2265
00007e  7025              STRB     r5,[r4,#0]            ;2268
000080  2001              MOVS     r0,#1                 ;2270
000082  e7c5              B        |L41.16|
                  |L41.132|
000084  e7ff              B        |L41.134|
                  |L41.134|
000086  f44f7000          MOV      r0,#0x200             ;2194
00008a  6460              STR      r0,[r4,#0x44]         ;2194
00008c  2001              MOVS     r0,#1                 ;2195
00008e  e7bf              B        |L41.16|
                  |L41.144|
000090  2002              MOVS     r0,#2                 ;2198
000092  e7bd              B        |L41.16|
                  |L41.148|
000094  3440              ADDS     r4,r4,#0x40           ;2229
000096  7066              STRB     r6,[r4,#1]            ;2229
000098  70a5              STRB     r5,[r4,#2]            ;2230
00009a  6860              LDR      r0,[r4,#4]            ;2233
00009c  f0400080          ORR      r0,r0,#0x80           ;2233
0000a0  6060              STR      r0,[r4,#4]            ;2233
0000a2  7025              STRB     r5,[r4,#0]            ;2236
0000a4  2001              MOVS     r0,#1                 ;2238
0000a6  e7b3              B        |L41.16|
                  |L41.168|
0000a8  6820              LDR      r0,[r4,#0]            ;2244
0000aa  6841              LDR      r1,[r0,#4]            ;2244
0000ac  f4214100          BIC      r1,r1,#0x8000         ;2244
0000b0  6041              STR      r1,[r0,#4]            ;2244
0000b2  f8845040          STRB     r5,[r4,#0x40]         ;2247
0000b6  f44f4100          MOV      r1,#0x8000            ;2253
0000ba  4620              MOV      r0,r4                 ;2253
0000bc  f7fffffe          BL       I2C_Enable_IRQ
0000c0  6820              LDR      r0,[r4,#0]            ;2256
0000c2  6801              LDR      r1,[r0,#0]            ;2256
0000c4  f4414100          ORR      r1,r1,#0x8000         ;2256
0000c8  6001              STR      r1,[r0,#0]            ;2256
0000ca  2000              MOVS     r0,#0                 ;2273
0000cc  e7a0              B        |L41.16|
;;;2280   /**
                          ENDP

0000ce  0000              DCW      0x0000
                  |L41.208|
                          DCD      0xffff0000
                  |L41.212|
                          DCD      I2C_Slave_ISR_DMA
                  |L41.216|
                          DCD      I2C_DMASlaveReceiveCplt
                  |L41.220|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_IT PROC
;;;1745     */
;;;1746   HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1747   {
;;;1748     if (hi2c->State == HAL_I2C_STATE_READY)
000002  f8903041          LDRB     r3,[r0,#0x41]
000006  2b20              CMP      r3,#0x20
000008  d001              BEQ      |L42.14|
;;;1749     {
;;;1750       /* Process Locked */
;;;1751       __HAL_LOCK(hi2c);
;;;1752   
;;;1753       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1754       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1755       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1756   
;;;1757       /* Enable Address Acknowledge */
;;;1758       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1759   
;;;1760       /* Prepare transfer parameters */
;;;1761       hi2c->pBuffPtr    = pData;
;;;1762       hi2c->XferCount   = Size;
;;;1763       hi2c->XferSize    = hi2c->XferCount;
;;;1764       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1765       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;1766   
;;;1767       /* Process Unlocked */
;;;1768       __HAL_UNLOCK(hi2c);
;;;1769   
;;;1770       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1771                 to avoid the risk of I2C interrupt handle execution before current
;;;1772                 process unlock */
;;;1773   
;;;1774       /* Enable ERR, TC, STOP, NACK, RXI interrupt */
;;;1775       /* possible to enable all of these */
;;;1776       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1777       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
;;;1778   
;;;1779       return HAL_OK;
;;;1780     }
;;;1781     else
;;;1782     {
;;;1783       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;1784     }
;;;1785   }
00000c  bd70              POP      {r4-r6,pc}
                  |L42.14|
00000e  f8903040          LDRB     r3,[r0,#0x40]         ;1751
000012  2b01              CMP      r3,#1                 ;1751
000014  d01e              BEQ      |L42.84|
000016  2301              MOVS     r3,#1                 ;1751
000018  3024              ADDS     r0,r0,#0x24           ;1751
00001a  7703              STRB     r3,[r0,#0x1c]         ;1751
00001c  2322              MOVS     r3,#0x22              ;1753
00001e  7743              STRB     r3,[r0,#0x1d]         ;1753
000020  2320              MOVS     r3,#0x20              ;1754
000022  7783              STRB     r3,[r0,#0x1e]         ;1754
000024  2400              MOVS     r4,#0                 ;1755
000026  6204              STR      r4,[r0,#0x20]         ;1755
000028  f8503c24          LDR      r3,[r0,#-0x24]        ;1758
00002c  685d              LDR      r5,[r3,#4]            ;1758
00002e  f4254500          BIC      r5,r5,#0x8000         ;1758
000032  605d              STR      r5,[r3,#4]            ;1758
000034  6001              STR      r1,[r0,#0]            ;1761
000036  80c2              STRH     r2,[r0,#6]            ;1762
000038  88c1              LDRH     r1,[r0,#6]            ;1763
00003a  8081              STRH     r1,[r0,#4]            ;1763
00003c  4906              LDR      r1,|L42.88|
00003e  6081              STR      r1,[r0,#8]            ;1764
000040  4906              LDR      r1,|L42.92|
000042  6101              STR      r1,[r0,#0x10]         ;1765
000044  7704              STRB     r4,[r0,#0x1c]         ;1768
000046  3824              SUBS     r0,r0,#0x24           ;1768
000048  f2480102          MOV      r1,#0x8002            ;1777
00004c  f7fffffe          BL       I2C_Enable_IRQ
000050  2000              MOVS     r0,#0                 ;1779
000052  bd70              POP      {r4-r6,pc}
                  |L42.84|
000054  2002              MOVS     r0,#2                 ;1751
000056  bd70              POP      {r4-r6,pc}
;;;1786   
                          ENDP

                  |L42.88|
                          DCD      0xffff0000
                  |L42.92|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Receive_DMA PROC
;;;4037     */
;;;4038   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4039                                                   uint32_t XferOptions)
;;;4040   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;4041     HAL_StatusTypeDef dmaxferstatus;
;;;4042   
;;;4043     /* Check the parameters */
;;;4044     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4045   
;;;4046     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f8940041          LDRB     r0,[r4,#0x41]
000010  2528              MOVS     r5,#0x28
000012  ea350000          BICS     r0,r5,r0
000016  d002              BEQ      |L43.30|
;;;4047     {
;;;4048       if ((pData == NULL) || (Size == 0U))
;;;4049       {
;;;4050         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;4051         return  HAL_ERROR;
;;;4052       }
;;;4053   
;;;4054       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;4055       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
;;;4056   
;;;4057       /* Process Locked */
;;;4058       __HAL_LOCK(hi2c);
;;;4059   
;;;4060       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;4061       /* and then toggle the HAL slave TX state to RX state */
;;;4062       if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;4063       {
;;;4064         /* Disable associated Interrupts */
;;;4065         I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;4066   
;;;4067         if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
;;;4068         {
;;;4069           /* Abort DMA Xfer if any */
;;;4070           if (hi2c->hdmatx != NULL)
;;;4071           {
;;;4072             hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
;;;4073   
;;;4074             /* Set the I2C DMA Abort callback :
;;;4075              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4076             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;4077   
;;;4078             /* Abort DMA TX */
;;;4079             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;4080             {
;;;4081               /* Call Directly XferAbortCallback function in case of error */
;;;4082               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;4083             }
;;;4084           }
;;;4085         }
;;;4086       }
;;;4087       else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;4088       {
;;;4089         if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
;;;4090         {
;;;4091           hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
;;;4092   
;;;4093           /* Abort DMA Xfer if any */
;;;4094           if (hi2c->hdmarx != NULL)
;;;4095           {
;;;4096             /* Set the I2C DMA Abort callback :
;;;4097              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4098             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;4099   
;;;4100             /* Abort DMA RX */
;;;4101             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;4102             {
;;;4103               /* Call Directly XferAbortCallback function in case of error */
;;;4104               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;4105             }
;;;4106           }
;;;4107         }
;;;4108       }
;;;4109       else
;;;4110       {
;;;4111         /* Nothing to do */
;;;4112       }
;;;4113   
;;;4114       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;4115       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4116       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4117   
;;;4118       /* Enable Address Acknowledge */
;;;4119       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;4120   
;;;4121       /* Prepare transfer parameters */
;;;4122       hi2c->pBuffPtr    = pData;
;;;4123       hi2c->XferCount   = Size;
;;;4124       hi2c->XferSize    = hi2c->XferCount;
;;;4125       hi2c->XferOptions = XferOptions;
;;;4126       hi2c->XferISR     = I2C_Slave_ISR_DMA;
;;;4127   
;;;4128       if (hi2c->hdmarx != NULL)
;;;4129       {
;;;4130         /* Set the I2C DMA transfer complete callback */
;;;4131         hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
;;;4132   
;;;4133         /* Set the DMA error callback */
;;;4134         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;4135   
;;;4136         /* Set the unused DMA callbacks to NULL */
;;;4137         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;4138         hi2c->hdmarx->XferAbortCallback = NULL;
;;;4139   
;;;4140         /* Enable the DMA channel */
;;;4141         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;4142       }
;;;4143       else
;;;4144       {
;;;4145         /* Update I2C state */
;;;4146         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;4147         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4148   
;;;4149         /* Update I2C error code */
;;;4150         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;4151   
;;;4152         /* Process Unlocked */
;;;4153         __HAL_UNLOCK(hi2c);
;;;4154   
;;;4155         return HAL_ERROR;
;;;4156       }
;;;4157   
;;;4158       if (dmaxferstatus == HAL_OK)
;;;4159       {
;;;4160         /* Update XferCount value */
;;;4161         hi2c->XferCount -= hi2c->XferSize;
;;;4162   
;;;4163         /* Reset XferSize */
;;;4164         hi2c->XferSize = 0;
;;;4165       }
;;;4166       else
;;;4167       {
;;;4168         /* Update I2C state */
;;;4169         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;4170         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4171   
;;;4172         /* Update I2C error code */
;;;4173         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4174   
;;;4175         /* Process Unlocked */
;;;4176         __HAL_UNLOCK(hi2c);
;;;4177   
;;;4178         return HAL_ERROR;
;;;4179       }
;;;4180   
;;;4181       if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
;;;4182       {
;;;4183         /* Clear ADDR flag after prepare the transfer parameters */
;;;4184         /* This action will generate an acknowledge to the Master */
;;;4185         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;4186       }
;;;4187   
;;;4188       /* Process Unlocked */
;;;4189       __HAL_UNLOCK(hi2c);
;;;4190   
;;;4191       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4192       to avoid the risk of I2C interrupt handle execution before current
;;;4193       process unlock */
;;;4194       /* REnable ADDR interrupt */
;;;4195       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
;;;4196   
;;;4197       /* Enable DMA Request */
;;;4198       hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;4199   
;;;4200       return HAL_OK;
;;;4201     }
;;;4202     else
;;;4203     {
;;;4204       return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L43.26|
;;;4205     }
;;;4206   }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L43.30|
00001e  b1c6              CBZ      r6,|L43.82|
000020  b1bf              CBZ      r7,|L43.82|
000022  f2480a02          MOV      r10,#0x8002           ;4055
000026  4651              MOV      r1,r10                ;4055
000028  4620              MOV      r0,r4                 ;4055
00002a  f7fffffe          BL       I2C_Disable_IRQ
00002e  f8940040          LDRB     r0,[r4,#0x40]         ;4058
000032  2801              CMP      r0,#1                 ;4058
000034  d012              BEQ      |L43.92|
000036  2001              MOVS     r0,#1                 ;4058
000038  f8840040          STRB     r0,[r4,#0x40]         ;4058
00003c  f8940041          LDRB     r0,[r4,#0x41]         ;4062
000040  f8df8130          LDR      r8,|L43.372|
000044  2829              CMP      r0,#0x29              ;4062
000046  d00b              BEQ      |L43.96|
000048  f8940041          LDRB     r0,[r4,#0x41]         ;4087
00004c  282a              CMP      r0,#0x2a              ;4087
00004e  d020              BEQ      |L43.146|
000050  e032              B        |L43.184|
                  |L43.82|
000052  f44f7000          MOV      r0,#0x200             ;4050
000056  6460              STR      r0,[r4,#0x44]         ;4050
000058  2001              MOVS     r0,#1                 ;4051
00005a  e7de              B        |L43.26|
                  |L43.92|
00005c  2002              MOVS     r0,#2                 ;4058
00005e  e7dc              B        |L43.26|
                  |L43.96|
000060  2101              MOVS     r1,#1                 ;4065
000062  4620              MOV      r0,r4                 ;4065
000064  f7fffffe          BL       I2C_Disable_IRQ
000068  6820              LDR      r0,[r4,#0]            ;4067
00006a  6801              LDR      r1,[r0,#0]            ;4067
00006c  0449              LSLS     r1,r1,#17             ;4067
00006e  d523              BPL      |L43.184|
000070  6ba1              LDR      r1,[r4,#0x38]         ;4070
000072  b309              CBZ      r1,|L43.184|
000074  6801              LDR      r1,[r0,#0]            ;4072
000076  f4214180          BIC      r1,r1,#0x4000         ;4072
00007a  6001              STR      r1,[r0,#0]            ;4072
00007c  6ba0              LDR      r0,[r4,#0x38]         ;4076
00007e  f8c08038          STR      r8,[r0,#0x38]         ;4076
000082  6ba0              LDR      r0,[r4,#0x38]         ;4079
000084  f7fffffe          BL       HAL_DMA_Abort_IT
000088  b1b0              CBZ      r0,|L43.184|
00008a  6ba0              LDR      r0,[r4,#0x38]         ;4082
00008c  6b81              LDR      r1,[r0,#0x38]         ;4082
00008e  4788              BLX      r1                    ;4082
000090  e012              B        |L43.184|
                  |L43.146|
000092  6820              LDR      r0,[r4,#0]            ;4089
000094  6801              LDR      r1,[r0,#0]            ;4089
000096  0409              LSLS     r1,r1,#16             ;4089
000098  d50e              BPL      |L43.184|
00009a  6801              LDR      r1,[r0,#0]            ;4091
00009c  f4214100          BIC      r1,r1,#0x8000         ;4091
0000a0  6001              STR      r1,[r0,#0]            ;4091
0000a2  6be0              LDR      r0,[r4,#0x3c]         ;4094
0000a4  b140              CBZ      r0,|L43.184|
0000a6  f8c08038          STR      r8,[r0,#0x38]         ;4098
0000aa  6be0              LDR      r0,[r4,#0x3c]         ;4101
0000ac  f7fffffe          BL       HAL_DMA_Abort_IT
0000b0  b110              CBZ      r0,|L43.184|
0000b2  6be0              LDR      r0,[r4,#0x3c]         ;4104
0000b4  6b81              LDR      r1,[r0,#0x38]         ;4104
0000b6  4788              BLX      r1                    ;4104
                  |L43.184|
0000b8  202a              MOVS     r0,#0x2a              ;4114
0000ba  f8840041          STRB     r0,[r4,#0x41]         ;4114
0000be  2020              MOVS     r0,#0x20              ;4115
0000c0  f8840042          STRB     r0,[r4,#0x42]         ;4115
0000c4  f04f0800          MOV      r8,#0                 ;4116
0000c8  f8c48044          STR      r8,[r4,#0x44]         ;4116
0000cc  6820              LDR      r0,[r4,#0]            ;4119
0000ce  6841              LDR      r1,[r0,#4]            ;4119
0000d0  f4214100          BIC      r1,r1,#0x8000         ;4119
0000d4  6041              STR      r1,[r0,#4]            ;4119
0000d6  6266              STR      r6,[r4,#0x24]         ;4122
0000d8  8567              STRH     r7,[r4,#0x2a]         ;4123
0000da  8d60              LDRH     r0,[r4,#0x2a]         ;4124
0000dc  8520              STRH     r0,[r4,#0x28]         ;4124
0000de  f8c4902c          STR      r9,[r4,#0x2c]         ;4125
0000e2  4825              LDR      r0,|L43.376|
0000e4  6360              STR      r0,[r4,#0x34]         ;4126
0000e6  6be0              LDR      r0,[r4,#0x3c]         ;4128
0000e8  b1f0              CBZ      r0,|L43.296|
0000ea  4924              LDR      r1,|L43.380|
0000ec  62c1              STR      r1,[r0,#0x2c]         ;4131
0000ee  6be1              LDR      r1,[r4,#0x3c]         ;4134
0000f0  4823              LDR      r0,|L43.384|
0000f2  6348              STR      r0,[r1,#0x34]         ;4134
0000f4  6be0              LDR      r0,[r4,#0x3c]         ;4137
0000f6  f8c08030          STR      r8,[r0,#0x30]         ;4137
0000fa  6be0              LDR      r0,[r4,#0x3c]         ;4138
0000fc  f8c08038          STR      r8,[r0,#0x38]         ;4138
000100  6821              LDR      r1,[r4,#0]            ;4141
000102  8d23              LDRH     r3,[r4,#0x28]         ;4141
000104  3124              ADDS     r1,r1,#0x24           ;4141
000106  4632              MOV      r2,r6                 ;4141
000108  6be0              LDR      r0,[r4,#0x3c]         ;4141
00010a  f7fffffe          BL       HAL_DMA_Start_IT
00010e  b1b8              CBZ      r0,|L43.320|
000110  f8845041          STRB     r5,[r4,#0x41]         ;4169
000114  f8848042          STRB     r8,[r4,#0x42]         ;4170
000118  6c60              LDR      r0,[r4,#0x44]         ;4173
00011a  f0400010          ORR      r0,r0,#0x10           ;4173
00011e  6460              STR      r0,[r4,#0x44]         ;4173
000120  f8848040          STRB     r8,[r4,#0x40]         ;4176
000124  2001              MOVS     r0,#1                 ;4178
000126  e778              B        |L43.26|
                  |L43.296|
000128  f8845041          STRB     r5,[r4,#0x41]         ;4146
00012c  f8848042          STRB     r8,[r4,#0x42]         ;4147
000130  6c60              LDR      r0,[r4,#0x44]         ;4150
000132  f0400080          ORR      r0,r0,#0x80           ;4150
000136  6460              STR      r0,[r4,#0x44]         ;4150
000138  f8848040          STRB     r8,[r4,#0x40]         ;4153
00013c  2001              MOVS     r0,#1                 ;4155
00013e  e76c              B        |L43.26|
                  |L43.320|
000140  8d60              LDRH     r0,[r4,#0x2a]         ;4161
000142  8d21              LDRH     r1,[r4,#0x28]         ;4161
000144  1a40              SUBS     r0,r0,r1              ;4161
000146  8560              STRH     r0,[r4,#0x2a]         ;4161
000148  f8a48028          STRH     r8,[r4,#0x28]         ;4164
00014c  6820              LDR      r0,[r4,#0]            ;4181
00014e  6981              LDR      r1,[r0,#0x18]         ;4181
000150  03c9              LSLS     r1,r1,#15             ;4181
000152  d401              BMI      |L43.344|
000154  2108              MOVS     r1,#8                 ;4185
000156  61c1              STR      r1,[r0,#0x1c]         ;4185
                  |L43.344|
000158  f8848040          STRB     r8,[r4,#0x40]         ;4189
00015c  4651              MOV      r1,r10                ;4195
00015e  4620              MOV      r0,r4                 ;4195
000160  f7fffffe          BL       I2C_Enable_IRQ
000164  6820              LDR      r0,[r4,#0]            ;4198
000166  6801              LDR      r1,[r0,#0]            ;4198
000168  f4414100          ORR      r1,r1,#0x8000         ;4198
00016c  6001              STR      r1,[r0,#0]            ;4198
00016e  2000              MOVS     r0,#0                 ;4200
000170  e753              B        |L43.26|
;;;4207   
                          ENDP

000172  0000              DCW      0x0000
                  |L43.372|
                          DCD      I2C_DMAAbort
                  |L43.376|
                          DCD      I2C_Slave_ISR_DMA
                  |L43.380|
                          DCD      I2C_DMASlaveReceiveCplt
                  |L43.384|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Receive_IT PROC
;;;3941     */
;;;3942   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3943                                                  uint32_t XferOptions)
;;;3944   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3945     /* Check the parameters */
;;;3946     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3947   
;;;3948     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f8941041          LDRB     r1,[r4,#0x41]
000010  2028              MOVS     r0,#0x28
000012  4388              BICS     r0,r0,r1
000014  d002              BEQ      |L44.28|
;;;3949     {
;;;3950       if ((pData == NULL) || (Size == 0U))
;;;3951       {
;;;3952         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;3953         return  HAL_ERROR;
;;;3954       }
;;;3955   
;;;3956       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;3957       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
;;;3958   
;;;3959       /* Process Locked */
;;;3960       __HAL_LOCK(hi2c);
;;;3961   
;;;3962       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;3963       /* and then toggle the HAL slave TX state to RX state */
;;;3964       if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;3965       {
;;;3966         /* Disable associated Interrupts */
;;;3967         I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;3968   
;;;3969         if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
;;;3970         {
;;;3971           hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
;;;3972   
;;;3973           /* Abort DMA Xfer if any */
;;;3974           if (hi2c->hdmatx != NULL)
;;;3975           {
;;;3976             /* Set the I2C DMA Abort callback :
;;;3977              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;3978             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;3979   
;;;3980             /* Abort DMA TX */
;;;3981             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;3982             {
;;;3983               /* Call Directly XferAbortCallback function in case of error */
;;;3984               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;3985             }
;;;3986           }
;;;3987         }
;;;3988       }
;;;3989   
;;;3990       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;3991       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;3992       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3993   
;;;3994       /* Enable Address Acknowledge */
;;;3995       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;3996   
;;;3997       /* Prepare transfer parameters */
;;;3998       hi2c->pBuffPtr    = pData;
;;;3999       hi2c->XferCount   = Size;
;;;4000       hi2c->XferSize    = hi2c->XferCount;
;;;4001       hi2c->XferOptions = XferOptions;
;;;4002       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;4003   
;;;4004       if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
;;;4005       {
;;;4006         /* Clear ADDR flag after prepare the transfer parameters */
;;;4007         /* This action will generate an acknowledge to the Master */
;;;4008         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;4009       }
;;;4010   
;;;4011       /* Process Unlocked */
;;;4012       __HAL_UNLOCK(hi2c);
;;;4013   
;;;4014       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4015       to avoid the risk of I2C interrupt handle execution before current
;;;4016       process unlock */
;;;4017       /* REnable ADDR interrupt */
;;;4018       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
;;;4019   
;;;4020       return HAL_OK;
;;;4021     }
;;;4022     else
;;;4023     {
;;;4024       return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L44.24|
;;;4025     }
;;;4026   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L44.28|
00001c  b195              CBZ      r5,|L44.68|
00001e  b18e              CBZ      r6,|L44.68|
000020  f2480802          MOV      r8,#0x8002            ;3957
000024  4641              MOV      r1,r8                 ;3957
000026  4620              MOV      r0,r4                 ;3957
000028  f7fffffe          BL       I2C_Disable_IRQ
00002c  f8940040          LDRB     r0,[r4,#0x40]         ;3960
000030  2801              CMP      r0,#1                 ;3960
000032  d00c              BEQ      |L44.78|
000034  2001              MOVS     r0,#1                 ;3960
000036  f8840040          STRB     r0,[r4,#0x40]         ;3960
00003a  f8940041          LDRB     r0,[r4,#0x41]         ;3964
00003e  2829              CMP      r0,#0x29              ;3964
000040  d007              BEQ      |L44.82|
000042  e01d              B        |L44.128|
                  |L44.68|
000044  f44f7000          MOV      r0,#0x200             ;3952
000048  6460              STR      r0,[r4,#0x44]         ;3952
00004a  2001              MOVS     r0,#1                 ;3953
00004c  e7e4              B        |L44.24|
                  |L44.78|
00004e  2002              MOVS     r0,#2                 ;3960
000050  e7e2              B        |L44.24|
                  |L44.82|
000052  2101              MOVS     r1,#1                 ;3967
000054  4620              MOV      r0,r4                 ;3967
000056  f7fffffe          BL       I2C_Disable_IRQ
00005a  6820              LDR      r0,[r4,#0]            ;3969
00005c  6801              LDR      r1,[r0,#0]            ;3969
00005e  0449              LSLS     r1,r1,#17             ;3969
000060  d50e              BPL      |L44.128|
000062  6801              LDR      r1,[r0,#0]            ;3971
000064  f4214180          BIC      r1,r1,#0x4000         ;3971
000068  6001              STR      r1,[r0,#0]            ;3971
00006a  6ba0              LDR      r0,[r4,#0x38]         ;3974
00006c  b140              CBZ      r0,|L44.128|
00006e  4915              LDR      r1,|L44.196|
000070  6381              STR      r1,[r0,#0x38]         ;3978
000072  6ba0              LDR      r0,[r4,#0x38]         ;3981
000074  f7fffffe          BL       HAL_DMA_Abort_IT
000078  b110              CBZ      r0,|L44.128|
00007a  6ba0              LDR      r0,[r4,#0x38]         ;3984
00007c  6b81              LDR      r1,[r0,#0x38]         ;3984
00007e  4788              BLX      r1                    ;3984
                  |L44.128|
000080  202a              MOVS     r0,#0x2a              ;3990
000082  f8840041          STRB     r0,[r4,#0x41]         ;3990
000086  2020              MOVS     r0,#0x20              ;3991
000088  f8840042          STRB     r0,[r4,#0x42]         ;3991
00008c  2100              MOVS     r1,#0                 ;3992
00008e  6461              STR      r1,[r4,#0x44]         ;3992
000090  6820              LDR      r0,[r4,#0]            ;3995
000092  6842              LDR      r2,[r0,#4]            ;3995
000094  f4224200          BIC      r2,r2,#0x8000         ;3995
000098  6042              STR      r2,[r0,#4]            ;3995
00009a  6265              STR      r5,[r4,#0x24]         ;3998
00009c  8566              STRH     r6,[r4,#0x2a]         ;3999
00009e  8d60              LDRH     r0,[r4,#0x2a]         ;4000
0000a0  8520              STRH     r0,[r4,#0x28]         ;4000
0000a2  62e7              STR      r7,[r4,#0x2c]         ;4001
0000a4  4808              LDR      r0,|L44.200|
0000a6  6360              STR      r0,[r4,#0x34]         ;4002
0000a8  6820              LDR      r0,[r4,#0]            ;4004
0000aa  6982              LDR      r2,[r0,#0x18]         ;4004
0000ac  03d2              LSLS     r2,r2,#15             ;4004
0000ae  d401              BMI      |L44.180|
0000b0  2208              MOVS     r2,#8                 ;4008
0000b2  61c2              STR      r2,[r0,#0x1c]         ;4008
                  |L44.180|
0000b4  f8841040          STRB     r1,[r4,#0x40]         ;4012
0000b8  4641              MOV      r1,r8                 ;4018
0000ba  4620              MOV      r0,r4                 ;4018
0000bc  f7fffffe          BL       I2C_Enable_IRQ
0000c0  2000              MOVS     r0,#0                 ;4020
0000c2  e7a9              B        |L44.24|
;;;4027   
                          ENDP

                  |L44.196|
                          DCD      I2C_DMAAbort
                  |L44.200|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Transmit_DMA PROC
;;;3761     */
;;;3762   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3763                                                    uint32_t XferOptions)
;;;3764   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;3765     HAL_StatusTypeDef dmaxferstatus;
;;;3766   
;;;3767     /* Check the parameters */
;;;3768     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3769   
;;;3770     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f8940041          LDRB     r0,[r4,#0x41]
000010  2528              MOVS     r5,#0x28
000012  ea350000          BICS     r0,r5,r0
000016  d002              BEQ      |L45.30|
;;;3771     {
;;;3772       if ((pData == NULL) || (Size == 0U))
;;;3773       {
;;;3774         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;3775         return  HAL_ERROR;
;;;3776       }
;;;3777   
;;;3778       /* Process Locked */
;;;3779       __HAL_LOCK(hi2c);
;;;3780   
;;;3781       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;3782       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
;;;3783   
;;;3784       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;3785       /* and then toggle the HAL slave RX state to TX state */
;;;3786       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;3787       {
;;;3788         /* Disable associated Interrupts */
;;;3789         I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;3790   
;;;3791         if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
;;;3792         {
;;;3793           /* Abort DMA Xfer if any */
;;;3794           if (hi2c->hdmarx != NULL)
;;;3795           {
;;;3796             hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
;;;3797   
;;;3798             /* Set the I2C DMA Abort callback :
;;;3799              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;3800             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;3801   
;;;3802             /* Abort DMA RX */
;;;3803             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;3804             {
;;;3805               /* Call Directly XferAbortCallback function in case of error */
;;;3806               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;3807             }
;;;3808           }
;;;3809         }
;;;3810       }
;;;3811       else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;3812       {
;;;3813         if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
;;;3814         {
;;;3815           hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
;;;3816   
;;;3817           /* Abort DMA Xfer if any */
;;;3818           if (hi2c->hdmatx != NULL)
;;;3819           {
;;;3820             /* Set the I2C DMA Abort callback :
;;;3821              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;3822             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;3823   
;;;3824             /* Abort DMA TX */
;;;3825             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;3826             {
;;;3827               /* Call Directly XferAbortCallback function in case of error */
;;;3828               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;3829             }
;;;3830           }
;;;3831         }
;;;3832       }
;;;3833       else
;;;3834       {
;;;3835         /* Nothing to do */
;;;3836       }
;;;3837   
;;;3838       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;3839       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;3840       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3841   
;;;3842       /* Enable Address Acknowledge */
;;;3843       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;3844   
;;;3845       /* Prepare transfer parameters */
;;;3846       hi2c->pBuffPtr    = pData;
;;;3847       hi2c->XferCount   = Size;
;;;3848       hi2c->XferSize    = hi2c->XferCount;
;;;3849       hi2c->XferOptions = XferOptions;
;;;3850       hi2c->XferISR     = I2C_Slave_ISR_DMA;
;;;3851   
;;;3852       if (hi2c->hdmatx != NULL)
;;;3853       {
;;;3854         /* Set the I2C DMA transfer complete callback */
;;;3855         hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
;;;3856   
;;;3857         /* Set the DMA error callback */
;;;3858         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3859   
;;;3860         /* Set the unused DMA callbacks to NULL */
;;;3861         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3862         hi2c->hdmatx->XferAbortCallback = NULL;
;;;3863   
;;;3864         /* Enable the DMA channel */
;;;3865         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;3866       }
;;;3867       else
;;;3868       {
;;;3869         /* Update I2C state */
;;;3870         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;3871         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3872   
;;;3873         /* Update I2C error code */
;;;3874         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;3875   
;;;3876         /* Process Unlocked */
;;;3877         __HAL_UNLOCK(hi2c);
;;;3878   
;;;3879         return HAL_ERROR;
;;;3880       }
;;;3881   
;;;3882       if (dmaxferstatus == HAL_OK)
;;;3883       {
;;;3884         /* Update XferCount value */
;;;3885         hi2c->XferCount -= hi2c->XferSize;
;;;3886   
;;;3887         /* Reset XferSize */
;;;3888         hi2c->XferSize = 0;
;;;3889       }
;;;3890       else
;;;3891       {
;;;3892         /* Update I2C state */
;;;3893         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;3894         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3895   
;;;3896         /* Update I2C error code */
;;;3897         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3898   
;;;3899         /* Process Unlocked */
;;;3900         __HAL_UNLOCK(hi2c);
;;;3901   
;;;3902         return HAL_ERROR;
;;;3903       }
;;;3904   
;;;3905       if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
;;;3906       {
;;;3907         /* Clear ADDR flag after prepare the transfer parameters */
;;;3908         /* This action will generate an acknowledge to the Master */
;;;3909         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3910       }
;;;3911   
;;;3912       /* Process Unlocked */
;;;3913       __HAL_UNLOCK(hi2c);
;;;3914   
;;;3915       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3916       to avoid the risk of I2C interrupt handle execution before current
;;;3917       process unlock */
;;;3918       /* Enable ERR, STOP, NACK, ADDR interrupts */
;;;3919       I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;3920   
;;;3921       /* Enable DMA Request */
;;;3922       hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;3923   
;;;3924       return HAL_OK;
;;;3925     }
;;;3926     else
;;;3927     {
;;;3928       return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L45.26|
;;;3929     }
;;;3930   }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L45.30|
00001e  b1be              CBZ      r6,|L45.80|
000020  b1b7              CBZ      r7,|L45.80|
000022  f8940040          LDRB     r0,[r4,#0x40]         ;3779
000026  2801              CMP      r0,#1                 ;3779
000028  d017              BEQ      |L45.90|
00002a  2001              MOVS     r0,#1                 ;3779
00002c  f8840040          STRB     r0,[r4,#0x40]         ;3779
000030  f2480101          MOV      r1,#0x8001            ;3782
000034  4620              MOV      r0,r4                 ;3782
000036  f7fffffe          BL       I2C_Disable_IRQ
00003a  f8940041          LDRB     r0,[r4,#0x41]         ;3786
00003e  f8df9134          LDR      r9,|L45.372|
000042  282a              CMP      r0,#0x2a              ;3786
000044  d00b              BEQ      |L45.94|
000046  f8940041          LDRB     r0,[r4,#0x41]         ;3811
00004a  2829              CMP      r0,#0x29              ;3811
00004c  d020              BEQ      |L45.144|
00004e  e032              B        |L45.182|
                  |L45.80|
000050  f44f7000          MOV      r0,#0x200             ;3774
000054  6460              STR      r0,[r4,#0x44]         ;3774
000056  2001              MOVS     r0,#1                 ;3775
000058  e7df              B        |L45.26|
                  |L45.90|
00005a  2002              MOVS     r0,#2                 ;3779
00005c  e7dd              B        |L45.26|
                  |L45.94|
00005e  2102              MOVS     r1,#2                 ;3789
000060  4620              MOV      r0,r4                 ;3789
000062  f7fffffe          BL       I2C_Disable_IRQ
000066  6820              LDR      r0,[r4,#0]            ;3791
000068  6801              LDR      r1,[r0,#0]            ;3791
00006a  0409              LSLS     r1,r1,#16             ;3791
00006c  d523              BPL      |L45.182|
00006e  6be1              LDR      r1,[r4,#0x3c]         ;3794
000070  b309              CBZ      r1,|L45.182|
000072  6801              LDR      r1,[r0,#0]            ;3796
000074  f4214100          BIC      r1,r1,#0x8000         ;3796
000078  6001              STR      r1,[r0,#0]            ;3796
00007a  6be0              LDR      r0,[r4,#0x3c]         ;3800
00007c  f8c09038          STR      r9,[r0,#0x38]         ;3800
000080  6be0              LDR      r0,[r4,#0x3c]         ;3803
000082  f7fffffe          BL       HAL_DMA_Abort_IT
000086  b1b0              CBZ      r0,|L45.182|
000088  6be0              LDR      r0,[r4,#0x3c]         ;3806
00008a  6b81              LDR      r1,[r0,#0x38]         ;3806
00008c  4788              BLX      r1                    ;3806
00008e  e012              B        |L45.182|
                  |L45.144|
000090  6820              LDR      r0,[r4,#0]            ;3813
000092  6801              LDR      r1,[r0,#0]            ;3813
000094  0449              LSLS     r1,r1,#17             ;3813
000096  d50e              BPL      |L45.182|
000098  6801              LDR      r1,[r0,#0]            ;3815
00009a  f4214180          BIC      r1,r1,#0x4000         ;3815
00009e  6001              STR      r1,[r0,#0]            ;3815
0000a0  6ba0              LDR      r0,[r4,#0x38]         ;3818
0000a2  b140              CBZ      r0,|L45.182|
0000a4  f8c09038          STR      r9,[r0,#0x38]         ;3822
0000a8  6ba0              LDR      r0,[r4,#0x38]         ;3825
0000aa  f7fffffe          BL       HAL_DMA_Abort_IT
0000ae  b110              CBZ      r0,|L45.182|
0000b0  6ba0              LDR      r0,[r4,#0x38]         ;3828
0000b2  6b81              LDR      r1,[r0,#0x38]         ;3828
0000b4  4788              BLX      r1                    ;3828
                  |L45.182|
0000b6  2029              MOVS     r0,#0x29              ;3838
0000b8  f8840041          STRB     r0,[r4,#0x41]         ;3838
0000bc  2020              MOVS     r0,#0x20              ;3839
0000be  f8840042          STRB     r0,[r4,#0x42]         ;3839
0000c2  f04f0900          MOV      r9,#0                 ;3840
0000c6  f8c49044          STR      r9,[r4,#0x44]         ;3840
0000ca  6820              LDR      r0,[r4,#0]            ;3843
0000cc  6841              LDR      r1,[r0,#4]            ;3843
0000ce  f4214100          BIC      r1,r1,#0x8000         ;3843
0000d2  6041              STR      r1,[r0,#4]            ;3843
0000d4  6266              STR      r6,[r4,#0x24]         ;3846
0000d6  8567              STRH     r7,[r4,#0x2a]         ;3847
0000d8  8d60              LDRH     r0,[r4,#0x2a]         ;3848
0000da  8520              STRH     r0,[r4,#0x28]         ;3848
0000dc  f8c4802c          STR      r8,[r4,#0x2c]         ;3849
0000e0  4825              LDR      r0,|L45.376|
0000e2  6360              STR      r0,[r4,#0x34]         ;3850
0000e4  6ba0              LDR      r0,[r4,#0x38]         ;3852
0000e6  b1f0              CBZ      r0,|L45.294|
0000e8  4924              LDR      r1,|L45.380|
0000ea  62c1              STR      r1,[r0,#0x2c]         ;3855
0000ec  6ba1              LDR      r1,[r4,#0x38]         ;3858
0000ee  4824              LDR      r0,|L45.384|
0000f0  6348              STR      r0,[r1,#0x34]         ;3858
0000f2  6ba0              LDR      r0,[r4,#0x38]         ;3861
0000f4  f8c09030          STR      r9,[r0,#0x30]         ;3861
0000f8  6ba0              LDR      r0,[r4,#0x38]         ;3862
0000fa  f8c09038          STR      r9,[r0,#0x38]         ;3862
0000fe  6822              LDR      r2,[r4,#0]            ;3865
000100  8d23              LDRH     r3,[r4,#0x28]         ;3865
000102  3228              ADDS     r2,r2,#0x28           ;3865
000104  4631              MOV      r1,r6                 ;3865
000106  6ba0              LDR      r0,[r4,#0x38]         ;3865
000108  f7fffffe          BL       HAL_DMA_Start_IT
00010c  b1b8              CBZ      r0,|L45.318|
00010e  f8845041          STRB     r5,[r4,#0x41]         ;3893
000112  f8849042          STRB     r9,[r4,#0x42]         ;3894
000116  6c60              LDR      r0,[r4,#0x44]         ;3897
000118  f0400010          ORR      r0,r0,#0x10           ;3897
00011c  6460              STR      r0,[r4,#0x44]         ;3897
00011e  f8849040          STRB     r9,[r4,#0x40]         ;3900
000122  2001              MOVS     r0,#1                 ;3902
000124  e779              B        |L45.26|
                  |L45.294|
000126  f8845041          STRB     r5,[r4,#0x41]         ;3870
00012a  f8849042          STRB     r9,[r4,#0x42]         ;3871
00012e  6c60              LDR      r0,[r4,#0x44]         ;3874
000130  f0400080          ORR      r0,r0,#0x80           ;3874
000134  6460              STR      r0,[r4,#0x44]         ;3874
000136  f8849040          STRB     r9,[r4,#0x40]         ;3877
00013a  2001              MOVS     r0,#1                 ;3879
00013c  e76d              B        |L45.26|
                  |L45.318|
00013e  8d60              LDRH     r0,[r4,#0x2a]         ;3885
000140  8d21              LDRH     r1,[r4,#0x28]         ;3885
000142  1a40              SUBS     r0,r0,r1              ;3885
000144  8560              STRH     r0,[r4,#0x2a]         ;3885
000146  f8a49028          STRH     r9,[r4,#0x28]         ;3888
00014a  6820              LDR      r0,[r4,#0]            ;3905
00014c  6981              LDR      r1,[r0,#0x18]         ;3905
00014e  03c9              LSLS     r1,r1,#15             ;3905
000150  d501              BPL      |L45.342|
000152  2108              MOVS     r1,#8                 ;3909
000154  61c1              STR      r1,[r0,#0x1c]         ;3909
                  |L45.342|
000156  f8849040          STRB     r9,[r4,#0x40]         ;3913
00015a  f44f4100          MOV      r1,#0x8000            ;3919
00015e  4620              MOV      r0,r4                 ;3919
000160  f7fffffe          BL       I2C_Enable_IRQ
000164  6820              LDR      r0,[r4,#0]            ;3922
000166  6801              LDR      r1,[r0,#0]            ;3922
000168  f4414180          ORR      r1,r1,#0x4000         ;3922
00016c  6001              STR      r1,[r0,#0]            ;3922
00016e  2000              MOVS     r0,#0                 ;3924
000170  e753              B        |L45.26|
;;;3931   
                          ENDP

000172  0000              DCW      0x0000
                  |L45.372|
                          DCD      I2C_DMAAbort
                  |L45.376|
                          DCD      I2C_Slave_ISR_DMA
                  |L45.380|
                          DCD      I2C_DMASlaveTransmitCplt
                  |L45.384|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Transmit_IT PROC
;;;3665     */
;;;3666   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3667                                                   uint32_t XferOptions)
;;;3668   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3669     /* Check the parameters */
;;;3670     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3671   
;;;3672     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f8941041          LDRB     r1,[r4,#0x41]
000010  2028              MOVS     r0,#0x28
000012  4388              BICS     r0,r0,r1
000014  d002              BEQ      |L46.28|
;;;3673     {
;;;3674       if ((pData == NULL) || (Size == 0U))
;;;3675       {
;;;3676         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;3677         return  HAL_ERROR;
;;;3678       }
;;;3679   
;;;3680       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;3681       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
;;;3682   
;;;3683       /* Process Locked */
;;;3684       __HAL_LOCK(hi2c);
;;;3685   
;;;3686       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;3687       /* and then toggle the HAL slave RX state to TX state */
;;;3688       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;3689       {
;;;3690         /* Disable associated Interrupts */
;;;3691         I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;3692   
;;;3693         /* Abort DMA Xfer if any */
;;;3694         if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
;;;3695         {
;;;3696           hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
;;;3697   
;;;3698           if (hi2c->hdmarx != NULL)
;;;3699           {
;;;3700             /* Set the I2C DMA Abort callback :
;;;3701              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;3702             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;3703   
;;;3704             /* Abort DMA RX */
;;;3705             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;3706             {
;;;3707               /* Call Directly XferAbortCallback function in case of error */
;;;3708               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;3709             }
;;;3710           }
;;;3711         }
;;;3712       }
;;;3713   
;;;3714       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;3715       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;3716       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3717   
;;;3718       /* Enable Address Acknowledge */
;;;3719       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;3720   
;;;3721       /* Prepare transfer parameters */
;;;3722       hi2c->pBuffPtr    = pData;
;;;3723       hi2c->XferCount   = Size;
;;;3724       hi2c->XferSize    = hi2c->XferCount;
;;;3725       hi2c->XferOptions = XferOptions;
;;;3726       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;3727   
;;;3728       if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
;;;3729       {
;;;3730         /* Clear ADDR flag after prepare the transfer parameters */
;;;3731         /* This action will generate an acknowledge to the Master */
;;;3732         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3733       }
;;;3734   
;;;3735       /* Process Unlocked */
;;;3736       __HAL_UNLOCK(hi2c);
;;;3737   
;;;3738       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3739       to avoid the risk of I2C interrupt handle execution before current
;;;3740       process unlock */
;;;3741       /* REnable ADDR interrupt */
;;;3742       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
;;;3743   
;;;3744       return HAL_OK;
;;;3745     }
;;;3746     else
;;;3747     {
;;;3748       return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L46.24|
;;;3749     }
;;;3750   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L46.28|
00001c  b195              CBZ      r5,|L46.68|
00001e  b18e              CBZ      r6,|L46.68|
000020  f2480801          MOV      r8,#0x8001            ;3681
000024  4641              MOV      r1,r8                 ;3681
000026  4620              MOV      r0,r4                 ;3681
000028  f7fffffe          BL       I2C_Disable_IRQ
00002c  f8940040          LDRB     r0,[r4,#0x40]         ;3684
000030  2801              CMP      r0,#1                 ;3684
000032  d00c              BEQ      |L46.78|
000034  2001              MOVS     r0,#1                 ;3684
000036  f8840040          STRB     r0,[r4,#0x40]         ;3684
00003a  f8940041          LDRB     r0,[r4,#0x41]         ;3688
00003e  282a              CMP      r0,#0x2a              ;3688
000040  d007              BEQ      |L46.82|
000042  e01d              B        |L46.128|
                  |L46.68|
000044  f44f7000          MOV      r0,#0x200             ;3676
000048  6460              STR      r0,[r4,#0x44]         ;3676
00004a  2001              MOVS     r0,#1                 ;3677
00004c  e7e4              B        |L46.24|
                  |L46.78|
00004e  2002              MOVS     r0,#2                 ;3684
000050  e7e2              B        |L46.24|
                  |L46.82|
000052  2102              MOVS     r1,#2                 ;3691
000054  4620              MOV      r0,r4                 ;3691
000056  f7fffffe          BL       I2C_Disable_IRQ
00005a  6820              LDR      r0,[r4,#0]            ;3694
00005c  6801              LDR      r1,[r0,#0]            ;3694
00005e  0409              LSLS     r1,r1,#16             ;3694
000060  d50e              BPL      |L46.128|
000062  6801              LDR      r1,[r0,#0]            ;3696
000064  f4214100          BIC      r1,r1,#0x8000         ;3696
000068  6001              STR      r1,[r0,#0]            ;3696
00006a  6be0              LDR      r0,[r4,#0x3c]         ;3698
00006c  b140              CBZ      r0,|L46.128|
00006e  4915              LDR      r1,|L46.196|
000070  6381              STR      r1,[r0,#0x38]         ;3702
000072  6be0              LDR      r0,[r4,#0x3c]         ;3705
000074  f7fffffe          BL       HAL_DMA_Abort_IT
000078  b110              CBZ      r0,|L46.128|
00007a  6be0              LDR      r0,[r4,#0x3c]         ;3708
00007c  6b81              LDR      r1,[r0,#0x38]         ;3708
00007e  4788              BLX      r1                    ;3708
                  |L46.128|
000080  2029              MOVS     r0,#0x29              ;3714
000082  f8840041          STRB     r0,[r4,#0x41]         ;3714
000086  2020              MOVS     r0,#0x20              ;3715
000088  f8840042          STRB     r0,[r4,#0x42]         ;3715
00008c  2100              MOVS     r1,#0                 ;3716
00008e  6461              STR      r1,[r4,#0x44]         ;3716
000090  6820              LDR      r0,[r4,#0]            ;3719
000092  6842              LDR      r2,[r0,#4]            ;3719
000094  f4224200          BIC      r2,r2,#0x8000         ;3719
000098  6042              STR      r2,[r0,#4]            ;3719
00009a  6265              STR      r5,[r4,#0x24]         ;3722
00009c  8566              STRH     r6,[r4,#0x2a]         ;3723
00009e  8d60              LDRH     r0,[r4,#0x2a]         ;3724
0000a0  8520              STRH     r0,[r4,#0x28]         ;3724
0000a2  62e7              STR      r7,[r4,#0x2c]         ;3725
0000a4  4808              LDR      r0,|L46.200|
0000a6  6360              STR      r0,[r4,#0x34]         ;3726
0000a8  6820              LDR      r0,[r4,#0]            ;3728
0000aa  6982              LDR      r2,[r0,#0x18]         ;3728
0000ac  03d2              LSLS     r2,r2,#15             ;3728
0000ae  d501              BPL      |L46.180|
0000b0  2208              MOVS     r2,#8                 ;3732
0000b2  61c2              STR      r2,[r0,#0x1c]         ;3732
                  |L46.180|
0000b4  f8841040          STRB     r1,[r4,#0x40]         ;3736
0000b8  4641              MOV      r1,r8                 ;3742
0000ba  4620              MOV      r0,r4                 ;3742
0000bc  f7fffffe          BL       I2C_Enable_IRQ
0000c0  2000              MOVS     r0,#0                 ;3744
0000c2  e7a9              B        |L46.24|
;;;3751   
                          ENDP

                  |L46.196|
                          DCD      I2C_DMAAbort
                  |L46.200|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_Slave_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Transmit PROC
;;;1296     */
;;;1297   HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1298   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  4698              MOV      r8,r3
;;;1299     uint32_t tickstart;
;;;1300   
;;;1301     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f8940041          LDRB     r0,[r4,#0x41]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L47.26|
;;;1302     {
;;;1303       if ((pData == NULL) || (Size == 0U))
;;;1304       {
;;;1305         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;1306         return  HAL_ERROR;
;;;1307       }
;;;1308       /* Process Locked */
;;;1309       __HAL_LOCK(hi2c);
;;;1310   
;;;1311       /* Init tickstart for timeout management*/
;;;1312       tickstart = HAL_GetTick();
;;;1313   
;;;1314       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1315       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1316       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1317   
;;;1318       /* Prepare transfer parameters */
;;;1319       hi2c->pBuffPtr  = pData;
;;;1320       hi2c->XferCount = Size;
;;;1321       hi2c->XferISR   = NULL;
;;;1322   
;;;1323       /* Enable Address Acknowledge */
;;;1324       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1325   
;;;1326       /* Wait until ADDR flag is set */
;;;1327       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1328       {
;;;1329         /* Disable Address Acknowledge */
;;;1330         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1331         return HAL_ERROR;
;;;1332       }
;;;1333   
;;;1334       /* Clear ADDR flag */
;;;1335       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;1336   
;;;1337       /* If 10bit addressing mode is selected */
;;;1338       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;1339       {
;;;1340         /* Wait until ADDR flag is set */
;;;1341         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1342         {
;;;1343           /* Disable Address Acknowledge */
;;;1344           hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1345           return HAL_ERROR;
;;;1346         }
;;;1347   
;;;1348         /* Clear ADDR flag */
;;;1349         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;1350       }
;;;1351   
;;;1352       /* Wait until DIR flag is set Transmitter mode */
;;;1353       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
;;;1354       {
;;;1355         /* Disable Address Acknowledge */
;;;1356         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1357         return HAL_ERROR;
;;;1358       }
;;;1359   
;;;1360       while (hi2c->XferCount > 0U)
;;;1361       {
;;;1362         /* Wait until TXIS flag is set */
;;;1363         if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1364         {
;;;1365           /* Disable Address Acknowledge */
;;;1366           hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1367           return HAL_ERROR;
;;;1368         }
;;;1369   
;;;1370         /* Write data to TXDR */
;;;1371         hi2c->Instance->TXDR = *hi2c->pBuffPtr;
;;;1372   
;;;1373         /* Increment Buffer pointer */
;;;1374         hi2c->pBuffPtr++;
;;;1375   
;;;1376         hi2c->XferCount--;
;;;1377       }
;;;1378   
;;;1379       /* Wait until STOP flag is set */
;;;1380       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1381       {
;;;1382         /* Disable Address Acknowledge */
;;;1383         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1384   
;;;1385         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1386         {
;;;1387           /* Normal use case for Transmitter mode */
;;;1388           /* A NACK is generated to confirm the end of transfer */
;;;1389           hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1390         }
;;;1391         else
;;;1392         {
;;;1393           return HAL_ERROR;
;;;1394         }
;;;1395       }
;;;1396   
;;;1397       /* Clear STOP flag */
;;;1398       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;1399   
;;;1400       /* Wait until BUSY flag is reset */
;;;1401       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
;;;1402       {
;;;1403         /* Disable Address Acknowledge */
;;;1404         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1405         return HAL_ERROR;
;;;1406       }
;;;1407   
;;;1408       /* Disable Address Acknowledge */
;;;1409       hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1410   
;;;1411       hi2c->State = HAL_I2C_STATE_READY;
;;;1412       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;1413   
;;;1414       /* Process Unlocked */
;;;1415       __HAL_UNLOCK(hi2c);
;;;1416   
;;;1417       return HAL_OK;
;;;1418     }
;;;1419     else
;;;1420     {
;;;1421       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L47.22|
;;;1422     }
;;;1423   }
000016  e8bd8ff8          POP      {r3-r11,pc}
                  |L47.26|
00001a  f1b90f00          CMP      r9,#0                 ;1303
00001e  d02d              BEQ      |L47.124|
000020  f1ba0f00          CMP      r10,#0                ;1303
000024  d02a              BEQ      |L47.124|
000026  f8940040          LDRB     r0,[r4,#0x40]         ;1309
00002a  2801              CMP      r0,#1                 ;1309
00002c  d02b              BEQ      |L47.134|
00002e  2001              MOVS     r0,#1                 ;1309
000030  f8840040          STRB     r0,[r4,#0x40]         ;1309
000034  f7fffffe          BL       HAL_GetTick
000038  4605              MOV      r5,r0                 ;1312
00003a  2021              MOVS     r0,#0x21              ;1314
00003c  f8840041          STRB     r0,[r4,#0x41]         ;1314
000040  2720              MOVS     r7,#0x20              ;1315
000042  f8847042          STRB     r7,[r4,#0x42]         ;1315
000046  2600              MOVS     r6,#0                 ;1316
000048  6466              STR      r6,[r4,#0x44]         ;1316
00004a  f8c49024          STR      r9,[r4,#0x24]         ;1319
00004e  f8a4a02a          STRH     r10,[r4,#0x2a]        ;1320
000052  6366              STR      r6,[r4,#0x34]         ;1321
000054  6820              LDR      r0,[r4,#0]            ;1324
000056  6841              LDR      r1,[r0,#4]            ;1324
000058  f4214100          BIC      r1,r1,#0x8000         ;1324
00005c  6041              STR      r1,[r0,#4]            ;1324
00005e  4643              MOV      r3,r8                 ;1327
000060  2200              MOVS     r2,#0                 ;1327
000062  2108              MOVS     r1,#8                 ;1327
000064  4620              MOV      r0,r4                 ;1327
000066  9500              STR      r5,[sp,#0]            ;1327
000068  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00006c  b168              CBZ      r0,|L47.138|
00006e  6820              LDR      r0,[r4,#0]            ;1330
000070  6841              LDR      r1,[r0,#4]            ;1330
000072  f4414100          ORR      r1,r1,#0x8000         ;1330
000076  6041              STR      r1,[r0,#4]            ;1330
000078  2001              MOVS     r0,#1                 ;1331
00007a  e7cc              B        |L47.22|
                  |L47.124|
00007c  f44f7000          MOV      r0,#0x200             ;1305
000080  6460              STR      r0,[r4,#0x44]         ;1305
000082  2001              MOVS     r0,#1                 ;1306
000084  e7c7              B        |L47.22|
                  |L47.134|
000086  2002              MOVS     r0,#2                 ;1309
000088  e7c5              B        |L47.22|
                  |L47.138|
00008a  6820              LDR      r0,[r4,#0]            ;1335
00008c  f04f0908          MOV      r9,#8                 ;1335
000090  f8c0901c          STR      r9,[r0,#0x1c]         ;1335
000094  68e0              LDR      r0,[r4,#0xc]          ;1338
000096  2802              CMP      r0,#2                 ;1338
000098  d111              BNE      |L47.190|
00009a  4643              MOV      r3,r8                 ;1341
00009c  2200              MOVS     r2,#0                 ;1341
00009e  2108              MOVS     r1,#8                 ;1341
0000a0  4620              MOV      r0,r4                 ;1341
0000a2  9500              STR      r5,[sp,#0]            ;1341
0000a4  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000a8  b130              CBZ      r0,|L47.184|
0000aa  6820              LDR      r0,[r4,#0]            ;1344
0000ac  6841              LDR      r1,[r0,#4]            ;1344
0000ae  f4414100          ORR      r1,r1,#0x8000         ;1344
0000b2  6041              STR      r1,[r0,#4]            ;1344
0000b4  2001              MOVS     r0,#1                 ;1345
0000b6  e7ae              B        |L47.22|
                  |L47.184|
0000b8  6820              LDR      r0,[r4,#0]            ;1349
0000ba  f8c0901c          STR      r9,[r0,#0x1c]         ;1349
                  |L47.190|
0000be  4643              MOV      r3,r8                 ;1353
0000c0  2200              MOVS     r2,#0                 ;1353
0000c2  f44f3180          MOV      r1,#0x10000           ;1353
0000c6  4620              MOV      r0,r4                 ;1353
0000c8  9500              STR      r5,[sp,#0]            ;1353
0000ca  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000ce  b1e8              CBZ      r0,|L47.268|
0000d0  6820              LDR      r0,[r4,#0]            ;1356
0000d2  6841              LDR      r1,[r0,#4]            ;1356
0000d4  f4414100          ORR      r1,r1,#0x8000         ;1356
0000d8  6041              STR      r1,[r0,#4]            ;1356
0000da  2001              MOVS     r0,#1                 ;1357
0000dc  e79b              B        |L47.22|
                  |L47.222|
0000de  462a              MOV      r2,r5                 ;1363
0000e0  4641              MOV      r1,r8                 ;1363
0000e2  4620              MOV      r0,r4                 ;1363
0000e4  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
0000e8  b130              CBZ      r0,|L47.248|
0000ea  6820              LDR      r0,[r4,#0]            ;1366
0000ec  6841              LDR      r1,[r0,#4]            ;1366
0000ee  f4414100          ORR      r1,r1,#0x8000         ;1366
0000f2  6041              STR      r1,[r0,#4]            ;1366
0000f4  2001              MOVS     r0,#1                 ;1367
0000f6  e78e              B        |L47.22|
                  |L47.248|
0000f8  6a60              LDR      r0,[r4,#0x24]         ;1371
0000fa  6821              LDR      r1,[r4,#0]            ;1371
0000fc  7800              LDRB     r0,[r0,#0]            ;1371
0000fe  6288              STR      r0,[r1,#0x28]         ;1371
000100  6a60              LDR      r0,[r4,#0x24]         ;1374
000102  1c40              ADDS     r0,r0,#1              ;1374
000104  6260              STR      r0,[r4,#0x24]         ;1374
000106  8d60              LDRH     r0,[r4,#0x2a]         ;1376
000108  1e40              SUBS     r0,r0,#1              ;1376
00010a  8560              STRH     r0,[r4,#0x2a]         ;1376
                  |L47.268|
00010c  8d60              LDRH     r0,[r4,#0x2a]         ;1360
00010e  2800              CMP      r0,#0                 ;1360
000110  d1e5              BNE      |L47.222|
000112  462a              MOV      r2,r5                 ;1380
000114  4641              MOV      r1,r8                 ;1380
000116  4620              MOV      r0,r4                 ;1380
000118  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00011c  b150              CBZ      r0,|L47.308|
00011e  6820              LDR      r0,[r4,#0]            ;1383
000120  6841              LDR      r1,[r0,#4]            ;1383
000122  f4414100          ORR      r1,r1,#0x8000         ;1383
000126  6041              STR      r1,[r0,#4]            ;1383
000128  6c60              LDR      r0,[r4,#0x44]         ;1385
00012a  2804              CMP      r0,#4                 ;1385
00012c  d001              BEQ      |L47.306|
00012e  2001              MOVS     r0,#1                 ;1393
000130  e771              B        |L47.22|
                  |L47.306|
000132  6466              STR      r6,[r4,#0x44]         ;1389
                  |L47.308|
000134  6820              LDR      r0,[r4,#0]            ;1398
000136  61c7              STR      r7,[r0,#0x1c]         ;1398
000138  2201              MOVS     r2,#1                 ;1401
00013a  4643              MOV      r3,r8                 ;1401
00013c  03d1              LSLS     r1,r2,#15             ;1401
00013e  4620              MOV      r0,r4                 ;1401
000140  9500              STR      r5,[sp,#0]            ;1401
000142  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000146  b130              CBZ      r0,|L47.342|
000148  6820              LDR      r0,[r4,#0]            ;1404
00014a  6841              LDR      r1,[r0,#4]            ;1404
00014c  f4414100          ORR      r1,r1,#0x8000         ;1404
000150  6041              STR      r1,[r0,#4]            ;1404
000152  2001              MOVS     r0,#1                 ;1405
000154  e75f              B        |L47.22|
                  |L47.342|
000156  3423              ADDS     r4,r4,#0x23           ;1409
000158  f8540c23          LDR      r0,[r4,#-0x23]        ;1409
00015c  6841              LDR      r1,[r0,#4]            ;1409
00015e  f4414100          ORR      r1,r1,#0x8000         ;1409
000162  6041              STR      r1,[r0,#4]            ;1409
000164  77a7              STRB     r7,[r4,#0x1e]         ;1411
000166  77e6              STRB     r6,[r4,#0x1f]         ;1412
000168  7766              STRB     r6,[r4,#0x1d]         ;1415
00016a  2000              MOVS     r0,#0                 ;1417
00016c  e753              B        |L47.22|
;;;1424   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_DMA PROC
;;;2082     */
;;;2083   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;2084   {
000002  4604              MOV      r4,r0
;;;2085     HAL_StatusTypeDef dmaxferstatus;
;;;2086   
;;;2087     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f8940041          LDRB     r0,[r4,#0x41]
000008  2820              CMP      r0,#0x20
00000a  d001              BEQ      |L48.16|
;;;2088     {
;;;2089       if ((pData == NULL) || (Size == 0U))
;;;2090       {
;;;2091         hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
;;;2092         return  HAL_ERROR;
;;;2093       }
;;;2094       /* Process Locked */
;;;2095       __HAL_LOCK(hi2c);
;;;2096   
;;;2097       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;2098       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;2099       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2100   
;;;2101       /* Prepare transfer parameters */
;;;2102       hi2c->pBuffPtr    = pData;
;;;2103       hi2c->XferCount   = Size;
;;;2104       hi2c->XferSize    = hi2c->XferCount;
;;;2105       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2106       hi2c->XferISR     = I2C_Slave_ISR_DMA;
;;;2107   
;;;2108       if (hi2c->hdmatx != NULL)
;;;2109       {
;;;2110         /* Set the I2C DMA transfer complete callback */
;;;2111         hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
;;;2112   
;;;2113         /* Set the DMA error callback */
;;;2114         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2115   
;;;2116         /* Set the unused DMA callbacks to NULL */
;;;2117         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2118         hi2c->hdmatx->XferAbortCallback = NULL;
;;;2119   
;;;2120         /* Enable the DMA channel */
;;;2121         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;2122       }
;;;2123       else
;;;2124       {
;;;2125         /* Update I2C state */
;;;2126         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;2127         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2128   
;;;2129         /* Update I2C error code */
;;;2130         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2131   
;;;2132         /* Process Unlocked */
;;;2133         __HAL_UNLOCK(hi2c);
;;;2134   
;;;2135         return HAL_ERROR;
;;;2136       }
;;;2137   
;;;2138       if (dmaxferstatus == HAL_OK)
;;;2139       {
;;;2140         /* Enable Address Acknowledge */
;;;2141         hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;2142   
;;;2143         /* Process Unlocked */
;;;2144         __HAL_UNLOCK(hi2c);
;;;2145   
;;;2146         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2147                   to avoid the risk of I2C interrupt handle execution before current
;;;2148                   process unlock */
;;;2149         /* Enable ERR, STOP, NACK, ADDR interrupts */
;;;2150         I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;2151   
;;;2152         /* Enable DMA Request */
;;;2153         hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;2154       }
;;;2155       else
;;;2156       {
;;;2157         /* Update I2C state */
;;;2158         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;2159         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2160   
;;;2161         /* Update I2C error code */
;;;2162         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2163   
;;;2164         /* Process Unlocked */
;;;2165         __HAL_UNLOCK(hi2c);
;;;2166   
;;;2167         return HAL_ERROR;
;;;2168       }
;;;2169   
;;;2170       return HAL_OK;
;;;2171     }
;;;2172     else
;;;2173     {
;;;2174       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;2175     }
;;;2176   }
00000e  bd70              POP      {r4-r6,pc}
                  |L48.16|
000010  b399              CBZ      r1,|L48.122|
000012  b392              CBZ      r2,|L48.122|
000014  f8940040          LDRB     r0,[r4,#0x40]         ;2095
000018  2801              CMP      r0,#1                 ;2095
00001a  d034              BEQ      |L48.134|
00001c  2001              MOVS     r0,#1                 ;2095
00001e  3424              ADDS     r4,r4,#0x24           ;2095
000020  7720              STRB     r0,[r4,#0x1c]         ;2095
000022  2021              MOVS     r0,#0x21              ;2097
000024  7760              STRB     r0,[r4,#0x1d]         ;2097
000026  2020              MOVS     r0,#0x20              ;2098
000028  77a0              STRB     r0,[r4,#0x1e]         ;2098
00002a  2500              MOVS     r5,#0                 ;2099
00002c  6225              STR      r5,[r4,#0x20]         ;2099
00002e  6021              STR      r1,[r4,#0]            ;2102
000030  80e2              STRH     r2,[r4,#6]            ;2103
000032  88e0              LDRH     r0,[r4,#6]            ;2104
000034  80a0              STRH     r0,[r4,#4]            ;2104
000036  4823              LDR      r0,|L48.196|
000038  60a0              STR      r0,[r4,#8]            ;2105
00003a  4823              LDR      r0,|L48.200|
00003c  6120              STR      r0,[r4,#0x10]         ;2106
00003e  6960              LDR      r0,[r4,#0x14]         ;2108
000040  3c24              SUBS     r4,r4,#0x24           ;2108
000042  2628              MOVS     r6,#0x28              ;2126
000044  b308              CBZ      r0,|L48.138|
000046  4a21              LDR      r2,|L48.204|
000048  62c2              STR      r2,[r0,#0x2c]         ;2111
00004a  6ba2              LDR      r2,[r4,#0x38]         ;2114
00004c  4820              LDR      r0,|L48.208|
00004e  6350              STR      r0,[r2,#0x34]         ;2114
000050  6ba0              LDR      r0,[r4,#0x38]         ;2117
000052  6305              STR      r5,[r0,#0x30]         ;2117
000054  6ba0              LDR      r0,[r4,#0x38]         ;2118
000056  6385              STR      r5,[r0,#0x38]         ;2118
000058  6822              LDR      r2,[r4,#0]            ;2121
00005a  8d23              LDRH     r3,[r4,#0x28]         ;2121
00005c  3228              ADDS     r2,r2,#0x28           ;2121
00005e  6ba0              LDR      r0,[r4,#0x38]         ;2121
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  b1d8              CBZ      r0,|L48.158|
000066  3440              ADDS     r4,r4,#0x40           ;2158
000068  7066              STRB     r6,[r4,#1]            ;2158
00006a  70a5              STRB     r5,[r4,#2]            ;2159
00006c  6860              LDR      r0,[r4,#4]            ;2162
00006e  f0400010          ORR      r0,r0,#0x10           ;2162
000072  6060              STR      r0,[r4,#4]            ;2162
000074  7025              STRB     r5,[r4,#0]            ;2165
000076  2001              MOVS     r0,#1                 ;2167
                  |L48.120|
000078  bd70              POP      {r4-r6,pc}
                  |L48.122|
00007a  e7ff              B        |L48.124|
                  |L48.124|
00007c  f44f7000          MOV      r0,#0x200             ;2091
000080  6460              STR      r0,[r4,#0x44]         ;2091
000082  2001              MOVS     r0,#1                 ;2092
000084  e7f8              B        |L48.120|
                  |L48.134|
000086  2002              MOVS     r0,#2                 ;2095
000088  e7f6              B        |L48.120|
                  |L48.138|
00008a  3440              ADDS     r4,r4,#0x40           ;2126
00008c  7066              STRB     r6,[r4,#1]            ;2126
00008e  70a5              STRB     r5,[r4,#2]            ;2127
000090  6860              LDR      r0,[r4,#4]            ;2130
000092  f0400080          ORR      r0,r0,#0x80           ;2130
000096  6060              STR      r0,[r4,#4]            ;2130
000098  7025              STRB     r5,[r4,#0]            ;2133
00009a  2001              MOVS     r0,#1                 ;2135
00009c  e7ec              B        |L48.120|
                  |L48.158|
00009e  6820              LDR      r0,[r4,#0]            ;2141
0000a0  6841              LDR      r1,[r0,#4]            ;2141
0000a2  f4214100          BIC      r1,r1,#0x8000         ;2141
0000a6  6041              STR      r1,[r0,#4]            ;2141
0000a8  f8845040          STRB     r5,[r4,#0x40]         ;2144
0000ac  f44f4100          MOV      r1,#0x8000            ;2150
0000b0  4620              MOV      r0,r4                 ;2150
0000b2  f7fffffe          BL       I2C_Enable_IRQ
0000b6  6820              LDR      r0,[r4,#0]            ;2153
0000b8  6801              LDR      r1,[r0,#0]            ;2153
0000ba  f4414180          ORR      r1,r1,#0x4000         ;2153
0000be  6001              STR      r1,[r0,#0]            ;2153
0000c0  2000              MOVS     r0,#0                 ;2170
0000c2  e7d9              B        |L48.120|
;;;2177   
                          ENDP

                  |L48.196|
                          DCD      0xffff0000
                  |L48.200|
                          DCD      I2C_Slave_ISR_DMA
                  |L48.204|
                          DCD      I2C_DMASlaveTransmitCplt
                  |L48.208|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_IT PROC
;;;1696     */
;;;1697   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1698   {
;;;1699     if (hi2c->State == HAL_I2C_STATE_READY)
000002  f8903041          LDRB     r3,[r0,#0x41]
000006  2b20              CMP      r3,#0x20
000008  d001              BEQ      |L49.14|
;;;1700     {
;;;1701       /* Process Locked */
;;;1702       __HAL_LOCK(hi2c);
;;;1703   
;;;1704       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1705       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1706       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1707   
;;;1708       /* Enable Address Acknowledge */
;;;1709       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1710   
;;;1711       /* Prepare transfer parameters */
;;;1712       hi2c->pBuffPtr    = pData;
;;;1713       hi2c->XferCount   = Size;
;;;1714       hi2c->XferSize    = hi2c->XferCount;
;;;1715       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1716       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;1717   
;;;1718       /* Process Unlocked */
;;;1719       __HAL_UNLOCK(hi2c);
;;;1720   
;;;1721       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1722                 to avoid the risk of I2C interrupt handle execution before current
;;;1723                 process unlock */
;;;1724   
;;;1725       /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;1726       /* possible to enable all of these */
;;;1727       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1728       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
;;;1729   
;;;1730       return HAL_OK;
;;;1731     }
;;;1732     else
;;;1733     {
;;;1734       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;1735     }
;;;1736   }
00000c  bd70              POP      {r4-r6,pc}
                  |L49.14|
00000e  f8903040          LDRB     r3,[r0,#0x40]         ;1702
000012  2b01              CMP      r3,#1                 ;1702
000014  d01e              BEQ      |L49.84|
000016  2301              MOVS     r3,#1                 ;1702
000018  3024              ADDS     r0,r0,#0x24           ;1702
00001a  7703              STRB     r3,[r0,#0x1c]         ;1702
00001c  2321              MOVS     r3,#0x21              ;1704
00001e  7743              STRB     r3,[r0,#0x1d]         ;1704
000020  2320              MOVS     r3,#0x20              ;1705
000022  7783              STRB     r3,[r0,#0x1e]         ;1705
000024  2400              MOVS     r4,#0                 ;1706
000026  6204              STR      r4,[r0,#0x20]         ;1706
000028  f8503c24          LDR      r3,[r0,#-0x24]        ;1709
00002c  685d              LDR      r5,[r3,#4]            ;1709
00002e  f4254500          BIC      r5,r5,#0x8000         ;1709
000032  605d              STR      r5,[r3,#4]            ;1709
000034  6001              STR      r1,[r0,#0]            ;1712
000036  80c2              STRH     r2,[r0,#6]            ;1713
000038  88c1              LDRH     r1,[r0,#6]            ;1714
00003a  8081              STRH     r1,[r0,#4]            ;1714
00003c  4906              LDR      r1,|L49.88|
00003e  6081              STR      r1,[r0,#8]            ;1715
000040  4906              LDR      r1,|L49.92|
000042  6101              STR      r1,[r0,#0x10]         ;1716
000044  7704              STRB     r4,[r0,#0x1c]         ;1719
000046  3824              SUBS     r0,r0,#0x24           ;1719
000048  f2480101          MOV      r1,#0x8001            ;1728
00004c  f7fffffe          BL       I2C_Enable_IRQ
000050  2000              MOVS     r0,#0                 ;1730
000052  bd70              POP      {r4-r6,pc}
                  |L49.84|
000054  2002              MOVS     r0,#2                 ;1702
000056  bd70              POP      {r4-r6,pc}
;;;1737   
                          ENDP

                  |L49.88|
                          DCD      0xffff0000
                  |L49.92|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.I2C_ConvertOtherXferOptions||, CODE, READONLY, ALIGN=1

                  I2C_ConvertOtherXferOptions PROC
;;;6609     */
;;;6610   static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;6611   {
;;;6612     /* if user set XferOptions to I2C_OTHER_FRAME            */
;;;6613     /* it request implicitly to generate a restart condition */
;;;6614     /* set XferOptions to I2C_FIRST_FRAME                    */
;;;6615     if (hi2c->XferOptions == I2C_OTHER_FRAME)
000002  29aa              CMP      r1,#0xaa
000004  d007              BEQ      |L50.22|
;;;6616     {
;;;6617       hi2c->XferOptions = I2C_FIRST_FRAME;
;;;6618     }
;;;6619     /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
;;;6620     /* it request implicitly to generate a restart condition    */
;;;6621     /* then generate a stop condition at the end of transfer    */
;;;6622     /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
;;;6623     else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
000006  6ac1              LDR      r1,[r0,#0x2c]
000008  f5b14f2a          CMP      r1,#0xaa00
00000c  d102              BNE      |L50.20|
;;;6624     {
;;;6625       hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
00000e  f04f7100          MOV      r1,#0x2000000
000012  62c1              STR      r1,[r0,#0x2c]
                  |L50.20|
;;;6626     }
;;;6627     else
;;;6628     {
;;;6629       /* Nothing to do */
;;;6630     }
;;;6631   }
000014  4770              BX       lr
                  |L50.22|
000016  2100              MOVS     r1,#0                 ;6617
000018  62c1              STR      r1,[r0,#0x2c]         ;6617
00001a  4770              BX       lr
;;;6632   
                          ENDP


                          AREA ||i.I2C_DMAAbort||, CODE, READONLY, ALIGN=1

                  I2C_DMAAbort PROC
;;;6192     */
;;;6193   static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
000000  6a80              LDR      r0,[r0,#0x28]
;;;6194   {
;;;6195     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
;;;6196   
;;;6197     /* Reset AbortCpltCallback */
;;;6198     if (hi2c->hdmatx != NULL)
000002  2200              MOVS     r2,#0
000004  6b81              LDR      r1,[r0,#0x38]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L51.12|
;;;6199     {
;;;6200       hi2c->hdmatx->XferAbortCallback = NULL;
00000a  638a              STR      r2,[r1,#0x38]
                  |L51.12|
;;;6201     }
;;;6202     if (hi2c->hdmarx != NULL)
00000c  6bc1              LDR      r1,[r0,#0x3c]
00000e  b101              CBZ      r1,|L51.18|
;;;6203     {
;;;6204       hi2c->hdmarx->XferAbortCallback = NULL;
000010  638a              STR      r2,[r1,#0x38]
                  |L51.18|
;;;6205     }
;;;6206   
;;;6207     I2C_TreatErrorCallback(hi2c);
000012  f7ffbffe          B.W      I2C_TreatErrorCallback
;;;6208   }
;;;6209   
                          ENDP


                          AREA ||i.I2C_DMAError||, CODE, READONLY, ALIGN=1

                  I2C_DMAError PROC
;;;6175     */
;;;6176   static void I2C_DMAError(DMA_HandleTypeDef *hdma)
000000  6a80              LDR      r0,[r0,#0x28]
;;;6177   {
;;;6178     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
;;;6179   
;;;6180     /* Disable Acknowledge */
;;;6181     hi2c->Instance->CR2 |= I2C_CR2_NACK;
000002  6801              LDR      r1,[r0,#0]
000004  684a              LDR      r2,[r1,#4]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  604a              STR      r2,[r1,#4]
;;;6182   
;;;6183     /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6184     I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
00000c  2110              MOVS     r1,#0x10
00000e  f7ffbffe          B.W      I2C_ITError
;;;6185   }
;;;6186   
                          ENDP


                          AREA ||i.I2C_DMAMasterReceiveCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAMasterReceiveCplt PROC
;;;6100     */
;;;6101   static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6102   {
;;;6103     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a84              LDR      r4,[r0,#0x28]
;;;6104   
;;;6105     /* Disable DMA Request */
;;;6106     hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f4214100          BIC      r1,r1,#0x8000
00000c  6001              STR      r1,[r0,#0]
;;;6107   
;;;6108     /* If last transfer, enable STOP interrupt */
;;;6109     if (hi2c->XferCount == 0U)
00000e  8d60              LDRH     r0,[r4,#0x2a]
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L53.40|
;;;6110     {
;;;6111       /* Enable STOP interrupt */
;;;6112       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
;;;6113     }
;;;6114     /* else prepare a new DMA transfer and enable TCReload interrupt */
;;;6115     else
;;;6116     {
;;;6117       /* Update Buffer pointer */
;;;6118       hi2c->pBuffPtr += hi2c->XferSize;
000014  8d21              LDRH     r1,[r4,#0x28]
000016  6a60              LDR      r0,[r4,#0x24]
000018  1842              ADDS     r2,r0,r1
00001a  6262              STR      r2,[r4,#0x24]
;;;6119   
;;;6120       /* Set the XferSize to transfer */
;;;6121       if (hi2c->XferCount > MAX_NBYTE_SIZE)
00001c  8d60              LDRH     r0,[r4,#0x2a]
00001e  28ff              CMP      r0,#0xff
000020  d908              BLS      |L53.52|
;;;6122       {
;;;6123         hi2c->XferSize = MAX_NBYTE_SIZE;
000022  20ff              MOVS     r0,#0xff
000024  8520              STRH     r0,[r4,#0x28]
000026  e007              B        |L53.56|
                  |L53.40|
000028  4620              MOV      r0,r4                 ;6112
00002a  e8bd4010          POP      {r4,lr}               ;6112
00002e  2120              MOVS     r1,#0x20              ;6112
000030  f7ffbffe          B.W      I2C_Enable_IRQ
                  |L53.52|
;;;6124       }
;;;6125       else
;;;6126       {
;;;6127         hi2c->XferSize = hi2c->XferCount;
000034  8d60              LDRH     r0,[r4,#0x2a]
000036  8520              STRH     r0,[r4,#0x28]
                  |L53.56|
;;;6128       }
;;;6129   
;;;6130       /* Enable the DMA channel */
;;;6131       if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
000038  6821              LDR      r1,[r4,#0]
00003a  8d23              LDRH     r3,[r4,#0x28]
00003c  3124              ADDS     r1,r1,#0x24
00003e  6be0              LDR      r0,[r4,#0x3c]
000040  f7fffffe          BL       HAL_DMA_Start_IT
000044  b128              CBZ      r0,|L53.82|
;;;6132       {
;;;6133         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6134         I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
000046  4620              MOV      r0,r4
000048  e8bd4010          POP      {r4,lr}
00004c  2110              MOVS     r1,#0x10
00004e  f7ffbffe          B.W      I2C_ITError
                  |L53.82|
;;;6135       }
;;;6136       else
;;;6137       {
;;;6138         /* Enable TC interrupts */
;;;6139         I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
000052  4620              MOV      r0,r4
000054  e8bd4010          POP      {r4,lr}
000058  2140              MOVS     r1,#0x40
00005a  f7ffbffe          B.W      I2C_Enable_IRQ
;;;6140       }
;;;6141     }
;;;6142   }
;;;6143   
                          ENDP


                          AREA ||i.I2C_DMAMasterTransmitCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAMasterTransmitCplt PROC
;;;6025     */
;;;6026   static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;6027   {
;;;6028     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000002  6a84              LDR      r4,[r0,#0x28]
;;;6029   
;;;6030     /* Disable DMA Request */
;;;6031     hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f4214180          BIC      r1,r1,#0x4000
00000c  6001              STR      r1,[r0,#0]
;;;6032   
;;;6033     /* If last transfer, enable STOP interrupt */
;;;6034     if (hi2c->XferCount == 0U)
00000e  8d60              LDRH     r0,[r4,#0x2a]
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L54.40|
;;;6035     {
;;;6036       /* Enable STOP interrupt */
;;;6037       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
;;;6038     }
;;;6039     /* else prepare a new DMA transfer and enable TCReload interrupt */
;;;6040     else
;;;6041     {
;;;6042       /* Update Buffer pointer */
;;;6043       hi2c->pBuffPtr += hi2c->XferSize;
000014  8d21              LDRH     r1,[r4,#0x28]
000016  6a60              LDR      r0,[r4,#0x24]
000018  4401              ADD      r1,r1,r0
00001a  6261              STR      r1,[r4,#0x24]
;;;6044   
;;;6045       /* Set the XferSize to transfer */
;;;6046       if (hi2c->XferCount > MAX_NBYTE_SIZE)
00001c  8d60              LDRH     r0,[r4,#0x2a]
00001e  28ff              CMP      r0,#0xff
000020  d908              BLS      |L54.52|
;;;6047       {
;;;6048         hi2c->XferSize = MAX_NBYTE_SIZE;
000022  20ff              MOVS     r0,#0xff
000024  8520              STRH     r0,[r4,#0x28]
000026  e007              B        |L54.56|
                  |L54.40|
000028  4620              MOV      r0,r4                 ;6037
00002a  e8bd4010          POP      {r4,lr}               ;6037
00002e  2120              MOVS     r1,#0x20              ;6037
000030  f7ffbffe          B.W      I2C_Enable_IRQ
                  |L54.52|
;;;6049       }
;;;6050       else
;;;6051       {
;;;6052         hi2c->XferSize = hi2c->XferCount;
000034  8d60              LDRH     r0,[r4,#0x2a]
000036  8520              STRH     r0,[r4,#0x28]
                  |L54.56|
;;;6053       }
;;;6054   
;;;6055       /* Enable the DMA channel */
;;;6056       if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
000038  6822              LDR      r2,[r4,#0]
00003a  8d23              LDRH     r3,[r4,#0x28]
00003c  3228              ADDS     r2,r2,#0x28
00003e  6ba0              LDR      r0,[r4,#0x38]
000040  f7fffffe          BL       HAL_DMA_Start_IT
000044  b128              CBZ      r0,|L54.82|
;;;6057       {
;;;6058         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6059         I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
000046  4620              MOV      r0,r4
000048  e8bd4010          POP      {r4,lr}
00004c  2110              MOVS     r1,#0x10
00004e  f7ffbffe          B.W      I2C_ITError
                  |L54.82|
;;;6060       }
;;;6061       else
;;;6062       {
;;;6063         /* Enable TC interrupts */
;;;6064         I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
000052  4620              MOV      r0,r4
000054  e8bd4010          POP      {r4,lr}
000058  2140              MOVS     r1,#0x40
00005a  f7ffbffe          B.W      I2C_Enable_IRQ
;;;6065       }
;;;6066     }
;;;6067   }
;;;6068   
                          ENDP


                          AREA ||i.I2C_DMASlaveReceiveCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMASlaveReceiveCplt PROC
;;;6148     */
;;;6149   static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
000000  6a80              LDR      r0,[r0,#0x28]
;;;6150   {
;;;6151     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
;;;6152     uint32_t tmpoptions = hi2c->XferOptions;
000002  6ac1              LDR      r1,[r0,#0x2c]
;;;6153   
;;;6154     if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
000004  6bc2              LDR      r2,[r0,#0x3c]
000006  6812              LDR      r2,[r2,#0]
000008  6852              LDR      r2,[r2,#4]
00000a  2a00              CMP      r2,#0
00000c  d109              BNE      |L55.34|
;;;6155         (tmpoptions != I2C_NO_OPTION_FRAME))
00000e  f5113f80          CMN      r1,#0x10000
000012  d006              BEQ      |L55.34|
;;;6156     {
;;;6157       /* Disable DMA Request */
;;;6158       hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
000014  6801              LDR      r1,[r0,#0]
000016  680a              LDR      r2,[r1,#0]
000018  f4224200          BIC      r2,r2,#0x8000
00001c  600a              STR      r2,[r1,#0]
;;;6159   
;;;6160       /* Call I2C Slave Sequential complete process */
;;;6161       I2C_ITSlaveSeqCplt(hi2c);
00001e  f7ffbffe          B.W      I2C_ITSlaveSeqCplt
                  |L55.34|
;;;6162     }
;;;6163     else
;;;6164     {
;;;6165       /* No specific action, Master fully manage the generation of STOP condition */
;;;6166       /* Mean that this generation can arrive at any time, at the end or during DMA process */
;;;6167       /* So STOP condition should be manage through Interrupt treatment */
;;;6168     }
;;;6169   }
000022  4770              BX       lr
;;;6170   
                          ENDP


                          AREA ||i.I2C_DMASlaveTransmitCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMASlaveTransmitCplt PROC
;;;6073     */
;;;6074   static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
000000  6a80              LDR      r0,[r0,#0x28]
;;;6075   {
;;;6076     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
;;;6077     uint32_t tmpoptions = hi2c->XferOptions;
000002  6ac1              LDR      r1,[r0,#0x2c]
;;;6078   
;;;6079     if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
000004  f1b17f80          CMP      r1,#0x1000000
000008  d001              BEQ      |L56.14|
00000a  2900              CMP      r1,#0
00000c  d106              BNE      |L56.28|
                  |L56.14|
;;;6080     {
;;;6081       /* Disable DMA Request */
;;;6082       hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  f4224280          BIC      r2,r2,#0x4000
000016  600a              STR      r2,[r1,#0]
;;;6083   
;;;6084       /* Last Byte is Transmitted */
;;;6085       /* Call I2C Slave Sequential complete process */
;;;6086       I2C_ITSlaveSeqCplt(hi2c);
000018  f7ffbffe          B.W      I2C_ITSlaveSeqCplt
                  |L56.28|
;;;6087     }
;;;6088     else
;;;6089     {
;;;6090       /* No specific action, Master fully manage the generation of STOP condition */
;;;6091       /* Mean that this generation can arrive at any time, at the end or during DMA process */
;;;6092       /* So STOP condition should be manage through Interrupt treatment */
;;;6093     }
;;;6094   }
00001c  4770              BX       lr
;;;6095   
                          ENDP


                          AREA ||i.I2C_Disable_IRQ||, CODE, READONLY, ALIGN=1

                  I2C_Disable_IRQ PROC
;;;6546     */
;;;6547   static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
000000  b530              PUSH     {r4,r5,lr}
;;;6548   {
;;;6549     uint32_t tmpisr = 0U;
000002  2200              MOVS     r2,#0
;;;6550   
;;;6551     if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
000004  07cb              LSLS     r3,r1,#31
;;;6552     {
;;;6553       /* Disable TC and TXI interrupts */
;;;6554       tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
;;;6555   
;;;6556       if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
000006  f04f0528          MOV      r5,#0x28
00000a  d006              BEQ      |L57.26|
00000c  2242              MOVS     r2,#0x42              ;6554
00000e  f8904041          LDRB     r4,[r0,#0x41]
000012  ea350304          BICS     r3,r5,r4
000016  d000              BEQ      |L57.26|
;;;6557       {
;;;6558         /* Disable NACK and STOP interrupts */
;;;6559         tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
000018  22f2              MOVS     r2,#0xf2
                  |L57.26|
;;;6560       }
;;;6561     }
;;;6562   
;;;6563     if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
00001a  078b              LSLS     r3,r1,#30
00001c  d508              BPL      |L57.48|
;;;6564     {
;;;6565       /* Disable TC and RXI interrupts */
;;;6566       tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
00001e  f0420244          ORR      r2,r2,#0x44
;;;6567   
;;;6568       if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
000022  f8904041          LDRB     r4,[r0,#0x41]
000026  ea350304          BICS     r3,r5,r4
00002a  d001              BEQ      |L57.48|
;;;6569       {
;;;6570         /* Disable NACK and STOP interrupts */
;;;6571         tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
00002c  f04202b0          ORR      r2,r2,#0xb0
                  |L57.48|
;;;6572       }
;;;6573     }
;;;6574   
;;;6575     if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
000030  040b              LSLS     r3,r1,#16
000032  d501              BPL      |L57.56|
;;;6576     {
;;;6577       /* Disable ADDR, NACK and STOP interrupts */
;;;6578       tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
000034  f04202b8          ORR      r2,r2,#0xb8
                  |L57.56|
;;;6579     }
;;;6580   
;;;6581     if (InterruptRequest == I2C_XFER_ERROR_IT)
000038  2910              CMP      r1,#0x10
00003a  d101              BNE      |L57.64|
;;;6582     {
;;;6583       /* Enable ERR and NACK interrupts */
;;;6584       tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
00003c  f0420290          ORR      r2,r2,#0x90
                  |L57.64|
;;;6585     }
;;;6586   
;;;6587     if (InterruptRequest == I2C_XFER_CPLT_IT)
000040  2920              CMP      r1,#0x20
000042  d101              BNE      |L57.72|
;;;6588     {
;;;6589       /* Enable STOP interrupts */
;;;6590       tmpisr |= I2C_IT_STOPI;
000044  f0420220          ORR      r2,r2,#0x20
                  |L57.72|
;;;6591     }
;;;6592   
;;;6593     if (InterruptRequest == I2C_XFER_RELOAD_IT)
000048  2940              CMP      r1,#0x40
00004a  d101              BNE      |L57.80|
;;;6594     {
;;;6595       /* Enable TC interrupts */
;;;6596       tmpisr |= I2C_IT_TCI;
00004c  f0420240          ORR      r2,r2,#0x40
                  |L57.80|
;;;6597     }
;;;6598   
;;;6599     /* Disable interrupts only at the end */
;;;6600     /* to avoid a breaking situation like at "t" time */
;;;6601     /* all disable interrupts request are not done */
;;;6602     __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
000050  6800              LDR      r0,[r0,#0]
000052  6801              LDR      r1,[r0,#0]
000054  4391              BICS     r1,r1,r2
000056  6001              STR      r1,[r0,#0]
;;;6603   }
000058  bd30              POP      {r4,r5,pc}
;;;6604   
                          ENDP


                          AREA ||i.I2C_Enable_IRQ||, CODE, READONLY, ALIGN=2

                  I2C_Enable_IRQ PROC
;;;6475     */
;;;6476   static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
000000  b510              PUSH     {r4,lr}
;;;6477   {
;;;6478     uint32_t tmpisr = 0U;
000002  2200              MOVS     r2,#0
;;;6479   
;;;6480     if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
000004  4c15              LDR      r4,|L58.92|
000006  6b43              LDR      r3,[r0,#0x34]
000008  42a3              CMP      r3,r4
00000a  d002              BEQ      |L58.18|
;;;6481         (hi2c->XferISR == I2C_Slave_ISR_DMA))
00000c  4c14              LDR      r4,|L58.96|
00000e  42a3              CMP      r3,r4
000010  d10f              BNE      |L58.50|
                  |L58.18|
;;;6482     {
;;;6483       if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
000012  040b              LSLS     r3,r1,#16
000014  d500              BPL      |L58.24|
;;;6484       {
;;;6485         /* Enable ERR, STOP, NACK and ADDR interrupts */
;;;6486         tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
000016  22b8              MOVS     r2,#0xb8
                  |L58.24|
;;;6487       }
;;;6488   
;;;6489       if (InterruptRequest == I2C_XFER_ERROR_IT)
000018  2910              CMP      r1,#0x10
00001a  d101              BNE      |L58.32|
;;;6490       {
;;;6491         /* Enable ERR and NACK interrupts */
;;;6492         tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
00001c  f0420290          ORR      r2,r2,#0x90
                  |L58.32|
;;;6493       }
;;;6494   
;;;6495       if (InterruptRequest == I2C_XFER_CPLT_IT)
000020  2920              CMP      r1,#0x20
000022  d101              BNE      |L58.40|
;;;6496       {
;;;6497         /* Enable STOP interrupts */
;;;6498         tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
000024  f0420260          ORR      r2,r2,#0x60
                  |L58.40|
;;;6499       }
;;;6500   
;;;6501       if (InterruptRequest == I2C_XFER_RELOAD_IT)
000028  2940              CMP      r1,#0x40
00002a  d111              BNE      |L58.80|
;;;6502       {
;;;6503         /* Enable TC interrupts */
;;;6504         tmpisr |= I2C_IT_TCI;
00002c  f0420240          ORR      r2,r2,#0x40
000030  e00e              B        |L58.80|
                  |L58.50|
;;;6505       }
;;;6506     }
;;;6507     else
;;;6508     {
;;;6509       if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
000032  040b              LSLS     r3,r1,#16
000034  d500              BPL      |L58.56|
;;;6510       {
;;;6511         /* Enable ERR, STOP, NACK, and ADDR interrupts */
;;;6512         tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
000036  22b8              MOVS     r2,#0xb8
                  |L58.56|
;;;6513       }
;;;6514   
;;;6515       if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
000038  07cb              LSLS     r3,r1,#31
00003a  d001              BEQ      |L58.64|
;;;6516       {
;;;6517         /* Enable ERR, TC, STOP, NACK and RXI interrupts */
;;;6518         tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
00003c  f04202f2          ORR      r2,r2,#0xf2
                  |L58.64|
;;;6519       }
;;;6520   
;;;6521       if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
000040  078b              LSLS     r3,r1,#30
000042  d501              BPL      |L58.72|
;;;6522       {
;;;6523         /* Enable ERR, TC, STOP, NACK and TXI interrupts */
;;;6524         tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
000044  f04202f4          ORR      r2,r2,#0xf4
                  |L58.72|
;;;6525       }
;;;6526   
;;;6527       if (InterruptRequest == I2C_XFER_CPLT_IT)
000048  2920              CMP      r1,#0x20
00004a  d101              BNE      |L58.80|
;;;6528       {
;;;6529         /* Enable STOP interrupts */
;;;6530         tmpisr |= I2C_IT_STOPI;
00004c  f0420220          ORR      r2,r2,#0x20
                  |L58.80|
;;;6531       }
;;;6532     }
;;;6533   
;;;6534     /* Enable interrupts only at the end */
;;;6535     /* to avoid the risk of I2C interrupt handle execution before */
;;;6536     /* all interrupts requested done */
;;;6537     __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
000050  6800              LDR      r0,[r0,#0]
000052  6801              LDR      r1,[r0,#0]
000054  4311              ORRS     r1,r1,r2
000056  6001              STR      r1,[r0,#0]
;;;6538   }
000058  bd10              POP      {r4,pc}
;;;6539   
                          ENDP

00005a  0000              DCW      0x0000
                  |L58.92|
                          DCD      I2C_Master_ISR_DMA
                  |L58.96|
                          DCD      I2C_Slave_ISR_DMA

                          AREA ||i.I2C_Flush_TXDR||, CODE, READONLY, ALIGN=1

                  I2C_Flush_TXDR PROC
;;;6004     */
;;;6005   static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
000000  6801              LDR      r1,[r0,#0]
;;;6006   {
;;;6007     /* If a pending TXIS flag is set */
;;;6008     /* Write a dummy data in TXDR to clear it */
;;;6009     if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
000002  698a              LDR      r2,[r1,#0x18]
000004  43d2              MVNS     r2,r2
000006  0792              LSLS     r2,r2,#30
000008  d401              BMI      |L59.14|
;;;6010     {
;;;6011       hi2c->Instance->TXDR = 0x00U;
00000a  2200              MOVS     r2,#0
00000c  628a              STR      r2,[r1,#0x28]
                  |L59.14|
;;;6012     }
;;;6013   
;;;6014     /* Flush TX register if not empty */
;;;6015     if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
00000e  6800              LDR      r0,[r0,#0]
000010  6981              LDR      r1,[r0,#0x18]
000012  43c9              MVNS     r1,r1
000014  07c9              LSLS     r1,r1,#31
000016  d003              BEQ      |L59.32|
;;;6016     {
;;;6017       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
000018  6981              LDR      r1,[r0,#0x18]
00001a  f0410101          ORR      r1,r1,#1
00001e  6181              STR      r1,[r0,#0x18]
                  |L59.32|
;;;6018     }
;;;6019   }
000020  4770              BX       lr
;;;6020   
                          ENDP


                          AREA ||i.I2C_ITAddrCplt||, CODE, READONLY, ALIGN=1

                  I2C_ITAddrCplt PROC
;;;5279     */
;;;5280   static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5281   {
000004  4604              MOV      r4,r0
;;;5282     uint8_t transferdirection;
;;;5283     uint16_t slaveaddrcode;
;;;5284     uint16_t ownadd1code;
;;;5285     uint16_t ownadd2code;
;;;5286   
;;;5287     /* Prevent unused argument(s) compilation warning */
;;;5288     UNUSED(ITFlags);
;;;5289   
;;;5290     /* In case of Listen state, need to inform upper layer of address match code event */
;;;5291     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000006  f8940041          LDRB     r0,[r4,#0x41]
00000a  2228              MOVS     r2,#0x28
00000c  4382              BICS     r2,r2,r0
;;;5292     {
;;;5293       transferdirection = I2C_GET_DIR(hi2c);
00000e  6820              LDR      r0,[r4,#0]
000010  f04f0700          MOV      r7,#0                 ;5291
;;;5294       slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
;;;5295       ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
;;;5296       ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
;;;5297   
;;;5298       /* If 10bits addressing mode is selected */
;;;5299       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;5300       {
;;;5301         if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
;;;5302         {
;;;5303           slaveaddrcode = ownadd1code;
;;;5304           hi2c->AddrEventCount++;
;;;5305           if (hi2c->AddrEventCount == 2U)
;;;5306           {
;;;5307             /* Reset Address Event counter */
;;;5308             hi2c->AddrEventCount = 0U;
;;;5309   
;;;5310             /* Clear ADDR flag */
;;;5311             __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
000014  f04f0108          MOV      r1,#8
000018  d004              BEQ      |L60.36|
;;;5312   
;;;5313             /* Process Unlocked */
;;;5314             __HAL_UNLOCK(hi2c);
;;;5315   
;;;5316             /* Call Slave Addr callback */
;;;5317   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5318             hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
;;;5319   #else
;;;5320             HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
;;;5321   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5322           }
;;;5323         }
;;;5324         else
;;;5325         {
;;;5326           slaveaddrcode = ownadd2code;
;;;5327   
;;;5328           /* Disable ADDR Interrupts */
;;;5329           I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;5330   
;;;5331           /* Process Unlocked */
;;;5332           __HAL_UNLOCK(hi2c);
;;;5333   
;;;5334           /* Call Slave Addr callback */
;;;5335   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5336           hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
;;;5337   #else
;;;5338           HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
;;;5339   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5340         }
;;;5341       }
;;;5342       /* else 7 bits addressing mode is selected */
;;;5343       else
;;;5344       {
;;;5345         /* Disable ADDR Interrupts */
;;;5346         I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;5347   
;;;5348         /* Process Unlocked */
;;;5349         __HAL_UNLOCK(hi2c);
;;;5350   
;;;5351         /* Call Slave Addr callback */
;;;5352   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5353         hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
;;;5354   #else
;;;5355         HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
;;;5356   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5357       }
;;;5358     }
;;;5359     /* Else clear address flag only */
;;;5360     else
;;;5361     {
;;;5362       /* Clear ADDR flag */
;;;5363       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
00001a  61c1              STR      r1,[r0,#0x1c]
;;;5364   
;;;5365       /* Process Unlocked */
;;;5366       __HAL_UNLOCK(hi2c);
00001c  f8847040          STRB     r7,[r4,#0x40]
                  |L60.32|
;;;5367     }
;;;5368   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L60.36|
000024  6982              LDR      r2,[r0,#0x18]         ;5293
000026  f3c24600          UBFX     r6,r2,#16,#1          ;5293
00002a  6982              LDR      r2,[r0,#0x18]         ;5294
00002c  f402027e          AND      r2,r2,#0xfe0000       ;5294
000030  0c15              LSRS     r5,r2,#16             ;5294
000032  6882              LDR      r2,[r0,#8]            ;5295
000034  f3c20209          UBFX     r2,r2,#0,#10          ;5295
000038  68c3              LDR      r3,[r0,#0xc]          ;5296
00003a  f00308fe          AND      r8,r3,#0xfe           ;5296
00003e  68e3              LDR      r3,[r4,#0xc]          ;5299
000040  f44f4c00          MOV      r12,#0x8000           ;5329
000044  2b02              CMP      r3,#2                 ;5299
000046  d00b              BEQ      |L60.96|
000048  4661              MOV      r1,r12                ;5346
00004a  4620              MOV      r0,r4                 ;5346
00004c  f7fffffe          BL       I2C_Disable_IRQ
000050  f8847040          STRB     r7,[r4,#0x40]         ;5349
000054  462a              MOV      r2,r5                 ;5355
000056  4631              MOV      r1,r6                 ;5355
000058  4620              MOV      r0,r4                 ;5355
00005a  f7fffffe          BL       HAL_I2C_AddrCallback
00005e  e7df              B        |L60.32|
                  |L60.96|
000060  f0050306          AND      r3,r5,#6              ;5301
000064  2506              MOVS     r5,#6                 ;5301
000066  ea0515d2          AND      r5,r5,r2,LSR #7       ;5301
00006a  42ab              CMP      r3,r5                 ;5301
00006c  d10e              BNE      |L60.140|
00006e  6ca3              LDR      r3,[r4,#0x48]         ;5304
000070  1c5b              ADDS     r3,r3,#1              ;5304
000072  64a3              STR      r3,[r4,#0x48]         ;5304
000074  6ca3              LDR      r3,[r4,#0x48]         ;5305
000076  2b02              CMP      r3,#2                 ;5305
000078  d1d2              BNE      |L60.32|
00007a  64a7              STR      r7,[r4,#0x48]         ;5308
00007c  61c1              STR      r1,[r0,#0x1c]         ;5311
00007e  f8847040          STRB     r7,[r4,#0x40]         ;5314
000082  4631              MOV      r1,r6                 ;5320
000084  4620              MOV      r0,r4                 ;5320
000086  f7fffffe          BL       HAL_I2C_AddrCallback
00008a  e7c9              B        |L60.32|
                  |L60.140|
00008c  4661              MOV      r1,r12                ;5329
00008e  4620              MOV      r0,r4                 ;5329
000090  f7fffffe          BL       I2C_Disable_IRQ
000094  f8847040          STRB     r7,[r4,#0x40]         ;5332
000098  4642              MOV      r2,r8                 ;5338
00009a  4631              MOV      r1,r6                 ;5338
00009c  4620              MOV      r0,r4                 ;5338
00009e  f7fffffe          BL       HAL_I2C_AddrCallback
0000a2  e7bd              B        |L60.32|
;;;5369   
                          ENDP


                          AREA ||i.I2C_ITError||, CODE, READONLY, ALIGN=2

                  I2C_ITError PROC
;;;5854     */
;;;5855   static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
000000  b570              PUSH     {r4-r6,lr}
;;;5856   {
000002  4604              MOV      r4,r0
;;;5857     HAL_I2C_StateTypeDef tmpstate = hi2c->State;
000004  f8940041          LDRB     r0,[r4,#0x41]
;;;5858     uint32_t tmppreviousstate;
;;;5859   
;;;5860     /* Reset handle parameters */
;;;5861     hi2c->Mode          = HAL_I2C_MODE_NONE;
000008  2500              MOVS     r5,#0
00000a  f8845042          STRB     r5,[r4,#0x42]
;;;5862     hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
00000e  4a3b              LDR      r2,|L61.252|
000010  62e2              STR      r2,[r4,#0x2c]
;;;5863     hi2c->XferCount     = 0U;
000012  8565              STRH     r5,[r4,#0x2a]
;;;5864   
;;;5865     /* Set new error code */
;;;5866     hi2c->ErrorCode |= ErrorCode;
000014  6c62              LDR      r2,[r4,#0x44]
000016  430a              ORRS     r2,r2,r1
000018  6462              STR      r2,[r4,#0x44]
;;;5867   
;;;5868     /* Disable Interrupts */
;;;5869     if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
00001a  2828              CMP      r0,#0x28
00001c  d023              BEQ      |L61.102|
;;;5870         (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
00001e  2829              CMP      r0,#0x29
000020  d021              BEQ      |L61.102|
;;;5871         (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
000022  282a              CMP      r0,#0x2a
000024  d01f              BEQ      |L61.102|
;;;5872     {
;;;5873       /* Disable all interrupts, except interrupts related to LISTEN state */
;;;5874       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
;;;5875   
;;;5876       /* keep HAL_I2C_STATE_LISTEN if set */
;;;5877       hi2c->State         = HAL_I2C_STATE_LISTEN;
;;;5878       hi2c->XferISR       = I2C_Slave_ISR_IT;
;;;5879     }
;;;5880     else
;;;5881     {
;;;5882       /* Disable all interrupts */
;;;5883       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
000026  f2480103          MOV      r1,#0x8003
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       I2C_Disable_IRQ
;;;5884   
;;;5885       /* If state is an abort treatment on going, don't change state */
;;;5886       /* This change will be do later */
;;;5887       if (hi2c->State != HAL_I2C_STATE_ABORT)
000030  f8940041          LDRB     r0,[r4,#0x41]
000034  2860              CMP      r0,#0x60
000036  d002              BEQ      |L61.62|
;;;5888       {
;;;5889         /* Set HAL_I2C_STATE_READY */
;;;5890         hi2c->State         = HAL_I2C_STATE_READY;
000038  2020              MOVS     r0,#0x20
00003a  f8840041          STRB     r0,[r4,#0x41]
                  |L61.62|
;;;5891       }
;;;5892       hi2c->XferISR       = NULL;
00003e  6365              STR      r5,[r4,#0x34]
                  |L61.64|
;;;5893     }
;;;5894   
;;;5895     /* Abort DMA TX transfer if any */
;;;5896     tmppreviousstate = hi2c->PreviousState;
000040  6b20              LDR      r0,[r4,#0x30]
;;;5897     if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
;;;5898                                    (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
;;;5899     {
;;;5900       if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
;;;5901       {
;;;5902         hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
;;;5903       }
;;;5904   
;;;5905       if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
;;;5906       {
;;;5907         /* Set the I2C DMA Abort callback :
;;;5908          will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;5909         hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
000042  4e2f              LDR      r6,|L61.256|
000044  6ba1              LDR      r1,[r4,#0x38]         ;5897
000046  b119              CBZ      r1,|L61.80|
000048  2811              CMP      r0,#0x11              ;5897
00004a  d016              BEQ      |L61.122|
00004c  2821              CMP      r0,#0x21              ;5898
00004e  d014              BEQ      |L61.122|
                  |L61.80|
;;;5910   
;;;5911         /* Process Unlocked */
;;;5912         __HAL_UNLOCK(hi2c);
;;;5913   
;;;5914         /* Abort DMA TX */
;;;5915         if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;5916         {
;;;5917           /* Call Directly XferAbortCallback function in case of error */
;;;5918           hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;5919         }
;;;5920       }
;;;5921       else
;;;5922       {
;;;5923         I2C_TreatErrorCallback(hi2c);
;;;5924       }
;;;5925     }
;;;5926     /* Abort DMA RX transfer if any */
;;;5927     else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
000050  6be1              LDR      r1,[r4,#0x3c]
000052  b119              CBZ      r1,|L61.92|
000054  2812              CMP      r0,#0x12
000056  d030              BEQ      |L61.186|
;;;5928                                         (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
000058  2822              CMP      r0,#0x22
00005a  d02e              BEQ      |L61.186|
                  |L61.92|
;;;5929     {
;;;5930       if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
;;;5931       {
;;;5932         hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
;;;5933       }
;;;5934   
;;;5935       if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
;;;5936       {
;;;5937         /* Set the I2C DMA Abort callback :
;;;5938           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;5939         hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;5940   
;;;5941         /* Process Unlocked */
;;;5942         __HAL_UNLOCK(hi2c);
;;;5943   
;;;5944         /* Abort DMA RX */
;;;5945         if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;5946         {
;;;5947           /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
;;;5948           hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;5949         }
;;;5950       }
;;;5951       else
;;;5952       {
;;;5953         I2C_TreatErrorCallback(hi2c);
;;;5954       }
;;;5955     }
;;;5956     else
;;;5957     {
;;;5958       I2C_TreatErrorCallback(hi2c);
00005c  4620              MOV      r0,r4
00005e  e8bd4070          POP      {r4-r6,lr}
000062  f7ffbffe          B.W      I2C_TreatErrorCallback
                  |L61.102|
000066  2103              MOVS     r1,#3                 ;5874
000068  4620              MOV      r0,r4                 ;5874
00006a  f7fffffe          BL       I2C_Disable_IRQ
00006e  2028              MOVS     r0,#0x28              ;5877
000070  f8840041          STRB     r0,[r4,#0x41]         ;5877
000074  4823              LDR      r0,|L61.260|
000076  6360              STR      r0,[r4,#0x34]         ;5878
000078  e7e2              B        |L61.64|
                  |L61.122|
00007a  6820              LDR      r0,[r4,#0]            ;5900
00007c  6801              LDR      r1,[r0,#0]            ;5900
00007e  0449              LSLS     r1,r1,#17             ;5900
000080  d503              BPL      |L61.138|
000082  6801              LDR      r1,[r0,#0]            ;5902
000084  f4214180          BIC      r1,r1,#0x4000         ;5902
000088  6001              STR      r1,[r0,#0]            ;5902
                  |L61.138|
00008a  6ba0              LDR      r0,[r4,#0x38]         ;5905
00008c  f7fffffe          BL       HAL_DMA_GetState
000090  2801              CMP      r0,#1                 ;5905
000092  d00d              BEQ      |L61.176|
000094  6ba0              LDR      r0,[r4,#0x38]         ;5909
000096  6386              STR      r6,[r0,#0x38]         ;5909
000098  f8845040          STRB     r5,[r4,#0x40]         ;5912
00009c  6ba0              LDR      r0,[r4,#0x38]         ;5915
00009e  f7fffffe          BL       HAL_DMA_Abort_IT
0000a2  2800              CMP      r0,#0                 ;5915
0000a4  d029              BEQ      |L61.250|
0000a6  6ba0              LDR      r0,[r4,#0x38]         ;5918
0000a8  6b81              LDR      r1,[r0,#0x38]         ;5918
0000aa  e8bd4070          POP      {r4-r6,lr}            ;5918
0000ae  4708              BX       r1                    ;5918
                  |L61.176|
0000b0  4620              MOV      r0,r4                 ;5923
0000b2  e8bd4070          POP      {r4-r6,lr}            ;5923
0000b6  f7ffbffe          B.W      I2C_TreatErrorCallback
                  |L61.186|
0000ba  6820              LDR      r0,[r4,#0]            ;5930
0000bc  6801              LDR      r1,[r0,#0]            ;5930
0000be  0409              LSLS     r1,r1,#16             ;5930
0000c0  d503              BPL      |L61.202|
0000c2  6801              LDR      r1,[r0,#0]            ;5932
0000c4  f4214100          BIC      r1,r1,#0x8000         ;5932
0000c8  6001              STR      r1,[r0,#0]            ;5932
                  |L61.202|
0000ca  6be0              LDR      r0,[r4,#0x3c]         ;5935
0000cc  f7fffffe          BL       HAL_DMA_GetState
0000d0  2801              CMP      r0,#1                 ;5935
0000d2  d00d              BEQ      |L61.240|
0000d4  6be0              LDR      r0,[r4,#0x3c]         ;5939
0000d6  6386              STR      r6,[r0,#0x38]         ;5939
0000d8  f8845040          STRB     r5,[r4,#0x40]         ;5942
0000dc  6be0              LDR      r0,[r4,#0x3c]         ;5945
0000de  f7fffffe          BL       HAL_DMA_Abort_IT
0000e2  2800              CMP      r0,#0                 ;5945
0000e4  d009              BEQ      |L61.250|
0000e6  6be0              LDR      r0,[r4,#0x3c]         ;5948
0000e8  6b81              LDR      r1,[r0,#0x38]         ;5948
0000ea  e8bd4070          POP      {r4-r6,lr}            ;5948
0000ee  4708              BX       r1                    ;5948
                  |L61.240|
0000f0  4620              MOV      r0,r4                 ;5953
0000f2  e8bd4070          POP      {r4-r6,lr}            ;5953
0000f6  f7ffbffe          B.W      I2C_TreatErrorCallback
                  |L61.250|
;;;5959     }
;;;5960   }
0000fa  bd70              POP      {r4-r6,pc}
;;;5961   
                          ENDP

                  |L61.252|
                          DCD      0xffff0000
                  |L61.256|
                          DCD      I2C_DMAAbort
                  |L61.260|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.I2C_ITListenCplt||, CODE, READONLY, ALIGN=2

                  I2C_ITListenCplt PROC
;;;5803     */
;;;5804   static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  b570              PUSH     {r4-r6,lr}
;;;5805   {
000002  4604              MOV      r4,r0
;;;5806     /* Reset handle parameters */
;;;5807     hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000004  4816              LDR      r0,|L62.96|
000006  62e0              STR      r0,[r4,#0x2c]
;;;5808     hi2c->PreviousState = I2C_STATE_NONE;
000008  2500              MOVS     r5,#0
00000a  6325              STR      r5,[r4,#0x30]
;;;5809     hi2c->State = HAL_I2C_STATE_READY;
00000c  2020              MOVS     r0,#0x20
00000e  f8840041          STRB     r0,[r4,#0x41]
;;;5810     hi2c->Mode = HAL_I2C_MODE_NONE;
000012  f8845042          STRB     r5,[r4,#0x42]
;;;5811     hi2c->XferISR = NULL;
000016  6365              STR      r5,[r4,#0x34]
;;;5812   
;;;5813     /* Store Last receive data if any */
;;;5814     if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
000018  43c8              MVNS     r0,r1
00001a  0740              LSLS     r0,r0,#29
00001c  d411              BMI      |L62.66|
;;;5815     {
;;;5816       /* Read data from RXDR */
;;;5817       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
00001e  6820              LDR      r0,[r4,#0]
000020  6a40              LDR      r0,[r0,#0x24]
000022  6a61              LDR      r1,[r4,#0x24]
000024  7008              STRB     r0,[r1,#0]
;;;5818   
;;;5819       /* Increment Buffer pointer */
;;;5820       hi2c->pBuffPtr++;
000026  6a60              LDR      r0,[r4,#0x24]
000028  1c40              ADDS     r0,r0,#1
00002a  6260              STR      r0,[r4,#0x24]
;;;5821   
;;;5822       if ((hi2c->XferSize > 0U))
00002c  8d20              LDRH     r0,[r4,#0x28]
00002e  b140              CBZ      r0,|L62.66|
;;;5823       {
;;;5824         hi2c->XferSize--;
000030  1e40              SUBS     r0,r0,#1
000032  8520              STRH     r0,[r4,#0x28]
;;;5825         hi2c->XferCount--;
000034  8d60              LDRH     r0,[r4,#0x2a]
000036  1e40              SUBS     r0,r0,#1
000038  8560              STRH     r0,[r4,#0x2a]
;;;5826   
;;;5827         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;5828         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00003a  6c60              LDR      r0,[r4,#0x44]
00003c  f0400004          ORR      r0,r0,#4
000040  6460              STR      r0,[r4,#0x44]
                  |L62.66|
;;;5829       }
;;;5830     }
;;;5831   
;;;5832     /* Disable all Interrupts*/
;;;5833     I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
000042  f2480103          MOV      r1,#0x8003
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       I2C_Disable_IRQ
;;;5834   
;;;5835     /* Clear NACK Flag */
;;;5836     __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00004c  6821              LDR      r1,[r4,#0]
00004e  2010              MOVS     r0,#0x10
000050  61c8              STR      r0,[r1,#0x1c]
;;;5837   
;;;5838     /* Process Unlocked */
;;;5839     __HAL_UNLOCK(hi2c);
000052  f8845040          STRB     r5,[r4,#0x40]
;;;5840   
;;;5841     /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;5842   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5843     hi2c->ListenCpltCallback(hi2c);
;;;5844   #else
;;;5845     HAL_I2C_ListenCpltCallback(hi2c);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       HAL_I2C_ListenCpltCallback
;;;5846   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5847   }
00005c  bd70              POP      {r4-r6,pc}
;;;5848   
                          ENDP

00005e  0000              DCW      0x0000
                  |L62.96|
                          DCD      0xffff0000

                          AREA ||i.I2C_ITMasterCplt||, CODE, READONLY, ALIGN=2

                  I2C_ITMasterCplt PROC
;;;5501     */
;;;5502   static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  b5f8              PUSH     {r3-r7,lr}
;;;5503   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
;;;5504     uint32_t tmperror;
;;;5505     uint32_t tmpITFlags = ITFlags;
;;;5506     __IO uint32_t tmpreg;
;;;5507   
;;;5508     /* Clear STOP Flag */
;;;5509     __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
000006  6820              LDR      r0,[r4,#0]
000008  2620              MOVS     r6,#0x20
00000a  61c6              STR      r6,[r0,#0x1c]
;;;5510   
;;;5511     /* Disable Interrupts and Store Previous state */
;;;5512     if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
00000c  f8940041          LDRB     r0,[r4,#0x41]
000010  2821              CMP      r0,#0x21
000012  d004              BEQ      |L63.30|
;;;5513     {
;;;5514       I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;5515       hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
;;;5516     }
;;;5517     else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
000014  f8940041          LDRB     r0,[r4,#0x41]
000018  2822              CMP      r0,#0x22
00001a  d007              BEQ      |L63.44|
00001c  e00c              B        |L63.56|
                  |L63.30|
00001e  2101              MOVS     r1,#1                 ;5514
000020  4620              MOV      r0,r4                 ;5514
000022  f7fffffe          BL       I2C_Disable_IRQ
000026  2011              MOVS     r0,#0x11              ;5515
000028  6320              STR      r0,[r4,#0x30]         ;5515
00002a  e005              B        |L63.56|
                  |L63.44|
;;;5518     {
;;;5519       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       I2C_Disable_IRQ
;;;5520       hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000034  2012              MOVS     r0,#0x12
000036  6320              STR      r0,[r4,#0x30]
                  |L63.56|
;;;5521     }
;;;5522     else
;;;5523     {
;;;5524       /* Do nothing */
;;;5525     }
;;;5526   
;;;5527     /* Clear Configuration Register 2 */
;;;5528     I2C_RESET_CR2(hi2c);
000038  6820              LDR      r0,[r4,#0]
00003a  6841              LDR      r1,[r0,#4]
00003c  4a2f              LDR      r2,|L63.252|
00003e  4011              ANDS     r1,r1,r2
000040  6041              STR      r1,[r0,#4]
;;;5529   
;;;5530     /* Reset handle parameters */
;;;5531     hi2c->XferISR       = NULL;
000042  2500              MOVS     r5,#0
000044  6365              STR      r5,[r4,#0x34]
;;;5532     hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
000046  482e              LDR      r0,|L63.256|
000048  62e0              STR      r0,[r4,#0x2c]
;;;5533   
;;;5534     if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
00004a  43f8              MVNS     r0,r7
00004c  06c1              LSLS     r1,r0,#27
00004e  d406              BMI      |L63.94|
;;;5535     {
;;;5536       /* Clear NACK Flag */
;;;5537       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000050  6822              LDR      r2,[r4,#0]
000052  2110              MOVS     r1,#0x10
000054  61d1              STR      r1,[r2,#0x1c]
;;;5538   
;;;5539       /* Set acknowledge error code */
;;;5540       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000056  6c61              LDR      r1,[r4,#0x44]
000058  f0410104          ORR      r1,r1,#4
00005c  6461              STR      r1,[r4,#0x44]
                  |L63.94|
;;;5541     }
;;;5542   
;;;5543     /* Fetch Last receive data if any */
;;;5544     if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
00005e  f8941041          LDRB     r1,[r4,#0x41]
000062  2960              CMP      r1,#0x60
000064  d105              BNE      |L63.114|
000066  0740              LSLS     r0,r0,#29
000068  d403              BMI      |L63.114|
;;;5545     {
;;;5546       /* Read data from RXDR */
;;;5547       tmpreg = (uint8_t)hi2c->Instance->RXDR;
00006a  6820              LDR      r0,[r4,#0]
00006c  6a40              LDR      r0,[r0,#0x24]
00006e  b2c0              UXTB     r0,r0
000070  9000              STR      r0,[sp,#0]
                  |L63.114|
;;;5548       UNUSED(tmpreg);
;;;5549     }
;;;5550   
;;;5551     /* Flush TX register */
;;;5552     I2C_Flush_TXDR(hi2c);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       I2C_Flush_TXDR
;;;5553   
;;;5554     /* Store current volatile hi2c->ErrorCode, misra rule */
;;;5555     tmperror = hi2c->ErrorCode;
000078  6c60              LDR      r0,[r4,#0x44]
;;;5556   
;;;5557     /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5558     if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
00007a  f8941041          LDRB     r1,[r4,#0x41]
00007e  2960              CMP      r1,#0x60
000080  d000              BEQ      |L63.132|
000082  b128              CBZ      r0,|L63.144|
                  |L63.132|
;;;5559     {
;;;5560       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5561       I2C_ITError(hi2c, hi2c->ErrorCode);
000084  6c61              LDR      r1,[r4,#0x44]
000086  4620              MOV      r0,r4
000088  e8bd40f8          POP      {r3-r7,lr}
00008c  f7ffbffe          B.W      I2C_ITError
                  |L63.144|
;;;5562     }
;;;5563     /* hi2c->State == HAL_I2C_STATE_BUSY_TX */
;;;5564     else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
000090  f8940041          LDRB     r0,[r4,#0x41]
000094  2821              CMP      r0,#0x21
000096  d012              BEQ      |L63.190|
;;;5565     {
;;;5566       hi2c->State = HAL_I2C_STATE_READY;
;;;5567       hi2c->PreviousState = I2C_STATE_NONE;
;;;5568   
;;;5569       if (hi2c->Mode == HAL_I2C_MODE_MEM)
;;;5570       {
;;;5571         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;5572   
;;;5573         /* Process Unlocked */
;;;5574         __HAL_UNLOCK(hi2c);
;;;5575   
;;;5576         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5577   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5578         hi2c->MemTxCpltCallback(hi2c);
;;;5579   #else
;;;5580         HAL_I2C_MemTxCpltCallback(hi2c);
;;;5581   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5582       }
;;;5583       else
;;;5584       {
;;;5585         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;5586   
;;;5587         /* Process Unlocked */
;;;5588         __HAL_UNLOCK(hi2c);
;;;5589   
;;;5590         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5591   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5592         hi2c->MasterTxCpltCallback(hi2c);
;;;5593   #else
;;;5594         HAL_I2C_MasterTxCpltCallback(hi2c);
;;;5595   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5596       }
;;;5597     }
;;;5598     /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
;;;5599     else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
000098  f8940041          LDRB     r0,[r4,#0x41]
00009c  2822              CMP      r0,#0x22
00009e  d10d              BNE      |L63.188|
;;;5600     {
;;;5601       hi2c->State = HAL_I2C_STATE_READY;
0000a0  f8846041          STRB     r6,[r4,#0x41]
;;;5602       hi2c->PreviousState = I2C_STATE_NONE;
0000a4  6325              STR      r5,[r4,#0x30]
;;;5603   
;;;5604       if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000a6  f8940042          LDRB     r0,[r4,#0x42]
0000aa  2840              CMP      r0,#0x40
0000ac  d01e              BEQ      |L63.236|
;;;5605       {
;;;5606         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;5607   
;;;5608         /* Process Unlocked */
;;;5609         __HAL_UNLOCK(hi2c);
;;;5610   
;;;5611         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5612   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5613         hi2c->MemRxCpltCallback(hi2c);
;;;5614   #else
;;;5615         HAL_I2C_MemRxCpltCallback(hi2c);
;;;5616   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5617       }
;;;5618       else
;;;5619       {
;;;5620         hi2c->Mode = HAL_I2C_MODE_NONE;
0000ae  f8845042          STRB     r5,[r4,#0x42]
;;;5621   
;;;5622         /* Process Unlocked */
;;;5623         __HAL_UNLOCK(hi2c);
0000b2  f8845040          STRB     r5,[r4,#0x40]
;;;5624   
;;;5625         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5626   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5627         hi2c->MasterRxCpltCallback(hi2c);
;;;5628   #else
;;;5629         HAL_I2C_MasterRxCpltCallback(hi2c);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L63.188|
;;;5630   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5631       }
;;;5632     }
;;;5633     else
;;;5634     {
;;;5635       /* Nothing to do */
;;;5636     }
;;;5637   }
0000bc  bdf8              POP      {r3-r7,pc}
                  |L63.190|
0000be  f8846041          STRB     r6,[r4,#0x41]         ;5566
0000c2  6325              STR      r5,[r4,#0x30]         ;5567
0000c4  f8940042          LDRB     r0,[r4,#0x42]         ;5569
0000c8  2840              CMP      r0,#0x40              ;5569
0000ca  d007              BEQ      |L63.220|
0000cc  f8845042          STRB     r5,[r4,#0x42]         ;5585
0000d0  f8845040          STRB     r5,[r4,#0x40]         ;5588
0000d4  4620              MOV      r0,r4                 ;5594
0000d6  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
0000da  bdf8              POP      {r3-r7,pc}
                  |L63.220|
0000dc  f8845042          STRB     r5,[r4,#0x42]         ;5571
0000e0  f8845040          STRB     r5,[r4,#0x40]         ;5574
0000e4  4620              MOV      r0,r4                 ;5580
0000e6  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
0000ea  bdf8              POP      {r3-r7,pc}
                  |L63.236|
0000ec  f8845042          STRB     r5,[r4,#0x42]         ;5606
0000f0  f8845040          STRB     r5,[r4,#0x40]         ;5609
0000f4  4620              MOV      r0,r4                 ;5615
0000f6  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
0000fa  bdf8              POP      {r3-r7,pc}
;;;5638   
                          ENDP

                  |L63.252|
                          DCD      0xfe00e800
                  |L63.256|
                          DCD      0xffff0000

                          AREA ||i.I2C_ITMasterSeqCplt||, CODE, READONLY, ALIGN=1

                  I2C_ITMasterSeqCplt PROC
;;;5374     */
;;;5375   static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5376   {
000002  4604              MOV      r4,r0
;;;5377     /* Reset I2C handle mode */
;;;5378     hi2c->Mode = HAL_I2C_MODE_NONE;
000004  2500              MOVS     r5,#0
000006  f8845042          STRB     r5,[r4,#0x42]
;;;5379   
;;;5380     /* No Generate Stop, to permit restart mode */
;;;5381     /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
;;;5382     if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
00000a  f8941041          LDRB     r1,[r4,#0x41]
;;;5383     {
;;;5384       hi2c->State         = HAL_I2C_STATE_READY;
00000e  2020              MOVS     r0,#0x20
000010  2921              CMP      r1,#0x21              ;5382
000012  d00e              BEQ      |L64.50|
;;;5385       hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
;;;5386       hi2c->XferISR       = NULL;
;;;5387   
;;;5388       /* Disable Interrupts */
;;;5389       I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;5390   
;;;5391       /* Process Unlocked */
;;;5392       __HAL_UNLOCK(hi2c);
;;;5393   
;;;5394       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5395   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5396       hi2c->MasterTxCpltCallback(hi2c);
;;;5397   #else
;;;5398       HAL_I2C_MasterTxCpltCallback(hi2c);
;;;5399   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5400     }
;;;5401     /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
;;;5402     else
;;;5403     {
;;;5404       hi2c->State         = HAL_I2C_STATE_READY;
000014  f8840041          STRB     r0,[r4,#0x41]
;;;5405       hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000018  2012              MOVS     r0,#0x12
00001a  6320              STR      r0,[r4,#0x30]
;;;5406       hi2c->XferISR       = NULL;
00001c  6365              STR      r5,[r4,#0x34]
;;;5407   
;;;5408       /* Disable Interrupts */
;;;5409       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
00001e  2102              MOVS     r1,#2
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_Disable_IRQ
;;;5410   
;;;5411       /* Process Unlocked */
;;;5412       __HAL_UNLOCK(hi2c);
000026  f8845040          STRB     r5,[r4,#0x40]
;;;5413   
;;;5414       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5415   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5416       hi2c->MasterRxCpltCallback(hi2c);
;;;5417   #else
;;;5418       HAL_I2C_MasterRxCpltCallback(hi2c);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
;;;5419   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5420     }
;;;5421   }
000030  bd70              POP      {r4-r6,pc}
                  |L64.50|
000032  f8840041          STRB     r0,[r4,#0x41]         ;5384
000036  2011              MOVS     r0,#0x11              ;5385
000038  6320              STR      r0,[r4,#0x30]         ;5385
00003a  6365              STR      r5,[r4,#0x34]         ;5386
00003c  2101              MOVS     r1,#1                 ;5389
00003e  4620              MOV      r0,r4                 ;5389
000040  f7fffffe          BL       I2C_Disable_IRQ
000044  f8845040          STRB     r5,[r4,#0x40]         ;5392
000048  4620              MOV      r0,r4                 ;5398
00004a  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
00004e  bd70              POP      {r4-r6,pc}
;;;5422   
                          ENDP


                          AREA ||i.I2C_ITSlaveCplt||, CODE, READONLY, ALIGN=2

                  I2C_ITSlaveCplt PROC
;;;5644     */
;;;5645   static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5646   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;5647     uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
000008  6822              LDR      r2,[r4,#0]
00000a  6817              LDR      r7,[r2,#0]
;;;5648     uint32_t tmpITFlags = ITFlags;
;;;5649     HAL_I2C_StateTypeDef tmpstate = hi2c->State;
00000c  f8940041          LDRB     r0,[r4,#0x41]
;;;5650   
;;;5651     /* Clear STOP Flag */
;;;5652     __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
000010  2620              MOVS     r6,#0x20
000012  61d6              STR      r6,[r2,#0x1c]
;;;5653   
;;;5654     /* Disable Interrupts and Store Previous state */
;;;5655     if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
000014  2821              CMP      r0,#0x21
000016  d006              BEQ      |L65.38|
000018  2829              CMP      r0,#0x29
00001a  d004              BEQ      |L65.38|
;;;5656     {
;;;5657       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
;;;5658       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
;;;5659     }
;;;5660     else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
00001c  2822              CMP      r0,#0x22
00001e  d00a              BEQ      |L65.54|
000020  282a              CMP      r0,#0x2a
000022  d008              BEQ      |L65.54|
000024  e00e              B        |L65.68|
                  |L65.38|
000026  f2480101          MOV      r1,#0x8001            ;5657
00002a  4620              MOV      r0,r4                 ;5657
00002c  f7fffffe          BL       I2C_Disable_IRQ
000030  2021              MOVS     r0,#0x21              ;5658
000032  6320              STR      r0,[r4,#0x30]         ;5658
000034  e006              B        |L65.68|
                  |L65.54|
;;;5661     {
;;;5662       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
000036  f2480102          MOV      r1,#0x8002
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       I2C_Disable_IRQ
;;;5663       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000040  2022              MOVS     r0,#0x22
000042  6320              STR      r0,[r4,#0x30]
                  |L65.68|
;;;5664     }
;;;5665     else
;;;5666     {
;;;5667       /* Do nothing */
;;;5668     }
;;;5669   
;;;5670     /* Disable Address Acknowledge */
;;;5671     hi2c->Instance->CR2 |= I2C_CR2_NACK;
000044  6820              LDR      r0,[r4,#0]
000046  6841              LDR      r1,[r0,#4]
000048  f4414100          ORR      r1,r1,#0x8000
00004c  6041              STR      r1,[r0,#4]
;;;5672   
;;;5673     /* Clear Configuration Register 2 */
;;;5674     I2C_RESET_CR2(hi2c);
00004e  6820              LDR      r0,[r4,#0]
000050  6841              LDR      r1,[r0,#4]
000052  4a3a              LDR      r2,|L65.316|
000054  4011              ANDS     r1,r1,r2
000056  6041              STR      r1,[r0,#4]
;;;5675   
;;;5676     /* Flush TX register */
;;;5677     I2C_Flush_TXDR(hi2c);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       I2C_Flush_TXDR
;;;5678   
;;;5679     /* If a DMA is ongoing, Update handle size context */
;;;5680     if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
00005e  43f8              MVNS     r0,r7
000060  0441              LSLS     r1,r0,#17
000062  d40a              BMI      |L65.122|
;;;5681     {
;;;5682       /* Disable DMA Request */
;;;5683       hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
000064  6820              LDR      r0,[r4,#0]
000066  6801              LDR      r1,[r0,#0]
000068  f4214180          BIC      r1,r1,#0x4000
00006c  6001              STR      r1,[r0,#0]
;;;5684   
;;;5685       if (hi2c->hdmatx != NULL)
00006e  6ba0              LDR      r0,[r4,#0x38]
000070  b178              CBZ      r0,|L65.146|
;;;5686       {
;;;5687         hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmatx);
000072  6800              LDR      r0,[r0,#0]
000074  6840              LDR      r0,[r0,#4]
000076  8560              STRH     r0,[r4,#0x2a]
000078  e00b              B        |L65.146|
                  |L65.122|
;;;5688       }
;;;5689     }
;;;5690     else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
00007a  0400              LSLS     r0,r0,#16
00007c  d409              BMI      |L65.146|
;;;5691     {
;;;5692       /* Disable DMA Request */
;;;5693       hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
00007e  6820              LDR      r0,[r4,#0]
000080  6801              LDR      r1,[r0,#0]
000082  f4214100          BIC      r1,r1,#0x8000
000086  6001              STR      r1,[r0,#0]
;;;5694   
;;;5695       if (hi2c->hdmarx != NULL)
000088  6be0              LDR      r0,[r4,#0x3c]
00008a  b110              CBZ      r0,|L65.146|
;;;5696       {
;;;5697         hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
00008c  6800              LDR      r0,[r0,#0]
00008e  6840              LDR      r0,[r0,#4]
000090  8560              STRH     r0,[r4,#0x2a]
                  |L65.146|
;;;5698       }
;;;5699     }
;;;5700     else
;;;5701     {
;;;5702       /* Do nothing */
;;;5703     }
;;;5704   
;;;5705     /* Store Last receive data if any */
;;;5706     if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
000092  43e8              MVNS     r0,r5
000094  0740              LSLS     r0,r0,#29
000096  d40f              BMI      |L65.184|
;;;5707     {
;;;5708       /* Remove RXNE flag on temporary variable as read done */
;;;5709       tmpITFlags &= ~I2C_FLAG_RXNE;
000098  f0250504          BIC      r5,r5,#4
;;;5710   
;;;5711       /* Read data from RXDR */
;;;5712       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
00009c  6820              LDR      r0,[r4,#0]
00009e  6a40              LDR      r0,[r0,#0x24]
0000a0  6a61              LDR      r1,[r4,#0x24]
0000a2  7008              STRB     r0,[r1,#0]
;;;5713   
;;;5714       /* Increment Buffer pointer */
;;;5715       hi2c->pBuffPtr++;
0000a4  6a60              LDR      r0,[r4,#0x24]
0000a6  1c40              ADDS     r0,r0,#1
0000a8  6260              STR      r0,[r4,#0x24]
;;;5716   
;;;5717       if ((hi2c->XferSize > 0U))
0000aa  8d20              LDRH     r0,[r4,#0x28]
0000ac  b120              CBZ      r0,|L65.184|
;;;5718       {
;;;5719         hi2c->XferSize--;
0000ae  1e40              SUBS     r0,r0,#1
0000b0  8520              STRH     r0,[r4,#0x28]
;;;5720         hi2c->XferCount--;
0000b2  8d60              LDRH     r0,[r4,#0x2a]
0000b4  1e40              SUBS     r0,r0,#1
0000b6  8560              STRH     r0,[r4,#0x2a]
                  |L65.184|
;;;5721       }
;;;5722     }
;;;5723   
;;;5724     /* All data are not transferred, so set error code accordingly */
;;;5725     if (hi2c->XferCount != 0U)
0000b8  8d60              LDRH     r0,[r4,#0x2a]
0000ba  b118              CBZ      r0,|L65.196|
;;;5726     {
;;;5727       /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;5728       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
0000bc  6c60              LDR      r0,[r4,#0x44]
0000be  f0400004          ORR      r0,r0,#4
0000c2  6460              STR      r0,[r4,#0x44]
                  |L65.196|
;;;5729     }
;;;5730   
;;;5731     hi2c->Mode = HAL_I2C_MODE_NONE;
0000c4  2700              MOVS     r7,#0
0000c6  f8847042          STRB     r7,[r4,#0x42]
;;;5732     hi2c->XferISR = NULL;
0000ca  6367              STR      r7,[r4,#0x34]
;;;5733   
;;;5734     if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
0000cc  6c60              LDR      r0,[r4,#0x44]
0000ce  b168              CBZ      r0,|L65.236|
;;;5735     {
;;;5736       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5737       I2C_ITError(hi2c, hi2c->ErrorCode);
0000d0  6c61              LDR      r1,[r4,#0x44]
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       I2C_ITError
;;;5738   
;;;5739       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;5740       if (hi2c->State == HAL_I2C_STATE_LISTEN)
0000d8  f8940041          LDRB     r0,[r4,#0x41]
0000dc  2828              CMP      r0,#0x28
0000de  d115              BNE      |L65.268|
;;;5741       {
;;;5742         /* Call I2C Listen complete process */
;;;5743         I2C_ITListenCplt(hi2c, tmpITFlags);
0000e0  4629              MOV      r1,r5
0000e2  4620              MOV      r0,r4
0000e4  e8bd41f0          POP      {r4-r8,lr}
0000e8  f7ffbffe          B.W      I2C_ITListenCplt
                  |L65.236|
;;;5744       }
;;;5745     }
;;;5746     else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
0000ec  6ae0              LDR      r0,[r4,#0x2c]
0000ee  4d14              LDR      r5,|L65.320|
0000f0  42a8              CMP      r0,r5
0000f2  d00d              BEQ      |L65.272|
;;;5747     {
;;;5748       /* Call the Sequential Complete callback, to inform upper layer of the end of Transfer */
;;;5749       I2C_ITSlaveSeqCplt(hi2c);
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       I2C_ITSlaveSeqCplt
;;;5750   
;;;5751       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
0000fa  62e5              STR      r5,[r4,#0x2c]
;;;5752       hi2c->State = HAL_I2C_STATE_READY;
0000fc  f8846041          STRB     r6,[r4,#0x41]
;;;5753       hi2c->PreviousState = I2C_STATE_NONE;
000100  6327              STR      r7,[r4,#0x30]
;;;5754   
;;;5755       /* Process Unlocked */
;;;5756       __HAL_UNLOCK(hi2c);
000102  f8847040          STRB     r7,[r4,#0x40]
;;;5757   
;;;5758       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;5759   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5760       hi2c->ListenCpltCallback(hi2c);
;;;5761   #else
;;;5762       HAL_I2C_ListenCpltCallback(hi2c);
000106  4620              MOV      r0,r4
000108  f7fffffe          BL       HAL_I2C_ListenCpltCallback
                  |L65.268|
;;;5763   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5764     }
;;;5765     /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5766     else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
;;;5767     {
;;;5768       hi2c->State = HAL_I2C_STATE_READY;
;;;5769       hi2c->PreviousState = I2C_STATE_NONE;
;;;5770   
;;;5771       /* Process Unlocked */
;;;5772       __HAL_UNLOCK(hi2c);
;;;5773   
;;;5774       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5775   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5776       hi2c->SlaveRxCpltCallback(hi2c);
;;;5777   #else
;;;5778       HAL_I2C_SlaveRxCpltCallback(hi2c);
;;;5779   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5780     }
;;;5781     else
;;;5782     {
;;;5783       hi2c->State = HAL_I2C_STATE_READY;
;;;5784       hi2c->PreviousState = I2C_STATE_NONE;
;;;5785   
;;;5786       /* Process Unlocked */
;;;5787       __HAL_UNLOCK(hi2c);
;;;5788   
;;;5789       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5790   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5791       hi2c->SlaveTxCpltCallback(hi2c);
;;;5792   #else
;;;5793       HAL_I2C_SlaveTxCpltCallback(hi2c);
;;;5794   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5795     }
;;;5796   }
00010c  e8bd81f0          POP      {r4-r8,pc}
                  |L65.272|
000110  f8940041          LDRB     r0,[r4,#0x41]         ;5766
000114  2822              CMP      r0,#0x22              ;5766
000116  d008              BEQ      |L65.298|
000118  f8846041          STRB     r6,[r4,#0x41]         ;5783
00011c  6327              STR      r7,[r4,#0x30]         ;5784
00011e  f8847040          STRB     r7,[r4,#0x40]         ;5787
000122  4620              MOV      r0,r4                 ;5793
000124  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
000128  e7f0              B        |L65.268|
                  |L65.298|
00012a  f8846041          STRB     r6,[r4,#0x41]         ;5768
00012e  6327              STR      r7,[r4,#0x30]         ;5769
000130  f8847040          STRB     r7,[r4,#0x40]         ;5772
000134  4620              MOV      r0,r4                 ;5778
000136  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
00013a  e7e7              B        |L65.268|
;;;5797   
                          ENDP

                  |L65.316|
                          DCD      0xfe00e800
                  |L65.320|
                          DCD      0xffff0000

                          AREA ||i.I2C_ITSlaveSeqCplt||, CODE, READONLY, ALIGN=1

                  I2C_ITSlaveSeqCplt PROC
;;;5427     */
;;;5428   static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5429   {
000002  4604              MOV      r4,r0
;;;5430     uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
;;;5431   
;;;5432     /* Reset I2C handle mode */
;;;5433     hi2c->Mode = HAL_I2C_MODE_NONE;
000008  2500              MOVS     r5,#0
00000a  f8845042          STRB     r5,[r4,#0x42]
;;;5434   
;;;5435     /* If a DMA is ongoing, Update handle size context */
;;;5436     if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
00000e  43c9              MVNS     r1,r1
000010  044a              LSLS     r2,r1,#17
000012  d404              BMI      |L66.30|
;;;5437     {
;;;5438       /* Disable DMA Request */
;;;5439       hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
000014  6801              LDR      r1,[r0,#0]
000016  f4214180          BIC      r1,r1,#0x4000
00001a  6001              STR      r1,[r0,#0]
00001c  e005              B        |L66.42|
                  |L66.30|
;;;5440     }
;;;5441     else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
00001e  0409              LSLS     r1,r1,#16
000020  d403              BMI      |L66.42|
;;;5442     {
;;;5443       /* Disable DMA Request */
;;;5444       hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
000022  6801              LDR      r1,[r0,#0]
000024  f4214100          BIC      r1,r1,#0x8000
000028  6001              STR      r1,[r0,#0]
                  |L66.42|
;;;5445     }
;;;5446     else
;;;5447     {
;;;5448       /* Do nothing */
;;;5449     }
;;;5450   
;;;5451     if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
00002a  f8941041          LDRB     r1,[r4,#0x41]
;;;5452     {
;;;5453       /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
;;;5454       hi2c->State         = HAL_I2C_STATE_LISTEN;
00002e  2028              MOVS     r0,#0x28
000030  2929              CMP      r1,#0x29              ;5451
000032  d011              BEQ      |L66.88|
;;;5455       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
;;;5456   
;;;5457       /* Disable Interrupts */
;;;5458       I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;5459   
;;;5460       /* Process Unlocked */
;;;5461       __HAL_UNLOCK(hi2c);
;;;5462   
;;;5463       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5464   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5465       hi2c->SlaveTxCpltCallback(hi2c);
;;;5466   #else
;;;5467       HAL_I2C_SlaveTxCpltCallback(hi2c);
;;;5468   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5469     }
;;;5470   
;;;5471     else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
000034  f8941041          LDRB     r1,[r4,#0x41]
000038  292a              CMP      r1,#0x2a
00003a  d10c              BNE      |L66.86|
;;;5472     {
;;;5473       /* Remove HAL_I2C_STATE_SLAVE_BUSY_RX, keep only HAL_I2C_STATE_LISTEN */
;;;5474       hi2c->State         = HAL_I2C_STATE_LISTEN;
00003c  f8840041          STRB     r0,[r4,#0x41]
;;;5475       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000040  2022              MOVS     r0,#0x22
000042  6320              STR      r0,[r4,#0x30]
;;;5476   
;;;5477       /* Disable Interrupts */
;;;5478       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
000044  2102              MOVS     r1,#2
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       I2C_Disable_IRQ
;;;5479   
;;;5480       /* Process Unlocked */
;;;5481       __HAL_UNLOCK(hi2c);
00004c  f8845040          STRB     r5,[r4,#0x40]
;;;5482   
;;;5483       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5484   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5485       hi2c->SlaveRxCpltCallback(hi2c);
;;;5486   #else
;;;5487       HAL_I2C_SlaveRxCpltCallback(hi2c);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L66.86|
;;;5488   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5489     }
;;;5490     else
;;;5491     {
;;;5492       /* Nothing to do */
;;;5493     }
;;;5494   }
000056  bd70              POP      {r4-r6,pc}
                  |L66.88|
000058  f8840041          STRB     r0,[r4,#0x41]         ;5454
00005c  2021              MOVS     r0,#0x21              ;5455
00005e  6320              STR      r0,[r4,#0x30]         ;5455
000060  2101              MOVS     r1,#1                 ;5458
000062  4620              MOV      r0,r4                 ;5458
000064  f7fffffe          BL       I2C_Disable_IRQ
000068  f8845040          STRB     r5,[r4,#0x40]         ;5461
00006c  4620              MOV      r0,r4                 ;5467
00006e  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
000072  bd70              POP      {r4-r6,pc}
;;;5495   
                          ENDP


                          AREA ||i.I2C_IsAcknowledgeFailed||, CODE, READONLY, ALIGN=2

                  I2C_IsAcknowledgeFailed PROC
;;;6384     */
;;;6385   static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6386   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;6387     if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
00000a  6820              LDR      r0,[r4,#0]
00000c  6980              LDR      r0,[r0,#0x18]
00000e  43c0              MVNS     r0,r0
000010  06c0              LSLS     r0,r0,#27
000012  d436              BMI      |L67.130|
;;;6388     {
;;;6389       /* Wait until STOP Flag is reset */
;;;6390       /* AutoEnd should be initiate after AF */
;;;6391       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
000014  2700              MOVS     r7,#0
;;;6392       {
;;;6393         /* Check for the Timeout */
;;;6394         if (Timeout != HAL_MAX_DELAY)
;;;6395         {
;;;6396           if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6397           {
;;;6398             hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;6399             hi2c->State = HAL_I2C_STATE_READY;
000016  f04f0820          MOV      r8,#0x20
00001a  e007              B        |L67.44|
                  |L67.28|
00001c  1c68              ADDS     r0,r5,#1              ;6394
00001e  d005              BEQ      |L67.44|
000020  f7fffffe          BL       HAL_GetTick
000024  1b80              SUBS     r0,r0,r6              ;6396
000026  42a8              CMP      r0,r5                 ;6396
000028  d820              BHI      |L67.108|
00002a  b1fd              CBZ      r5,|L67.108|
                  |L67.44|
00002c  6820              LDR      r0,[r4,#0]            ;6391
00002e  6980              LDR      r0,[r0,#0x18]         ;6391
000030  43c0              MVNS     r0,r0                 ;6391
000032  0680              LSLS     r0,r0,#26             ;6391
000034  d4f2              BMI      |L67.28|
;;;6400             hi2c->Mode = HAL_I2C_MODE_NONE;
;;;6401   
;;;6402             /* Process Unlocked */
;;;6403             __HAL_UNLOCK(hi2c);
;;;6404   
;;;6405             return HAL_ERROR;
;;;6406           }
;;;6407         }
;;;6408       }
;;;6409   
;;;6410       /* Clear NACKF Flag */
;;;6411       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000036  6821              LDR      r1,[r4,#0]
000038  2010              MOVS     r0,#0x10
00003a  61c8              STR      r0,[r1,#0x1c]
;;;6412   
;;;6413       /* Clear STOP Flag */
;;;6414       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
00003c  6820              LDR      r0,[r4,#0]
00003e  f8c0801c          STR      r8,[r0,#0x1c]
;;;6415   
;;;6416       /* Flush TX register */
;;;6417       I2C_Flush_TXDR(hi2c);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       I2C_Flush_TXDR
;;;6418   
;;;6419       /* Clear Configuration Register 2 */
;;;6420       I2C_RESET_CR2(hi2c);
000048  6820              LDR      r0,[r4,#0]
00004a  6841              LDR      r1,[r0,#4]
00004c  4a0e              LDR      r2,|L67.136|
00004e  4011              ANDS     r1,r1,r2
000050  6041              STR      r1,[r0,#4]
;;;6421   
;;;6422       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000052  6c60              LDR      r0,[r4,#0x44]
000054  f0400004          ORR      r0,r0,#4
000058  6460              STR      r0,[r4,#0x44]
;;;6423       hi2c->State = HAL_I2C_STATE_READY;
00005a  f8848041          STRB     r8,[r4,#0x41]
;;;6424       hi2c->Mode = HAL_I2C_MODE_NONE;
00005e  f8847042          STRB     r7,[r4,#0x42]
;;;6425   
;;;6426       /* Process Unlocked */
;;;6427       __HAL_UNLOCK(hi2c);
000062  f8847040          STRB     r7,[r4,#0x40]
;;;6428   
;;;6429       return HAL_ERROR;
000066  2001              MOVS     r0,#1
                  |L67.104|
;;;6430     }
;;;6431     return HAL_OK;
;;;6432   }
000068  e8bd81f0          POP      {r4-r8,pc}
                  |L67.108|
00006c  3440              ADDS     r4,r4,#0x40           ;6398
00006e  6860              LDR      r0,[r4,#4]            ;6398
000070  f0400020          ORR      r0,r0,#0x20           ;6398
000074  6060              STR      r0,[r4,#4]            ;6398
000076  f8848001          STRB     r8,[r4,#1]            ;6399
00007a  70a7              STRB     r7,[r4,#2]            ;6400
00007c  7027              STRB     r7,[r4,#0]            ;6403
00007e  2001              MOVS     r0,#1                 ;6405
000080  e7f2              B        |L67.104|
                  |L67.130|
000082  2000              MOVS     r0,#0                 ;6431
000084  e7f0              B        |L67.104|
;;;6433   
                          ENDP

000086  0000              DCW      0x0000
                  |L67.136|
                          DCD      0xfe00e800

                          AREA ||i.I2C_Master_ISR_DMA||, CODE, READONLY, ALIGN=2

                  I2C_Master_ISR_DMA PROC
;;;4902     */
;;;4903   static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
000000  b5f8              PUSH     {r3-r7,lr}
;;;4904   {
000002  4604              MOV      r4,r0
;;;4905     uint16_t devaddress;
;;;4906     uint32_t xfermode;
;;;4907   
;;;4908     /* Process Locked */
;;;4909     __HAL_LOCK(hi2c);
000004  f8940040          LDRB     r0,[r4,#0x40]
000008  2801              CMP      r0,#1
00000a  d01a              BEQ      |L68.66|
00000c  2001              MOVS     r0,#1
00000e  f8840040          STRB     r0,[r4,#0x40]
;;;4910   
;;;4911     if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
000012  43cb              MVNS     r3,r1
000014  06de              LSLS     r6,r3,#27
000016  f04f0500          MOV      r5,#0
00001a  ea6f0002          MVN      r0,r2
00001e  d412              BMI      |L68.70|
000020  06c2              LSLS     r2,r0,#27
000022  d410              BMI      |L68.70|
;;;4912     {
;;;4913       /* Clear NACK Flag */
;;;4914       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000024  6821              LDR      r1,[r4,#0]
000026  2010              MOVS     r0,#0x10
000028  61c8              STR      r0,[r1,#0x1c]
;;;4915   
;;;4916       /* Set corresponding Error Code */
;;;4917       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00002a  6c60              LDR      r0,[r4,#0x44]
00002c  f0400004          ORR      r0,r0,#4
000030  6460              STR      r0,[r4,#0x44]
;;;4918   
;;;4919       /* No need to generate STOP, it is automatically done */
;;;4920       /* But enable STOP interrupt, to treat it */
;;;4921       /* Error callback will be send during stop flag treatment */
;;;4922       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
000032  2120              MOVS     r1,#0x20
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Enable_IRQ
;;;4923   
;;;4924       /* Flush TX register */
;;;4925       I2C_Flush_TXDR(hi2c);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       I2C_Flush_TXDR
000040  e06b              B        |L68.282|
                  |L68.66|
000042  2002              MOVS     r0,#2                 ;4909
;;;4926     }
;;;4927     else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
;;;4928     {
;;;4929       /* Disable TC interrupt */
;;;4930       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
;;;4931   
;;;4932       if (hi2c->XferCount != 0U)
;;;4933       {
;;;4934         /* Recover Slave address */
;;;4935         devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
;;;4936   
;;;4937         /* Prepare the new XferSize to transfer */
;;;4938         if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;4939         {
;;;4940           hi2c->XferSize = MAX_NBYTE_SIZE;
;;;4941           xfermode = I2C_RELOAD_MODE;
;;;4942         }
;;;4943         else
;;;4944         {
;;;4945           hi2c->XferSize = hi2c->XferCount;
;;;4946           if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
;;;4947           {
;;;4948             xfermode = hi2c->XferOptions;
;;;4949           }
;;;4950           else
;;;4951           {
;;;4952             xfermode = I2C_AUTOEND_MODE;
;;;4953           }
;;;4954         }
;;;4955   
;;;4956         /* Set the new XferSize in Nbytes register */
;;;4957         I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
;;;4958   
;;;4959         /* Update XferCount value */
;;;4960         hi2c->XferCount -= hi2c->XferSize;
;;;4961   
;;;4962         /* Enable DMA Request */
;;;4963         if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
;;;4964         {
;;;4965           hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;4966         }
;;;4967         else
;;;4968         {
;;;4969           hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;4970         }
;;;4971       }
;;;4972       else
;;;4973       {
;;;4974         /* Call TxCpltCallback() if no stop mode is set */
;;;4975         if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
;;;4976         {
;;;4977           /* Call I2C Master Sequential complete process */
;;;4978           I2C_ITMasterSeqCplt(hi2c);
;;;4979         }
;;;4980         else
;;;4981         {
;;;4982           /* Wrong size Status regarding TCR flag event */
;;;4983           /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4984           I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
;;;4985         }
;;;4986       }
;;;4987     }
;;;4988     else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
;;;4989     {
;;;4990       if (hi2c->XferCount == 0U)
;;;4991       {
;;;4992         if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
;;;4993         {
;;;4994           /* Generate a stop condition in case of no transfer option */
;;;4995           if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
;;;4996           {
;;;4997             /* Generate Stop */
;;;4998             hi2c->Instance->CR2 |= I2C_CR2_STOP;
;;;4999           }
;;;5000           else
;;;5001           {
;;;5002             /* Call I2C Master Sequential complete process */
;;;5003             I2C_ITMasterSeqCplt(hi2c);
;;;5004           }
;;;5005         }
;;;5006       }
;;;5007       else
;;;5008       {
;;;5009         /* Wrong size Status regarding TC flag event */
;;;5010         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5011         I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
;;;5012       }
;;;5013     }
;;;5014     else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
;;;5015     {
;;;5016       /* Call I2C Master complete process */
;;;5017       I2C_ITMasterCplt(hi2c, ITFlags);
;;;5018     }
;;;5019     else
;;;5020     {
;;;5021       /* Nothing to do */
;;;5022     }
;;;5023   
;;;5024     /* Process Unlocked */
;;;5025     __HAL_UNLOCK(hi2c);
;;;5026   
;;;5027     return HAL_OK;
;;;5028   }
000044  bdf8              POP      {r3-r7,pc}
                  |L68.70|
000046  4a37              LDR      r2,|L68.292|
000048  061e              LSLS     r6,r3,#24             ;4927
00004a  d444              BMI      |L68.214|
00004c  0646              LSLS     r6,r0,#25             ;4927
00004e  d442              BMI      |L68.214|
000050  6820              LDR      r0,[r4,#0]            ;4930
000052  6801              LDR      r1,[r0,#0]            ;4930
000054  f0210140          BIC      r1,r1,#0x40           ;4930
000058  6001              STR      r1,[r0,#0]            ;4930
00005a  8d60              LDRH     r0,[r4,#0x2a]         ;4932
00005c  b370              CBZ      r0,|L68.188|
00005e  6820              LDR      r0,[r4,#0]            ;4935
000060  6840              LDR      r0,[r0,#4]            ;4935
000062  f3c00109          UBFX     r1,r0,#0,#10          ;4935
000066  8d60              LDRH     r0,[r4,#0x2a]         ;4938
000068  28ff              CMP      r0,#0xff              ;4938
00006a  d904              BLS      |L68.118|
00006c  20ff              MOVS     r0,#0xff              ;4940
00006e  8520              STRH     r0,[r4,#0x28]         ;4940
000070  f04f7380          MOV      r3,#0x1000000         ;4941
000074  e008              B        |L68.136|
                  |L68.118|
000076  8d60              LDRH     r0,[r4,#0x2a]         ;4945
000078  8520              STRH     r0,[r4,#0x28]         ;4945
00007a  6ae0              LDR      r0,[r4,#0x2c]         ;4946
00007c  4290              CMP      r0,r2                 ;4946
00007e  d001              BEQ      |L68.132|
000080  6ae3              LDR      r3,[r4,#0x2c]         ;4948
000082  e001              B        |L68.136|
                  |L68.132|
000084  f04f7300          MOV      r3,#0x2000000         ;4952
                  |L68.136|
000088  9500              STR      r5,[sp,#0]            ;4957
00008a  f8942028          LDRB     r2,[r4,#0x28]         ;4957
00008e  4620              MOV      r0,r4                 ;4957
000090  f7fffffe          BL       I2C_TransferConfig
000094  8d60              LDRH     r0,[r4,#0x2a]         ;4960
000096  8d21              LDRH     r1,[r4,#0x28]         ;4960
000098  1a40              SUBS     r0,r0,r1              ;4960
00009a  8560              STRH     r0,[r4,#0x2a]         ;4960
00009c  f8940041          LDRB     r0,[r4,#0x41]         ;4963
0000a0  2822              CMP      r0,#0x22              ;4963
0000a2  d005              BEQ      |L68.176|
0000a4  6820              LDR      r0,[r4,#0]            ;4969
0000a6  6801              LDR      r1,[r0,#0]            ;4969
0000a8  f4414180          ORR      r1,r1,#0x4000         ;4969
0000ac  6001              STR      r1,[r0,#0]            ;4969
0000ae  e034              B        |L68.282|
                  |L68.176|
0000b0  6820              LDR      r0,[r4,#0]            ;4965
0000b2  6801              LDR      r1,[r0,#0]            ;4965
0000b4  f4414100          ORR      r1,r1,#0x8000         ;4965
0000b8  6001              STR      r1,[r0,#0]            ;4965
0000ba  e02e              B        |L68.282|
                  |L68.188|
0000bc  6820              LDR      r0,[r4,#0]            ;4975
0000be  6840              LDR      r0,[r0,#4]            ;4975
0000c0  0180              LSLS     r0,r0,#6              ;4975
0000c2  d403              BMI      |L68.204|
0000c4  4620              MOV      r0,r4                 ;4978
0000c6  f7fffffe          BL       I2C_ITMasterSeqCplt
0000ca  e026              B        |L68.282|
                  |L68.204|
0000cc  2140              MOVS     r1,#0x40              ;4984
0000ce  4620              MOV      r0,r4                 ;4984
0000d0  f7fffffe          BL       I2C_ITError
0000d4  e021              B        |L68.282|
                  |L68.214|
0000d6  065e              LSLS     r6,r3,#25             ;4988
0000d8  d418              BMI      |L68.268|
0000da  0646              LSLS     r6,r0,#25             ;4988
0000dc  d416              BMI      |L68.268|
0000de  8d60              LDRH     r0,[r4,#0x2a]         ;4990
0000e0  b120              CBZ      r0,|L68.236|
0000e2  2140              MOVS     r1,#0x40              ;5011
0000e4  4620              MOV      r0,r4                 ;5011
0000e6  f7fffffe          BL       I2C_ITError
0000ea  e016              B        |L68.282|
                  |L68.236|
0000ec  6820              LDR      r0,[r4,#0]            ;4992
0000ee  6841              LDR      r1,[r0,#4]            ;4992
0000f0  0189              LSLS     r1,r1,#6              ;4992
0000f2  d412              BMI      |L68.282|
0000f4  6ae1              LDR      r1,[r4,#0x2c]         ;4995
0000f6  4291              CMP      r1,r2                 ;4995
0000f8  d104              BNE      |L68.260|
0000fa  6841              LDR      r1,[r0,#4]            ;4998
0000fc  f4414180          ORR      r1,r1,#0x4000         ;4998
000100  6041              STR      r1,[r0,#4]            ;4998
000102  e00a              B        |L68.282|
                  |L68.260|
000104  4620              MOV      r0,r4                 ;5003
000106  f7fffffe          BL       I2C_ITMasterSeqCplt
00010a  e006              B        |L68.282|
                  |L68.268|
00010c  069a              LSLS     r2,r3,#26             ;5014
00010e  d404              BMI      |L68.282|
000110  0680              LSLS     r0,r0,#26             ;5014
000112  d402              BMI      |L68.282|
000114  4620              MOV      r0,r4                 ;5017
000116  f7fffffe          BL       I2C_ITMasterCplt
                  |L68.282|
00011a  f8845040          STRB     r5,[r4,#0x40]         ;5025
00011e  2000              MOVS     r0,#0                 ;5027
000120  bdf8              POP      {r3-r7,pc}
;;;5029   
                          ENDP

000122  0000              DCW      0x0000
                  |L68.292|
                          DCD      0xffff0000

                          AREA ||i.I2C_Master_ISR_IT||, CODE, READONLY, ALIGN=2

                  I2C_Master_ISR_IT PROC
;;;4630     */
;;;4631   static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
000000  b5f8              PUSH     {r3-r7,lr}
;;;4632   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;4633     uint16_t devaddress;
;;;4634     uint32_t tmpITFlags = ITFlags;
;;;4635   
;;;4636     /* Process Locked */
;;;4637     __HAL_LOCK(hi2c);
000006  f8940040          LDRB     r0,[r4,#0x40]
00000a  2801              CMP      r0,#1
00000c  d016              BEQ      |L69.60|
00000e  2001              MOVS     r0,#1
000010  f8840040          STRB     r0,[r4,#0x40]
;;;4638   
;;;4639     if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
000014  43f0              MVNS     r0,r6
000016  06c1              LSLS     r1,r0,#27
000018  f04f0700          MOV      r7,#0
00001c  ea6f0502          MVN      r5,r2
000020  d40e              BMI      |L69.64|
000022  06e9              LSLS     r1,r5,#27
000024  d40c              BMI      |L69.64|
;;;4640     {
;;;4641       /* Clear NACK Flag */
;;;4642       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000026  6821              LDR      r1,[r4,#0]
000028  2010              MOVS     r0,#0x10
00002a  61c8              STR      r0,[r1,#0x1c]
;;;4643   
;;;4644       /* Set corresponding Error Code */
;;;4645       /* No need to generate STOP, it is automatically done */
;;;4646       /* Error callback will be send during stop flag treatment */
;;;4647       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00002c  6c60              LDR      r0,[r4,#0x44]
00002e  f0400004          ORR      r0,r0,#4
000032  6460              STR      r0,[r4,#0x44]
;;;4648   
;;;4649       /* Flush TX register */
;;;4650       I2C_Flush_TXDR(hi2c);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Flush_TXDR
00003a  e06d              B        |L69.280|
                  |L69.60|
00003c  2002              MOVS     r0,#2                 ;4637
;;;4651     }
;;;4652     else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
;;;4653     {
;;;4654       /* Remove RXNE flag on temporary variable as read done */
;;;4655       tmpITFlags &= ~I2C_FLAG_RXNE;
;;;4656   
;;;4657       /* Read data from RXDR */
;;;4658       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
;;;4659   
;;;4660       /* Increment Buffer pointer */
;;;4661       hi2c->pBuffPtr++;
;;;4662   
;;;4663       hi2c->XferSize--;
;;;4664       hi2c->XferCount--;
;;;4665     }
;;;4666     else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
;;;4667     {
;;;4668       /* Write data to TXDR */
;;;4669       hi2c->Instance->TXDR = *hi2c->pBuffPtr;
;;;4670   
;;;4671       /* Increment Buffer pointer */
;;;4672       hi2c->pBuffPtr++;
;;;4673   
;;;4674       hi2c->XferSize--;
;;;4675       hi2c->XferCount--;
;;;4676     }
;;;4677     else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
;;;4678     {
;;;4679       if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
;;;4680       {
;;;4681         devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
;;;4682   
;;;4683         if (hi2c->XferCount > MAX_NBYTE_SIZE)
;;;4684         {
;;;4685           hi2c->XferSize = MAX_NBYTE_SIZE;
;;;4686           I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;4687         }
;;;4688         else
;;;4689         {
;;;4690           hi2c->XferSize = hi2c->XferCount;
;;;4691           if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
;;;4692           {
;;;4693             I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
;;;4694           }
;;;4695           else
;;;4696           {
;;;4697             I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;4698           }
;;;4699         }
;;;4700       }
;;;4701       else
;;;4702       {
;;;4703         /* Call TxCpltCallback() if no stop mode is set */
;;;4704         if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
;;;4705         {
;;;4706           /* Call I2C Master Sequential complete process */
;;;4707           I2C_ITMasterSeqCplt(hi2c);
;;;4708         }
;;;4709         else
;;;4710         {
;;;4711           /* Wrong size Status regarding TCR flag event */
;;;4712           /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4713           I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
;;;4714         }
;;;4715       }
;;;4716     }
;;;4717     else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
;;;4718     {
;;;4719       if (hi2c->XferCount == 0U)
;;;4720       {
;;;4721         if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
;;;4722         {
;;;4723           /* Generate a stop condition in case of no transfer option */
;;;4724           if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
;;;4725           {
;;;4726             /* Generate Stop */
;;;4727             hi2c->Instance->CR2 |= I2C_CR2_STOP;
;;;4728           }
;;;4729           else
;;;4730           {
;;;4731             /* Call I2C Master Sequential complete process */
;;;4732             I2C_ITMasterSeqCplt(hi2c);
;;;4733           }
;;;4734         }
;;;4735       }
;;;4736       else
;;;4737       {
;;;4738         /* Wrong size Status regarding TC flag event */
;;;4739         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4740         I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
;;;4741       }
;;;4742     }
;;;4743     else
;;;4744     {
;;;4745       /* Nothing to do */
;;;4746     }
;;;4747   
;;;4748     if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
;;;4749     {
;;;4750       /* Call I2C Master complete process */
;;;4751       I2C_ITMasterCplt(hi2c, tmpITFlags);
;;;4752     }
;;;4753   
;;;4754     /* Process Unlocked */
;;;4755     __HAL_UNLOCK(hi2c);
;;;4756   
;;;4757     return HAL_OK;
;;;4758   }
00003e  bdf8              POP      {r3-r7,pc}
                  |L69.64|
000040  0741              LSLS     r1,r0,#29             ;4652
000042  d411              BMI      |L69.104|
000044  0769              LSLS     r1,r5,#29             ;4652
000046  d40f              BMI      |L69.104|
000048  f0260604          BIC      r6,r6,#4              ;4655
00004c  6820              LDR      r0,[r4,#0]            ;4658
00004e  6a40              LDR      r0,[r0,#0x24]         ;4658
000050  6a61              LDR      r1,[r4,#0x24]         ;4658
000052  7008              STRB     r0,[r1,#0]            ;4658
000054  6a60              LDR      r0,[r4,#0x24]         ;4661
000056  1c40              ADDS     r0,r0,#1              ;4661
000058  6260              STR      r0,[r4,#0x24]         ;4661
00005a  8d20              LDRH     r0,[r4,#0x28]         ;4663
00005c  1e40              SUBS     r0,r0,#1              ;4663
00005e  8520              STRH     r0,[r4,#0x28]         ;4663
000060  8d60              LDRH     r0,[r4,#0x2a]         ;4664
000062  1e40              SUBS     r0,r0,#1              ;4664
000064  8560              STRH     r0,[r4,#0x2a]         ;4664
000066  e057              B        |L69.280|
                  |L69.104|
000068  0781              LSLS     r1,r0,#30             ;4666
00006a  d40f              BMI      |L69.140|
00006c  07a9              LSLS     r1,r5,#30             ;4666
00006e  d40d              BMI      |L69.140|
000070  6a60              LDR      r0,[r4,#0x24]         ;4669
000072  6821              LDR      r1,[r4,#0]            ;4669
000074  7800              LDRB     r0,[r0,#0]            ;4669
000076  6288              STR      r0,[r1,#0x28]         ;4669
000078  6a60              LDR      r0,[r4,#0x24]         ;4672
00007a  1c40              ADDS     r0,r0,#1              ;4672
00007c  6260              STR      r0,[r4,#0x24]         ;4672
00007e  8d20              LDRH     r0,[r4,#0x28]         ;4674
000080  1e40              SUBS     r0,r0,#1              ;4674
000082  8520              STRH     r0,[r4,#0x28]         ;4674
000084  8d60              LDRH     r0,[r4,#0x2a]         ;4675
000086  1e40              SUBS     r0,r0,#1              ;4675
000088  8560              STRH     r0,[r4,#0x2a]         ;4675
00008a  e045              B        |L69.280|
                  |L69.140|
00008c  4a31              LDR      r2,|L69.340|
00008e  0601              LSLS     r1,r0,#24             ;4677
000090  d438              BMI      |L69.260|
000092  0669              LSLS     r1,r5,#25             ;4677
000094  d436              BMI      |L69.260|
000096  8d60              LDRH     r0,[r4,#0x2a]         ;4679
000098  b108              CBZ      r0,|L69.158|
00009a  8d20              LDRH     r0,[r4,#0x28]         ;4679
00009c  b138              CBZ      r0,|L69.174|
                  |L69.158|
00009e  6820              LDR      r0,[r4,#0]            ;4704
0000a0  6840              LDR      r0,[r0,#4]            ;4704
0000a2  0180              LSLS     r0,r0,#6              ;4704
0000a4  d429              BMI      |L69.250|
0000a6  4620              MOV      r0,r4                 ;4707
0000a8  f7fffffe          BL       I2C_ITMasterSeqCplt
0000ac  e034              B        |L69.280|
                  |L69.174|
0000ae  6820              LDR      r0,[r4,#0]            ;4681
0000b0  6840              LDR      r0,[r0,#4]            ;4681
0000b2  f3c00109          UBFX     r1,r0,#0,#10          ;4681
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;4683
0000b8  28ff              CMP      r0,#0xff              ;4683
0000ba  d908              BLS      |L69.206|
0000bc  22ff              MOVS     r2,#0xff              ;4685
0000be  8522              STRH     r2,[r4,#0x28]         ;4685
0000c0  f04f7380          MOV      r3,#0x1000000         ;4686
0000c4  4620              MOV      r0,r4                 ;4686
0000c6  9700              STR      r7,[sp,#0]            ;4686
0000c8  f7fffffe          BL       I2C_TransferConfig
0000cc  e024              B        |L69.280|
                  |L69.206|
0000ce  8d60              LDRH     r0,[r4,#0x2a]         ;4690
0000d0  8520              STRH     r0,[r4,#0x28]         ;4690
0000d2  6ae0              LDR      r0,[r4,#0x2c]         ;4691
0000d4  4290              CMP      r0,r2                 ;4691
0000d6  d007              BEQ      |L69.232|
0000d8  9700              STR      r7,[sp,#0]            ;4693
0000da  6ae3              LDR      r3,[r4,#0x2c]         ;4693
0000dc  f8942028          LDRB     r2,[r4,#0x28]         ;4693
0000e0  4620              MOV      r0,r4                 ;4693
0000e2  f7fffffe          BL       I2C_TransferConfig
0000e6  e017              B        |L69.280|
                  |L69.232|
0000e8  9700              STR      r7,[sp,#0]            ;4697
0000ea  f8942028          LDRB     r2,[r4,#0x28]         ;4697
0000ee  f04f7300          MOV      r3,#0x2000000         ;4697
0000f2  4620              MOV      r0,r4                 ;4697
0000f4  f7fffffe          BL       I2C_TransferConfig
0000f8  e00e              B        |L69.280|
                  |L69.250|
0000fa  2140              MOVS     r1,#0x40              ;4713
0000fc  4620              MOV      r0,r4                 ;4713
0000fe  f7fffffe          BL       I2C_ITError
000102  e009              B        |L69.280|
                  |L69.260|
000104  0640              LSLS     r0,r0,#25             ;4717
000106  d407              BMI      |L69.280|
000108  0668              LSLS     r0,r5,#25             ;4717
00010a  d405              BMI      |L69.280|
00010c  8d60              LDRH     r0,[r4,#0x2a]         ;4719
00010e  b180              CBZ      r0,|L69.306|
000110  2140              MOVS     r1,#0x40              ;4740
000112  4620              MOV      r0,r4                 ;4740
000114  f7fffffe          BL       I2C_ITError
                  |L69.280|
000118  43f0              MVNS     r0,r6                 ;4748
00011a  0680              LSLS     r0,r0,#26             ;4748
00011c  d405              BMI      |L69.298|
00011e  06a8              LSLS     r0,r5,#26             ;4748
000120  d403              BMI      |L69.298|
000122  4631              MOV      r1,r6                 ;4751
000124  4620              MOV      r0,r4                 ;4751
000126  f7fffffe          BL       I2C_ITMasterCplt
                  |L69.298|
00012a  f8847040          STRB     r7,[r4,#0x40]         ;4755
00012e  2000              MOVS     r0,#0                 ;4757
000130  bdf8              POP      {r3-r7,pc}
                  |L69.306|
000132  6820              LDR      r0,[r4,#0]            ;4721
000134  6841              LDR      r1,[r0,#4]            ;4721
000136  0189              LSLS     r1,r1,#6              ;4721
000138  d4ee              BMI      |L69.280|
00013a  6ae1              LDR      r1,[r4,#0x2c]         ;4724
00013c  4291              CMP      r1,r2                 ;4724
00013e  d104              BNE      |L69.330|
000140  6841              LDR      r1,[r0,#4]            ;4727
000142  f4414180          ORR      r1,r1,#0x4000         ;4727
000146  6041              STR      r1,[r0,#4]            ;4727
000148  e7e6              B        |L69.280|
                  |L69.330|
00014a  4620              MOV      r0,r4                 ;4732
00014c  f7fffffe          BL       I2C_ITMasterSeqCplt
000150  e7e2              B        |L69.280|
;;;4759   
                          ENDP

000152  0000              DCW      0x0000
                  |L69.340|
                          DCD      0xffff0000

                          AREA ||i.I2C_RequestMemoryRead||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryRead PROC
;;;5231     */
;;;5232   static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;5233                                                  uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
;;;5234   {
000004  4604              MOV      r4,r0
000006  e9dd9808          LDRD     r9,r8,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;5235     I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
00000e  4818              LDR      r0,|L70.112|
000010  9000              STR      r0,[sp,#0]
000012  b2fa              UXTB     r2,r7
000014  2300              MOVS     r3,#0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       I2C_TransferConfig
;;;5236   
;;;5237     /* Wait until TXIS flag is set */
;;;5238     if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
00001c  4642              MOV      r2,r8
00001e  4649              MOV      r1,r9
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
000026  b110              CBZ      r0,|L70.46|
;;;5239     {
;;;5240       return HAL_ERROR;
000028  2001              MOVS     r0,#1
                  |L70.42|
;;;5241     }
;;;5242   
;;;5243     /* If Memory address size is 8Bit */
;;;5244     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;5245     {
;;;5246       /* Send Memory Address */
;;;5247       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;5248     }
;;;5249     /* If Memory address size is 16Bit */
;;;5250     else
;;;5251     {
;;;5252       /* Send MSB of Memory Address */
;;;5253       hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
;;;5254   
;;;5255       /* Wait until TXIS flag is set */
;;;5256       if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;5257       {
;;;5258         return HAL_ERROR;
;;;5259       }
;;;5260   
;;;5261       /* Send LSB of Memory Address */
;;;5262       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;5263     }
;;;5264   
;;;5265     /* Wait until TC flag is set */
;;;5266     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
;;;5267     {
;;;5268       return HAL_ERROR;
;;;5269     }
;;;5270   
;;;5271     return HAL_OK;
;;;5272   }
00002a  e8bd83f8          POP      {r3-r9,pc}
                  |L70.46|
00002e  b2f5              UXTB     r5,r6                 ;5247
000030  2f01              CMP      r7,#1                 ;5244
000032  d00a              BEQ      |L70.74|
000034  6821              LDR      r1,[r4,#0]            ;5253
000036  0a30              LSRS     r0,r6,#8              ;5253
000038  6288              STR      r0,[r1,#0x28]         ;5253
00003a  4642              MOV      r2,r8                 ;5256
00003c  4649              MOV      r1,r9                 ;5256
00003e  4620              MOV      r0,r4                 ;5256
000040  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
000044  b120              CBZ      r0,|L70.80|
000046  2001              MOVS     r0,#1                 ;5258
000048  e7ef              B        |L70.42|
                  |L70.74|
00004a  6820              LDR      r0,[r4,#0]            ;5247
00004c  6285              STR      r5,[r0,#0x28]         ;5247
00004e  e001              B        |L70.84|
                  |L70.80|
000050  6820              LDR      r0,[r4,#0]            ;5262
000052  6285              STR      r5,[r0,#0x28]         ;5262
                  |L70.84|
000054  464b              MOV      r3,r9                 ;5266
000056  2200              MOVS     r2,#0                 ;5266
000058  2140              MOVS     r1,#0x40              ;5266
00005a  4620              MOV      r0,r4                 ;5266
00005c  f8cd8000          STR      r8,[sp,#0]            ;5266
000060  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000064  b108              CBZ      r0,|L70.106|
000066  2001              MOVS     r0,#1                 ;5268
000068  e7df              B        |L70.42|
                  |L70.106|
00006a  2000              MOVS     r0,#0                 ;5271
00006c  e7dd              B        |L70.42|
;;;5273   
                          ENDP

00006e  0000              DCW      0x0000
                  |L70.112|
                          DCD      0x80002000

                          AREA ||i.I2C_RequestMemoryWrite||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryWrite PROC
;;;5177     */
;;;5178   static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;5179                                                   uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
;;;5180   {
000004  4604              MOV      r4,r0
000006  e9dd9808          LDRD     r9,r8,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;5181     I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
00000e  4818              LDR      r0,|L71.112|
000010  9000              STR      r0,[sp,#0]
000012  02c3              LSLS     r3,r0,#11
000014  b2fa              UXTB     r2,r7
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       I2C_TransferConfig
;;;5182   
;;;5183     /* Wait until TXIS flag is set */
;;;5184     if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
00001c  4642              MOV      r2,r8
00001e  4649              MOV      r1,r9
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
000026  b110              CBZ      r0,|L71.46|
;;;5185     {
;;;5186       return HAL_ERROR;
000028  2001              MOVS     r0,#1
                  |L71.42|
;;;5187     }
;;;5188   
;;;5189     /* If Memory address size is 8Bit */
;;;5190     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;5191     {
;;;5192       /* Send Memory Address */
;;;5193       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;5194     }
;;;5195     /* If Memory address size is 16Bit */
;;;5196     else
;;;5197     {
;;;5198       /* Send MSB of Memory Address */
;;;5199       hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
;;;5200   
;;;5201       /* Wait until TXIS flag is set */
;;;5202       if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;5203       {
;;;5204         return HAL_ERROR;
;;;5205       }
;;;5206   
;;;5207       /* Send LSB of Memory Address */
;;;5208       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;5209     }
;;;5210   
;;;5211     /* Wait until TCR flag is set */
;;;5212     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
;;;5213     {
;;;5214       return HAL_ERROR;
;;;5215     }
;;;5216   
;;;5217     return HAL_OK;
;;;5218   }
00002a  e8bd83f8          POP      {r3-r9,pc}
                  |L71.46|
00002e  b2f5              UXTB     r5,r6                 ;5193
000030  2f01              CMP      r7,#1                 ;5190
000032  d00a              BEQ      |L71.74|
000034  6821              LDR      r1,[r4,#0]            ;5199
000036  0a30              LSRS     r0,r6,#8              ;5199
000038  6288              STR      r0,[r1,#0x28]         ;5199
00003a  4642              MOV      r2,r8                 ;5202
00003c  4649              MOV      r1,r9                 ;5202
00003e  4620              MOV      r0,r4                 ;5202
000040  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
000044  b120              CBZ      r0,|L71.80|
000046  2001              MOVS     r0,#1                 ;5204
000048  e7ef              B        |L71.42|
                  |L71.74|
00004a  6820              LDR      r0,[r4,#0]            ;5193
00004c  6285              STR      r5,[r0,#0x28]         ;5193
00004e  e001              B        |L71.84|
                  |L71.80|
000050  6820              LDR      r0,[r4,#0]            ;5208
000052  6285              STR      r5,[r0,#0x28]         ;5208
                  |L71.84|
000054  464b              MOV      r3,r9                 ;5212
000056  2200              MOVS     r2,#0                 ;5212
000058  2180              MOVS     r1,#0x80              ;5212
00005a  4620              MOV      r0,r4                 ;5212
00005c  f8cd8000          STR      r8,[sp,#0]            ;5212
000060  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000064  b108              CBZ      r0,|L71.106|
000066  2001              MOVS     r0,#1                 ;5214
000068  e7df              B        |L71.42|
                  |L71.106|
00006a  2000              MOVS     r0,#0                 ;5217
00006c  e7dd              B        |L71.42|
;;;5219   
                          ENDP

00006e  0000              DCW      0x0000
                  |L71.112|
                          DCD      0x80002000

                          AREA ||i.I2C_Slave_ISR_DMA||, CODE, READONLY, ALIGN=1

                  I2C_Slave_ISR_DMA PROC
;;;5037     */
;;;5038   static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;5039   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;5040     uint32_t tmpoptions = hi2c->XferOptions;
000008  6ae6              LDR      r6,[r4,#0x2c]
;;;5041     uint32_t treatdmanack = 0U;
00000a  2700              MOVS     r7,#0
;;;5042     HAL_I2C_StateTypeDef tmpstate;
;;;5043   
;;;5044     /* Process locked */
;;;5045     __HAL_LOCK(hi2c);
00000c  f8940040          LDRB     r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d022              BEQ      |L72.90|
000014  2001              MOVS     r0,#1
000016  f8840040          STRB     r0,[r4,#0x40]
;;;5046   
;;;5047     /* Check if STOPF is set */
;;;5048     if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
00001a  ea6f0809          MVN      r8,r9
00001e  ea5f6088          LSLS     r0,r8,#26
000022  ea6f0502          MVN      r5,r2
000026  d405              BMI      |L72.52|
000028  06a8              LSLS     r0,r5,#26
00002a  d403              BMI      |L72.52|
;;;5049     {
;;;5050       /* Call I2C Slave complete process */
;;;5051       I2C_ITSlaveCplt(hi2c, ITFlags);
00002c  4649              MOV      r1,r9
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       I2C_ITSlaveCplt
                  |L72.52|
;;;5052     }
;;;5053   
;;;5054     if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
000034  ea5f60c8          LSLS     r0,r8,#27
000038  d460              BMI      |L72.252|
00003a  06e8              LSLS     r0,r5,#27
00003c  d45e              BMI      |L72.252|
;;;5055     {
;;;5056       /* Check that I2C transfer finished */
;;;5057       /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
;;;5058       /* Mean XferCount == 0 */
;;;5059       /* So clear Flag NACKF only */
;;;5060       if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
00003e  0468              LSLS     r0,r5,#17
;;;5061           (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
;;;5062       {
;;;5063         /* Split check of hdmarx, for MISRA compliance */
;;;5064         if (hi2c->hdmarx != NULL)
;;;5065         {
;;;5066           if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
;;;5067           {
;;;5068             if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
;;;5069             {
;;;5070               treatdmanack = 1U;
;;;5071             }
;;;5072           }
;;;5073         }
;;;5074   
;;;5075         /* Split check of hdmatx, for MISRA compliance  */
;;;5076         if (hi2c->hdmatx != NULL)
;;;5077         {
;;;5078           if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
;;;5079           {
;;;5080             if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
;;;5081             {
;;;5082               treatdmanack = 1U;
;;;5083             }
;;;5084           }
;;;5085         }
;;;5086   
;;;5087         if (treatdmanack == 1U)
;;;5088         {
;;;5089           /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
;;;5090           if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
;;;5091           {
;;;5092             /* Call I2C Listen complete process */
;;;5093             I2C_ITListenCplt(hi2c, ITFlags);
;;;5094           }
;;;5095           else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
;;;5096           {
;;;5097             /* Clear NACK Flag */
;;;5098             __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000040  f04f0110          MOV      r1,#0x10
000044  d501              BPL      |L72.74|
000046  0428              LSLS     r0,r5,#16             ;5061
000048  d455              BMI      |L72.246|
                  |L72.74|
00004a  6be0              LDR      r0,[r4,#0x3c]         ;5064
00004c  b148              CBZ      r0,|L72.98|
00004e  042a              LSLS     r2,r5,#16             ;5066
000050  d407              BMI      |L72.98|
000052  6800              LDR      r0,[r0,#0]            ;5068
000054  6840              LDR      r0,[r0,#4]            ;5068
000056  b118              CBZ      r0,|L72.96|
000058  e003              B        |L72.98|
                  |L72.90|
00005a  2002              MOVS     r0,#2                 ;5045
                  |L72.92|
;;;5099   
;;;5100             /* Flush TX register */
;;;5101             I2C_Flush_TXDR(hi2c);
;;;5102   
;;;5103             /* Last Byte is Transmitted */
;;;5104             /* Call I2C Slave Sequential complete process */
;;;5105             I2C_ITSlaveSeqCplt(hi2c);
;;;5106           }
;;;5107           else
;;;5108           {
;;;5109             /* Clear NACK Flag */
;;;5110             __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;5111           }
;;;5112         }
;;;5113         else
;;;5114         {
;;;5115           /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
;;;5116           /* Clear NACK Flag */
;;;5117           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;5118   
;;;5119           /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;5120           hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
;;;5121   
;;;5122           /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
;;;5123           tmpstate = hi2c->State;
;;;5124   
;;;5125           if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
;;;5126           {
;;;5127             if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
;;;5128             {
;;;5129               hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
;;;5130             }
;;;5131             else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
;;;5132             {
;;;5133               hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
;;;5134             }
;;;5135             else
;;;5136             {
;;;5137               /* Do nothing */
;;;5138             }
;;;5139   
;;;5140             /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5141             I2C_ITError(hi2c, hi2c->ErrorCode);
;;;5142           }
;;;5143         }
;;;5144       }
;;;5145       else
;;;5146       {
;;;5147         /* Only Clear NACK Flag, no DMA treatment is pending */
;;;5148         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;5149       }
;;;5150     }
;;;5151     else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
;;;5152     {
;;;5153       I2C_ITAddrCplt(hi2c, ITFlags);
;;;5154     }
;;;5155     else
;;;5156     {
;;;5157       /* Nothing to do */
;;;5158     }
;;;5159   
;;;5160     /* Process Unlocked */
;;;5161     __HAL_UNLOCK(hi2c);
;;;5162   
;;;5163     return HAL_OK;
;;;5164   }
00005c  e8bd87f0          POP      {r4-r10,pc}
                  |L72.96|
000060  2701              MOVS     r7,#1                 ;5070
                  |L72.98|
000062  6ba0              LDR      r0,[r4,#0x38]         ;5076
000064  b128              CBZ      r0,|L72.114|
000066  046a              LSLS     r2,r5,#17             ;5078
000068  d403              BMI      |L72.114|
00006a  6800              LDR      r0,[r0,#0]            ;5080
00006c  6840              LDR      r0,[r0,#4]            ;5080
00006e  b900              CBNZ     r0,|L72.114|
000070  2701              MOVS     r7,#1                 ;5082
                  |L72.114|
000072  2f01              CMP      r7,#1                 ;5087
000074  d00c              BEQ      |L72.144|
000076  6820              LDR      r0,[r4,#0]            ;5117
000078  61c1              STR      r1,[r0,#0x1c]         ;5117
00007a  6c60              LDR      r0,[r4,#0x44]         ;5120
00007c  f0400004          ORR      r0,r0,#4              ;5120
000080  6460              STR      r0,[r4,#0x44]         ;5120
000082  f8940041          LDRB     r0,[r4,#0x41]         ;5123
000086  b31e              CBZ      r6,|L72.208|
000088  f1b67f80          CMP      r6,#0x1000000         ;5125
00008c  d020              BEQ      |L72.208|
00008e  e03e              B        |L72.270|
                  |L72.144|
000090  f8940041          LDRB     r0,[r4,#0x41]         ;5090
000094  2828              CMP      r0,#0x28              ;5090
000096  d102              BNE      |L72.158|
000098  f1b67f00          CMP      r6,#0x2000000         ;5090
00009c  d004              BEQ      |L72.168|
                  |L72.158|
00009e  f8940041          LDRB     r0,[r4,#0x41]         ;5095
0000a2  2829              CMP      r0,#0x29              ;5095
0000a4  d005              BEQ      |L72.178|
0000a6  e010              B        |L72.202|
                  |L72.168|
0000a8  4649              MOV      r1,r9                 ;5093
0000aa  4620              MOV      r0,r4                 ;5093
0000ac  f7fffffe          BL       I2C_ITListenCplt
0000b0  e02d              B        |L72.270|
                  |L72.178|
0000b2  f5163f80          CMN      r6,#0x10000           ;5095
0000b6  d008              BEQ      |L72.202|
0000b8  6820              LDR      r0,[r4,#0]            ;5098
0000ba  61c1              STR      r1,[r0,#0x1c]         ;5098
0000bc  4620              MOV      r0,r4                 ;5101
0000be  f7fffffe          BL       I2C_Flush_TXDR
0000c2  4620              MOV      r0,r4                 ;5105
0000c4  f7fffffe          BL       I2C_ITSlaveSeqCplt
0000c8  e021              B        |L72.270|
                  |L72.202|
0000ca  6820              LDR      r0,[r4,#0]            ;5110
0000cc  61c1              STR      r1,[r0,#0x1c]         ;5110
0000ce  e01e              B        |L72.270|
                  |L72.208|
0000d0  2821              CMP      r0,#0x21              ;5127
0000d2  d006              BEQ      |L72.226|
0000d4  2829              CMP      r0,#0x29              ;5127
0000d6  d004              BEQ      |L72.226|
0000d8  2822              CMP      r0,#0x22              ;5131
0000da  d005              BEQ      |L72.232|
0000dc  282a              CMP      r0,#0x2a              ;5131
0000de  d003              BEQ      |L72.232|
0000e0  e004              B        |L72.236|
                  |L72.226|
0000e2  2021              MOVS     r0,#0x21              ;5129
0000e4  6320              STR      r0,[r4,#0x30]         ;5129
0000e6  e001              B        |L72.236|
                  |L72.232|
0000e8  2022              MOVS     r0,#0x22              ;5133
0000ea  6320              STR      r0,[r4,#0x30]         ;5133
                  |L72.236|
0000ec  6c61              LDR      r1,[r4,#0x44]         ;5141
0000ee  4620              MOV      r0,r4                 ;5141
0000f0  f7fffffe          BL       I2C_ITError
0000f4  e00b              B        |L72.270|
                  |L72.246|
0000f6  6820              LDR      r0,[r4,#0]            ;5148
0000f8  61c1              STR      r1,[r0,#0x1c]         ;5148
0000fa  e008              B        |L72.270|
                  |L72.252|
0000fc  ea5f7008          LSLS     r0,r8,#28             ;5151
000100  d405              BMI      |L72.270|
000102  0728              LSLS     r0,r5,#28             ;5151
000104  d403              BMI      |L72.270|
000106  4649              MOV      r1,r9                 ;5153
000108  4620              MOV      r0,r4                 ;5153
00010a  f7fffffe          BL       I2C_ITAddrCplt
                  |L72.270|
00010e  2000              MOVS     r0,#0                 ;5161
000110  f8840040          STRB     r0,[r4,#0x40]         ;5161
000114  e7a2              B        |L72.92|
;;;5165   
                          ENDP


                          AREA ||i.I2C_Slave_ISR_IT||, CODE, READONLY, ALIGN=2

                  I2C_Slave_ISR_IT PROC
;;;4767     */
;;;4768   static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4769   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;4770     uint32_t tmpoptions = hi2c->XferOptions;
000008  6ae5              LDR      r5,[r4,#0x2c]
;;;4771     uint32_t tmpITFlags = ITFlags;
;;;4772   
;;;4773     /* Process locked */
;;;4774     __HAL_LOCK(hi2c);
00000a  f8940040          LDRB     r0,[r4,#0x40]
00000e  2801              CMP      r0,#1
000010  d026              BEQ      |L73.96|
000012  2001              MOVS     r0,#1
000014  f8840040          STRB     r0,[r4,#0x40]
;;;4775   
;;;4776     /* Check if STOPF is set */
;;;4777     if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
000018  ea6f0708          MVN      r7,r8
00001c  06b8              LSLS     r0,r7,#26
00001e  ea6f0602          MVN      r6,r2
000022  d405              BMI      |L73.48|
000024  06b0              LSLS     r0,r6,#26
000026  d403              BMI      |L73.48|
;;;4778     {
;;;4779       /* Call I2C Slave complete process */
;;;4780       I2C_ITSlaveCplt(hi2c, tmpITFlags);
000028  4641              MOV      r1,r8
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       I2C_ITSlaveCplt
                  |L73.48|
;;;4781     }
;;;4782   
;;;4783     if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
;;;4784     {
;;;4785       /* Check that I2C transfer finished */
;;;4786       /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
;;;4787       /* Mean XferCount == 0*/
;;;4788       /* So clear Flag NACKF only */
;;;4789       if (hi2c->XferCount == 0U)
;;;4790       {
;;;4791         /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
;;;4792         if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
;;;4793         {
;;;4794           /* Call I2C Listen complete process */
;;;4795           I2C_ITListenCplt(hi2c, tmpITFlags);
;;;4796         }
;;;4797         else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
000030  493d              LDR      r1,|L73.296|
000032  06f8              LSLS     r0,r7,#27             ;4783
;;;4798         {
;;;4799           /* Clear NACK Flag */
;;;4800           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;4801   
;;;4802           /* Flush TX register */
;;;4803           I2C_Flush_TXDR(hi2c);
;;;4804   
;;;4805           /* Last Byte is Transmitted */
;;;4806           /* Call I2C Slave Sequential complete process */
;;;4807           I2C_ITSlaveSeqCplt(hi2c);
;;;4808         }
;;;4809         else
;;;4810         {
;;;4811           /* Clear NACK Flag */
;;;4812           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;4813         }
;;;4814       }
;;;4815       else
;;;4816       {
;;;4817         /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
;;;4818         /* Clear NACK Flag */
;;;4819         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;4820   
;;;4821         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;4822         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
;;;4823   
;;;4824         if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
000034  f04f7280          MOV      r2,#0x1000000
000038  d434              BMI      |L73.164|
00003a  06f0              LSLS     r0,r6,#27             ;4783
00003c  d432              BMI      |L73.164|
00003e  8d63              LDRH     r3,[r4,#0x2a]         ;4789
000040  2010              MOVS     r0,#0x10              ;4800
000042  b183              CBZ      r3,|L73.102|
000044  6821              LDR      r1,[r4,#0]            ;4819
000046  61c8              STR      r0,[r1,#0x1c]         ;4819
000048  6c60              LDR      r0,[r4,#0x44]         ;4822
00004a  f0400004          ORR      r0,r0,#4              ;4822
00004e  6460              STR      r0,[r4,#0x44]         ;4822
000050  b10d              CBZ      r5,|L73.86|
000052  4295              CMP      r5,r2
000054  d164              BNE      |L73.288|
                  |L73.86|
;;;4825         {
;;;4826           /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4827           I2C_ITError(hi2c, hi2c->ErrorCode);
000056  6c61              LDR      r1,[r4,#0x44]
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       I2C_ITError
00005e  e05f              B        |L73.288|
                  |L73.96|
000060  2002              MOVS     r0,#2                 ;4774
                  |L73.98|
;;;4828         }
;;;4829       }
;;;4830     }
;;;4831     else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
;;;4832     {
;;;4833       if (hi2c->XferCount > 0U)
;;;4834       {
;;;4835         /* Read data from RXDR */
;;;4836         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
;;;4837   
;;;4838         /* Increment Buffer pointer */
;;;4839         hi2c->pBuffPtr++;
;;;4840   
;;;4841         hi2c->XferSize--;
;;;4842         hi2c->XferCount--;
;;;4843       }
;;;4844   
;;;4845       if ((hi2c->XferCount == 0U) && \
;;;4846           (tmpoptions != I2C_NO_OPTION_FRAME))
;;;4847       {
;;;4848         /* Call I2C Slave Sequential complete process */
;;;4849         I2C_ITSlaveSeqCplt(hi2c);
;;;4850       }
;;;4851     }
;;;4852     else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
;;;4853              (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
;;;4854     {
;;;4855       I2C_ITAddrCplt(hi2c, tmpITFlags);
;;;4856     }
;;;4857     else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
;;;4858     {
;;;4859       /* Write data to TXDR only if XferCount not reach "0" */
;;;4860       /* A TXIS flag can be set, during STOP treatment      */
;;;4861       /* Check if all data have already been sent */
;;;4862       /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
;;;4863       if (hi2c->XferCount > 0U)
;;;4864       {
;;;4865         /* Write data to TXDR */
;;;4866         hi2c->Instance->TXDR = *hi2c->pBuffPtr;
;;;4867   
;;;4868         /* Increment Buffer pointer */
;;;4869         hi2c->pBuffPtr++;
;;;4870   
;;;4871         hi2c->XferCount--;
;;;4872         hi2c->XferSize--;
;;;4873       }
;;;4874       else
;;;4875       {
;;;4876         if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
;;;4877         {
;;;4878           /* Last Byte is Transmitted */
;;;4879           /* Call I2C Slave Sequential complete process */
;;;4880           I2C_ITSlaveSeqCplt(hi2c);
;;;4881         }
;;;4882       }
;;;4883     }
;;;4884     else
;;;4885     {
;;;4886       /* Nothing to do */
;;;4887     }
;;;4888   
;;;4889     /* Process Unlocked */
;;;4890     __HAL_UNLOCK(hi2c);
;;;4891   
;;;4892     return HAL_OK;
;;;4893   }
000062  e8bd81f0          POP      {r4-r8,pc}
                  |L73.102|
000066  f8942041          LDRB     r2,[r4,#0x41]         ;4792
00006a  2a28              CMP      r2,#0x28              ;4792
00006c  d102              BNE      |L73.116|
00006e  f1b57f00          CMP      r5,#0x2000000         ;4792
000072  d004              BEQ      |L73.126|
                  |L73.116|
000074  f8942041          LDRB     r2,[r4,#0x41]         ;4797
000078  2a29              CMP      r2,#0x29              ;4797
00007a  d005              BEQ      |L73.136|
00007c  e00f              B        |L73.158|
                  |L73.126|
00007e  4641              MOV      r1,r8                 ;4795
000080  4620              MOV      r0,r4                 ;4795
000082  f7fffffe          BL       I2C_ITListenCplt
000086  e04b              B        |L73.288|
                  |L73.136|
000088  428d              CMP      r5,r1                 ;4797
00008a  d008              BEQ      |L73.158|
00008c  6821              LDR      r1,[r4,#0]            ;4800
00008e  61c8              STR      r0,[r1,#0x1c]         ;4800
000090  4620              MOV      r0,r4                 ;4803
000092  f7fffffe          BL       I2C_Flush_TXDR
000096  4620              MOV      r0,r4                 ;4807
000098  f7fffffe          BL       I2C_ITSlaveSeqCplt
00009c  e040              B        |L73.288|
                  |L73.158|
00009e  6821              LDR      r1,[r4,#0]            ;4812
0000a0  61c8              STR      r0,[r1,#0x1c]         ;4812
0000a2  e03d              B        |L73.288|
                  |L73.164|
0000a4  0778              LSLS     r0,r7,#29             ;4831
0000a6  d418              BMI      |L73.218|
0000a8  0770              LSLS     r0,r6,#29             ;4831
0000aa  d416              BMI      |L73.218|
0000ac  8d60              LDRH     r0,[r4,#0x2a]         ;4833
0000ae  b160              CBZ      r0,|L73.202|
0000b0  6820              LDR      r0,[r4,#0]            ;4836
0000b2  6a40              LDR      r0,[r0,#0x24]         ;4836
0000b4  6a62              LDR      r2,[r4,#0x24]         ;4836
0000b6  7010              STRB     r0,[r2,#0]            ;4836
0000b8  6a60              LDR      r0,[r4,#0x24]         ;4839
0000ba  1c40              ADDS     r0,r0,#1              ;4839
0000bc  6260              STR      r0,[r4,#0x24]         ;4839
0000be  8d20              LDRH     r0,[r4,#0x28]         ;4841
0000c0  1e40              SUBS     r0,r0,#1              ;4841
0000c2  8520              STRH     r0,[r4,#0x28]         ;4841
0000c4  8d60              LDRH     r0,[r4,#0x2a]         ;4842
0000c6  1e40              SUBS     r0,r0,#1              ;4842
0000c8  8560              STRH     r0,[r4,#0x2a]         ;4842
                  |L73.202|
0000ca  8d60              LDRH     r0,[r4,#0x2a]         ;4845
0000cc  bb08              CBNZ     r0,|L73.274|
0000ce  428d              CMP      r5,r1                 ;4846
0000d0  d026              BEQ      |L73.288|
0000d2  4620              MOV      r0,r4                 ;4849
0000d4  f7fffffe          BL       I2C_ITSlaveSeqCplt
0000d8  e022              B        |L73.288|
                  |L73.218|
0000da  0738              LSLS     r0,r7,#28             ;4852
0000dc  d406              BMI      |L73.236|
0000de  0730              LSLS     r0,r6,#28             ;4853
0000e0  d404              BMI      |L73.236|
0000e2  4641              MOV      r1,r8                 ;4855
0000e4  4620              MOV      r0,r4                 ;4855
0000e6  f7fffffe          BL       I2C_ITAddrCplt
0000ea  e019              B        |L73.288|
                  |L73.236|
0000ec  07b8              LSLS     r0,r7,#30             ;4857
0000ee  d417              BMI      |L73.288|
0000f0  07b0              LSLS     r0,r6,#30             ;4857
0000f2  d415              BMI      |L73.288|
0000f4  8d60              LDRH     r0,[r4,#0x2a]         ;4863
0000f6  b168              CBZ      r0,|L73.276|
0000f8  6a60              LDR      r0,[r4,#0x24]         ;4866
0000fa  6821              LDR      r1,[r4,#0]            ;4866
0000fc  7800              LDRB     r0,[r0,#0]            ;4866
0000fe  6288              STR      r0,[r1,#0x28]         ;4866
000100  6a60              LDR      r0,[r4,#0x24]         ;4869
000102  1c40              ADDS     r0,r0,#1              ;4869
000104  6260              STR      r0,[r4,#0x24]         ;4869
000106  8d60              LDRH     r0,[r4,#0x2a]         ;4871
000108  1e40              SUBS     r0,r0,#1              ;4871
00010a  8560              STRH     r0,[r4,#0x2a]         ;4871
00010c  8d20              LDRH     r0,[r4,#0x28]         ;4872
00010e  1e40              SUBS     r0,r0,#1              ;4872
000110  8520              STRH     r0,[r4,#0x28]         ;4872
                  |L73.274|
000112  e005              B        |L73.288|
                  |L73.276|
000114  4295              CMP      r5,r2                 ;4876
000116  d000              BEQ      |L73.282|
000118  b915              CBNZ     r5,|L73.288|
                  |L73.282|
00011a  4620              MOV      r0,r4                 ;4880
00011c  f7fffffe          BL       I2C_ITSlaveSeqCplt
                  |L73.288|
000120  2000              MOVS     r0,#0                 ;4890
000122  f8840040          STRB     r0,[r4,#0x40]         ;4890
000126  e79c              B        |L73.98|
;;;4894   
                          ENDP

                  |L73.296|
                          DCD      0xffff0000

                          AREA ||i.I2C_TransferConfig||, CODE, READONLY, ALIGN=2

                  I2C_TransferConfig PROC
;;;6452     */
;;;6453   static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;6454                                  uint32_t Request)
;;;6455   {
000002  9c05              LDR      r4,[sp,#0x14]
;;;6456     /* Check the parameters */
;;;6457     assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;6458     assert_param(IS_TRANSFER_MODE(Mode));
;;;6459     assert_param(IS_TRANSFER_REQUEST(Request));
;;;6460   
;;;6461     /* update CR2 register */
;;;6462     MODIFY_REG(hi2c->Instance->CR2,
000004  6800              LDR      r0,[r0,#0]
000006  6845              LDR      r5,[r0,#4]
000008  f44f6680          MOV      r6,#0x400
00000c  4f06              LDR      r7,|L74.40|
00000e  f3c10109          UBFX     r1,r1,#0,#10
000012  ea065654          AND      r6,r6,r4,LSR #21
000016  ea414102          ORR      r1,r1,r2,LSL #16
00001a  433e              ORRS     r6,r6,r7
00001c  4319              ORRS     r1,r1,r3
00001e  43b5              BICS     r5,r5,r6
000020  4321              ORRS     r1,r1,r4
000022  430d              ORRS     r5,r5,r1
000024  6045              STR      r5,[r0,#4]
;;;6463                ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
;;;6464                  (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
;;;6465                (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) |
;;;6466                           (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
;;;6467   }
000026  bdf0              POP      {r4-r7,pc}
;;;6468   
                          ENDP

                  |L74.40|
                          DCD      0x03ff63ff

                          AREA ||i.I2C_TreatErrorCallback||, CODE, READONLY, ALIGN=1

                  I2C_TreatErrorCallback PROC
;;;5966     */
;;;5967   static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;5968   {
;;;5969     if (hi2c->State == HAL_I2C_STATE_ABORT)
000002  f8902041          LDRB     r2,[r0,#0x41]
000006  2100              MOVS     r1,#0
000008  2a60              CMP      r2,#0x60
00000a  d005              BEQ      |L75.24|
;;;5970     {
;;;5971       hi2c->State = HAL_I2C_STATE_READY;
;;;5972       hi2c->PreviousState = I2C_STATE_NONE;
;;;5973   
;;;5974       /* Process Unlocked */
;;;5975       __HAL_UNLOCK(hi2c);
;;;5976   
;;;5977       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5978   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5979       hi2c->AbortCpltCallback(hi2c);
;;;5980   #else
;;;5981       HAL_I2C_AbortCpltCallback(hi2c);
;;;5982   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5983     }
;;;5984     else
;;;5985     {
;;;5986       hi2c->PreviousState = I2C_STATE_NONE;
00000c  6301              STR      r1,[r0,#0x30]
;;;5987   
;;;5988       /* Process Unlocked */
;;;5989       __HAL_UNLOCK(hi2c);
00000e  f8801040          STRB     r1,[r0,#0x40]
;;;5990   
;;;5991       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5992   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5993       hi2c->ErrorCallback(hi2c);
;;;5994   #else
;;;5995       HAL_I2C_ErrorCallback(hi2c);
000012  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;5996   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5997     }
;;;5998   }
000016  bd10              POP      {r4,pc}
                  |L75.24|
000018  2220              MOVS     r2,#0x20              ;5971
00001a  f8802041          STRB     r2,[r0,#0x41]         ;5971
00001e  6301              STR      r1,[r0,#0x30]         ;5972
000020  f8801040          STRB     r1,[r0,#0x40]         ;5975
000024  f7fffffe          BL       HAL_I2C_AbortCpltCallback
000028  bd10              POP      {r4,pc}
;;;5999   
                          ENDP


                          AREA ||i.I2C_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnFlagUntilTimeout PROC
;;;6219     */
;;;6220   static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6221                                                       uint32_t Timeout, uint32_t Tickstart)
;;;6222   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;6223     while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
;;;6224     {
;;;6225       /* Check for the Timeout */
;;;6226       if (Timeout != HAL_MAX_DELAY)
;;;6227       {
;;;6228         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6229         {
;;;6230           hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;6231           hi2c->State = HAL_I2C_STATE_READY;
;;;6232           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;6233   
;;;6234           /* Process Unlocked */
;;;6235           __HAL_UNLOCK(hi2c);
;;;6236           return HAL_ERROR;
000010  e008              B        |L76.36|
                  |L76.18|
000012  1c68              ADDS     r0,r5,#1              ;6226
000014  d006              BEQ      |L76.36|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;6228
00001e  42a8              CMP      r0,r5                 ;6228
000020  d80b              BHI      |L76.58|
000022  b155              CBZ      r5,|L76.58|
                  |L76.36|
000024  6820              LDR      r0,[r4,#0]            ;6223
000026  6980              LDR      r0,[r0,#0x18]         ;6223
000028  ea360000          BICS     r0,r6,r0              ;6223
00002c  d011              BEQ      |L76.82|
00002e  2000              MOVS     r0,#0                 ;6223
                  |L76.48|
000030  42b8              CMP      r0,r7                 ;6223
000032  d0ee              BEQ      |L76.18|
;;;6237         }
;;;6238       }
;;;6239     }
;;;6240     return HAL_OK;
000034  2000              MOVS     r0,#0
                  |L76.54|
;;;6241   }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L76.58|
00003a  3440              ADDS     r4,r4,#0x40           ;6230
00003c  6860              LDR      r0,[r4,#4]            ;6230
00003e  f0400020          ORR      r0,r0,#0x20           ;6230
000042  6060              STR      r0,[r4,#4]            ;6230
000044  2020              MOVS     r0,#0x20              ;6231
000046  7060              STRB     r0,[r4,#1]            ;6231
000048  2000              MOVS     r0,#0                 ;6232
00004a  70a0              STRB     r0,[r4,#2]            ;6232
00004c  7020              STRB     r0,[r4,#0]            ;6235
00004e  2001              MOVS     r0,#1                 ;6236
000050  e7f1              B        |L76.54|
                  |L76.82|
000052  2001              MOVS     r0,#1                 ;6223
000054  e7ec              B        |L76.48|
;;;6242   
                          ENDP


                          AREA ||i.I2C_WaitOnRXNEFlagUntilTimeout||, CODE, READONLY, ALIGN=2

                  I2C_WaitOnRXNEFlagUntilTimeout PROC
;;;6321     */
;;;6322   static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6323   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;6324     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
00000a  2700              MOVS     r7,#0
;;;6325     {
;;;6326       /* Check if a NACK is detected */
;;;6327       if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6328       {
;;;6329         return HAL_ERROR;
;;;6330       }
;;;6331   
;;;6332       /* Check if a STOPF is detected */
;;;6333       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
;;;6334       {
;;;6335         /* Check if an RXNE is pending */
;;;6336         /* Store Last receive data if any */
;;;6337         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
;;;6338         {
;;;6339           /* Return HAL_OK */
;;;6340           /* The Reading of data from RXDR will be done in caller function */
;;;6341           return HAL_OK;
;;;6342         }
;;;6343         else
;;;6344         {
;;;6345           /* Clear STOP Flag */
;;;6346           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
00000c  f04f0820          MOV      r8,#0x20
000010  e02c              B        |L77.108|
                  |L77.18|
000012  4632              MOV      r2,r6                 ;6327
000014  4629              MOV      r1,r5                 ;6327
000016  4620              MOV      r0,r4                 ;6327
000018  f7fffffe          BL       I2C_IsAcknowledgeFailed
00001c  b110              CBZ      r0,|L77.36|
00001e  2001              MOVS     r0,#1                 ;6329
                  |L77.32|
;;;6347   
;;;6348           /* Clear Configuration Register 2 */
;;;6349           I2C_RESET_CR2(hi2c);
;;;6350   
;;;6351           hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;6352           hi2c->State = HAL_I2C_STATE_READY;
;;;6353           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;6354   
;;;6355           /* Process Unlocked */
;;;6356           __HAL_UNLOCK(hi2c);
;;;6357   
;;;6358           return HAL_ERROR;
;;;6359         }
;;;6360       }
;;;6361   
;;;6362       /* Check for the Timeout */
;;;6363       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6364       {
;;;6365         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;6366         hi2c->State = HAL_I2C_STATE_READY;
;;;6367   
;;;6368         /* Process Unlocked */
;;;6369         __HAL_UNLOCK(hi2c);
;;;6370   
;;;6371         return HAL_ERROR;
;;;6372       }
;;;6373     }
;;;6374     return HAL_OK;
;;;6375   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L77.36|
000024  6820              LDR      r0,[r4,#0]            ;6333
000026  6980              LDR      r0,[r0,#0x18]         ;6333
000028  43c0              MVNS     r0,r0                 ;6333
00002a  0680              LSLS     r0,r0,#26             ;6333
00002c  d418              BMI      |L77.96|
00002e  6820              LDR      r0,[r4,#0]            ;6337
000030  6981              LDR      r1,[r0,#0x18]         ;6337
000032  43c9              MVNS     r1,r1                 ;6337
000034  0749              LSLS     r1,r1,#29             ;6337
000036  d403              BMI      |L77.64|
000038  8d21              LDRH     r1,[r4,#0x28]         ;6337
00003a  b109              CBZ      r1,|L77.64|
00003c  2000              MOVS     r0,#0                 ;6341
00003e  e7ef              B        |L77.32|
                  |L77.64|
000040  f8c0801c          STR      r8,[r0,#0x1c]         ;6346
000044  6820              LDR      r0,[r4,#0]            ;6349
000046  6841              LDR      r1,[r0,#4]            ;6349
000048  4a11              LDR      r2,|L77.144|
00004a  4011              ANDS     r1,r1,r2              ;6349
00004c  6041              STR      r1,[r0,#4]            ;6349
00004e  6467              STR      r7,[r4,#0x44]         ;6351
000050  f8848041          STRB     r8,[r4,#0x41]         ;6352
000054  f8847042          STRB     r7,[r4,#0x42]         ;6353
000058  f8847040          STRB     r7,[r4,#0x40]         ;6356
00005c  2001              MOVS     r0,#1                 ;6358
00005e  e7df              B        |L77.32|
                  |L77.96|
000060  f7fffffe          BL       HAL_GetTick
000064  1b80              SUBS     r0,r0,r6              ;6363
000066  42a8              CMP      r0,r5                 ;6363
000068  d807              BHI      |L77.122|
00006a  b135              CBZ      r5,|L77.122|
                  |L77.108|
00006c  6820              LDR      r0,[r4,#0]            ;6324
00006e  6980              LDR      r0,[r0,#0x18]         ;6324
000070  43c0              MVNS     r0,r0                 ;6324
000072  0740              LSLS     r0,r0,#29             ;6324
000074  d4cd              BMI      |L77.18|
000076  2000              MOVS     r0,#0                 ;6374
000078  e7d2              B        |L77.32|
                  |L77.122|
00007a  6c60              LDR      r0,[r4,#0x44]         ;6365
00007c  f0400020          ORR      r0,r0,#0x20           ;6365
000080  6460              STR      r0,[r4,#0x44]         ;6365
000082  f8848041          STRB     r8,[r4,#0x41]         ;6366
000086  f8847040          STRB     r7,[r4,#0x40]         ;6369
00008a  2001              MOVS     r0,#1                 ;6371
00008c  e7c8              B        |L77.32|
;;;6376   
                          ENDP

00008e  0000              DCW      0x0000
                  |L77.144|
                          DCD      0xfe00e800

                          AREA ||i.I2C_WaitOnSTOPFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnSTOPFlagUntilTimeout PROC
;;;6287     */
;;;6288   static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;6289   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;6290     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
;;;6291     {
;;;6292       /* Check if a NACK is detected */
;;;6293       if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6294       {
;;;6295         return HAL_ERROR;
;;;6296       }
;;;6297   
;;;6298       /* Check for the Timeout */
;;;6299       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6300       {
;;;6301         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;6302         hi2c->State = HAL_I2C_STATE_READY;
;;;6303         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;6304   
;;;6305         /* Process Unlocked */
;;;6306         __HAL_UNLOCK(hi2c);
;;;6307   
;;;6308         return HAL_ERROR;
000008  e00d              B        |L78.38|
                  |L78.10|
00000a  4632              MOV      r2,r6                 ;6293
00000c  4629              MOV      r1,r5                 ;6293
00000e  4620              MOV      r0,r4                 ;6293
000010  f7fffffe          BL       I2C_IsAcknowledgeFailed
000014  b108              CBZ      r0,|L78.26|
000016  2001              MOVS     r0,#1                 ;6295
;;;6309       }
;;;6310     }
;;;6311     return HAL_OK;
;;;6312   }
000018  bd70              POP      {r4-r6,pc}
                  |L78.26|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6              ;6299
000020  42a8              CMP      r0,r5                 ;6299
000022  d807              BHI      |L78.52|
000024  b135              CBZ      r5,|L78.52|
                  |L78.38|
000026  6820              LDR      r0,[r4,#0]            ;6290
000028  6980              LDR      r0,[r0,#0x18]         ;6290
00002a  43c0              MVNS     r0,r0                 ;6290
00002c  0680              LSLS     r0,r0,#26             ;6290
00002e  d4ec              BMI      |L78.10|
000030  2000              MOVS     r0,#0                 ;6311
000032  bd70              POP      {r4-r6,pc}
                  |L78.52|
000034  3440              ADDS     r4,r4,#0x40           ;6301
000036  6860              LDR      r0,[r4,#4]            ;6301
000038  f0400020          ORR      r0,r0,#0x20           ;6301
00003c  6060              STR      r0,[r4,#4]            ;6301
00003e  2020              MOVS     r0,#0x20              ;6302
000040  7060              STRB     r0,[r4,#1]            ;6302
000042  2000              MOVS     r0,#0                 ;6303
000044  70a0              STRB     r0,[r4,#2]            ;6303
000046  7020              STRB     r0,[r4,#0]            ;6306
000048  2001              MOVS     r0,#1                 ;6308
00004a  bd70              POP      {r4-r6,pc}
;;;6313   
                          ENDP


                          AREA ||i.I2C_WaitOnTXISFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnTXISFlagUntilTimeout PROC
;;;6250     */
;;;6251   static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;6252   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;6253     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
;;;6254     {
;;;6255       /* Check if a NACK is detected */
;;;6256       if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6257       {
;;;6258         return HAL_ERROR;
;;;6259       }
;;;6260   
;;;6261       /* Check for the Timeout */
;;;6262       if (Timeout != HAL_MAX_DELAY)
;;;6263       {
;;;6264         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6265         {
;;;6266           hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;6267           hi2c->State = HAL_I2C_STATE_READY;
;;;6268           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;6269   
;;;6270           /* Process Unlocked */
;;;6271           __HAL_UNLOCK(hi2c);
;;;6272   
;;;6273           return HAL_ERROR;
000008  e00f              B        |L79.42|
                  |L79.10|
00000a  4632              MOV      r2,r6                 ;6256
00000c  4629              MOV      r1,r5                 ;6256
00000e  4620              MOV      r0,r4                 ;6256
000010  f7fffffe          BL       I2C_IsAcknowledgeFailed
000014  b108              CBZ      r0,|L79.26|
000016  2001              MOVS     r0,#1                 ;6258
;;;6274         }
;;;6275       }
;;;6276     }
;;;6277     return HAL_OK;
;;;6278   }
000018  bd70              POP      {r4-r6,pc}
                  |L79.26|
00001a  1c68              ADDS     r0,r5,#1              ;6262
00001c  d005              BEQ      |L79.42|
00001e  f7fffffe          BL       HAL_GetTick
000022  1b80              SUBS     r0,r0,r6              ;6264
000024  42a8              CMP      r0,r5                 ;6264
000026  d807              BHI      |L79.56|
000028  b135              CBZ      r5,|L79.56|
                  |L79.42|
00002a  6820              LDR      r0,[r4,#0]            ;6253
00002c  6980              LDR      r0,[r0,#0x18]         ;6253
00002e  43c0              MVNS     r0,r0                 ;6253
000030  0780              LSLS     r0,r0,#30             ;6253
000032  d4ea              BMI      |L79.10|
000034  2000              MOVS     r0,#0                 ;6277
000036  bd70              POP      {r4-r6,pc}
                  |L79.56|
000038  3440              ADDS     r4,r4,#0x40           ;6266
00003a  6860              LDR      r0,[r4,#4]            ;6266
00003c  f0400020          ORR      r0,r0,#0x20           ;6266
000040  6060              STR      r0,[r4,#4]            ;6266
000042  2020              MOVS     r0,#0x20              ;6267
000044  7060              STRB     r0,[r4,#1]            ;6267
000046  2000              MOVS     r0,#0                 ;6268
000048  70a0              STRB     r0,[r4,#2]            ;6268
00004a  7020              STRB     r0,[r4,#0]            ;6271
00004c  2001              MOVS     r0,#1                 ;6273
00004e  bd70              POP      {r4-r6,pc}
;;;6279   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_i2c_c_0eb271f4____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32l4xx_hal_i2c_c_0eb271f4____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_i2c_c_0eb271f4____REVSH|
#line 507
|__asm___19_stm32l4xx_hal_i2c_c_0eb271f4____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32l4xx_hal_i2c_c_0eb271f4____RRX|
#line 694
|__asm___19_stm32l4xx_hal_i2c_c_0eb271f4____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
