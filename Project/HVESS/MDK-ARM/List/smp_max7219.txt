; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\smp_max7219.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\smp_max7219.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\SMP\smp_max7219.c]
                          THUMB

                          AREA ||i.MAX7219_All_Display||, CODE, READONLY, ALIGN=2

                  MAX7219_All_Display PROC
;;;432    
;;;433    void MAX7219_All_Display(uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;434    {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
;;;435    	uint8_t i,j, *d, bTemp[32];	
;;;436      for (j=0; j< 9; j++){
000006  2400              MOVS     r4,#0
;;;437          d = bTemp;
;;;438          for (i=0; i<iNumControllers; i++)
000008  4e0b              LDR      r6,|L1.56|
                  |L1.10|
00000a  4669              MOV      r1,sp                 ;437
00000c  2200              MOVS     r2,#0
00000e  7973              LDRB     r3,[r6,#5]
000010  e004              B        |L1.28|
                  |L1.18|
;;;439          {
;;;440              *d++ = j;          // set REG. display
000012  700c              STRB     r4,[r1,#0]
;;;441              *d++ = data;
000014  704d              STRB     r5,[r1,#1]
000016  1c89              ADDS     r1,r1,#2
000018  1c52              ADDS     r2,r2,#1              ;438
00001a  b2d2              UXTB     r2,r2                 ;438
                  |L1.28|
00001c  429a              CMP      r2,r3                 ;438
00001e  d3f8              BCC      |L1.18|
;;;442          } // for i
;;;443          maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
000020  0658              LSLS     r0,r3,#25
000022  0e01              LSRS     r1,r0,#24
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       maxSendSequence
00002a  1c64              ADDS     r4,r4,#1              ;436
00002c  b2e4              UXTB     r4,r4                 ;436
00002e  2c09              CMP      r4,#9                 ;436
000030  d3eb              BCC      |L1.10|
;;;444    	}
;;;445    }
000032  b008              ADD      sp,sp,#0x20
000034  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      ||.data||

                          AREA ||i.MAX7219_Display_1||, CODE, READONLY, ALIGN=2

                  MAX7219_Display_1 PROC
;;;446    
;;;447    void MAX7219_Display_1(void)
000000  b570              PUSH     {r4-r6,lr}
;;;448    {
000002  b088              SUB      sp,sp,#0x20
;;;449    	uint8_t i,j, *d, bTemp[32];	
;;;450      for (j=1; j< 9; j++){
000004  2401              MOVS     r4,#1
;;;451          d = bTemp;
;;;452          for (i=0; i<iNumControllers; i++)
000006  4d0e              LDR      r5,|L2.64|
                  |L2.8|
000008  4669              MOV      r1,sp                 ;451
00000a  2000              MOVS     r0,#0
;;;453          {
;;;454              *d++ = j;          // set REG. display
;;;455              *d++ = ucFont[255+j+i*8];
00000c  4b0d              LDR      r3,|L2.68|
00000e  796a              LDRB     r2,[r5,#5]            ;452
000010  e009              B        |L2.38|
                  |L2.18|
000012  700c              STRB     r4,[r1,#0]            ;454
000014  eb0406c0          ADD      r6,r4,r0,LSL #3
000018  441e              ADD      r6,r6,r3
00001a  f89660ff          LDRB     r6,[r6,#0xff]
00001e  704e              STRB     r6,[r1,#1]
000020  1c89              ADDS     r1,r1,#2
000022  1c40              ADDS     r0,r0,#1              ;452
000024  b2c0              UXTB     r0,r0                 ;452
                  |L2.38|
000026  4290              CMP      r0,r2                 ;452
000028  d3f3              BCC      |L2.18|
;;;456          } // for i
;;;457          maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
00002a  0650              LSLS     r0,r2,#25
00002c  0e01              LSRS     r1,r0,#24
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       maxSendSequence
000034  1c64              ADDS     r4,r4,#1              ;450
000036  b2e4              UXTB     r4,r4                 ;450
000038  2c09              CMP      r4,#9                 ;450
00003a  d3e5              BCC      |L2.8|
;;;458    	}
;;;459    }
00003c  b008              ADD      sp,sp,#0x20
00003e  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L2.64|
                          DCD      ||.data||
                  |L2.68|
                          DCD      ||.constdata||

                          AREA ||i.max7219_SendByte||, CODE, READONLY, ALIGN=2

                  max7219_SendByte PROC
;;;133    
;;;134    void max7219_SendByte(uint8_t *dataout, uint8_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;135    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;136      char i,j;
;;;137      for(j=0; j<len ; j++){
000008  2300              MOVS     r3,#0
;;;138          for (i=8; i>0; i--) {
;;;139            unsigned char mask = 1 << (i - 1);                    // calculate bitmask
;;;140            MAX7219_CLK_0();                                      // bring CLK low
00000a  4c15              LDR      r4,|L3.96|
00000c  e024              B        |L3.88|
                  |L3.14|
00000e  2208              MOVS     r2,#8                 ;138
000010  2601              MOVS     r6,#1                 ;139
                  |L3.18|
000012  1e52              SUBS     r2,r2,#1              ;139
000014  fa06f002          LSL      r0,r6,r2              ;139
000018  b2c5              UXTB     r5,r0                 ;139
00001a  6960              LDR      r0,[r4,#0x14]
00001c  f4206000          BIC      r0,r0,#0x800
000020  6160              STR      r0,[r4,#0x14]
;;;141    				max7219_small_delay(1);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       max7219_small_delay
;;;142            if (dataout[j] & mask)                              // output one data bit
000028  5cf8              LDRB     r0,[r7,r3]
00002a  4228              TST      r0,r5
00002c  d004              BEQ      |L3.56|
;;;143              MAX7219_DATA_1();                                   //  "1"
00002e  6960              LDR      r0,[r4,#0x14]
000030  f4405000          ORR      r0,r0,#0x2000
000034  6160              STR      r0,[r4,#0x14]
000036  e003              B        |L3.64|
                  |L3.56|
;;;144            else                                                  //  or
;;;145              MAX7219_DATA_0();                                   //  "0"
000038  6960              LDR      r0,[r4,#0x14]
00003a  f4205000          BIC      r0,r0,#0x2000
00003e  6160              STR      r0,[r4,#0x14]
                  |L3.64|
;;;146            MAX7219_CLK_1();                                      // bring CLK high
000040  6960              LDR      r0,[r4,#0x14]
000042  f4406000          ORR      r0,r0,#0x800
000046  6160              STR      r0,[r4,#0x14]
;;;147    				max7219_small_delay(1);
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       max7219_small_delay
00004e  b2d2              UXTB     r2,r2                 ;138
000050  2a00              CMP      r2,#0                 ;138
000052  d1de              BNE      |L3.18|
000054  1c5b              ADDS     r3,r3,#1              ;137
000056  b2db              UXTB     r3,r3                 ;137
                  |L3.88|
000058  4543              CMP      r3,r8                 ;137
00005a  d3d8              BCC      |L3.14|
;;;148    	   }
;;;149      }
;;;150    }	
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;151    	
                          ENDP

                  |L3.96|
                          DCD      0x48001000

                          AREA ||i.max7219_small_delay||, CODE, READONLY, ALIGN=1

                  max7219_small_delay PROC
;;;127    
;;;128    void max7219_small_delay(uint8_t nop_num){
000000  2100              MOVS     r1,#0
000002  e001              B        |L4.8|
                  |L4.4|
;;;129        for(int i= 0 ; i< nop_num ;i++){
;;;130    		    __NOP();
000004  bf00              NOP      
000006  1c49              ADDS     r1,r1,#1              ;129
                  |L4.8|
000008  4281              CMP      r1,r0                 ;129
00000a  dbfb              BLT      |L4.4|
;;;131    		}
;;;132    }
00000c  4770              BX       lr
;;;133    
                          ENDP


                          AREA ||i.maxDrawString||, CODE, READONLY, ALIGN=2

                  maxDrawString PROC
;;;321    //
;;;322    void maxDrawString(char *pString, uint8_t *pImage, uint8_t iPitch, uint8_t bSmall)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;323    {
;;;324    static uint8_t b, bMask, i, j, *d, bCol;
;;;325    const uint8_t *pFont;
;;;326    const uint8_t *s;
;;;327    static int iWidth;
;;;328    
;;;329       d = pImage;
;;;330       bCol = 0;
000004  4e2b              LDR      r6,|L5.180|
000006  f04f0900          MOV      r9,#0
00000a  f8869004          STRB     r9,[r6,#4]
;;;331       if (bSmall)
00000e  2b00              CMP      r3,#0
000010  d004              BEQ      |L5.28|
;;;332       {
;;;333          pFont = ucFont;
000012  f8dfe0a4          LDR      lr,|L5.184|
;;;334          iWidth = 6;
000016  2306              MOVS     r3,#6
000018  60f3              STR      r3,[r6,#0xc]  ; iWidth
00001a  e045              B        |L5.168|
                  |L5.28|
;;;335       }
;;;336       else
;;;337       {
;;;338          pFont = ucFont;
00001c  f8dfe098          LDR      lr,|L5.184|
;;;339          iWidth = 8;
000020  2308              MOVS     r3,#8
000022  60f3              STR      r3,[r6,#0xc]  ; iWidth
000024  e040              B        |L5.168|
                  |L5.38|
;;;340       }
;;;341       while (*pString)
;;;342       {
;;;343          b = *pString++;
000026  7033              STRB     r3,[r6,#0]
000028  1c40              ADDS     r0,r0,#1
;;;344          s = &pFont[(int)b * iWidth]; // 6 or 8 uint8_ts per character in ASCII order
00002a  f8d6a00c          LDR      r10,[r6,#0xc]  ; iWidth
00002e  fb03e40a          MLA      r4,r3,r10,lr
;;;345          for (i=0; i<iWidth; i++) // column
000032  f8869002          STRB     r9,[r6,#2]
000036  e033              B        |L5.160|
                  |L5.56|
;;;346          {
;;;347             bMask = (0x80 >> (bCol & 7));
000038  f896c004          LDRB     r12,[r6,#4]  ; bCol
00003c  2580              MOVS     r5,#0x80
00003e  f00c0307          AND      r3,r12,#7
000042  40dd              LSRS     r5,r5,r3
000044  7075              STRB     r5,[r6,#1]
;;;348             b = *s++; // current font uint8_t
000046  f8143b01          LDRB     r3,[r4],#1
00004a  7033              STRB     r3,[r6,#0]
;;;349             for (j=0; j<8; j++) // bit number of source becomes destination row
00004c  f8869003          STRB     r9,[r6,#3]
                  |L5.80|
;;;350             {
;;;351                if (b & 1) // start from LSB
000050  7837              LDRB     r7,[r6,#0]  ; b
000052  07fb              LSLS     r3,r7,#31
000054  d008              BEQ      |L5.104|
;;;352                   d[j*iPitch] |= bMask;
000056  78f3              LDRB     r3,[r6,#3]  ; j
000058  4353              MULS     r3,r2,r3
00005a  f811b003          LDRB     r11,[r1,r3]
00005e  ea4b0b05          ORR      r11,r11,r5
000062  f801b003          STRB     r11,[r1,r3]
000066  e007              B        |L5.120|
                  |L5.104|
;;;353                else
;;;354                   d[j*iPitch] &= ~bMask;
000068  78f3              LDRB     r3,[r6,#3]  ; j
00006a  4353              MULS     r3,r2,r3
00006c  f811b003          LDRB     r11,[r1,r3]
000070  ea2b0b05          BIC      r11,r11,r5
000074  f801b003          STRB     r11,[r1,r3]
                  |L5.120|
;;;355                b >>= 1; // shift down font uint8_t
000078  087b              LSRS     r3,r7,#1
00007a  7033              STRB     r3,[r6,#0]
00007c  78f3              LDRB     r3,[r6,#3]            ;349  ; j
00007e  1c5b              ADDS     r3,r3,#1              ;349
000080  b2db              UXTB     r3,r3                 ;349
000082  70f3              STRB     r3,[r6,#3]            ;349
000084  2b08              CMP      r3,#8                 ;349
000086  d3e3              BCC      |L5.80|
;;;356             } // for j
;;;357             bCol++;
000088  f10c0c01          ADD      r12,r12,#1
00008c  f886c004          STRB     r12,[r6,#4]
;;;358             if ((bCol & 7) == 0) // next uint8_t
000090  ea5f734c          LSLS     r3,r12,#29
000094  d100              BNE      |L5.152|
;;;359                d++;
000096  1c49              ADDS     r1,r1,#1
                  |L5.152|
000098  f1080801          ADD      r8,r8,#1              ;345
00009c  f8868002          STRB     r8,[r6,#2]            ;345
                  |L5.160|
0000a0  f8968002          LDRB     r8,[r6,#2]            ;345  ; i
0000a4  45d0              CMP      r8,r10                ;345
0000a6  dbc7              BLT      |L5.56|
                  |L5.168|
0000a8  7803              LDRB     r3,[r0,#0]            ;341
0000aa  2b00              CMP      r3,#0                 ;341
0000ac  d1bb              BNE      |L5.38|
;;;360          } // for i
;;;361       } // while string
;;;362    } /* maxDrawString() */
0000ae  e8bd8ff0          POP      {r4-r11,pc}
;;;363    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L5.180|
                          DCD      ||.data||
                  |L5.184|
                          DCD      ||.constdata||

                          AREA ||i.maxInit||, CODE, READONLY, ALIGN=2

                  maxInit PROC
;;;407    //
;;;408    int maxInit(uint8_t iNum, uint8_t bDecodeMode)
000000  b510              PUSH     {r4,lr}
;;;409    {
000002  460c              MOV      r4,r1
;;;410      iNumControllers = iNum;
000004  4a0b              LDR      r2,|L6.52|
000006  7150              STRB     r0,[r2,#5]
;;;411    	
;;;412    	MAX7219_CS_1();  
000008  480b              LDR      r0,|L6.56|
00000a  6942              LDR      r2,[r0,#0x14]
00000c  f4425280          ORR      r2,r2,#0x1000
000010  6142              STR      r2,[r0,#0x14]
;;;413    	
;;;414      maxPowerUp(1); // turn on the LED controllers
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       maxPowerUp
;;;415      maxSetLimit(8); // tell it to display 8 rows of 8 pixels
000018  2008              MOVS     r0,#8
00001a  f7fffffe          BL       maxSetLimit
;;;416      maxSetIntensity(5); // set the minimum intensity to start (1/32 duty cycle)
00001e  2005              MOVS     r0,#5
000020  f7fffffe          BL       maxSetIntensity
;;;417      maxSetSegmentMode(bDecodeMode); // sets BCD (7-segment), or none (pixels
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       maxSetSegmentMode
;;;418      maxSetTestMode(0); // disable test mode (it can accidentally get set at power up) 
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       maxSetTestMode
;;;419      return 0;
000030  2000              MOVS     r0,#0
;;;420    } /* maxInit() */
000032  bd10              POP      {r4,pc}
;;;421    
                          ENDP

                  |L6.52|
                          DCD      ||.data||
                  |L6.56|
                          DCD      0x48001000

                          AREA ||i.maxPowerUp||, CODE, READONLY, ALIGN=2

                  maxPowerUp PROC
;;;175    //
;;;176    void maxPowerUp(uint8_t bPowerUp)
000000  b510              PUSH     {r4,lr}
;;;177    {
000002  b088              SUB      sp,sp,#0x20
;;;178    uint8_t i;
;;;179    uint8_t *d, bTemp[32]; // up to 16 controllers
;;;180      d = bTemp;
000004  4669              MOV      r1,sp
;;;181      for (i=0; i<iNumControllers; i++)
000006  2200              MOVS     r2,#0
000008  4b08              LDR      r3,|L7.44|
;;;182      {
;;;183         *d++ = 0x0C; // power up/down
00000a  240c              MOVS     r4,#0xc
00000c  795b              LDRB     r3,[r3,#5]            ;181
00000e  e004              B        |L7.26|
                  |L7.16|
000010  700c              STRB     r4,[r1,#0]
;;;184         *d++ = bPowerUp;
000012  7048              STRB     r0,[r1,#1]
000014  1c89              ADDS     r1,r1,#2
000016  1c52              ADDS     r2,r2,#1              ;181
000018  b2d2              UXTB     r2,r2                 ;181
                  |L7.26|
00001a  429a              CMP      r2,r3                 ;181
00001c  d3f8              BCC      |L7.16|
;;;185      }
;;;186      maxSendSequence(bTemp, iNumControllers * 2); // send the power up/down instruction
00001e  0658              LSLS     r0,r3,#25
000020  0e01              LSRS     r1,r0,#24
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       maxSendSequence
;;;187    } /* maxPowerUp() */
000028  b008              ADD      sp,sp,#0x20
00002a  bd10              POP      {r4,pc}
;;;188    //
                          ENDP

                  |L7.44|
                          DCD      ||.data||

                          AREA ||i.maxScrollBitmap||, CODE, READONLY, ALIGN=1

                  maxScrollBitmap PROC
;;;369    //
;;;370    void maxScrollBitmap(uint8_t *pBitmap, int iPitch, int iScroll)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;371    {
;;;372    uint8_t b, bEdge, *s;
;;;373    int col, row;
;;;374    
;;;375      if (iScroll > 0) // scroll left
000004  2a00              CMP      r2,#0
000006  dd22              BLE      |L8.78|
;;;376      {
;;;377         for (row=0; row<8; row++)
000008  2500              MOVS     r5,#0
;;;378         {
;;;379            s = &pBitmap[row * iPitch];
;;;380            bEdge = s[0] >> (8-iScroll);
00000a  f1c20708          RSB      r7,r2,#8
                  |L8.14|
00000e  fb050301          MLA      r3,r5,r1,r0           ;379
000012  f8939000          LDRB     r9,[r3,#0]
000016  fa29f907          LSR      r9,r9,r7
;;;381            for (col=0; col<iPitch; col++)
00001a  2400              MOVS     r4,#0
;;;382            {
;;;383               b = s[col] << iScroll;
;;;384               b |= (col == iPitch-1) ? bEdge : (s[col+1] >> (8-iScroll));
00001c  f1a10801          SUB      r8,r1,#1
000020  e00e              B        |L8.64|
                  |L8.34|
000022  5d1e              LDRB     r6,[r3,r4]            ;383
000024  4096              LSLS     r6,r6,r2              ;383
000026  f0060cff          AND      r12,r6,#0xff          ;383
00002a  4544              CMP      r4,r8
00002c  d101              BNE      |L8.50|
00002e  464e              MOV      r6,r9
000030  e002              B        |L8.56|
                  |L8.50|
000032  191e              ADDS     r6,r3,r4
000034  7876              LDRB     r6,[r6,#1]
000036  40fe              LSRS     r6,r6,r7
                  |L8.56|
000038  ea46060c          ORR      r6,r6,r12
;;;385               s[col] = b;
00003c  551e              STRB     r6,[r3,r4]
00003e  1c64              ADDS     r4,r4,#1              ;381
                  |L8.64|
000040  428c              CMP      r4,r1                 ;381
000042  dbee              BLT      |L8.34|
000044  1c6d              ADDS     r5,r5,#1              ;377
000046  2d08              CMP      r5,#8                 ;377
000048  dbe1              BLT      |L8.14|
                  |L8.74|
;;;386            } // for col
;;;387         } // for row
;;;388      }
;;;389      else // scroll right
;;;390      {
;;;391         iScroll = 0 - iScroll; // make it a positive number
;;;392         for (row=0; row<8; row++)
;;;393         {
;;;394            s = &pBitmap[row * iPitch];
;;;395            bEdge = s[iPitch-1] << (8-iScroll);
;;;396            for (col=iPitch-1; col>=0; col--)
;;;397            {
;;;398               b = s[col] >> iScroll;
;;;399               b |= (col == 0) ? bEdge : (s[col-1] << (8-iScroll));
;;;400               s[col] = b;
;;;401            } // for col
;;;402         } // for row    
;;;403      }
;;;404    } /* maxScrollBitmap() */
00004a  e8bd83f0          POP      {r4-r9,pc}
                  |L8.78|
00004e  f1c20c00          RSB      r12,r2,#0             ;391
000052  2400              MOVS     r4,#0                 ;392
000054  f1cc0608          RSB      r6,r12,#8             ;380
                  |L8.88|
000058  fb040201          MLA      r2,r4,r1,r0           ;394
00005c  1853              ADDS     r3,r2,r1              ;395
00005e  f8133c01          LDRB     r3,[r3,#-1]           ;395
000062  40b3              LSLS     r3,r3,r6              ;395
000064  f00308ff          AND      r8,r3,#0xff           ;395
000068  1e4b              SUBS     r3,r1,#1              ;396
00006a  2b00              CMP      r3,#0                 ;396
00006c  db0c              BLT      |L8.136|
                  |L8.110|
00006e  5cd7              LDRB     r7,[r2,r3]            ;398
000070  fa27f70c          LSR      r7,r7,r12             ;398
000074  b163              CBZ      r3,|L8.144|
000076  18d5              ADDS     r5,r2,r3              ;399
000078  f8155c01          LDRB     r5,[r5,#-1]           ;399
00007c  40b5              LSLS     r5,r5,r6              ;399
                  |L8.126|
00007e  433d              ORRS     r5,r5,r7              ;399
000080  54d5              STRB     r5,[r2,r3]            ;400
000082  1e5b              SUBS     r3,r3,#1              ;396
000084  2b00              CMP      r3,#0                 ;396
000086  daf2              BGE      |L8.110|
                  |L8.136|
000088  1c64              ADDS     r4,r4,#1              ;392
00008a  2c08              CMP      r4,#8                 ;392
00008c  dbe4              BLT      |L8.88|
00008e  e7dc              B        |L8.74|
                  |L8.144|
000090  4645              MOV      r5,r8                 ;399
000092  e7f4              B        |L8.126|
;;;405    //
                          ENDP


                          AREA ||i.maxSegmentString||, CODE, READONLY, ALIGN=1

                  maxSegmentString PROC
;;;281    //
;;;282    void maxSegmentString(char *pString)
000000  b578              PUSH     {r3-r6,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284    unsigned char ucTemp[4];
;;;285    int iDigit;
;;;286    
;;;287    	memset(ucTemp, 0, sizeof(ucTemp));
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;288    	iDigit = 0;
000008  2500              MOVS     r5,#0
;;;289    	while (*pString && iDigit < 8)
;;;290    	{
;;;291    		ucTemp[0] = 8 - (iDigit & 7); // cmd byte to write
;;;292    		if (pString[0] >= '0' && pString[0] <= '9')
;;;293    		{
;;;294    			ucTemp[1] = *pString++; // store digit
;;;295    			if (pString[0] == '.')
;;;296    			{
;;;297    				ucTemp[1] |= 0x80; // turn on decimal point
;;;298    				pString++;
;;;299    			}
;;;300    		}
;;;301    		else
;;;302    		{
;;;303    			ucTemp[1] = 0xf; // space = all segments off
00000a  260f              MOVS     r6,#0xf
00000c  e01e              B        |L9.76|
                  |L9.14|
00000e  f0050007          AND      r0,r5,#7              ;291
000012  f1c00008          RSB      r0,r0,#8              ;291
000016  f88d0000          STRB     r0,[sp,#0]            ;291
00001a  7820              LDRB     r0,[r4,#0]            ;292
00001c  f1a00130          SUB      r1,r0,#0x30           ;292
000020  2909              CMP      r1,#9                 ;292
000022  d80b              BHI      |L9.60|
000024  f88d0001          STRB     r0,[sp,#1]            ;294
000028  1c64              ADDS     r4,r4,#1              ;294
00002a  7821              LDRB     r1,[r4,#0]            ;295
00002c  292e              CMP      r1,#0x2e              ;295
00002e  d108              BNE      |L9.66|
000030  f0400080          ORR      r0,r0,#0x80           ;297
000034  f88d0001          STRB     r0,[sp,#1]            ;297
000038  1c64              ADDS     r4,r4,#1              ;298
00003a  e002              B        |L9.66|
                  |L9.60|
00003c  f88d6001          STRB     r6,[sp,#1]
;;;304    			pString++;
000040  1c64              ADDS     r4,r4,#1
                  |L9.66|
;;;305    		}
;;;306    		iDigit++;
000042  1c6d              ADDS     r5,r5,#1
;;;307    		maxSendSequence(ucTemp, 2); // need to latch each byte pair
000044  2102              MOVS     r1,#2
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       maxSendSequence
                  |L9.76|
00004c  7820              LDRB     r0,[r4,#0]            ;289
00004e  b178              CBZ      r0,|L9.112|
000050  2d08              CMP      r5,#8                 ;289
000052  dbdc              BLT      |L9.14|
000054  e00c              B        |L9.112|
                  |L9.86|
;;;308    	}
;;;309    	while (iDigit < 8) // blank out remaining digits
;;;310    	{
;;;311    		ucTemp[0] = 8 - (iDigit & 7);
000056  f0050007          AND      r0,r5,#7
00005a  f1c00008          RSB      r0,r0,#8
00005e  f88d0000          STRB     r0,[sp,#0]
;;;312    		ucTemp[1] = 0xf; // all segments off
000062  f88d6001          STRB     r6,[sp,#1]
;;;313    		iDigit++;
000066  1c6d              ADDS     r5,r5,#1
;;;314    		maxSendSequence(ucTemp, 2);
000068  2102              MOVS     r1,#2
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       maxSendSequence
                  |L9.112|
000070  2d08              CMP      r5,#8                 ;309
000072  dbf0              BLT      |L9.86|
;;;315    	}
;;;316    } /* maxSegmentString() */
000074  bd78              POP      {r3-r6,pc}
;;;317    //
                          ENDP


                          AREA ||i.maxSendImage||, CODE, READONLY, ALIGN=2

                  maxSendImage PROC
;;;225    //
;;;226    void maxSendImage(uint8_t *pImage, int iPitch)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;227    {
000004  b088              SUB      sp,sp,#0x20
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;228    uint8_t i, j;
;;;229    uint8_t *s, *d, bTemp[32];
;;;230    
;;;231       for (j=0; j<8; j++) // 8 rows to transmit
00000a  2500              MOVS     r5,#0
;;;232       {
;;;233          s = &pImage[iPitch * j];
;;;234          d = bTemp;
;;;235          for (i=0; i<iNumControllers; i++)
00000c  f8df803c          LDR      r8,|L10.76|
                  |L10.16|
000010  fb076405          MLA      r4,r7,r5,r6           ;233
000014  466a              MOV      r2,sp                 ;234
000016  2300              MOVS     r3,#0
;;;236          {
;;;237             *d++ = (j+1); // row number is the "instruction"
000018  1c6d              ADDS     r5,r5,#1
00001a  b2e9              UXTB     r1,r5
00001c  f8980005          LDRB     r0,[r8,#5]            ;235
000020  e007              B        |L10.50|
                  |L10.34|
000022  f8021b01          STRB     r1,[r2],#1
;;;238             *d++ = *s++; // image data
000026  f814cb01          LDRB     r12,[r4],#1
00002a  f802cb01          STRB     r12,[r2],#1
00002e  1c5b              ADDS     r3,r3,#1              ;235
000030  b2db              UXTB     r3,r3                 ;235
                  |L10.50|
000032  4283              CMP      r3,r0                 ;235
000034  d3f5              BCC      |L10.34|
;;;239          } // for each controller
;;;240          maxSendSequence(bTemp, iNumControllers * 2);
000036  0640              LSLS     r0,r0,#25
000038  0e01              LSRS     r1,r0,#24
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       maxSendSequence
000040  b2ed              UXTB     r5,r5                 ;231
000042  2d08              CMP      r5,#8                 ;231
000044  d3e4              BCC      |L10.16|
;;;241       } // for each row of image
;;;242    } /* maxSendImage() */
000046  b008              ADD      sp,sp,#0x20
000048  e8bd81f0          POP      {r4-r8,pc}
;;;243    
                          ENDP

                  |L10.76|
                          DCD      ||.data||

                          AREA ||i.maxSendSequence||, CODE, READONLY, ALIGN=2

                  maxSendSequence PROC
;;;161    //
;;;162    void maxSendSequence(uint8_t *pSequence, uint8_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;163    {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
;;;164      // The CS line stays low throughout a "transaction". Send all of the control uint8_ts for all of the chained
;;;165      // controllers in a single transaction. When the CS line rises, the data will be latched
;;;166       MAX7219_CS_0();
000006  4c0a              LDR      r4,|L11.48|
000008  6962              LDR      r2,[r4,#0x14]
00000a  f4225280          BIC      r2,r2,#0x1000
00000e  6162              STR      r2,[r4,#0x14]
;;;167    	 max7219_small_delay(1);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       max7219_small_delay
;;;168       max7219_SendByte(pSequence, len);
000016  4629              MOV      r1,r5
000018  4618              MOV      r0,r3
00001a  f7fffffe          BL       max7219_SendByte
;;;169    	 MAX7219_CS_1();   
00001e  6960              LDR      r0,[r4,#0x14]
000020  f4405080          ORR      r0,r0,#0x1000
000024  6160              STR      r0,[r4,#0x14]
;;;170    	 max7219_small_delay(1);
000026  e8bd4030          POP      {r4,r5,lr}
00002a  2001              MOVS     r0,#1
00002c  f7ffbffe          B.W      max7219_small_delay
;;;171    } /* maxSendSequence() */
;;;172    
                          ENDP

                  |L11.48|
                          DCD      0x48001000

                          AREA ||i.maxSetIntensity||, CODE, READONLY, ALIGN=2

                  maxSetIntensity PROC
;;;191    //
;;;192    void maxSetIntensity(uint8_t bIntensity)
000000  b510              PUSH     {r4,lr}
;;;193    {
000002  b088              SUB      sp,sp,#0x20
;;;194    uint8_t *d, bTemp[32];
;;;195    uint8_t i;
;;;196    
;;;197      d = bTemp;
000004  4669              MOV      r1,sp
;;;198      for (i=0; i<iNumControllers; i++)
000006  2200              MOVS     r2,#0
000008  4b08              LDR      r3,|L12.44|
;;;199      {
;;;200          *d++ = 0x0A; // set intensity
00000a  240a              MOVS     r4,#0xa
00000c  795b              LDRB     r3,[r3,#5]            ;198
00000e  e004              B        |L12.26|
                  |L12.16|
000010  700c              STRB     r4,[r1,#0]
;;;201          *d++ = bIntensity;
000012  7048              STRB     r0,[r1,#1]
000014  1c89              ADDS     r1,r1,#2
000016  1c52              ADDS     r2,r2,#1              ;198
000018  b2d2              UXTB     r2,r2                 ;198
                  |L12.26|
00001a  429a              CMP      r2,r3                 ;198
00001c  d3f8              BCC      |L12.16|
;;;202      } // for i
;;;203      maxSendSequence(bTemp, iNumControllers * 2);
00001e  0658              LSLS     r0,r3,#25
000020  0e01              LSRS     r1,r0,#24
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       maxSendSequence
;;;204    } /* maxSetIntensity() */
000028  b008              ADD      sp,sp,#0x20
00002a  bd10              POP      {r4,pc}
;;;205    //
                          ENDP

                  |L12.44|
                          DCD      ||.data||

                          AREA ||i.maxSetLimit||, CODE, READONLY, ALIGN=2

                  maxSetLimit PROC
;;;264    //
;;;265    void maxSetLimit(uint8_t bLimit)
000000  b510              PUSH     {r4,lr}
;;;266    {
000002  b088              SUB      sp,sp,#0x20
;;;267    uint8_t i, *d, bTemp[32];
;;;268    
;;;269      d = bTemp;
000004  4669              MOV      r1,sp
;;;270      for (i=0; i<iNumControllers; i++)
000006  2200              MOVS     r2,#0
000008  4b09              LDR      r3,|L13.48|
;;;271      {
;;;272          *d++ = 0x0B; // set scan limit
00000a  240b              MOVS     r4,#0xb
;;;273          *d++ = (bLimit - 1);
00000c  1e40              SUBS     r0,r0,#1
00000e  795b              LDRB     r3,[r3,#5]            ;270
000010  b2c0              UXTB     r0,r0
000012  e004              B        |L13.30|
                  |L13.20|
000014  700c              STRB     r4,[r1,#0]            ;272
000016  7048              STRB     r0,[r1,#1]
000018  1c89              ADDS     r1,r1,#2
00001a  1c52              ADDS     r2,r2,#1              ;270
00001c  b2d2              UXTB     r2,r2                 ;270
                  |L13.30|
00001e  429a              CMP      r2,r3                 ;270
000020  d3f8              BCC      |L13.20|
;;;274      } // for i
;;;275      maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
000022  0658              LSLS     r0,r3,#25
000024  0e01              LSRS     r1,r0,#24
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       maxSendSequence
;;;276    } /* maxSetLimit() */
00002c  b008              ADD      sp,sp,#0x20
00002e  bd10              POP      {r4,pc}
;;;277    
                          ENDP

                  |L13.48|
                          DCD      ||.data||

                          AREA ||i.maxSetSegmentMode||, CODE, READONLY, ALIGN=2

                  maxSetSegmentMode PROC
;;;207    //
;;;208    void maxSetSegmentMode(uint8_t bMode)
000000  b530              PUSH     {r4,r5,lr}
;;;209    {
000002  b088              SUB      sp,sp,#0x20
;;;210    uint8_t i, *d, bTemp[32];
;;;211    
;;;212      d = bTemp;
000004  4669              MOV      r1,sp
;;;213      for (i=0; i<iNumControllers; i++)
000006  2200              MOVS     r2,#0
000008  4b0b              LDR      r3,|L14.56|
;;;214      {
;;;215          *d++ = 0x09; // decode mode
00000a  2509              MOVS     r5,#9
00000c  795c              LDRB     r4,[r3,#5]            ;213
00000e  e009              B        |L14.36|
                  |L14.16|
000010  f8015b01          STRB     r5,[r1],#1
;;;216          *d++ = (bMode) ? 0xff : 0x00;
000014  b108              CBZ      r0,|L14.26|
000016  23ff              MOVS     r3,#0xff
000018  e000              B        |L14.28|
                  |L14.26|
00001a  2300              MOVS     r3,#0
                  |L14.28|
00001c  f8013b01          STRB     r3,[r1],#1
000020  1c52              ADDS     r2,r2,#1              ;213
000022  b2d2              UXTB     r2,r2                 ;213
                  |L14.36|
000024  42a2              CMP      r2,r4                 ;213
000026  d3f3              BCC      |L14.16|
;;;217      } // for i
;;;218      maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
000028  0660              LSLS     r0,r4,#25
00002a  0e01              LSRS     r1,r0,#24
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       maxSendSequence
;;;219    } /* maxSetSegmentMode() */
000032  b008              ADD      sp,sp,#0x20
000034  bd30              POP      {r4,r5,pc}
;;;220    
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      ||.data||

                          AREA ||i.maxSetTestMode||, CODE, READONLY, ALIGN=2

                  maxSetTestMode PROC
;;;248    //
;;;249    void maxSetTestMode(uint8_t bOn)
000000  b510              PUSH     {r4,lr}
;;;250    {
000002  b088              SUB      sp,sp,#0x20
;;;251    uint8_t i, *d, bTemp[32];
;;;252    
;;;253      d = bTemp;
000004  4669              MOV      r1,sp
;;;254      for (i=0; i<iNumControllers; i++)
000006  2200              MOVS     r2,#0
000008  4b08              LDR      r3,|L15.44|
;;;255      {
;;;256          *d++ = 0x0F; // test mode
00000a  240f              MOVS     r4,#0xf
00000c  795b              LDRB     r3,[r3,#5]            ;254
00000e  e004              B        |L15.26|
                  |L15.16|
000010  700c              STRB     r4,[r1,#0]
;;;257          *d++ = bOn;
000012  7048              STRB     r0,[r1,#1]
000014  1c89              ADDS     r1,r1,#2
000016  1c52              ADDS     r2,r2,#1              ;254
000018  b2d2              UXTB     r2,r2                 ;254
                  |L15.26|
00001a  429a              CMP      r2,r3                 ;254
00001c  d3f8              BCC      |L15.16|
;;;258      } // for i
;;;259      maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
00001e  0658              LSLS     r0,r3,#25
000020  0e01              LSRS     r1,r0,#24
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       maxSendSequence
;;;260    } /* maxSetTestMode() */
000028  b008              ADD      sp,sp,#0x20
00002a  bd10              POP      {r4,pc}
;;;261    //
                          ENDP

                  |L15.44|
                          DCD      ||.data||

                          AREA ||i.maxShutdown||, CODE, READONLY, ALIGN=1

                  maxShutdown PROC
;;;421    
;;;422    void maxShutdown(void)
000000  2000              MOVS     r0,#0
;;;423    {
;;;424    	
;;;425       maxPowerUp(0); // turn off the LED controllers
000002  f7ffbffe          B.W      maxPowerUp
;;;426       //AIOCloseSPI(file_spi);
;;;427       //file_spi = -1;
;;;428       //AIOShutdown();
;;;429    	
;;;430    } /* maxShutdown() */
;;;431    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ucFont
000000  20202020          DCB      0x20,0x20,0x20,0x20
000004  00002000          DCB      0x00,0x00,0x20,0x00
000008  50505000          DCB      0x50,0x50,0x50,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  28287c28          DCB      0x28,0x28,0x7c,0x28
000014  7c282800          DCB      0x7c,0x28,0x28,0x00
000018  103c5038          DCB      0x10,0x3c,0x50,0x38
00001c  14781000          DCB      0x14,0x78,0x10,0x00
000020  60640810          DCB      0x60,0x64,0x08,0x10
000024  204c0c00          DCB      0x20,0x4c,0x0c,0x00
000028  30485020          DCB      0x30,0x48,0x50,0x20
00002c  50483400          DCB      0x50,0x48,0x34,0x00
000030  30102000          DCB      0x30,0x10,0x20,0x00
000034  00000000          DCB      0x00,0x00,0x00,0x00
000038  10204040          DCB      0x10,0x20,0x40,0x40
00003c  40201000          DCB      0x40,0x20,0x10,0x00
000040  40201010          DCB      0x40,0x20,0x10,0x10
000044  10204000          DCB      0x10,0x20,0x40,0x00
000048  00105438          DCB      0x00,0x10,0x54,0x38
00004c  54100000          DCB      0x54,0x10,0x00,0x00
000050  0010107c          DCB      0x00,0x10,0x10,0x7c
000054  10100000          DCB      0x10,0x10,0x00,0x00
000058  00000030          DCB      0x00,0x00,0x00,0x30
00005c  10200000          DCB      0x10,0x20,0x00,0x00
000060  0000007e          DCB      0x00,0x00,0x00,0x7e
000064  00000000          DCB      0x00,0x00,0x00,0x00
000068  00000000          DCB      0x00,0x00,0x00,0x00
00006c  60600000          DCB      0x60,0x60,0x00,0x00
000070  00040810          DCB      0x00,0x04,0x08,0x10
000074  20400000          DCB      0x20,0x40,0x00,0x00
000078  38444c54          DCB      0x38,0x44,0x4c,0x54
00007c  64443800          DCB      0x64,0x44,0x38,0x00
000080  10301010          DCB      0x10,0x30,0x10,0x10
000084  10103800          DCB      0x10,0x10,0x38,0x00
000088  38440408          DCB      0x38,0x44,0x04,0x08
00008c  10207c00          DCB      0x10,0x20,0x7c,0x00
000090  7c081008          DCB      0x7c,0x08,0x10,0x08
000094  04443800          DCB      0x04,0x44,0x38,0x00
000098  08182848          DCB      0x08,0x18,0x28,0x48
00009c  7c080800          DCB      0x7c,0x08,0x08,0x00
0000a0  3e203c02          DCB      0x3e,0x20,0x3c,0x02
0000a4  02221c00          DCB      0x02,0x22,0x1c,0x00
0000a8  18204078          DCB      0x18,0x20,0x40,0x78
0000ac  44443800          DCB      0x44,0x44,0x38,0x00
0000b0  7c040810          DCB      0x7c,0x04,0x08,0x10
0000b4  20202000          DCB      0x20,0x20,0x20,0x00
0000b8  38444438          DCB      0x38,0x44,0x44,0x38
0000bc  44443800          DCB      0x44,0x44,0x38,0x00
0000c0  3844443c          DCB      0x38,0x44,0x44,0x3c
0000c4  04083000          DCB      0x04,0x08,0x30,0x00
0000c8  00303000          DCB      0x00,0x30,0x30,0x00
0000cc  30300000          DCB      0x30,0x30,0x00,0x00
0000d0  00303000          DCB      0x00,0x30,0x30,0x00
0000d4  30102000          DCB      0x30,0x10,0x20,0x00
0000d8  08102040          DCB      0x08,0x10,0x20,0x40
0000dc  20100800          DCB      0x20,0x10,0x08,0x00
0000e0  00007c00          DCB      0x00,0x00,0x7c,0x00
0000e4  007c0000          DCB      0x00,0x7c,0x00,0x00
0000e8  20100804          DCB      0x20,0x10,0x08,0x04
0000ec  08102000          DCB      0x08,0x10,0x20,0x00
0000f0  38440408          DCB      0x38,0x44,0x04,0x08
0000f4  10001000          DCB      0x10,0x00,0x10,0x00
0000f8  38440434          DCB      0x38,0x44,0x04,0x34
0000fc  54543800          DCB      0x54,0x54,0x38,0x00
000100  38444444          DCB      0x38,0x44,0x44,0x44
000104  7c444400          DCB      0x7c,0x44,0x44,0x00
000108  78444478          DCB      0x78,0x44,0x44,0x78
00010c  44447800          DCB      0x44,0x44,0x78,0x00
000110  38444040          DCB      0x38,0x44,0x40,0x40
000114  40443800          DCB      0x40,0x44,0x38,0x00
000118  70484444          DCB      0x70,0x48,0x44,0x44
00011c  44487000          DCB      0x44,0x48,0x70,0x00
000120  7c404078          DCB      0x7c,0x40,0x40,0x78
000124  40407c00          DCB      0x40,0x40,0x7c,0x00
000128  7c404078          DCB      0x7c,0x40,0x40,0x78
00012c  40404000          DCB      0x40,0x40,0x40,0x00
000130  3844405c          DCB      0x38,0x44,0x40,0x5c
000134  44443800          DCB      0x44,0x44,0x38,0x00
000138  4444447c          DCB      0x44,0x44,0x44,0x7c
00013c  44444400          DCB      0x44,0x44,0x44,0x00
000140  38101010          DCB      0x38,0x10,0x10,0x10
000144  10103800          DCB      0x10,0x10,0x38,0x00
000148  1c080808          DCB      0x1c,0x08,0x08,0x08
00014c  08483000          DCB      0x08,0x48,0x30,0x00
000150  44485060          DCB      0x44,0x48,0x50,0x60
000154  50484400          DCB      0x50,0x48,0x44,0x00
000158  40404040          DCB      0x40,0x40,0x40,0x40
00015c  40407c00          DCB      0x40,0x40,0x7c,0x00
000160  446c5454          DCB      0x44,0x6c,0x54,0x54
000164  44444400          DCB      0x44,0x44,0x44,0x00
000168  44446454          DCB      0x44,0x44,0x64,0x54
00016c  4c444400          DCB      0x4c,0x44,0x44,0x00
000170  38444444          DCB      0x38,0x44,0x44,0x44
000174  44443800          DCB      0x44,0x44,0x38,0x00
000178  78444478          DCB      0x78,0x44,0x44,0x78
00017c  40404000          DCB      0x40,0x40,0x40,0x00
000180  70888888          DCB      0x70,0x88,0x88,0x88
000184  a8906800          DCB      0xa8,0x90,0x68,0x00
000188  78444478          DCB      0x78,0x44,0x44,0x78
00018c  50484400          DCB      0x50,0x48,0x44,0x00
000190  3c404038          DCB      0x3c,0x40,0x40,0x38
000194  04047800          DCB      0x04,0x04,0x78,0x00
000198  7c101010          DCB      0x7c,0x10,0x10,0x10
00019c  10101000          DCB      0x10,0x10,0x10,0x00
0001a0  44444444          DCB      0x44,0x44,0x44,0x44
0001a4  44443800          DCB      0x44,0x44,0x38,0x00
0001a8  44444444          DCB      0x44,0x44,0x44,0x44
0001ac  44281000          DCB      0x44,0x28,0x10,0x00
0001b0  44444444          DCB      0x44,0x44,0x44,0x44
0001b4  44543800          DCB      0x44,0x54,0x38,0x00
0001b8  44442810          DCB      0x44,0x44,0x28,0x10
0001bc  28444400          DCB      0x28,0x44,0x44,0x00
0001c0  44444428          DCB      0x44,0x44,0x44,0x28
0001c4  10101000          DCB      0x10,0x10,0x10,0x00
0001c8  7c040810          DCB      0x7c,0x04,0x08,0x10
0001cc  20407c00          DCB      0x20,0x40,0x7c,0x00
0001d0  70404040          DCB      0x70,0x40,0x40,0x40
0001d4  40407000          DCB      0x40,0x40,0x70,0x00
0001d8  44287c10          DCB      0x44,0x28,0x7c,0x10
0001dc  7c101000          DCB      0x7c,0x10,0x10,0x00
0001e0  10284400          DCB      0x10,0x28,0x44,0x00
0001e4  00000000          DCB      0x00,0x00,0x00,0x00
0001e8  00000000          DCB      0x00,0x00,0x00,0x00
0001ec  00007c00          DCB      0x00,0x00,0x7c,0x00
0001f0  40201000          DCB      0x40,0x20,0x10,0x00
0001f4  00000000          DCB      0x00,0x00,0x00,0x00
0001f8  00003804          DCB      0x00,0x00,0x38,0x04
0001fc  3c443c00          DCB      0x3c,0x44,0x3c,0x00
000200  40407844          DCB      0x40,0x40,0x78,0x44
000204  44447800          DCB      0x44,0x44,0x78,0x00
000208  00003840          DCB      0x00,0x00,0x38,0x40
00020c  40403800          DCB      0x40,0x40,0x38,0x00
000210  0404344c          DCB      0x04,0x04,0x34,0x4c
000214  44443c00          DCB      0x44,0x44,0x3c,0x00
000218  00003844          DCB      0x00,0x00,0x38,0x44
00021c  7c403800          DCB      0x7c,0x40,0x38,0x00
000220  18242020          DCB      0x18,0x24,0x20,0x20
000224  70202000          DCB      0x70,0x20,0x20,0x00
000228  003c4444          DCB      0x00,0x3c,0x44,0x44
00022c  3c043800          DCB      0x3c,0x04,0x38,0x00
000230  40405864          DCB      0x40,0x40,0x58,0x64
000234  44444400          DCB      0x44,0x44,0x44,0x00
000238  10003010          DCB      0x10,0x00,0x30,0x10
00023c  10103800          DCB      0x10,0x10,0x38,0x00
000240  08000808          DCB      0x08,0x00,0x08,0x08
000244  08483000          DCB      0x08,0x48,0x30,0x00
000248  40404850          DCB      0x40,0x40,0x48,0x50
00024c  60504800          DCB      0x60,0x50,0x48,0x00
000250  30101010          DCB      0x30,0x10,0x10,0x10
000254  10103800          DCB      0x10,0x10,0x38,0x00
000258  00006854          DCB      0x00,0x00,0x68,0x54
00025c  54444400          DCB      0x54,0x44,0x44,0x00
000260  00005864          DCB      0x00,0x00,0x58,0x64
000264  44444400          DCB      0x44,0x44,0x44,0x00
000268  00003844          DCB      0x00,0x00,0x38,0x44
00026c  44443800          DCB      0x44,0x44,0x38,0x00
000270  00007844          DCB      0x00,0x00,0x78,0x44
000274  78404000          DCB      0x78,0x40,0x40,0x00
000278  0000344c          DCB      0x00,0x00,0x34,0x4c
00027c  3c040400          DCB      0x3c,0x04,0x04,0x00
000280  00005864          DCB      0x00,0x00,0x58,0x64
000284  40404000          DCB      0x40,0x40,0x40,0x00
000288  00003840          DCB      0x00,0x00,0x38,0x40
00028c  38047800          DCB      0x38,0x04,0x78,0x00
000290  20207020          DCB      0x20,0x20,0x70,0x20
000294  20241800          DCB      0x20,0x24,0x18,0x00
000298  00004444          DCB      0x00,0x00,0x44,0x44
00029c  444c3400          DCB      0x44,0x4c,0x34,0x00
0002a0  00004444          DCB      0x00,0x00,0x44,0x44
0002a4  44281000          DCB      0x44,0x28,0x10,0x00
0002a8  00444444          DCB      0x00,0x44,0x44,0x44
0002ac  54280000          DCB      0x54,0x28,0x00,0x00
0002b0  00442810          DCB      0x00,0x44,0x28,0x10
0002b4  28440000          DCB      0x28,0x44,0x00,0x00
0002b8  0044443c          DCB      0x00,0x44,0x44,0x3c
0002bc  04043800          DCB      0x04,0x04,0x38,0x00
0002c0  00007c08          DCB      0x00,0x00,0x7c,0x08
0002c4  10207c00          DCB      0x10,0x20,0x7c,0x00
0002c8  10202040          DCB      0x10,0x20,0x20,0x40
0002cc  20201000          DCB      0x20,0x20,0x10,0x00
0002d0  10101010          DCB      0x10,0x10,0x10,0x10
0002d4  10101000          DCB      0x10,0x10,0x10,0x00
0002d8  40202010          DCB      0x40,0x20,0x20,0x10
0002dc  20204000          DCB      0x20,0x20,0x40,0x00
0002e0  0010087c          DCB      0x00,0x10,0x08,0x7c
0002e4  08100000          DCB      0x08,0x10,0x00,0x00
0002e8  0010207c          DCB      0x00,0x10,0x20,0x7c
0002ec  20100000          DCB      0x20,0x10,0x00,0x00
0002f0  10284444          DCB      0x10,0x28,0x44,0x44
0002f4  44443800          DCB      0x44,0x44,0x38,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  b
000000  00                DCB      0x00
                  bMask
000001  00                DCB      0x00
                  i
000002  00                DCB      0x00
                  j
000003  00                DCB      0x00
                  bCol
000004  00                DCB      0x00
                  iNumControllers
000005  000000            DCB      0x00,0x00,0x00
                  d
                          DCD      0x00000000
                  iWidth
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\SMP\\smp_max7219.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_smp_max7219_c_ucFont____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___13_smp_max7219_c_ucFont____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_smp_max7219_c_ucFont____REVSH|
#line 507
|__asm___13_smp_max7219_c_ucFont____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_smp_max7219_c_ucFont____RRX|
#line 694
|__asm___13_smp_max7219_c_ucFont____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
