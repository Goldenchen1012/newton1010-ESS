L 1 "..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_ll_dma2d.c"
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_dma2d.c
N  * @author  MCD Application Team
N  * @brief   DMA2D LL module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 0L
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32l4xx_ll_dma2d.h"
S#include "stm32l4xx_ll_bus.h"
S#ifdef  USE_FULL_ASSERT
S#include "stm32_assert.h"
S#else
S#define assert_param(expr) ((void)0U)
S#endif
S
S/** @addtogroup STM32L4xx_LL_Driver
S  * @{
S  */
S
S#if defined (DMA2D)
S
S/** @addtogroup DMA2D_LL
S  * @{
S  */
S
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/** @addtogroup DMA2D_LL_Private_Constants DMA2D Private Constants
S  * @{
S  */
S#define LL_DMA2D_COLOR            0xFFU                                      /*!< Maximum output color setting                   */
S#define LL_DMA2D_NUMBEROFLINES    DMA2D_NLR_NL                               /*!< Maximum number of lines                        */
S#define LL_DMA2D_NUMBEROFPIXELS   (DMA2D_NLR_PL >> DMA2D_NLR_PL_Pos)         /*!< Maximum number of pixels per lines             */
S#define LL_DMA2D_OFFSET_MAX       0x3FFFU                                    /*!< Maximum output line offset expressed in pixels */
S#define LL_DMA2D_CLUTSIZE_MAX     0xFFU                                      /*!< Maximum CLUT size                              */
S/**
S  * @}
S  */
S/* Private macros ------------------------------------------------------------*/
S/** @addtogroup DMA2D_LL_Private_Macros
S  * @{
S  */
S#if defined(DMA2D_M2M_BLEND_FIXED_COLOR_FG_BG_SUPPORT)
S#define IS_LL_DMA2D_MODE(MODE)          (((MODE) == LL_DMA2D_MODE_M2M)                      || \
S                                         ((MODE) == LL_DMA2D_MODE_M2M_PFC)                  || \
S                                         ((MODE) == LL_DMA2D_MODE_M2M_BLEND)                || \
S                                         ((MODE) == LL_DMA2D_MODE_M2M_BLEND_FIXED_COLOR_FG) || \
S                                         ((MODE) == LL_DMA2D_MODE_M2M_BLEND_FIXED_COLOR_BG) || \
S                                         ((MODE) == LL_DMA2D_MODE_R2M))
X#define IS_LL_DMA2D_MODE(MODE)          (((MODE) == LL_DMA2D_MODE_M2M)                      ||                                          ((MODE) == LL_DMA2D_MODE_M2M_PFC)                  ||                                          ((MODE) == LL_DMA2D_MODE_M2M_BLEND)                ||                                          ((MODE) == LL_DMA2D_MODE_M2M_BLEND_FIXED_COLOR_FG) ||                                          ((MODE) == LL_DMA2D_MODE_M2M_BLEND_FIXED_COLOR_BG) ||                                          ((MODE) == LL_DMA2D_MODE_R2M))
S#else
S#define IS_LL_DMA2D_MODE(MODE)          (((MODE) == LL_DMA2D_MODE_M2M)       || \
S                                         ((MODE) == LL_DMA2D_MODE_M2M_PFC)   || \
S                                         ((MODE) == LL_DMA2D_MODE_M2M_BLEND) || \
S                                         ((MODE) == LL_DMA2D_MODE_R2M))
X#define IS_LL_DMA2D_MODE(MODE)          (((MODE) == LL_DMA2D_MODE_M2M)       ||                                          ((MODE) == LL_DMA2D_MODE_M2M_PFC)   ||                                          ((MODE) == LL_DMA2D_MODE_M2M_BLEND) ||                                          ((MODE) == LL_DMA2D_MODE_R2M))
S#endif /*DMA2D_M2M_BLEND_FIXED_COLOR_FG_BG_SUPPORT*/
S
S#define IS_LL_DMA2D_OCMODE(MODE_ARGB)   (((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_ARGB8888) || \
S                                         ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_RGB888)   || \
S                                         ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_RGB565)   || \
S                                         ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_ARGB1555) || \
S                                         ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_ARGB4444))
X#define IS_LL_DMA2D_OCMODE(MODE_ARGB)   (((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_ARGB8888) ||                                          ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_RGB888)   ||                                          ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_RGB565)   ||                                          ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_ARGB1555) ||                                          ((MODE_ARGB) == LL_DMA2D_OUTPUT_MODE_ARGB4444))
S
S#define IS_LL_DMA2D_GREEN(GREEN)        ((GREEN) <= LL_DMA2D_COLOR)
S#define IS_LL_DMA2D_RED(RED)            ((RED)   <= LL_DMA2D_COLOR)
S#define IS_LL_DMA2D_BLUE(BLUE)          ((BLUE)  <= LL_DMA2D_COLOR)
S#define IS_LL_DMA2D_ALPHA(ALPHA)        ((ALPHA) <= LL_DMA2D_COLOR)
S
S#if defined(DMA2D_LINE_OFFSET_MODE_SUPPORT)
S#define IS_LL_DMA2D_OFFSET_MODE(MODE)   (((MODE) == LL_DMA2D_LINE_OFFSET_PIXELS) || \
S                                         ((MODE) == LL_DMA2D_LINE_OFFSET_BYTES))
X#define IS_LL_DMA2D_OFFSET_MODE(MODE)   (((MODE) == LL_DMA2D_LINE_OFFSET_PIXELS) ||                                          ((MODE) == LL_DMA2D_LINE_OFFSET_BYTES))
S#endif /* DMA2D_LINE_OFFSET_MODE_SUPPORT */
S
S#define IS_LL_DMA2D_OFFSET(OFFSET)      ((OFFSET) <= LL_DMA2D_OFFSET_MAX)
S
S#define IS_LL_DMA2D_LINE(LINES)         ((LINES)  <= LL_DMA2D_NUMBEROFLINES)
S#define IS_LL_DMA2D_PIXEL(PIXELS)       ((PIXELS) <= LL_DMA2D_NUMBEROFPIXELS)
S
S#if defined(DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT)
S#define IS_LL_DMA2D_SWAP_MODE(MODE)     (((MODE) == LL_DMA2D_SWAP_MODE_REGULAR) || \
S                                         ((MODE) == LL_DMA2D_SWAP_MODE_TWO_BY_TWO))
X#define IS_LL_DMA2D_SWAP_MODE(MODE)     (((MODE) == LL_DMA2D_SWAP_MODE_REGULAR) ||                                          ((MODE) == LL_DMA2D_SWAP_MODE_TWO_BY_TWO))
S#endif /* DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT */
S
S#define IS_LL_DMA2D_ALPHAINV(ALPHA)     (((ALPHA) == LL_DMA2D_ALPHA_REGULAR) || \
S                                         ((ALPHA) == LL_DMA2D_ALPHA_INVERTED))
X#define IS_LL_DMA2D_ALPHAINV(ALPHA)     (((ALPHA) == LL_DMA2D_ALPHA_REGULAR) ||                                          ((ALPHA) == LL_DMA2D_ALPHA_INVERTED))
S
S#define IS_LL_DMA2D_RBSWAP(RBSWAP)      (((RBSWAP) == LL_DMA2D_RB_MODE_REGULAR) || \
S                                         ((RBSWAP) == LL_DMA2D_RB_MODE_SWAP))
X#define IS_LL_DMA2D_RBSWAP(RBSWAP)      (((RBSWAP) == LL_DMA2D_RB_MODE_REGULAR) ||                                          ((RBSWAP) == LL_DMA2D_RB_MODE_SWAP))
S
S#define IS_LL_DMA2D_LCMODE(MODE_ARGB)   (((MODE_ARGB) == LL_DMA2D_INPUT_MODE_ARGB8888) || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_RGB888)   || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_RGB565)   || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_ARGB1555) || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_ARGB4444) || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_L8)       || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_AL44)     || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_AL88)     || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_L4)       || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_A8)       || \
S                                         ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_A4))
X#define IS_LL_DMA2D_LCMODE(MODE_ARGB)   (((MODE_ARGB) == LL_DMA2D_INPUT_MODE_ARGB8888) ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_RGB888)   ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_RGB565)   ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_ARGB1555) ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_ARGB4444) ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_L8)       ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_AL44)     ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_AL88)     ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_L4)       ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_A8)       ||                                          ((MODE_ARGB) == LL_DMA2D_INPUT_MODE_A4))
S
S#define IS_LL_DMA2D_CLUTCMODE(CLUTCMODE) (((CLUTCMODE) == LL_DMA2D_CLUT_COLOR_MODE_ARGB8888) || \
S                                          ((CLUTCMODE) == LL_DMA2D_CLUT_COLOR_MODE_RGB888))
X#define IS_LL_DMA2D_CLUTCMODE(CLUTCMODE) (((CLUTCMODE) == LL_DMA2D_CLUT_COLOR_MODE_ARGB8888) ||                                           ((CLUTCMODE) == LL_DMA2D_CLUT_COLOR_MODE_RGB888))
S
S#define IS_LL_DMA2D_CLUTSIZE(SIZE)      ((SIZE) <= LL_DMA2D_CLUTSIZE_MAX)
S
S#define IS_LL_DMA2D_ALPHAMODE(MODE)     (((MODE) == LL_DMA2D_ALPHA_MODE_NO_MODIF) || \
S                                         ((MODE) == LL_DMA2D_ALPHA_MODE_REPLACE)  || \
S                                         ((MODE) == LL_DMA2D_ALPHA_MODE_COMBINE))
X#define IS_LL_DMA2D_ALPHAMODE(MODE)     (((MODE) == LL_DMA2D_ALPHA_MODE_NO_MODIF) ||                                          ((MODE) == LL_DMA2D_ALPHA_MODE_REPLACE)  ||                                          ((MODE) == LL_DMA2D_ALPHA_MODE_COMBINE))
S
S
S/**
S  * @}
S  */
S
S/* Private function prototypes -----------------------------------------------*/
S
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup DMA2D_LL_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup DMA2D_LL_EF_Init_Functions Initialization and De-initialization Functions
S  * @{
S  */
S
S/**
S  * @brief  De-initialize DMA2D registers (registers restored to their default values).
S  * @param  DMA2Dx DMA2D Instance
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: DMA2D registers are de-initialized
S  *          - ERROR: DMA2D registers are not de-initialized
S  */
SErrorStatus LL_DMA2D_DeInit(DMA2D_TypeDef *DMA2Dx)
S{
S  ErrorStatus status = SUCCESS;
S
S  /* Check the parameters */
S  assert_param(IS_DMA2D_ALL_INSTANCE(DMA2Dx));
S
S  if (DMA2Dx == DMA2D)
S  {
S    /* Force reset of DMA2D clock */
S    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA2D);
S
S    /* Release reset of DMA2D clock */
S    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA2D);
S  }
S  else
S  {
S    status = ERROR;
S  }
S
S  return (status);
S}
S
S/**
S  * @brief  Initialize DMA2D registers according to the specified parameters in DMA2D_InitStruct.
S  * @note   DMA2D transfers must be disabled to set initialization bits in configuration registers,
S  *         otherwise ERROR result is returned.
S  * @param  DMA2Dx DMA2D Instance
S  * @param  DMA2D_InitStruct  pointer to a LL_DMA2D_InitTypeDef structure
S  *         that contains the configuration information for the specified DMA2D peripheral.
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: DMA2D registers are initialized according to DMA2D_InitStruct content
S  *          - ERROR: Issue occurred during DMA2D registers initialization
S  */
SErrorStatus LL_DMA2D_Init(DMA2D_TypeDef *DMA2Dx, LL_DMA2D_InitTypeDef *DMA2D_InitStruct)
S{
S  ErrorStatus status = ERROR;
S  LL_DMA2D_ColorTypeDef DMA2D_ColorStruct;
S  uint32_t tmp, tmp1, tmp2;
S  uint32_t regMask, regValue;
S
S  /* Check the parameters */
S  assert_param(IS_DMA2D_ALL_INSTANCE(DMA2Dx));
S  assert_param(IS_LL_DMA2D_MODE(DMA2D_InitStruct->Mode));
S  assert_param(IS_LL_DMA2D_OCMODE(DMA2D_InitStruct->ColorMode));
S  assert_param(IS_LL_DMA2D_LINE(DMA2D_InitStruct->NbrOfLines));
S  assert_param(IS_LL_DMA2D_PIXEL(DMA2D_InitStruct->NbrOfPixelsPerLines));
S  assert_param(IS_LL_DMA2D_GREEN(DMA2D_InitStruct->OutputGreen));
S  assert_param(IS_LL_DMA2D_RED(DMA2D_InitStruct->OutputRed));
S  assert_param(IS_LL_DMA2D_BLUE(DMA2D_InitStruct->OutputBlue));
S  assert_param(IS_LL_DMA2D_ALPHA(DMA2D_InitStruct->OutputAlpha));
S#if defined(DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT)
S  assert_param(IS_LL_DMA2D_SWAP_MODE(DMA2D_InitStruct->OutputSwapMode));
S#endif /* DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT */
S#if defined(DMA2D_LINE_OFFSET_MODE_SUPPORT)
S  assert_param(IS_LL_DMA2D_OFFSET_MODE(DMA2D_InitStruct->LineOffsetMode));
S#endif /* DMA2D_LINE_OFFSET_MODE_SUPPORT */
S  assert_param(IS_LL_DMA2D_OFFSET(DMA2D_InitStruct->LineOffset));
S  assert_param(IS_LL_DMA2D_ALPHAINV(DMA2D_InitStruct->AlphaInversionMode));
S  assert_param(IS_LL_DMA2D_RBSWAP(DMA2D_InitStruct->RBSwapMode));
S
S  /* DMA2D transfers must be disabled to configure bits in initialization registers */
S  tmp = LL_DMA2D_IsTransferOngoing(DMA2Dx);
S  tmp1 = LL_DMA2D_FGND_IsEnabledCLUTLoad(DMA2Dx);
S  tmp2 = LL_DMA2D_BGND_IsEnabledCLUTLoad(DMA2Dx);
S  if ((tmp == 0U) && (tmp1 == 0U) && (tmp2 == 0U))
S  {
S    /* DMA2D CR register configuration -------------------------------------------*/
S#if defined(DMA2D_LINE_OFFSET_MODE_SUPPORT)
S    MODIFY_REG(DMA2Dx->CR, (DMA2D_CR_MODE | DMA2D_CR_LOM), \
S               (DMA2D_InitStruct->Mode | DMA2D_InitStruct->LineOffsetMode));
X    MODIFY_REG(DMA2Dx->CR, (DMA2D_CR_MODE | DMA2D_CR_LOM),                (DMA2D_InitStruct->Mode | DMA2D_InitStruct->LineOffsetMode));
S#else
S    LL_DMA2D_SetMode(DMA2Dx, DMA2D_InitStruct->Mode);
S#endif /* DMA2D_LINE_OFFSET_MODE_SUPPORT */
S
S    /* DMA2D OPFCCR register configuration ---------------------------------------*/
S    regMask = DMA2D_OPFCCR_CM;
S    regValue = DMA2D_InitStruct->ColorMode;
S
S#if defined(DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT)
S    regMask |= DMA2D_OPFCCR_SB;
S    regValue |= DMA2D_InitStruct->OutputSwapMode;
S#endif /* DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT */
S
S    regMask |= (DMA2D_OPFCCR_RBS | DMA2D_OPFCCR_AI);
S    regValue |= (DMA2D_InitStruct->AlphaInversionMode | DMA2D_InitStruct->RBSwapMode);
S
S
S    MODIFY_REG(DMA2Dx->OPFCCR, regMask, regValue);
S
S    /* DMA2D OOR register configuration ------------------------------------------*/
S    LL_DMA2D_SetLineOffset(DMA2Dx, DMA2D_InitStruct->LineOffset);
S
S    /* DMA2D NLR register configuration ------------------------------------------*/
S    LL_DMA2D_ConfigSize(DMA2Dx, DMA2D_InitStruct->NbrOfLines, DMA2D_InitStruct->NbrOfPixelsPerLines);
S
S    /* DMA2D OMAR register configuration ------------------------------------------*/
S    LL_DMA2D_SetOutputMemAddr(DMA2Dx, DMA2D_InitStruct->OutputMemoryAddress);
S
S    /* DMA2D OCOLR register configuration ------------------------------------------*/
S    DMA2D_ColorStruct.ColorMode   = DMA2D_InitStruct->ColorMode;
S    DMA2D_ColorStruct.OutputBlue  = DMA2D_InitStruct->OutputBlue;
S    DMA2D_ColorStruct.OutputGreen = DMA2D_InitStruct->OutputGreen;
S    DMA2D_ColorStruct.OutputRed   = DMA2D_InitStruct->OutputRed;
S    DMA2D_ColorStruct.OutputAlpha = DMA2D_InitStruct->OutputAlpha;
S    LL_DMA2D_ConfigOutputColor(DMA2Dx, &DMA2D_ColorStruct);
S
S    status = SUCCESS;
S  }
S  /* If DMA2D transfers are not disabled, return ERROR */
S
S  return (status);
S}
S
S/**
S  * @brief Set each @ref LL_DMA2D_InitTypeDef field to default value.
S  * @param DMA2D_InitStruct  pointer to a @ref LL_DMA2D_InitTypeDef structure
S  *                          whose fields will be set to default values.
S  * @retval None
S  */
Svoid LL_DMA2D_StructInit(LL_DMA2D_InitTypeDef *DMA2D_InitStruct)
S{
S  /* Set DMA2D_InitStruct fields to default values */
S  DMA2D_InitStruct->Mode                = LL_DMA2D_MODE_M2M;
S  DMA2D_InitStruct->ColorMode           = LL_DMA2D_OUTPUT_MODE_ARGB8888;
S  DMA2D_InitStruct->NbrOfLines          = 0x0U;
S  DMA2D_InitStruct->NbrOfPixelsPerLines = 0x0U;
S#if defined(DMA2D_LINE_OFFSET_MODE_SUPPORT)
S  DMA2D_InitStruct->LineOffsetMode      = LL_DMA2D_LINE_OFFSET_PIXELS;
S#endif /* DMA2D_LINE_OFFSET_MODE_SUPPORT */
S  DMA2D_InitStruct->LineOffset          = 0x0U;
S  DMA2D_InitStruct->OutputBlue          = 0x0U;
S  DMA2D_InitStruct->OutputGreen         = 0x0U;
S  DMA2D_InitStruct->OutputRed           = 0x0U;
S  DMA2D_InitStruct->OutputAlpha         = 0x0U;
S  DMA2D_InitStruct->OutputMemoryAddress = 0x0U;
S#if defined(DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT)
S  DMA2D_InitStruct->OutputSwapMode      = LL_DMA2D_SWAP_MODE_REGULAR;
S#endif /* DMA2D_OUTPUT_TWO_BY_TWO_SWAP_SUPPORT */
S  DMA2D_InitStruct->AlphaInversionMode  = LL_DMA2D_ALPHA_REGULAR;
S  DMA2D_InitStruct->RBSwapMode          = LL_DMA2D_RB_MODE_REGULAR;
S}
S
S/**
S  * @brief  Configure the foreground or background according to the specified parameters
S  *         in the LL_DMA2D_LayerCfgTypeDef structure.
S  * @param  DMA2Dx DMA2D Instance
S  * @param  DMA2D_LayerCfg  pointer to a LL_DMA2D_LayerCfgTypeDef structure that contains
S  *         the configuration information for the specified layer.
S  * @param  LayerIdx  DMA2D Layer index.
S  *                   This parameter can be one of the following values:
S  *                   0(background) / 1(foreground)
S  * @retval None
S  */
Svoid LL_DMA2D_ConfigLayer(DMA2D_TypeDef *DMA2Dx, LL_DMA2D_LayerCfgTypeDef *DMA2D_LayerCfg, uint32_t LayerIdx)
S{
S  /* Check the parameters */
S  assert_param(IS_LL_DMA2D_OFFSET(DMA2D_LayerCfg->LineOffset));
S  assert_param(IS_LL_DMA2D_LCMODE(DMA2D_LayerCfg->ColorMode));
S  assert_param(IS_LL_DMA2D_CLUTCMODE(DMA2D_LayerCfg->CLUTColorMode));
S  assert_param(IS_LL_DMA2D_CLUTSIZE(DMA2D_LayerCfg->CLUTSize));
S  assert_param(IS_LL_DMA2D_ALPHAMODE(DMA2D_LayerCfg->AlphaMode));
S  assert_param(IS_LL_DMA2D_GREEN(DMA2D_LayerCfg->Green));
S  assert_param(IS_LL_DMA2D_RED(DMA2D_LayerCfg->Red));
S  assert_param(IS_LL_DMA2D_BLUE(DMA2D_LayerCfg->Blue));
S  assert_param(IS_LL_DMA2D_ALPHA(DMA2D_LayerCfg->Alpha));
S  assert_param(IS_LL_DMA2D_ALPHAINV(DMA2D_LayerCfg->AlphaInversionMode));
S  assert_param(IS_LL_DMA2D_RBSWAP(DMA2D_LayerCfg->RBSwapMode));
S
S
S  if (LayerIdx == 0U)
S  {
S    /* Configure the background memory address */
S    LL_DMA2D_BGND_SetMemAddr(DMA2Dx, DMA2D_LayerCfg->MemoryAddress);
S
S    /* Configure the background line offset */
S    LL_DMA2D_BGND_SetLineOffset(DMA2Dx, DMA2D_LayerCfg->LineOffset);
S
S    /* Configure the background Alpha value, Alpha mode, RB swap, Alpha inversion
S       CLUT size, CLUT Color mode and Color mode */
S    MODIFY_REG(DMA2Dx->BGPFCCR, \
S               (DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_RBS | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_AM | \
S                DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM | DMA2D_BGPFCCR_CM), \
S               ((DMA2D_LayerCfg->Alpha << DMA2D_BGPFCCR_ALPHA_Pos) | DMA2D_LayerCfg->RBSwapMode | \
S                DMA2D_LayerCfg->AlphaInversionMode | DMA2D_LayerCfg->AlphaMode | \
S                (DMA2D_LayerCfg->CLUTSize << DMA2D_BGPFCCR_CS_Pos) | DMA2D_LayerCfg->CLUTColorMode | \
S                DMA2D_LayerCfg->ColorMode));
X    MODIFY_REG(DMA2Dx->BGPFCCR,                (DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_RBS | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_AM |                 DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM | DMA2D_BGPFCCR_CM),                ((DMA2D_LayerCfg->Alpha << DMA2D_BGPFCCR_ALPHA_Pos) | DMA2D_LayerCfg->RBSwapMode |                 DMA2D_LayerCfg->AlphaInversionMode | DMA2D_LayerCfg->AlphaMode |                 (DMA2D_LayerCfg->CLUTSize << DMA2D_BGPFCCR_CS_Pos) | DMA2D_LayerCfg->CLUTColorMode |                 DMA2D_LayerCfg->ColorMode));
S
S    /* Configure the background color */
S    LL_DMA2D_BGND_SetColor(DMA2Dx, DMA2D_LayerCfg->Red, DMA2D_LayerCfg->Green, DMA2D_LayerCfg->Blue);
S
S    /* Configure the background CLUT memory address */
S    LL_DMA2D_BGND_SetCLUTMemAddr(DMA2Dx, DMA2D_LayerCfg->CLUTMemoryAddress);
S  }
S  else
S  {
S    /* Configure the foreground memory address */
S    LL_DMA2D_FGND_SetMemAddr(DMA2Dx, DMA2D_LayerCfg->MemoryAddress);
S
S    /* Configure the foreground line offset */
S    LL_DMA2D_FGND_SetLineOffset(DMA2Dx, DMA2D_LayerCfg->LineOffset);
S
S    /* Configure the foreground Alpha value, Alpha mode, RB swap, Alpha inversion
S       CLUT size, CLUT Color mode and Color mode */
S    MODIFY_REG(DMA2Dx->FGPFCCR, \
S               (DMA2D_FGPFCCR_ALPHA | DMA2D_FGPFCCR_RBS | DMA2D_FGPFCCR_AI | DMA2D_FGPFCCR_AM | \
S                DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM | DMA2D_FGPFCCR_CM), \
S               ((DMA2D_LayerCfg->Alpha << DMA2D_FGPFCCR_ALPHA_Pos) | DMA2D_LayerCfg->RBSwapMode | \
S                DMA2D_LayerCfg->AlphaInversionMode | DMA2D_LayerCfg->AlphaMode | \
S                (DMA2D_LayerCfg->CLUTSize << DMA2D_FGPFCCR_CS_Pos) | DMA2D_LayerCfg->CLUTColorMode | \
S                DMA2D_LayerCfg->ColorMode));
X    MODIFY_REG(DMA2Dx->FGPFCCR,                (DMA2D_FGPFCCR_ALPHA | DMA2D_FGPFCCR_RBS | DMA2D_FGPFCCR_AI | DMA2D_FGPFCCR_AM |                 DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM | DMA2D_FGPFCCR_CM),                ((DMA2D_LayerCfg->Alpha << DMA2D_FGPFCCR_ALPHA_Pos) | DMA2D_LayerCfg->RBSwapMode |                 DMA2D_LayerCfg->AlphaInversionMode | DMA2D_LayerCfg->AlphaMode |                 (DMA2D_LayerCfg->CLUTSize << DMA2D_FGPFCCR_CS_Pos) | DMA2D_LayerCfg->CLUTColorMode |                 DMA2D_LayerCfg->ColorMode));
S
S    /* Configure the foreground color */
S    LL_DMA2D_FGND_SetColor(DMA2Dx, DMA2D_LayerCfg->Red, DMA2D_LayerCfg->Green, DMA2D_LayerCfg->Blue);
S
S    /* Configure the foreground CLUT memory address */
S    LL_DMA2D_FGND_SetCLUTMemAddr(DMA2Dx, DMA2D_LayerCfg->CLUTMemoryAddress);
S  }
S}
S
S/**
S  * @brief Set each @ref LL_DMA2D_LayerCfgTypeDef field to default value.
S  * @param DMA2D_LayerCfg  pointer to a @ref LL_DMA2D_LayerCfgTypeDef structure
S  *                        whose fields will be set to default values.
S  * @retval None
S  */
Svoid LL_DMA2D_LayerCfgStructInit(LL_DMA2D_LayerCfgTypeDef *DMA2D_LayerCfg)
S{
S  /* Set DMA2D_LayerCfg fields to default values */
S  DMA2D_LayerCfg->MemoryAddress      = 0x0U;
S  DMA2D_LayerCfg->ColorMode          = LL_DMA2D_INPUT_MODE_ARGB8888;
S  DMA2D_LayerCfg->LineOffset         = 0x0U;
S  DMA2D_LayerCfg->CLUTColorMode      = LL_DMA2D_CLUT_COLOR_MODE_ARGB8888;
S  DMA2D_LayerCfg->CLUTSize           = 0x0U;
S  DMA2D_LayerCfg->AlphaMode          = LL_DMA2D_ALPHA_MODE_NO_MODIF;
S  DMA2D_LayerCfg->Alpha              = 0x0U;
S  DMA2D_LayerCfg->Blue               = 0x0U;
S  DMA2D_LayerCfg->Green              = 0x0U;
S  DMA2D_LayerCfg->Red                = 0x0U;
S  DMA2D_LayerCfg->CLUTMemoryAddress  = 0x0U;
S  DMA2D_LayerCfg->AlphaInversionMode = LL_DMA2D_ALPHA_REGULAR;
S  DMA2D_LayerCfg->RBSwapMode         = LL_DMA2D_RB_MODE_REGULAR;
S}
S
S/**
S  * @brief  Initialize DMA2D output color register according to the specified parameters
S  *         in DMA2D_ColorStruct.
S  * @param  DMA2Dx DMA2D Instance
S  * @param  DMA2D_ColorStruct  pointer to a LL_DMA2D_ColorTypeDef structure that contains
S  *         the color configuration information for the specified DMA2D peripheral.
S  * @retval None
S  */
Svoid LL_DMA2D_ConfigOutputColor(DMA2D_TypeDef *DMA2Dx, LL_DMA2D_ColorTypeDef *DMA2D_ColorStruct)
S{
S  uint32_t outgreen;
S  uint32_t outred;
S  uint32_t outalpha;
S
S  /* Check the parameters */
S  assert_param(IS_DMA2D_ALL_INSTANCE(DMA2Dx));
S  assert_param(IS_LL_DMA2D_OCMODE(DMA2D_ColorStruct->ColorMode));
S  assert_param(IS_LL_DMA2D_GREEN(DMA2D_ColorStruct->OutputGreen));
S  assert_param(IS_LL_DMA2D_RED(DMA2D_ColorStruct->OutputRed));
S  assert_param(IS_LL_DMA2D_BLUE(DMA2D_ColorStruct->OutputBlue));
S  assert_param(IS_LL_DMA2D_ALPHA(DMA2D_ColorStruct->OutputAlpha));
S
S  /* DMA2D OCOLR register configuration ------------------------------------------*/
S  if (DMA2D_ColorStruct->ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB8888)
S  {
S    outgreen = DMA2D_ColorStruct->OutputGreen << 8U;
S    outred = DMA2D_ColorStruct->OutputRed << 16U;
S    outalpha = DMA2D_ColorStruct->OutputAlpha << 24U;
S  }
S  else if (DMA2D_ColorStruct->ColorMode == LL_DMA2D_OUTPUT_MODE_RGB888)
S  {
S    outgreen = DMA2D_ColorStruct->OutputGreen << 8U;
S    outred = DMA2D_ColorStruct->OutputRed << 16U;
S    outalpha = 0x00000000U;
S  }
S  else if (DMA2D_ColorStruct->ColorMode == LL_DMA2D_OUTPUT_MODE_RGB565)
S  {
S    outgreen = DMA2D_ColorStruct->OutputGreen << 5U;
S    outred = DMA2D_ColorStruct->OutputRed << 11U;
S    outalpha = 0x00000000U;
S  }
S  else if (DMA2D_ColorStruct->ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB1555)
S  {
S    outgreen = DMA2D_ColorStruct->OutputGreen << 5U;
S    outred = DMA2D_ColorStruct->OutputRed << 10U;
S    outalpha = DMA2D_ColorStruct->OutputAlpha << 15U;
S  }
S  else /* ColorMode = LL_DMA2D_OUTPUT_MODE_ARGB4444 */
S  {
S    outgreen = DMA2D_ColorStruct->OutputGreen << 4U;
S    outred = DMA2D_ColorStruct->OutputRed << 8U;
S    outalpha = DMA2D_ColorStruct->OutputAlpha << 12U;
S  }
S  LL_DMA2D_SetOutputColor(DMA2Dx, (outgreen | outred | DMA2D_ColorStruct->OutputBlue | outalpha));
S}
S
S/**
S  * @brief  Return DMA2D output Blue color.
S  * @param  DMA2Dx DMA2D Instance.
S  * @param  ColorMode This parameter can be one of the following values:
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB8888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB565
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB1555
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB4444
S  * @retval Output Blue color value between Min_Data=0 and Max_Data=0xFF
S  */
Suint32_t LL_DMA2D_GetOutputBlueColor(DMA2D_TypeDef *DMA2Dx, uint32_t ColorMode)
S{
S  uint32_t color;
S
S  /* Check the parameters */
S  assert_param(IS_DMA2D_ALL_INSTANCE(DMA2Dx));
S  assert_param(IS_LL_DMA2D_OCMODE(ColorMode));
S
S  /* DMA2D OCOLR register reading ------------------------------------------*/
S  if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB8888)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFFU));
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_RGB888)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFFU));
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_RGB565)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0x1FU));
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB1555)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0x1FU));
S  }
S  else /* ColorMode = LL_DMA2D_OUTPUT_MODE_ARGB4444 */
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFU));
S  }
S
S  return color;
S}
S
S/**
S  * @brief  Return DMA2D output Green color.
S  * @param  DMA2Dx DMA2D Instance.
S  * @param  ColorMode This parameter can be one of the following values:
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB8888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB565
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB1555
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB4444
S  * @retval Output Green color value between Min_Data=0 and Max_Data=0xFF
S  */
Suint32_t LL_DMA2D_GetOutputGreenColor(DMA2D_TypeDef *DMA2Dx, uint32_t ColorMode)
S{
S  uint32_t color;
S
S  /* Check the parameters */
S  assert_param(IS_DMA2D_ALL_INSTANCE(DMA2Dx));
S  assert_param(IS_LL_DMA2D_OCMODE(ColorMode));
S
S  /* DMA2D OCOLR register reading ------------------------------------------*/
S  if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB8888)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFF00U) >> 8U);
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_RGB888)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFF00U) >> 8U);
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_RGB565)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0x7E0U) >> 5U);
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB1555)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0x3E0U) >> 5U);
S  }
S  else /* ColorMode = LL_DMA2D_OUTPUT_MODE_ARGB4444 */
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xF0U) >> 4U);
S  }
S
S  return color;
S}
S
S/**
S  * @brief  Return DMA2D output Red color.
S  * @param  DMA2Dx DMA2D Instance.
S  * @param  ColorMode This parameter can be one of the following values:
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB8888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB565
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB1555
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB4444
S  * @retval Output Red color value between Min_Data=0 and Max_Data=0xFF
S  */
Suint32_t LL_DMA2D_GetOutputRedColor(DMA2D_TypeDef *DMA2Dx, uint32_t ColorMode)
S{
S  uint32_t color;
S
S  /* Check the parameters */
S  assert_param(IS_DMA2D_ALL_INSTANCE(DMA2Dx));
S  assert_param(IS_LL_DMA2D_OCMODE(ColorMode));
S
S  /* DMA2D OCOLR register reading ------------------------------------------*/
S  if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB8888)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFF0000U) >> 16U);
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_RGB888)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFF0000U) >> 16U);
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_RGB565)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xF800U) >> 11U);
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB1555)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0x7C00U) >> 10U);
S  }
S  else /* ColorMode = LL_DMA2D_OUTPUT_MODE_ARGB4444 */
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xF00U) >> 8U);
S  }
S
S  return color;
S}
S
S/**
S  * @brief  Return DMA2D output Alpha color.
S  * @param  DMA2Dx DMA2D Instance.
S  * @param  ColorMode This parameter can be one of the following values:
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB8888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB888
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_RGB565
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB1555
S  *         @arg @ref LL_DMA2D_OUTPUT_MODE_ARGB4444
S  * @retval Output Alpha color value between Min_Data=0 and Max_Data=0xFF
S  */
Suint32_t LL_DMA2D_GetOutputAlphaColor(DMA2D_TypeDef *DMA2Dx, uint32_t ColorMode)
S{
S  uint32_t color;
S
S  /* Check the parameters */
S  assert_param(IS_DMA2D_ALL_INSTANCE(DMA2Dx));
S  assert_param(IS_LL_DMA2D_OCMODE(ColorMode));
S
S  /* DMA2D OCOLR register reading ------------------------------------------*/
S  if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB8888)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xFF000000U) >> 24U);
S  }
S  else if ((ColorMode == LL_DMA2D_OUTPUT_MODE_RGB888) || (ColorMode == LL_DMA2D_OUTPUT_MODE_RGB565))
S  {
S    color = 0x0U;
S  }
S  else if (ColorMode == LL_DMA2D_OUTPUT_MODE_ARGB1555)
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0x8000U) >> 15U);
S  }
S  else /* ColorMode = LL_DMA2D_OUTPUT_MODE_ARGB4444 */
S  {
S    color = (uint32_t)(READ_BIT(DMA2Dx->OCOLR, 0xF000U) >> 12U);
S  }
S
S  return color;
S}
S
S/**
S  * @brief  Configure DMA2D transfer size.
S  * @param  DMA2Dx DMA2D Instance
S  * @param  NbrOfLines Value between Min_Data=0 and Max_Data=0xFFFF
S  * @param  NbrOfPixelsPerLines Value between Min_Data=0 and Max_Data=0x3FFF
S  * @retval None
S  */
Svoid LL_DMA2D_ConfigSize(DMA2D_TypeDef *DMA2Dx, uint32_t NbrOfLines, uint32_t NbrOfPixelsPerLines)
S{
S  MODIFY_REG(DMA2Dx->NLR, (DMA2D_NLR_PL | DMA2D_NLR_NL), \
S             ((NbrOfPixelsPerLines << DMA2D_NLR_PL_Pos) | NbrOfLines));
X  MODIFY_REG(DMA2Dx->NLR, (DMA2D_NLR_PL | DMA2D_NLR_NL),              ((NbrOfPixelsPerLines << DMA2D_NLR_PL_Pos) | NbrOfLines));
S}
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S#endif /* defined (DMA2D) */
S
S/**
S  * @}
S  */
S
N#endif /* USE_FULL_LL_DRIVER */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
