; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_ll_utils.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_ll_utils.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_ll_utils.c]
                          THUMB

                          AREA ||i.LL_Init1msTick||, CODE, READONLY, ALIGN=1

                  LL_Init1msTick PROC
;;;170      */
;;;171    void LL_Init1msTick(uint32_t HCLKFrequency)
000000  f44f717a          MOV      r1,#0x3e8
;;;172    {
;;;173      /* Use frequency provided in argument */
;;;174      LL_InitTick(HCLKFrequency, 1000U);
000004  fbb0f1f1          UDIV     r1,r0,r1
000008  f04f20e0          MOV      r0,#0xe000e000
00000c  1e49              SUBS     r1,r1,#1
00000e  6141              STR      r1,[r0,#0x14]
000010  2100              MOVS     r1,#0
000012  6181              STR      r1,[r0,#0x18]
000014  2105              MOVS     r1,#5
000016  6101              STR      r1,[r0,#0x10]
;;;175    }
000018  4770              BX       lr
;;;176    
                          ENDP


                          AREA ||i.LL_PLL_ConfigSystemClock_HSE||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSE PROC
;;;669      */
;;;670    ErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;671                                             LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;672    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;673      ErrorStatus status;
;;;674      uint32_t pllfreq;
;;;675    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;676        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;677      uint32_t hpre = 0U;  /* Set default value */
;;;678    #endif
;;;679    
;;;680      /* Check the parameters */
;;;681      assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));
;;;682      assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));
;;;683    
;;;684      /* Check if one of the PLL is enabled */
;;;685      if(UTILS_PLL_IsBusy() == SUCCESS)
00000c  f7fffffe          BL       UTILS_PLL_IsBusy
000010  b110              CBZ      r0,|L2.24|
;;;686      {
;;;687        /* Calculate the new PLL output frequency */
;;;688        pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);
;;;689    
;;;690        /* Enable HSE if not enabled */
;;;691        if(LL_RCC_HSE_IsReady() != 1U)
;;;692        {
;;;693          /* Check if need to enable HSE bypass feature or not */
;;;694          if(HSEBypass == LL_UTILS_HSEBYPASS_ON)
;;;695          {
;;;696            LL_RCC_HSE_EnableBypass();
;;;697          }
;;;698          else
;;;699          {
;;;700            LL_RCC_HSE_DisableBypass();
;;;701          }
;;;702    
;;;703          /* Enable HSE */
;;;704          LL_RCC_HSE_Enable();
;;;705          while (LL_RCC_HSE_IsReady() != 1U)
;;;706          {
;;;707            /* Wait for HSE ready */
;;;708          }
;;;709        }
;;;710    
;;;711        /* Configure PLL */
;;;712        LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,
;;;713                                    UTILS_PLLInitStruct->PLLR);
;;;714    
;;;715    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;716        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;717        /* Prevent undershoot at highest frequency by applying intermediate AHB prescaler 2 */
;;;718        if(pllfreq > 80000000U)
;;;719        {
;;;720          if(UTILS_ClkInitStruct->AHBCLKDivider == LL_RCC_SYSCLK_DIV_1)
;;;721          {
;;;722            UTILS_ClkInitStruct->AHBCLKDivider = LL_RCC_SYSCLK_DIV_2;
;;;723            hpre = LL_RCC_SYSCLK_DIV_2;
;;;724          }
;;;725        }
;;;726    #endif
;;;727        /* Enable PLL and switch system clock to PLL */
;;;728        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
;;;729    
;;;730    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;731        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;732        /* Apply definitive AHB prescaler value if necessary */
;;;733        if((status == SUCCESS) && (hpre != LL_RCC_SYSCLK_DIV_1))
;;;734        {
;;;735          /* Set FLASH latency to highest latency */
;;;736          status = LL_SetFlashLatency(pllfreq);
;;;737          if(status == SUCCESS)
;;;738          {
;;;739            UTILS_ClkInitStruct->AHBCLKDivider = LL_RCC_SYSCLK_DIV_1;
;;;740            LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
;;;741            LL_SetSystemCoreClock(pllfreq);
;;;742          }
;;;743        }
;;;744    #endif
;;;745      }
;;;746      else
;;;747      {
;;;748        /* Current PLL configuration cannot be modified */
;;;749        status = ERROR;
000012  2001              MOVS     r0,#1
;;;750      }
;;;751    
;;;752      return status;
;;;753    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L2.24|
000018  4629              MOV      r1,r5                 ;688
00001a  4630              MOV      r0,r6                 ;688
00001c  f7fffffe          BL       UTILS_GetPLLOutputFrequency
000020  4606              MOV      r6,r0                 ;688
000022  4911              LDR      r1,|L2.104|
000024  6808              LDR      r0,[r1,#0]            ;688
000026  f3c04040          UBFX     r0,r0,#17,#1          ;688
00002a  b970              CBNZ     r0,|L2.74|
00002c  2c01              CMP      r4,#1                 ;694
00002e  d016              BEQ      |L2.94|
000030  6808              LDR      r0,[r1,#0]            ;694
000032  f4202080          BIC      r0,r0,#0x40000        ;694
000036  6008              STR      r0,[r1,#0]            ;694
                  |L2.56|
000038  6808              LDR      r0,[r1,#0]            ;694
00003a  f4403080          ORR      r0,r0,#0x10000        ;694
00003e  6008              STR      r0,[r1,#0]            ;694
                  |L2.64|
000040  680c              LDR      r4,[r1,#0]            ;694
000042  f3c44440          UBFX     r4,r4,#17,#1          ;694
000046  2c00              CMP      r4,#0                 ;705
000048  d0fa              BEQ      |L2.64|
                  |L2.74|
00004a  cd0e              LDM      r5!,{r1-r3}           ;712
00004c  2003              MOVS     r0,#3                 ;712
00004e  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
000052  4639              MOV      r1,r7                 ;728
000054  4630              MOV      r0,r6                 ;728
000056  e8bd41f0          POP      {r4-r8,lr}            ;728
00005a  f7ffbffe          B.W      UTILS_EnablePLLAndSwitchSystem
                  |L2.94|
00005e  6808              LDR      r0,[r1,#0]            ;728
000060  f4402080          ORR      r0,r0,#0x40000        ;728
000064  6008              STR      r0,[r1,#0]            ;728
000066  e7e7              B        |L2.56|
;;;754    
                          ENDP

                  |L2.104|
                          DCD      0x40021000

                          AREA ||i.LL_PLL_ConfigSystemClock_HSI||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSI PROC
;;;579      */
;;;580    ErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
000000  b570              PUSH     {r4-r6,lr}
;;;581                                             LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;582    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;583      ErrorStatus status;
;;;584      uint32_t pllfreq;
;;;585    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;586        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;587      uint32_t hpre = LL_RCC_SYSCLK_DIV_1;  /* Set default value */
;;;588    #endif
;;;589    
;;;590      /* Check if one of the PLL is enabled */
;;;591      if(UTILS_PLL_IsBusy() == SUCCESS)
000006  f7fffffe          BL       UTILS_PLL_IsBusy
00000a  b108              CBZ      r0,|L3.16|
;;;592      {
;;;593        /* Calculate the new PLL output frequency */
;;;594        pllfreq = UTILS_GetPLLOutputFrequency(HSI_VALUE, UTILS_PLLInitStruct);
;;;595    
;;;596        /* Enable HSI if not enabled */
;;;597        if(LL_RCC_HSI_IsReady() != 1U)
;;;598        {
;;;599          LL_RCC_HSI_Enable();
;;;600          while (LL_RCC_HSI_IsReady() != 1U)
;;;601          {
;;;602            /* Wait for HSI ready */
;;;603          }
;;;604        }
;;;605    
;;;606        /* Configure PLL */
;;;607        LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,
;;;608                                    UTILS_PLLInitStruct->PLLR);
;;;609    
;;;610    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;611        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;612        /* Prevent undershoot at highest frequency by applying intermediate AHB prescaler 2 */
;;;613        if(pllfreq > 80000000U)
;;;614        {
;;;615          if(UTILS_ClkInitStruct->AHBCLKDivider == LL_RCC_SYSCLK_DIV_1)
;;;616          {
;;;617            UTILS_ClkInitStruct->AHBCLKDivider = LL_RCC_SYSCLK_DIV_2;
;;;618            hpre = LL_RCC_SYSCLK_DIV_2;
;;;619          }
;;;620        }
;;;621    #endif
;;;622        /* Enable PLL and switch system clock to PLL */
;;;623        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
;;;624    
;;;625    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;626        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;627        /* Apply definitive AHB prescaler value if necessary */
;;;628        if((status == SUCCESS) && (hpre != LL_RCC_SYSCLK_DIV_1))
;;;629        {
;;;630          /* Set FLASH latency to highest latency */
;;;631          status = LL_SetFlashLatency(pllfreq);
;;;632          if(status == SUCCESS)
;;;633          {
;;;634            UTILS_ClkInitStruct->AHBCLKDivider = LL_RCC_SYSCLK_DIV_1;
;;;635            LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
;;;636            LL_SetSystemCoreClock(pllfreq);
;;;637          }
;;;638        }
;;;639    #endif
;;;640      }
;;;641      else
;;;642      {
;;;643        /* Current PLL configuration cannot be modified */
;;;644        status = ERROR;
00000c  2001              MOVS     r0,#1
;;;645      }
;;;646    
;;;647      return status;
;;;648    }
00000e  bd70              POP      {r4-r6,pc}
                  |L3.16|
000010  4621              MOV      r1,r4                 ;594
000012  480e              LDR      r0,|L3.76|
000014  f7fffffe          BL       UTILS_GetPLLOutputFrequency
000018  4605              MOV      r5,r0                 ;594
00001a  4a0d              LDR      r2,|L3.80|
00001c  6810              LDR      r0,[r2,#0]            ;594
00001e  f3c02080          UBFX     r0,r0,#10,#1          ;594
000022  b940              CBNZ     r0,|L3.54|
000024  6810              LDR      r0,[r2,#0]            ;597
000026  f4407080          ORR      r0,r0,#0x100          ;597
00002a  6010              STR      r0,[r2,#0]            ;597
                  |L3.44|
00002c  6813              LDR      r3,[r2,#0]            ;597
00002e  f3c32380          UBFX     r3,r3,#10,#1          ;597
000032  2b00              CMP      r3,#0                 ;600
000034  d0fa              BEQ      |L3.44|
                  |L3.54|
000036  cc0e              LDM      r4!,{r1-r3}           ;607
000038  2002              MOVS     r0,#2                 ;607
00003a  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
00003e  4631              MOV      r1,r6                 ;623
000040  4628              MOV      r0,r5                 ;623
000042  e8bd4070          POP      {r4-r6,lr}            ;623
000046  f7ffbffe          B.W      UTILS_EnablePLLAndSwitchSystem
;;;649    
                          ENDP

00004a  0000              DCW      0x0000
                  |L3.76|
                          DCD      0x00f42400
                  |L3.80|
                          DCD      0x40021000

                          AREA ||i.LL_PLL_ConfigSystemClock_MSI||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_MSI PROC
;;;444      */
;;;445    ErrorStatus LL_PLL_ConfigSystemClock_MSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;446                                             LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;447    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;448      ErrorStatus status = SUCCESS;
000008  2400              MOVS     r4,#0
;;;449      uint32_t pllfreq, msi_range;
;;;450    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;451        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;452      uint32_t hpre = 0U;  /* Set default value */
;;;453    #endif
;;;454    
;;;455      /* Check if one of the PLL is enabled */
;;;456      if(UTILS_PLL_IsBusy() == SUCCESS)
00000a  f7fffffe          BL       UTILS_PLL_IsBusy
00000e  b118              CBZ      r0,|L4.24|
;;;457      {
;;;458        /* Get the current MSI range */
;;;459        if(LL_RCC_MSI_IsEnabledRangeSelect() != 0U)
;;;460        {
;;;461          msi_range =  LL_RCC_MSI_GetRange();
;;;462          switch (msi_range)
;;;463          {
;;;464            case LL_RCC_MSIRANGE_0:     /* MSI = 100 KHz  */
;;;465            case LL_RCC_MSIRANGE_1:     /* MSI = 200 KHz  */
;;;466            case LL_RCC_MSIRANGE_2:     /* MSI = 400 KHz  */
;;;467            case LL_RCC_MSIRANGE_3:     /* MSI = 800 KHz  */
;;;468            case LL_RCC_MSIRANGE_4:     /* MSI = 1 MHz    */
;;;469            case LL_RCC_MSIRANGE_5:     /* MSI = 2 MHz    */
;;;470              /* PLLVCO input frequency is not in the range from 4 to 16 MHz*/
;;;471              status = ERROR;
;;;472              break;
;;;473    
;;;474            case LL_RCC_MSIRANGE_6:     /* MSI = 4 MHz    */
;;;475            case LL_RCC_MSIRANGE_7:     /* MSI = 8 MHz    */
;;;476            case LL_RCC_MSIRANGE_8:     /* MSI = 16 MHz   */
;;;477            case LL_RCC_MSIRANGE_9:     /* MSI = 24 MHz   */
;;;478            case LL_RCC_MSIRANGE_10:    /* MSI = 32 MHz   */
;;;479            case LL_RCC_MSIRANGE_11:    /* MSI = 48 MHz   */
;;;480            default:
;;;481              break;
;;;482          }
;;;483        }
;;;484        else
;;;485        {
;;;486          msi_range = LL_RCC_MSI_GetRangeAfterStandby();
;;;487          switch (msi_range)
;;;488          {
;;;489            case LL_RCC_MSISRANGE_4:    /* MSI = 1 MHz    */
;;;490            case LL_RCC_MSISRANGE_5:    /* MSI = 2 MHz    */
;;;491              /* PLLVCO input frequency is not in the range from 4 to 16 MHz*/
;;;492              status = ERROR;
;;;493              break;
;;;494    
;;;495            case LL_RCC_MSISRANGE_7:    /* MSI = 8 MHz    */
;;;496            case LL_RCC_MSISRANGE_6:    /* MSI = 4 MHz    */
;;;497            default:
;;;498              break;
;;;499          }
;;;500        }
;;;501    
;;;502        /* Main PLL configuration and activation */
;;;503        if(status != ERROR)
;;;504        {
;;;505          /* Calculate the new PLL output frequency */
;;;506          pllfreq = UTILS_GetPLLOutputFrequency(__LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(), msi_range),
;;;507                                                UTILS_PLLInitStruct);
;;;508    
;;;509          /* Enable MSI if not enabled */
;;;510          if(LL_RCC_MSI_IsReady() != 1U)
;;;511          {
;;;512            LL_RCC_MSI_Enable();
;;;513            while ((LL_RCC_MSI_IsReady() != 1U))
;;;514            {
;;;515              /* Wait for MSI ready */
;;;516            }
;;;517          }
;;;518    
;;;519          /* Configure PLL */
;;;520          LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_MSI, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,
;;;521                                      UTILS_PLLInitStruct->PLLR);
;;;522    
;;;523    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;524        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;525          /* Prevent undershoot at highest frequency by applying intermediate AHB prescaler 2 */
;;;526          if(pllfreq > 80000000U)
;;;527          {
;;;528            if(UTILS_ClkInitStruct->AHBCLKDivider == LL_RCC_SYSCLK_DIV_1)
;;;529            {
;;;530              UTILS_ClkInitStruct->AHBCLKDivider = LL_RCC_SYSCLK_DIV_2;
;;;531              hpre = LL_RCC_SYSCLK_DIV_2;
;;;532            }
;;;533          }
;;;534    #endif
;;;535          /* Enable PLL and switch system clock to PLL */
;;;536          status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
;;;537    
;;;538    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;539        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;540          /* Apply definitive AHB prescaler value if necessary */
;;;541          if((status == SUCCESS) && (hpre != LL_RCC_SYSCLK_DIV_1))
;;;542          {
;;;543            /* Set FLASH latency to highest latency */
;;;544            status = LL_SetFlashLatency(pllfreq);
;;;545            if(status == SUCCESS)
;;;546            {
;;;547              UTILS_ClkInitStruct->AHBCLKDivider = LL_RCC_SYSCLK_DIV_1;
;;;548              LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
;;;549              LL_SetSystemCoreClock(pllfreq);
;;;550            }
;;;551          }
;;;552    #endif
;;;553        }
;;;554      }
;;;555      else
;;;556      {
;;;557        /* Current PLL configuration cannot be modified */
;;;558        status = ERROR;
000010  2401              MOVS     r4,#1
                  |L4.18|
;;;559      }
;;;560    
;;;561      return status;
000012  4620              MOV      r0,r4
;;;562    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L4.24|
000018  4d22              LDR      r5,|L4.164|
00001a  6828              LDR      r0,[r5,#0]
00001c  f3c000c0          UBFX     r0,r0,#3,#1
000020  b150              CBZ      r0,|L4.56|
000022  6828              LDR      r0,[r5,#0]            ;459
000024  f00000f0          AND      r0,r0,#0xf0           ;459
000028  f0100f0f          TST      r0,#0xf               ;462
00002c  d10f              BNE      |L4.78|
00002e  1101              ASRS     r1,r0,#4              ;462
000030  2905              CMP      r1,#5                 ;462
000032  d80c              BHI      |L4.78|
000034  2401              MOVS     r4,#1                 ;471
000036  e00a              B        |L4.78|
                  |L4.56|
000038  f8d50094          LDR      r0,[r5,#0x94]         ;472
00003c  f4006070          AND      r0,r0,#0xf00          ;472
000040  f5b06f80          CMP      r0,#0x400             ;487
000044  d002              BEQ      |L4.76|
000046  f5b06fa0          CMP      r0,#0x500             ;487
00004a  d100              BNE      |L4.78|
                  |L4.76|
00004c  2401              MOVS     r4,#1                 ;492
                  |L4.78|
00004e  2c01              CMP      r4,#1                 ;503
000050  d0df              BEQ      |L4.18|
000052  6829              LDR      r1,[r5,#0]            ;503
000054  f3c102c0          UBFX     r2,r1,#3,#1           ;503
000058  4913              LDR      r1,|L4.168|
00005a  b15a              CBZ      r2,|L4.116|
00005c  0900              LSRS     r0,r0,#4              ;506
00005e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;506
                  |L4.98|
000062  4631              MOV      r1,r6                 ;506
000064  f7fffffe          BL       UTILS_GetPLLOutputFrequency
000068  4604              MOV      r4,r0                 ;506
00006a  6828              LDR      r0,[r5,#0]            ;506
00006c  f3c00040          UBFX     r0,r0,#1,#1           ;506
000070  b120              CBZ      r0,|L4.124|
000072  e00c              B        |L4.142|
                  |L4.116|
000074  0a00              LSRS     r0,r0,#8              ;506
000076  f8510020          LDR      r0,[r1,r0,LSL #2]     ;506
00007a  e7f2              B        |L4.98|
                  |L4.124|
00007c  6828              LDR      r0,[r5,#0]            ;506
00007e  f0400001          ORR      r0,r0,#1              ;506
000082  6028              STR      r0,[r5,#0]            ;506
                  |L4.132|
000084  6828              LDR      r0,[r5,#0]            ;506
000086  f3c00040          UBFX     r0,r0,#1,#1           ;506
00008a  2800              CMP      r0,#0                 ;513
00008c  d0fa              BEQ      |L4.132|
                  |L4.142|
00008e  ce0e              LDM      r6!,{r1-r3}           ;520
000090  2001              MOVS     r0,#1                 ;520
000092  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
000096  4639              MOV      r1,r7                 ;536
000098  4620              MOV      r0,r4                 ;536
00009a  f7fffffe          BL       UTILS_EnablePLLAndSwitchSystem
00009e  4604              MOV      r4,r0                 ;536
0000a0  e7b7              B        |L4.18|
;;;563    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L4.164|
                          DCD      0x40021000
                  |L4.168|
                          DCD      MSIRangeTable

                          AREA ||i.LL_RCC_PLL_ConfigDomain_SYS||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_ConfigDomain_SYS PROC
;;;3799     */
;;;3800   __STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
000000  4308              ORRS     r0,r0,r1
;;;3801   {
;;;3802     MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLR,
000002  ea402102          ORR      r1,r0,r2,LSL #8
000006  4a04              LDR      r2,|L5.24|
000008  4319              ORRS     r1,r1,r3
00000a  68d0              LDR      r0,[r2,#0xc]
00000c  4b03              LDR      r3,|L5.28|
00000e  4018              ANDS     r0,r0,r3
000010  4301              ORRS     r1,r1,r0
000012  60d1              STR      r1,[r2,#0xc]
;;;3803                Source | PLLM | (PLLN << RCC_PLLCFGR_PLLN_Pos) | PLLR);
;;;3804   }
000014  4770              BX       lr
;;;3805   
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x40021000
                  |L5.28|
                          DCD      0xf9ff808c

                          AREA ||i.LL_SetFlashLatency||, CODE, READONLY, ALIGN=2

                  LL_SetFlashLatency PROC
;;;292      */
;;;293    ErrorStatus LL_SetFlashLatency(uint32_t HCLKFrequency)
000000  2200              MOVS     r2,#0
;;;294    {
;;;295      ErrorStatus status = SUCCESS;
;;;296    
;;;297      uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
000002  2100              MOVS     r1,#0
;;;298    
;;;299      /* Frequency cannot be equal to 0 or greater than max clock */
;;;300      if ((HCLKFrequency == 0U) || (HCLKFrequency > UTILS_MAX_FREQUENCY_SCALE1))
000004  2800              CMP      r0,#0
000006  d002              BEQ      |L6.14|
000008  4b20              LDR      r3,|L6.140|
00000a  4298              CMP      r0,r3
00000c  d901              BLS      |L6.18|
                  |L6.14|
;;;301      {
;;;302        status = ERROR;
00000e  2201              MOVS     r2,#1
000010  e039              B        |L6.134|
                  |L6.18|
000012  4b1f              LDR      r3,|L6.144|
000014  681b              LDR      r3,[r3,#0]
000016  f40363c0          AND      r3,r3,#0x600
;;;303      }
;;;304      else
;;;305      {
;;;306        if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
00001a  f5b37f00          CMP      r3,#0x200
00001e  d004              BEQ      |L6.42|
;;;307        {
;;;308    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;309        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;310          if(HCLKFrequency > UTILS_SCALE1_LATENCY5_FREQ)
;;;311          {
;;;312            /* 100 < HCLK <= 120 => 5WS (6 CPU cycles) */
;;;313            latency = LL_FLASH_LATENCY_5;
;;;314          }
;;;315          else if(HCLKFrequency > UTILS_SCALE1_LATENCY4_FREQ)
;;;316          {
;;;317            /* 80 < HCLK <= 100 => 4WS (5 CPU cycles) */
;;;318            latency = LL_FLASH_LATENCY_4;
;;;319          }
;;;320          else if(HCLKFrequency > UTILS_SCALE1_LATENCY3_FREQ)
;;;321          {
;;;322            /* 60 < HCLK <= 80 => 3WS (4 CPU cycles) */
;;;323            latency = LL_FLASH_LATENCY_3;
;;;324          }
;;;325          else if(HCLKFrequency > UTILS_SCALE1_LATENCY2_FREQ)
;;;326          {
;;;327            /* 40 < HCLK <= 20 => 2WS (3 CPU cycles) */
;;;328            latency = LL_FLASH_LATENCY_2;
;;;329          }
;;;330          else
;;;331          {
;;;332            if(HCLKFrequency > UTILS_SCALE1_LATENCY1_FREQ)
;;;333            {
;;;334              /* 20 < HCLK <= 40 => 1WS (2 CPU cycles) */
;;;335              latency = LL_FLASH_LATENCY_1;
;;;336            }
;;;337            /* else HCLKFrequency <= 10MHz default LL_FLASH_LATENCY_0 0WS */
;;;338          }
;;;339    #else
;;;340          if(HCLKFrequency > UTILS_SCALE1_LATENCY4_FREQ)
;;;341          {
;;;342            /* 64 < HCLK <= 80 => 4WS (5 CPU cycles) */
;;;343            latency = LL_FLASH_LATENCY_4;
;;;344          }
;;;345          else if(HCLKFrequency > UTILS_SCALE1_LATENCY3_FREQ)
;;;346          {
;;;347            /* 48 < HCLK <= 64 => 3WS (4 CPU cycles) */
;;;348            latency = LL_FLASH_LATENCY_3;
;;;349          }
;;;350          else if(HCLKFrequency > UTILS_SCALE1_LATENCY2_FREQ)
;;;351          {
;;;352            /* 32 < HCLK <= 48 => 2WS (3 CPU cycles) */
;;;353            latency = LL_FLASH_LATENCY_2;
;;;354          }
;;;355          else
;;;356          {
;;;357            if(HCLKFrequency > UTILS_SCALE1_LATENCY1_FREQ)
;;;358            {
;;;359              /* 16 < HCLK <= 32 => 1WS (2 CPU cycles) */
;;;360              latency = LL_FLASH_LATENCY_1;
;;;361            }
;;;362            /* else HCLKFrequency <= 16MHz default LL_FLASH_LATENCY_0 0WS */
;;;363          }
;;;364    #endif
;;;365        }
;;;366        else /* SCALE2 */
;;;367        {
;;;368    #if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
;;;369        defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
;;;370          if(HCLKFrequency > UTILS_MAX_FREQUENCY_SCALE2)
;;;371          {
;;;372            /* Unexpected HCLK > 26 */
;;;373            status = ERROR;
;;;374          }
;;;375          else if(HCLKFrequency > UTILS_SCALE2_LATENCY2_FREQ)
;;;376          {
;;;377            /* 16 < HCLK <= 26 => 2WS (3 CPU cycles) */
;;;378            latency = LL_FLASH_LATENCY_2;
;;;379          }
;;;380          else
;;;381          {
;;;382            if(HCLKFrequency > UTILS_SCALE2_LATENCY1_FREQ)
;;;383            {
;;;384              /* 8 < HCLK <= 16 => 1WS (2 CPU cycles) */
;;;385              latency = LL_FLASH_LATENCY_1;
;;;386            }
;;;387            /* else HCLKFrequency <= 8MHz default LL_FLASH_LATENCY_0 0WS */
;;;388          }
;;;389    #else
;;;390          if(HCLKFrequency > UTILS_MAX_FREQUENCY_SCALE2)
000020  4b1c              LDR      r3,|L6.148|
000022  4298              CMP      r0,r3
000024  d915              BLS      |L6.82|
;;;391          {
;;;392            /* Unexpected HCLK > 26 */
;;;393            status = ERROR;
000026  2201              MOVS     r2,#1
000028  e021              B        |L6.110|
                  |L6.42|
00002a  4b1b              LDR      r3,|L6.152|
00002c  4298              CMP      r0,r3                 ;340
00002e  d901              BLS      |L6.52|
000030  2104              MOVS     r1,#4                 ;343
000032  e01c              B        |L6.110|
                  |L6.52|
000034  4b19              LDR      r3,|L6.156|
000036  4298              CMP      r0,r3                 ;345
000038  d901              BLS      |L6.62|
00003a  2103              MOVS     r1,#3                 ;348
00003c  e017              B        |L6.110|
                  |L6.62|
00003e  4b18              LDR      r3,|L6.160|
000040  4298              CMP      r0,r3                 ;350
000042  d901              BLS      |L6.72|
000044  2102              MOVS     r1,#2                 ;353
000046  e012              B        |L6.110|
                  |L6.72|
000048  4b16              LDR      r3,|L6.164|
00004a  4298              CMP      r0,r3                 ;357
00004c  d90f              BLS      |L6.110|
00004e  2101              MOVS     r1,#1                 ;360
000050  e00d              B        |L6.110|
                  |L6.82|
;;;394          }
;;;395          else if(HCLKFrequency > UTILS_SCALE2_LATENCY3_FREQ)
000052  4b15              LDR      r3,|L6.168|
000054  4298              CMP      r0,r3
000056  d901              BLS      |L6.92|
;;;396          {
;;;397            /* 18 < HCLK <= 26 => 3WS (4 CPU cycles) */
;;;398            latency = LL_FLASH_LATENCY_3;
000058  2103              MOVS     r1,#3
00005a  e008              B        |L6.110|
                  |L6.92|
;;;399          }
;;;400          else if(HCLKFrequency > UTILS_SCALE2_LATENCY2_FREQ)
00005c  4b13              LDR      r3,|L6.172|
00005e  4298              CMP      r0,r3
000060  d901              BLS      |L6.102|
;;;401          {
;;;402            /* 12 < HCLK <= 18 => 2WS (3 CPU cycles) */
;;;403            latency = LL_FLASH_LATENCY_2;
000062  2102              MOVS     r1,#2
000064  e003              B        |L6.110|
                  |L6.102|
;;;404          }
;;;405          else
;;;406          {
;;;407            if(HCLKFrequency > UTILS_SCALE2_LATENCY1_FREQ)
000066  4b12              LDR      r3,|L6.176|
000068  4298              CMP      r0,r3
00006a  d900              BLS      |L6.110|
;;;408            {
;;;409              /* 6 < HCLK <= 12 => 1WS (2 CPU cycles) */
;;;410              latency = LL_FLASH_LATENCY_1;
00006c  2101              MOVS     r1,#1
                  |L6.110|
00006e  4811              LDR      r0,|L6.180|
000070  6803              LDR      r3,[r0,#0]
000072  f0230307          BIC      r3,r3,#7
000076  430b              ORRS     r3,r3,r1
000078  6003              STR      r3,[r0,#0]
00007a  6800              LDR      r0,[r0,#0]
00007c  f0000007          AND      r0,r0,#7
;;;411            }
;;;412            /* else HCLKFrequency <= 6MHz default LL_FLASH_LATENCY_0 0WS */
;;;413          }
;;;414    #endif
;;;415        }
;;;416    
;;;417        LL_FLASH_SetLatency(latency);
;;;418    
;;;419        /* Check that the new number of wait states is taken into account to access the Flash
;;;420           memory by reading the FLASH_ACR register */
;;;421        if(LL_FLASH_GetLatency() != latency)
000080  4288              CMP      r0,r1
000082  d000              BEQ      |L6.134|
;;;422        {
;;;423          status = ERROR;
000084  2201              MOVS     r2,#1
                  |L6.134|
;;;424        }
;;;425      }
;;;426      return status;
000086  4610              MOV      r0,r2
;;;427    }
000088  4770              BX       lr
;;;428    
                          ENDP

00008a  0000              DCW      0x0000
                  |L6.140|
                          DCD      0x04c4b400
                  |L6.144|
                          DCD      0x40007000
                  |L6.148|
                          DCD      0x018cba80
                  |L6.152|
                          DCD      0x03d09000
                  |L6.156|
                          DCD      0x02dc6c00
                  |L6.160|
                          DCD      0x01e84800
                  |L6.164|
                          DCD      0x00f42400
                  |L6.168|
                          DCD      0x0112a880
                  |L6.172|
                          DCD      0x00b71b00
                  |L6.176|
                          DCD      0x005b8d80
                  |L6.180|
                          DCD      0x40022000

                          AREA ||i.LL_SetSystemCoreClock||, CODE, READONLY, ALIGN=2

                  LL_SetSystemCoreClock PROC
;;;278      */
;;;279    void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
000000  4901              LDR      r1,|L7.8|
;;;280    {
;;;281      /* HCLK clock frequency */
;;;282      SystemCoreClock = HCLKFrequency;
000002  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;283    }
000004  4770              BX       lr
;;;284    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.LL_mDelay||, CODE, READONLY, ALIGN=1

                  LL_mDelay PROC
;;;186      */
;;;187    void LL_mDelay(uint32_t Delay)
000000  b508              PUSH     {r3,lr}
;;;188    {
;;;189      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
000002  f04f21e0          MOV      r1,#0xe000e000
000006  690a              LDR      r2,[r1,#0x10]
000008  9200              STR      r2,[sp,#0]
;;;190      uint32_t tmpDelay = Delay;
;;;191    
;;;192      /* Add this code to indicate that local variable is not used */
;;;193      ((void)tmp);
;;;194    
;;;195      /* Add a period to guaranty minimum wait */
;;;196      if(tmpDelay < LL_MAX_DELAY)
00000a  1c42              ADDS     r2,r0,#1
00000c  d005              BEQ      |L8.26|
;;;197      {
;;;198        tmpDelay++;
00000e  1c40              ADDS     r0,r0,#1
000010  e003              B        |L8.26|
                  |L8.18|
;;;199      }
;;;200    
;;;201      while (tmpDelay != 0U)
;;;202      {
;;;203        if((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
000012  690a              LDR      r2,[r1,#0x10]
000014  03d2              LSLS     r2,r2,#15
000016  d500              BPL      |L8.26|
;;;204        {
;;;205          tmpDelay--;
000018  1e40              SUBS     r0,r0,#1
                  |L8.26|
00001a  2800              CMP      r0,#0                 ;201
00001c  d1f9              BNE      |L8.18|
;;;206        }
;;;207      }
;;;208    }
00001e  bd08              POP      {r3,pc}
;;;209    
                          ENDP


                          AREA ||i.UTILS_EnablePLLAndSwitchSystem||, CODE, READONLY, ALIGN=2

                  UTILS_EnablePLLAndSwitchSystem PROC
;;;844      */
;;;845    static ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;846    {
000002  460c              MOV      r4,r1
;;;847      ErrorStatus status = SUCCESS;
000004  2200              MOVS     r2,#0
;;;848      uint32_t hclk_frequency;
;;;849    
;;;850      assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));
;;;851      assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));
;;;852      assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));
;;;853    
;;;854      /* Calculate HCLK frequency */
;;;855      hclk_frequency = __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);
000006  7821              LDRB     r1,[r4,#0]
000008  4b22              LDR      r3,|L9.148|
00000a  f3c11103          UBFX     r1,r1,#4,#4
00000e  5c59              LDRB     r1,[r3,r1]
000010  fa20f501          LSR      r5,r0,r1
;;;856    
;;;857      /* Increasing the number of wait states because of higher CPU frequency */
;;;858      if(SystemCoreClock < hclk_frequency)
000014  4e20              LDR      r6,|L9.152|
000016  6830              LDR      r0,[r6,#0]  ; SystemCoreClock
000018  42a8              CMP      r0,r5
00001a  d203              BCS      |L9.36|
;;;859      {
;;;860        /* Set FLASH latency to highest latency */
;;;861        status = LL_SetFlashLatency(hclk_frequency);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       LL_SetFlashLatency
000022  4602              MOV      r2,r0
                  |L9.36|
;;;862      }
;;;863    
;;;864      /* Update system clock configuration */
;;;865      if(status == SUCCESS)
000024  bb42              CBNZ     r2,|L9.120|
000026  481d              LDR      r0,|L9.156|
000028  6801              LDR      r1,[r0,#0]
00002a  f0417180          ORR      r1,r1,#0x1000000
00002e  6001              STR      r1,[r0,#0]
000030  68c1              LDR      r1,[r0,#0xc]
000032  f0417180          ORR      r1,r1,#0x1000000
000036  60c1              STR      r1,[r0,#0xc]
                  |L9.56|
000038  6801              LDR      r1,[r0,#0]
00003a  f3c16140          UBFX     r1,r1,#25,#1
;;;866      {
;;;867        /* Enable PLL */
;;;868        LL_RCC_PLL_Enable();
;;;869        LL_RCC_PLL_EnableDomain_SYS();
;;;870        while (LL_RCC_PLL_IsReady() != 1U)
00003e  2900              CMP      r1,#0
000040  d0fa              BEQ      |L9.56|
;;;871        {
;;;872          /* Wait for PLL ready */
;;;873        }
;;;874    
;;;875        /* Sysclk activation on the main PLL */
;;;876        LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
000042  6821              LDR      r1,[r4,#0]
000044  6883              LDR      r3,[r0,#8]
000046  f02303f0          BIC      r3,r3,#0xf0
00004a  430b              ORRS     r3,r3,r1
00004c  6083              STR      r3,[r0,#8]
00004e  6881              LDR      r1,[r0,#8]
000050  f0410103          ORR      r1,r1,#3
000054  6081              STR      r1,[r0,#8]
                  |L9.86|
000056  6881              LDR      r1,[r0,#8]
000058  f001010c          AND      r1,r1,#0xc
;;;877        LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
;;;878        while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
00005c  290c              CMP      r1,#0xc
00005e  d1fa              BNE      |L9.86|
;;;879        {
;;;880          /* Wait for system clock switch to PLL */
;;;881        }
;;;882    
;;;883        /* Set APB1 & APB2 prescaler*/
;;;884        LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);
000060  6861              LDR      r1,[r4,#4]
000062  6883              LDR      r3,[r0,#8]
000064  f42363e0          BIC      r3,r3,#0x700
000068  430b              ORRS     r3,r3,r1
00006a  6083              STR      r3,[r0,#8]
;;;885        LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);
00006c  68a1              LDR      r1,[r4,#8]
00006e  6883              LDR      r3,[r0,#8]
000070  f4235360          BIC      r3,r3,#0x3800
000074  430b              ORRS     r3,r3,r1
000076  6083              STR      r3,[r0,#8]
                  |L9.120|
;;;886      }
;;;887    
;;;888      /* Decreasing the number of wait states because of lower CPU frequency */
;;;889      if(SystemCoreClock > hclk_frequency)
000078  6830              LDR      r0,[r6,#0]  ; SystemCoreClock
00007a  42a8              CMP      r0,r5
00007c  d903              BLS      |L9.134|
;;;890      {
;;;891        /* Set FLASH latency to lowest latency */
;;;892        status = LL_SetFlashLatency(hclk_frequency);
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       LL_SetFlashLatency
000084  4602              MOV      r2,r0
                  |L9.134|
;;;893      }
;;;894    
;;;895      /* Update SystemCoreClock variable */
;;;896      if(status == SUCCESS)
000086  b912              CBNZ     r2,|L9.142|
;;;897      {
;;;898        LL_SetSystemCoreClock(hclk_frequency);
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       LL_SetSystemCoreClock
                  |L9.142|
;;;899      }
;;;900    
;;;901      return status;
00008e  4610              MOV      r0,r2
;;;902    }
000090  bd70              POP      {r4-r6,pc}
;;;903    
                          ENDP

000092  0000              DCW      0x0000
                  |L9.148|
                          DCD      AHBPrescTable
                  |L9.152|
                          DCD      SystemCoreClock
                  |L9.156|
                          DCD      0x40021000

                          AREA ||i.UTILS_GetPLLOutputFrequency||, CODE, READONLY, ALIGN=1

                  UTILS_GetPLLOutputFrequency PROC
;;;772      */
;;;773    static uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)
000000  680a              LDR      r2,[r1,#0]
;;;774    {
;;;775      uint32_t pllfreq;
;;;776    
;;;777      /* Check the parameters */
;;;778      assert_param(IS_LL_UTILS_PLLM_VALUE(UTILS_PLLInitStruct->PLLM));
;;;779      assert_param(IS_LL_UTILS_PLLN_VALUE(UTILS_PLLInitStruct->PLLN));
;;;780      assert_param(IS_LL_UTILS_PLLR_VALUE(UTILS_PLLInitStruct->PLLR));
;;;781    
;;;782      /* Check different PLL parameters according to RM                          */
;;;783      /*  - PLLM: ensure that the VCO input frequency ranges from 4 to 16 MHz.   */
;;;784      pllfreq = PLL_InputFrequency / (((UTILS_PLLInitStruct->PLLM >> RCC_PLLCFGR_PLLM_Pos) + 1U));
000002  2301              MOVS     r3,#1
000004  eb031212          ADD      r2,r3,r2,LSR #4
000008  fbb0f2f2          UDIV     r2,r0,r2
;;;785      assert_param(IS_LL_UTILS_PLLVCO_INPUT(pllfreq));
;;;786    
;;;787      /*  - PLLN: ensure that the VCO output frequency is between 64 and 344 MHz.*/
;;;788      pllfreq = pllfreq * (UTILS_PLLInitStruct->PLLN & (RCC_PLLCFGR_PLLN >> RCC_PLLCFGR_PLLN_Pos));
00000c  7908              LDRB     r0,[r1,#4]
00000e  f000007f          AND      r0,r0,#0x7f
000012  4350              MULS     r0,r2,r0
;;;789      assert_param(IS_LL_UTILS_PLLVCO_OUTPUT(pllfreq));
;;;790    
;;;791      /*  - PLLR: ensure that max frequency at 120000000 Hz is reached                   */
;;;792      pllfreq = pllfreq / (((UTILS_PLLInitStruct->PLLR >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U);
000014  6889              LDR      r1,[r1,#8]
000016  eb036151          ADD      r1,r3,r1,LSR #25
00001a  0049              LSLS     r1,r1,#1
00001c  fbb0f0f1          UDIV     r0,r0,r1
;;;793      assert_param(IS_LL_UTILS_PLL_FREQUENCY(pllfreq));
;;;794    
;;;795      return pllfreq;
;;;796    }
000020  4770              BX       lr
;;;797    
                          ENDP


                          AREA ||i.UTILS_PLL_IsBusy||, CODE, READONLY, ALIGN=2

                  UTILS_PLL_IsBusy PROC
;;;803      */
;;;804    static ErrorStatus UTILS_PLL_IsBusy(void)
000000  2000              MOVS     r0,#0
000002  4909              LDR      r1,|L11.40|
000004  680a              LDR      r2,[r1,#0]
000006  f3c26240          UBFX     r2,r2,#25,#1
;;;805    {
;;;806      ErrorStatus status = SUCCESS;
;;;807    
;;;808      /* Check if PLL is busy*/
;;;809      if(LL_RCC_PLL_IsReady() != 0U)
00000a  2a00              CMP      r2,#0
00000c  d000              BEQ      |L11.16|
;;;810      {
;;;811        /* PLL configuration cannot be modified */
;;;812        status = ERROR;
00000e  2001              MOVS     r0,#1
                  |L11.16|
000010  680a              LDR      r2,[r1,#0]
000012  f3c262c0          UBFX     r2,r2,#27,#1
;;;813      }
;;;814    
;;;815    #if defined(RCC_PLLSAI1_SUPPORT)
;;;816      /* Check if PLLSAI1 is busy*/
;;;817      if(LL_RCC_PLLSAI1_IsReady() != 0U)
000016  b102              CBZ      r2,|L11.26|
;;;818      {
;;;819        /* PLLSAI1 configuration cannot be modified */
;;;820        status = ERROR;
000018  2001              MOVS     r0,#1
                  |L11.26|
00001a  6809              LDR      r1,[r1,#0]
00001c  f3c17140          UBFX     r1,r1,#29,#1
;;;821      }
;;;822    #endif /*RCC_PLLSAI1_SUPPORT*/
;;;823    #if defined(RCC_PLLSAI2_SUPPORT)
;;;824    
;;;825      /* Check if PLLSAI2 is busy*/
;;;826      if(LL_RCC_PLLSAI2_IsReady() != 0U)
000020  2900              CMP      r1,#0
000022  d000              BEQ      |L11.38|
;;;827      {
;;;828        /* PLLSAI2 configuration cannot be modified */
;;;829        status = ERROR;
000024  2001              MOVS     r0,#1
                  |L11.38|
;;;830      }
;;;831    #endif /*RCC_PLLSAI2_SUPPORT*/
;;;832    
;;;833      return status;
;;;834    }
000026  4770              BX       lr
;;;835    
                          ENDP

                  |L11.40|
                          DCD      0x40021000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_ll_utils.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_ll_utils_c_fa0b8999____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32l4xx_ll_utils_c_fa0b8999____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_ll_utils_c_fa0b8999____REVSH|
#line 507
|__asm___20_stm32l4xx_ll_utils_c_fa0b8999____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32l4xx_ll_utils_c_fa0b8999____RRX|
#line 694
|__asm___20_stm32l4xx_ll_utils_c_fa0b8999____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
