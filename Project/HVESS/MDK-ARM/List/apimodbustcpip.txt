; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\apimodbustcpip.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\apimodbustcpip.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\API\ApiModbusTCPIP.c]
                          THUMB

                          AREA ||i.ByteToWord||, CODE, READONLY, ALIGN=1

                  ByteToWord PROC
;;;98     /********** Byte Word Convert **********/
;;;99     uint16_t ByteToWord(uint8_t highbyte,uint8_t lowbyte){
000000  eb012000          ADD      r0,r1,r0,LSL #8
;;;100    	uint16_t ret;
;;;101    	ret = ((((uint16_t)highbyte)<<8)&0xFF00) + ((uint16_t)lowbyte&0x00FF);
000004  b280              UXTH     r0,r0
;;;102    	return ret;
;;;103    }
000006  4770              BX       lr
;;;104    
                          ENDP


                          AREA ||i.ModbusTCPIP_Func_ReadHoldReg||, CODE, READONLY, ALIGN=2

                  ModbusTCPIP_Func_ReadHoldReg PROC
;;;211    ******************************************************************************/
;;;212    uint8_t ModbusTCPIP_Func_ReadHoldReg( uint16_t xu16StartRegAddr, uint16_t xu16ReadRegCnt, W5500_Socket_parm Socket){
000000  b40f              PUSH     {r0-r3}
;;;213    	uint8_t *TempDataPtr;
;;;214    	uint16_t lu16ByteCnt,lu16EndRegAddr,i;
;;;215    	/* lu16EndRegAddr = BMS info size + SCU info size */
;;;216    	lu16EndRegAddr = 0x40; //For test
;;;217    	/* Check ask addr and length wheather over max Len */
;;;218    	if(xu16ReadRegCnt > MODBUS_TCPIP_READ_WRITE_MAXWORDCNT){
000002  297f              CMP      r1,#0x7f
000004  d902              BLS      |L2.12|
;;;219    		return Illegal_DataValue;
000006  2003              MOVS     r0,#3
                  |L2.8|
;;;220    	}else if((xu16StartRegAddr+xu16ReadRegCnt)>lu16EndRegAddr){
;;;221    		return Illegal_DataAddr;
;;;222    	}else{
;;;223    	/* Fill response data frame */	
;;;224    		lu16ByteCnt = xu16ReadRegCnt*2;
;;;225    		TempDataPtr = Socket.Memory.tx_buf_Ptr + READ_HOLDING_REG_RES_BYTECNT_OFFSET;
;;;226    		*TempDataPtr = (uint8_t)lu16ByteCnt;
;;;227    		/* Copy data from mapping memory */
;;;228    		TempDataPtr = Socket.Memory.tx_buf_Ptr + READ_HOLDING_REG_RES_DATA_OFFSET;   
;;;229    		for(i = 0; i<lu16ByteCnt; i++){
;;;230    			*(TempDataPtr+i) = 0;  // Should be change to mapping memory array e.g. : Data[xu16StartRegAddr+i]
;;;231    		}	
;;;232    	}
;;;233    	ResponseLength = lu16ByteCnt+READ_HOLDING_REG_RES_HEADER_LEN;
;;;234    	return Normal;
;;;235    }
000008  b004              ADD      sp,sp,#0x10
00000a  4770              BX       lr
                  |L2.12|
00000c  4408              ADD      r0,r0,r1              ;220
00000e  2840              CMP      r0,#0x40              ;220
000010  d901              BLS      |L2.22|
000012  2002              MOVS     r0,#2                 ;221
000014  e7f8              B        |L2.8|
                  |L2.22|
000016  f64f70ff          MOV      r0,#0xffff            ;224
00001a  ea000141          AND      r1,r0,r1,LSL #1       ;224
00001e  9806              LDR      r0,[sp,#0x18]         ;225
000020  7201              STRB     r1,[r0,#8]            ;226
000022  9a06              LDR      r2,[sp,#0x18]         ;228
000024  3209              ADDS     r2,r2,#9              ;228
000026  2000              MOVS     r0,#0                 ;229
000028  2300              MOVS     r3,#0                 ;229
00002a  e002              B        |L2.50|
                  |L2.44|
00002c  5413              STRB     r3,[r2,r0]            ;230
00002e  1c40              ADDS     r0,r0,#1              ;229
000030  b280              UXTH     r0,r0                 ;229
                  |L2.50|
000032  4288              CMP      r0,r1                 ;229
000034  d3fa              BCC      |L2.44|
000036  4802              LDR      r0,|L2.64|
000038  1cc9              ADDS     r1,r1,#3              ;233
00003a  7001              STRB     r1,[r0,#0]            ;233
00003c  2000              MOVS     r0,#0                 ;234
00003e  e7e3              B        |L2.8|
;;;236      
                          ENDP

                  |L2.64|
                          DCD      ||.data||

                          AREA ||i.ModbusTCPIP_Func_WriteMultiReg||, CODE, READONLY, ALIGN=2

                  ModbusTCPIP_Func_WriteMultiReg PROC
;;;247    ******************************************************************************/
;;;248    uint8_t ModbusTCPIP_Func_WriteMultiReg(uint16_t xu16StartRegAddr, uint16_t xu16WriteRegCnt, W5500_Socket_parm Socket){
000000  b40f              PUSH     {r0-r3}
;;;249    	uint8_t *TempDataPtr, lu8ByteCnt;
;;;250    
;;;251    	/* Get write byte Count from client command */
;;;252    	TempDataPtr = Socket.Memory.rx_buf_Ptr + WRITE_MULTIPLE_REGISTER_BYTECNT_OFFSET;
000002  9a04              LDR      r2,[sp,#0x10]
;;;253    	lu8ByteCnt = *TempDataPtr;
000004  7b12              LDRB     r2,[r2,#0xc]
;;;254    	
;;;255    	//SEGGER_RTT_printf(0,"Write Reg Cnt: %d  Byte Cnt %d\r\n",xu16WriteRegCnt,lu8ByteCnt);
;;;256    	if((xu16WriteRegCnt > MODBUS_TCPIP_READ_WRITE_MAXWORDCNT)||(xu16WriteRegCnt == 0)||((xu16WriteRegCnt*2) != (uint16_t)lu8ByteCnt)){
000006  297f              CMP      r1,#0x7f
000008  d803              BHI      |L3.18|
00000a  b111              CBZ      r1,|L3.18|
00000c  ebb20f41          CMP      r2,r1,LSL #1
000010  d002              BEQ      |L3.24|
                  |L3.18|
;;;257    		return Illegal_DataValue;
000012  2003              MOVS     r0,#3
                  |L3.20|
;;;258    	}else{
;;;259    		switch( xu16StartRegAddr){
;;;260    		case TEST_REG_ADDR:
;;;261    			// Data pointer start at TempDataPtr = Socket_ModbusTCPIP.buffers.tx_buf + WRITE_MULTIPLE_REGISTER_DATA_OFFSET;
;;;262    			break;
;;;263    		default:
;;;264    			return Illegal_DataAddr;
;;;265    			break;
;;;266    		}
;;;267    	}
;;;268    	ResponseLength = WRITE_MULTIPLE_REGISTER_RES_LEN;
;;;269    	return Normal;
;;;270    	
;;;271    }
000014  b004              ADD      sp,sp,#0x10
000016  4770              BX       lr
                  |L3.24|
000018  b108              CBZ      r0,|L3.30|
00001a  2002              MOVS     r0,#2                 ;264
00001c  e7fa              B        |L3.20|
                  |L3.30|
00001e  4902              LDR      r1,|L3.40|
000020  2006              MOVS     r0,#6                 ;268
000022  7008              STRB     r0,[r1,#0]            ;268
000024  2000              MOVS     r0,#0                 ;269
000026  e7f5              B        |L3.20|
;;;272    
                          ENDP

                  |L3.40|
                          DCD      ||.data||

                          AREA ||i.ModbusTCPIP_cb||, CODE, READONLY, ALIGN=2

                  ModbusTCPIP_cb PROC
;;;61     ******************************************************************************/
;;;62     uint16_t ModbusTCPIP_cb(W5500_cb_type p_evt, uint16_t DataLen){
000000  b51f              PUSH     {r0-r4,lr}
;;;63     	switch(p_evt){
000002  2800              CMP      r0,#0
000004  d002              BEQ      |L4.12|
;;;64     		case W5500_DATA_RECV:
;;;65     			return Modbus_TCPIP_Parser(Socket_ModbusTCPIP,DataLen);
;;;66     			break;
;;;67     		case W5500_Socket_REG_Success:
;;;68     			break;
;;;69     		case W5500_COMMUNICATE_ERR:
;;;70     			break;
;;;71     	}
;;;72     	return 0;
000006  2000              MOVS     r0,#0
                  |L4.8|
;;;73     }					
000008  b004              ADD      sp,sp,#0x10
00000a  bd10              POP      {r4,pc}
                  |L4.12|
00000c  4805              LDR      r0,|L4.36|
00000e  9103              STR      r1,[sp,#0xc]          ;65
000010  e9d02306          LDRD     r2,r3,[r0,#0x18]      ;65
000014  6941              LDR      r1,[r0,#0x14]         ;65  ; Socket_ModbusTCPIP
000016  1d00              ADDS     r0,r0,#4              ;65
000018  e88d000e          STM      sp,{r1-r3}            ;65
00001c  c80f              LDM      r0,{r0-r3}            ;65
00001e  f7fffffe          BL       Modbus_TCPIP_Parser
000022  e7f1              B        |L4.8|
;;;74     uint16_t ModbusTest1(W5500_cb_type p_evt, uint16_t DataLen){
                          ENDP

                  |L4.36|
                          DCD      ||.data||

                          AREA ||i.ModbusTest1||, CODE, READONLY, ALIGN=2

                  ModbusTest1 PROC
;;;73     }					
;;;74     uint16_t ModbusTest1(W5500_cb_type p_evt, uint16_t DataLen){
000000  b51f              PUSH     {r0-r4,lr}
;;;75     	switch(p_evt){
000002  2800              CMP      r0,#0
000004  d002              BEQ      |L5.12|
;;;76     		case W5500_DATA_RECV:
;;;77     			return Modbus_TCPIP_Parser(Socket_Test1,DataLen);
;;;78     			break;
;;;79     		case W5500_Socket_REG_Success:
;;;80     			break;
;;;81     		case W5500_COMMUNICATE_ERR:
;;;82     			break;
;;;83     	}
;;;84     	return 0;
000006  2000              MOVS     r0,#0
                  |L5.8|
;;;85     }					
000008  b004              ADD      sp,sp,#0x10
00000a  bd10              POP      {r4,pc}
                  |L5.12|
00000c  4805              LDR      r0,|L5.36|
00000e  9103              STR      r1,[sp,#0xc]          ;77
000010  e9d0230d          LDRD     r2,r3,[r0,#0x34]      ;77
000014  6b01              LDR      r1,[r0,#0x30]         ;77  ; Socket_Test1
000016  3020              ADDS     r0,r0,#0x20           ;77
000018  e88d000e          STM      sp,{r1-r3}            ;77
00001c  c80f              LDM      r0,{r0-r3}            ;77
00001e  f7fffffe          BL       Modbus_TCPIP_Parser
000022  e7f1              B        |L5.8|
;;;86     uint16_t ModbusTest2(W5500_cb_type p_evt, uint16_t DataLen){
                          ENDP

                  |L5.36|
                          DCD      ||.data||

                          AREA ||i.ModbusTest2||, CODE, READONLY, ALIGN=2

                  ModbusTest2 PROC
;;;85     }					
;;;86     uint16_t ModbusTest2(W5500_cb_type p_evt, uint16_t DataLen){
000000  b51f              PUSH     {r0-r4,lr}
;;;87     	switch(p_evt){
000002  2800              CMP      r0,#0
000004  d002              BEQ      |L6.12|
;;;88     		case W5500_DATA_RECV:
;;;89     			return Modbus_TCPIP_Parser(Socket_Test2,DataLen);
;;;90     			break;
;;;91     		case W5500_Socket_REG_Success:
;;;92     			break;
;;;93     		case W5500_COMMUNICATE_ERR:
;;;94     			break;
;;;95     	}
;;;96     	return 0;
000006  2000              MOVS     r0,#0
                  |L6.8|
;;;97     }	
000008  b004              ADD      sp,sp,#0x10
00000a  bd10              POP      {r4,pc}
                  |L6.12|
00000c  4805              LDR      r0,|L6.36|
00000e  9103              STR      r1,[sp,#0xc]          ;89
000010  e9d02314          LDRD     r2,r3,[r0,#0x50]      ;89
000014  6cc1              LDR      r1,[r0,#0x4c]         ;89  ; Socket_Test2
000016  303c              ADDS     r0,r0,#0x3c           ;89
000018  e88d000e          STM      sp,{r1-r3}            ;89
00001c  c80f              LDM      r0,{r0-r3}            ;89
00001e  f7fffffe          BL       Modbus_TCPIP_Parser
000022  e7f1              B        |L6.8|
;;;98     /********** Byte Word Convert **********/
                          ENDP

                  |L6.36|
                          DCD      ||.data||

                          AREA ||i.Modbus_TCPIP_Parser||, CODE, READONLY, ALIGN=2

                  Modbus_TCPIP_Parser PROC
;;;126    
;;;127    uint16_t Modbus_TCPIP_Parser(W5500_Socket_parm Socket, uint16_t DataLen){
000000  b40f              PUSH     {r0-r3}
000002  b570              PUSH     {r4-r6,lr}
000004  b086              SUB      sp,sp,#0x18
000006  9b11              LDR      r3,[sp,#0x44]
;;;128    	uint8_t *TempDataPtr,lu8ExceptionCode = Normal;
000008  2200              MOVS     r2,#0
;;;129    	uint16_t lu16FunctionCode,lu16StartRegAddr, lu16RegCnt;
;;;130    	
;;;131    	/* Offset to Protocal byte offset */
;;;132    	TempDataPtr = Socket.Memory.rx_buf_Ptr + MODBUS_TCPIP_PROTOCOLID_OFFSET;
00000a  980c              LDR      r0,[sp,#0x30]
;;;133    	/* Confirm receive data frame protocal is TCP/IP */
;;;134    	if(ByteToWord(*TempDataPtr,*(TempDataPtr+1))!= MODBUS_TCPIP_PROTOCOLID){
00000c  78c1              LDRB     r1,[r0,#3]
00000e  7880              LDRB     r0,[r0,#2]
000010  f7fffffe          BL       ByteToWord
;;;135    		//SEGGER_RTT_printf(0,"Protocol ID not TCPIP, recv %x \r\n",ByteToWord(*TempDataPtr,*(TempDataPtr+1)));
;;;136    		lu8ExceptionCode = Gateway_Target_ResponseFail;
;;;137    	}else{
;;;138    		/* Check message length  */
;;;139    		TempDataPtr = Socket.Memory.rx_buf_Ptr + MODBUS_TCPIP_MASSAGELEN_OFFSET;
;;;140    		if(ByteToWord(*TempDataPtr,*(TempDataPtr+1))!= (DataLen-MODBUS_TCPIP_HEADER_LEN)){
;;;141    			lu8ExceptionCode = Illegal_DataValue;
;;;142    		}
;;;143    		/* Confirm Unit ID byte */
;;;144    		TempDataPtr = Socket.Memory.rx_buf_Ptr + MODBUS_TCPIP_UNITID_OFFSET;
;;;145    		if(*TempDataPtr != Socket.DeviceID ){
;;;146    			lu8ExceptionCode = Gateway_Target_ResponseFail;
;;;147    		}	
;;;148    		if(lu8ExceptionCode == Normal){
;;;149    			/* According to function code, response data or overwrite valaue at register */
;;;150    			TempDataPtr = Socket.Memory.rx_buf_Ptr + MODBUS_TCPIP_PDU_OFFSET;
;;;151    			lu16FunctionCode = *TempDataPtr;
;;;152    			lu16StartRegAddr = ByteToWord(*(TempDataPtr+1),*(TempDataPtr+2));
;;;153    			lu16RegCnt = ByteToWord(*(TempDataPtr+3),*(TempDataPtr+4));
;;;154    			//SEGGER_RTT_printf(0,"Function code : %d  Start addr: %d  RegCnt : %d\r\n",lu16FunctionCode, lu16StartRegAddr, lu16RegCnt);
;;;155    			//SEGGER_RTT_printf(0,"Socket Num : %d\r\n",Socket.Num);
;;;156    			switch(lu16FunctionCode){
;;;157    				case READ_HOLDING_REG:
;;;158    					lu8ExceptionCode = ModbusTCPIP_Func_ReadHoldReg(lu16StartRegAddr, lu16RegCnt, Socket);
;;;159    					break;
;;;160    				case PRESEET_MULTIPLE_REG:
;;;161    					lu8ExceptionCode =  ModbusTCPIP_Func_WriteMultiReg(lu16StartRegAddr, lu16RegCnt, Socket);
;;;162    					break;
;;;163    				default:
;;;164    					lu8ExceptionCode = Illegal_Function;
;;;165    					break;
;;;166    			}
;;;167    		}
;;;168    		/********** Fill response data frame (Trans ID, Protocol ID, and Unit ID are as same as recv data) **********/
;;;169    		
;;;170    		/* Handdle Exception response data */
;;;171    		if(lu8ExceptionCode != Normal){
;;;172    			/* Set response massage length */
;;;173    			TempDataPtr = Socket.Memory.tx_buf_Ptr + MODBUS_TCPIP_MASSAGELEN_OFFSET;
;;;174    			*TempDataPtr = WordToByte(MODBUS_TCPIP_EXCEPTION_RES_LEN, HIGH_Byte);
;;;175    			*(TempDataPtr+1) = WordToByte(MODBUS_TCPIP_EXCEPTION_RES_LEN, LOW_Byte);
;;;176    			/* Set response function code */
;;;177    			TempDataPtr = Socket.Memory.tx_buf_Ptr + MODBUS_TCPIP_PDU_OFFSET;
;;;178    			*TempDataPtr |= MODBUS_TCPIP_EXCEPTION_FUN_CODE;
;;;179    			/* Set data */
;;;180    			TempDataPtr = Socket.Memory.tx_buf_Ptr + MODBUS_TCPIP_EXCEPTION_DATA_OFFSET;
;;;181    			*TempDataPtr = lu8ExceptionCode;
;;;182    
;;;183    			ResponseLength = MODBUS_TCPIP_EXCEPTION_RES_LEN+MODBUS_TCPIP_HEADER_LEN;
000014  4c33              LDR      r4,|L7.228|
000016  2800              CMP      r0,#0                 ;134
000018  d162              BNE      |L7.224|
00001a  980c              LDR      r0,[sp,#0x30]         ;139
00001c  7941              LDRB     r1,[r0,#5]            ;140
00001e  7900              LDRB     r0,[r0,#4]            ;140
000020  f7fffffe          BL       ByteToWord
000024  1f9b              SUBS     r3,r3,#6              ;140
000026  4298              CMP      r0,r3                 ;140
000028  d000              BEQ      |L7.44|
00002a  2203              MOVS     r2,#3                 ;141
                  |L7.44|
00002c  980c              LDR      r0,[sp,#0x30]         ;144
00002e  f89d102c          LDRB     r1,[sp,#0x2c]         ;145
000032  7980              LDRB     r0,[r0,#6]            ;145
000034  4288              CMP      r0,r1                 ;145
000036  d000              BEQ      |L7.58|
000038  220b              MOVS     r2,#0xb               ;146
                  |L7.58|
00003a  b98a              CBNZ     r2,|L7.96|
00003c  9a0c              LDR      r2,[sp,#0x30]         ;150
00003e  79d3              LDRB     r3,[r2,#7]            ;151
000040  7a51              LDRB     r1,[r2,#9]            ;152
000042  7a10              LDRB     r0,[r2,#8]            ;152
000044  f7fffffe          BL       ByteToWord
000048  4606              MOV      r6,r0                 ;152
00004a  7ad1              LDRB     r1,[r2,#0xb]          ;153
00004c  7a90              LDRB     r0,[r2,#0xa]          ;153
00004e  f7fffffe          BL       ByteToWord
000052  4605              MOV      r5,r0                 ;153
000054  a90c              ADD      r1,sp,#0x30           ;158
000056  2b03              CMP      r3,#3                 ;156
000058  d01b              BEQ      |L7.146|
00005a  2b10              CMP      r3,#0x10              ;156
00005c  d025              BEQ      |L7.170|
00005e  2201              MOVS     r2,#1                 ;164
                  |L7.96|
000060  b37a              CBZ      r2,|L7.194|
000062  9b0e              LDR      r3,[sp,#0x38]         ;173
000064  2100              MOVS     r1,#0                 ;174
000066  2003              MOVS     r0,#3                 ;174
000068  f7fffffe          BL       WordToByte
00006c  7118              STRB     r0,[r3,#4]            ;174
00006e  2101              MOVS     r1,#1                 ;175
000070  2003              MOVS     r0,#3                 ;175
000072  f7fffffe          BL       WordToByte
000076  7158              STRB     r0,[r3,#5]            ;175
000078  980e              LDR      r0,[sp,#0x38]         ;177
00007a  79c1              LDRB     r1,[r0,#7]            ;178
00007c  f0410180          ORR      r1,r1,#0x80           ;178
000080  71c1              STRB     r1,[r0,#7]            ;178
000082  980e              LDR      r0,[sp,#0x38]         ;180
000084  7202              STRB     r2,[r0,#8]            ;181
000086  2009              MOVS     r0,#9
000088  7020              STRB     r0,[r4,#0]
                  |L7.138|
;;;184    			return ResponseLength;
;;;185    		/* Handle normal response data */
;;;186    		}else{
;;;187    			/* Set massage length of response */
;;;188    			TempDataPtr = Socket.Memory.tx_buf_Ptr + MODBUS_TCPIP_MASSAGELEN_OFFSET;
;;;189    			*TempDataPtr = WordToByte(ResponseLength, HIGH_Byte);
;;;190    			*(TempDataPtr+1) = WordToByte(ResponseLength, LOW_Byte);
;;;191    			/* Update total length of response frame */
;;;192    			ResponseLength+= MODBUS_TCPIP_HEADER_LEN;
;;;193    		}
;;;194    	}
;;;195    	
;;;196    	return ResponseLength;
;;;197    }
00008a  b006              ADD      sp,sp,#0x18
00008c  bc70              POP      {r4-r6}
00008e  f85dfb14          LDR      pc,[sp],#0x14
                  |L7.146|
000092  2214              MOVS     r2,#0x14              ;158
000094  4668              MOV      r0,sp                 ;158
000096  f7fffffe          BL       __aeabi_memcpy4
00009a  e9dd230a          LDRD     r2,r3,[sp,#0x28]      ;158
00009e  4629              MOV      r1,r5                 ;158
0000a0  4630              MOV      r0,r6                 ;158
0000a2  f7fffffe          BL       ModbusTCPIP_Func_ReadHoldReg
0000a6  4602              MOV      r2,r0                 ;158
0000a8  e7da              B        |L7.96|
                  |L7.170|
0000aa  2214              MOVS     r2,#0x14              ;161
0000ac  4668              MOV      r0,sp                 ;161
0000ae  f7fffffe          BL       __aeabi_memcpy4
0000b2  e9dd230a          LDRD     r2,r3,[sp,#0x28]      ;161
0000b6  4629              MOV      r1,r5                 ;161
0000b8  4630              MOV      r0,r6                 ;161
0000ba  f7fffffe          BL       ModbusTCPIP_Func_WriteMultiReg
0000be  4602              MOV      r2,r0                 ;161
0000c0  e7ce              B        |L7.96|
                  |L7.194|
0000c2  e7ff              B        |L7.196|
                  |L7.196|
0000c4  9a0e              LDR      r2,[sp,#0x38]         ;188
0000c6  2100              MOVS     r1,#0                 ;189
0000c8  7820              LDRB     r0,[r4,#0]            ;189  ; ResponseLength
0000ca  f7fffffe          BL       WordToByte
0000ce  7110              STRB     r0,[r2,#4]            ;189
0000d0  2101              MOVS     r1,#1                 ;190
0000d2  7820              LDRB     r0,[r4,#0]            ;190  ; ResponseLength
0000d4  f7fffffe          BL       WordToByte
0000d8  7150              STRB     r0,[r2,#5]            ;190
0000da  7820              LDRB     r0,[r4,#0]            ;192  ; ResponseLength
0000dc  1d80              ADDS     r0,r0,#6              ;192
0000de  7020              STRB     r0,[r4,#0]            ;192
                  |L7.224|
0000e0  7820              LDRB     r0,[r4,#0]            ;196  ; ResponseLength
0000e2  e7d2              B        |L7.138|
;;;198    
                          ENDP

                  |L7.228|
                          DCD      ||.data||

                          AREA ||i.Modbus_TCPIP_Socket_Open||, CODE, READONLY, ALIGN=2

                  Modbus_TCPIP_Socket_Open PROC
;;;118    
;;;119    void Modbus_TCPIP_Socket_Open(void){
000000  b510              PUSH     {r4,lr}
;;;120    	/* Register socket and caall back function */
;;;121    	W5500_Socket_Register(&Socket_ModbusTCPIP, ModbusTCPIP_cb);   
000002  4908              LDR      r1,|L8.36|
000004  4808              LDR      r0,|L8.40|
000006  f7fffffe          BL       W5500_Socket_Register
;;;122    	W5500_Socket_Register(&Socket_Test1 , ModbusTest1); 
00000a  4807              LDR      r0,|L8.40|
00000c  4907              LDR      r1,|L8.44|
00000e  301c              ADDS     r0,r0,#0x1c
000010  f7fffffe          BL       W5500_Socket_Register
;;;123    	W5500_Socket_Register(&Socket_Test2 , ModbusTest2);   	
000014  4804              LDR      r0,|L8.40|
000016  e8bd4010          POP      {r4,lr}
00001a  4905              LDR      r1,|L8.48|
00001c  3038              ADDS     r0,r0,#0x38
00001e  f7ffbffe          B.W      W5500_Socket_Register
;;;124    }
;;;125    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      ModbusTCPIP_cb
                  |L8.40|
                          DCD      ||.data||+0x4
                  |L8.44|
                          DCD      ModbusTest1
                  |L8.48|
                          DCD      ModbusTest2

                          AREA ||i.WordToByte||, CODE, READONLY, ALIGN=1

                  WordToByte PROC
;;;104    
;;;105    uint8_t WordToByte(uint16_t xu16Data, uint8_t xu8Type){
000000  2900              CMP      r1,#0
000002  d003              BEQ      |L9.12|
;;;106    	uint8_t ret;
;;;107    	switch(xu8Type){
000004  2901              CMP      r1,#1
000006  d100              BNE      |L9.10|
;;;108    		case HIGH_Byte:
;;;109    			ret = (uint8_t)((xu16Data&0xFF00)>>8);	
;;;110    			break;
;;;111    		case LOW_Byte:
;;;112    			ret = (uint8_t)(xu16Data&0x00FF);	
000008  b2c0              UXTB     r0,r0
                  |L9.10|
;;;113    			break;
;;;114    	}
;;;115    	return ret;
;;;116    }
00000a  4770              BX       lr
                  |L9.12|
00000c  0a00              LSRS     r0,r0,#8              ;109
00000e  4770              BX       lr
;;;117    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ModbusTCPIP_buffer
                          %        2000

                          AREA ||area_number.12||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.bss||
                  ModbusTest1_buffer
                          %        2000

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.13||, ||.bss||
                  ModbusTest2_buffer
                          %        2000

                          AREA ||.data||, DATA, ALIGN=2

                  ResponseLength
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  Socket_ModbusTCPIP
000004  0001              DCB      0x00,0x01
000006  01f6              DCW      0x01f6
000008  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      ModbusTCPIP_buffer
000010  07d0              DCW      0x07d0
000012  0000              DCB      0x00,0x00
                          DCD      ModbusTCPIP_buffer
000018  07d0              DCW      0x07d0
00001a  0000              DCB      0x00,0x00
00001c  0000              DCW      0x0000
00001e  0000              DCB      0x00,0x00
                  Socket_Test1
000020  0001              DCB      0x00,0x01
000022  1388              DCW      0x1388
000024  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      ModbusTest1_buffer
00002c  07d0              DCW      0x07d0
00002e  0000              DCB      0x00,0x00
                          DCD      ModbusTest1_buffer
000034  07d0              DCW      0x07d0
000036  0000              DCB      0x00,0x00
000038  0000              DCW      0x0000
00003a  0000              DCB      0x00,0x00
                  Socket_Test2
00003c  0001              DCB      0x00,0x01
00003e  1450              DCW      0x1450
000040  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      ModbusTest2_buffer
000048  07d0              DCW      0x07d0
00004a  0000              DCB      0x00,0x00
                          DCD      ModbusTest2_buffer
000050  07d0              DCW      0x07d0
000052  0000              DCB      0x00,0x00
000054  0000              DCW      0x0000
000056  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\API\\ApiModbusTCPIP.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_ApiModbusTCPIP_c_e3825b87____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___16_ApiModbusTCPIP_c_e3825b87____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_ApiModbusTCPIP_c_e3825b87____REVSH|
#line 507
|__asm___16_ApiModbusTCPIP_c_e3825b87____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_ApiModbusTCPIP_c_e3825b87____RRX|
#line 694
|__asm___16_ApiModbusTCPIP_c_e3825b87____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
