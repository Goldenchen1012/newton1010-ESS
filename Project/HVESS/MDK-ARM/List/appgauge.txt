; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\appgauge.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\appgauge.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\APP\AppGauge.c]
                          THUMB

                          AREA ||i.CheckTerminateSocUseRa||, CODE, READONLY, ALIGN=2

                  CheckTerminateSocUseRa PROC
;;;912    //--------------------------------------------
;;;913    WORD CheckTerminateSocUseRa(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;914    {
000004  b085              SUB      sp,sp,#0x14
;;;915    	const	WORD StepTab[]={500,250,100,50,20,10,5,1,0};
000006  2214              MOVS     r2,#0x14
000008  4929              LDR      r1,|L1.176|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;916    	WORD	basesoc,soc,lastsoc,endsoc,SocStep;
;;;917    	WORD	Vbat,v;
;;;918    	BYTE	i;
;;;919    	DWORD	realRa,vRa;
;;;920    	WORD	RunTimes=0;
;;;921    	
;;;922    	basesoc = getTerminateSocFromOcvTable();	//??OCV table ??????? SOC
000010  f7fffffe          BL       getTerminateSocFromOcvTable
;;;923    	lastsoc = basesoc;
000014  4606              MOV      r6,r0
;;;924    	endsoc = 10000;
000016  f2427910          MOV      r9,#0x2710
;;;925    	SocStep = 1000;
00001a  f44f757a          MOV      r5,#0x3e8
;;;926    
;;;927    	soc = lastsoc;
00001e  4634              MOV      r4,r6
;;;928    	for(i=0; i<10; i++)		//10%, 1% 0.1% 0.01%
000020  2700              MOVS     r7,#0
;;;929    	{
;;;930    		for(;soc<endsoc; soc += SocStep)
;;;931    		{
;;;932    			RunTimes++;
;;;933    			Vbat = GetOcvVoltage(soc);	//????
;;;934    			realRa = (DWORD)GetRaFromSoc(soc);		//????Ra?
;;;935    			//-------------------------------			
;;;936    			realRa *= (DWORD)mAppScuGauage.Cal_RaValue;
000022  f8dfb090          LDR      r11,|L1.180|
000026  e02f              B        |L1.136|
                  |L1.40|
000028  4620              MOV      r0,r4                 ;933
00002a  f7fffffe          BL       GetOcvVoltage
00002e  4680              MOV      r8,r0                 ;933
000030  4620              MOV      r0,r4                 ;934
000032  f7fffffe          BL       GetRaFromSoc
000036  f8bb1072          LDRH     r1,[r11,#0x72]  ; mAppScuGauage
00003a  4341              MULS     r1,r0,r1
;;;937    			realRa /= (DWORD)mAppScuGauage.Table_RaValue;
00003c  f8bb0070          LDRH     r0,[r11,#0x70]  ; mAppScuGauage
000040  fbb1faf0          UDIV     r10,r1,r0
;;;938    			//-------------------------------
;;;939    			vRa = abs(appGaugeGetCurrentValue());
000044  f7fffffe          BL       appGaugeGetCurrentValue
000048  2800              CMP      r0,#0
00004a  da00              BGE      |L1.78|
00004c  4240              RSBS     r0,r0,#0
                  |L1.78|
;;;940    			vRa *= (DWORD)realRa;
00004e  fb00f00a          MUL      r0,r0,r10
;;;941    
;;;942    			vRa /= 100000L;			//???0.1mV ??
000052  4919              LDR      r1,|L1.184|
000054  fbb0f0f1          UDIV     r0,r0,r1
;;;943    			if(vRa > 65535)			//j++ 20180328 ????overflow !!!
000058  f5b03f80          CMP      r0,#0x10000
00005c  d301              BCC      |L1.98|
;;;944    				vRa = 65535;
00005e  f64f70ff          MOV      r0,#0xffff
                  |L1.98|
;;;945    			v = (WORD)vRa;
000062  b280              UXTH     r0,r0
;;;946    			//-------------------------------			
;;;947    			if(Vbat < v)
000064  4580              CMP      r8,r0
000066  d30c              BCC      |L1.130|
;;;948    			{
;;;949    				continue;
;;;950    			}
;;;951    			Vbat -= v;
000068  eba80000          SUB      r0,r8,r0
00006c  b280              UXTH     r0,r0
;;;952    			if(Vbat == mAppScuGauage.TerminateVoltage)
00006e  f8bb1156          LDRH     r1,[r11,#0x156]  ; mAppScuGauage
000072  4281              CMP      r1,r0
000074  d103              BNE      |L1.126|
;;;953    				return soc;
000076  4620              MOV      r0,r4
                  |L1.120|
;;;954    			if(Vbat >= mAppScuGauage.TerminateVoltage)
;;;955    				break;
;;;956    			lastsoc = soc;
;;;957    		}
;;;958    		endsoc = lastsoc + SocStep;
;;;959    		SocStep = StepTab[i+1];
;;;960    		if(SocStep == 0)
;;;961    		{
;;;962    			if(soc == 1)
;;;963    				soc = 0;
;;;964    			break;
;;;965    		}
;;;966    		soc = lastsoc + SocStep;
;;;967    	}
;;;968    
;;;969    	return soc;
;;;970    }
000078  b005              ADD      sp,sp,#0x14
00007a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.126|
00007e  d905              BLS      |L1.140|
000080  4626              MOV      r6,r4                 ;956
                  |L1.130|
000082  eb040005          ADD      r0,r4,r5              ;930
000086  b284              UXTH     r4,r0                 ;930
                  |L1.136|
000088  454c              CMP      r4,r9                 ;930
00008a  d3cd              BCC      |L1.40|
                  |L1.140|
00008c  1970              ADDS     r0,r6,r5              ;958
00008e  fa1ff980          UXTH     r9,r0                 ;958
000092  1c7f              ADDS     r7,r7,#1              ;959
000094  f83d5017          LDRH     r5,[sp,r7,LSL #1]     ;959
000098  b135              CBZ      r5,|L1.168|
00009a  1970              ADDS     r0,r6,r5              ;966
00009c  b284              UXTH     r4,r0                 ;966
00009e  b2ff              UXTB     r7,r7                 ;928
0000a0  2f0a              CMP      r7,#0xa               ;928
0000a2  d3f1              BCC      |L1.136|
                  |L1.164|
0000a4  4620              MOV      r0,r4                 ;969
0000a6  e7e7              B        |L1.120|
                  |L1.168|
0000a8  2c01              CMP      r4,#1                 ;962
0000aa  d1fb              BNE      |L1.164|
0000ac  2400              MOVS     r4,#0                 ;963
0000ae  e7f9              B        |L1.164|
;;;971    
                          ENDP

                  |L1.176|
                          DCD      ||.constdata||
                  |L1.180|
                          DCD      ||.bss||
                  |L1.184|
                          DCD      0x000186a0

                          AREA ||i.CvtQmaxPassChargeTomAh||, CODE, READONLY, ALIGN=2

                  CvtQmaxPassChargeTomAh PROC
;;;175    
;;;176    DWORD CvtQmaxPassChargeTomAh(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;177    {
;;;178    	tLLbyte		LLbyte;
;;;179    	LLbyte.sll = mAppScuGauage.QmaxPassCharge.sll;
000002  4905              LDR      r1,|L2.24|
000004  e9d10112          LDRD     r0,r1,[r1,#0x48]
;;;180    	LLbyte.sll /= (DLONG)(3600u * 1000u * 1000u);    //uA , ms-->sec-->h
000008  4a04              LDR      r2,|L2.28|
00000a  2300              MOVS     r3,#0
00000c  f7fffffe          BL       __aeabi_ldivmod
000010  e9cd0100          STRD     r0,r1,[sp,#0]
;;;181    	return	LLbyte.l[0];
000014  9800              LDR      r0,[sp,#0]
;;;182    }
000016  bd1c              POP      {r2-r4,pc}
;;;183    DWORD CvtRaPassChargeTomAh(void)
                          ENDP

                  |L2.24|
                          DCD      ||.bss||
                  |L2.28|
                          DCD      0xd693a400

                          AREA ||i.CvtRaPassChargeTomAh||, CODE, READONLY, ALIGN=2

                  CvtRaPassChargeTomAh PROC
;;;182    }
;;;183    DWORD CvtRaPassChargeTomAh(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;184    {
;;;185    	tLLbyte		LLbyte;
;;;186    	LLbyte.sll = mAppScuGauage.RaPassCharge.ll;
000002  4905              LDR      r1,|L3.24|
000004  e9d10114          LDRD     r0,r1,[r1,#0x50]
;;;187    	LLbyte.sll /= (DLONG)(3600u * 1000u * 1000u);    //uA ms-->sec-->h
000008  4a04              LDR      r2,|L3.28|
00000a  2300              MOVS     r3,#0
00000c  f7fffffe          BL       __aeabi_ldivmod
000010  e9cd0100          STRD     r0,r1,[sp,#0]
;;;188    	return	LLbyte.l[0];
000014  9800              LDR      r0,[sp,#0]
;;;189    }
000016  bd1c              POP      {r2-r4,pc}
;;;190    
                          ENDP

                  |L3.24|
                          DCD      ||.bss||
                  |L3.28|
                          DCD      0xd693a400

                          AREA ||i.GetAverageCellVoltage||, CODE, READONLY, ALIGN=1

                  GetAverageCellVoltage PROC
;;;209    }
;;;210    uint16_t GetAverageCellVoltage(void)
000000  b570              PUSH     {r4-r6,lr}
;;;211    {
;;;212    	WORD	no,cell;
;;;213    	uint32_t	TotalCellVoltage = 0;
000002  2500              MOVS     r5,#0
;;;214    	
;;;215    	if(gaugeCellNumber() == 0)
000004  f7fffffe          BL       apiSysParGetCellNumber
000008  b108              CBZ      r0,|L4.14|
;;;216    		return 3500;
;;;217    	
;;;218    	for(cell=0; cell < gaugeCellNumber(); cell++)
00000a  2400              MOVS     r4,#0
00000c  e008              B        |L4.32|
                  |L4.14|
00000e  f64050ac          MOV      r0,#0xdac             ;216
;;;219    	{
;;;220    		TotalCellVoltage += halAfeGetCellVoltage(cell);
;;;221    	}
;;;222    	TotalCellVoltage /= gaugeCellNumber();
;;;223    	
;;;224    	return (uint16_t)TotalCellVoltage;
;;;225    }
000012  bd70              POP      {r4-r6,pc}
                  |L4.20|
000014  4620              MOV      r0,r4                 ;220
000016  f7fffffe          BL       halAfeGetCellVoltage
00001a  4405              ADD      r5,r5,r0              ;220
00001c  1c64              ADDS     r4,r4,#1              ;218
00001e  b2a4              UXTH     r4,r4                 ;218
                  |L4.32|
000020  f7fffffe          BL       apiSysParGetCellNumber
000024  42a0              CMP      r0,r4                 ;218
000026  d8f5              BHI      |L4.20|
000028  f7fffffe          BL       apiSysParGetCellNumber
00002c  fbb5f0f0          UDIV     r0,r5,r0              ;222
000030  b280              UXTH     r0,r0                 ;224
000032  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP


                          AREA ||i.GetOcvVoltage||, CODE, READONLY, ALIGN=2

                  GetOcvVoltage PROC
;;;268    //	根據SOC 回傳OCV 電壓值
;;;269    WORD GetOcvVoltage(WORD SOC)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
;;;271    	BYTE	i,soc;
;;;272        DWORD	v;
;;;273        DWORD   dV,dR;
;;;274        BYTE	negflag;
;;;275        
;;;276        if(mAppScuGauage.OcvTableNum<1)
000002  4c2a              LDR      r4,|L5.172|
000004  f8945088          LDRB     r5,[r4,#0x88]  ; mAppScuGauage
000008  2d00              CMP      r5,#0
00000a  d00a              BEQ      |L5.34|
;;;277        	return 0;
;;;278        soc = SOC / 100;
00000c  2164              MOVS     r1,#0x64
00000e  fbb0f1f1          UDIV     r1,r0,r1
000012  b2ca              UXTB     r2,r1
;;;279     	if(soc < mAppScuGauage.OcvTable[0].Level)
000014  f894108a          LDRB     r1,[r4,#0x8a]  ; mAppScuGauage
000018  4291              CMP      r1,r2
00001a  d904              BLS      |L5.38|
;;;280            return mAppScuGauage.OcvTable[0].Value;
00001c  f8b4008c          LDRH     r0,[r4,#0x8c]  ; mAppScuGauage
;;;281    	else if(soc >= mAppScuGauage.OcvTable[mAppScuGauage.OcvTableNum-1].Level)
;;;282            return mAppScuGauage.OcvTable[mAppScuGauage.OcvTableNum-1].Value;
;;;283    	else
;;;284    	{
;;;285    		for(i=0; i<(mAppScuGauage.OcvTableNum-1); i++)
;;;286    		{
;;;287    			if(soc >= mAppScuGauage.OcvTable[i].Level &&
;;;288    		   	   soc < mAppScuGauage.OcvTable[i+1].Level)
;;;289    		   	{
;;;290    		   		v = SOC-((WORD)mAppScuGauage.OcvTable[i].Level * 100);
;;;291    		   		//----------------------------------
;;;292    		   		//	j++ 20190618 新增判斷負電壓值!!!
;;;293    		   		//		某些 OCV table 會有高SOC 比低SOC 電壓還低的情況!!!
;;;294    		   		if(mAppScuGauage.OcvTable[i+1].Value >= mAppScuGauage.OcvTable[i].Value)
;;;295    		   		{
;;;296    			   		dV = mAppScuGauage.OcvTable[i+1].Value-
;;;297    					   mAppScuGauage.OcvTable[i].Value;
;;;298    					negflag = 0;
;;;299    				}
;;;300    				else
;;;301    				{
;;;302    					dV = mAppScuGauage.OcvTable[i].Value-
;;;303    					   mAppScuGauage.OcvTable[i+1].Value;
;;;304    					negflag=1;
;;;305    				}
;;;306    				//-----------------------------
;;;307    		   		dR = mAppScuGauage.OcvTable[i+1].Level - mAppScuGauage.OcvTable[i].Level;
;;;308    		   		dR *= 100L;
;;;309    		   		v *= dV;
;;;310    		   		v /= dR;
;;;311    		   		if(negflag)
;;;312    		   			v = mAppScuGauage.OcvTable[i].Value - v;
;;;313    		   		else
;;;314    		   			v = mAppScuGauage.OcvTable[i].Value + v;	
;;;315    		 		break;
;;;316    		   	}
;;;317    		}
;;;318    	}
;;;319        return v;
;;;320    }
000020  bd70              POP      {r4-r6,pc}
                  |L5.34|
000022  2000              MOVS     r0,#0                 ;277
000024  bd70              POP      {r4-r6,pc}
                  |L5.38|
000026  1e6d              SUBS     r5,r5,#1              ;281
000028  eb040185          ADD      r1,r4,r5,LSL #2       ;281
00002c  f891608a          LDRB     r6,[r1,#0x8a]         ;281
000030  4296              CMP      r6,r2                 ;281
000032  d802              BHI      |L5.58|
000034  f8b1008c          LDRH     r0,[r1,#0x8c]         ;282
000038  bd70              POP      {r4-r6,pc}
                  |L5.58|
00003a  2100              MOVS     r1,#0                 ;285
00003c  e032              B        |L5.164|
                  |L5.62|
00003e  eb040681          ADD      r6,r4,r1,LSL #2       ;287
000042  f896608a          LDRB     r6,[r6,#0x8a]         ;287
000046  4296              CMP      r6,r2                 ;287
000048  d82a              BHI      |L5.160|
00004a  1c4e              ADDS     r6,r1,#1              ;288
00004c  eb040686          ADD      r6,r4,r6,LSL #2       ;288
000050  f896608a          LDRB     r6,[r6,#0x8a]         ;288
000054  4296              CMP      r6,r2                 ;288
000056  d923              BLS      |L5.160|
000058  eb040281          ADD      r2,r4,r1,LSL #2       ;290
00005c  f06f0518          MVN      r5,#0x18              ;290
000060  f8123f8a          LDRB     r3,[r2,#0x8a]!        ;290
000064  fb13f505          SMULBB   r5,r3,r5              ;290
000068  eb000585          ADD      r5,r0,r5,LSL #2       ;290
00006c  1c49              ADDS     r1,r1,#1              ;294
00006e  eb040481          ADD      r4,r4,r1,LSL #2       ;294
000072  8850              LDRH     r0,[r2,#2]            ;294
000074  f8b4108c          LDRH     r1,[r4,#0x8c]         ;294
000078  4281              CMP      r1,r0                 ;294
00007a  d302              BCC      |L5.130|
00007c  1a0a              SUBS     r2,r1,r0              ;296
00007e  2100              MOVS     r1,#0                 ;298
000080  e001              B        |L5.134|
                  |L5.130|
000082  1a42              SUBS     r2,r0,r1              ;302
000084  2101              MOVS     r1,#1                 ;304
                  |L5.134|
000086  f894408a          LDRB     r4,[r4,#0x8a]         ;307
00008a  1ae3              SUBS     r3,r4,r3              ;307
00008c  2464              MOVS     r4,#0x64              ;308
00008e  4363              MULS     r3,r4,r3              ;308
000090  4355              MULS     r5,r2,r5              ;309
000092  fbb5f2f3          UDIV     r2,r5,r3              ;310
000096  b109              CBZ      r1,|L5.156|
000098  1a83              SUBS     r3,r0,r2              ;312
00009a  e005              B        |L5.168|
                  |L5.156|
00009c  1883              ADDS     r3,r0,r2              ;314
00009e  e003              B        |L5.168|
                  |L5.160|
0000a0  1c49              ADDS     r1,r1,#1              ;285
0000a2  b2c9              UXTB     r1,r1                 ;285
                  |L5.164|
0000a4  428d              CMP      r5,r1                 ;285
0000a6  dcca              BGT      |L5.62|
                  |L5.168|
0000a8  b298              UXTH     r0,r3                 ;319
0000aa  bd70              POP      {r4-r6,pc}
;;;321    //------------------------------------
                          ENDP

                  |L5.172|
                          DCD      ||.bss||

                          AREA ||i.GetRaFromSoc||, CODE, READONLY, ALIGN=2

                  GetRaFromSoc PROC
;;;323    //	解析度 0.01 mR
;;;324    WORD GetRaFromSoc(WORD SOC)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;325    {
000004  4606              MOV      r6,r0
;;;326    	BYTE	i;
;;;327    	DWORD	dR,dS,S;
;;;328    	WORD	Ra;
;;;329    	BYTE	plus_flag;
;;;330    	BYTE	soc;
;;;331    	
;;;332    	Ra = mAppScuGauage.RaTable[0].Value;	//設定初始值
000006  4b2e              LDR      r3,|L6.192|
000008  f8b300f0          LDRH     r0,[r3,#0xf0]  ; mAppScuGauage
;;;333    	
;;;334    	soc = SOC / 100;
00000c  2764              MOVS     r7,#0x64
00000e  fbb6f1f7          UDIV     r1,r6,r7
000012  b2ca              UXTB     r2,r1
;;;335    	if(mAppScuGauage.RaTableNum < 1)
000014  f8934089          LDRB     r4,[r3,#0x89]  ; mAppScuGauage
000018  2c00              CMP      r4,#0
00001a  d002              BEQ      |L6.34|
;;;336    		return 0;
;;;337    	for(i=0; i<(mAppScuGauage.RaTableNum - 1); i++)
00001c  2100              MOVS     r1,#0
00001e  1e64              SUBS     r4,r4,#1
000020  e04a              B        |L6.184|
                  |L6.34|
000022  2000              MOVS     r0,#0                 ;336
                  |L6.36|
;;;338    	{
;;;339    		if(soc >= mAppScuGauage.RaTable[i].Level &&
;;;340    		   soc < mAppScuGauage.RaTable[i+1].Level)
;;;341    		{
;;;342    			if(mAppScuGauage.RaTable[i].Value==
;;;343    			   mAppScuGauage.RaTable[i+1].Value)
;;;344    			{
;;;345    				Ra = mAppScuGauage.RaTable[i].Value;
;;;346    				break;	
;;;347    			}
;;;348    			
;;;349    			if(mAppScuGauage.RaTable[i].Value>
;;;350    			   mAppScuGauage.RaTable[i+1].Value)
;;;351    			{
;;;352    				dR = mAppScuGauage.RaTable[i].Value-
;;;353    					mAppScuGauage.RaTable[i+1].Value;
;;;354    				plus_flag = 0;
;;;355    				S=((WORD)mAppScuGauage.RaTable[i+1].Level * 100) - SOC;
;;;356    			}
;;;357    			else
;;;358    			{
;;;359    				dR = mAppScuGauage.RaTable[i+1].Value-
;;;360    					mAppScuGauage.RaTable[i].Value;
;;;361    				plus_flag = 1;
;;;362    				S = SOC-((WORD)mAppScuGauage.RaTable[i].Level * 100);
;;;363    			}
;;;364    			dS = mAppScuGauage.RaTable[i+1].Level - mAppScuGauage.RaTable[i].Level;
;;;365    			S *= dR;
;;;366    			S /= dS;
;;;367    			S /= 100;
;;;368    			if(plus_flag)
;;;369    				S += mAppScuGauage.RaTable[i].Value;
;;;370    			else
;;;371    				S += mAppScuGauage.RaTable[i+1].Value;
;;;372    			Ra = (WORD)S;
;;;373    			break;
;;;374    		}
;;;375    	}
;;;376    	return Ra;
;;;377    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L6.40|
000028  eb030581          ADD      r5,r3,r1,LSL #2       ;339
00002c  f89550ee          LDRB     r5,[r5,#0xee]         ;339
000030  4295              CMP      r5,r2                 ;339
000032  d83e              BHI      |L6.178|
000034  1c4d              ADDS     r5,r1,#1              ;340
000036  eb030585          ADD      r5,r3,r5,LSL #2       ;340
00003a  f89550ee          LDRB     r5,[r5,#0xee]         ;340
00003e  4295              CMP      r5,r2                 ;340
000040  d937              BLS      |L6.178|
000042  eb030481          ADD      r4,r3,r1,LSL #2       ;342
000046  1c49              ADDS     r1,r1,#1              ;342
000048  eb030c81          ADD      r12,r3,r1,LSL #2      ;342
00004c  f8b400f0          LDRH     r0,[r4,#0xf0]         ;342
000050  f8bc10f0          LDRH     r1,[r12,#0xf0]        ;342
000054  4288              CMP      r0,r1                 ;342
000056  d0e5              BEQ      |L6.36|
000058  d90c              BLS      |L6.116|
00005a  eba00301          SUB      r3,r0,r1              ;352
00005e  f04f0500          MOV      r5,#0                 ;354
000062  f89c20ee          LDRB     r2,[r12,#0xee]        ;355
000066  eb0208c2          ADD      r8,r2,r2,LSL #3       ;355
00006a  eb081202          ADD      r2,r8,r2,LSL #4       ;355
00006e  ebc60282          RSB      r2,r6,r2,LSL #2       ;355
000072  e00b              B        |L6.140|
                  |L6.116|
000074  eba10300          SUB      r3,r1,r0              ;359
000078  f04f0501          MOV      r5,#1                 ;361
00007c  f89420ee          LDRB     r2,[r4,#0xee]         ;362
000080  f06f0818          MVN      r8,#0x18              ;362
000084  fb12f208          SMULBB   r2,r2,r8              ;362
000088  eb060282          ADD      r2,r6,r2,LSL #2       ;362
                  |L6.140|
00008c  f89c60ee          LDRB     r6,[r12,#0xee]        ;364
000090  f89440ee          LDRB     r4,[r4,#0xee]         ;364
000094  eba60404          SUB      r4,r6,r4              ;364
000098  fb02f203          MUL      r2,r2,r3              ;365
00009c  fbb2f2f4          UDIV     r2,r2,r4              ;366
0000a0  fbb2f2f7          UDIV     r2,r2,r7              ;367
0000a4  b10d              CBZ      r5,|L6.170|
0000a6  4410              ADD      r0,r0,r2              ;369
0000a8  e001              B        |L6.174|
                  |L6.170|
0000aa  eb010002          ADD      r0,r1,r2              ;371
                  |L6.174|
0000ae  b280              UXTH     r0,r0                 ;372
0000b0  e7b8              B        |L6.36|
                  |L6.178|
0000b2  f1010101          ADD      r1,r1,#1              ;337
0000b6  b2c9              UXTB     r1,r1                 ;337
                  |L6.184|
0000b8  428c              CMP      r4,r1                 ;337
0000ba  dcb5              BGT      |L6.40|
0000bc  e7b2              B        |L6.36|
;;;378    
                          ENDP

0000be  0000              DCW      0x0000
                  |L6.192|
                          DCD      ||.bss||

                          AREA ||i.appGaugeCleanCycleCount||, CODE, READONLY, ALIGN=2

                  appGaugeCleanCycleCount PROC
;;;1454   }
;;;1455   void appGaugeCleanCycleCount(void)
000000  b510              PUSH     {r4,lr}
;;;1456   {
;;;1457   	mAppScuGauage.CycleCount.i = 0;	
000002  4807              LDR      r0,|L7.32|
000004  2100              MOVS     r1,#0
000006  8341              STRH     r1,[r0,#0x1a]
;;;1458   	mAppScuGauage.TotalDisChargeCount.ll = 0;
000008  2200              MOVS     r2,#0
00000a  6402              STR      r2,[r0,#0x40]  ; mAppScuGauage
00000c  6442              STR      r2,[r0,#0x44]  ; mAppScuGauage
;;;1459   	apiSysParSetCycleCount(0);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       apiSysParSetCycleCount
;;;1460   	apiRamSaveTotalDisChargeCount(0);
000014  e8bd4010          POP      {r4,lr}
000018  2000              MOVS     r0,#0
00001a  f7ffbffe          B.W      apiRamSaveTotalDisChargeCount
;;;1461   }
;;;1462   
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetCurrentMode||, CODE, READONLY, ALIGN=2

                  appGaugeGetCurrentMode PROC
;;;1528   
;;;1529   uint8_t	appGaugeGetCurrentMode(void)
000000  4801              LDR      r0,|L8.8|
;;;1530   {
;;;1531   	return mAppScuGauage.ChargeMode;
000002  7840              LDRB     r0,[r0,#1]  ; mAppScuGauage
;;;1532   }
000004  4770              BX       lr
;;;1533   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetCurrentValue||, CODE, READONLY, ALIGN=1

                  appGaugeGetCurrentValue PROC
;;;1533   
;;;1534   tCurrent appGaugeGetCurrentValue(void)
000000  b510              PUSH     {r4,lr}
;;;1535   {
;;;1536   	if(appGaugeGetCurrentMode() == APP_SCU_GAUGE_RELEASE_MODE)
000002  f7fffffe          BL       appGaugeGetCurrentMode
000006  b120              CBZ      r0,|L9.18|
;;;1537   		return 0;
;;;1538   	else 
;;;1539   		return halAfeGetCurrentValue(0);
000008  e8bd4010          POP      {r4,lr}
00000c  2000              MOVS     r0,#0
00000e  f7ffbffe          B.W      halAfeGetCurrentValue
                  |L9.18|
000012  2000              MOVS     r0,#0                 ;1537
;;;1540   }
000014  bd10              POP      {r4,pc}
;;;1541   
                          ENDP


                          AREA ||i.appGaugeGetCyleCount||, CODE, READONLY, ALIGN=2

                  appGaugeGetCyleCount PROC
;;;1462   
;;;1463   uint16_t appGaugeGetCyleCount(void)
000000  4801              LDR      r0,|L10.8|
;;;1464   {
;;;1465   	return mAppScuGauage.CycleCount.i;
000002  8b40              LDRH     r0,[r0,#0x1a]  ; mAppScuGauage
;;;1466   }
000004  4770              BX       lr
;;;1467   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetDisplaySoc||, CODE, READONLY, ALIGN=2

                  appGaugeGetDisplaySoc PROC
;;;1549   }
;;;1550   uint16_t appGaugeGetDisplaySoc(void)
000000  4801              LDR      r0,|L11.8|
;;;1551   {
;;;1552   	return mAppScuGauage.DisplaySocValue.i;
000002  f8b00152          LDRH     r0,[r0,#0x152]  ; mAppScuGauage
;;;1553   }
000006  4770              BX       lr
;;;1554   
                          ENDP

                  |L11.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetEndOfSoc||, CODE, READONLY, ALIGN=2

                  appGaugeGetEndOfSoc PROC
;;;1545   }
;;;1546   uint16_t appGaugeGetEndOfSoc(void)
000000  4801              LDR      r0,|L12.8|
;;;1547   {
;;;1548   	return mAppScuGauage.CutOffSoc;
000002  8cc0              LDRH     r0,[r0,#0x26]  ; mAppScuGauage
;;;1549   }
000004  4770              BX       lr
;;;1550   uint16_t appGaugeGetDisplaySoc(void)
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetFCC||, CODE, READONLY, ALIGN=2

                  appGaugeGetFCC PROC
;;;1523   }
;;;1524   uint32_t appGaugeGetFCC(void)
000000  4801              LDR      r0,|L13.8|
;;;1525   {
;;;1526   	return mAppScuGauage.FCC.l;
000002  6b00              LDR      r0,[r0,#0x30]  ; mAppScuGauage
;;;1527   }
000004  4770              BX       lr
;;;1528   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetQPassCharge||, CODE, READONLY, ALIGN=1

                  appGaugeGetQPassCharge PROC
;;;1515   
;;;1516   int32_t appGaugeGetQPassCharge(void)
000000  f7ffbffe          B.W      CvtQmaxPassChargeTomAh
;;;1517   {
;;;1518   	return CvtQmaxPassChargeTomAh();
;;;1519   }
;;;1520   int32_t appGaugeGetRPassCharge(void)
                          ENDP


                          AREA ||i.appGaugeGetQStart||, CODE, READONLY, ALIGN=2

                  appGaugeGetQStart PROC
;;;1500   
;;;1501   uint32_t appGaugeGetQStart(void)
000000  4801              LDR      r0,|L15.8|
;;;1502   {
;;;1503   	return mAppScuGauage.Qstart.l;
000002  6a80              LDR      r0,[r0,#0x28]  ; mAppScuGauage
;;;1504   }
000004  4770              BX       lr
;;;1505   uint32_t appGaugeGetRM(void)
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetQmax||, CODE, READONLY, ALIGN=2

                  appGaugeGetQmax PROC
;;;1488   
;;;1489   uint32_t appGaugeGetQmax(void)
000000  4801              LDR      r0,|L16.8|
;;;1490   {
;;;1491   	return mAppScuGauage.Qmax.l;
000002  6b40              LDR      r0,[r0,#0x34]  ; mAppScuGauage
;;;1492   }
000004  4770              BX       lr
;;;1493   
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetRM||, CODE, READONLY, ALIGN=1

                  appGaugeGetRM PROC
;;;1504   }
;;;1505   uint32_t appGaugeGetRM(void)
000000  f7ffbffe          B.W      appScuGaugeCvtRmTomAh
;;;1506   {
;;;1507   	return appScuGaugeCvtRmTomAh();
;;;1508   }
;;;1509   
                          ENDP


                          AREA ||i.appGaugeGetRPassCharge||, CODE, READONLY, ALIGN=1

                  appGaugeGetRPassCharge PROC
;;;1519   }
;;;1520   int32_t appGaugeGetRPassCharge(void)
000000  f7ffbffe          B.W      CvtRaPassChargeTomAh
;;;1521   {
;;;1522   	return CvtRaPassChargeTomAh();
;;;1523   }
;;;1524   uint32_t appGaugeGetFCC(void)
                          ENDP


                          AREA ||i.appGaugeGetRSoc||, CODE, READONLY, ALIGN=2

                  appGaugeGetRSoc PROC
;;;1468   
;;;1469   uint16_t appGaugeGetRSoc(void)
000000  4801              LDR      r0,|L19.8|
;;;1470   {
;;;1471   	return mAppScuGauage.RsocValue.i;
000002  f8b00154          LDRH     r0,[r0,#0x154]  ; mAppScuGauage
;;;1472   }
000006  4770              BX       lr
;;;1473   
                          ENDP

                  |L19.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetRamSoc||, CODE, READONLY, ALIGN=2

                  appGaugeGetRamSoc PROC
;;;1541   
;;;1542   uint16_t appGaugeGetRamSoc(void)
000000  4801              LDR      r0,|L20.8|
;;;1543   {
;;;1544   	return mAppScuGauage.RamSoc;
000002  8a80              LDRH     r0,[r0,#0x14]  ; mAppScuGauage
;;;1545   }
000004  4770              BX       lr
;;;1546   uint16_t appGaugeGetEndOfSoc(void)
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetSOH||, CODE, READONLY, ALIGN=2

                  appGaugeGetSOH PROC
;;;1478    
;;;1479   uint16_t appGaugeGetSOH(void)
000000  b510              PUSH     {r4,lr}
;;;1480   {
;;;1481   	uint32_t	n;
;;;1482   	
;;;1483   	n = mAppScuGauage.Qmax.l;
000002  4805              LDR      r0,|L21.24|
000004  6b44              LDR      r4,[r0,#0x34]  ; mAppScuGauage
;;;1484   	n *= 10000L;
000006  f2427010          MOV      r0,#0x2710
00000a  4344              MULS     r4,r0,r4
;;;1485   	n /= apiSysParGetDesignedCapacity();
00000c  f7fffffe          BL       apiSysParGetDesignedCapacity
000010  fbb4f0f0          UDIV     r0,r4,r0
;;;1486   	return n;
000014  b280              UXTH     r0,r0
;;;1487   }
000016  bd10              POP      {r4,pc}
;;;1488   
                          ENDP

                  |L21.24|
                          DCD      ||.bss||

                          AREA ||i.appGaugeGetSoc0||, CODE, READONLY, ALIGN=2

                  appGaugeGetSoc0 PROC
;;;1473   
;;;1474   uint16_t appGaugeGetSoc0(void)
000000  4801              LDR      r0,|L22.8|
;;;1475   {
;;;1476   	return mAppScuGauage.Soc0;
000002  89c0              LDRH     r0,[r0,#0xe]  ; mAppScuGauage
;;;1477   }
000004  4770              BX       lr
;;;1478    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      ||.bss||

                          AREA ||i.appGaugeOpen||, CODE, READONLY, ALIGN=2

                  appGaugeOpen PROC
;;;1554   
;;;1555   void appGaugeOpen(tAppGaugeEvtHandler eventHandler)
000000  b510              PUSH     {r4,lr}
;;;1556   {
000002  4604              MOV      r4,r0
;;;1557   	chargeModeIni();
000004  f7fffffe          BL       chargeModeIni
;;;1558   	gaugeQPassChargeIni();
000008  f7fffffe          BL       gaugeQPassChargeIni
;;;1559   	gaugeRPassChargeIni();
00000c  f7fffffe          BL       gaugeRPassChargeIni
;;;1560   	setupOcvTable();
000010  f7fffffe          BL       setupOcvTable
;;;1561   	setupRaTable();
000014  f7fffffe          BL       setupRaTable
;;;1562   	baseInfoIni();
000018  f7fffffe          BL       baseInfoIni
;;;1563   	setupFullChargeCondition();
00001c  f7fffffe          BL       setupFullChargeCondition
;;;1564   
;;;1565   	mAppScuGauage.EvtHandler = eventHandler;
000020  4806              LDR      r0,|L23.60|
000022  f8c04168          STR      r4,[r0,#0x168]  ; mAppScuGauage
;;;1566   	mAppScuGauage.GaugeTickMs = 0;	
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;1567     	LibSwTimerOpen(gaugeSwTimerHandler, 0);
00002a  4805              LDR      r0,|L23.64|
00002c  f7fffffe          BL       LibSwTimerOpen
;;;1568     	LibHwTimerOpen(gaugeHwTimerHandler, 0);
000030  e8bd4010          POP      {r4,lr}
000034  2100              MOVS     r1,#0
000036  4803              LDR      r0,|L23.68|
000038  f7ffbffe          B.W      LibHwTimerOpen
;;;1569   }
;;;1570   
                          ENDP

                  |L23.60|
                          DCD      ||.bss||
                  |L23.64|
                          DCD      gaugeSwTimerHandler
                  |L23.68|
                          DCD      gaugeHwTimerHandler

                          AREA ||i.appGaugeSetQmax||, CODE, READONLY, ALIGN=2

                  appGaugeSetQmax PROC
;;;1493   
;;;1494   void appGaugeSetQmax(uint32_t qmax)
000000  b570              PUSH     {r4-r6,lr}
;;;1495   {
;;;1496   	mAppScuGauage.Qmax.l = qmax;
000002  4a07              LDR      r2,|L24.32|
000004  6350              STR      r0,[r2,#0x34]  ; mAppScuGauage
;;;1497   	mAppScuGauage.QmaxuAms.ll = mAppScuGauage.Qmax.l;
000006  2100              MOVS     r1,#0
;;;1498   	mAppScuGauage.QmaxuAms.ll *= (1000u * 3600u * 1000u);
000008  4b06              LDR      r3,|L24.36|
00000a  2400              MOVS     r4,#0
00000c  fba05603          UMULL    r5,r6,r0,r3
000010  fb016103          MLA      r1,r1,r3,r6
000014  fb001004          MLA      r0,r0,r4,r1
000018  e9c2500e          STRD     r5,r0,[r2,#0x38]
;;;1499   }
00001c  bd70              POP      {r4-r6,pc}
;;;1500   
                          ENDP

00001e  0000              DCW      0x0000
                  |L24.32|
                          DCD      ||.bss||
                  |L24.36|
                          DCD      0xd693a400

                          AREA ||i.appGaugeSetRM||, CODE, READONLY, ALIGN=2

                  appGaugeSetRM PROC
;;;1509   
;;;1510   void appGaugeSetRM(uint32_t rm)
000000  b570              PUSH     {r4-r6,lr}
;;;1511   {
;;;1512   	mAppScuGauage.RM.ll = rm;
000002  4a06              LDR      r2,|L25.28|
000004  2100              MOVS     r1,#0
;;;1513   	mAppScuGauage.RM.ll *= (DDWORD)(3600u * 1000u * 1000u);    //uA->mA ms-->sec-->h
000006  4b06              LDR      r3,|L25.32|
000008  2400              MOVS     r4,#0
00000a  fba05603          UMULL    r5,r6,r0,r3
00000e  fb016103          MLA      r1,r1,r3,r6
000012  fb001004          MLA      r0,r0,r4,r1
000016  e9c25016          STRD     r5,r0,[r2,#0x58]
;;;1514   }
00001a  bd70              POP      {r4-r6,pc}
;;;1515   
                          ENDP

                  |L25.28|
                          DCD      ||.bss||
                  |L25.32|
                          DCD      0xd693a400

                          AREA ||i.appGaugeSetSoc0||, CODE, READONLY, ALIGN=2

                  appGaugeSetSoc0 PROC
;;;1420   /* Public function prototypes ----------------------------------------------- */
;;;1421   void appGaugeSetSoc0(uint16_t soc)
000000  b510              PUSH     {r4,lr}
;;;1422   {
;;;1423   	uint32_t	n1;
;;;1424   	mAppScuGauage.Soc0Valid = 1;
000002  4c10              LDR      r4,|L26.68|
000004  2101              MOVS     r1,#1
000006  f8841020          STRB     r1,[r4,#0x20]
;;;1425   	mAppScuGauage.Soc0 = soc;
00000a  81e0              STRH     r0,[r4,#0xe]
;;;1426   	mAppScuGauage.StartCalRaSoc = mAppScuGauage.Soc0;	//設定為有效的RA Soc
00000c  8260              STRH     r0,[r4,#0x12]
;;;1427   	mAppScuGauage.RaSocValid = 1;
00000e  f8841021          STRB     r1,[r4,#0x21]
;;;1428   	gaugeRPassChargeIni();							//設定Ra PassCharge 初始值
000012  f7fffffe          BL       gaugeRPassChargeIni
;;;1429   	mAppScuGauage.RamSoc = mAppScuGauage.Soc0;
000016  89e0              LDRH     r0,[r4,#0xe]  ; mAppScuGauage
000018  82a0              STRH     r0,[r4,#0x14]
;;;1430   	mAppScuGauage.SocBase = mAppScuGauage.Soc0;
00001a  82e0              STRH     r0,[r4,#0x16]
;;;1431   	//---------------------------------
;;;1432   	//	抓取新的截止點
;;;1433   	mAppScuGauage.CutOffSoc = getTerminateSocFromOcvTable();
00001c  f7fffffe          BL       getTerminateSocFromOcvTable
000020  84e0              STRH     r0,[r4,#0x26]
;;;1434   	//--------------
;;;1435   	//計算QStart
;;;1436   	n1 = (10000L - mAppScuGauage.Soc0);
000022  89e0              LDRH     r0,[r4,#0xe]  ; mAppScuGauage
000024  f2427310          MOV      r3,#0x2710
000028  1a1a              SUBS     r2,r3,r0
;;;1437   	n1 *= mAppScuGauage.Qmax.l;
00002a  6b61              LDR      r1,[r4,#0x34]  ; mAppScuGauage
00002c  4351              MULS     r1,r2,r1
;;;1438   	n1 /= 10000L;
00002e  fbb1f1f3          UDIV     r1,r1,r3
;;;1439   	mAppScuGauage.Qstart.l = n1;
000032  62a1              STR      r1,[r4,#0x28]  ; mAppScuGauage
;;;1440   	gaugeSetRmAndFcc(mAppScuGauage.Soc0);
000034  f7fffffe          BL       gaugeSetRmAndFcc
;;;1441   	mAppScuGauage.DisplaySocValue.i = mAppScuGauage.RsocValue.i;
000038  f8b40154          LDRH     r0,[r4,#0x154]  ; mAppScuGauage
00003c  f8a40152          STRH     r0,[r4,#0x152]
;;;1442   }
000040  bd10              POP      {r4,pc}
;;;1443   void appGaugeUpdateSoc0(void)
                          ENDP

000042  0000              DCW      0x0000
                  |L26.68|
                          DCD      ||.bss||

                          AREA ||i.appGaugeUpdateSoc0||, CODE, READONLY, ALIGN=2

                  appGaugeUpdateSoc0 PROC
;;;1442   }
;;;1443   void appGaugeUpdateSoc0(void)
000000  b510              PUSH     {r4,lr}
;;;1444   {
;;;1445   	mAppScuGauage.RelaxSec = 5 * 3600;
000002  4c06              LDR      r4,|L27.28|
000004  f2446050          MOV      r0,#0x4650
000008  80e0              STRH     r0,[r4,#6]
;;;1446   	mAppScuGauage.ReadSocTime = 1800;
00000a  f44f60e1          MOV      r0,#0x708
00000e  80a0              STRH     r0,[r4,#4]
;;;1447   	mAppScuGauage.SocReadNum = 1;
000010  2001              MOVS     r0,#1
000012  7760              STRB     r0,[r4,#0x1d]
;;;1448   	mAppScuGauage.SocA_Voltage = GetAverageCellVoltage();
000014  f7fffffe          BL       GetAverageCellVoltage
000018  8160              STRH     r0,[r4,#0xa]
;;;1449   	
;;;1450   //	BatteryCapInfo.RelaxSec = 5*3600;
;;;1451   //	BatteryCapInfo.ReadSocTime = 1800;
;;;1452   //	BatteryCapInfo.SocA_Voltage = GetAverageCellVoltage();
;;;1453   //	BatteryCapInfo.SocReadNum = 1;
;;;1454   }
00001a  bd10              POP      {r4,pc}
;;;1455   void appGaugeCleanCycleCount(void)
                          ENDP

                  |L27.28|
                          DCD      ||.bss||

                          AREA ||i.appScuGaugeCvtRmTomAh||, CODE, READONLY, ALIGN=2

                  appScuGaugeCvtRmTomAh PROC
;;;190    
;;;191    DWORD appScuGaugeCvtRmTomAh(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;192    {
;;;193    	tLLbyte		LLbyte;
;;;194    	LLbyte.ll = mAppScuGauage.RM.ll;
000002  4905              LDR      r1,|L28.24|
000004  e9d10116          LDRD     r0,r1,[r1,#0x58]
;;;195    	LLbyte.ll /= (DDWORD)(3600u * 1000u * 1000u);    //uA->mA ms-->sec-->h
000008  4a04              LDR      r2,|L28.28|
00000a  2300              MOVS     r3,#0
00000c  f7fffffe          BL       __aeabi_uldivmod
000010  e9cd0100          STRD     r0,r1,[sp,#0]
;;;196    	return	LLbyte.l[0];
000014  9800              LDR      r0,[sp,#0]
;;;197    }
000016  bd1c              POP      {r2-r4,pc}
;;;198    
                          ENDP

                  |L28.24|
                          DCD      ||.bss||
                  |L28.28|
                          DCD      0xd693a400

                          AREA ||i.appScuGaugeSetFcc||, CODE, READONLY, ALIGN=2

                  appScuGaugeSetFcc PROC
;;;228    //------------------------------------
;;;229    void appScuGaugeSetFcc(void)
000000  b510              PUSH     {r4,lr}
;;;230    {
;;;231    	DWORD	n1;
;;;232    	LONG	slong;
;;;233    	n1 = appScuGaugeCvtRmTomAh();	
000002  f7fffffe          BL       appScuGaugeCvtRmTomAh
;;;234    	
;;;235    	mAppScuGauage.FCC.l = mAppScuGauage.Qstart.l + n1;
000006  4c0b              LDR      r4,|L29.52|
000008  6aa1              LDR      r1,[r4,#0x28]  ; mAppScuGauage
00000a  4408              ADD      r0,r0,r1
00000c  6320              STR      r0,[r4,#0x30]  ; mAppScuGauage
;;;236    	slong = CvtRaPassChargeTomAh();
00000e  f7fffffe          BL       CvtRaPassChargeTomAh
;;;237    	if(slong < 0)
000012  2800              CMP      r0,#0
000014  da04              BGE      |L29.32|
;;;238    	{
;;;239    		n1 = slong * (-1);
000016  4240              RSBS     r0,r0,#0
;;;240    		mAppScuGauage.FCC.l += n1;
000018  6b21              LDR      r1,[r4,#0x30]  ; mAppScuGauage
00001a  4408              ADD      r0,r0,r1
00001c  6320              STR      r0,[r4,#0x30]  ; mAppScuGauage
00001e  e004              B        |L29.42|
                  |L29.32|
;;;241    	}
;;;242    	else
;;;243    	{
;;;244    		if(mAppScuGauage.FCC.l >= slong)
000020  6b21              LDR      r1,[r4,#0x30]  ; mAppScuGauage
000022  4281              CMP      r1,r0
000024  d301              BCC      |L29.42|
;;;245    			mAppScuGauage.FCC.l -= slong;
000026  1a08              SUBS     r0,r1,r0
000028  6320              STR      r0,[r4,#0x30]  ; mAppScuGauage
                  |L29.42|
;;;246    	}
;;;247    	gaugeCalSoc();
00002a  e8bd4010          POP      {r4,lr}
00002e  f7ffbffe          B.W      gaugeCalSoc
;;;248    }
;;;249    
                          ENDP

000032  0000              DCW      0x0000
                  |L29.52|
                          DCD      ||.bss||

                          AREA ||i.appScuGaugeUpdateQmax||, CODE, READONLY, ALIGN=2

                  appScuGaugeUpdateQmax PROC
;;;461    //===========================================================================
;;;462    void appScuGaugeUpdateQmax(DWORD passcharge,BYTE Times)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;463    {
000004  4603              MOV      r3,r0
000006  460f              MOV      r7,r1
;;;464    	WORD		soc;
;;;465    	DWORD		n1;
;;;466    	tLLbyte		LLbyte;
;;;467    	
;;;468    	if(mAppScuGauage.StarCalQmaxSoc >= mAppScuGauage.Soc0)
000008  f8df80f4          LDR      r8,|L30.256|
00000c  f8b81010          LDRH     r1,[r8,#0x10]  ; mAppScuGauage
000010  f8b8200e          LDRH     r2,[r8,#0xe]  ; mAppScuGauage
000014  4291              CMP      r1,r2
000016  d302              BCC      |L30.30|
;;;469    		soc = mAppScuGauage.StarCalQmaxSoc - mAppScuGauage.Soc0;
000018  1a88              SUBS     r0,r1,r2
00001a  b282              UXTH     r2,r0
00001c  e001              B        |L30.34|
                  |L30.30|
;;;470    	else
;;;471    		soc = mAppScuGauage.Soc0 - mAppScuGauage.StarCalQmaxSoc;
00001e  1a50              SUBS     r0,r2,r1
000020  b282              UXTH     r2,r0
                  |L30.34|
;;;472    	//	由放電的百分比及容量，反推Qmax 的值
;;;473    	LLbyte.ll = (DDWORD)passcharge;
000022  2400              MOVS     r4,#0
;;;474    	LLbyte.ll *= (DDWORD)10000;	
000024  f2427110          MOV      r1,#0x2710
000028  fba30601          UMULL    r0,r6,r3,r1
00002c  fb046101          MLA      r1,r4,r1,r6
000030  2500              MOVS     r5,#0
000032  fb031105          MLA      r1,r3,r5,r1
;;;475    	LLbyte.ll /= (DDWORD)soc;
000036  2300              MOVS     r3,#0
000038  f7fffffe          BL       __aeabi_uldivmod
00003c  e9cd0100          STRD     r0,r1,[sp,#0]
;;;476    					
;;;477    	mAppScuGauage.QmaxUpdateTimes.i++;
000040  f8b80018          LDRH     r0,[r8,#0x18]  ; mAppScuGauage
000044  1c40              ADDS     r0,r0,#1
000046  f8a80018          STRH     r0,[r8,#0x18]
;;;478    	mAppScuGauage.Qmax.l = LLbyte.l[0];
00004a  9800              LDR      r0,[sp,#0]
00004c  f8c80034          STR      r0,[r8,#0x34]  ; mAppScuGauage
;;;479    	//------------------------------------------------------
;;;480    	//	20180328 限制Qmax 不可大於 DC 
;;;481    	if(mAppScuGauage.Qmax.l >= apiSysParGetDesignedCapacity())
000050  f7fffffe          BL       apiSysParGetDesignedCapacity
000054  f8d81034          LDR      r1,[r8,#0x34]  ; mAppScuGauage
000058  4288              CMP      r0,r1
00005a  d803              BHI      |L30.100|
;;;482    		mAppScuGauage.Qmax.l = apiSysParGetDesignedCapacity();	
00005c  f7fffffe          BL       apiSysParGetDesignedCapacity
000060  f8c80034          STR      r0,[r8,#0x34]  ; mAppScuGauage
                  |L30.100|
;;;483    	//----------------------------------------------
;;;484    	mAppScuGauage.QmaxuAms.ll = mAppScuGauage.Qmax.l;				
000064  f8d85034          LDR      r5,[r8,#0x34]  ; mAppScuGauage
000068  4626              MOV      r6,r4
;;;485    	mAppScuGauage.QmaxuAms.ll *= 1000;	//mA-->uA
00006a  f44f707a          MOV      r0,#0x3e8
00006e  fba51300          UMULL    r1,r3,r5,r0
000072  fb063000          MLA      r0,r6,r0,r3
000076  2200              MOVS     r2,#0
000078  fb050202          MLA      r2,r5,r2,r0
00007c  4634              MOV      r4,r6
;;;486    	mAppScuGauage.QmaxuAms.ll *= 3600;	//h-->sec
00007e  f44f6361          MOV      r3,#0xe10
000082  fba10603          UMULL    r0,r6,r1,r3
000086  fb026203          MLA      r2,r2,r3,r6
00008a  2500              MOVS     r5,#0
00008c  fb012105          MLA      r1,r1,r5,r2
;;;487    	mAppScuGauage.QmaxuAms.ll *= 1000;	//sec-->ms
000090  f44f727a          MOV      r2,#0x3e8
000094  fba03602          UMULL    r3,r6,r0,r2
000098  fb016102          MLA      r1,r1,r2,r6
00009c  fb001005          MLA      r0,r0,r5,r1
0000a0  e9c8300e          STRD     r3,r0,[r8,#0x38]
;;;488    	//----------------------------------------------
;;;489    	;//j-- SaveBatteryInfo();
;;;490    	mAppScuGauage.QmaxStatus = 0;	//設定已更新過Qmax
0000a4  f888401e          STRB     r4,[r8,#0x1e]
;;;491    	gaugeQPassChargeIni();			//重新設定PassCharge的基本值
0000a8  f7fffffe          BL       gaugeQPassChargeIni
;;;492    	//--------------
;;;493    	//計算QStart
;;;494    	n1 = (10000L - mAppScuGauage.Soc0);
0000ac  f8b8000e          LDRH     r0,[r8,#0xe]  ; mAppScuGauage
0000b0  f2427310          MOV      r3,#0x2710
0000b4  1a1a              SUBS     r2,r3,r0
;;;495    	n1 *= mAppScuGauage.Qmax.l;
0000b6  f8d81034          LDR      r1,[r8,#0x34]  ; mAppScuGauage
0000ba  4351              MULS     r1,r2,r1
;;;496    	n1 /= 10000L;
0000bc  fbb1f1f3          UDIV     r1,r1,r3
;;;497    	mAppScuGauage.Qstart.l = n1;
0000c0  f8c81028          STR      r1,[r8,#0x28]  ; mAppScuGauage
;;;498    	//-------------
;;;499    	//	必需先更新Qstart 再更新RM,因為更新RM 時會一併更新FCC
;;;500    	gaugeSetRmAndFcc(mAppScuGauage.Soc0);
0000c4  f7fffffe          BL       gaugeSetRmAndFcc
;;;501    	if(Times==0)
0000c8  b187              CBZ      r7,|L30.236|
;;;502    	{
;;;503    		if(mAppScuGauage.EvtHandler)
;;;504    			mAppScuGauage.EvtHandler(0, APP_GAUGE_EVENT_UPDATE_QMAX_1ST, 0);
;;;505    		;//j-- SaveFaultData(EVENT_UPDATE_QMAX_1ST,area);
;;;506    	}
;;;507    	else
;;;508    	{
;;;509    		if(mAppScuGauage.EvtHandler)
0000ca  f8d83168          LDR      r3,[r8,#0x168]  ; mAppScuGauage
0000ce  b11b              CBZ      r3,|L30.216|
;;;510    			mAppScuGauage.EvtHandler(0, APP_GAUGE_EVENT_UPDATE_QMAX, 0);
0000d0  2200              MOVS     r2,#0
0000d2  2105              MOVS     r1,#5
0000d4  4610              MOV      r0,r2
0000d6  4798              BLX      r3
                  |L30.216|
;;;511    
;;;512    		;//j-- SaveFaultData(EVENT_UPDATE_QMAX,area);
;;;513    	}	
;;;514    	apiSysParSetQmaxUpdateTimes(mAppScuGauage.QmaxUpdateTimes.i);
0000d8  f8b80018          LDRH     r0,[r8,#0x18]  ; mAppScuGauage
0000dc  f7fffffe          BL       apiSysParSetQmaxUpdateTimes
;;;515    	apiSysParSetQmax(mAppScuGauage.Qmax.l);
0000e0  f8d80034          LDR      r0,[r8,#0x34]  ; mAppScuGauage
0000e4  e8bd41fc          POP      {r2-r8,lr}
0000e8  f7ffbffe          B.W      apiSysParSetQmax
                  |L30.236|
0000ec  f8d83168          LDR      r3,[r8,#0x168]        ;503  ; mAppScuGauage
0000f0  2b00              CMP      r3,#0                 ;503
0000f2  d0f1              BEQ      |L30.216|
0000f4  2200              MOVS     r2,#0                 ;504
0000f6  2104              MOVS     r1,#4                 ;504
0000f8  4610              MOV      r0,r2                 ;504
0000fa  4798              BLX      r3                    ;504
0000fc  e7ec              B        |L30.216|
;;;516    }
;;;517    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L30.256|
                          DCD      ||.bss||

                          AREA ||i.appScuGaugeUpdateRm||, CODE, READONLY, ALIGN=2

                  appScuGaugeUpdateRm PROC
;;;972    //----------------------------------------------------
;;;973    void appScuGaugeUpdateRm(WORD lastsoc,WORD nowsoc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;974    {
000004  4602              MOV      r2,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  460d              MOV      r5,r1
;;;975    	BYTE		i;
;;;976    	WORD		st,ed;
;;;977    	WORD		SocTabVoltage;
;;;978    	WORD		RealVoltage;
;;;979    	double		cur,newRa;
;;;980    	char	str[100];
;;;981    	
;;;982    	if(mAppScuGauage.RaTableNum<1)
00000c  4e41              LDR      r6,|L31.276|
00000e  f8960089          LDRB     r0,[r6,#0x89]  ; mAppScuGauage
000012  2800              CMP      r0,#0
000014  d06d              BEQ      |L31.242|
;;;983    		return;
;;;984    		
;;;985    	//scuDebugMsg("I.T...................");
;;;986    
;;;987    	for(i=mAppScuGauage.RaTableNum-1; i>=1; i--)
000016  1e40              SUBS     r0,r0,#1
000018  b2c4              UXTB     r4,r0
;;;988    	{
;;;989    		st = mAppScuGauage.RaTable[i-1].Level * 100;
;;;990    		ed = mAppScuGauage.RaTable[i].Level * 100;
;;;991    				
;;;992    		if(lastsoc>=ed && nowsoc>st && nowsoc<=ed && i != mAppScuGauage.RmUpdateLastLevel)
00001a  f896702c          LDRB     r7,[r6,#0x2c]
00001e  e075              B        |L31.268|
                  |L31.32|
000020  1e60              SUBS     r0,r4,#1              ;989
000022  eb060180          ADD      r1,r6,r0,LSL #2       ;989
000026  2364              MOVS     r3,#0x64              ;989
000028  f89110ee          LDRB     r1,[r1,#0xee]         ;989
00002c  fb11f303          SMULBB   r3,r1,r3              ;989
000030  eb060184          ADD      r1,r6,r4,LSL #2       ;990
000034  f04f0c64          MOV      r12,#0x64             ;990
000038  f89110ee          LDRB     r1,[r1,#0xee]         ;990
00003c  fb11f10c          SMULBB   r1,r1,r12             ;990
000040  428a              CMP      r2,r1
000042  d35a              BCC      |L31.250|
000044  429d              CMP      r5,r3
000046  d958              BLS      |L31.250|
000048  428d              CMP      r5,r1
00004a  d856              BHI      |L31.250|
00004c  42a7              CMP      r7,r4
00004e  d054              BEQ      |L31.250|
;;;993    		{
;;;994    			//sprintf(str,"RA Level=%d", i);
;;;995    			//scuDebugMsg(str);
;;;996    			mAppScuGauage.RmUpdateLastLevel = i;
000050  f886402c          STRB     r4,[r6,#0x2c]
;;;997    			//-------------------------------
;;;998    			SocTabVoltage = GetOcvVoltage(nowsoc);
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       GetOcvVoltage
00005a  4680              MOV      r8,r0
;;;999    			
;;;1000   			//-------------------------------
;;;1001   			RealVoltage = GetAverageCellVoltage();
00005c  f7fffffe          BL       GetAverageCellVoltage
000060  4607              MOV      r7,r0
;;;1002   			if(SocTabVoltage > RealVoltage)
000062  45b8              CMP      r8,r7
000064  d945              BLS      |L31.242|
;;;1003   			{
;;;1004   				mAppScuGauage.Table_RaValue = GetRaFromSoc(nowsoc);
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       GetRaFromSoc
00006c  f8a60070          STRH     r0,[r6,#0x70]
;;;1005   //				cur = (double)mAppScuGauage.AvggCurrent.sl;
;;;1006   				cur = abs(appGaugeGetCurrentValue());
000070  f7fffffe          BL       appGaugeGetCurrentValue
000074  2800              CMP      r0,#0
000076  da00              BGE      |L31.122|
000078  4240              RSBS     r0,r0,#0
                  |L31.122|
00007a  f7fffffe          BL       __aeabi_i2d
00007e  ec410b18          VMOV     d8,r0,r1
;;;1007   				newRa =(double)(SocTabVoltage - RealVoltage);
000082  eba80007          SUB      r0,r8,r7
000086  f7fffffe          BL       __aeabi_i2d
00008a  ec410b10          VMOV     d0,r0,r1
;;;1008   				newRa *= 100000.0;	//0.01mR
00008e  ed9f1b22          VLDR     d1,|L31.280|
000092  ec510b10          VMOV     r0,r1,d0
000096  ec532b11          VMOV     r2,r3,d1
00009a  f7fffffe          BL       __aeabi_dmul
00009e  ec410b10          VMOV     d0,r0,r1
;;;1009   				newRa /= cur;
0000a2  ec532b18          VMOV     r2,r3,d8
0000a6  ec510b10          VMOV     r0,r1,d0
0000aa  f7fffffe          BL       __aeabi_ddiv
0000ae  ec410b10          VMOV     d0,r0,r1
;;;1010   				mAppScuGauage.Cal_RaValue = (WORD)newRa;
0000b2  ec510b10          VMOV     r0,r1,d0
0000b6  f7fffffe          BL       __aeabi_d2uiz
0000ba  f8a60072          STRH     r0,[r6,#0x72]
;;;1011   				
;;;1012   				mAppScuGauage.CutOffSoc = CheckTerminateSocUseRa();
0000be  f7fffffe          BL       CheckTerminateSocUseRa
0000c2  84f0              STRH     r0,[r6,#0x26]
;;;1013   
;;;1014   				//sprintf(str,"CalRa= %d RA CutSoc = %d AvgI=%f", 
;;;1015   				//		mAppScuGauage.Cal_RaValue,
;;;1016   				///		mAppScuGauage.CutOffSoc,
;;;1017   				//		cur
;;;1018   				//		);
;;;1019   				//scuDebugMsg(str);
;;;1020   				
;;;1021   				gaugeSetRmAndFcc(nowsoc);
0000c4  4628              MOV      r0,r5
0000c6  f7fffffe          BL       gaugeSetRmAndFcc
;;;1022   				if(mAppScuGauage.EvtHandler)
0000ca  f8d63168          LDR      r3,[r6,#0x168]  ; mAppScuGauage
0000ce  b16b              CBZ      r3,|L31.236|
;;;1023   				{
;;;1024   					mAppScuGauage.EvtHandler(0, APP_GAUGE_EVENT_CAL_RA1+i, &mAppScuGauage.Cal_RaValue);
0000d0  4a10              LDR      r2,|L31.276|
0000d2  f1040128          ADD      r1,r4,#0x28
0000d6  3272              ADDS     r2,r2,#0x72
0000d8  460c              MOV      r4,r1
0000da  2000              MOVS     r0,#0
0000dc  4798              BLX      r3
;;;1025   					mAppScuGauage.EvtHandler(0, APP_GAUGE_EVENT_CAL_RA1+i, &mAppScuGauage.CutOffSoc);
0000de  4a0d              LDR      r2,|L31.276|
0000e0  f8d63168          LDR      r3,[r6,#0x168]  ; mAppScuGauage
0000e4  3226              ADDS     r2,r2,#0x26
0000e6  4621              MOV      r1,r4
0000e8  2000              MOVS     r0,#0
0000ea  4798              BLX      r3
                  |L31.236|
;;;1026   					
;;;1027   					//j--SaveFaultData(EVENT_CAL_RA1+i,BatteryCapInfo[area].Cal_RaValue);	//
;;;1028   					//j--SaveFaultData(EVENT_CAL_RA1+i,BatteryCapInfo[area].CutOffSoc);	//
;;;1029   				}
;;;1030   				mAppScuGauage.CalRaIdleTimer = 10;
0000ec  200a              MOVS     r0,#0xa
0000ee  f8860076          STRB     r0,[r6,#0x76]
                  |L31.242|
;;;1031   			}
;;;1032   			else
;;;1033   			{
;;;1034   				//scuDebugMsg("soc Vtable << Real Voltage !!!!!!!!");
;;;1035   			}
;;;1036   			break;
;;;1037   		}
;;;1038   		if(lastsoc>ed && nowsoc>ed)
;;;1039   		{
;;;1040   			if(mAppScuGauage.RmUpdateLastLevel != (i+1))
;;;1041   			{
;;;1042   				//sprintf(str,"???Leval=%d",i+1);
;;;1043   				//scuDebugMsg(str);
;;;1044   				;
;;;1045   			}
;;;1046   			mAppScuGauage.RmUpdateLastLevel = i + 1;
;;;1047   			break;
;;;1048   		}
;;;1049   	}
;;;1050   }
0000f2  ecbd8b02          VPOP     {d8}
0000f6  e8bd81f0          POP      {r4-r8,pc}
                  |L31.250|
0000fa  428a              CMP      r2,r1                 ;1038
0000fc  d905              BLS      |L31.266|
0000fe  428d              CMP      r5,r1                 ;1038
000100  d903              BLS      |L31.266|
000102  1c64              ADDS     r4,r4,#1              ;1046
000104  f886402c          STRB     r4,[r6,#0x2c]         ;1046
000108  e7f3              B        |L31.242|
                  |L31.266|
00010a  b2c4              UXTB     r4,r0                 ;987
                  |L31.268|
00010c  2c00              CMP      r4,#0                 ;987
00010e  d187              BNE      |L31.32|
000110  e7ef              B        |L31.242|
;;;1051   
                          ENDP

000112  0000              DCW      0x0000
                  |L31.276|
                          DCD      ||.bss||
                  |L31.280|
000118  00000000          DCFD     0x40f86a0000000000 ; 100000
00011c  40f86a00

                          AREA ||i.baseInfoIni||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  baseInfoIni PROC
;;;1300   
;;;1301   static void baseInfoIni(void)
000000  b510              PUSH     {r4,lr}
;;;1302   {
000002  b09a              SUB      sp,sp,#0x68
;;;1303   	uint32_t	n1;
;;;1304   	char	str[100];
;;;1305   
;;;1306   	mAppScuGauage.RamSoc = apiRamLoadSoc();
000004  f7fffffe          BL       apiRamLoadSoc
000008  4c1c              LDR      r4,|L32.124|
00000a  82a0              STRH     r0,[r4,#0x14]
;;;1307   	if(mAppScuGauage.RamSoc == 0xffff)
00000c  f5a0417f          SUB      r1,r0,#0xff00
000010  39ff              SUBS     r1,r1,#0xff
000012  d102              BNE      |L32.26|
;;;1308   	{
;;;1309   		//scuDebugMsg("Ram Soc error");
;;;1310   		mAppScuGauage.RamSoc = 5000;
000014  f2413088          MOV      r0,#0x1388
000018  82a0              STRH     r0,[r4,#0x14]
                  |L32.26|
;;;1311   	}
;;;1312   	appGaugeSetQmax(apiSysParGetQmax());
00001a  f7fffffe          BL       apiSysParGetQmax
00001e  f7fffffe          BL       appGaugeSetQmax
;;;1313   	
;;;1314   	mAppScuGauage.QmaxUpdateTimes.i = apiSysParGetQmaxUpdateTimes();
000022  f7fffffe          BL       apiSysParGetQmaxUpdateTimes
000026  8320              STRH     r0,[r4,#0x18]
;;;1315   	mAppScuGauage.CycleCount.i = apiSysParGetCycleCount();
000028  f7fffffe          BL       apiSysParGetCycleCount
00002c  8360              STRH     r0,[r4,#0x1a]
;;;1316   
;;;1317   	loadTotalDischargeCountFromRam();
00002e  f7fffffe          BL       loadTotalDischargeCountFromRam
;;;1318   	setupIdleTime();
000032  f7fffffe          BL       setupIdleTime
;;;1319   	
;;;1320   //	mAppScuGauage.Qmax.l = apiSysParGetQmax();
;;;1321   //	mAppScuGauage.QmaxuAms.ll = mAppScuGauage.Qmax.l;
;;;1322   //	mAppScuGauage.QmaxuAms.ll *= (1000u * 3600u * 1000u);
;;;1323   	
;;;1324   	mAppScuGauage.SocBase = mAppScuGauage.RamSoc;
000036  8aa0              LDRH     r0,[r4,#0x14]  ; mAppScuGauage
000038  82e0              STRH     r0,[r4,#0x16]
;;;1325   	n1 = (DWORD)(10000L - mAppScuGauage.RamSoc);
00003a  f2427310          MOV      r3,#0x2710
00003e  1a1a              SUBS     r2,r3,r0
;;;1326   	n1 *= mAppScuGauage.Qmax.l;
000040  6b61              LDR      r1,[r4,#0x34]  ; mAppScuGauage
000042  4351              MULS     r1,r2,r1
;;;1327   	n1 /= 10000L;
000044  fbb1f1f3          UDIV     r1,r1,r3
;;;1328   	mAppScuGauage.Qstart.l = n1;
000048  62a1              STR      r1,[r4,#0x28]  ; mAppScuGauage
;;;1329   	gaugeSetRmAndFcc(mAppScuGauage.RamSoc);
00004a  f7fffffe          BL       gaugeSetRmAndFcc
;;;1330   	mAppScuGauage.DisplaySocValue.i = mAppScuGauage.RsocValue.i;
00004e  f8b40154          LDRH     r0,[r4,#0x154]  ; mAppScuGauage
000052  f8a40152          STRH     r0,[r4,#0x152]
;;;1331   	mAppScuGauage.LastRsocValue = mAppScuGauage.RsocValue.i;
000056  f8a4015e          STRH     r0,[r4,#0x15e]
;;;1332   	mAppScuGauage.TerminateVoltage = apiSysParGetTerminateVoltage();
00005a  f7fffffe          BL       apiSysParGetTerminateVoltage
00005e  f8a40156          STRH     r0,[r4,#0x156]
;;;1333   
;;;1334   	mAppScuGauage.CutOffSoc = getTerminateSocFromOcvTable();
000062  f7fffffe          BL       getTerminateSocFromOcvTable
000066  84e0              STRH     r0,[r4,#0x26]
;;;1335   	sprintf(str,"CutSoc = %d", mAppScuGauage.CutOffSoc);
000068  4602              MOV      r2,r0
00006a  a105              ADR      r1,|L32.128|
00006c  a801              ADD      r0,sp,#4
00006e  f7fffffe          BL       __2sprintf
;;;1336   	scuDebugMsg(str);
000072  a801              ADD      r0,sp,#4
000074  f7fffffe          BL       appSerialCanDavinciSendTextMessage
;;;1337   //	mAppScuGauage.FCC.l = 280u * 1000u;
;;;1338   }
000078  b01a              ADD      sp,sp,#0x68
00007a  bd10              POP      {r4,pc}
;;;1339   
                          ENDP

                  |L32.124|
                          DCD      ||.bss||
                  |L32.128|
000080  43757453          DCB      "CutSoc = %d",0
000084  6f63203d
000088  20256400

                          AREA ||i.chargeModeIni||, CODE, READONLY, ALIGN=2

                  chargeModeIni PROC
;;;159    
;;;160    static void chargeModeIni(void)
000000  4802              LDR      r0,|L33.12|
;;;161    {
;;;162    	mAppScuGauage.ChargeMode = APP_SCU_GAUGE_RELEASE_MODE;
000002  2100              MOVS     r1,#0
000004  7041              STRB     r1,[r0,#1]
;;;163    	mAppScuGauage.ChargeModeTemp = APP_SCU_GAUGE_UNKNOW_MODE;
000006  2103              MOVS     r1,#3
000008  7081              STRB     r1,[r0,#2]
;;;164    }
00000a  4770              BX       lr
;;;165    
                          ENDP

                  |L33.12|
                          DCD      ||.bss||

                          AREA ||i.gaugeCalAvgCurrent||, CODE, READONLY, ALIGN=2

                  gaugeCalAvgCurrent PROC
;;;542    }
;;;543    static void gaugeCalAvgCurrent(void)
000000  b570              PUSH     {r4-r6,lr}
;;;544    {
000002  ed2d8b04          VPUSH    {d8-d9}
;;;545    	double	d1,d2;
;;;546    	DWORD	curmA;
;;;547    	DWORD	diff;
;;;548    	DWORD	dI;
;;;549    	char	str[100];
;;;550    	static	double	avg;
;;;551    			
;;;552    	if(mAppScuGauage.FirstReadCurrentFlag)
000006  4c26              LDR      r4,|L34.160|
;;;553    	{
;;;554    		//scuDebugMsg("First");
;;;555    		mAppScuGauage.FirstReadCurrentFlag = 0;
;;;556    		avg = (double)abs(appGaugeGetCurrentValue());
000008  4d26              LDR      r5,|L34.164|
00000a  f8940165          LDRB     r0,[r4,#0x165]        ;552  ; mAppScuGauage
00000e  2800              CMP      r0,#0                 ;552
000010  d00e              BEQ      |L34.48|
000012  2000              MOVS     r0,#0                 ;555
000014  f8840165          STRB     r0,[r4,#0x165]        ;555
000018  f7fffffe          BL       appGaugeGetCurrentValue
00001c  2800              CMP      r0,#0
00001e  da00              BGE      |L34.34|
000020  4240              RSBS     r0,r0,#0
                  |L34.34|
000022  f7fffffe          BL       __aeabi_i2d
000026  e9c50102          STRD     r0,r1,[r5,#8]
                  |L34.42|
;;;557    		//mAppScuGauage.AbsAvggCurrent= (double)abs(appGaugeGetCurrentValue());
;;;558    		//CellRAvgCurrent[area]=(double)curmA;
;;;559    	}
;;;560    	else
;;;561    	{
;;;562    		d1 = avg;//mAppScuGauage.AbsAvggCurrent;
;;;563    		d1 *= 19.0;
;;;564    		d1 /= 20.0;
;;;565    		d2 = (double)abs(appGaugeGetCurrentValue());
;;;566    		d2 /= (double)(20.0);
;;;567    		//sprintf(str, "Avg %f %f", d1, d2);
;;;568    		//scuDebugMsg(str);
;;;569    		
;;;570    		d1 += d2;
;;;571    		avg = d1;
;;;572    		mAppScuGauage.AbsAvggCurrent = (DWORD)d1;
;;;573    		//------------------------------
;;;574    		//d1=CellRAvgCurrent[area]*((double)9.0/(double)10.0);
;;;575    		//d2=(double)curmA/(double)(10.0);
;;;576    		//d1+=d2;
;;;577    		//CellRAvgCurrent[area]=d1;
;;;578    	}
;;;579    }		
00002a  ecbd8b04          VPOP     {d8-d9}
00002e  bd70              POP      {r4-r6,pc}
                  |L34.48|
000030  ed950b02          VLDR     d0,[r5,#8]            ;562
000034  ed9f1b1c          VLDR     d1,|L34.168|
000038  ec510b10          VMOV     r0,r1,d0              ;563
00003c  ec532b11          VMOV     r2,r3,d1              ;563
000040  f7fffffe          BL       __aeabi_dmul
000044  ec410b10          VMOV     d0,r0,r1              ;563
000048  ed9f9b19          VLDR     d9,|L34.176|
00004c  ec510b10          VMOV     r0,r1,d0              ;564
000050  ec532b19          VMOV     r2,r3,d9              ;564
000054  f7fffffe          BL       __aeabi_ddiv
000058  ec410b18          VMOV     d8,r0,r1              ;564
00005c  f7fffffe          BL       appGaugeGetCurrentValue
000060  2800              CMP      r0,#0                 ;565
000062  da00              BGE      |L34.102|
000064  4240              RSBS     r0,r0,#0              ;565
                  |L34.102|
000066  f7fffffe          BL       __aeabi_i2d
00006a  ec410b10          VMOV     d0,r0,r1              ;565
00006e  ec532b19          VMOV     r2,r3,d9              ;566
000072  ec510b10          VMOV     r0,r1,d0              ;566
000076  f7fffffe          BL       __aeabi_ddiv
00007a  ec410b10          VMOV     d0,r0,r1              ;566
00007e  ec510b18          VMOV     r0,r1,d8              ;570
000082  ec532b10          VMOV     r2,r3,d0              ;570
000086  f7fffffe          BL       __aeabi_dadd
00008a  ec410b10          VMOV     d0,r0,r1              ;570
00008e  ed850b02          VSTR     d0,[r5,#8]            ;571
000092  ec510b10          VMOV     r0,r1,d0              ;572
000096  f7fffffe          BL       __aeabi_d2uiz
00009a  f8c40160          STR      r0,[r4,#0x160]        ;572  ; mAppScuGauage
00009e  e7c4              B        |L34.42|
;;;580    
                          ENDP

                  |L34.160|
                          DCD      ||.bss||
                  |L34.164|
                          DCD      ||.data||
                  |L34.168|
0000a8  00000000          DCFD     0x4033000000000000 ; 19
0000ac  40330000
                  |L34.176|
0000b0  00000000          DCFD     0x4034000000000000 ; 20
0000b4  40340000

                          AREA ||i.gaugeCalCapacity||, CODE, READONLY, ALIGN=2

                  gaugeCalCapacity PROC
;;;580    
;;;581    static void gaugeCalCapacity(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;582    {
;;;583    	char	str[100];
;;;584    	uint64_t	CalRmValue;
;;;585    
;;;586    	if(mAppScuGauage.GaugeTickMs == 0)
000004  4e44              LDR      r6,|L35.280|
000006  7834              LDRB     r4,[r6,#0]  ; mAppScuGauage
000008  2c00              CMP      r4,#0
00000a  d05b              BEQ      |L35.196|
;;;587    		return;
;;;588    	CalRmValue = mAppScuGauage.GaugeTickMs;
00000c  2700              MOVS     r7,#0
00000e  463d              MOV      r5,r7
;;;589    	CalRmValue *= (uint64_t)abs(appGaugeGetCurrentValue());
000010  f7fffffe          BL       appGaugeGetCurrentValue
000014  2800              CMP      r0,#0
000016  da00              BGE      |L35.26|
000018  4240              RSBS     r0,r0,#0
                  |L35.26|
00001a  4621              MOV      r1,r4
00001c  fba04301          UMULL    r4,r3,r0,r1
000020  17c2              ASRS     r2,r0,#31
000022  fb023101          MLA      r1,r2,r1,r3
000026  fb001505          MLA      r5,r0,r5,r1
;;;590    	CalRmValue *= 1000u;	//uA
00002a  f44f707a          MOV      r0,#0x3e8
00002e  fba41300          UMULL    r1,r3,r4,r0
000032  fb053000          MLA      r0,r5,r0,r3
000036  2200              MOVS     r2,#0
000038  fb040502          MLA      r5,r4,r2,r0
00003c  460c              MOV      r4,r1
;;;591    	
;;;592    	mAppScuGauage.GaugeTickMs = 0;
00003e  7037              STRB     r7,[r6,#0]
;;;593    	//sprintf(str, "%u", CalRmValue); 
;;;594    	//appScuGaugeDebugMsg(str);
;;;595    
;;;596    //	mAppScuGauage.TimeTickMs = 0;
;;;597    	gaugeUpdateCurrentMode();
000040  f7fffffe          BL       gaugeUpdateCurrentMode
;;;598    	gaugeCalAvgCurrent();
000044  f7fffffe          BL       gaugeCalAvgCurrent
;;;599    	
;;;600    	if(appGaugeGetCurrentMode() == APP_SCU_GAUGE_CHARGE_MODE)
000048  f7fffffe          BL       appGaugeGetCurrentMode
;;;601    	{
;;;602    		mAppScuGauage.RM.ll += CalRmValue; 
;;;603    		if(mAppScuGauage.RM.ll > mAppScuGauage.QmaxuAms.ll)
;;;604    			mAppScuGauage.RM.ll = mAppScuGauage.QmaxuAms.ll;
;;;605    
;;;606    		//sprintf(str,"Charge Mode %u %d",
;;;607    		//			mAppScuGauage.RM.ll,
;;;608    		//			appScuGaugeCvtRmTomAh());
;;;609    		
;;;610    		//appScuGaugeDebugMsg(str);
;;;611    
;;;612    		//----------------------------------
;;;613    		if(mAppScuGauage.Soc0Valid)	//有抓到有效的Soc0,可以計算Qmax PassCharge
;;;614    		{
;;;615    			if(mAppScuGauage.QmaxStatus==0)
;;;616    			{
;;;617    				if(mAppScuGauage.EvtHandler)
;;;618    					mAppScuGauage.EvtHandler(0,APP_GAUGE_EVENT_START_CHG_SOC,0);
;;;619    				
;;;620    			//		SaveFaultData(EVENT_START_CHG_SOC,BatteryCapInfo[area].Soc0);	//記錄休息五小時之後開始充電的Soc
;;;621    				
;;;622    				mAppScuGauage.StarCalQmaxSoc = mAppScuGauage.Soc0;
;;;623    				mAppScuGauage.QmaxStatus = 1;
00004c  2701              MOVS     r7,#1
00004e  2802              CMP      r0,#2                 ;600
000050  d00f              BEQ      |L35.114|
;;;624    			}	
;;;625    			mAppScuGauage.QmaxPassCharge.sll += CalRmValue;	
;;;626    		}
;;;627    		mAppScuGauage.RaPassCharge.sll += CalRmValue;
;;;628    	}
;;;629    	else if(appGaugeGetCurrentMode() == APP_SCU_GAUGE_DISCHARGE_MODE)
000052  f7fffffe          BL       appGaugeGetCurrentMode
000056  2801              CMP      r0,#1
000058  d134              BNE      |L35.196|
;;;630    	{
;;;631    		//appScuGaugeDebugMsg("DisCharge Mode");
;;;632    		
;;;633    		if(mAppScuGauage.RM.ll >= CalRmValue)
00005a  e9d60116          LDRD     r0,r1,[r6,#0x58]
00005e  1b02              SUBS     r2,r0,r4
000060  eb710205          SBCS     r2,r1,r5
000064  d330              BCC      |L35.200|
;;;634    			mAppScuGauage.RM.ll -= CalRmValue; 
000066  1b00              SUBS     r0,r0,r4
000068  eb610105          SBC      r1,r1,r5
00006c  e9c60116          STRD     r0,r1,[r6,#0x58]
000070  e02d              B        |L35.206|
                  |L35.114|
000072  e9d60116          LDRD     r0,r1,[r6,#0x58]      ;602
000076  1900              ADDS     r0,r0,r4              ;602
000078  4169              ADCS     r1,r1,r5              ;602
00007a  e9c60116          STRD     r0,r1,[r6,#0x58]      ;602
00007e  e9d6230e          LDRD     r2,r3,[r6,#0x38]      ;603
000082  1a10              SUBS     r0,r2,r0              ;603
000084  eb730001          SBCS     r0,r3,r1              ;603
000088  d201              BCS      |L35.142|
00008a  e9c62316          STRD     r2,r3,[r6,#0x58]      ;604
                  |L35.142|
00008e  f8960020          LDRB     r0,[r6,#0x20]         ;613  ; mAppScuGauage
000092  b188              CBZ      r0,|L35.184|
000094  7fb0              LDRB     r0,[r6,#0x1e]         ;615  ; mAppScuGauage
000096  b948              CBNZ     r0,|L35.172|
000098  f8d63168          LDR      r3,[r6,#0x168]        ;617  ; mAppScuGauage
00009c  b11b              CBZ      r3,|L35.166|
00009e  2200              MOVS     r2,#0                 ;618
0000a0  4611              MOV      r1,r2                 ;618
0000a2  4610              MOV      r0,r2                 ;618
0000a4  4798              BLX      r3                    ;618
                  |L35.166|
0000a6  89f0              LDRH     r0,[r6,#0xe]          ;622  ; mAppScuGauage
0000a8  8230              STRH     r0,[r6,#0x10]         ;622
0000aa  77b7              STRB     r7,[r6,#0x1e]         ;623
                  |L35.172|
0000ac  e9d61012          LDRD     r1,r0,[r6,#0x48]      ;625
0000b0  1909              ADDS     r1,r1,r4              ;625
0000b2  4168              ADCS     r0,r0,r5              ;625
0000b4  e9c61012          STRD     r1,r0,[r6,#0x48]      ;625
                  |L35.184|
0000b8  e9d61014          LDRD     r1,r0,[r6,#0x50]      ;627
0000bc  1909              ADDS     r1,r1,r4              ;627
0000be  4168              ADCS     r0,r0,r5              ;627
0000c0  e9c61014          STRD     r1,r0,[r6,#0x50]      ;627
                  |L35.196|
;;;635    		else
;;;636    			mAppScuGauage.RM.ll = 0;	
;;;637    			
;;;638    		
;;;639    		//------------------------------
;;;640    		if(mAppScuGauage.Soc0Valid)	//有抓到有效的Soc0,可以計算Qmax PassCharge
;;;641    		{
;;;642    			if(mAppScuGauage.QmaxStatus==0)
;;;643    			{
;;;644    //					char	str[100];
;;;645    				if(mAppScuGauage.EvtHandler)
;;;646    					mAppScuGauage.EvtHandler(0,APP_GAUGE_EVENT_START_DHG_SOC, &mAppScuGauage.Soc0);
;;;647    
;;;648    				//SaveFaultData(EVENT_START_DHG_SOC,BatteryCapInfo[area].Soc0);	//記錄休息五小時之後開始放電的Soc
;;;649    
;;;650    				mAppScuGauage.StarCalQmaxSoc = mAppScuGauage.Soc0;
;;;651    				mAppScuGauage.QmaxStatus = 1;
;;;652    //					sprintf(str,"設定 StarCalQmaxSoc=%d",BatteryCapInfo.Soc0);
;;;653    //					SendUartMessage((BYTE *)str);
;;;654    			}	
;;;655    			mAppScuGauage.QmaxPassCharge.sll -= CalRmValue;	//累計開始放電的容量			
;;;656    		}
;;;657    		mAppScuGauage.TotalDisChargeCount.ll += CalRmValue;	//累計放電的容量,用於計算 Cycle count
;;;658    		mAppScuGauage.RaPassCharge.sll -= CalRmValue;
;;;659    	}
;;;660    }
0000c4  e8bd81f0          POP      {r4-r8,pc}
                  |L35.200|
0000c8  2100              MOVS     r1,#0                 ;636
0000ca  65b1              STR      r1,[r6,#0x58]         ;636  ; mAppScuGauage
0000cc  65f1              STR      r1,[r6,#0x5c]         ;636  ; mAppScuGauage
                  |L35.206|
0000ce  f8960020          LDRB     r0,[r6,#0x20]         ;640  ; mAppScuGauage
0000d2  b198              CBZ      r0,|L35.252|
0000d4  7fb0              LDRB     r0,[r6,#0x1e]         ;642  ; mAppScuGauage
0000d6  b950              CBNZ     r0,|L35.238|
0000d8  f8d63168          LDR      r3,[r6,#0x168]        ;645  ; mAppScuGauage
0000dc  b123              CBZ      r3,|L35.232|
0000de  4a0e              LDR      r2,|L35.280|
0000e0  2101              MOVS     r1,#1                 ;646
0000e2  320e              ADDS     r2,r2,#0xe            ;646
0000e4  2000              MOVS     r0,#0                 ;646
0000e6  4798              BLX      r3                    ;646
                  |L35.232|
0000e8  89f0              LDRH     r0,[r6,#0xe]          ;650  ; mAppScuGauage
0000ea  8230              STRH     r0,[r6,#0x10]         ;650
0000ec  77b7              STRB     r7,[r6,#0x1e]         ;651
                  |L35.238|
0000ee  e9d61012          LDRD     r1,r0,[r6,#0x48]      ;655
0000f2  1b09              SUBS     r1,r1,r4              ;655
0000f4  eb600005          SBC      r0,r0,r5              ;655
0000f8  e9c61012          STRD     r1,r0,[r6,#0x48]      ;655
                  |L35.252|
0000fc  e9d61010          LDRD     r1,r0,[r6,#0x40]      ;657
000100  1909              ADDS     r1,r1,r4              ;657
000102  4168              ADCS     r0,r0,r5              ;657
000104  e9c61010          STRD     r1,r0,[r6,#0x40]      ;657
000108  e9d61014          LDRD     r1,r0,[r6,#0x50]      ;658
00010c  1b09              SUBS     r1,r1,r4              ;658
00010e  eb600005          SBC      r0,r0,r5              ;658
000112  e9c61014          STRD     r1,r0,[r6,#0x50]      ;658
000116  e7d5              B        |L35.196|
;;;661    //------------------------------------
                          ENDP

                  |L35.280|
                          DCD      ||.bss||

                          AREA ||i.gaugeCalCellRValue||, CODE, READONLY, ALIGN=2

                  gaugeCalCellRValue PROC
;;;381    //	根據 BatteryCapInfo[area].RamSoc 的值取得目前Ocv Table 電壓值
;;;382    static void gaugeCalCellRValue(void)
000000  b510              PUSH     {r4,lr}
;;;383    {
000002  ed2d8b06          VPUSH    {d8-d10}
;;;384    	WORD		SocTabVoltage;
;;;385    	WORD		RealVoltage;
;;;386    	double		cur,newRa;
;;;387    	char		str[100];
;;;388    	
;;;389    	//j-- if(SystemParameter.CalRTimer[area]<50)
;;;390    //		return;
;;;391    	
;;;392    //j--	if(SystemParameter.CellRAvgCurrentTimer[area]<10)	//等待電流穩定 1 Sec 之後才可計算內阻	
;;;393    //		return;
;;;394    	
;;;395    //j--	SystemParameter.CalRTimer[area]=0;
;;;396    	
;;;397    	SocTabVoltage = GetOcvVoltage(mAppScuGauage.RamSoc);
000006  4824              LDR      r0,|L36.152|
000008  8a80              LDRH     r0,[r0,#0x14]  ; mAppScuGauage
00000a  f7fffffe          BL       GetOcvVoltage
00000e  4604              MOV      r4,r0
;;;398    	RealVoltage = GetAverageCellVoltage();
000010  f7fffffe          BL       GetAverageCellVoltage
000014  4601              MOV      r1,r0
;;;399    	
;;;400    	//sprintf(str,"Cal RValue =%d %d ",
;;;401    	//				SocTabVoltage,
;;;402    	//				RealVoltage);
;;;403    	//scuDebugMsg(str);
;;;404    	if(appGaugeGetCurrentMode() == APP_SCU_GAUGE_DISCHARGE_MODE)	//放電模式
000016  f7fffffe          BL       appGaugeGetCurrentMode
00001a  2801              CMP      r0,#1
00001c  d031              BEQ      |L36.130|
;;;405    	{
;;;406    		//scuDebugMsg("Discharge ");
;;;407    		if(SocTabVoltage > RealVoltage)
;;;408    		{
;;;409    			newRa = (double)(SocTabVoltage - RealVoltage);
;;;410    		}
;;;411    		else
;;;412    		{
;;;413    //			strcat(str," Last R1 ");
;;;414    			//scuDebugMsg("放電條件錯誤,無法計算內阻");
;;;415    			return;
;;;416    			//goto _exit;
;;;417    		}
;;;418    	}	
;;;419    	else if(appGaugeGetCurrentMode() == APP_SCU_GAUGE_CHARGE_MODE)
00001e  f7fffffe          BL       appGaugeGetCurrentMode
000022  2802              CMP      r0,#2
000024  d135              BNE      |L36.146|
;;;420    	{
;;;421    		//-------------------------------
;;;422    		//	實際電壓值		
;;;423    		if(RealVoltage>SocTabVoltage)
000026  42a1              CMP      r1,r4
000028  d933              BLS      |L36.146|
;;;424    		{
;;;425    			newRa=(double)(RealVoltage-SocTabVoltage);
00002a  1b08              SUBS     r0,r1,r4
00002c  f7fffffe          BL       __aeabi_i2d
000030  ec410b18          VMOV     d8,r0,r1
                  |L36.52|
;;;426    		}
;;;427    		else
;;;428    		{
;;;429    	//		strcat(str," Last R2 ");
;;;430    			//SendMessageToCan("充電條件錯誤,無法計算內阻");
;;;431    			return;
;;;432    			//goto _exit;
;;;433    		}
;;;434    	}
;;;435    	else	//無充放電模式,無法計算內阻,改以Ra Table 為主?
;;;436    	{
;;;437    		//strcat(str," Last R3 ");
;;;438    		return;
;;;439    		//goto _exit;
;;;440    	}
;;;441    	//----------------------------------
;;;442    	//	計算實際內阻
;;;443    	;//j-- cur = (double)SystemParameter.CellRAvgCurrent[area].l;	//mA
;;;444    //	sprintf(str,"RA1= %d",(DWORD) newRa);
;;;445    //	scuDebugMsg(str);
;;;446    	
;;;447    	cur = abs(appGaugeGetCurrentValue());
000034  f7fffffe          BL       appGaugeGetCurrentValue
;;;448    //	sprintf(str,"curr= %d",(DWORD) cur);
;;;449    //	scuDebugMsg(str);
;;;450    	
;;;451    	newRa *= 100000.0;	//0.01mR
;;;452    	newRa /= cur;		
;;;453    	if(newRa > 65535.0)
000038  ed9fab18          VLDR     d10,|L36.156|
00003c  2800              CMP      r0,#0                 ;447
00003e  da00              BGE      |L36.66|
000040  4240              RSBS     r0,r0,#0              ;447
                  |L36.66|
000042  f7fffffe          BL       __aeabi_i2d
000046  ec410b19          VMOV     d9,r0,r1              ;447
00004a  ed9f0b16          VLDR     d0,|L36.164|
00004e  ec510b18          VMOV     r0,r1,d8              ;451
000052  ec532b10          VMOV     r2,r3,d0              ;451
000056  f7fffffe          BL       __aeabi_dmul
00005a  ec410b10          VMOV     d0,r0,r1              ;451
00005e  ec532b19          VMOV     r2,r3,d9              ;452
000062  ec510b10          VMOV     r0,r1,d0              ;452
000066  f7fffffe          BL       __aeabi_ddiv
00006a  ec410b10          VMOV     d0,r0,r1              ;452
00006e  ec532b1a          VMOV     r2,r3,d10
000072  ecbd8b06          VPOP     {d8-d10}
000076  ec510b10          VMOV     r0,r1,d0
00007a  e8bd4010          POP      {r4,lr}
00007e  f7ffbffe          B.W      __aeabi_cdrcmple
                  |L36.130|
000082  428c              CMP      r4,r1                 ;407
000084  d905              BLS      |L36.146|
000086  1a60              SUBS     r0,r4,r1              ;409
000088  f7fffffe          BL       __aeabi_i2d
00008c  ec410b18          VMOV     d8,r0,r1              ;409
000090  e7d0              B        |L36.52|
                  |L36.146|
;;;454    		newRa = 65535.0;
;;;455    //	sprintf(str,"RA= %d",(DWORD) newRa);
;;;456    //	scuDebugMsg(str);
;;;457    	//j-- SystemParameter.CellRValue[area]=(WORD)newRa;
;;;458    }
000092  ecbd8b06          VPOP     {d8-d10}
000096  bd10              POP      {r4,pc}
;;;459    
                          ENDP

                  |L36.152|
                          DCD      ||.bss||
                  |L36.156|
00009c  00000000          DCFD     0x40efffe000000000 ; 65535
0000a0  40efffe0
                  |L36.164|
0000a4  00000000          DCFD     0x40f86a0000000000 ; 100000
0000a8  40f86a00

                          AREA ||i.gaugeCalSoc||, CODE, READONLY, ALIGN=2

                  gaugeCalSoc PROC
;;;199    //------------------------------------
;;;200    static void gaugeCalSoc(void)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202    	DWORD	n1;
;;;203    	n1 = appScuGaugeCvtRmTomAh();//...RM_mAh.l;
000002  f7fffffe          BL       appScuGaugeCvtRmTomAh
;;;204    	n1 *= 10000L;
000006  f2427110          MOV      r1,#0x2710
00000a  4348              MULS     r0,r1,r0
;;;205    	n1 /= mAppScuGauage.FCC.l;
00000c  4a05              LDR      r2,|L37.36|
00000e  6b11              LDR      r1,[r2,#0x30]  ; mAppScuGauage
000010  fbb0f0f1          UDIV     r0,r0,r1
;;;206    	if(n1 > 10000)
000014  f2427110          MOV      r1,#0x2710
000018  4288              CMP      r0,r1
00001a  d900              BLS      |L37.30|
;;;207    		n1 = 10000;
00001c  4608              MOV      r0,r1
                  |L37.30|
;;;208    	mAppScuGauage.RsocValue.i = n1;		//真正的Soc
00001e  f8a20154          STRH     r0,[r2,#0x154]
;;;209    }
000022  bd10              POP      {r4,pc}
;;;210    uint16_t GetAverageCellVoltage(void)
                          ENDP

                  |L37.36|
                          DCD      ||.bss||

                          AREA ||i.gaugeCheckCycleCount||, CODE, READONLY, ALIGN=2

                  gaugeCheckCycleCount PROC
;;;1051   
;;;1052   void gaugeCheckCycleCount(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1053   {
;;;1054   	tLLbyte		LLbyte;
;;;1055   	char	str[100];
;;;1056   	uint32_t	mAh;
;;;1057   	
;;;1058   	mAh = mAppScuGauage.TotalDisChargeCount.ll /(3600u * 1000u * 1000u);
000002  4c12              LDR      r4,|L38.76|
;;;1059   	
;;;1060   	LLbyte.ll = apiSysParGetDesignedCapacity();
000004  f7fffffe          BL       apiSysParGetDesignedCapacity
000008  2300              MOVS     r3,#0
00000a  4602              MOV      r2,r0
;;;1061   	LLbyte.ll *= (DDWORD)(3600000u * 800u);		//uA sec
00000c  4610              MOV      r0,r2
00000e  4d10              LDR      r5,|L38.80|
000010  2200              MOVS     r2,#0
000012  fba01605          UMULL    r1,r6,r0,r5
000016  fb036305          MLA      r3,r3,r5,r6
00001a  fb003202          MLA      r2,r0,r2,r3
00001e  e9cd1200          STRD     r1,r2,[sp,#0]
;;;1062   /*
;;;1063   	sprintf(str,"Cycle Count:%u %d / %d %.8lX%.8lX / %.8lX%.8lX",
;;;1064   			mAppScuGauage.CycleCount.i,
;;;1065   			mAh,
;;;1066   			apiSysParGetDesignedCapacity(),
;;;1067   			mAppScuGauage.TotalDisChargeCount.l[1],
;;;1068   			mAppScuGauage.TotalDisChargeCount.l[0],
;;;1069   			LLbyte.l[1],
;;;1070   			LLbyte.l[0]		
;;;1071   			);
;;;1072   		
;;;1073   	scuDebugMsg(str);
;;;1074   */	
;;;1075   	if(mAppScuGauage.TotalDisChargeCount.ll >= LLbyte.ll)
000022  e9d45610          LDRD     r5,r6,[r4,#0x40]
000026  1a68              SUBS     r0,r5,r1
000028  eb760002          SBCS     r0,r6,r2
00002c  d30c              BCC      |L38.72|
;;;1076   	{
;;;1077   		mAppScuGauage.TotalDisChargeCount.ll -= LLbyte.ll;
00002e  1a68              SUBS     r0,r5,r1
000030  eb660602          SBC      r6,r6,r2
000034  e9c40610          STRD     r0,r6,[r4,#0x40]
;;;1078   		mAppScuGauage.CycleCount.i++;
000038  8b60              LDRH     r0,[r4,#0x1a]  ; mAppScuGauage
00003a  1c40              ADDS     r0,r0,#1
00003c  b280              UXTH     r0,r0
00003e  8360              STRH     r0,[r4,#0x1a]
;;;1079   		apiSysParSetCycleCount(mAppScuGauage.CycleCount.i);
000040  e8bd407c          POP      {r2-r6,lr}
000044  f7ffbffe          B.W      apiSysParSetCycleCount
                  |L38.72|
;;;1080   	}
;;;1081   }
000048  bd7c              POP      {r2-r6,pc}
;;;1082   
                          ENDP

00004a  0000              DCW      0x0000
                  |L38.76|
                          DCD      ||.bss||
                  |L38.80|
                          DCD      0xaba95000

                          AREA ||i.gaugeCorrectCapacity||, CODE, READONLY, ALIGN=1

                  gaugeCorrectCapacity PROC
;;;1270   
;;;1271   static void gaugeCorrectCapacity(void)
000000  b510              PUSH     {r4,lr}
;;;1272   {
;;;1273   	gaugeCalSoc();	
000002  f7fffffe          BL       gaugeCalSoc
;;;1274   	gaugeCalCellRValue();
000006  f7fffffe          BL       gaugeCalCellRValue
;;;1275   	
;;;1276   	if(appGaugeGetCurrentMode() == APP_SCU_GAUGE_RELEASE_MODE)
00000a  f7fffffe          BL       appGaugeGetCurrentMode
00000e  b118              CBZ      r0,|L39.24|
;;;1277   		gaugeReleaseMode();
;;;1278   	else
;;;1279   	{
;;;1280   		scuGaugeUnReleasedMode();
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      scuGaugeUnReleasedMode
                  |L39.24|
000018  e8bd4010          POP      {r4,lr}               ;1277
00001c  f7ffbffe          B.W      gaugeReleaseMode
;;;1281   	}
;;;1282   	
;;;1283   }
;;;1284   
                          ENDP


                          AREA ||i.gaugeHwTimerHandler||, CODE, READONLY, ALIGN=2

                  gaugeHwTimerHandler PROC
;;;1405   }
;;;1406   static void gaugeHwTimerHandler(__far void *dest, uint16_t evt, void *vDataPtr)
000000  4802              LDR      r0,|L40.12|
;;;1407   {
;;;1408   	mAppScuGauage.GaugeTickMs++;
000002  7801              LDRB     r1,[r0,#0]  ; mAppScuGauage
000004  1c49              ADDS     r1,r1,#1
000006  7001              STRB     r1,[r0,#0]
;;;1409   }
000008  4770              BX       lr
;;;1410   
                          ENDP

00000a  0000              DCW      0x0000
                  |L40.12|
                          DCD      ||.bss||

                          AREA ||i.gaugeQPassChargeIni||, CODE, READONLY, ALIGN=2

                  gaugeQPassChargeIni PROC
;;;165    
;;;166    static void gaugeQPassChargeIni(void)
000000  4802              LDR      r0,|L41.12|
;;;167    {
;;;168    	mAppScuGauage.QmaxPassCharge.sll = 0;
000002  2200              MOVS     r2,#0
000004  6482              STR      r2,[r0,#0x48]  ; mAppScuGauage
000006  64c2              STR      r2,[r0,#0x4c]  ; mAppScuGauage
;;;169    }
000008  4770              BX       lr
;;;170    
                          ENDP

00000a  0000              DCW      0x0000
                  |L41.12|
                          DCD      ||.bss||

                          AREA ||i.gaugeRPassChargeIni||, CODE, READONLY, ALIGN=2

                  gaugeRPassChargeIni PROC
;;;170    
;;;171    static void gaugeRPassChargeIni(void)
000000  4802              LDR      r0,|L42.12|
;;;172    {
;;;173    	mAppScuGauage.RaPassCharge.sll = 0;
000002  2200              MOVS     r2,#0
000004  6502              STR      r2,[r0,#0x50]  ; mAppScuGauage
000006  6542              STR      r2,[r0,#0x54]  ; mAppScuGauage
;;;174    }
000008  4770              BX       lr
;;;175    
                          ENDP

00000a  0000              DCW      0x0000
                  |L42.12|
                          DCD      ||.bss||

                          AREA ||i.gaugeReleaseMode||, CODE, READONLY, ALIGN=2

                  gaugeReleaseMode PROC
;;;763    
;;;764    static void gaugeReleaseMode(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;765    {
000002  b099              SUB      sp,sp,#0x64
;;;766    	long		slong;
;;;767    	DWORD		n1,n2;
;;;768    	BYTE		Over5HrFlag;
;;;769    	BYTE		PlusFlag;
;;;770    	char	str[100];
;;;771    
;;;772    	if(mAppScuGauage.RelaxSec < 0xfff0)
000004  4c55              LDR      r4,|L43.348|
000006  f64f71f0          MOV      r1,#0xfff0
00000a  88e0              LDRH     r0,[r4,#6]  ; mAppScuGauage
00000c  4288              CMP      r0,r1
00000e  d201              BCS      |L43.20|
;;;773    		mAppScuGauage.RelaxSec++;
000010  1c40              ADDS     r0,r0,#1
000012  80e0              STRH     r0,[r4,#6]
                  |L43.20|
;;;774    	mAppScuGauage.ReadSocTime++;
000014  88a0              LDRH     r0,[r4,#4]  ; mAppScuGauage
000016  1c40              ADDS     r0,r0,#1
000018  b280              UXTH     r0,r0
00001a  80a0              STRH     r0,[r4,#4]
;;;775    	//scuDebugMsg("gaugeReleaseMode....0");
;;;776    	if(mAppScuGauage.ReadSocTime >= (30*60) )		//Relax 超過30分鐘
00001c  f5b06fe1          CMP      r0,#0x708
000020  d37d              BCC      |L43.286|
;;;777    	{
;;;778    		//scuDebugMsg("gaugeReleaseMode....1");
;;;779    		mAppScuGauage.ReadSocTime = (30*60-100);	//下次在100 sec 之後更新Soc 0
000022  f24060a4          MOV      r0,#0x6a4
000026  80a0              STRH     r0,[r4,#4]
;;;780    		mAppScuGauage.SocB_Voltage = GetAverageCellVoltage();
000028  f7fffffe          BL       GetAverageCellVoltage
00002c  81a0              STRH     r0,[r4,#0xc]
;;;781    		if(mAppScuGauage.SocReadNum == 0)
00002e  7f61              LDRB     r1,[r4,#0x1d]  ; mAppScuGauage
;;;782    		{
;;;783    			mAppScuGauage.SocA_Voltage = mAppScuGauage.SocB_Voltage;
;;;784    			mAppScuGauage.SocReadNum = 1;
000030  2601              MOVS     r6,#1
000032  b909              CBNZ     r1,|L43.56|
000034  8160              STRH     r0,[r4,#0xa]          ;783
000036  7766              STRB     r6,[r4,#0x1d]
                  |L43.56|
;;;785    //				SendUartMessage("第一次取樣SOC");
;;;786    		}			
;;;787    		if(mAppScuGauage.RelaxSec >= (5L*3600L))	//總Relax時間超過5小時,無條件設為Soc0 或更新Qmax
000038  88e0              LDRH     r0,[r4,#6]  ; mAppScuGauage
00003a  f2446150          MOV      r1,#0x4650
00003e  4288              CMP      r0,r1
000040  d30a              BCC      |L43.88|
;;;788    		{
;;;789    			if(!mAppScuGauage.Over5HrStatus)
000042  f8940077          LDRB     r0,[r4,#0x77]  ; mAppScuGauage
000046  b940              CBNZ     r0,|L43.90|
;;;790    			{
;;;791    				if(mAppScuGauage.EvtHandler)
000048  f8d43168          LDR      r3,[r4,#0x168]  ; mAppScuGauage
00004c  b12b              CBZ      r3,|L43.90|
;;;792    					mAppScuGauage.EvtHandler(0,APP_GAUGE_EVENT_IDLE_OVER_5HR, 0);
00004e  2200              MOVS     r2,#0
000050  2102              MOVS     r1,#2
000052  4610              MOV      r0,r2
000054  4798              BLX      r3
000056  e000              B        |L43.90|
                  |L43.88|
;;;793    
;;;794    				;//j--	SaveFaultData(EVENT_IDLE_OVER_5HR,area);
;;;795    					//BatteryCapInfo.Over5HrStatus=1;
;;;796    			}
;;;797    				//BatteryCapInfo.RelaxSec=0;
;;;798    			;//j-- Over5HrFlag=TRUE;				
;;;799    			//j--	goto _Update_Soc0;
;;;800    		}
;;;801    		else
;;;802    			Over5HrFlag = 0;
000058  2500              MOVS     r5,#0
                  |L43.90|
;;;803    				
;;;804    			//if(BatteryCapInfo.SocB_Voltage>=BatteryCapInfo.SocA_Voltage)
;;;805    			//	SocDeltaVoltage=BatteryCapInfo.SocB_Voltage-BatteryCapInfo.SocA_Voltage;
;;;806    			//else
;;;807    			//	SocDeltaVoltage=BatteryCapInfo.SocA_Voltage-BatteryCapInfo.SocB_Voltage;
;;;808    			mAppScuGauage.SocA_Voltage = mAppScuGauage.SocB_Voltage;
00005a  89a0              LDRH     r0,[r4,#0xc]  ; mAppScuGauage
00005c  8160              STRH     r0,[r4,#0xa]
;;;809    			//if(SocDeltaVoltage>40)	//dv/dt <40uV 才可以識為正確的Soc
;;;810    		if(1)						//6813 最低解析度為100uV
;;;811    		{
;;;812    				//SendUartMessage("Soc 壓差大於40uV");
;;;813    			;//j--	goto _exit;
;;;814    		}
;;;815    //			SendUartMessage("Soc 壓差小於40uV");
;;;816    //_Update_Soc0:
;;;817    		//scuDebugMsg("_Update_Soc0");
;;;818    		getSocTableUseAvgCellVoltage();
00005e  f7fffffe          BL       getSocTableUseAvgCellVoltage
;;;819    		if(mAppScuGauage.NowSocValid)	//有效的 SOC
000062  7fe0              LDRB     r0,[r4,#0x1f]  ; mAppScuGauage
000064  b388              CBZ      r0,|L43.202|
;;;820    		{
;;;821    			//scuDebugMsg("gaugeReleaseMode....2");
;;;822    			if(Over5HrFlag && (!mAppScuGauage.Over5HrStatus ||
000066  b165              CBZ      r5,|L43.130|
000068  f8940077          LDRB     r0,[r4,#0x77]  ; mAppScuGauage
00006c  b108              CBZ      r0,|L43.114|
;;;823    				mAppScuGauage.Over5HrStatus==2))
00006e  2802              CMP      r0,#2
000070  d107              BNE      |L43.130|
                  |L43.114|
;;;824    			{
;;;825    				if(mAppScuGauage.EvtHandler)
000072  f8d43168          LDR      r3,[r4,#0x168]  ; mAppScuGauage
000076  b123              CBZ      r3,|L43.130|
;;;826    					mAppScuGauage.EvtHandler(0, APP_GAUGE_EVENT_GET_5HR_SOC, &mAppScuGauage.NowSoc);
000078  4a38              LDR      r2,|L43.348|
00007a  2106              MOVS     r1,#6
00007c  3208              ADDS     r2,r2,#8
00007e  2000              MOVS     r0,#0
000080  4798              BLX      r3
                  |L43.130|
;;;827    				;//j--	SaveFaultData(EVENT_GET_5HR_SOC,BatteryCapInfo[area].NowSoc);				
;;;828    			}
;;;829    			mAppScuGauage.Over5HrStatus = 1;
000082  f8846077          STRB     r6,[r4,#0x77]
;;;830    			//sprintf(str,"讀取到有效的Soc 0 = %d", mAppScuGauage.NowSoc);
;;;831    			scuDebugMsg(str);
000086  4668              MOV      r0,sp
000088  f7fffffe          BL       appSerialCanDavinciSendTextMessage
;;;832    			mAppScuGauage.Soc0Valid = 1;
00008c  f8846020          STRB     r6,[r4,#0x20]
;;;833    			mAppScuGauage.Soc0 = mAppScuGauage.NowSoc;
000090  8920              LDRH     r0,[r4,#8]  ; mAppScuGauage
000092  81e0              STRH     r0,[r4,#0xe]
;;;834    			mAppScuGauage.StartCalRaSoc = mAppScuGauage.Soc0;	//設定為有效的RA Soc
000094  8260              STRH     r0,[r4,#0x12]
;;;835    			mAppScuGauage.RaSocValid = 1;
000096  f8846021          STRB     r6,[r4,#0x21]
;;;836    			gaugeRPassChargeIni();							//設定Ra PassCharge 初始值
00009a  f7fffffe          BL       gaugeRPassChargeIni
;;;837    			mAppScuGauage.RamSoc = mAppScuGauage.NowSoc;
00009e  8920              LDRH     r0,[r4,#8]  ; mAppScuGauage
0000a0  82a0              STRH     r0,[r4,#0x14]
;;;838    			mAppScuGauage.SocBase = mAppScuGauage.RamSoc;
0000a2  82e0              STRH     r0,[r4,#0x16]
;;;839    			//---------------------------------
;;;840    			//	抓取新的截止點
;;;841    			mAppScuGauage.CutOffSoc = getTerminateSocFromOcvTable();
0000a4  f7fffffe          BL       getTerminateSocFromOcvTable
0000a8  84e0              STRH     r0,[r4,#0x26]
;;;842    			//--------------
;;;843    			//計算QStart
;;;844    			n1 = (10000L - mAppScuGauage.NowSoc);
0000aa  8920              LDRH     r0,[r4,#8]  ; mAppScuGauage
0000ac  f2427310          MOV      r3,#0x2710
0000b0  1a19              SUBS     r1,r3,r0
;;;845    			n1 *= mAppScuGauage.Qmax.l;
0000b2  6b62              LDR      r2,[r4,#0x34]  ; mAppScuGauage
0000b4  434a              MULS     r2,r1,r2
;;;846    			n1 /= 10000L;
0000b6  fbb2f1f3          UDIV     r1,r2,r3
;;;847    			mAppScuGauage.Qstart.l = n1;
0000ba  62a1              STR      r1,[r4,#0x28]  ; mAppScuGauage
;;;848    			gaugeSetRmAndFcc(mAppScuGauage.NowSoc);
0000bc  f7fffffe          BL       gaugeSetRmAndFcc
;;;849    			mAppScuGauage.DisplaySocValue.i = mAppScuGauage.RsocValue.i;
0000c0  f8b40154          LDRH     r0,[r4,#0x154]  ; mAppScuGauage
0000c4  f8a40152          STRH     r0,[r4,#0x152]
0000c8  e00e              B        |L43.232|
                  |L43.202|
0000ca  e7ff              B        |L43.204|
                  |L43.204|
;;;850    		}
;;;851    		else
;;;852    		{
;;;853    			if(Over5HrFlag && !mAppScuGauage.Over5HrStatus)
0000cc  b14d              CBZ      r5,|L43.226|
0000ce  f8940077          LDRB     r0,[r4,#0x77]  ; mAppScuGauage
0000d2  b930              CBNZ     r0,|L43.226|
;;;854    			{
;;;855    				if(mAppScuGauage.EvtHandler)
0000d4  f8d43168          LDR      r3,[r4,#0x168]  ; mAppScuGauage
0000d8  b11b              CBZ      r3,|L43.226|
;;;856    					mAppScuGauage.EvtHandler(0, APP_GAUGE_EVENT_CANNOT_GET_5HR_SOC, 0);
0000da  2200              MOVS     r2,#0
0000dc  2103              MOVS     r1,#3
0000de  4610              MOV      r0,r2
0000e0  4798              BLX      r3
                  |L43.226|
;;;857    
;;;858    				;//j--		SaveFaultData(EVENT_CANNOT_GET_5HR_SOC,0);		//無法讀取到正確的Soc
;;;859    			}
;;;860    			mAppScuGauage.Over5HrStatus = 2;
0000e2  2002              MOVS     r0,#2
0000e4  f8840077          STRB     r0,[r4,#0x77]
                  |L43.232|
;;;861    			;//j--	goto _exit;;
;;;862    		}
;;;863    		//----------------------------
;;;864    		//Relax-->DisCharge-->Relax,	Update Qmax
;;;865    		if(mAppScuGauage.QmaxStatus == 1)	
0000e8  7fa0              LDRB     r0,[r4,#0x1e]  ; mAppScuGauage
0000ea  2801              CMP      r0,#1
0000ec  d11a              BNE      |L43.292|
;;;866    		{
;;;867    			slong = (LONG)CvtQmaxPassChargeTomAh();
0000ee  f7fffffe          BL       CvtQmaxPassChargeTomAh
;;;868    			if(slong < 0)
0000f2  2800              CMP      r0,#0
0000f4  da01              BGE      |L43.250|
;;;869    				n1 = slong * (-1);
0000f6  4246              RSBS     r6,r0,#0
0000f8  e000              B        |L43.252|
                  |L43.250|
;;;870    			else
;;;871    				n1 = slong;
0000fa  4606              MOV      r6,r0
                  |L43.252|
;;;872    			//sprintf(str,"PassCharge 總容量=%d",n1);			
;;;873    			//SendUartMessage(str);		
;;;874    			if(mAppScuGauage.QmaxUpdateTimes.i == 0)	//第一次更新
0000fc  8b20              LDRH     r0,[r4,#0x18]  ; mAppScuGauage
0000fe  2700              MOVS     r7,#0
000100  b190              CBZ      r0,|L43.296|
;;;875    			{
;;;876    				n2 = (apiSysParGetDesignedCapacity() * 9L) / 10L;
;;;877    					//sprintf(str,"第一次更新允許容量:%d",n2);
;;;878    					//SendMessageToCan(str);
;;;879    				if(n1 >= n2)	
;;;880    				{
;;;881    					appScuGaugeUpdateQmax(n1,0);
;;;882    				}
;;;883    				else if(Over5HrFlag)	//第一次更新條件不成立而且Relax 總時間超過5小時，重設更新條件
;;;884    				{
;;;885    					mAppScuGauage.QmaxStatus = 0;	//重新設定更新條件
;;;886    					gaugeQPassChargeIni();
;;;887    				}
;;;888    			}
;;;889    			else
;;;890    			{
;;;891    				n2=(apiSysParGetDesignedCapacity() * 37L) / 100L;
000102  f7fffffe          BL       apiSysParGetDesignedCapacity
000106  eb000180          ADD      r1,r0,r0,LSL #2
00010a  eb011040          ADD      r0,r1,r0,LSL #5
00010e  2164              MOVS     r1,#0x64
000110  fbb0f0f1          UDIV     r0,r0,r1
;;;892    				if(n1 >= n2)
000114  4286              CMP      r6,r0
000116  d31b              BCC      |L43.336|
;;;893    				{
;;;894    					appScuGaugeUpdateQmax(n1, 2);
000118  2102              MOVS     r1,#2
00011a  4630              MOV      r0,r6
00011c  e000              B        |L43.288|
                  |L43.286|
00011e  e001              B        |L43.292|
                  |L43.288|
000120  f7fffffe          BL       appScuGaugeUpdateQmax
                  |L43.292|
;;;895    				}
;;;896    				else if(Over5HrFlag)	//第一次更新條件不成立而且Relax 總時間超過5小時，重設更新條件
;;;897    				{
;;;898    					mAppScuGauage.QmaxStatus = 0;	//重新設定更新條件
;;;899    					gaugeQPassChargeIni();
;;;900    				}
;;;901    			}
;;;902    		}	//if(BatteryCapInfo.QmaxStatus==1)	
;;;903    	}		
;;;904    	//---------
;;;905    //j--	CheckNotFullSoc();
;;;906    //	}	//if(ChargeMode==RELEASE_MODE)
;;;907    }
000124  b019              ADD      sp,sp,#0x64
000126  bdf0              POP      {r4-r7,pc}
                  |L43.296|
000128  f7fffffe          BL       apiSysParGetDesignedCapacity
00012c  eb0000c0          ADD      r0,r0,r0,LSL #3       ;876
000130  210a              MOVS     r1,#0xa               ;876
000132  fbb0f0f1          UDIV     r0,r0,r1              ;876
000136  4286              CMP      r6,r0                 ;879
000138  d304              BCC      |L43.324|
00013a  2100              MOVS     r1,#0                 ;881
00013c  4630              MOV      r0,r6                 ;881
00013e  f7fffffe          BL       appScuGaugeUpdateQmax
000142  e7ef              B        |L43.292|
                  |L43.324|
000144  2d00              CMP      r5,#0                 ;883
000146  d0ed              BEQ      |L43.292|
000148  77a7              STRB     r7,[r4,#0x1e]         ;885
00014a  f7fffffe          BL       gaugeQPassChargeIni
00014e  e7e9              B        |L43.292|
                  |L43.336|
000150  2d00              CMP      r5,#0                 ;896
000152  d0e7              BEQ      |L43.292|
000154  77a7              STRB     r7,[r4,#0x1e]         ;898
000156  f7fffffe          BL       gaugeQPassChargeIni
00015a  e7e3              B        |L43.292|
;;;908    
                          ENDP

                  |L43.348|
                          DCD      ||.bss||

                          AREA ||i.gaugeSetRmAndFcc||, CODE, READONLY, ALIGN=2

                  gaugeSetRmAndFcc PROC
;;;249    
;;;250    static void gaugeSetRmAndFcc(uint16_t soc)
000000  b570              PUSH     {r4-r6,lr}
;;;251    {
;;;252    	DDWORD	d,n;
;;;253    	if(soc >= mAppScuGauage.CutOffSoc)
000002  4d17              LDR      r5,|L44.96|
000004  8ce9              LDRH     r1,[r5,#0x26]  ; mAppScuGauage
000006  4281              CMP      r1,r0
000008  d802              BHI      |L44.16|
;;;254    		d = (DDWORD)(soc - mAppScuGauage.CutOffSoc);
00000a  1a42              SUBS     r2,r0,r1
00000c  17d3              ASRS     r3,r2,#31
00000e  e001              B        |L44.20|
                  |L44.16|
;;;255    	else
;;;256    		d = 0;
000010  2200              MOVS     r2,#0
000012  4613              MOV      r3,r2
                  |L44.20|
;;;257    			
;;;258    	n = (DDWORD)mAppScuGauage.Qmax.l;
000014  6b68              LDR      r0,[r5,#0x34]  ; mAppScuGauage
000016  2100              MOVS     r1,#0
;;;259    	n *= d;
000018  4604              MOV      r4,r0
00001a  fba40602          UMULL    r0,r6,r4,r2
00001e  fb016102          MLA      r1,r1,r2,r6
000022  fb041103          MLA      r1,r4,r3,r1
;;;260    	n /= (DDWORD)10000;		//mAh
000026  f2427210          MOV      r2,#0x2710
00002a  2300              MOVS     r3,#0
00002c  f7fffffe          BL       __aeabi_uldivmod
;;;261    	n *= (DDWORD)1000L;		//uAhH	
000030  f44f727a          MOV      r2,#0x3e8
000034  fba03602          UMULL    r3,r6,r0,r2
000038  fb016102          MLA      r1,r1,r2,r6
00003c  2400              MOVS     r4,#0
00003e  fb001104          MLA      r1,r0,r4,r1
000042  4618              MOV      r0,r3
;;;262    	mAppScuGauage.RM.ll = (DDWORD)n*(DDWORD)3600*(DDWORD)1000;
000044  4a07              LDR      r2,|L44.100|
000046  2300              MOVS     r3,#0
000048  fba04602          UMULL    r4,r6,r0,r2
00004c  fb016102          MLA      r1,r1,r2,r6
000050  fb001003          MLA      r0,r0,r3,r1
000054  e9c54016          STRD     r4,r0,[r5,#0x58]
;;;263    	
;;;264    	appScuGaugeSetFcc();
000058  e8bd4070          POP      {r4-r6,lr}
00005c  f7ffbffe          B.W      appScuGaugeSetFcc
;;;265    }
;;;266    
                          ENDP

                  |L44.96|
                          DCD      ||.bss||
                  |L44.100|
                          DCD      0x0036ee80

                          AREA ||i.gaugeSwTimerHandler||, CODE, READONLY, ALIGN=2

                  gaugeSwTimerHandler PROC
;;;1350   
;;;1351   static void gaugeSwTimerHandler(__far void *dest, uint16_t evt, void *vDataPtr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1352   {
000004  460c              MOV      r4,r1
;;;1353   	static uint16_t	count1 = 0;
;;;1354   	static uint8_t	count=0;
;;;1355   	char	str[100];
;;;1356   	
;;;1357   	//GPIOD->ODR |= GPIO_PIN_14;
;;;1358   	count1++;
000006  4d18              LDR      r5,|L45.104|
000008  8868              LDRH     r0,[r5,#2]  ; count1
00000a  1c40              ADDS     r0,r0,#1
00000c  8068              STRH     r0,[r5,#2]
;;;1359   	if(appProjectIsInSimuMode()==0 &&  halAfeGetState() != AFE_STATE_NORMAL)
00000e  f7fffffe          BL       appProjectIsInSimuMode
;;;1360   	{
;;;1361   		if(count1 >= 2000)
000012  f44f67fa          MOV      r7,#0x7d0
000016  2600              MOVS     r6,#0
000018  b940              CBNZ     r0,|L45.44|
00001a  f7fffffe          BL       halAfeGetState
00001e  b128              CBZ      r0,|L45.44|
000020  8868              LDRH     r0,[r5,#2]  ; count1
000022  42b8              CMP      r0,r7
000024  d300              BCC      |L45.40|
;;;1362   		{
;;;1363   			//sprintf(str,"ret %d %d", appProjectIsSimuMode(), halAfeGetState());
;;;1364   			//appSerialCanDavinciSendTextMessage(str);
;;;1365   			count1 = 0;
000026  806e              STRH     r6,[r5,#2]
                  |L45.40|
;;;1366   		}
;;;1367   		return;
;;;1368   	}
;;;1369   	if(count1 >= 2000)
;;;1370   	{
;;;1371   		//sprintf(str,"run %d %d", appProjectIsSimuMode(), halAfeGetState());
;;;1372   		//appSerialCanDavinciSendTextMessage(str);
;;;1373   		count1 = 0;
;;;1374   	}
;;;1375   	
;;;1376   	if(evt == LIB_SW_TIMER_EVT_SW_1MS)
;;;1377   		return;
;;;1378   	//GPIOD->ODR |= GPIO_PIN_14;
;;;1379   	if(evt == LIB_SW_TIMER_EVT_SW_10MS_1)
;;;1380   	{
;;;1381   		gaugeCalCapacity();	
;;;1382   		count++;
;;;1383   		if(count>=100)
;;;1384   		{
;;;1385   			count = 0;
;;;1386   		}
;;;1387   	}
;;;1388   	else if(evt == LIB_SW_TIMER_EVT_SW_1S)
;;;1389   	{
;;;1390   		//gaugeCalAvgCurrent();
;;;1391   		
;;;1392   		//sprintf(str,"I = %d AvgI = %d %d", 
;;;1393   		//		abs(appGaugeGetCurrentValue()),
;;;1394   		//		mAppScuGauage.AbsAvggCurrent,
;;;1395   		//		mAppScuGauage.FirstReadCurrentFlag
;;;1396   		//		);
;;;1397   		//scuDebugMsg(str);		
;;;1398   		
;;;1399   		apiRamSaveSoc(mAppScuGauage.RamSoc);
;;;1400   		saveTotalDischargeCountToRam();
;;;1401   
;;;1402   		gaugeCorrectCapacity();
;;;1403   	}
;;;1404   	//GPIOD->ODR &= ~GPIO_PIN_14;
;;;1405   }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L45.44|
00002c  8868              LDRH     r0,[r5,#2]            ;1369  ; count1
00002e  42b8              CMP      r0,r7                 ;1369
000030  d300              BCC      |L45.52|
000032  806e              STRH     r6,[r5,#2]            ;1373
                  |L45.52|
000034  2c0a              CMP      r4,#0xa               ;1376
000036  d0f7              BEQ      |L45.40|
000038  2c01              CMP      r4,#1                 ;1379
00003a  d00b              BEQ      |L45.84|
00003c  2c0d              CMP      r4,#0xd               ;1388
00003e  d1f3              BNE      |L45.40|
000040  480a              LDR      r0,|L45.108|
000042  8a80              LDRH     r0,[r0,#0x14]         ;1399  ; mAppScuGauage
000044  f7fffffe          BL       apiRamSaveSoc
000048  f7fffffe          BL       saveTotalDischargeCountToRam
00004c  e8bd41f0          POP      {r4-r8,lr}            ;1402
000050  f7ffbffe          B.W      gaugeCorrectCapacity
                  |L45.84|
000054  f7fffffe          BL       gaugeCalCapacity
000058  7828              LDRB     r0,[r5,#0]            ;1382  ; count
00005a  1c40              ADDS     r0,r0,#1              ;1382
00005c  b2c0              UXTB     r0,r0                 ;1382
00005e  7028              STRB     r0,[r5,#0]            ;1382
000060  2864              CMP      r0,#0x64              ;1383
000062  d3e1              BCC      |L45.40|
000064  702e              STRB     r6,[r5,#0]            ;1385
000066  e7df              B        |L45.40|
;;;1406   static void gaugeHwTimerHandler(__far void *dest, uint16_t evt, void *vDataPtr)
                          ENDP

                  |L45.104|
                          DCD      ||.data||
                  |L45.108|
                          DCD      ||.bss||

                          AREA ||i.gaugeUpdateCurrentMode||, CODE, READONLY, ALIGN=2

                  gaugeUpdateCurrentMode PROC
;;;517    
;;;518    static uint8_t	gaugeUpdateCurrentMode(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;519    {
;;;520    	tCurrent	Current;
;;;521    	tCurrent	AbsCurrentValue;
;;;522    	Current = 	halAfeGetCurrentValue(0);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       halAfeGetCurrentValue
00000a  4604              MOV      r4,r0
;;;523    	AbsCurrentValue = abs(Current);
00000c  0020              MOVS     r0,r4
00000e  d500              BPL      |L46.18|
000010  4240              RSBS     r0,r0,#0
                  |L46.18|
000012  4605              MOV      r5,r0
;;;524    	
;;;525    	if(AbsCurrentValue < apiSysParGetZeroCurrentValue())
000014  f7fffffe          BL       apiSysParGetZeroCurrentValue
;;;526    	{
;;;527    		mAppScuGauage.ChargeMode = APP_SCU_GAUGE_RELEASE_MODE;
;;;528    	}
;;;529    	else if(AbsCurrentValue > apiSysParGetMinChargeCurrentValue())
;;;530    	{
;;;531    		if(Current < 0)
;;;532    			mAppScuGauage.ChargeMode = APP_SCU_GAUGE_CHARGE_MODE;
;;;533    		else
;;;534    			mAppScuGauage.ChargeMode = APP_SCU_GAUGE_DISCHARGE_MODE;
000018  2701              MOVS     r7,#1
00001a  4e0c              LDR      r6,|L46.76|
00001c  42a8              CMP      r0,r5                 ;525
00001e  dd02              BLE      |L46.38|
000020  2000              MOVS     r0,#0                 ;527
000022  7070              STRB     r0,[r6,#1]            ;527
000024  e009              B        |L46.58|
                  |L46.38|
000026  f7fffffe          BL       apiSysParGetMinChargeCurrentValue
00002a  42a8              CMP      r0,r5                 ;529
00002c  da05              BGE      |L46.58|
00002e  2c00              CMP      r4,#0                 ;531
000030  da02              BGE      |L46.56|
000032  2002              MOVS     r0,#2                 ;532
000034  7070              STRB     r0,[r6,#1]            ;532
000036  e000              B        |L46.58|
                  |L46.56|
000038  7077              STRB     r7,[r6,#1]
                  |L46.58|
;;;535    	}
;;;536    	if(mAppScuGauage.ChargeModeTemp != mAppScuGauage.ChargeMode)
00003a  78b1              LDRB     r1,[r6,#2]  ; mAppScuGauage
00003c  7870              LDRB     r0,[r6,#1]  ; mAppScuGauage
00003e  4281              CMP      r1,r0
000040  d002              BEQ      |L46.72|
;;;537    	{
;;;538    		mAppScuGauage.ChargeModeTemp = mAppScuGauage.ChargeMode;
000042  70b0              STRB     r0,[r6,#2]
;;;539    		mAppScuGauage.FirstReadCurrentFlag = 1;
000044  f8867165          STRB     r7,[r6,#0x165]
                  |L46.72|
;;;540    	}
;;;541    	return mAppScuGauage.ChargeMode;
;;;542    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;543    static void gaugeCalAvgCurrent(void)
                          ENDP

                  |L46.76|
                          DCD      ||.bss||

                          AREA ||i.getSocTableUseAvgCellVoltage||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  getSocTableUseAvgCellVoltage PROC
;;;711    //	根據Cell電壓值,回傳SOC 
;;;712    void getSocTableUseAvgCellVoltage(void)
000000  b530              PUSH     {r4,r5,lr}
;;;713    {
000002  b099              SUB      sp,sp,#0x64
;;;714    	WORD	voltage;
;;;715    	char	str[100];
;;;716    	
;;;717    	voltage = GetAverageCellVoltage();
000004  f7fffffe          BL       GetAverageCellVoltage
000008  4604              MOV      r4,r0
;;;718    	sprintf(str,"Avg CV=%d", voltage);
00000a  4622              MOV      r2,r4
00000c  a10e              ADR      r1,|L47.72|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __2sprintf
;;;719    	scuDebugMsg(str);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       appSerialCanDavinciSendTextMessage
;;;720    	//-----------------------------------------------
;;;721    	//	判斷是否在平坦區
;;;722    	if(voltage > apiSysParGetMinFlatVoltage() &&
00001a  f7fffffe          BL       apiSysParGetMinFlatVoltage
;;;723    	   voltage < apiSysParGetMaxFlatVoltage())
;;;724    	{
;;;725    		mAppScuGauage.NowSocValid = 0;
00001e  4d0d              LDR      r5,|L47.84|
000020  42a0              CMP      r0,r4                 ;722
000022  d20a              BCS      |L47.58|
000024  f7fffffe          BL       apiSysParGetMaxFlatVoltage
000028  42a0              CMP      r0,r4                 ;723
00002a  d906              BLS      |L47.58|
00002c  2000              MOVS     r0,#0
00002e  77e8              STRB     r0,[r5,#0x1f]
;;;726    		scuDebugMsg("平坦區");
000030  a009              ADR      r0,|L47.88|
000032  f7fffffe          BL       appSerialCanDavinciSendTextMessage
                  |L47.54|
;;;727    		return;
;;;728    	}
;;;729    	mAppScuGauage.NowSoc = getSocUseVoltage(voltage);
;;;730    	mAppScuGauage.NowSocValid = 1;
;;;731    }
000036  b019              ADD      sp,sp,#0x64
000038  bd30              POP      {r4,r5,pc}
                  |L47.58|
00003a  4620              MOV      r0,r4                 ;729
00003c  f7fffffe          BL       getSocUseVoltage
000040  8128              STRH     r0,[r5,#8]            ;729
000042  2001              MOVS     r0,#1                 ;730
000044  77e8              STRB     r0,[r5,#0x1f]         ;730
000046  e7f6              B        |L47.54|
;;;732    
                          ENDP

                  |L47.72|
000048  41766720          DCB      "Avg CV=%d",0
00004c  43563d25
000050  6400    
000052  00                DCB      0
000053  00                DCB      0
                  |L47.84|
                          DCD      ||.bss||
                  |L47.88|
000058  a5ada95a          DCB      165,173,169,"Z",176,207,0
00005c  b0cf00  
00005f  00                DCB      0

                          AREA ||i.getSocUseVoltage||, CODE, READONLY, ALIGN=2

                  getSocUseVoltage PROC
;;;661    //------------------------------------
;;;662    uint16_t getSocUseVoltage(uint32_t voltage)
000000  b530              PUSH     {r4,r5,lr}
;;;663    {
;;;664    	DWORD	dV,dR,y;
;;;665    	BYTE	i;
;;;666    	WORD	soc;
;;;667    	
;;;668    	if(mAppScuGauage.OcvTableNum < 1)
000002  4b26              LDR      r3,|L48.156|
000004  f8934088          LDRB     r4,[r3,#0x88]  ; mAppScuGauage
000008  2c00              CMP      r4,#0
00000a  d007              BEQ      |L48.28|
;;;669    		return 0;
;;;670    	//-----------------------------------------------
;;;671    	soc = 5000;	//default value
00000c  f2413288          MOV      r2,#0x1388
;;;672    	if(voltage < mAppScuGauage.OcvTable[0].Value)
000010  f8b3108c          LDRH     r1,[r3,#0x8c]  ; mAppScuGauage
000014  4281              CMP      r1,r0
000016  d903              BLS      |L48.32|
;;;673    		soc = 0;	//0%
000018  2200              MOVS     r2,#0
00001a  e03c              B        |L48.150|
                  |L48.28|
00001c  2000              MOVS     r0,#0                 ;669
;;;674    	else if(voltage >= mAppScuGauage.OcvTable[mAppScuGauage.OcvTableNum - 1].Value)
;;;675    		soc = (uint16_t)mAppScuGauage.OcvTable[mAppScuGauage.OcvTableNum - 1].Level * 100;		//100%
;;;676    	else
;;;677    	{
;;;678    		for(i=0; i<(mAppScuGauage.OcvTableNum - 1); i++)
;;;679    		{
;;;680    			if(voltage >= mAppScuGauage.OcvTable[i].Value && 
;;;681    		   	   voltage < mAppScuGauage.OcvTable[i+1].Value)
;;;682    		   	{
;;;683    		   		y = voltage - mAppScuGauage.OcvTable[i].Value;
;;;684    		   		dV = mAppScuGauage.OcvTable[i+1].Value - mAppScuGauage.OcvTable[i].Value;
;;;685    		   		dR = mAppScuGauage.OcvTable[i+1].Level - mAppScuGauage.OcvTable[i].Level;
;;;686    		   		y *= dR;
;;;687    		   		y *= 100L;
;;;688    		   		y /= dV;		//換算出百分比
;;;689    		 		y += ((DWORD)mAppScuGauage.OcvTable[i].Level*100L);
;;;690    		 		soc = (WORD)y;
;;;691    #if	0
;;;692    				{
;;;693    			 		char	str[100];
;;;694    			 		sprintf(str,"%d %d %d %d %d %d %d",i,voltage,soc,
;;;695    			 			EEPromParameter.OcvTable[i].Value.i,
;;;696    		 				EEPromParameter.OcvTable[i].Level,
;;;697    		 				EEPromParameter.OcvTable[i+1].Value.i,
;;;698    		 				EEPromParameter.OcvTable[i+1].Level		 					 			
;;;699    		 			);
;;;700    			 		SendMessageToCan(str);
;;;701    				}
;;;702    #endif
;;;703    		 		break;
;;;704    		   	}
;;;705    		}
;;;706    	}
;;;707    	return soc;
;;;708    }
00001e  bd30              POP      {r4,r5,pc}
                  |L48.32|
000020  1e64              SUBS     r4,r4,#1              ;674
000022  eb030184          ADD      r1,r3,r4,LSL #2       ;674
000026  f8b1508c          LDRH     r5,[r1,#0x8c]         ;674
00002a  4285              CMP      r5,r0                 ;674
00002c  d805              BHI      |L48.58|
00002e  f891008a          LDRB     r0,[r1,#0x8a]         ;675
000032  2164              MOVS     r1,#0x64              ;675
000034  fb10f201          SMULBB   r2,r0,r1              ;675
000038  e02d              B        |L48.150|
                  |L48.58|
00003a  2100              MOVS     r1,#0                 ;678
00003c  e029              B        |L48.146|
                  |L48.62|
00003e  eb030581          ADD      r5,r3,r1,LSL #2       ;680
000042  f8b5508c          LDRH     r5,[r5,#0x8c]         ;680
000046  4285              CMP      r5,r0                 ;680
000048  d821              BHI      |L48.142|
00004a  1c4d              ADDS     r5,r1,#1              ;681
00004c  eb030585          ADD      r5,r3,r5,LSL #2       ;681
000050  f8b5508c          LDRH     r5,[r5,#0x8c]         ;681
000054  4285              CMP      r5,r0                 ;681
000056  d91a              BLS      |L48.142|
000058  eb030281          ADD      r2,r3,r1,LSL #2       ;683
00005c  328a              ADDS     r2,r2,#0x8a           ;683
00005e  8854              LDRH     r4,[r2,#2]            ;683
000060  1b05              SUBS     r5,r0,r4              ;683
000062  1c49              ADDS     r1,r1,#1              ;684
000064  eb030081          ADD      r0,r3,r1,LSL #2       ;684
000068  308a              ADDS     r0,r0,#0x8a           ;684
00006a  8841              LDRH     r1,[r0,#2]            ;684
00006c  1b0b              SUBS     r3,r1,r4              ;684
00006e  7801              LDRB     r1,[r0,#0]            ;685
000070  7810              LDRB     r0,[r2,#0]            ;685
000072  1a09              SUBS     r1,r1,r0              ;685
000074  434d              MULS     r5,r1,r5              ;686
000076  2164              MOVS     r1,#0x64              ;687
000078  434d              MULS     r5,r1,r5              ;687
00007a  fbb5f1f3          UDIV     r1,r5,r3              ;688
00007e  eb0002c0          ADD      r2,r0,r0,LSL #3       ;689
000082  eb021000          ADD      r0,r2,r0,LSL #4       ;689
000086  eb010080          ADD      r0,r1,r0,LSL #2       ;689
00008a  b282              UXTH     r2,r0                 ;690
00008c  e003              B        |L48.150|
                  |L48.142|
00008e  1c49              ADDS     r1,r1,#1              ;678
000090  b2c9              UXTB     r1,r1                 ;678
                  |L48.146|
000092  428c              CMP      r4,r1                 ;678
000094  dcd3              BGT      |L48.62|
                  |L48.150|
000096  4610              MOV      r0,r2                 ;707
000098  bd30              POP      {r4,r5,pc}
;;;709    
                          ENDP

00009a  0000              DCW      0x0000
                  |L48.156|
                          DCD      ||.bss||

                          AREA ||i.getTerminateSocFromOcvTable||, CODE, READONLY, ALIGN=2

                  getTerminateSocFromOcvTable PROC
;;;733    //--------------------------------------------
;;;734    static uint16_t getTerminateSocFromOcvTable(void)
000000  b530              PUSH     {r4,r5,lr}
;;;735    {
;;;736    	DWORD	dS,dV,v;
;;;737    	BYTE	i;
;;;738    	if(mAppScuGauage.OcvTableNum < 1)
000002  4a29              LDR      r2,|L49.168|
000004  f8923088          LDRB     r3,[r2,#0x88]  ; mAppScuGauage
000008  2b00              CMP      r3,#0
00000a  d007              BEQ      |L49.28|
;;;739    		return 0;
;;;740    	if(mAppScuGauage.TerminateVoltage <= mAppScuGauage.OcvTable[0].Value)
00000c  f8b21156          LDRH     r1,[r2,#0x156]  ; mAppScuGauage
000010  f8b2008c          LDRH     r0,[r2,#0x8c]  ; mAppScuGauage
000014  4281              CMP      r1,r0
000016  d803              BHI      |L49.32|
;;;741    		return 0;
000018  2000              MOVS     r0,#0
;;;742    	else if(mAppScuGauage.TerminateVoltage >= mAppScuGauage.OcvTable[mAppScuGauage.OcvTableNum-1].Value)
;;;743    		return 10000;
;;;744    	for(i=0; i<(mAppScuGauage.OcvTableNum-1); i++)
;;;745    	{
;;;746    		if((mAppScuGauage.TerminateVoltage >= mAppScuGauage.OcvTable[i].Value) &&
;;;747    		   (mAppScuGauage.TerminateVoltage < mAppScuGauage.OcvTable[i+1].Value))
;;;748    		{
;;;749    			if(mAppScuGauage.TerminateVoltage == mAppScuGauage.OcvTable[i].Value)
;;;750    				return ((WORD)mAppScuGauage.OcvTable[i].Level * 100);
;;;751    			dS = mAppScuGauage.OcvTable[i+1].Level - mAppScuGauage.OcvTable[i].Level;
;;;752    			dS *= 100L;
;;;753    			dV = mAppScuGauage.OcvTable[i+1].Value- mAppScuGauage.OcvTable[i].Value;
;;;754    			v = mAppScuGauage.TerminateVoltage - mAppScuGauage.OcvTable[i].Value;
;;;755    			v *= dS;
;;;756    			v /= dV;
;;;757    			v += ((WORD)mAppScuGauage.OcvTable[i].Level * 100);
;;;758    			return (WORD)v;
;;;759    		}
;;;760    	}
;;;761    	return 0;
;;;762    }
00001a  bd30              POP      {r4,r5,pc}
                  |L49.28|
00001c  2000              MOVS     r0,#0                 ;739
00001e  bd30              POP      {r4,r5,pc}
                  |L49.32|
000020  1e5b              SUBS     r3,r3,#1              ;742
000022  eb020083          ADD      r0,r2,r3,LSL #2       ;742
000026  f8b0008c          LDRH     r0,[r0,#0x8c]         ;742
00002a  4281              CMP      r1,r0                 ;742
00002c  d302              BCC      |L49.52|
00002e  f2427010          MOV      r0,#0x2710            ;743
000032  bd30              POP      {r4,r5,pc}
                  |L49.52|
000034  2000              MOVS     r0,#0                 ;744
000036  e033              B        |L49.160|
                  |L49.56|
000038  eb020480          ADD      r4,r2,r0,LSL #2       ;746
00003c  f8b4408c          LDRH     r4,[r4,#0x8c]         ;746
000040  42a1              CMP      r1,r4                 ;746
000042  d32b              BCC      |L49.156|
000044  1c44              ADDS     r4,r0,#1              ;747
000046  eb020484          ADD      r4,r2,r4,LSL #2       ;747
00004a  f8b4408c          LDRH     r4,[r4,#0x8c]         ;747
00004e  42a1              CMP      r1,r4                 ;747
000050  d224              BCS      |L49.156|
000052  eb020480          ADD      r4,r2,r0,LSL #2       ;749
000056  f8b4308c          LDRH     r3,[r4,#0x8c]         ;749
00005a  4299              CMP      r1,r3                 ;749
00005c  d105              BNE      |L49.106|
00005e  f894008a          LDRB     r0,[r4,#0x8a]         ;750
000062  2164              MOVS     r1,#0x64              ;750
000064  fb10f001          SMULBB   r0,r0,r1              ;750
000068  bd30              POP      {r4,r5,pc}
                  |L49.106|
00006a  1c40              ADDS     r0,r0,#1              ;751
00006c  eb020280          ADD      r2,r2,r0,LSL #2       ;751
000070  f894008a          LDRB     r0,[r4,#0x8a]         ;751
000074  f8125f8a          LDRB     r5,[r2,#0x8a]!        ;751
000078  1a2c              SUBS     r4,r5,r0              ;751
00007a  2564              MOVS     r5,#0x64              ;752
00007c  fb14f405          SMULBB   r4,r4,r5              ;752
000080  8852              LDRH     r2,[r2,#2]            ;753
000082  1ad2              SUBS     r2,r2,r3              ;753
000084  1ac9              SUBS     r1,r1,r3              ;754
000086  4361              MULS     r1,r4,r1              ;755
000088  fbb1f1f2          UDIV     r1,r1,r2              ;756
00008c  eb0002c0          ADD      r2,r0,r0,LSL #3       ;757
000090  eb021000          ADD      r0,r2,r0,LSL #4       ;757
000094  eb010080          ADD      r0,r1,r0,LSL #2       ;757
000098  b280              UXTH     r0,r0                 ;758
00009a  bd30              POP      {r4,r5,pc}
                  |L49.156|
00009c  1c40              ADDS     r0,r0,#1              ;744
00009e  b2c0              UXTB     r0,r0                 ;744
                  |L49.160|
0000a0  4283              CMP      r3,r0                 ;744
0000a2  dcc9              BGT      |L49.56|
0000a4  2000              MOVS     r0,#0                 ;761
0000a6  bd30              POP      {r4,r5,pc}
;;;763    
                          ENDP

                  |L49.168|
                          DCD      ||.bss||

                          AREA ||i.loadTotalDischargeCountFromRam||, CODE, READONLY, ALIGN=2

                  loadTotalDischargeCountFromRam PROC
;;;1284   
;;;1285   static void loadTotalDischargeCountFromRam(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1286   {
;;;1287   	mAppScuGauage.TotalDisChargeCount.ll = apiRamLoadTotalDisChargeCount();	//mAh
000002  f7fffffe          BL       apiRamLoadTotalDisChargeCount
000006  4a06              LDR      r2,|L50.32|
000008  2100              MOVS     r1,#0
;;;1288   	mAppScuGauage.TotalDisChargeCount.ll *= (3600u * 1000u *1000u);	//ms, uA
00000a  4b06              LDR      r3,|L50.36|
00000c  2400              MOVS     r4,#0
00000e  fba05603          UMULL    r5,r6,r0,r3
000012  fb016103          MLA      r1,r1,r3,r6
000016  fb001004          MLA      r0,r0,r4,r1
00001a  e9c25010          STRD     r5,r0,[r2,#0x40]
;;;1289   }
00001e  bd70              POP      {r4-r6,pc}
;;;1290   
                          ENDP

                  |L50.32|
                          DCD      ||.bss||
                  |L50.36|
                          DCD      0xd693a400

                          AREA ||i.saveTotalDischargeCountToRam||, CODE, READONLY, ALIGN=2

                  saveTotalDischargeCountToRam PROC
;;;1340   
;;;1341   static void saveTotalDischargeCountToRam(void)
000000  b510              PUSH     {r4,lr}
;;;1342   {
;;;1343   	uint32_t	mAh;
;;;1344   	if(appGaugeGetCurrentMode() != APP_SCU_GAUGE_DISCHARGE_MODE)		
000002  f7fffffe          BL       appGaugeGetCurrentMode
000006  2801              CMP      r0,#1
000008  d10a              BNE      |L51.32|
;;;1345   		return;
;;;1346   	
;;;1347   	mAh = mAppScuGauage.TotalDisChargeCount.ll /(3600u * 1000u * 1000u);
00000a  4906              LDR      r1,|L51.36|
00000c  4a06              LDR      r2,|L51.40|
00000e  2300              MOVS     r3,#0
000010  e9d10110          LDRD     r0,r1,[r1,#0x40]
000014  f7fffffe          BL       __aeabi_uldivmod
;;;1348   	apiRamSaveTotalDisChargeCount(mAh);
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      apiRamSaveTotalDisChargeCount
                  |L51.32|
;;;1349   }
000020  bd10              POP      {r4,pc}
;;;1350   
                          ENDP

000022  0000              DCW      0x0000
                  |L51.36|
                          DCD      ||.bss||
                  |L51.40|
                          DCD      0xd693a400

                          AREA ||i.scuGaugeUnReleasedMode||, CODE, READONLY, ALIGN=2

                  scuGaugeUnReleasedMode PROC
;;;1084   //-----------------------------------------------
;;;1085   static void scuGaugeUnReleasedMode(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1086   {
;;;1087   	LONG		slong;
;;;1088   	DWORD		n1,n2;
;;;1089   	BYTE		Over5HrFlag;
;;;1090   	BYTE		PlusFlag;
;;;1091   	char	str[100];
;;;1092   	
;;;1093   	apiRamSaveLastChgDhgTime();
000004  f7fffffe          BL       apiRamSaveLastChgDhgTime
;;;1094   	//--------------------------
;;;1095   	//	計算最新的Soc值
;;;1096   	slong = CvtRaPassChargeTomAh();
000008  f7fffffe          BL       CvtRaPassChargeTomAh
;;;1097   	if(slong < 0)	//放電
00000c  2800              CMP      r0,#0
00000e  da02              BGE      |L52.22|
;;;1098   	{
;;;1099   		n1 = slong * (-1);
000010  4240              RSBS     r0,r0,#0
;;;1100   		PlusFlag = 0;
000012  2100              MOVS     r1,#0
000014  e000              B        |L52.24|
                  |L52.22|
;;;1101   	}
;;;1102   	else
;;;1103   	{
;;;1104   		PlusFlag = 1;
000016  2101              MOVS     r1,#1
                  |L52.24|
;;;1105   		n1 = slong;
;;;1106   	}
;;;1107   	n1 *= 10000L;
000018  f2427210          MOV      r2,#0x2710
00001c  4350              MULS     r0,r2,r0
;;;1108   	n1 /= mAppScuGauage.Qmax.l;		//充放電百分比
00001e  4d5e              LDR      r5,|L52.408|
000020  6b6a              LDR      r2,[r5,#0x34]  ; mAppScuGauage
000022  fbb0f0f2          UDIV     r0,r0,r2
;;;1109   	if(PlusFlag)					//充電
;;;1110   	{
;;;1111   		mAppScuGauage.RamSoc = mAppScuGauage.SocBase + n1;
;;;1112   		if(mAppScuGauage.RamSoc > 10000L)
000026  f2427410          MOV      r4,#0x2710
00002a  2600              MOVS     r6,#0
00002c  b139              CBZ      r1,|L52.62|
00002e  8ae9              LDRH     r1,[r5,#0x16]         ;1111  ; mAppScuGauage
000030  4408              ADD      r0,r0,r1              ;1111
000032  b280              UXTH     r0,r0                 ;1111
000034  82a8              STRH     r0,[r5,#0x14]         ;1111
000036  42a0              CMP      r0,r4
000038  d908              BLS      |L52.76|
;;;1113   			mAppScuGauage.RamSoc = 10000L;
00003a  82ac              STRH     r4,[r5,#0x14]
00003c  e006              B        |L52.76|
                  |L52.62|
;;;1114   	}
;;;1115   	else
;;;1116   	{
;;;1117   		if(mAppScuGauage.SocBase >= n1)
00003e  8ae9              LDRH     r1,[r5,#0x16]  ; mAppScuGauage
000040  4281              CMP      r1,r0
000042  d302              BCC      |L52.74|
;;;1118   			mAppScuGauage.RamSoc = mAppScuGauage.SocBase - n1;
000044  1a08              SUBS     r0,r1,r0
000046  82a8              STRH     r0,[r5,#0x14]
000048  e000              B        |L52.76|
                  |L52.74|
;;;1119   		else
;;;1120   			mAppScuGauage.RamSoc = 0;
00004a  82ae              STRH     r6,[r5,#0x14]
                  |L52.76|
;;;1121   	}
;;;1122   	//--------------------------
;;;1123   	if(appGaugeGetCurrentMode() == APP_SCU_GAUGE_DISCHARGE_MODE)	//在放電模式，可以判斷是否到到Rtable 的參考值
00004c  f7fffffe          BL       appGaugeGetCurrentMode
;;;1124   	{	
;;;1125   		mAppScuGauage.FullChargeTimerCount = 0;
;;;1126   		//DryCtrl_NoFull_Chg();
;;;1127   			
;;;1128   		//--------------------
;;;1129   		gaugeCheckCycleCount();
;;;1130   				
;;;1131   		//--------------------------
;;;1132   		//	判斷是否已到到截止電壓	
;;;1133   		{
;;;1134   			WORD	v;
;;;1135   			v = GetAverageCellVoltage();
;;;1136   			if(v < mAppScuGauage.TerminateVoltage)	//已放到截止電壓
;;;1137   			{
;;;1138   				mAppScuGauage.TerminateVoltageCount++;
;;;1139   				if(mAppScuGauage.TerminateVoltageCount >= 40)	//已連續低於截止電壓40 sec, 設定容量為0
;;;1140   				{
;;;1141   					mAppScuGauage.TerminateVoltageCount = 40;
;;;1142   					mAppScuGauage.RM.ll = 0;
;;;1143   					//scuDebugMsg("...............EDV");
;;;1144   				}
;;;1145   			}
;;;1146   			else
;;;1147   				mAppScuGauage.TerminateVoltageCount = 0;
;;;1148   		}
;;;1149   		//-------------------------	
;;;1150   		//	j++
;;;1151   		//	20171121 修改為直接以 RamSoc 做為Ra 校正的參考點,
;;;1152   		//	不再另外以 	StartCalRaSoc 為參考點
;;;1153   		if(mAppScuGauage.RaLastSoc != 0xffff)
;;;1154   		{						
;;;1155   			appScuGaugeUpdateRm(mAppScuGauage.RaLastSoc, mAppScuGauage.RamSoc);
;;;1156   		}
;;;1157   		mAppScuGauage.RaLastSoc = mAppScuGauage.RamSoc;
;;;1158   		//---------------------------
;;;1159   		//	放電模式,校正SOC 顯示值
;;;1160   		if(mAppScuGauage.DisplaySocValue.i != mAppScuGauage.RsocValue.i)
;;;1161   		{				
;;;1162   			if(mAppScuGauage.DisplaySocValue.i <= mAppScuGauage.RsocValue.i)
;;;1163   			{
;;;1164   				#if	0
;;;1165   				WORD	n;
;;;1166   				n=SystemParameter.RsocValue.i-SystemParameter.DisplaySocValue.i;
;;;1167   				n*=105;
;;;1168   				n/=100;	//20秒
;;;1169   				if(n==0)
;;;1170   					SystemParameter.DisplaySocValue.i=SystemParameter.RsocValue.i;
;;;1171   				else
;;;1172   					SystemParameter.DisplaySocValue.i+=n;	
;;;1173   				#endif
;;;1174   				;
;;;1175   			}
;;;1176   			else
;;;1177   			{
;;;1178   				WORD	n,n1;
;;;1179   				if(mAppScuGauage.LastRsocValue > mAppScuGauage.RsocValue.i)
;;;1180   					n1 = mAppScuGauage.LastRsocValue - mAppScuGauage.RsocValue.i;
;;;1181   				else
;;;1182   					n1 = 0;
;;;1183   				n1 /= 30;
000050  271e              MOVS     r7,#0x1e
000052  f64f78ff          MOV      r8,#0xffff            ;1153
000056  2801              CMP      r0,#1                 ;1123
000058  d005              BEQ      |L52.102|
;;;1184   				n = mAppScuGauage.DisplaySocValue.i - mAppScuGauage.RsocValue.i;
;;;1185   				n /= 30;	//20秒
;;;1186   				n1 += n;
;;;1187   				if(n1 >= mAppScuGauage.DisplaySocValue.i || n1 == 0)
;;;1188   					mAppScuGauage.DisplaySocValue.i = mAppScuGauage.RsocValue.i;
;;;1189   				else
;;;1190   					mAppScuGauage.DisplaySocValue.i -= n1;
;;;1191   			}
;;;1192   		}
;;;1193   	}	//if(ChargeMode==DISCHARGE_MODE)
;;;1194   	//------------------------------------------------------
;;;1195   	else		//充電模式
;;;1196   	{
;;;1197   		//------------------
;;;1198   		//	充電模式，判斷是否到達taper current & voltage 的條件
;;;1199   		{
;;;1200   			WORD	v;
;;;1201   			DWORD	current;
;;;1202   			DDWORD	d;
;;;1203   			current = abs(appGaugeGetCurrentValue());
00005a  f7fffffe          BL       appGaugeGetCurrentValue
00005e  2800              CMP      r0,#0
000060  db44              BLT      |L52.236|
000062  4681              MOV      r9,r0
000064  e044              B        |L52.240|
                  |L52.102|
000066  f8856075          STRB     r6,[r5,#0x75]         ;1125
00006a  f7fffffe          BL       gaugeCheckCycleCount
00006e  f7fffffe          BL       GetAverageCellVoltage
000072  f8b51156          LDRH     r1,[r5,#0x156]        ;1136  ; mAppScuGauage
000076  4281              CMP      r1,r0                 ;1136
000078  d90e              BLS      |L52.152|
00007a  f8950074          LDRB     r0,[r5,#0x74]         ;1138  ; mAppScuGauage
00007e  1c40              ADDS     r0,r0,#1              ;1138
000080  b2c0              UXTB     r0,r0                 ;1138
000082  f8850074          STRB     r0,[r5,#0x74]         ;1138
000086  2828              CMP      r0,#0x28              ;1139
000088  d308              BCC      |L52.156|
00008a  2028              MOVS     r0,#0x28              ;1141
00008c  f8850074          STRB     r0,[r5,#0x74]         ;1141
000090  2000              MOVS     r0,#0                 ;1142
000092  65a8              STR      r0,[r5,#0x58]         ;1142  ; mAppScuGauage
000094  65e8              STR      r0,[r5,#0x5c]         ;1142  ; mAppScuGauage
000096  e001              B        |L52.156|
                  |L52.152|
000098  f8856074          STRB     r6,[r5,#0x74]         ;1147
                  |L52.156|
00009c  8ca8              LDRH     r0,[r5,#0x24]         ;1153  ; mAppScuGauage
00009e  4540              CMP      r0,r8                 ;1153
0000a0  d002              BEQ      |L52.168|
0000a2  8aa9              LDRH     r1,[r5,#0x14]         ;1155  ; mAppScuGauage
0000a4  f7fffffe          BL       appScuGaugeUpdateRm
                  |L52.168|
0000a8  8aa8              LDRH     r0,[r5,#0x14]         ;1157  ; mAppScuGauage
0000aa  84a8              STRH     r0,[r5,#0x24]         ;1157
0000ac  f8b51152          LDRH     r1,[r5,#0x152]        ;1160  ; mAppScuGauage
0000b0  f8b50154          LDRH     r0,[r5,#0x154]        ;1160  ; mAppScuGauage
0000b4  4281              CMP      r1,r0                 ;1160
0000b6  d961              BLS      |L52.380|
0000b8  f8b5215e          LDRH     r2,[r5,#0x15e]        ;1179  ; mAppScuGauage
0000bc  4282              CMP      r2,r0                 ;1179
0000be  d902              BLS      |L52.198|
0000c0  1a12              SUBS     r2,r2,r0              ;1180
0000c2  b292              UXTH     r2,r2                 ;1180
0000c4  e000              B        |L52.200|
                  |L52.198|
0000c6  2200              MOVS     r2,#0                 ;1182
                  |L52.200|
0000c8  fbb2f3f7          UDIV     r3,r2,r7              ;1183
0000cc  1a0a              SUBS     r2,r1,r0              ;1184
0000ce  b292              UXTH     r2,r2                 ;1184
0000d0  fbb2f2f7          UDIV     r2,r2,r7              ;1185
0000d4  441a              ADD      r2,r2,r3              ;1186
0000d6  b292              UXTH     r2,r2                 ;1186
0000d8  4291              CMP      r1,r2                 ;1187
0000da  d904              BLS      |L52.230|
0000dc  b11a              CBZ      r2,|L52.230|
0000de  1a88              SUBS     r0,r1,r2              ;1190
0000e0  f8a50152          STRH     r0,[r5,#0x152]        ;1190
0000e4  e04a              B        |L52.380|
                  |L52.230|
0000e6  f8a50152          STRH     r0,[r5,#0x152]        ;1188
0000ea  e047              B        |L52.380|
                  |L52.236|
0000ec  f1c00900          RSB      r9,r0,#0
                  |L52.240|
;;;1204   				
;;;1205   			v = GetAverageCellVoltage();
0000f0  f7fffffe          BL       GetAverageCellVoltage
;;;1206   			
;;;1207   			if(v >= mAppScuGauage.FullCharge.Voltage && 
0000f4  f8b51158          LDRH     r1,[r5,#0x158]  ; mAppScuGauage
0000f8  4281              CMP      r1,r0
0000fa  d82c              BHI      |L52.342|
;;;1208   			   current < mAppScuGauage.FullCharge.Current)	//已頂到充飽的條件
0000fc  f8b5015a          LDRH     r0,[r5,#0x15a]  ; mAppScuGauage
000100  4548              CMP      r0,r9
000102  d928              BLS      |L52.342|
;;;1209   			{
;;;1210   				if(mAppScuGauage.FullChargeTimerCount < 200)
000104  f8950075          LDRB     r0,[r5,#0x75]  ; mAppScuGauage
000108  28c8              CMP      r0,#0xc8
00010a  d202              BCS      |L52.274|
;;;1211   					mAppScuGauage.FullChargeTimerCount++;
00010c  1c40              ADDS     r0,r0,#1
00010e  f8850075          STRB     r0,[r5,#0x75]
                  |L52.274|
;;;1212   				if(mAppScuGauage.FullChargeTimerCount >= mAppScuGauage.FullCharge.Second)
000112  f8950075          LDRB     r0,[r5,#0x75]  ; mAppScuGauage
000116  f895115c          LDRB     r1,[r5,#0x15c]  ; mAppScuGauage
00011a  4288              CMP      r0,r1
00011c  d31d              BCC      |L52.346|
;;;1213   				{			
;;;1214   					#if 0					
;;;1215   					if(SystemParameter.BmuNumber==1)
;;;1216   						LedChargeMode(TRUE);	//充飽電
;;;1217   					else
;;;1218   					{
;;;1219   						if(BatteryCapInfo[0].FullChargeTimerCount>=40 &&
;;;1220   						   BatteryCapInfo[1].FullChargeTimerCount>=40)
;;;1221   						LedChargeMode(TRUE);	//充飽電   
;;;1222   					}
;;;1223   					#endif
;;;1224   					//BatteryCapInfo[area].FullChargeTimerCount=40;
;;;1225   					//----------------------------
;;;1226   					mAppScuGauage.RamSoc = 10000;
00011e  82ac              STRH     r4,[r5,#0x14]
;;;1227   					mAppScuGauage.SocBase = 10000;
000120  82ec              STRH     r4,[r5,#0x16]
;;;1228   					mAppScuGauage.Qstart.l = 0;
000122  62ae              STR      r6,[r5,#0x28]  ; mAppScuGauage
;;;1229   					gaugeRPassChargeIni();		//設定Ra PassCharge 初始值
000124  f7fffffe          BL       gaugeRPassChargeIni
;;;1230   					mAppScuGauage.FCC.l = mAppScuGauage.Qmax.l;
000128  6b6b              LDR      r3,[r5,#0x34]  ; mAppScuGauage
00012a  632b              STR      r3,[r5,#0x30]  ; mAppScuGauage
;;;1231   					d = mAppScuGauage.Qmax.l;	//mAh
00012c  4634              MOV      r4,r6
;;;1232   					d *= 1000;	//uA
00012e  f44f707a          MOV      r0,#0x3e8
000132  fba31c00          UMULL    r1,r12,r3,r0
000136  fb04c000          MLA      r0,r4,r0,r12
00013a  2200              MOVS     r2,#0
00013c  fb030402          MLA      r4,r3,r2,r0
000140  460b              MOV      r3,r1
;;;1233   					mAppScuGauage.RM.ll = (DDWORD)d*(DDWORD)3600*(DDWORD)1000;	//H-->ms
000142  4816              LDR      r0,|L52.412|
000144  fba31c00          UMULL    r1,r12,r3,r0
000148  fb04c000          MLA      r0,r4,r0,r12
00014c  fb030002          MLA      r0,r3,r2,r0
000150  e9c51016          STRD     r1,r0,[r5,#0x58]
000154  e001              B        |L52.346|
                  |L52.342|
;;;1234   						//----------------------------
;;;1235   				}
;;;1236   			}
;;;1237   			else
;;;1238   			{
;;;1239   				//LedChargeMode(FALSE);
;;;1240   				mAppScuGauage.FullChargeTimerCount = 0;
000156  f8856075          STRB     r6,[r5,#0x75]
                  |L52.346|
;;;1241   			}
;;;1242   		}			
;;;1243   		//------------------				
;;;1244   #ifdef RE_CHARGE_TEST			
;;;1245   		old_soc=255;
;;;1246   #endif			
;;;1247   		mAppScuGauage.RaLastSoc = 0xffff;		//重新設定 Ra Last Soc 
00015a  f8a58024          STRH     r8,[r5,#0x24]
;;;1248   		//---------------------------
;;;1249   		//	充電模式,校正SOC 顯示值
;;;1250   		if(mAppScuGauage.DisplaySocValue.i != mAppScuGauage.RsocValue.i)
00015e  f8b50152          LDRH     r0,[r5,#0x152]  ; mAppScuGauage
000162  f8b51154          LDRH     r1,[r5,#0x154]  ; mAppScuGauage
000166  4288              CMP      r0,r1
000168  d208              BCS      |L52.380|
;;;1251   		{
;;;1252   			if(mAppScuGauage.DisplaySocValue.i < mAppScuGauage.RsocValue.i)
;;;1253   			{
;;;1254   				WORD	n;
;;;1255   				n = mAppScuGauage.RsocValue.i - mAppScuGauage.DisplaySocValue.i;
00016a  eba10200          SUB      r2,r1,r0
00016e  b292              UXTH     r2,r2
;;;1256   				n /= 30;	//30秒
000170  fbb2f2f7          UDIV     r2,r2,r7
;;;1257   				if(n == 0)
000174  b16a              CBZ      r2,|L52.402|
;;;1258   					mAppScuGauage.DisplaySocValue.i = mAppScuGauage.RsocValue.i;
;;;1259   				else
;;;1260   					mAppScuGauage.DisplaySocValue.i += n;	
000176  4410              ADD      r0,r0,r2
000178  f8a50152          STRH     r0,[r5,#0x152]
                  |L52.380|
;;;1261   			}			
;;;1262   		}			
;;;1263   	}
;;;1264   	mAppScuGauage.RelaxSec = 0;
00017c  80ee              STRH     r6,[r5,#6]
;;;1265   	mAppScuGauage.ReadSocTime = 0;
00017e  80ae              STRH     r6,[r5,#4]
;;;1266   	mAppScuGauage.SocReadNum = 0;
000180  776e              STRB     r6,[r5,#0x1d]
;;;1267   	mAppScuGauage.Over5HrStatus = 0;
000182  f8856077          STRB     r6,[r5,#0x77]
;;;1268   	mAppScuGauage.LastRsocValue = mAppScuGauage.RsocValue.i;
000186  f8b50154          LDRH     r0,[r5,#0x154]  ; mAppScuGauage
00018a  f8a5015e          STRH     r0,[r5,#0x15e]
;;;1269   }
00018e  e8bd87f0          POP      {r4-r10,pc}
                  |L52.402|
000192  f8a51152          STRH     r1,[r5,#0x152]        ;1258
000196  e7f1              B        |L52.380|
;;;1270   
                          ENDP

                  |L52.408|
                          DCD      ||.bss||
                  |L52.412|
                          DCD      0x0036ee80

                          AREA ||i.setupFullChargeCondition||, CODE, READONLY, ALIGN=2

                  setupFullChargeCondition PROC
;;;1410   
;;;1411   static void setupFullChargeCondition(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;1412   {
;;;1413   	tScuProtectPar	mScuProtectPar;
;;;1414   	apiSysParGetFullChargeCondition(&mScuProtectPar);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       apiSysParGetFullChargeCondition
;;;1415   	
;;;1416   	mAppScuGauage.FullCharge.Voltage = mScuProtectPar.SetValue.i[0];
000008  4805              LDR      r0,|L53.32|
00000a  f8bd1000          LDRH     r1,[sp,#0]
00000e  8001              STRH     r1,[r0,#0]
;;;1417   	mAppScuGauage.FullCharge.Current = mScuProtectPar.STime.i[0];
000010  f8bd1004          LDRH     r1,[sp,#4]
000014  8041              STRH     r1,[r0,#2]
;;;1418   	mAppScuGauage.FullCharge.Second = mScuProtectPar.RelValue.b[0];
000016  f89d1008          LDRB     r1,[sp,#8]
00001a  7101              STRB     r1,[r0,#4]
;;;1419   }
00001c  bd1f              POP      {r0-r4,pc}
;;;1420   /* Public function prototypes ----------------------------------------------- */
                          ENDP

00001e  0000              DCW      0x0000
                  |L53.32|
                          DCD      ||.bss||+0x158

                          AREA ||i.setupIdleTime||, CODE, READONLY, ALIGN=2

                  setupIdleTime PROC
;;;1290   
;;;1291   static void setupIdleTime(void)
000000  b510              PUSH     {r4,lr}
;;;1292   {
;;;1293   	uint32_t	sec;
;;;1294   	sec = apiRamLoadReleaseTime();
000002  f7fffffe          BL       apiRamLoadReleaseTime
;;;1295   	if(sec >= 0xfff0)
000006  f64f71f0          MOV      r1,#0xfff0
00000a  4288              CMP      r0,r1
00000c  d300              BCC      |L54.16|
;;;1296   		sec = 0xfff0;
00000e  4608              MOV      r0,r1
                  |L54.16|
;;;1297   	mAppScuGauage.RelaxSec = sec;
000010  4901              LDR      r1,|L54.24|
000012  80c8              STRH     r0,[r1,#6]
;;;1298   	mAppScuGauage.ReadSocTime = sec;
000014  8088              STRH     r0,[r1,#4]
;;;1299   }
000016  bd10              POP      {r4,pc}
;;;1300   
                          ENDP

                  |L54.24|
                          DCD      ||.bss||

                          AREA ||i.setupOcvTable||, CODE, READONLY, ALIGN=2

                  setupOcvTable PROC
;;;116    
;;;117    void setupOcvTable(void)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
;;;119    	uint8_t	i;
;;;120    	char	str[100];
;;;121    	
;;;122    	mAppScuGauage.OcvTableNum = 0;
000002  4e0c              LDR      r6,|L55.52|
000004  2000              MOVS     r0,#0
000006  f8860088          STRB     r0,[r6,#0x88]
;;;123    	for(i=0; i<25; i++)
00000a  2400              MOVS     r4,#0
                  |L55.12|
;;;124    	{
;;;125    		apiSysParGetOcvTable(i, &mAppScuGauage.OcvTable[i]);
00000c  eb060184          ADD      r1,r6,r4,LSL #2
000010  460d              MOV      r5,r1
000012  318a              ADDS     r1,r1,#0x8a
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       apiSysParGetOcvTable
;;;126    //		sprintf(str,"OCV %d %d",
;;;127    //					mAppScuGauage.OcvTable[i].Level,
;;;128    //					mAppScuGauage.OcvTable[i].Value);
;;;129    //		scuDebugMsg(str);
;;;130    		
;;;131    		if(mAppScuGauage.OcvTable[i].Level >= 100)
00001a  f895008a          LDRB     r0,[r5,#0x8a]
00001e  2864              CMP      r0,#0x64
000020  d303              BCC      |L55.42|
;;;132    		{
;;;133    			mAppScuGauage.OcvTableNum = i + 1;
000022  1c64              ADDS     r4,r4,#1
000024  f8864088          STRB     r4,[r6,#0x88]
;;;134    			break;
;;;135    		}
;;;136    	}
;;;137    }
000028  bd70              POP      {r4-r6,pc}
                  |L55.42|
00002a  1c64              ADDS     r4,r4,#1              ;123
00002c  b2e4              UXTB     r4,r4                 ;123
00002e  2c19              CMP      r4,#0x19              ;123
000030  d3ec              BCC      |L55.12|
000032  bd70              POP      {r4-r6,pc}
;;;138    static void setupRaTable(void)
                          ENDP

                  |L55.52|
                          DCD      ||.bss||

                          AREA ||i.setupRaTable||, CODE, READONLY, ALIGN=2

                  setupRaTable PROC
;;;137    }
;;;138    static void setupRaTable(void)
000000  b570              PUSH     {r4-r6,lr}
;;;139    {
;;;140    	uint8_t	i;
;;;141    	char	str[100];
;;;142    	mAppScuGauage.RaTableNum = 0;
000002  4e0c              LDR      r6,|L56.52|
000004  2000              MOVS     r0,#0
000006  f8860089          STRB     r0,[r6,#0x89]
;;;143    	
;;;144    	for(i=0; i<25; i++)
00000a  2400              MOVS     r4,#0
                  |L56.12|
;;;145    	{
;;;146    		apiSysParGetRaTable(i, &mAppScuGauage.RaTable[i]);
00000c  eb060184          ADD      r1,r6,r4,LSL #2
000010  460d              MOV      r5,r1
000012  31ee              ADDS     r1,r1,#0xee
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       apiSysParGetRaTable
;;;147    //		sprintf(str,"RA %d %d",
;;;148    //					mAppScuGauage.RaTable[i].Level,
;;;149    //					mAppScuGauage.RaTable[i].Value);
;;;150    //		scuDebugMsg(str);
;;;151    		
;;;152    		if(mAppScuGauage.RaTable[i].Level >= 100)
00001a  f89500ee          LDRB     r0,[r5,#0xee]
00001e  2864              CMP      r0,#0x64
000020  d303              BCC      |L56.42|
;;;153    		{
;;;154    			mAppScuGauage.RaTableNum = i + 1;
000022  1c64              ADDS     r4,r4,#1
000024  f8864089          STRB     r4,[r6,#0x89]
;;;155    			break;
;;;156    		}
;;;157    	}
;;;158    }
000028  bd70              POP      {r4-r6,pc}
                  |L56.42|
00002a  1c64              ADDS     r4,r4,#1              ;144
00002c  b2e4              UXTB     r4,r4                 ;144
00002e  2c19              CMP      r4,#0x19              ;144
000030  d3ec              BCC      |L56.12|
000032  bd70              POP      {r4-r6,pc}
;;;159    
                          ENDP

                  |L56.52|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  mAppScuGauage
                          %        368

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  01f400fa          DCW      0x01f4,0x00fa
000004  00640032          DCW      0x0064,0x0032
000008  0014000a          DCW      0x0014,0x000a
00000c  00050001          DCW      0x0005,0x0001
000010  0000              DCW      0x0000

                          AREA ||.data||, DATA, ALIGN=3

                  count
000000  0000              DCB      0x00,0x00
                  count1
000002  0000              DCW      0x0000
                          DCD      0x00000000
                  avg
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\APP\\AppGauge.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_AppGauge_c_fa720816____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___10_AppGauge_c_fa720816____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_AppGauge_c_fa720816____REVSH|
#line 507
|__asm___10_AppGauge_c_fa720816____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_AppGauge_c_fa720816____RRX|
#line 694
|__asm___10_AppGauge_c_fa720816____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
