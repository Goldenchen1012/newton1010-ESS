; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32l4xx_hal_uart_ex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32l4xx_hal_uart_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../../../Drivers/CMSIS/Include -I../../../Drivers/CMSIS/Device/ST/STM32L4xx/Include -I../../../Drivers/STM32L4xx_HAL_Driver/Inc -I../../../Drivers/BSP/STM32L4xx_Nucleo_144 -I..\..\..\User -I..\..\..\HAL -I..\..\..\Lib -I..\..\..\Config_Common -I..\..\..\AppProtect -I..\..\..\APP -I..\..\..\Lib\SMP -I..\..\..\Drivers\SMP -I..\..\..\BSP -I..\..\..\Drivers\BSP\STM32L496V_Davinci -I..\..\..\API -I..\..\..\AppCommunication -I..\..\..\Drivers\W5500 -I..\..\..\RTT -I.\RTE\_HVESS_Normal -IC:\Users\88691\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\88691\AppData\Local\Arm\Packs\Keil\STM32L4xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32L4xx\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -DSTM32L496xx -D_RTE_ -DSTM32L496xx -DUSE_HAL_DRIVER -DUSE_STM32L4XX_NUCLEO_144 -DBSPSMPS -DUSE_STM32L4XX_NUCLEO_144_SMPS -DUSE_ADP5301ACBZ -W ..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_hal_uart_ex.c]
                          THUMB

                          AREA ||i.HAL_MultiProcessorEx_AddressLength_Set||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessorEx_AddressLength_Set PROC
;;;438      */
;;;439    HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
000000  2800              CMP      r0,#0
;;;440    {
000002  d013              BEQ      |L1.44|
;;;441      /* Check the UART handle allocation */
;;;442      if (huart == NULL)
;;;443      {
;;;444        return HAL_ERROR;
;;;445      }
;;;446    
;;;447      /* Check the address length parameter */
;;;448      assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
;;;449    
;;;450      huart->gState = HAL_UART_STATE_BUSY;
000004  2224              MOVS     r2,#0x24
000006  6782              STR      r2,[r0,#0x78]
;;;451    
;;;452      /* Disable the Peripheral */
;;;453      __HAL_UART_DISABLE(huart);
000008  6802              LDR      r2,[r0,#0]
00000a  6813              LDR      r3,[r2,#0]
00000c  f0230301          BIC      r3,r3,#1
000010  6013              STR      r3,[r2,#0]
;;;454    
;;;455      /* Set the address length */
;;;456      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
000012  6802              LDR      r2,[r0,#0]
000014  6853              LDR      r3,[r2,#4]
000016  f0230310          BIC      r3,r3,#0x10
00001a  430b              ORRS     r3,r3,r1
00001c  6053              STR      r3,[r2,#4]
;;;457    
;;;458      /* Enable the Peripheral */
;;;459      __HAL_UART_ENABLE(huart);
00001e  6801              LDR      r1,[r0,#0]
000020  680a              LDR      r2,[r1,#0]
000022  f0420201          ORR      r2,r2,#1
000026  600a              STR      r2,[r1,#0]
;;;460    
;;;461      /* TEACK and/or REACK to check before moving huart->gState to Ready */
;;;462      return (UART_CheckIdleState(huart));
000028  f7ffbffe          B.W      UART_CheckIdleState
                  |L1.44|
00002c  2001              MOVS     r0,#1                 ;444
;;;463    }
00002e  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.HAL_RS485Ex_Init||, CODE, READONLY, ALIGN=2

                  HAL_RS485Ex_Init PROC
;;;169      */
;;;170    HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;171                                       uint32_t DeassertionTime)
;;;172    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;173      uint32_t temp;
;;;174    
;;;175      /* Check the UART handle allocation */
;;;176      if (huart == NULL)
00000c  2c00              CMP      r4,#0
00000e  d002              BEQ      |L2.22|
;;;177      {
;;;178        return HAL_ERROR;
;;;179      }
;;;180      /* Check the Driver Enable UART instance */
;;;181      assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
;;;182    
;;;183      /* Check the Driver Enable polarity */
;;;184      assert_param(IS_UART_DE_POLARITY(Polarity));
;;;185    
;;;186      /* Check the Driver Enable assertion time */
;;;187      assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
;;;188    
;;;189      /* Check the Driver Enable deassertion time */
;;;190      assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
;;;191    
;;;192      if (huart->gState == HAL_UART_STATE_RESET)
000010  6fa0              LDR      r0,[r4,#0x78]
000012  b118              CBZ      r0,|L2.28|
000014  e008              B        |L2.40|
                  |L2.22|
000016  2001              MOVS     r0,#1                 ;178
                  |L2.24|
;;;193      {
;;;194        /* Allocate lock resource and initialize it */
;;;195        huart->Lock = HAL_UNLOCKED;
;;;196    
;;;197    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;198        UART_InitCallbacksToDefault(huart);
;;;199    
;;;200        if (huart->MspInitCallback == NULL)
;;;201        {
;;;202          huart->MspInitCallback = HAL_UART_MspInit;
;;;203        }
;;;204    
;;;205        /* Init the low level hardware */
;;;206        huart->MspInitCallback(huart);
;;;207    #else
;;;208        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;209        HAL_UART_MspInit(huart);
;;;210    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;211      }
;;;212    
;;;213      huart->gState = HAL_UART_STATE_BUSY;
;;;214    
;;;215      /* Disable the Peripheral */
;;;216      __HAL_UART_DISABLE(huart);
;;;217    
;;;218      /* Set the UART Communication parameters */
;;;219      if (UART_SetConfig(huart) == HAL_ERROR)
;;;220      {
;;;221        return HAL_ERROR;
;;;222      }
;;;223    
;;;224      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;225      {
;;;226        UART_AdvFeatureConfig(huart);
;;;227      }
;;;228    
;;;229      /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
;;;230      SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
;;;231    
;;;232      /* Set the Driver Enable polarity */
;;;233      MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
;;;234    
;;;235      /* Set the Driver Enable assertion and deassertion times */
;;;236      temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
;;;237      temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
;;;238      MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT | USART_CR1_DEAT), temp);
;;;239    
;;;240      /* Enable the Peripheral */
;;;241      __HAL_UART_ENABLE(huart);
;;;242    
;;;243      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;244      return (UART_CheckIdleState(huart));
;;;245    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L2.28|
00001c  2000              MOVS     r0,#0                 ;195
00001e  f8840074          STRB     r0,[r4,#0x74]         ;195
000022  4620              MOV      r0,r4                 ;209
000024  f7fffffe          BL       HAL_UART_MspInit
                  |L2.40|
000028  2024              MOVS     r0,#0x24              ;213
00002a  67a0              STR      r0,[r4,#0x78]         ;213
00002c  6820              LDR      r0,[r4,#0]            ;216
00002e  6801              LDR      r1,[r0,#0]            ;216
000030  f0210101          BIC      r1,r1,#1              ;216
000034  6001              STR      r1,[r0,#0]            ;216
000036  4620              MOV      r0,r4                 ;219
000038  f7fffffe          BL       UART_SetConfig
00003c  2801              CMP      r0,#1                 ;219
00003e  d022              BEQ      |L2.134|
000040  6a60              LDR      r0,[r4,#0x24]         ;224
000042  b110              CBZ      r0,|L2.74|
000044  4620              MOV      r0,r4                 ;226
000046  f7fffffe          BL       UART_AdvFeatureConfig
                  |L2.74|
00004a  6820              LDR      r0,[r4,#0]            ;230
00004c  6881              LDR      r1,[r0,#8]            ;230
00004e  f4414180          ORR      r1,r1,#0x4000         ;230
000052  6081              STR      r1,[r0,#8]            ;230
000054  6820              LDR      r0,[r4,#0]            ;233
000056  6881              LDR      r1,[r0,#8]            ;233
000058  f4214100          BIC      r1,r1,#0x8000         ;233
00005c  4329              ORRS     r1,r1,r5              ;233
00005e  6081              STR      r1,[r0,#8]            ;233
000060  0570              LSLS     r0,r6,#21             ;236
000062  ea404107          ORR      r1,r0,r7,LSL #16      ;237
000066  6820              LDR      r0,[r4,#0]            ;238
000068  6802              LDR      r2,[r0,#0]            ;238
00006a  4b08              LDR      r3,|L2.140|
00006c  401a              ANDS     r2,r2,r3              ;238
00006e  430a              ORRS     r2,r2,r1              ;238
000070  6002              STR      r2,[r0,#0]            ;238
000072  6820              LDR      r0,[r4,#0]            ;241
000074  6801              LDR      r1,[r0,#0]            ;241
000076  f0410101          ORR      r1,r1,#1              ;241
00007a  6001              STR      r1,[r0,#0]            ;241
00007c  4620              MOV      r0,r4                 ;244
00007e  e8bd41f0          POP      {r4-r8,lr}            ;244
000082  f7ffbffe          B.W      UART_CheckIdleState
                  |L2.134|
000086  2001              MOVS     r0,#1                 ;221
000088  e7c6              B        |L2.24|
;;;246    
                          ENDP

00008a  0000              DCW      0x0000
                  |L2.140|
                          DCD      0xfc00ffff

                          AREA ||i.HAL_UARTEx_DisableClockStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_DisableClockStopMode PROC
;;;410      */
;;;411    HAL_StatusTypeDef HAL_UARTEx_DisableClockStopMode(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;412    {
;;;413      /* Process Locked */
;;;414      __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L3.34|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;415    
;;;416      /* Clear UCESM bit */
;;;417      CLEAR_BIT(huart->Instance->CR3, USART_CR3_UCESM);
00000e  6801              LDR      r1,[r0,#0]
000010  688a              LDR      r2,[r1,#8]
000012  f4220200          BIC      r2,r2,#0x800000
000016  608a              STR      r2,[r1,#8]
;;;418    
;;;419      /* Process Unlocked */
;;;420      __HAL_UNLOCK(huart);
000018  2100              MOVS     r1,#0
00001a  f8801074          STRB     r1,[r0,#0x74]
;;;421    
;;;422      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;423    }
000020  4770              BX       lr
                  |L3.34|
000022  2002              MOVS     r0,#2                 ;414
000024  4770              BX       lr
;;;424    
                          ENDP


                          AREA ||i.HAL_UARTEx_DisableStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_DisableStopMode PROC
;;;550      */
;;;551    HAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;552    {
;;;553      /* Process Locked */
;;;554      __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L4.34|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;555    
;;;556      /* Clear UESM bit */
;;;557      CLEAR_BIT(huart->Instance->CR1, USART_CR1_UESM);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  f0220202          BIC      r2,r2,#2
000016  600a              STR      r2,[r1,#0]
;;;558    
;;;559      /* Process Unlocked */
;;;560      __HAL_UNLOCK(huart);
000018  2100              MOVS     r1,#0
00001a  f8801074          STRB     r1,[r0,#0x74]
;;;561    
;;;562      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;563    }
000020  4770              BX       lr
                  |L4.34|
000022  2002              MOVS     r0,#2                 ;554
000024  4770              BX       lr
;;;564    
                          ENDP


                          AREA ||i.HAL_UARTEx_EnableClockStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_EnableClockStopMode PROC
;;;391      */
;;;392    HAL_StatusTypeDef HAL_UARTEx_EnableClockStopMode(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;393    {
;;;394      /* Process Locked */
;;;395      __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L5.34|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;396    
;;;397      /* Set UCESM bit */
;;;398      SET_BIT(huart->Instance->CR3, USART_CR3_UCESM);
00000e  6801              LDR      r1,[r0,#0]
000010  688a              LDR      r2,[r1,#8]
000012  f4420200          ORR      r2,r2,#0x800000
000016  608a              STR      r2,[r1,#8]
;;;399    
;;;400      /* Process Unlocked */
;;;401      __HAL_UNLOCK(huart);
000018  2100              MOVS     r1,#0
00001a  f8801074          STRB     r1,[r0,#0x74]
;;;402    
;;;403      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;404    }
000020  4770              BX       lr
                  |L5.34|
000022  2002              MOVS     r0,#2                 ;395
000024  4770              BX       lr
;;;405    
                          ENDP


                          AREA ||i.HAL_UARTEx_EnableStopMode||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_EnableStopMode PROC
;;;531      */
;;;532    HAL_StatusTypeDef HAL_UARTEx_EnableStopMode(UART_HandleTypeDef *huart)
000000  f8901074          LDRB     r1,[r0,#0x74]
;;;533    {
;;;534      /* Process Locked */
;;;535      __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L6.34|
000008  2101              MOVS     r1,#1
00000a  f8801074          STRB     r1,[r0,#0x74]
;;;536    
;;;537      /* Set UESM bit */
;;;538      SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  f0420202          ORR      r2,r2,#2
000016  600a              STR      r2,[r1,#0]
;;;539    
;;;540      /* Process Unlocked */
;;;541      __HAL_UNLOCK(huart);
000018  2100              MOVS     r1,#0
00001a  f8801074          STRB     r1,[r0,#0x74]
;;;542    
;;;543      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;544    }
000020  4770              BX       lr
                  |L6.34|
000022  2002              MOVS     r0,#2                 ;535
000024  4770              BX       lr
;;;545    
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle PROC
;;;762      */
;;;763    HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;764    {
000004  4604              MOV      r4,r0
000006  f8dd8028          LDR      r8,[sp,#0x28]
00000a  460e              MOV      r6,r1
00000c  4615              MOV      r5,r2
00000e  461f              MOV      r7,r3
;;;765      uint8_t  *pdata8bits;
;;;766      uint16_t *pdata16bits;
;;;767      uint16_t uhMask;
;;;768      uint32_t tickstart;
;;;769    
;;;770      /* Check that a Rx process is not already ongoing */
;;;771      if (huart->RxState == HAL_UART_STATE_READY)
000010  6fe0              LDR      r0,[r4,#0x7c]
000012  2820              CMP      r0,#0x20
000014  d002              BEQ      |L7.28|
;;;772      {
;;;773        if ((pData == NULL) || (Size == 0U))
;;;774        {
;;;775          return  HAL_ERROR;
;;;776        }
;;;777    
;;;778        __HAL_LOCK(huart);
;;;779    
;;;780        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;781        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;782        huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;783    
;;;784        /* Init tickstart for timeout management */
;;;785        tickstart = HAL_GetTick();
;;;786    
;;;787        huart->RxXferSize  = Size;
;;;788        huart->RxXferCount = Size;
;;;789    
;;;790        /* Computation of UART mask to apply to RDR register */
;;;791        UART_MASK_COMPUTATION(huart);
;;;792        uhMask = huart->Mask;
;;;793    
;;;794        /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;795        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;796        {
;;;797          pdata8bits  = NULL;
;;;798          pdata16bits = (uint16_t *) pData;
;;;799        }
;;;800        else
;;;801        {
;;;802          pdata8bits  = pData;
;;;803          pdata16bits = NULL;
;;;804        }
;;;805    
;;;806        __HAL_UNLOCK(huart);
;;;807    
;;;808        /* Initialize output number of received elements */
;;;809        *RxLen = 0U;
;;;810    
;;;811        /* as long as data have to be received */
;;;812        while (huart->RxXferCount > 0U)
;;;813        {
;;;814          /* Check if IDLE flag is set */
;;;815          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
;;;816          {
;;;817            /* Clear IDLE flag in ISR */
;;;818            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
;;;819    
;;;820            /* If Set, but no data ever received, clear flag without exiting loop */
;;;821            /* If Set, and data has already been received, this means Idle Event is valid : End reception */
;;;822            if (*RxLen > 0U)
;;;823            {
;;;824              huart->RxState = HAL_UART_STATE_READY;
;;;825    
;;;826              return HAL_OK;
;;;827            }
;;;828          }
;;;829    
;;;830          /* Check if RXNE flag is set */
;;;831          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))
;;;832          {
;;;833            if (pdata8bits == NULL)
;;;834            {
;;;835              *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
;;;836              pdata16bits++;
;;;837            }
;;;838            else
;;;839            {
;;;840              *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;841              pdata8bits++;
;;;842            }
;;;843            /* Increment number of received elements */
;;;844            *RxLen += 1U;
;;;845            huart->RxXferCount--;
;;;846          }
;;;847    
;;;848          /* Check for the Timeout */
;;;849          if (Timeout != HAL_MAX_DELAY)
;;;850          {
;;;851            if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;852            {
;;;853              huart->RxState = HAL_UART_STATE_READY;
;;;854    
;;;855              return HAL_TIMEOUT;
;;;856            }
;;;857          }
;;;858        }
;;;859    
;;;860        /* Set number of received elements in output parameter : RxLen */
;;;861        *RxLen = huart->RxXferSize - huart->RxXferCount;
;;;862        /* At end of Rx process, restore huart->RxState to Ready */
;;;863        huart->RxState = HAL_UART_STATE_READY;
;;;864    
;;;865        return HAL_OK;
;;;866      }
;;;867      else
;;;868      {
;;;869        return HAL_BUSY;
000016  2002              MOVS     r0,#2
                  |L7.24|
;;;870      }
;;;871    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.28|
00001c  b306              CBZ      r6,|L7.96|
00001e  b1fd              CBZ      r5,|L7.96|
000020  f8940074          LDRB     r0,[r4,#0x74]         ;778
000024  2801              CMP      r0,#1                 ;778
000026  d01d              BEQ      |L7.100|
000028  2001              MOVS     r0,#1                 ;778
00002a  f8840074          STRB     r0,[r4,#0x74]         ;778
00002e  f04f0b00          MOV      r11,#0                ;780
000032  f8c4b080          STR      r11,[r4,#0x80]        ;780
000036  2122              MOVS     r1,#0x22              ;781
000038  67e1              STR      r1,[r4,#0x7c]         ;781
00003a  6620              STR      r0,[r4,#0x60]         ;782
00003c  f7fffffe          BL       HAL_GetTick
000040  4682              MOV      r10,r0                ;785
000042  f8a45058          STRH     r5,[r4,#0x58]         ;787
000046  f8a4505a          STRH     r5,[r4,#0x5a]         ;788
00004a  68a0              LDR      r0,[r4,#8]            ;791
00004c  f44f5280          MOV      r2,#0x1000            ;791
000050  23ff              MOVS     r3,#0xff              ;791
000052  4290              CMP      r0,r2                 ;791
000054  d10d              BNE      |L7.114|
000056  6921              LDR      r1,[r4,#0x10]         ;791
000058  b131              CBZ      r1,|L7.104|
00005a  f8a4305c          STRH     r3,[r4,#0x5c]         ;791
00005e  e00f              B        |L7.128|
                  |L7.96|
000060  2001              MOVS     r0,#1                 ;775
000062  e7d9              B        |L7.24|
                  |L7.100|
000064  2002              MOVS     r0,#2                 ;778
000066  e7d7              B        |L7.24|
                  |L7.104|
000068  f24011ff          MOV      r1,#0x1ff             ;791
00006c  f8a4105c          STRH     r1,[r4,#0x5c]         ;791
000070  e006              B        |L7.128|
                  |L7.114|
000072  217f              MOVS     r1,#0x7f              ;791
000074  b198              CBZ      r0,|L7.158|
000076  f1b05f80          CMP      r0,#0x10000000        ;791
00007a  d018              BEQ      |L7.174|
00007c  f8a4b05c          STRH     r11,[r4,#0x5c]        ;791
                  |L7.128|
000080  f8b4905c          LDRH     r9,[r4,#0x5c]         ;792
000084  4290              CMP      r0,r2                 ;795
000086  d101              BNE      |L7.140|
000088  6920              LDR      r0,[r4,#0x10]         ;795
00008a  b1c8              CBZ      r0,|L7.192|
                  |L7.140|
00008c  4635              MOV      r5,r6                 ;802
00008e  2600              MOVS     r6,#0                 ;803
                  |L7.144|
000090  f884b074          STRB     r11,[r4,#0x74]        ;806
000094  f8a7b000          STRH     r11,[r7,#0]           ;809
000098  f04f0b20          MOV      r11,#0x20             ;824
00009c  e03c              B        |L7.280|
                  |L7.158|
00009e  6925              LDR      r5,[r4,#0x10]         ;791
0000a0  b115              CBZ      r5,|L7.168|
0000a2  f8a4105c          STRH     r1,[r4,#0x5c]         ;791
0000a6  e7eb              B        |L7.128|
                  |L7.168|
0000a8  f8a4305c          STRH     r3,[r4,#0x5c]         ;791
0000ac  e7e8              B        |L7.128|
                  |L7.174|
0000ae  6923              LDR      r3,[r4,#0x10]         ;791
0000b0  b11b              CBZ      r3,|L7.186|
0000b2  213f              MOVS     r1,#0x3f              ;791
0000b4  f8a4105c          STRH     r1,[r4,#0x5c]         ;791
0000b8  e7e2              B        |L7.128|
                  |L7.186|
0000ba  f8a4105c          STRH     r1,[r4,#0x5c]         ;791
0000be  e7df              B        |L7.128|
                  |L7.192|
0000c0  2500              MOVS     r5,#0                 ;797
0000c2  e7e5              B        |L7.144|
                  |L7.196|
0000c4  6820              LDR      r0,[r4,#0]            ;815
0000c6  69c1              LDR      r1,[r0,#0x1c]         ;815
0000c8  06c9              LSLS     r1,r1,#27             ;815
0000ca  d507              BPL      |L7.220|
0000cc  2110              MOVS     r1,#0x10              ;818
0000ce  6201              STR      r1,[r0,#0x20]         ;818
0000d0  8838              LDRH     r0,[r7,#0]            ;822
0000d2  b118              CBZ      r0,|L7.220|
0000d4  f8c4b07c          STR      r11,[r4,#0x7c]        ;824
0000d8  2000              MOVS     r0,#0                 ;826
0000da  e79d              B        |L7.24|
                  |L7.220|
0000dc  6820              LDR      r0,[r4,#0]            ;831
0000de  69c1              LDR      r1,[r0,#0x1c]         ;831
0000e0  0689              LSLS     r1,r1,#26             ;831
0000e2  d50d              BPL      |L7.256|
0000e4  b32d              CBZ      r5,|L7.306|
0000e6  8c80              LDRH     r0,[r0,#0x24]         ;840
0000e8  ea000009          AND      r0,r0,r9              ;840
0000ec  f8050b01          STRB     r0,[r5],#1            ;840
                  |L7.240|
0000f0  8838              LDRH     r0,[r7,#0]            ;844
0000f2  1c40              ADDS     r0,r0,#1              ;844
0000f4  8038              STRH     r0,[r7,#0]            ;844
0000f6  f8b4005a          LDRH     r0,[r4,#0x5a]         ;845
0000fa  1e40              SUBS     r0,r0,#1              ;845
0000fc  f8a4005a          STRH     r0,[r4,#0x5a]         ;845
                  |L7.256|
000100  f1b83fff          CMP      r8,#0xffffffff        ;849
000104  d008              BEQ      |L7.280|
000106  f7fffffe          BL       HAL_GetTick
00010a  eba0000a          SUB      r0,r0,r10             ;851
00010e  4540              CMP      r0,r8                 ;851
000110  d815              BHI      |L7.318|
000112  f1b80f00          CMP      r8,#0                 ;851
000116  d012              BEQ      |L7.318|
                  |L7.280|
000118  f8b4005a          LDRH     r0,[r4,#0x5a]         ;812
00011c  2800              CMP      r0,#0                 ;812
00011e  d1d1              BNE      |L7.196|
000120  f8340f58          LDRH     r0,[r4,#0x58]!        ;861
000124  8861              LDRH     r1,[r4,#2]            ;861
000126  1a40              SUBS     r0,r0,r1              ;861
000128  8038              STRH     r0,[r7,#0]            ;861
00012a  f8c4b024          STR      r11,[r4,#0x24]        ;863
00012e  2000              MOVS     r0,#0                 ;865
000130  e772              B        |L7.24|
                  |L7.306|
000132  8c80              LDRH     r0,[r0,#0x24]         ;835
000134  ea000009          AND      r0,r0,r9              ;835
000138  f8260b02          STRH     r0,[r6],#2            ;835
00013c  e7d8              B        |L7.240|
                  |L7.318|
00013e  f8c4b07c          STR      r11,[r4,#0x7c]        ;853
000142  2003              MOVS     r0,#3                 ;855
000144  e768              B        |L7.24|
;;;872    
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_DMA||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_DMA PROC
;;;946      */
;;;947    HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;948    {
000002  4604              MOV      r4,r0
;;;949      HAL_StatusTypeDef status;
;;;950    
;;;951      /* Check that a Rx process is not already ongoing */
;;;952      if (huart->RxState == HAL_UART_STATE_READY)
000004  6fe0              LDR      r0,[r4,#0x7c]
000006  2820              CMP      r0,#0x20
000008  d001              BEQ      |L8.14|
;;;953      {
;;;954        if ((pData == NULL) || (Size == 0U))
;;;955        {
;;;956          return HAL_ERROR;
;;;957        }
;;;958    
;;;959        __HAL_LOCK(huart);
;;;960    
;;;961        /* Set Reception type to reception till IDLE Event*/
;;;962        huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;963    
;;;964        status =  UART_Start_Receive_DMA(huart, pData, Size);
;;;965    
;;;966        /* Check Rx process has been successfully started */
;;;967        if (status == HAL_OK)
;;;968        {
;;;969          if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;970          {
;;;971            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
;;;972            SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;973          }
;;;974          else
;;;975          {
;;;976            /* In case of errors already pending when reception is started,
;;;977               Interrupts may have already been raised and lead to reception abortion.
;;;978               (Overrun error for instance).
;;;979               In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;980            status = HAL_ERROR;
;;;981          }
;;;982        }
;;;983    
;;;984        return status;
;;;985      }
;;;986      else
;;;987      {
;;;988        return HAL_BUSY;
00000a  2002              MOVS     r0,#2
                  |L8.12|
;;;989      }
;;;990    }
00000c  bd10              POP      {r4,pc}
                  |L8.14|
00000e  b191              CBZ      r1,|L8.54|
000010  b18a              CBZ      r2,|L8.54|
000012  f8940074          LDRB     r0,[r4,#0x74]         ;959
000016  2801              CMP      r0,#1                 ;959
000018  d00f              BEQ      |L8.58|
00001a  2001              MOVS     r0,#1                 ;959
00001c  f8840074          STRB     r0,[r4,#0x74]         ;959
000020  6620              STR      r0,[r4,#0x60]         ;962
000022  4620              MOV      r0,r4                 ;964
000024  f7fffffe          BL       UART_Start_Receive_DMA
000028  2800              CMP      r0,#0                 ;959
00002a  d1ef              BNE      |L8.12|
00002c  6e21              LDR      r1,[r4,#0x60]         ;969
00002e  2901              CMP      r1,#1                 ;969
000030  d005              BEQ      |L8.62|
000032  2001              MOVS     r0,#1                 ;980
000034  bd10              POP      {r4,pc}
                  |L8.54|
000036  2001              MOVS     r0,#1                 ;956
000038  bd10              POP      {r4,pc}
                  |L8.58|
00003a  2002              MOVS     r0,#2                 ;959
00003c  bd10              POP      {r4,pc}
                  |L8.62|
00003e  6822              LDR      r2,[r4,#0]            ;971
000040  2110              MOVS     r1,#0x10              ;971
000042  6211              STR      r1,[r2,#0x20]         ;971
000044  6821              LDR      r1,[r4,#0]            ;972
000046  680a              LDR      r2,[r1,#0]            ;972
000048  f0420210          ORR      r2,r2,#0x10           ;972
00004c  600a              STR      r2,[r1,#0]            ;972
00004e  bd10              POP      {r4,pc}
;;;991    
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_IT||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_IT PROC
;;;885      */
;;;886    HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;887    {
000002  4604              MOV      r4,r0
;;;888      HAL_StatusTypeDef status;
;;;889    
;;;890      /* Check that a Rx process is not already ongoing */
;;;891      if (huart->RxState == HAL_UART_STATE_READY)
000004  6fe0              LDR      r0,[r4,#0x7c]
000006  2820              CMP      r0,#0x20
000008  d001              BEQ      |L9.14|
;;;892      {
;;;893        if ((pData == NULL) || (Size == 0U))
;;;894        {
;;;895          return HAL_ERROR;
;;;896        }
;;;897    
;;;898        __HAL_LOCK(huart);
;;;899    
;;;900        /* Set Reception type to reception till IDLE Event*/
;;;901        huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;902    
;;;903        status =  UART_Start_Receive_IT(huart, pData, Size);
;;;904    
;;;905        /* Check Rx process has been successfully started */
;;;906        if (status == HAL_OK)
;;;907        {
;;;908          if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;909          {
;;;910            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
;;;911            SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;912          }
;;;913          else
;;;914          {
;;;915            /* In case of errors already pending when reception is started,
;;;916               Interrupts may have already been raised and lead to reception abortion.
;;;917               (Overrun error for instance).
;;;918               In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;919            status = HAL_ERROR;
;;;920          }
;;;921        }
;;;922    
;;;923        return status;
;;;924      }
;;;925      else
;;;926      {
;;;927        return HAL_BUSY;
00000a  2002              MOVS     r0,#2
                  |L9.12|
;;;928      }
;;;929    }
00000c  bd10              POP      {r4,pc}
                  |L9.14|
00000e  b191              CBZ      r1,|L9.54|
000010  b18a              CBZ      r2,|L9.54|
000012  f8940074          LDRB     r0,[r4,#0x74]         ;898
000016  2801              CMP      r0,#1                 ;898
000018  d00f              BEQ      |L9.58|
00001a  2001              MOVS     r0,#1                 ;898
00001c  f8840074          STRB     r0,[r4,#0x74]         ;898
000020  6620              STR      r0,[r4,#0x60]         ;901
000022  4620              MOV      r0,r4                 ;903
000024  f7fffffe          BL       UART_Start_Receive_IT
000028  2800              CMP      r0,#0                 ;898
00002a  d1ef              BNE      |L9.12|
00002c  6e21              LDR      r1,[r4,#0x60]         ;908
00002e  2901              CMP      r1,#1                 ;908
000030  d005              BEQ      |L9.62|
000032  2001              MOVS     r0,#1                 ;919
000034  bd10              POP      {r4,pc}
                  |L9.54|
000036  2001              MOVS     r0,#1                 ;895
000038  bd10              POP      {r4,pc}
                  |L9.58|
00003a  2002              MOVS     r0,#2                 ;898
00003c  bd10              POP      {r4,pc}
                  |L9.62|
00003e  6822              LDR      r2,[r4,#0]            ;910
000040  2110              MOVS     r1,#0x10              ;910
000042  6211              STR      r1,[r2,#0x20]         ;910
000044  6821              LDR      r1,[r4,#0]            ;911
000046  680a              LDR      r2,[r1,#0]            ;911
000048  f0420210          ORR      r2,r2,#0x10           ;911
00004c  600a              STR      r2,[r1,#0]            ;911
00004e  bd10              POP      {r4,pc}
;;;930    
                          ENDP


                          AREA ||i.HAL_UARTEx_StopModeWakeUpSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_StopModeWakeUpSourceConfig PROC
;;;476      */
;;;477    HAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;478    {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
;;;479      HAL_StatusTypeDef status = HAL_OK;
000006  2500              MOVS     r5,#0
;;;480      uint32_t tickstart;
;;;481    
;;;482      /* check the wake-up from stop mode UART instance */
;;;483      assert_param(IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance));
;;;484      /* check the wake-up selection parameter */
;;;485      assert_param(IS_UART_WAKEUP_SELECTION(WakeUpSelection.WakeUpEvent));
;;;486    
;;;487      /* Process Locked */
;;;488      __HAL_LOCK(huart);
000008  f8940074          LDRB     r0,[r4,#0x74]
00000c  2801              CMP      r0,#1
00000e  d013              BEQ      |L10.56|
000010  2001              MOVS     r0,#1
000012  f8840074          STRB     r0,[r4,#0x74]
;;;489    
;;;490      huart->gState = HAL_UART_STATE_BUSY;
000016  2024              MOVS     r0,#0x24
000018  67a0              STR      r0,[r4,#0x78]
;;;491    
;;;492      /* Disable the Peripheral */
;;;493      __HAL_UART_DISABLE(huart);
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
;;;494    
;;;495      /* Set the wake-up selection scheme */
;;;496      MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
000024  6820              LDR      r0,[r4,#0]
000026  6881              LDR      r1,[r0,#8]
000028  9a03              LDR      r2,[sp,#0xc]
00002a  f4211140          BIC      r1,r1,#0x300000
00002e  4311              ORRS     r1,r1,r2
000030  6081              STR      r1,[r0,#8]
000032  9803              LDR      r0,[sp,#0xc]          ;488
000034  b118              CBZ      r0,|L10.62|
000036  e007              B        |L10.72|
                  |L10.56|
000038  2002              MOVS     r0,#2                 ;488
                  |L10.58|
;;;497    
;;;498      if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
;;;499      {
;;;500        UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
;;;501      }
;;;502    
;;;503      /* Enable the Peripheral */
;;;504      __HAL_UART_ENABLE(huart);
;;;505    
;;;506      /* Init tickstart for timeout management */
;;;507      tickstart = HAL_GetTick();
;;;508    
;;;509      /* Wait until REACK flag is set */
;;;510      if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;511      {
;;;512        status = HAL_TIMEOUT;
;;;513      }
;;;514      else
;;;515      {
;;;516        /* Initialize the UART State */
;;;517        huart->gState = HAL_UART_STATE_READY;
;;;518      }
;;;519    
;;;520      /* Process Unlocked */
;;;521      __HAL_UNLOCK(huart);
;;;522    
;;;523      return status;
;;;524    }
00003a  b005              ADD      sp,sp,#0x14
00003c  bd30              POP      {r4,r5,pc}
                  |L10.62|
00003e  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;500
000042  4620              MOV      r0,r4                 ;500
000044  f7fffffe          BL       UARTEx_Wakeup_AddressConfig
                  |L10.72|
000048  6820              LDR      r0,[r4,#0]            ;504
00004a  6801              LDR      r1,[r0,#0]            ;504
00004c  f0410101          ORR      r1,r1,#1              ;504
000050  6001              STR      r1,[r0,#0]            ;504
000052  f7fffffe          BL       HAL_GetTick
000056  4603              MOV      r3,r0                 ;507
000058  f06f407e          MVN      r0,#0xfe000000        ;510
00005c  9000              STR      r0,[sp,#0]            ;510
00005e  2200              MOVS     r2,#0                 ;510
000060  f44f0180          MOV      r1,#0x400000          ;510
000064  4620              MOV      r0,r4                 ;510
000066  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006a  b108              CBZ      r0,|L10.112|
00006c  2503              MOVS     r5,#3                 ;512
00006e  e001              B        |L10.116|
                  |L10.112|
000070  2020              MOVS     r0,#0x20              ;517
000072  67a0              STR      r0,[r4,#0x78]         ;517
                  |L10.116|
000074  2000              MOVS     r0,#0                 ;521
000076  f8840074          STRB     r0,[r4,#0x74]         ;521
00007a  4628              MOV      r0,r5                 ;523
00007c  e7dd              B        |L10.58|
;;;525    
                          ENDP


                          AREA ||i.HAL_UARTEx_WakeupCallback||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_WakeupCallback PROC
;;;275      */
;;;276    __weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;277    {
;;;278      /* Prevent unused argument(s) compilation warning */
;;;279      UNUSED(huart);
;;;280    
;;;281      /* NOTE : This function should not be modified, when the callback is needed,
;;;282                the HAL_UARTEx_WakeupCallback can be implemented in the user file.
;;;283       */
;;;284    }
;;;285    
                          ENDP


                          AREA ||i.UARTEx_Wakeup_AddressConfig||, CODE, READONLY, ALIGN=1

                  UARTEx_Wakeup_AddressConfig PROC
;;;1009     */
;;;1010   static void UARTEx_Wakeup_AddressConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)
000000  b507              PUSH     {r0-r2,lr}
;;;1011   {
;;;1012     assert_param(IS_UART_ADDRESSLENGTH_DETECT(WakeUpSelection.AddressLength));
;;;1013   
;;;1014     /* Set the USART address length */
;;;1015     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
000002  6801              LDR      r1,[r0,#0]
000004  684a              LDR      r2,[r1,#4]
000006  f8bd3008          LDRH     r3,[sp,#8]
00000a  f0220210          BIC      r2,r2,#0x10
00000e  431a              ORRS     r2,r2,r3
000010  604a              STR      r2,[r1,#4]
;;;1016   
;;;1017     /* Set the USART address node */
;;;1018     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
000012  6800              LDR      r0,[r0,#0]
000014  f89d200a          LDRB     r2,[sp,#0xa]
000018  6841              LDR      r1,[r0,#4]
00001a  f362611f          BFI      r1,r2,#24,#8
00001e  6041              STR      r1,[r0,#4]
;;;1019   }
000020  bd0e              POP      {r1-r3,pc}
;;;1020   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Drivers\\STM32L4xx_HAL_Driver\\Src\\stm32l4xx_hal_uart_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32l4xx_hal_uart_ex_c_83a37df4____REV16|
#line 492 "../../../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___23_stm32l4xx_hal_uart_ex_c_83a37df4____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32l4xx_hal_uart_ex_c_83a37df4____REVSH|
#line 507
|__asm___23_stm32l4xx_hal_uart_ex_c_83a37df4____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32l4xx_hal_uart_ex_c_83a37df4____RRX|
#line 694
|__asm___23_stm32l4xx_hal_uart_ex_c_83a37df4____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
