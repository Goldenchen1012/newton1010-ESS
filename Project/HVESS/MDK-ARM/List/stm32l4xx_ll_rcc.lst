L 1 "..\..\..\Drivers\STM32L4xx_HAL_Driver\Src\stm32l4xx_ll_rcc.c"
N/**
N  ******************************************************************************
N  * @file    stm32l4xx_ll_rcc.c
N  * @author  MCD Application Team
N  * @brief   RCC LL module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N#if defined(USE_FULL_LL_DRIVER)
X#if 0L
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32l4xx_ll_rcc.h"
S#ifdef  USE_FULL_ASSERT
S  #include "stm32_assert.h"
S#else
S  #define assert_param(expr) ((void)0U)
S#endif
S/** @addtogroup STM32L4xx_LL_Driver
S  * @{
S  */
S
S#if defined(RCC)
S
S/** @addtogroup RCC_LL
S  * @{
S  */
S
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/* Private macros ------------------------------------------------------------*/
S/** @addtogroup RCC_LL_Private_Macros
S  * @{
S  */
S#if   defined(RCC_CCIPR_USART3SEL)
S#define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_USART2_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_USART3_CLKSOURCE))
X#define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_USART2_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_USART3_CLKSOURCE))
S#else
S#define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_USART2_CLKSOURCE))
X#define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_USART2_CLKSOURCE))
S
S#endif /* RCC_CCIPR_USART3SEL */
S#if defined(RCC_CCIPR_UART4SEL) && defined(RCC_CCIPR_UART5SEL)
S#define IS_LL_RCC_UART_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_UART4_CLKSOURCE) \
S                                             || ((__VALUE__) == LL_RCC_UART5_CLKSOURCE))
X#define IS_LL_RCC_UART_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_UART4_CLKSOURCE)                                              || ((__VALUE__) == LL_RCC_UART5_CLKSOURCE))
S#elif defined(RCC_CCIPR_UART4SEL)
S#define IS_LL_RCC_UART_CLKSOURCE(__VALUE__)    ((__VALUE__) == LL_RCC_UART4_CLKSOURCE)
S#elif defined(RCC_CCIPR_UART5SEL)
S#define IS_LL_RCC_UART_CLKSOURCE(__VALUE__)    ((__VALUE__) == LL_RCC_UART5_CLKSOURCE)
S#endif /* RCC_CCIPR_UART4SEL && RCC_CCIPR_UART5SEL*/
S
S#define IS_LL_RCC_LPUART_CLKSOURCE(__VALUE__) (((__VALUE__) == LL_RCC_LPUART1_CLKSOURCE))
S
S#if defined(RCC_CCIPR_I2C2SEL) && defined(RCC_CCIPR_I2C3SEL) && defined(RCC_CCIPR2_I2C4SEL)
S#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_I2C4_CLKSOURCE))
X#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_I2C4_CLKSOURCE))
S#elif defined(RCC_CCIPR_I2C2SEL) && defined(RCC_CCIPR_I2C3SEL)
S#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE))
X#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE))
S
S#elif !defined(RCC_CCIPR_I2C2SEL) && defined(RCC_CCIPR_I2C3SEL)
S#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE))
X#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE))
S
S#else
S#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)     ((__VALUE__) == LL_RCC_I2C1_CLKSOURCE)
S
S#endif /* RCC_CCIPR_I2C2SEL && RCC_CCIPR_I2C3SEL && RCC_CCIPR2_I2C4SEL */
S#define IS_LL_RCC_LPTIM_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_LPTIM1_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_LPTIM2_CLKSOURCE))
X#define IS_LL_RCC_LPTIM_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_LPTIM1_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_LPTIM2_CLKSOURCE))
S
S#if defined(RCC_CCIPR_SAI2SEL) || defined(RCC_CCIPR2_SAI2SEL)
S#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_CLKSOURCE) \
S                                            || ((__VALUE__) == LL_RCC_SAI2_CLKSOURCE))
X#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_CLKSOURCE)                                             || ((__VALUE__) == LL_RCC_SAI2_CLKSOURCE))
S#elif defined(RCC_CCIPR_SAI1SEL) || defined(RCC_CCIPR2_SAI1SEL)
S#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    ((__VALUE__) == LL_RCC_SAI1_CLKSOURCE)
S#endif /* RCC_CCIPR_SAI2SEL RCC_CCIPR2_SAI2SEL ||*/
S
S#if defined(SDMMC1)
S#if defined(RCC_CCIPR2_SDMMCSEL)
S#define IS_LL_RCC_SDMMC_KERNELCLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_SDMMC1_KERNELCLKSOURCE))
S#endif /* RCC_CCIPR2_SDMMCSEL */
S
S#define IS_LL_RCC_SDMMC_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_SDMMC1_CLKSOURCE))
S#endif /* SDMMC1 */
S
S#define IS_LL_RCC_RNG_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_RNG_CLKSOURCE))
S
S#if defined(USB_OTG_FS) || defined(USB)
S#define IS_LL_RCC_USB_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_USB_CLKSOURCE))
S#endif /* USB_OTG_FS || USB */
S
S#define IS_LL_RCC_ADC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_ADC_CLKSOURCE))
S
S#if defined(SWPMI1)
S#define IS_LL_RCC_SWPMI_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_SWPMI1_CLKSOURCE))
S#endif /* SWPMI1 */
S
S#if   defined(DFSDM1_Channel0)
S#define IS_LL_RCC_DFSDM_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_DFSDM1_CLKSOURCE))
S#if defined(RCC_CCIPR2_DFSDM1SEL)
S#define IS_LL_RCC_DFSDM_AUDIO_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_DFSDM1_AUDIO_CLKSOURCE))
S#endif /* RCC_CCIPR2_DFSDM1SEL */
S#endif /* DFSDM1_Channel0 */
S
S#if defined(DSI)
S#define IS_LL_RCC_DSI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_DSI_CLKSOURCE))
S#endif /* DSI */
S
S#if defined(LTDC)
S#define IS_LL_RCC_LTDC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_LTDC_CLKSOURCE))
S#endif /* LTDC */
S
S#if defined(OCTOSPI1)
S#define IS_LL_RCC_OCTOSPI_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_OCTOSPI_CLKSOURCE))
S#endif /* OCTOSPI */
S
S/**
S  * @}
S  */
S
S/* Private function prototypes -----------------------------------------------*/
S/** @defgroup RCC_LL_Private_Functions RCC Private functions
S  * @{
S  */
Sstatic uint32_t RCC_GetSystemClockFreq(void);
Sstatic uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency);
Sstatic uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency);
Sstatic uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency);
Sstatic uint32_t RCC_PLL_GetFreqDomain_SYS(void);
S#if defined(RCC_CCIPR_SAI1SEL) || defined(RCC_CCIPR_SAI2SEL) || defined(RCC_CCIPR2_SAI1SEL) || defined(RCC_CCIPR2_SAI2SEL)
Sstatic uint32_t RCC_PLL_GetFreqDomain_SAI(void);
S#endif
Sstatic uint32_t RCC_PLL_GetFreqDomain_48M(void);
S#if defined(RCC_PLLSAI1_SUPPORT)
Sstatic uint32_t RCC_PLLSAI1_GetFreqDomain_SAI(void);
Sstatic uint32_t RCC_PLLSAI1_GetFreqDomain_48M(void);
Sstatic uint32_t RCC_PLLSAI1_GetFreqDomain_ADC(void);
S#endif /* RCC_PLLSAI1_SUPPORT */
S#if defined(RCC_PLLSAI2_SUPPORT)
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_SAI(void);
S#if defined(LTDC)
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_LTDC(void);
S#else
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_ADC(void);
S#endif /* LTDC */
S#if defined(DSI)
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_DSI(void);
S#endif /* DSI */
S#endif /*RCC_PLLSAI2_SUPPORT*/
S/**
S  * @}
S  */
S
S
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup RCC_LL_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup RCC_LL_EF_Init
S  * @{
S  */
S
S/**
S  * @brief  Reset the RCC clock configuration to the default reset state.
S  * @note   The default reset state of the clock configuration is given below:
S  *         - MSI  ON and used as system clock source
S  *         - HSE, HSI, PLL, PLLSAI1 and PLLSAI2 OFF
S  *         - AHB, APB1 and APB2 prescaler set to 1.
S  *         - CSS, MCO OFF
S  *         - All interrupts disabled
S  * @note   This function doesn't modify the configuration of the
S  *         - Peripheral clocks
S  *         - LSI, LSE and RTC clocks
S  * @retval An ErrorStatus enumeration value:
S  *          - SUCCESS: RCC registers are de-initialized
S  *          - ERROR: not applicable
S  */
SErrorStatus LL_RCC_DeInit(void)
S{
S  __IO uint32_t vl_mask;
S
S  /* Set MSION bit */
S  LL_RCC_MSI_Enable();
S
S  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
S  while (LL_RCC_MSI_IsReady() == 0U)
S  {
S  }
S
S  /* Set MSIRANGE default value */
S  LL_RCC_MSI_SetRange(LL_RCC_MSIRANGE_6);
S
S  /* Set MSITRIM bits to the reset value*/
S  LL_RCC_MSI_SetCalibTrimming(0);
S
S  /* Set HSITRIM bits to the reset value*/
S#if defined(RCC_ICSCR_HSITRIM_6)
S  LL_RCC_HSI_SetCalibTrimming(0x40U);
S#else
S  LL_RCC_HSI_SetCalibTrimming(0x10U);
S#endif /* RCC_ICSCR_HSITRIM_6 */
S
S  /* Reset CFGR register */
S  LL_RCC_WriteReg(CFGR, 0x00000000U);
S
S  /* Read CR register */
S  vl_mask = LL_RCC_ReadReg(CR);
S
S  /* Reset HSION, HSIKERON, HSIASFS, HSEON, PLLON bits */
S  CLEAR_BIT(vl_mask,
S            (RCC_CR_HSION | RCC_CR_HSIASFS | RCC_CR_HSIKERON  | RCC_CR_HSEON | RCC_CR_PLLON));
S
S#if defined(RCC_PLLSAI1_SUPPORT)
S  /* Reset PLLSAI1ON bit */
S  CLEAR_BIT(vl_mask, RCC_CR_PLLSAI1ON);
S#endif /*RCC_PLLSAI1_SUPPORT*/
S
S#if defined(RCC_PLLSAI2_SUPPORT)
S  /* Reset PLLSAI2ON bit */
S  CLEAR_BIT(vl_mask, RCC_CR_PLLSAI2ON);
S#endif /*RCC_PLLSAI2_SUPPORT*/
S
S  /* Write new value in CR register */
S  LL_RCC_WriteReg(CR, vl_mask);
S
S#if defined(RCC_PLLSAI2_SUPPORT)
S  /* Wait for PLLRDY, PLLSAI1RDY and PLLSAI2RDY bits to be reset */
S  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY) != 0U)
S  {
S  }
S#elif defined(RCC_PLLSAI1_SUPPORT)
S  /* Wait for PLLRDY and PLLSAI1RDY to be reset */
S  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY) != 0U)
S  {
S  }
S#else
S  /* Wait for PLLRDY bit to be reset */
S  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
S  {
S  }
S#endif
S
S  /* Reset PLLCFGR register */
S  LL_RCC_WriteReg(PLLCFGR, 16U << RCC_PLLCFGR_PLLN_Pos);
S
S#if defined(RCC_PLLSAI1_SUPPORT)
S  /* Reset PLLSAI1CFGR register */
S  LL_RCC_WriteReg(PLLSAI1CFGR, 16U << RCC_PLLSAI1CFGR_PLLSAI1N_Pos);
S#endif /*RCC_PLLSAI1_SUPPORT*/
S
S#if defined(RCC_PLLSAI2_SUPPORT)
S  /* Reset PLLSAI2CFGR register */
S  LL_RCC_WriteReg(PLLSAI2CFGR, 16U << RCC_PLLSAI2CFGR_PLLSAI2N_Pos);
S#endif /*RCC_PLLSAI2_SUPPORT*/
S
S  /* Reset HSEBYP bit */
S  LL_RCC_HSE_DisableBypass();
S
S  /* Disable all interrupts */
S  LL_RCC_WriteReg(CIER, 0x00000000U);
S
S  /* Clear all interrupt flags */
S  vl_mask = RCC_CICR_LSIRDYC | RCC_CICR_LSERDYC | RCC_CICR_MSIRDYC | RCC_CICR_HSIRDYC | RCC_CICR_HSERDYC | RCC_CICR_PLLRDYC | \
S            RCC_CICR_CSSC | RCC_CICR_LSECSSC;
X  vl_mask = RCC_CICR_LSIRDYC | RCC_CICR_LSERDYC | RCC_CICR_MSIRDYC | RCC_CICR_HSIRDYC | RCC_CICR_HSERDYC | RCC_CICR_PLLRDYC |             RCC_CICR_CSSC | RCC_CICR_LSECSSC;
S#if defined(RCC_HSI48_SUPPORT)
S  vl_mask |= RCC_CICR_HSI48RDYC;
S#endif
S#if defined(RCC_PLLSAI1_SUPPORT)
S  vl_mask |= RCC_CICR_PLLSAI1RDYC;
S#endif
S#if defined(RCC_PLLSAI2_SUPPORT)
S  vl_mask |= RCC_CICR_PLLSAI2RDYC;
S#endif
S  LL_RCC_WriteReg(CICR, vl_mask);
S
S  /* Clear reset flags */
S  LL_RCC_ClearResetFlags();
S
S  return SUCCESS;
S}
S
S/**
S  * @}
S  */
S
S/** @addtogroup RCC_LL_EF_Get_Freq
S  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks
S  *         and different peripheral clocks available on the device.
S  * @note   If SYSCLK source is MSI, function returns values based on MSI_VALUE(*)
S  * @note   If SYSCLK source is HSI, function returns values based on HSI_VALUE(**)
S  * @note   If SYSCLK source is HSE, function returns values based on HSE_VALUE(***)
S  * @note   If SYSCLK source is PLL, function returns values based on HSE_VALUE(***)
S  *         or HSI_VALUE(**) or MSI_VALUE(*) multiplied/divided by the PLL factors.
S  * @note   (*) MSI_VALUE is a constant defined in this file (default value
S  *             4 MHz) but the real value may vary depending on the variations
S  *             in voltage and temperature.
S  * @note   (**) HSI_VALUE is a constant defined in this file (default value
S  *              16 MHz) but the real value may vary depending on the variations
S  *              in voltage and temperature.
S  * @note   (***) HSE_VALUE is a constant defined in this file (default value
S  *               8 MHz), user has to ensure that HSE_VALUE is same as the real
S  *               frequency of the crystal used. Otherwise, this function may
S  *               have wrong result.
S  * @note   The result of this function could be incorrect when using fractional
S  *         value for HSE crystal.
S  * @note   This function can be used by the user application to compute the
S  *         baud-rate for the communication peripherals or configure other parameters.
S  * @{
S  */
S
S/**
S  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks
S  * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
S  *         must be called to update structure fields. Otherwise, any
S  *         configuration based on this function will be incorrect.
S  * @param  RCC_Clocks pointer to a @ref LL_RCC_ClocksTypeDef structure which will hold the clocks frequencies
S  * @retval None
S  */
Svoid LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)
S{
S  /* Get SYSCLK frequency */
S  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
S
S  /* HCLK clock frequency */
S  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
S
S  /* PCLK1 clock frequency */
S  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
S
S  /* PCLK2 clock frequency */
S  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
S}
S
S/**
S  * @brief  Return USARTx clock frequency
S  * @param  USARTxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_USART1_CLKSOURCE
S  *         @arg @ref LL_RCC_USART2_CLKSOURCE
S  *         @arg @ref LL_RCC_USART3_CLKSOURCE (*)
S  *
S  *         (*) value not defined in all devices.
S  * @retval USART clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready
S  */
Suint32_t LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource)
S{
S  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_USART_CLKSOURCE(USARTxSource));
S
S  if (USARTxSource == LL_RCC_USART1_CLKSOURCE)
S  {
S    /* USART1CLK clock frequency */
S    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
S    {
S      case LL_RCC_USART1_CLKSOURCE_SYSCLK: /* USART1 Clock is System Clock */
S        usart_frequency = RCC_GetSystemClockFreq();
S        break;
S
S      case LL_RCC_USART1_CLKSOURCE_HSI:    /* USART1 Clock is HSI Osc. */
S        if (LL_RCC_HSI_IsReady() != 0U)
S        {
S          usart_frequency = HSI_VALUE;
S        }
S        break;
S
S      case LL_RCC_USART1_CLKSOURCE_LSE:    /* USART1 Clock is LSE Osc. */
S        if (LL_RCC_LSE_IsReady() != 0U)
S        {
S          usart_frequency = LSE_VALUE;
S        }
S        break;
S
S      case LL_RCC_USART1_CLKSOURCE_PCLK2:  /* USART1 Clock is PCLK2 */
S        usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S        break;
S
S      default:
S        break;
S    }
S  }
S  else if (USARTxSource == LL_RCC_USART2_CLKSOURCE)
S  {
S    /* USART2CLK clock frequency */
S    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
S    {
S      case LL_RCC_USART2_CLKSOURCE_SYSCLK: /* USART2 Clock is System Clock */
S        usart_frequency = RCC_GetSystemClockFreq();
S        break;
S
S      case LL_RCC_USART2_CLKSOURCE_HSI:    /* USART2 Clock is HSI Osc. */
S        if (LL_RCC_HSI_IsReady() != 0U)
S        {
S          usart_frequency = HSI_VALUE;
S        }
S        break;
S
S      case LL_RCC_USART2_CLKSOURCE_LSE:    /* USART2 Clock is LSE Osc. */
S        if (LL_RCC_LSE_IsReady() != 0U)
S        {
S          usart_frequency = LSE_VALUE;
S        }
S        break;
S
S      case LL_RCC_USART2_CLKSOURCE_PCLK1:  /* USART2 Clock is PCLK1 */
S        usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S        break;
S
S      default:
S        break;
S    }
S  }
S  else
S  {
S#if defined(RCC_CCIPR_USART3SEL)
S    if (USARTxSource == LL_RCC_USART3_CLKSOURCE)
S    {
S      /* USART3CLK clock frequency */
S      switch (LL_RCC_GetUSARTClockSource(USARTxSource))
S      {
S        case LL_RCC_USART3_CLKSOURCE_SYSCLK: /* USART3 Clock is System Clock */
S          usart_frequency = RCC_GetSystemClockFreq();
S          break;
S
S        case LL_RCC_USART3_CLKSOURCE_HSI:    /* USART3 Clock is HSI Osc. */
S          if (LL_RCC_HSI_IsReady() != 0U)
S          {
S            usart_frequency = HSI_VALUE;
S          }
S          break;
S
S        case LL_RCC_USART3_CLKSOURCE_LSE:    /* USART3 Clock is LSE Osc. */
S          if (LL_RCC_LSE_IsReady() != 0U)
S          {
S            usart_frequency = LSE_VALUE;
S          }
S          break;
S
S        case LL_RCC_USART3_CLKSOURCE_PCLK1:  /* USART3 Clock is PCLK1 */
S          usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S          break;
S
S        default:
S          break;
S      }
S    }
S#endif /* RCC_CCIPR_USART3SEL */
S  }
S  return usart_frequency;
S}
S
S#if defined(RCC_CCIPR_UART4SEL) || defined(RCC_CCIPR_UART5SEL)
S/**
S  * @brief  Return UARTx clock frequency
S  * @param  UARTxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_UART4_CLKSOURCE
S  *         @arg @ref LL_RCC_UART5_CLKSOURCE
S  * @retval UART clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready
S  */
Suint32_t LL_RCC_GetUARTClockFreq(uint32_t UARTxSource)
S{
S  uint32_t uart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_UART_CLKSOURCE(UARTxSource));
S
S#if defined(RCC_CCIPR_UART4SEL)
S  if (UARTxSource == LL_RCC_UART4_CLKSOURCE)
S  {
S    /* UART4CLK clock frequency */
S    switch (LL_RCC_GetUARTClockSource(UARTxSource))
S    {
S      case LL_RCC_UART4_CLKSOURCE_SYSCLK: /* UART4 Clock is System Clock */
S        uart_frequency = RCC_GetSystemClockFreq();
S        break;
S
S      case LL_RCC_UART4_CLKSOURCE_HSI:    /* UART4 Clock is HSI Osc. */
S        if (LL_RCC_HSI_IsReady() != 0U)
S        {
S          uart_frequency = HSI_VALUE;
S        }
S        break;
S
S      case LL_RCC_UART4_CLKSOURCE_LSE:    /* UART4 Clock is LSE Osc. */
S        if (LL_RCC_LSE_IsReady() != 0U)
S        {
S          uart_frequency = LSE_VALUE;
S        }
S        break;
S
S      case LL_RCC_UART4_CLKSOURCE_PCLK1:  /* UART4 Clock is PCLK1 */
S        uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S        break;
S
S      default:
S        break;
S    }
S  }
S#endif /* RCC_CCIPR_UART4SEL */
S
S#if defined(RCC_CCIPR_UART5SEL)
S  if (UARTxSource == LL_RCC_UART5_CLKSOURCE)
S  {
S    /* UART5CLK clock frequency */
S    switch (LL_RCC_GetUARTClockSource(UARTxSource))
S    {
S      case LL_RCC_UART5_CLKSOURCE_SYSCLK: /* UART5 Clock is System Clock */
S        uart_frequency = RCC_GetSystemClockFreq();
S        break;
S
S      case LL_RCC_UART5_CLKSOURCE_HSI:    /* UART5 Clock is HSI Osc. */
S        if (LL_RCC_HSI_IsReady() != 0U)
S        {
S          uart_frequency = HSI_VALUE;
S        }
S        break;
S
S      case LL_RCC_UART5_CLKSOURCE_LSE:    /* UART5 Clock is LSE Osc. */
S        if (LL_RCC_LSE_IsReady() != 0U)
S        {
S          uart_frequency = LSE_VALUE;
S        }
S        break;
S
S      case LL_RCC_UART5_CLKSOURCE_PCLK1:  /* UART5 Clock is PCLK1 */
S        uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S        break;
S
S      default:
S        break;
S    }
S  }
S#endif /* RCC_CCIPR_UART5SEL */
S
S  return uart_frequency;
S}
S#endif /* RCC_CCIPR_UART4SEL || RCC_CCIPR_UART5SEL */
S
S/**
S  * @brief  Return I2Cx clock frequency
S  * @param  I2CxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_I2C1_CLKSOURCE
S  *         @arg @ref LL_RCC_I2C2_CLKSOURCE (*)
S  *         @arg @ref LL_RCC_I2C3_CLKSOURCE
S  *         @arg @ref LL_RCC_I2C4_CLKSOURCE (*)
S  *
S  *         (*) value not defined in all devices.
S  * @retval I2C clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that HSI oscillator is not ready
S  */
Suint32_t LL_RCC_GetI2CClockFreq(uint32_t I2CxSource)
S{
S  uint32_t i2c_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_I2C_CLKSOURCE(I2CxSource));
S
S  if (I2CxSource == LL_RCC_I2C1_CLKSOURCE)
S  {
S    /* I2C1 CLK clock frequency */
S    switch (LL_RCC_GetI2CClockSource(I2CxSource))
S    {
S      case LL_RCC_I2C1_CLKSOURCE_SYSCLK: /* I2C1 Clock is System Clock */
S        i2c_frequency = RCC_GetSystemClockFreq();
S        break;
S
S      case LL_RCC_I2C1_CLKSOURCE_HSI:    /* I2C1 Clock is HSI Osc. */
S        if (LL_RCC_HSI_IsReady() != 0U)
S        {
S          i2c_frequency = HSI_VALUE;
S        }
S        break;
S
S      case LL_RCC_I2C1_CLKSOURCE_PCLK1:  /* I2C1 Clock is PCLK1 */
S        i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S        break;
S
S      default:
S        break;
S    }
S  }
S#if defined(RCC_CCIPR_I2C2SEL)
S  else if (I2CxSource == LL_RCC_I2C2_CLKSOURCE)
S  {
S    /* I2C2 CLK clock frequency */
S    switch (LL_RCC_GetI2CClockSource(I2CxSource))
S    {
S      case LL_RCC_I2C2_CLKSOURCE_SYSCLK: /* I2C2 Clock is System Clock */
S        i2c_frequency = RCC_GetSystemClockFreq();
S        break;
S
S      case LL_RCC_I2C2_CLKSOURCE_HSI:    /* I2C2 Clock is HSI Osc. */
S        if (LL_RCC_HSI_IsReady() != 0U)
S        {
S          i2c_frequency = HSI_VALUE;
S        }
S        break;
S
S      case LL_RCC_I2C2_CLKSOURCE_PCLK1:  /* I2C2 Clock is PCLK1 */
S        i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S        break;
S
S      default:
S        break;
S    }
S  }
S#endif /*RCC_CCIPR_I2C2SEL*/
S  else
S  {
S    if (I2CxSource == LL_RCC_I2C3_CLKSOURCE)
S    {
S      /* I2C3 CLK clock frequency */
S      switch (LL_RCC_GetI2CClockSource(I2CxSource))
S      {
S        case LL_RCC_I2C3_CLKSOURCE_SYSCLK: /* I2C3 Clock is System Clock */
S          i2c_frequency = RCC_GetSystemClockFreq();
S          break;
S
S        case LL_RCC_I2C3_CLKSOURCE_HSI:    /* I2C3 Clock is HSI Osc. */
S          if (LL_RCC_HSI_IsReady() != 0U)
S          {
S            i2c_frequency = HSI_VALUE;
S          }
S          break;
S
S        case LL_RCC_I2C3_CLKSOURCE_PCLK1:  /* I2C3 Clock is PCLK1 */
S          i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S          break;
S
S        default:
S          break;
S      }
S    }
S#if defined(RCC_CCIPR2_I2C4SEL)
S    else
S    {
S      if (I2CxSource == LL_RCC_I2C4_CLKSOURCE)
S      {
S        /* I2C4 CLK clock frequency */
S        switch (LL_RCC_GetI2CClockSource(I2CxSource))
S        {
S          case LL_RCC_I2C4_CLKSOURCE_SYSCLK: /* I2C4 Clock is System Clock */
S            i2c_frequency = RCC_GetSystemClockFreq();
S            break;
S
S          case LL_RCC_I2C4_CLKSOURCE_HSI:    /* I2C4 Clock is HSI Osc. */
S            if (LL_RCC_HSI_IsReady() != 0U)
S            {
S              i2c_frequency = HSI_VALUE;
S            }
S            break;
S
S          case LL_RCC_I2C4_CLKSOURCE_PCLK1:  /* I2C4 Clock is PCLK1 */
S            i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S            break;
S
S          default:
S            break;
S        }
S      }
S    }
S#endif /*RCC_CCIPR2_I2C4SEL*/
S  }
S
S  return i2c_frequency;
S}
S
S
S/**
S  * @brief  Return LPUARTx clock frequency
S  * @param  LPUARTxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE
S  * @retval LPUART clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready
S  */
Suint32_t LL_RCC_GetLPUARTClockFreq(uint32_t LPUARTxSource)
S{
S  uint32_t lpuart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_LPUART_CLKSOURCE(LPUARTxSource));
S
S  /* LPUART1CLK clock frequency */
S  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
S  {
S    case LL_RCC_LPUART1_CLKSOURCE_SYSCLK: /* LPUART1 Clock is System Clock */
S      lpuart_frequency = RCC_GetSystemClockFreq();
S      break;
S
S    case LL_RCC_LPUART1_CLKSOURCE_HSI:    /* LPUART1 Clock is HSI Osc. */
S      if (LL_RCC_HSI_IsReady() != 0U)
S      {
S        lpuart_frequency = HSI_VALUE;
S      }
S      break;
S
S    case LL_RCC_LPUART1_CLKSOURCE_LSE:    /* LPUART1 Clock is LSE Osc. */
S      if (LL_RCC_LSE_IsReady() != 0U)
S      {
S        lpuart_frequency = LSE_VALUE;
S      }
S      break;
S
S    case LL_RCC_LPUART1_CLKSOURCE_PCLK1:  /* LPUART1 Clock is PCLK1 */
S      lpuart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S      break;
S
S    default:
S      break;
S  }
S
S  return lpuart_frequency;
S}
S
S/**
S  * @brief  Return LPTIMx clock frequency
S  * @param  LPTIMxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE
S  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE
S  * @retval LPTIM clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI, LSI or LSE) is not ready
S  */
Suint32_t LL_RCC_GetLPTIMClockFreq(uint32_t LPTIMxSource)
S{
S  uint32_t lptim_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_LPTIM_CLKSOURCE(LPTIMxSource));
S
S  if (LPTIMxSource == LL_RCC_LPTIM1_CLKSOURCE)
S  {
S    /* LPTIM1CLK clock frequency */
S    switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
S    {
S      case LL_RCC_LPTIM1_CLKSOURCE_LSI:    /* LPTIM1 Clock is LSI Osc. */
S        if (LL_RCC_LSI_IsReady() != 0U)
S        {
S#if defined(RCC_CSR_LSIPREDIV)
S          if (LL_RCC_LSI_GetPrediv() == LL_RCC_LSI_PREDIV_128)
S          {
S            lptim_frequency = LSI_VALUE / 128U;
S          }
S          else
S#endif /* RCC_CSR_LSIPREDIV */
S          {
S            lptim_frequency = LSI_VALUE;
S          }
S        }
S        break;
S
S      case LL_RCC_LPTIM1_CLKSOURCE_HSI:    /* LPTIM1 Clock is HSI Osc. */
S        if (LL_RCC_HSI_IsReady() != 0U)
S        {
S          lptim_frequency = HSI_VALUE;
S        }
S        break;
S
S      case LL_RCC_LPTIM1_CLKSOURCE_LSE:    /* LPTIM1 Clock is LSE Osc. */
S        if (LL_RCC_LSE_IsReady() != 0U)
S        {
S          lptim_frequency = LSE_VALUE;
S        }
S        break;
S
S      case LL_RCC_LPTIM1_CLKSOURCE_PCLK1:  /* LPTIM1 Clock is PCLK1 */
S        lptim_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S        break;
S
S      default:
S        break;
S    }
S  }
S  else
S  {
S    if (LPTIMxSource == LL_RCC_LPTIM2_CLKSOURCE)
S    {
S      /* LPTIM2CLK clock frequency */
S      switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
S      {
S        case LL_RCC_LPTIM2_CLKSOURCE_LSI:    /* LPTIM2 Clock is LSI Osc. */
S          if (LL_RCC_LSI_IsReady() != 0U)
S          {
S#if defined(RCC_CSR_LSIPREDIV)
S            if (LL_RCC_LSI_GetPrediv() == LL_RCC_LSI_PREDIV_128)
S            {
S              lptim_frequency = LSI_VALUE / 128U;
S            }
S            else
S#endif /* RCC_CSR_LSIPREDIV */
S            {
S              lptim_frequency = LSI_VALUE;
S            }
S          }
S          break;
S
S        case LL_RCC_LPTIM2_CLKSOURCE_HSI:    /* LPTIM2 Clock is HSI Osc. */
S          if (LL_RCC_HSI_IsReady() != 0U)
S          {
S            lptim_frequency = HSI_VALUE;
S          }
S          break;
S
S        case LL_RCC_LPTIM2_CLKSOURCE_LSE:    /* LPTIM2 Clock is LSE Osc. */
S          if (LL_RCC_LSE_IsReady() != 0U)
S          {
S            lptim_frequency = LSE_VALUE;
S          }
S          break;
S
S        case LL_RCC_LPTIM2_CLKSOURCE_PCLK1:  /* LPTIM2 Clock is PCLK1 */
S          lptim_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S          break;
S
S        default:
S          break;
S      }
S    }
S  }
S
S  return lptim_frequency;
S}
S
S#if defined(RCC_CCIPR_SAI1SEL) || defined(RCC_CCIPR_SAI2SEL) || defined(RCC_CCIPR2_SAI1SEL) || defined(RCC_CCIPR2_SAI2SEL)
S/**
S  * @brief  Return SAIx clock frequency
S  * @param  SAIxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_SAI1_CLKSOURCE
S  *         @arg @ref LL_RCC_SAI2_CLKSOURCE (*)
S  *
S  *         (*) value not defined in all devices.
S  * @retval SAI clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that PLL is not ready
S
S  */
Suint32_t LL_RCC_GetSAIClockFreq(uint32_t SAIxSource)
S{
S  uint32_t sai_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_SAI_CLKSOURCE(SAIxSource));
S
S  if (SAIxSource == LL_RCC_SAI1_CLKSOURCE)
S  {
S    /* SAI1CLK clock frequency */
S    switch (LL_RCC_GetSAIClockSource(SAIxSource))
S    {
S      case LL_RCC_SAI1_CLKSOURCE_PLLSAI1:    /* PLLSAI1 clock used as SAI1 clock source */
S        if (LL_RCC_PLLSAI1_IsReady() != 0U)
S        {
S          sai_frequency = RCC_PLLSAI1_GetFreqDomain_SAI();
S        }
S        break;
S
S#if defined(RCC_PLLSAI2_SUPPORT)
S      case LL_RCC_SAI1_CLKSOURCE_PLLSAI2:    /* PLLSAI2 clock used as SAI1 clock source */
S        if (LL_RCC_PLLSAI2_IsReady() != 0U)
S        {
S          sai_frequency = RCC_PLLSAI2_GetFreqDomain_SAI();
S        }
S        break;
S
S#endif /* RCC_PLLSAI2_SUPPORT */
S      case LL_RCC_SAI1_CLKSOURCE_PLL:        /* PLL clock used as SAI1 clock source */
S        if (LL_RCC_PLL_IsReady() != 0U)
S        {
S          sai_frequency = RCC_PLL_GetFreqDomain_SAI();
S        }
S        break;
S
S      case LL_RCC_SAI1_CLKSOURCE_PIN:        /* External input clock used as SAI1 clock source */
S        sai_frequency = EXTERNAL_SAI1_CLOCK_VALUE;
S        break;
S
S      default:
S        break;
S    }
S  }
S  else
S  {
S#if defined(RCC_CCIPR_SAI2SEL) || defined(RCC_CCIPR2_SAI2SEL)
S    if (SAIxSource == LL_RCC_SAI2_CLKSOURCE)
S    {
S      /* SAI2CLK clock frequency */
S      switch (LL_RCC_GetSAIClockSource(SAIxSource))
S      {
S        case LL_RCC_SAI2_CLKSOURCE_PLLSAI1:  /* PLLSAI1 clock used as SAI2 clock source */
S          if (LL_RCC_PLLSAI1_IsReady() != 0U)
S          {
S            sai_frequency = RCC_PLLSAI1_GetFreqDomain_SAI();
S          }
S          break;
S
S#if defined(RCC_PLLSAI2_SUPPORT)
S        case LL_RCC_SAI2_CLKSOURCE_PLLSAI2:  /* PLLSAI2 clock used as SAI2 clock source */
S          if (LL_RCC_PLLSAI2_IsReady() != 0U)
S          {
S            sai_frequency = RCC_PLLSAI2_GetFreqDomain_SAI();
S          }
S          break;
S
S#endif /* RCC_PLLSAI2_SUPPORT */
S        case LL_RCC_SAI2_CLKSOURCE_PLL:      /* PLL clock used as SAI2 clock source */
S          if (LL_RCC_PLL_IsReady() != 0U)
S          {
S            sai_frequency = RCC_PLL_GetFreqDomain_SAI();
S          }
S          break;
S
S      case LL_RCC_SAI2_CLKSOURCE_PIN:        /* External input clock used as SAI2 clock source */
S        sai_frequency = EXTERNAL_SAI2_CLOCK_VALUE;
S        break;
S
S      default:
S        break;
S      }
S    }
S#endif /* RCC_CCIPR_SAI2SEL || RCC_CCIPR2_SAI2SEL */
S  }
S
S  return sai_frequency;
S}
S#endif /* RCC_CCIPR_SAI1SEL || RCC_CCIPR_SAI2SEL || RCC_CCIPR2_SAI1SEL || RCC_CCIPR2_SAI2SEL*/
S
S#if defined(SDMMC1)
S#if defined(RCC_CCIPR2_SDMMCSEL)
S/**
S  * @brief  Return SDMMCx kernel clock frequency
S  * @param  SDMMCxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_SDMMC1_KERNELCLKSOURCE
S  * @retval SDMMC clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (MSI) or PLL is not ready
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that no clock source selected
S  */
Suint32_t LL_RCC_GetSDMMCKernelClockFreq(uint32_t SDMMCxSource)
S{
S  uint32_t sdmmc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_SDMMC_KERNELCLKSOURCE(SDMMCxSource));
S
S  /* SDMMC1CLK kernel clock frequency */
S  switch (LL_RCC_GetSDMMCKernelClockSource(SDMMCxSource))
S  {
S    case LL_RCC_SDMMC1_KERNELCLKSOURCE_48CLK:      /* 48MHz clock from internal multiplexor used as SDMMC1 clock source */
S      sdmmc_frequency = LL_RCC_GetSDMMCClockFreq(LL_RCC_SDMMC1_CLKSOURCE);
S      break;
S
S    case LL_RCC_SDMMC1_KERNELCLKSOURCE_PLLP:        /* PLL "P" output (PLLSAI3CLK) clock used as SDMMC1 clock source */
S      if (LL_RCC_PLL_IsReady() != 0U)
S      {
S        sdmmc_frequency = RCC_PLL_GetFreqDomain_SAI();
S      }
S      break;
S
S    default:
S      sdmmc_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
S      break;
S  }
S
S  return sdmmc_frequency;
S}
S#endif
S
S/**
S  * @brief  Return SDMMCx clock frequency
S  * @param  SDMMCxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_SDMMC1_CLKSOURCE
S  * @retval SDMMC clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (MSI) or PLL is not ready
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that no clock source selected
S  */
Suint32_t LL_RCC_GetSDMMCClockFreq(uint32_t SDMMCxSource)
S{
S  uint32_t sdmmc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_SDMMC_CLKSOURCE(SDMMCxSource));
S
S  /* SDMMC1CLK clock frequency */
S  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
S  {
S#if  defined(LL_RCC_SDMMC1_CLKSOURCE_PLLSAI1)
S    case LL_RCC_SDMMC1_CLKSOURCE_PLLSAI1:    /* PLLSAI1 clock used as SDMMC1 clock source */
S      if (LL_RCC_PLLSAI1_IsReady() != 0U)
S      {
S        sdmmc_frequency = RCC_PLLSAI1_GetFreqDomain_48M();
S      }
S      break;
S#endif
S
S    case LL_RCC_SDMMC1_CLKSOURCE_PLL:        /* PLL clock used as SDMMC1 clock source */
S      if (LL_RCC_PLL_IsReady() != 0U)
S      {
S        sdmmc_frequency = RCC_PLL_GetFreqDomain_48M();
S      }
S      break;
S
S#if  defined(LL_RCC_SDMMC1_CLKSOURCE_MSI)
S    case LL_RCC_SDMMC1_CLKSOURCE_MSI:        /* MSI clock used as SDMMC1 clock source */
S      if (LL_RCC_MSI_IsReady() != 0U)
S      {
S        sdmmc_frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      }
S      break;
S#endif
S
S#if defined(RCC_HSI48_SUPPORT)
S    case LL_RCC_SDMMC1_CLKSOURCE_HSI48:      /* HSI48 used as SDMMC1 clock source */
S      if (LL_RCC_HSI48_IsReady() != 0U)
S      {
S        sdmmc_frequency = HSI48_VALUE;
S      }
S      break;
S#else
S    case LL_RCC_SDMMC1_CLKSOURCE_NONE:       /* No clock used as SDMMC1 clock source */
S#endif
S    default:
S      sdmmc_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
S      break;
S  }
S
S  return sdmmc_frequency;
S}
S#endif /* SDMMC1 */
S
S/**
S  * @brief  Return RNGx clock frequency
S  * @param  RNGxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_RNG_CLKSOURCE
S  * @retval RNG clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (MSI) or PLL is not ready
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that no clock source selected
S  */
Suint32_t LL_RCC_GetRNGClockFreq(uint32_t RNGxSource)
S{
S  uint32_t rng_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_RNG_CLKSOURCE(RNGxSource));
S
S  /* RNGCLK clock frequency */
S  switch (LL_RCC_GetRNGClockSource(RNGxSource))
S  {
S#if defined(RCC_PLLSAI1_SUPPORT)
S    case LL_RCC_RNG_CLKSOURCE_PLLSAI1:       /* PLLSAI1 clock used as RNG clock source */
S      if (LL_RCC_PLLSAI1_IsReady() != 0U)
S      {
S        rng_frequency = RCC_PLLSAI1_GetFreqDomain_48M();
S      }
S      break;
S#endif /* RCC_PLLSAI1_SUPPORT */
S
S    case LL_RCC_RNG_CLKSOURCE_PLL:           /* PLL clock used as RNG clock source */
S      if (LL_RCC_PLL_IsReady() != 0U)
S      {
S        rng_frequency = RCC_PLL_GetFreqDomain_48M();
S      }
S      break;
S
S    case LL_RCC_RNG_CLKSOURCE_MSI:           /* MSI clock used as RNG clock source */
S      if (LL_RCC_MSI_IsReady() != 0U)
S      {
S        rng_frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      }
S      break;
S
S
S#if defined(RCC_HSI48_SUPPORT)
S    case LL_RCC_RNG_CLKSOURCE_HSI48:      /* HSI48 used as RNG clock source */
S      if (LL_RCC_HSI48_IsReady() != 0U)
S      {
S        rng_frequency = HSI48_VALUE;
S      }
S      break;
S#else
S    case LL_RCC_RNG_CLKSOURCE_NONE:       /* No clock used as RNG clock source */
S#endif
S    default:
S      rng_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
S      break;
S
S  }
S
S  return rng_frequency;
S}
S
S
S#if   defined(USB_OTG_FS)||defined(USB)
S/**
S  * @brief  Return USBx clock frequency
S  * @param  USBxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_USB_CLKSOURCE
S  * @retval USB clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (MSI) or PLL is not ready
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that no clock source selected
S  */
Suint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)
S{
S  uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_USB_CLKSOURCE(USBxSource));
S
S  /* USBCLK clock frequency */
S  switch (LL_RCC_GetUSBClockSource(USBxSource))
S  {
S#if defined(RCC_PLLSAI1_SUPPORT)
S    case LL_RCC_USB_CLKSOURCE_PLLSAI1:       /* PLLSAI1 clock used as USB clock source */
S      if (LL_RCC_PLLSAI1_IsReady() != 0U)
S      {
S        usb_frequency = RCC_PLLSAI1_GetFreqDomain_48M();
S      }
S      break;
S#endif /* RCC_PLLSAI1_SUPPORT */
S
S    case LL_RCC_USB_CLKSOURCE_PLL:           /* PLL clock used as USB clock source */
S      if (LL_RCC_PLL_IsReady() != 0U)
S      {
S        usb_frequency = RCC_PLL_GetFreqDomain_48M();
S      }
S      break;
S
S    case LL_RCC_USB_CLKSOURCE_MSI:           /* MSI clock used as USB clock source */
S      if (LL_RCC_MSI_IsReady() != 0U)
S      {
S        usb_frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      }
S      break;
S
S#if defined(RCC_HSI48_SUPPORT)
S    case LL_RCC_USB_CLKSOURCE_HSI48:      /* HSI48 used as USB clock source */
S      if (LL_RCC_HSI48_IsReady() != 0U)
S      {
S        usb_frequency = HSI48_VALUE;
S      }
S      break;
S#else
S    case LL_RCC_USB_CLKSOURCE_NONE:       /* No clock used as USB clock source */
S#endif
S    default:
S      usb_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
S      break;
S  }
S
S  return usb_frequency;
S}
S#endif /* USB_OTG_FS || USB */
S
S/**
S  * @brief  Return ADCx clock frequency
S  * @param  ADCxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_ADC_CLKSOURCE
S  * @retval ADC clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (MSI) or PLL is not ready
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that no clock source selected
S  */
Suint32_t LL_RCC_GetADCClockFreq(uint32_t ADCxSource)
S{
S  uint32_t adc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_ADC_CLKSOURCE(ADCxSource));
S
S  /* ADCCLK clock frequency */
S  switch (LL_RCC_GetADCClockSource(ADCxSource))
S  {
S#if defined(RCC_PLLSAI1_SUPPORT)
S    case LL_RCC_ADC_CLKSOURCE_PLLSAI1:       /* PLLSAI1 clock used as ADC clock source */
S      if (LL_RCC_PLLSAI1_IsReady() != 0U)
S      {
S        adc_frequency = RCC_PLLSAI1_GetFreqDomain_ADC();
S      }
S      break;
S#endif /* RCC_PLLSAI1_SUPPORT */
S
S#if defined(RCC_PLLSAI2_SUPPORT) && defined(LL_RCC_ADC_CLKSOURCE_PLLSAI2)
S    case LL_RCC_ADC_CLKSOURCE_PLLSAI2:       /* PLLSAI2 clock used as ADC clock source */
S      if (LL_RCC_PLLSAI2_IsReady() != 0U)
S      {
S         adc_frequency = RCC_PLLSAI2_GetFreqDomain_ADC();
S      }
S      break;
S#endif /* RCC_PLLSAI2_SUPPORT && LL_RCC_ADC_CLKSOURCE_PLLSAI2 */
S
S    case LL_RCC_ADC_CLKSOURCE_SYSCLK:        /* SYSCLK clock used as ADC clock source */
S      adc_frequency = RCC_GetSystemClockFreq();
S      break;
S
S    case LL_RCC_ADC_CLKSOURCE_NONE:          /* No clock used as ADC clock source */
S    default:
S      adc_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
S      break;
S  }
S
S  return adc_frequency;
S}
S
S#if defined(SWPMI1)
S/**
S  * @brief  Return SWPMIx clock frequency
S  * @param  SWPMIxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_SWPMI1_CLKSOURCE
S  * @retval SWPMI clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI) is not ready
S  */
Suint32_t LL_RCC_GetSWPMIClockFreq(uint32_t SWPMIxSource)
S{
S  uint32_t swpmi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_SWPMI_CLKSOURCE(SWPMIxSource));
S
S  /* SWPMI1CLK clock frequency */
S  switch (LL_RCC_GetSWPMIClockSource(SWPMIxSource))
S  {
S    case LL_RCC_SWPMI1_CLKSOURCE_HSI:        /* SWPMI1 Clock is HSI Osc. */
S      if (LL_RCC_HSI_IsReady())
S      {
S        swpmi_frequency = HSI_VALUE;
S      }
S      break;
S
S    case LL_RCC_SWPMI1_CLKSOURCE_PCLK1:      /* SWPMI1 Clock is PCLK1 */
S      swpmi_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S      break;
S
S    default:
S      break;
S  }
S
S  return swpmi_frequency;
S}
S#endif /* SWPMI1 */
S
S#if defined(DFSDM1_Channel0)
S/**
S  * @brief  Return DFSDMx clock frequency
S  * @param  DFSDMxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE
S  * @retval DFSDM clock frequency (in Hz)
S  */
Suint32_t LL_RCC_GetDFSDMClockFreq(uint32_t DFSDMxSource)
S{
S  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_DFSDM_CLKSOURCE(DFSDMxSource));
S
S  /* DFSDM1CLK clock frequency */
S  switch (LL_RCC_GetDFSDMClockSource(DFSDMxSource))
S  {
S    case LL_RCC_DFSDM1_CLKSOURCE_SYSCLK:     /* DFSDM1 Clock is SYSCLK */
S      dfsdm_frequency = RCC_GetSystemClockFreq();
S      break;
S
S    case LL_RCC_DFSDM1_CLKSOURCE_PCLK2:      /* DFSDM1 Clock is PCLK2 */
S      dfsdm_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
S      break;
S
S    default:
S      break;
S  }
S
S  return dfsdm_frequency;
S}
S
S#if defined(RCC_CCIPR2_DFSDM1SEL)
S/**
S  * @brief  Return DFSDMx Audio clock frequency
S  * @param  DFSDMxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DFSDM1_AUDIO_CLKSOURCE
S  * @retval DFSDM clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
S  */
Suint32_t LL_RCC_GetDFSDMAudioClockFreq(uint32_t DFSDMxSource)
S{
S  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_DFSDM_AUDIO_CLKSOURCE(DFSDMxSource));
S
S  /* DFSDM1CLK clock frequency */
S  switch (LL_RCC_GetDFSDMAudioClockSource(DFSDMxSource))
S  {
S    case LL_RCC_DFSDM1_AUDIO_CLKSOURCE_SAI1:     /* SAI1 clock used as DFSDM1 audio clock */
S      dfsdm_frequency = LL_RCC_GetSAIClockFreq(LL_RCC_SAI1_CLKSOURCE);
S      break;
S
S    case LL_RCC_DFSDM1_AUDIO_CLKSOURCE_MSI:      /* MSI clock used as DFSDM1 audio clock */
S      if (LL_RCC_MSI_IsReady() != 0U)
S      {
S        dfsdm_frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      }
S      break;
S
S    case LL_RCC_DFSDM1_AUDIO_CLKSOURCE_HSI:      /* HSI clock used as DFSDM1 audio clock */
S    default:
S      if (LL_RCC_HSI_IsReady() != 0U)
S      {
S        dfsdm_frequency = HSI_VALUE;
S      }
S      break;
S  }
S
S  return dfsdm_frequency;
S}
S#endif /* RCC_CCIPR2_DFSDM1SEL */
S#endif /* DFSDM1_Channel0 */
S
S#if defined(DSI)
S/**
S  * @brief  Return DSI clock frequency
S  * @param  DSIxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_DSI_CLKSOURCE
S  * @retval DSI clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that external clock is used
S  */
Suint32_t LL_RCC_GetDSIClockFreq(uint32_t DSIxSource)
S{
S  uint32_t dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_DSI_CLKSOURCE(DSIxSource));
S
S  /* DSICLK clock frequency */
S  switch (LL_RCC_GetDSIClockSource(DSIxSource))
S  {
S    case LL_RCC_DSI_CLKSOURCE_PLL:     /* DSI Clock is PLLSAI2 Osc. */
S      if (LL_RCC_PLLSAI2_IsReady() != 0U)
S      {
S        dsi_frequency = RCC_PLLSAI2_GetFreqDomain_DSI();
S      }
S      break;
S
S    case LL_RCC_DSI_CLKSOURCE_PHY:    /* DSI Clock is DSI physical clock. */
S    default:
S      dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
S      break;
S  }
S
S  return dsi_frequency;
S}
S#endif /* DSI */
S
S#if defined(LTDC)
S/**
S  * @brief  Return LTDC clock frequency
S  * @param  LTDCxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_LTDC_CLKSOURCE
S  * @retval LTDC clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator PLLSAI is not ready
S  */
Suint32_t LL_RCC_GetLTDCClockFreq(uint32_t LTDCxSource)
S{
S  uint32_t ltdc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_LTDC_CLKSOURCE(LTDCxSource));
S
S  if (LL_RCC_PLLSAI2_IsReady() != 0U)
S  {
S     ltdc_frequency = RCC_PLLSAI2_GetFreqDomain_LTDC();
S  }
S
S  return ltdc_frequency;
S}
S#endif /* LTDC */
S
S#if defined(OCTOSPI1)
S/**
S  * @brief  Return OCTOSPI clock frequency
S  * @param  OCTOSPIxSource This parameter can be one of the following values:
S  *         @arg @ref LL_RCC_OCTOSPI_CLKSOURCE
S  * @retval OCTOSPI clock frequency (in Hz)
S  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator PLLSAI is not ready
S  */
Suint32_t LL_RCC_GetOCTOSPIClockFreq(uint32_t OCTOSPIxSource)
S{
S  uint32_t octospi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S
S  /* Check parameter */
S  assert_param(IS_LL_RCC_OCTOSPI_CLKSOURCE(OCTOSPIxSource));
S
S  /* OCTOSPI clock frequency */
S  switch (LL_RCC_GetOCTOSPIClockSource(OCTOSPIxSource))
S  {
S    case LL_RCC_OCTOSPI_CLKSOURCE_SYSCLK:   /* OCTOSPI clock is SYSCLK */
S      octospi_frequency = RCC_GetSystemClockFreq();
S      break;
S
S    case LL_RCC_OCTOSPI_CLKSOURCE_MSI:      /* MSI clock used as OCTOSPI clock */
S      if (LL_RCC_MSI_IsReady() != 0U)
S      {
S        octospi_frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                     ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                      LL_RCC_MSI_GetRange() :
S                                      LL_RCC_MSI_GetRangeAfterStandby()));
S      }
S      break;
S
S    case LL_RCC_OCTOSPI_CLKSOURCE_PLL:      /* PLL clock used as OCTOSPI source */
S      if (LL_RCC_PLL_IsReady() != 0U)
S      {
S        octospi_frequency = RCC_PLL_GetFreqDomain_48M();
S      }
S      break;
S
S    default:
S      octospi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
S      break;
S  }
S
S  return octospi_frequency;
S}
S#endif /* OCTOSPI1 */
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/** @addtogroup RCC_LL_Private_Functions
S  * @{
S  */
S
S/**
S  * @brief  Return SYSTEM clock frequency
S  * @retval SYSTEM clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_GetSystemClockFreq(void)
S{
S  uint32_t frequency;
S
S  /* Get SYSCLK source -------------------------------------------------------*/
S  switch (LL_RCC_GetSysClkSource())
S  {
S    case LL_RCC_SYS_CLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
S      frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
S      frequency = HSI_VALUE;
S      break;
S
S    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
S      frequency = HSE_VALUE;
S      break;
S
S    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
S      frequency = RCC_PLL_GetFreqDomain_SYS();
S      break;
S
S    default:
S      frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S
S  return frequency;
S}
S
S/**
S  * @brief  Return HCLK clock frequency
S  * @param  SYSCLK_Frequency SYSCLK clock frequency
S  * @retval HCLK clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
S{
S  /* HCLK clock frequency */
S  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
S}
S
S/**
S  * @brief  Return PCLK1 clock frequency
S  * @param  HCLK_Frequency HCLK clock frequency
S  * @retval PCLK1 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
S{
S  /* PCLK1 clock frequency */
S  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
S}
S
S/**
S  * @brief  Return PCLK2 clock frequency
S  * @param  HCLK_Frequency HCLK clock frequency
S  * @retval PCLK2 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
S{
S  /* PCLK2 clock frequency */
S  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
S}
S
S/**
S  * @brief  Return PLL clock frequency used for system domain
S  * @retval PLL clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLL_GetFreqDomain_SYS(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
S     SYSCLK = PLL_VCO / PLLR
S  */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S  return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
S}
S
S#if defined(SAI1)
S/**
S  * @brief  Return PLL clock frequency used for SAI domain
S  * @retval PLL clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLL_GetFreqDomain_SAI(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE / PLLM) * PLLN
S     SAI Domain clock = PLL_VCO / PLLP
S  */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S  return __LL_RCC_CALC_PLLCLK_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetP());
S}
S#endif /* SAI1 */
S
S/**
S  * @brief  Return PLL clock frequency used for 48 MHz domain
S  * @retval PLL clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLL_GetFreqDomain_48M(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
S     48M Domain clock = PLL_VCO / PLLQ
S  */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S  return __LL_RCC_CALC_PLLCLK_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetQ());
S}
S#if defined(DSI)
S/**
S  * @brief  Return PLL clock frequency used for DSI clock
S  * @retval PLL clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_DSI(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S  /* PLLSAI2_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLSAI2M) * PLLSAI2N */
S  /* DSICLK = PLLSAI2_VCO / PLLSAI2R */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI2 clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI2 clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI2 clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S
S  return __LL_RCC_CALC_PLLSAI2_DSI_FREQ(pllinputfreq, LL_RCC_PLLSAI2_GetDivider(),
S                                        LL_RCC_PLLSAI2_GetN(), LL_RCC_PLLSAI2_GetR());
S}
S#endif /* DSI */
S
S#if defined(RCC_PLLSAI1_SUPPORT)
S/**
S  * @brief  Return PLLSAI1 clock frequency used for SAI domain
S  * @retval PLLSAI1 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLLSAI1_GetFreqDomain_SAI(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S#if  defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
S  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLSAI1M) * PLLSAI1N */
S#else
S  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLSAI1N */
S#endif
S  /* SAI Domain clock  = PLLSAI1_VCO / PLLSAI1P */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI1 clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI1 clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI1 clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S  return __LL_RCC_CALC_PLLSAI1_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLLSAI1_GetN(), LL_RCC_PLLSAI1_GetP());
S}
S
S/**
S  * @brief  Return PLLSAI1 clock frequency used for 48Mhz domain
S  * @retval PLLSAI1 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLLSAI1_GetFreqDomain_48M(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S#if  defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
S  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLSAI1M) * PLLSAI1N */
S#else
S  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLSAI1N */
S#endif
S  /* 48M Domain clock  = PLLSAI1_VCO / PLLSAI1Q */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI1 clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI1 clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI1 clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S  return __LL_RCC_CALC_PLLSAI1_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLLSAI1_GetN(), LL_RCC_PLLSAI1_GetQ());
S}
S
S/**
S  * @brief  Return PLLSAI1 clock frequency used for ADC domain
S  * @retval PLLSAI1 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLLSAI1_GetFreqDomain_ADC(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S#if  defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
S  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLSAI1M) * PLLSAI1N */
S#else
S  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLSAI1N */
S#endif
S  /* 48M Domain clock  = PLLSAI1_VCO / PLLSAI1R */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI1 clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI1 clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI1 clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S  return __LL_RCC_CALC_PLLSAI1_ADC_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLLSAI1_GetN(), LL_RCC_PLLSAI1_GetR());
S}
S#endif /* RCC_PLLSAI1_SUPPORT */
S
S#if defined(RCC_PLLSAI2_SUPPORT)
S/**
S  * @brief  Return PLLSAI2 clock frequency used for SAI domain
S  * @retval PLLSAI2 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_SAI(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S#if  defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
S  /* PLLSAI2_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLSAI2M) * PLLSAI2N */
S#else
S  /* PLLSAI2_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLSAI2N */
S#endif
S  /* SAI Domain clock  = PLLSAI2_VCO / PLLSAI2P */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI2 clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI2 clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI2 clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
S  return __LL_RCC_CALC_PLLSAI2_SAI_FREQ(pllinputfreq, LL_RCC_PLLSAI2_GetDivider(),
S                                        LL_RCC_PLLSAI2_GetN(), LL_RCC_PLLSAI2_GetP());
S#else
S  return __LL_RCC_CALC_PLLSAI2_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLLSAI2_GetN(), LL_RCC_PLLSAI2_GetP());
S#endif
S}
S
S#if  defined(LTDC)
S/**
S  * @brief  Return PLLSAI2 clock frequency used for LTDC domain
S  * @retval PLLSAI2 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_LTDC(void)
S{
S  uint32_t pllinputfreq, pllsource;
S
S  /* PLLSAI2_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLSAI2M) * PLLSAI2N */
S  /* LTDC Domain clock  = (PLLSAI2_VCO / PLLSAI2R) / PLLSAI2DIVR */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI2 clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI2 clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI2 clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S
S  return __LL_RCC_CALC_PLLSAI2_LTDC_FREQ(pllinputfreq, LL_RCC_PLLSAI2_GetDivider(),
S                                         LL_RCC_PLLSAI2_GetN(), LL_RCC_PLLSAI2_GetR(), LL_RCC_PLLSAI2_GetDIVR());
S}
S
S#else
S
S  /**
S  * @brief  Return PLLSAI2 clock frequency used for ADC domain
S  * @retval PLLSAI2 clock frequency (in Hz)
S  */
Sstatic uint32_t RCC_PLLSAI2_GetFreqDomain_ADC(void)
S{
S  uint32_t pllinputfreq = 0U, pllsource = 0U;
S
S  /* PLLSAI2_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLSAI2N */
S  /* 48M Domain clock  = PLLSAI2_VCO / PLLSAI2R */
S  pllsource = LL_RCC_PLL_GetMainSource();
S
S  switch (pllsource)
S  {
S    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI2 clock source */
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S
S    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI2 clock source */
S      pllinputfreq = HSI_VALUE;
S      break;
S
S    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI2 clock source */
S      pllinputfreq = HSE_VALUE;
S      break;
S
S    default:
S      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
S                                    ((LL_RCC_MSI_IsEnabledRangeSelect() != 0U) ?
S                                     LL_RCC_MSI_GetRange() :
S                                     LL_RCC_MSI_GetRangeAfterStandby()));
S      break;
S  }
S  return __LL_RCC_CALC_PLLSAI2_ADC_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
S                                        LL_RCC_PLLSAI2_GetN(), LL_RCC_PLLSAI2_GetR());
S}
S#endif /* LTDC */
S
S#endif /*RCC_PLLSAI2_SUPPORT*/
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S#endif /* defined(RCC) */
S
S/**
S  * @}
S  */
S
N#endif /* USE_FULL_LL_DRIVER */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
