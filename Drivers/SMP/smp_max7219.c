/**
  ******************************************************************************
  * @file    smp_max7219.c
  * @author  Golden Chen
  * @version V0.0.1
  * @date    2021/12/30
  * @brief   
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2021 SMP</center></h2>
  *
  * 
  *
  ******************************************************************************
  */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "stm32l4xx_hal.h"
#include "smp_max7219.h"
//
// MAX7219 LED Matrix controller library
// Each module shifts bits in and the next bit is shifted out. For example, in the case of my setup with 4 modules

const uint8_t ucFont[] = {
0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00, //33/ --> !
0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00, //34/ --> "
0x28,0x28,0x7C,0x28,0x7C,0x28,0x28,0x00, //35/ --> #
0x10,0x3C,0x50,0x38,0x14,0x78,0x10,0x00, //36/ --> $
0x60,0x64,0x08,0x10,0x20,0x4C,0x0C,0x00, //37/ --> %
0x30,0x48,0x50,0x20,0x50,0x48,0x34,0x00, //38/ --> &
0x30,0x10,0x20,0x00,0x00,0x00,0x00,0x00, //39/ --> '
0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00, //40/ --> (
0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00, //41/ --> )
0x00,0x10,0x54,0x38,0x54,0x10,0x00,0x00, //42/ --> *
0x00,0x10,0x10,0x7C,0x10,0x10,0x00,0x00, //43/ --> +
0x00,0x00,0x00,0x30,0x10,0x20,0x00,0x00, //44/ --> ,
0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00, //45/ --> -
0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00, //46/ --> .
0x00,0x04,0x08,0x10,0x20,0x40,0x00,0x00, //47/ --> /
0x38,0x44,0x4C,0x54,0x64,0x44,0x38,0x00, //48/ --> 0
0x10,0x30,0x10,0x10,0x10,0x10,0x38,0x00, //49/ --> 1
0x38,0x44,0x04,0x08,0x10,0x20,0x7C,0x00, //50/ --> 2
0x7C,0x08,0x10,0x08,0x04,0x44,0x38,0x00, //51/ --> 3
0x08,0x18,0x28,0x48,0x7C,0x08,0x08,0x00, //52/ --> 4
0x3E,0x20,0x3C,0x02,0x02,0x22,0x1C,0x00, //53/ --> 5
0x18,0x20,0x40,0x78,0x44,0x44,0x38,0x00, //54/ --> 6
0x7C,0x04,0x08,0x10,0x20,0x20,0x20,0x00, //55/ --> 7
0x38,0x44,0x44,0x38,0x44,0x44,0x38,0x00, //56/ --> 8
0x38,0x44,0x44,0x3C,0x04,0x08,0x30,0x00, //57/ --> 9
0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x00, //58/ --> :
0x00,0x30,0x30,0x00,0x30,0x10,0x20,0x00, //59/ --> ;
0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00, //60/ --> <
0x00,0x00,0x7C,0x00,0x00,0x7C,0x00,0x00, //61/ --> =
0x20,0x10,0x08,0x04,0x08,0x10,0x20,0x00, //62/ --> >
0x38,0x44,0x04,0x08,0x10,0x00,0x10,0x00, //63/ --> ?
0x38,0x44,0x04,0x34,0x54,0x54,0x38,0x00, //64/ --> @
0x38,0x44,0x44,0x44,0x7C,0x44,0x44,0x00, //65/ --> A
0x78,0x44,0x44,0x78,0x44,0x44,0x78,0x00, //66/ --> B
0x38,0x44,0x40,0x40,0x40,0x44,0x38,0x00, //67/ --> C
0x70,0x48,0x44,0x44,0x44,0x48,0x70,0x00, //68/ --> D
0x7C,0x40,0x40,0x78,0x40,0x40,0x7C,0x00, //69/ --> E
0x7C,0x40,0x40,0x78,0x40,0x40,0x40,0x00, //70/ --> F
0x38,0x44,0x40,0x5C,0x44,0x44,0x38,0x00, //71/ --> G
0x44,0x44,0x44,0x7C,0x44,0x44,0x44,0x00, //72/ --> H
0x38,0x10,0x10,0x10,0x10,0x10,0x38,0x00, //73/ --> I
0x1C,0x08,0x08,0x08,0x08,0x48,0x30,0x00, //74/ --> J
0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x00, //75/ --> K
0x40,0x40,0x40,0x40,0x40,0x40,0x7C,0x00, //76/ --> L
0x44,0x6C,0x54,0x54,0x44,0x44,0x44,0x00, //77/ --> M
0x44,0x44,0x64,0x54,0x4C,0x44,0x44,0x00, //78/ --> N
0x38,0x44,0x44,0x44,0x44,0x44,0x38,0x00, //79/ --> O
0x78,0x44,0x44,0x78,0x40,0x40,0x40,0x00, //80/ --> P
0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00, //81/ --> Q
0x78,0x44,0x44,0x78,0x50,0x48,0x44,0x00, //82/ --> R
0x3C,0x40,0x40,0x38,0x04,0x04,0x78,0x00, //83/ --> S
0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x00, //84/ --> T
0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x00, //85/ --> U
0x44,0x44,0x44,0x44,0x44,0x28,0x10,0x00, //86/ --> V
0x44,0x44,0x44,0x44,0x44,0x54,0x38,0x00, //87/ --> W
0x44,0x44,0x28,0x10,0x28,0x44,0x44,0x00, //88/ --> X
0x44,0x44,0x44,0x28,0x10,0x10,0x10,0x00, //89/ --> Y
0x7C,0x04,0x08,0x10,0x20,0x40,0x7C,0x00, //90/ --> Z
0x70,0x40,0x40,0x40,0x40,0x40,0x70,0x00, //91/ --> [
0x44,0x28,0x7C,0x10,0x7C,0x10,0x10,0x00, //92/ --> \
0x70,0x10,0x10,0x10,0x10,0x10,0x70,0x00, //93/ --> ]
0x10,0x28,0x44,0x00,0x00,0x00,0x00,0x00, //94/ --> ^
0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00, //95/ --> _
0x40,0x20,0x10,0x00,0x00,0x00,0x00,0x00, //96/ --> `
0x00,0x00,0x38,0x04,0x3C,0x44,0x3C,0x00, //97/ --> a
0x40,0x40,0x78,0x44,0x44,0x44,0x78,0x00, //98/ --> b
0x00,0x00,0x38,0x40,0x40,0x40,0x38,0x00, //99/ --> c
0x04,0x04,0x34,0x4C,0x44,0x44,0x3C,0x00, //100/ --> d
0x00,0x00,0x38,0x44,0x7C,0x40,0x38,0x00, //101/ --> e
0x18,0x24,0x20,0x20,0x70,0x20,0x20,0x00, //102/ --> f
0x00,0x3C,0x44,0x44,0x3C,0x04,0x38,0x00, //103/ --> g
0x40,0x40,0x58,0x64,0x44,0x44,0x44,0x00, //104/ --> h
0x10,0x00,0x30,0x10,0x10,0x10,0x38,0x00, //105/ --> i
0x08,0x00,0x08,0x08,0x08,0x48,0x30,0x00, //106/ --> j
0x40,0x40,0x48,0x50,0x60,0x50,0x48,0x00, //107/ --> k
0x30,0x10,0x10,0x10,0x10,0x10,0x38,0x00, //108/ --> l
0x00,0x00,0x68,0x54,0x54,0x44,0x44,0x00, //109/ --> m
0x00,0x00,0x58,0x64,0x44,0x44,0x44,0x00, //110/ --> n
0x00,0x00,0x38,0x44,0x44,0x44,0x38,0x00, //111/ --> o
0x00,0x00,0x78,0x44,0x78,0x40,0x40,0x00, //112/ --> p
0x00,0x00,0x34,0x4C,0x3C,0x04,0x04,0x00, //113/ --> q
0x00,0x00,0x58,0x64,0x40,0x40,0x40,0x00, //114/ --> r
0x00,0x00,0x38,0x40,0x38,0x04,0x78,0x00, //115/ --> s
0x20,0x20,0x70,0x20,0x20,0x24,0x18,0x00, //116/ --> t
0x00,0x00,0x44,0x44,0x44,0x4C,0x34,0x00, //117/ --> u
0x00,0x00,0x44,0x44,0x44,0x28,0x10,0x00, //118/ --> v
0x00,0x44,0x44,0x44,0x54,0x28,0x00,0x00, //119/ --> w
0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x00, //120/ --> x
0x00,0x44,0x44,0x3C,0x04,0x04,0x38,0x00, //121/ --> y
0x00,0x00,0x7C,0x08,0x10,0x20,0x7C,0x00, //122/ --> z
0x10,0x20,0x20,0x40,0x20,0x20,0x10,0x00, //123/ --> {
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00, //124/ --> |
0x40,0x20,0x20,0x10,0x20,0x20,0x40,0x00, //125/ --> }
0x00,0x10,0x08,0x7C,0x08,0x10,0x00,0x00, //126/ --> ~
0x00,0x10,0x20,0x7C,0x20,0x10,0x00,0x00, //127/ --> 
0x10,0x28,0x44,0x44,0x44,0x44,0x38,0x00, //128/ --> ?
};
	
static uint8_t iNumControllers;

void max7219_small_delay(uint8_t nop_num){
    for(int i= 0 ; i< nop_num ;i++){
		    __NOP();
		}
}

void max7219_SendByte(uint8_t *dataout, uint8_t len)
{
  char i,j;
  for(j=0; j<len ; j++){
      for (i=8; i>0; i--) {
        unsigned char mask = 1 << (i - 1);                    // calculate bitmask
        MAX7219_CLK_0();                                      // bring CLK low
				max7219_small_delay(1);
        if (dataout[j] & mask)                              // output one data bit
          MAX7219_DATA_1();                                   //  "1"
        else                                                  //  or
          MAX7219_DATA_0();                                   //  "0"
        MAX7219_CLK_1();                                      // bring CLK high
				max7219_small_delay(1);
	   }
  }
}	
	
	
//
// Transmit a sequence of N x 16 bits to the cascaded controllers
//
// Send an atomic sequence of uint8_ts for loading all chained controllers (16 bits per controller)
// Each controller acts like a 16-bit shift register and passes on the bits to the next controller. The
// last 16-bits to sit in the controller will be latched when the CS line goes high.
// uint8_t 0 -> D15-D8 (XXXX A3 A2 A1 A0), 4-bits unused and 4-bit register address
// uint8_t 1 -> D7-D0 (8-bit data)
//
void maxSendSequence(uint8_t *pSequence, uint8_t len)
{
  // The CS line stays low throughout a "transaction". Send all of the control uint8_ts for all of the chained
  // controllers in a single transaction. When the CS line rises, the data will be latched
   MAX7219_CS_0();
	 max7219_small_delay(1);
   max7219_SendByte(pSequence, len);
	 MAX7219_CS_1();   
	 max7219_small_delay(1);
} /* maxSendSequence() */


// Power on or off the LED controllers
//
void maxPowerUp(uint8_t bPowerUp)
{
uint8_t i;
uint8_t *d, bTemp[32]; // up to 16 controllers
  d = bTemp;
  for (i=0; i<iNumControllers; i++)
  {
     *d++ = 0x0C; // power up/down
     *d++ = bPowerUp;
  }
  maxSendSequence(bTemp, iNumControllers * 2); // send the power up/down instruction
} /* maxPowerUp() */
//
// Set the intensity (duty cycle of PWM signal) for the LED segments
// valid values are 0 (dimmest) to 15 (brightest)
//
void maxSetIntensity(uint8_t bIntensity)
{
uint8_t *d, bTemp[32];
uint8_t i;

  d = bTemp;
  for (i=0; i<iNumControllers; i++)
  {
      *d++ = 0x0A; // set intensity
      *d++ = bIntensity;
  } // for i
  maxSendSequence(bTemp, iNumControllers * 2);
} /* maxSetIntensity() */
//
// Set the segment decode mode (BCD or none)
//
void maxSetSegmentMode(uint8_t bMode)
{
uint8_t i, *d, bTemp[32];

  d = bTemp;
  for (i=0; i<iNumControllers; i++)
  {
      *d++ = 0x09; // decode mode
      *d++ = (bMode) ? 0xff : 0x00;
  } // for i
  maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
} /* maxSetSegmentMode() */

//
// Send image data to the array of controllers
// The image data is transmitted as N by 8 lines tall (N is the number of MAX7219 controllers)
// The pitch (uint8_ts per line) can be any value
//
void maxSendImage(uint8_t *pImage, int iPitch)
{
uint8_t i, j;
uint8_t *s, *d, bTemp[32];

   for (j=0; j<8; j++) // 8 rows to transmit
   {
      s = &pImage[iPitch * j];
      d = bTemp;
      for (i=0; i<iNumControllers; i++)
      {
         *d++ = (j+1); // row number is the "instruction"
         *d++ = *s++; // image data
      } // for each controller
      maxSendSequence(bTemp, iNumControllers * 2);
   } // for each row of image
} /* maxSendImage() */

//
// Enable (1) or disable (0) test mode
// This mode lights up every LED at max brightness
// It can sometimes power up in test mode
//
void maxSetTestMode(uint8_t bOn)
{
uint8_t i, *d, bTemp[32];

  d = bTemp;
  for (i=0; i<iNumControllers; i++)
  {
      *d++ = 0x0F; // test mode
      *d++ = bOn;
  } // for i
  maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
} /* maxSetTestMode() */
//
// Number of "digits/rows" to control
// valid values are 1-8 active digits/rows
//
void maxSetLimit(uint8_t bLimit)
{
uint8_t i, *d, bTemp[32];

  d = bTemp;
  for (i=0; i<iNumControllers; i++)
  {
      *d++ = 0x0B; // set scan limit
      *d++ = (bLimit - 1);
  } // for i
  maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
} /* maxSetLimit() */

//
// Send an ASCII string of numbers/spaces/decimal points
// to a 7-segment display
//
void maxSegmentString(char *pString)
{
unsigned char ucTemp[4];
int iDigit;

	memset(ucTemp, 0, sizeof(ucTemp));
	iDigit = 0;
	while (*pString && iDigit < 8)
	{
		ucTemp[0] = 8 - (iDigit & 7); // cmd byte to write
		if (pString[0] >= '0' && pString[0] <= '9')
		{
			ucTemp[1] = *pString++; // store digit
			if (pString[0] == '.')
			{
				ucTemp[1] |= 0x80; // turn on decimal point
				pString++;
			}
		}
		else
		{
			ucTemp[1] = 0xf; // space = all segments off
			pString++;
		}
		iDigit++;
		maxSendSequence(ucTemp, 2); // need to latch each byte pair
	}
	while (iDigit < 8) // blank out remaining digits
	{
		ucTemp[0] = 8 - (iDigit & 7);
		ucTemp[1] = 0xf; // all segments off
		iDigit++;
		maxSendSequence(ucTemp, 2);
	}
} /* maxSegmentString() */
//
// Draw a string of characters into the image buffer
// Normal characters are 8x8 and drawn on uint8_t boundaries
// Small characters are 6x8 and drawn on bit boundaries
//
void maxDrawString(char *pString, uint8_t *pImage, uint8_t iPitch, uint8_t bSmall)
{
static uint8_t b, bMask, i, j, *d, bCol;
const uint8_t *pFont;
const uint8_t *s;
static int iWidth;

   d = pImage;
   bCol = 0;
   if (bSmall)
   {
      pFont = ucFont;
      iWidth = 6;
   }
   else
   {
      pFont = ucFont;
      iWidth = 8;
   }
   while (*pString)
   {
      b = *pString++;
      s = &pFont[(int)b * iWidth]; // 6 or 8 uint8_ts per character in ASCII order
      for (i=0; i<iWidth; i++) // column
      {
         bMask = (0x80 >> (bCol & 7));
         b = *s++; // current font uint8_t
         for (j=0; j<8; j++) // bit number of source becomes destination row
         {
            if (b & 1) // start from LSB
               d[j*iPitch] |= bMask;
            else
               d[j*iPitch] &= ~bMask;
            b >>= 1; // shift down font uint8_t
         } // for j
         bCol++;
         if ((bCol & 7) == 0) // next uint8_t
            d++;
      } // for i
   } // while string
} /* maxDrawString() */

//
// Scroll a bitmap N bits left (positive) or right (negative)
// Valid scroll values are +1 to +7 and -1 to -7
// A bitmap is assumed to be iPitch uint8_ts wide by 8 rows tall
// Bits which scroll off one end are added back to the other end
//
void maxScrollBitmap(uint8_t *pBitmap, int iPitch, int iScroll)
{
uint8_t b, bEdge, *s;
int col, row;

  if (iScroll > 0) // scroll left
  {
     for (row=0; row<8; row++)
     {
        s = &pBitmap[row * iPitch];
        bEdge = s[0] >> (8-iScroll);
        for (col=0; col<iPitch; col++)
        {
           b = s[col] << iScroll;
           b |= (col == iPitch-1) ? bEdge : (s[col+1] >> (8-iScroll));
           s[col] = b;
        } // for col
     } // for row
  }
  else // scroll right
  {
     iScroll = 0 - iScroll; // make it a positive number
     for (row=0; row<8; row++)
     {
        s = &pBitmap[row * iPitch];
        bEdge = s[iPitch-1] << (8-iScroll);
        for (col=iPitch-1; col>=0; col--)
        {
           b = s[col] >> iScroll;
           b |= (col == 0) ? bEdge : (s[col-1] << (8-iScroll));
           s[col] = b;
        } // for col
     } // for row    
  }
} /* maxScrollBitmap() */
//
// Initialize the controllers
//
int maxInit(uint8_t iNum, uint8_t bDecodeMode)
{
  iNumControllers = iNum;
	
	MAX7219_CS_1();  
	
  maxPowerUp(1); // turn on the LED controllers
  maxSetLimit(8); // tell it to display 8 rows of 8 pixels
  maxSetIntensity(5); // set the minimum intensity to start (1/32 duty cycle)
  maxSetSegmentMode(bDecodeMode); // sets BCD (7-segment), or none (pixels
  maxSetTestMode(0); // disable test mode (it can accidentally get set at power up) 
  return 0;
} /* maxInit() */

void maxShutdown(void)
{
	
   maxPowerUp(0); // turn off the LED controllers
   //AIOCloseSPI(file_spi);
   //file_spi = -1;
   //AIOShutdown();
	
} /* maxShutdown() */


void MAX7219_All_Display(uint8_t data)
{
	uint8_t i,j, *d, bTemp[32];	
  for (j=0; j< 9; j++){
      d = bTemp;
      for (i=0; i<iNumControllers; i++)
      {
          *d++ = j;          // set REG. display
          *d++ = data;
      } // for i
      maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
	}
}

void MAX7219_Display_1(void)
{
	uint8_t i,j, *d, bTemp[32];	
  for (j=1; j< 9; j++){
      d = bTemp;
      for (i=0; i<iNumControllers; i++)
      {
          *d++ = j;          // set REG. display
          *d++ = ucFont[255+j+i*8];
      } // for i
      maxSendSequence(bTemp, iNumControllers * 2); // send the scan limit instructions to all controllers
	}
}
